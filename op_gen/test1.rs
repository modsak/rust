#![allow(dead_code)]
#![allow(non_camel_case_types)]
use super::graph::{Graph, GraphOperation, Operation, Edge};
use super::{Shape as OtherShape, new_id, TensorType, BFloat16, Tensor, AnyTensor, Result};
use num_complex::Complex as OtherComplex;
use std::rc::Rc;
use std::{f32, f64};
use std::marker::PhantomData;

impl GenerateBigQueryReaderPartitionsOp {
    pub fn new(inner: Rc<GenerateBigQueryReaderPartitions>) -> Self {
        Self{inner}
    }

    pub fn partitions(&self) -> Edge<String> {
        Edge::<String>::new(self.inner.clone(), 0)
    }
}

struct GenerateBigQueryReaderPartitionsOp {
    inner: Rc<GenerateBigQueryReaderPartitions>,
}

impl GraphOperation for GenerateBigQueryReaderPartitions {
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("GenerateBigQueryReaderPartitions_{}")?
        };
        let mut new_op = graph.new_operation("GenerateBigQueryReaderPartitions", &op_name)?;
        {
            (|attr| {new_op.set_attr_string("project_id", attr)})(&self.project_id)
        }
        {
            (|attr| {new_op.set_attr_string("dataset_id", attr)})(&self.dataset_id)
        }
        {
            (|attr| {new_op.set_attr_string("table_id", attr)})(&self.table_id)
        }
        {
            (|attrs| {new_op.set_attr_string_list("columns", attrs)})(&self.columns)
        }
        {
            (|attr| {new_op.set_attr_int("timestamp_millis", *attr)})(&self.timestamp_millis)
        }
        {
            (|attr| {new_op.set_attr_int("num_partitions", *attr)})(&self.num_partitions)
        }
        {
            match self.test_end_point {
            }
            None => new_op.set_attr_value_proto("test_end_point", &vec![18_u8, 0_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_string("test_end_point", attr)})(&value),
        };
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct GenerateBigQueryReaderPartitions {
    project_id: String,
    dataset_id: String,
    table_id: String,
    columns: Vec<String>,
    timestamp_millis: i64,
    num_partitions: i64,
    test_end_point: Option<String>,
    id_: usize,
}

impl GenerateBigQueryReaderPartitions {
    pub fn test_end_point(&mut self, test_end_point: &str) -> &mut Self {
        self.test_end_point = Some(test_end_point.to_string());
        &self
    }

    pub fn finish(self) -> GenerateBigQueryReaderPartitionsOp {
        GenerateBigQueryReaderPartitionsOp::new(Rc::new(self))
    }

    pub fn new(project_id: &str, dataset_id: &str, table_id: &str, columns: &[String], timestamp_millis: int, num_partitions: int) -> Self {
        Self {
            project_id: project_id.to_string()
            dataset_id: dataset_id.to_string()
            table_id: table_id.to_string()
            columns: columns.to_vec()
            timestamp_millis: timestamp_millis
            num_partitions: num_partitions
            test_end_point: None,
            id_: new_id(),
        }
    }
}

impl SkipgramOp {
    pub fn new(inner: Rc<Skipgram>) -> Self {
        Self{inner}
    }

    pub fn vocab_word(&self) -> Edge<String> {
        Edge::<String>::new(self.inner.clone(), 0)
    }

    pub fn vocab_freq(&self) -> Edge<i32> {
        Edge::<i32>::new(self.inner.clone(), 1)
    }

    pub fn words_per_epoch(&self) -> Edge<i64> {
        Edge::<i64>::new(self.inner.clone(), 2)
    }

    pub fn current_epoch(&self) -> Edge<i32> {
        Edge::<i32>::new(self.inner.clone(), 3)
    }

    pub fn total_words_processed(&self) -> Edge<i64> {
        Edge::<i64>::new(self.inner.clone(), 4)
    }

    pub fn examples(&self) -> Edge<i32> {
        Edge::<i32>::new(self.inner.clone(), 5)
    }

    pub fn labels(&self) -> Edge<i32> {
        Edge::<i32>::new(self.inner.clone(), 6)
    }
}

struct SkipgramOp {
    inner: Rc<Skipgram>,
}

impl GraphOperation for Skipgram {
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("Skipgram_{}")?
        };
        let mut new_op = graph.new_operation("Skipgram", &op_name)?;
        {
            (|attr| {new_op.set_attr_string("filename", attr)})(&self.filename)
        }
        {
            (|attr| {new_op.set_attr_int("batch_size", *attr)})(&self.batch_size)
        }
        {
            match self.window_size {
            }
            None => new_op.set_attr_value_proto("window_size", &vec![24_u8, 5_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_int("window_size", *attr)})(&value),
        };
        {
            match self.min_count {
            }
            None => new_op.set_attr_value_proto("min_count", &vec![24_u8, 5_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_int("min_count", *attr)})(&value),
        };
        {
            match self.subsample {
            }
            None => new_op.set_attr_value_proto("subsample", &vec![37_u8, 111_u8, 18_u8, 131_u8, 58_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_float("subsample", *attr)})(&value),
        };
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct Skipgram {
    filename: String,
    batch_size: i64,
    window_size: Option<i64>,
    min_count: Option<i64>,
    subsample: Option<f32>,
    id_: usize,
}

impl Skipgram {
    pub fn window_size(&mut self, window_size: int) -> &mut Self {
        self.window_size = Some(window_size);
        &self
    }

    pub fn min_count(&mut self, min_count: int) -> &mut Self {
        self.min_count = Some(min_count);
        &self
    }

    pub fn subsample(&mut self, subsample: f32) -> &mut Self {
        self.subsample = Some(subsample);
        &self
    }

    pub fn finish(self) -> SkipgramOp {
        SkipgramOp::new(Rc::new(self))
    }

    pub fn new(filename: &str, batch_size: int) -> Self {
        Self {
            filename: filename.to_string()
            batch_size: batch_size
            window_size: None,
            min_count: None,
            subsample: None,
            id_: new_id(),
        }
    }
}

pub trait con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64 for BFloat16 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64 for OtherComplex<f32> {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64 for OtherComplex<f64> {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64 for f32 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64 for f64 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64 for i16 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64 for i32 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64 for i64 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64 for i8 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64 for u16 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64 for u32 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64 for u64 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64 for u8 {
}

impl<T> ApplyPowerSignOp<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
{
    pub fn new(inner: Rc<ApplyPowerSign<T>>) -> Self {
        Self{inner}
    }

    pub fn out(&self) -> Edge<T> {
        Edge::<T>::new(self.inner.clone(), 0)
    }
}

struct ApplyPowerSignOp<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
{
    inner: Rc<ApplyPowerSign<T>>,
}

impl<T> GraphOperation for ApplyPowerSign<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("ApplyPowerSign_{}")?
        };
        let mut new_op = graph.new_operation("ApplyPowerSign", &op_name)?;
        {
            match self.use_locking {
            }
            None => new_op.set_attr_value_proto("use_locking", &vec![40_u8, 0_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_bool("use_locking", *attr)})(&value),
        };
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct ApplyPowerSign<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
{
    var: Edge<T>,
    m: Edge<T>,
    lr: Edge<T>,
    logbase: Edge<T>,
    sign_decay: Edge<T>,
    beta: Edge<T>,
    grad: Edge<T>,
    use_locking: Option<bool>,
    id_: usize,
}

impl<T> ApplyPowerSign<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
{
    pub fn use_locking(&mut self, use_locking: bool) -> &mut Self {
        self.use_locking = Some(use_locking);
        &self
    }

    pub fn finish(self) -> ApplyPowerSignOp<T> {
        ApplyPowerSignOp::new(Rc::new(self))
    }

    pub fn new(var: Edge<T>, m: Edge<T>, lr: Edge<T>, logbase: Edge<T>, sign_decay: Edge<T>, beta: Edge<T>, grad: Edge<T>) -> Self {
        Self {
            var,
            m,
            lr,
            logbase,
            sign_decay,
            beta,
            grad,
            use_locking: None,
            id_: new_id(),
        }
    }
}

impl<T> ApplyAddSignOp<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
{
    pub fn new(inner: Rc<ApplyAddSign<T>>) -> Self {
        Self{inner}
    }

    pub fn out(&self) -> Edge<T> {
        Edge::<T>::new(self.inner.clone(), 0)
    }
}

struct ApplyAddSignOp<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
{
    inner: Rc<ApplyAddSign<T>>,
}

impl<T> GraphOperation for ApplyAddSign<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("ApplyAddSign_{}")?
        };
        let mut new_op = graph.new_operation("ApplyAddSign", &op_name)?;
        {
            match self.use_locking {
            }
            None => new_op.set_attr_value_proto("use_locking", &vec![40_u8, 0_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_bool("use_locking", *attr)})(&value),
        };
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct ApplyAddSign<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
{
    var: Edge<T>,
    m: Edge<T>,
    lr: Edge<T>,
    alpha: Edge<T>,
    sign_decay: Edge<T>,
    beta: Edge<T>,
    grad: Edge<T>,
    use_locking: Option<bool>,
    id_: usize,
}

impl<T> ApplyAddSign<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
{
    pub fn use_locking(&mut self, use_locking: bool) -> &mut Self {
        self.use_locking = Some(use_locking);
        &self
    }

    pub fn finish(self) -> ApplyAddSignOp<T> {
        ApplyAddSignOp::new(Rc::new(self))
    }

    pub fn new(var: Edge<T>, m: Edge<T>, lr: Edge<T>, alpha: Edge<T>, sign_decay: Edge<T>, beta: Edge<T>, grad: Edge<T>) -> Self {
        Self {
            var,
            m,
            lr,
            alpha,
            sign_decay,
            beta,
            grad,
            use_locking: None,
            id_: new_id(),
        }
    }
}

pub trait con_or_DT_INT32_or_DT_INT64 {
}

impl con_or_DT_INT32_or_DT_INT64 for i32 {
}

impl con_or_DT_INT32_or_DT_INT64 for i64 {
}

impl<T, Tindices> SparseApplyRMSPropOp<T, Tindices>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      Tindices: con_or_DT_INT32_or_DT_INT64,
{
    pub fn new(inner: Rc<SparseApplyRMSProp<T, Tindices>>) -> Self {
        Self{inner}
    }

    pub fn out(&self) -> Edge<T> {
        Edge::<T>::new(self.inner.clone(), 0)
    }
}

struct SparseApplyRMSPropOp<T, Tindices>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      Tindices: con_or_DT_INT32_or_DT_INT64,
{
    inner: Rc<SparseApplyRMSProp<T, Tindices>>,
}

impl<T, Tindices> GraphOperation for SparseApplyRMSProp<T, Tindices>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      Tindices: con_or_DT_INT32_or_DT_INT64,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("SparseApplyRMSProp_{}")?
        };
        let mut new_op = graph.new_operation("SparseApplyRMSProp", &op_name)?;
        {
            match self.use_locking {
            }
            None => new_op.set_attr_value_proto("use_locking", &vec![40_u8, 0_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_bool("use_locking", *attr)})(&value),
        };
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct SparseApplyRMSProp<T, Tindices>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      Tindices: con_or_DT_INT32_or_DT_INT64,
{
    var: Edge<T>,
    ms: Edge<T>,
    mom: Edge<T>,
    lr: Edge<T>,
    rho: Edge<T>,
    momentum: Edge<T>,
    epsilon: Edge<T>,
    grad: Edge<T>,
    indices: Edge<Tindices>,
    use_locking: Option<bool>,
    id_: usize,
}

impl<T, Tindices> SparseApplyRMSProp<T, Tindices>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      Tindices: con_or_DT_INT32_or_DT_INT64,
{
    pub fn use_locking(&mut self, use_locking: bool) -> &mut Self {
        self.use_locking = Some(use_locking);
        &self
    }

    pub fn finish(self) -> SparseApplyRMSPropOp<T, Tindices> {
        SparseApplyRMSPropOp::new(Rc::new(self))
    }

    pub fn new(var: Edge<T>, ms: Edge<T>, mom: Edge<T>, lr: Edge<T>, rho: Edge<T>, momentum: Edge<T>, epsilon: Edge<T>, grad: Edge<T>, indices: Edge<Tindices>) -> Self {
        Self {
            var,
            ms,
            mom,
            lr,
            rho,
            momentum,
            epsilon,
            grad,
            indices,
            use_locking: None,
            id_: new_id(),
        }
    }
}

impl<T> ApplyCenteredRMSPropOp<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
{
    pub fn new(inner: Rc<ApplyCenteredRMSProp<T>>) -> Self {
        Self{inner}
    }

    pub fn out(&self) -> Edge<T> {
        Edge::<T>::new(self.inner.clone(), 0)
    }
}

struct ApplyCenteredRMSPropOp<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
{
    inner: Rc<ApplyCenteredRMSProp<T>>,
}

impl<T> GraphOperation for ApplyCenteredRMSProp<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("ApplyCenteredRMSProp_{}")?
        };
        let mut new_op = graph.new_operation("ApplyCenteredRMSProp", &op_name)?;
        {
            match self.use_locking {
            }
            None => new_op.set_attr_value_proto("use_locking", &vec![40_u8, 0_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_bool("use_locking", *attr)})(&value),
        };
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct ApplyCenteredRMSProp<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
{
    var: Edge<T>,
    mg: Edge<T>,
    ms: Edge<T>,
    mom: Edge<T>,
    lr: Edge<T>,
    rho: Edge<T>,
    momentum: Edge<T>,
    epsilon: Edge<T>,
    grad: Edge<T>,
    use_locking: Option<bool>,
    id_: usize,
}

impl<T> ApplyCenteredRMSProp<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
{
    pub fn use_locking(&mut self, use_locking: bool) -> &mut Self {
        self.use_locking = Some(use_locking);
        &self
    }

    pub fn finish(self) -> ApplyCenteredRMSPropOp<T> {
        ApplyCenteredRMSPropOp::new(Rc::new(self))
    }

    pub fn new(var: Edge<T>, mg: Edge<T>, ms: Edge<T>, mom: Edge<T>, lr: Edge<T>, rho: Edge<T>, momentum: Edge<T>, epsilon: Edge<T>, grad: Edge<T>) -> Self {
        Self {
            var,
            mg,
            ms,
            mom,
            lr,
            rho,
            momentum,
            epsilon,
            grad,
            use_locking: None,
            id_: new_id(),
        }
    }
}

impl<T, Tindices> SparseApplyMomentumOp<T, Tindices>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      Tindices: con_or_DT_INT32_or_DT_INT64,
{
    pub fn new(inner: Rc<SparseApplyMomentum<T, Tindices>>) -> Self {
        Self{inner}
    }

    pub fn out(&self) -> Edge<T> {
        Edge::<T>::new(self.inner.clone(), 0)
    }
}

struct SparseApplyMomentumOp<T, Tindices>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      Tindices: con_or_DT_INT32_or_DT_INT64,
{
    inner: Rc<SparseApplyMomentum<T, Tindices>>,
}

impl<T, Tindices> GraphOperation for SparseApplyMomentum<T, Tindices>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      Tindices: con_or_DT_INT32_or_DT_INT64,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("SparseApplyMomentum_{}")?
        };
        let mut new_op = graph.new_operation("SparseApplyMomentum", &op_name)?;
        {
            match self.use_locking {
            }
            None => new_op.set_attr_value_proto("use_locking", &vec![40_u8, 0_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_bool("use_locking", *attr)})(&value),
        };
        {
            match self.use_nesterov {
            }
            None => new_op.set_attr_value_proto("use_nesterov", &vec![40_u8, 0_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_bool("use_nesterov", *attr)})(&value),
        };
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct SparseApplyMomentum<T, Tindices>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      Tindices: con_or_DT_INT32_or_DT_INT64,
{
    var: Edge<T>,
    accum: Edge<T>,
    lr: Edge<T>,
    grad: Edge<T>,
    indices: Edge<Tindices>,
    momentum: Edge<T>,
    use_locking: Option<bool>,
    use_nesterov: Option<bool>,
    id_: usize,
}

impl<T, Tindices> SparseApplyMomentum<T, Tindices>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      Tindices: con_or_DT_INT32_or_DT_INT64,
{
    pub fn use_locking(&mut self, use_locking: bool) -> &mut Self {
        self.use_locking = Some(use_locking);
        &self
    }

    pub fn use_nesterov(&mut self, use_nesterov: bool) -> &mut Self {
        self.use_nesterov = Some(use_nesterov);
        &self
    }

    pub fn finish(self) -> SparseApplyMomentumOp<T, Tindices> {
        SparseApplyMomentumOp::new(Rc::new(self))
    }

    pub fn new(var: Edge<T>, accum: Edge<T>, lr: Edge<T>, grad: Edge<T>, indices: Edge<Tindices>, momentum: Edge<T>) -> Self {
        Self {
            var,
            accum,
            lr,
            grad,
            indices,
            momentum,
            use_locking: None,
            use_nesterov: None,
            id_: new_id(),
        }
    }
}

impl<T, Tindices> SparseApplyFtrlV2Op<T, Tindices>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      Tindices: con_or_DT_INT32_or_DT_INT64,
{
    pub fn new(inner: Rc<SparseApplyFtrlV2<T, Tindices>>) -> Self {
        Self{inner}
    }

    pub fn out(&self) -> Edge<T> {
        Edge::<T>::new(self.inner.clone(), 0)
    }
}

struct SparseApplyFtrlV2Op<T, Tindices>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      Tindices: con_or_DT_INT32_or_DT_INT64,
{
    inner: Rc<SparseApplyFtrlV2<T, Tindices>>,
}

impl<T, Tindices> GraphOperation for SparseApplyFtrlV2<T, Tindices>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      Tindices: con_or_DT_INT32_or_DT_INT64,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("SparseApplyFtrlV2_{}")?
        };
        let mut new_op = graph.new_operation("SparseApplyFtrlV2", &op_name)?;
        {
            match self.use_locking {
            }
            None => new_op.set_attr_value_proto("use_locking", &vec![40_u8, 0_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_bool("use_locking", *attr)})(&value),
        };
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct SparseApplyFtrlV2<T, Tindices>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      Tindices: con_or_DT_INT32_or_DT_INT64,
{
    var: Edge<T>,
    accum: Edge<T>,
    linear: Edge<T>,
    grad: Edge<T>,
    indices: Edge<Tindices>,
    lr: Edge<T>,
    l1: Edge<T>,
    l2: Edge<T>,
    l2_shrinkage: Edge<T>,
    lr_power: Edge<T>,
    use_locking: Option<bool>,
    id_: usize,
}

impl<T, Tindices> SparseApplyFtrlV2<T, Tindices>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      Tindices: con_or_DT_INT32_or_DT_INT64,
{
    pub fn use_locking(&mut self, use_locking: bool) -> &mut Self {
        self.use_locking = Some(use_locking);
        &self
    }

    pub fn finish(self) -> SparseApplyFtrlV2Op<T, Tindices> {
        SparseApplyFtrlV2Op::new(Rc::new(self))
    }

    pub fn new(var: Edge<T>, accum: Edge<T>, linear: Edge<T>, grad: Edge<T>, indices: Edge<Tindices>, lr: Edge<T>, l1: Edge<T>, l2: Edge<T>, l2_shrinkage: Edge<T>, lr_power: Edge<T>) -> Self {
        Self {
            var,
            accum,
            linear,
            grad,
            indices,
            lr,
            l1,
            l2,
            l2_shrinkage,
            lr_power,
            use_locking: None,
            id_: new_id(),
        }
    }
}

impl<T> ApplyFtrlV2Op<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
{
    pub fn new(inner: Rc<ApplyFtrlV2<T>>) -> Self {
        Self{inner}
    }

    pub fn out(&self) -> Edge<T> {
        Edge::<T>::new(self.inner.clone(), 0)
    }
}

struct ApplyFtrlV2Op<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
{
    inner: Rc<ApplyFtrlV2<T>>,
}

impl<T> GraphOperation for ApplyFtrlV2<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("ApplyFtrlV2_{}")?
        };
        let mut new_op = graph.new_operation("ApplyFtrlV2", &op_name)?;
        {
            match self.use_locking {
            }
            None => new_op.set_attr_value_proto("use_locking", &vec![40_u8, 0_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_bool("use_locking", *attr)})(&value),
        };
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct ApplyFtrlV2<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
{
    var: Edge<T>,
    accum: Edge<T>,
    linear: Edge<T>,
    grad: Edge<T>,
    lr: Edge<T>,
    l1: Edge<T>,
    l2: Edge<T>,
    l2_shrinkage: Edge<T>,
    lr_power: Edge<T>,
    use_locking: Option<bool>,
    id_: usize,
}

impl<T> ApplyFtrlV2<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
{
    pub fn use_locking(&mut self, use_locking: bool) -> &mut Self {
        self.use_locking = Some(use_locking);
        &self
    }

    pub fn finish(self) -> ApplyFtrlV2Op<T> {
        ApplyFtrlV2Op::new(Rc::new(self))
    }

    pub fn new(var: Edge<T>, accum: Edge<T>, linear: Edge<T>, grad: Edge<T>, lr: Edge<T>, l1: Edge<T>, l2: Edge<T>, l2_shrinkage: Edge<T>, lr_power: Edge<T>) -> Self {
        Self {
            var,
            accum,
            linear,
            grad,
            lr,
            l1,
            l2,
            l2_shrinkage,
            lr_power,
            use_locking: None,
            id_: new_id(),
        }
    }
}

impl<T, Tindices> SparseApplyAdagradOp<T, Tindices>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      Tindices: con_or_DT_INT32_or_DT_INT64,
{
    pub fn new(inner: Rc<SparseApplyAdagrad<T, Tindices>>) -> Self {
        Self{inner}
    }

    pub fn out(&self) -> Edge<T> {
        Edge::<T>::new(self.inner.clone(), 0)
    }
}

struct SparseApplyAdagradOp<T, Tindices>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      Tindices: con_or_DT_INT32_or_DT_INT64,
{
    inner: Rc<SparseApplyAdagrad<T, Tindices>>,
}

impl<T, Tindices> GraphOperation for SparseApplyAdagrad<T, Tindices>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      Tindices: con_or_DT_INT32_or_DT_INT64,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("SparseApplyAdagrad_{}")?
        };
        let mut new_op = graph.new_operation("SparseApplyAdagrad", &op_name)?;
        {
            match self.use_locking {
            }
            None => new_op.set_attr_value_proto("use_locking", &vec![40_u8, 0_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_bool("use_locking", *attr)})(&value),
        };
        {
            match self.update_slots {
            }
            None => new_op.set_attr_value_proto("update_slots", &vec![40_u8, 1_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_bool("update_slots", *attr)})(&value),
        };
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct SparseApplyAdagrad<T, Tindices>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      Tindices: con_or_DT_INT32_or_DT_INT64,
{
    var: Edge<T>,
    accum: Edge<T>,
    lr: Edge<T>,
    grad: Edge<T>,
    indices: Edge<Tindices>,
    use_locking: Option<bool>,
    update_slots: Option<bool>,
    id_: usize,
}

impl<T, Tindices> SparseApplyAdagrad<T, Tindices>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      Tindices: con_or_DT_INT32_or_DT_INT64,
{
    pub fn use_locking(&mut self, use_locking: bool) -> &mut Self {
        self.use_locking = Some(use_locking);
        &self
    }

    pub fn update_slots(&mut self, update_slots: bool) -> &mut Self {
        self.update_slots = Some(update_slots);
        &self
    }

    pub fn finish(self) -> SparseApplyAdagradOp<T, Tindices> {
        SparseApplyAdagradOp::new(Rc::new(self))
    }

    pub fn new(var: Edge<T>, accum: Edge<T>, lr: Edge<T>, grad: Edge<T>, indices: Edge<Tindices>) -> Self {
        Self {
            var,
            accum,
            lr,
            grad,
            indices,
            use_locking: None,
            update_slots: None,
            id_: new_id(),
        }
    }
}

impl<T, Tindices> SparseApplyAdadeltaOp<T, Tindices>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      Tindices: con_or_DT_INT32_or_DT_INT64,
{
    pub fn new(inner: Rc<SparseApplyAdadelta<T, Tindices>>) -> Self {
        Self{inner}
    }

    pub fn out(&self) -> Edge<T> {
        Edge::<T>::new(self.inner.clone(), 0)
    }
}

struct SparseApplyAdadeltaOp<T, Tindices>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      Tindices: con_or_DT_INT32_or_DT_INT64,
{
    inner: Rc<SparseApplyAdadelta<T, Tindices>>,
}

impl<T, Tindices> GraphOperation for SparseApplyAdadelta<T, Tindices>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      Tindices: con_or_DT_INT32_or_DT_INT64,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("SparseApplyAdadelta_{}")?
        };
        let mut new_op = graph.new_operation("SparseApplyAdadelta", &op_name)?;
        {
            match self.use_locking {
            }
            None => new_op.set_attr_value_proto("use_locking", &vec![40_u8, 0_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_bool("use_locking", *attr)})(&value),
        };
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct SparseApplyAdadelta<T, Tindices>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      Tindices: con_or_DT_INT32_or_DT_INT64,
{
    var: Edge<T>,
    accum: Edge<T>,
    accum_update: Edge<T>,
    lr: Edge<T>,
    rho: Edge<T>,
    epsilon: Edge<T>,
    grad: Edge<T>,
    indices: Edge<Tindices>,
    use_locking: Option<bool>,
    id_: usize,
}

impl<T, Tindices> SparseApplyAdadelta<T, Tindices>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      Tindices: con_or_DT_INT32_or_DT_INT64,
{
    pub fn use_locking(&mut self, use_locking: bool) -> &mut Self {
        self.use_locking = Some(use_locking);
        &self
    }

    pub fn finish(self) -> SparseApplyAdadeltaOp<T, Tindices> {
        SparseApplyAdadeltaOp::new(Rc::new(self))
    }

    pub fn new(var: Edge<T>, accum: Edge<T>, accum_update: Edge<T>, lr: Edge<T>, rho: Edge<T>, epsilon: Edge<T>, grad: Edge<T>, indices: Edge<Tindices>) -> Self {
        Self {
            var,
            accum,
            accum_update,
            lr,
            rho,
            epsilon,
            grad,
            indices,
            use_locking: None,
            id_: new_id(),
        }
    }
}

impl<T> ApplyAdadeltaOp<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
{
    pub fn new(inner: Rc<ApplyAdadelta<T>>) -> Self {
        Self{inner}
    }

    pub fn out(&self) -> Edge<T> {
        Edge::<T>::new(self.inner.clone(), 0)
    }
}

struct ApplyAdadeltaOp<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
{
    inner: Rc<ApplyAdadelta<T>>,
}

impl<T> GraphOperation for ApplyAdadelta<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("ApplyAdadelta_{}")?
        };
        let mut new_op = graph.new_operation("ApplyAdadelta", &op_name)?;
        {
            match self.use_locking {
            }
            None => new_op.set_attr_value_proto("use_locking", &vec![40_u8, 0_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_bool("use_locking", *attr)})(&value),
        };
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct ApplyAdadelta<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
{
    var: Edge<T>,
    accum: Edge<T>,
    accum_update: Edge<T>,
    lr: Edge<T>,
    rho: Edge<T>,
    epsilon: Edge<T>,
    grad: Edge<T>,
    use_locking: Option<bool>,
    id_: usize,
}

impl<T> ApplyAdadelta<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
{
    pub fn use_locking(&mut self, use_locking: bool) -> &mut Self {
        self.use_locking = Some(use_locking);
        &self
    }

    pub fn finish(self) -> ApplyAdadeltaOp<T> {
        ApplyAdadeltaOp::new(Rc::new(self))
    }

    pub fn new(var: Edge<T>, accum: Edge<T>, accum_update: Edge<T>, lr: Edge<T>, rho: Edge<T>, epsilon: Edge<T>, grad: Edge<T>) -> Self {
        Self {
            var,
            accum,
            accum_update,
            lr,
            rho,
            epsilon,
            grad,
            use_locking: None,
            id_: new_id(),
        }
    }
}

impl<T, Tindices> SparseApplyFtrlOp<T, Tindices>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      Tindices: con_or_DT_INT32_or_DT_INT64,
{
    pub fn new(inner: Rc<SparseApplyFtrl<T, Tindices>>) -> Self {
        Self{inner}
    }

    pub fn out(&self) -> Edge<T> {
        Edge::<T>::new(self.inner.clone(), 0)
    }
}

struct SparseApplyFtrlOp<T, Tindices>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      Tindices: con_or_DT_INT32_or_DT_INT64,
{
    inner: Rc<SparseApplyFtrl<T, Tindices>>,
}

impl<T, Tindices> GraphOperation for SparseApplyFtrl<T, Tindices>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      Tindices: con_or_DT_INT32_or_DT_INT64,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("SparseApplyFtrl_{}")?
        };
        let mut new_op = graph.new_operation("SparseApplyFtrl", &op_name)?;
        {
            match self.use_locking {
            }
            None => new_op.set_attr_value_proto("use_locking", &vec![40_u8, 0_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_bool("use_locking", *attr)})(&value),
        };
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct SparseApplyFtrl<T, Tindices>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      Tindices: con_or_DT_INT32_or_DT_INT64,
{
    var: Edge<T>,
    accum: Edge<T>,
    linear: Edge<T>,
    grad: Edge<T>,
    indices: Edge<Tindices>,
    lr: Edge<T>,
    l1: Edge<T>,
    l2: Edge<T>,
    lr_power: Edge<T>,
    use_locking: Option<bool>,
    id_: usize,
}

impl<T, Tindices> SparseApplyFtrl<T, Tindices>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      Tindices: con_or_DT_INT32_or_DT_INT64,
{
    pub fn use_locking(&mut self, use_locking: bool) -> &mut Self {
        self.use_locking = Some(use_locking);
        &self
    }

    pub fn finish(self) -> SparseApplyFtrlOp<T, Tindices> {
        SparseApplyFtrlOp::new(Rc::new(self))
    }

    pub fn new(var: Edge<T>, accum: Edge<T>, linear: Edge<T>, grad: Edge<T>, indices: Edge<Tindices>, lr: Edge<T>, l1: Edge<T>, l2: Edge<T>, lr_power: Edge<T>) -> Self {
        Self {
            var,
            accum,
            linear,
            grad,
            indices,
            lr,
            l1,
            l2,
            lr_power,
            use_locking: None,
            id_: new_id(),
        }
    }
}

impl UnicodeDecodeWithOffsetsOp {
    pub fn new(inner: Rc<UnicodeDecodeWithOffsets>) -> Self {
        Self{inner}
    }

    pub fn row_splits(&self) -> Edge<i64> {
        Edge::<i64>::new(self.inner.clone(), 0)
    }

    pub fn char_values(&self) -> Edge<i32> {
        Edge::<i32>::new(self.inner.clone(), 1)
    }

    pub fn char_to_byte_starts(&self) -> Edge<i64> {
        Edge::<i64>::new(self.inner.clone(), 2)
    }
}

struct UnicodeDecodeWithOffsetsOp {
    inner: Rc<UnicodeDecodeWithOffsets>,
}

impl GraphOperation for UnicodeDecodeWithOffsets {
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("UnicodeDecodeWithOffsets_{}")?
        };
        let mut new_op = graph.new_operation("UnicodeDecodeWithOffsets", &op_name)?;
        {
            (|attr| {new_op.set_attr_string("input_encoding", attr)})(&self.input_encoding)
        }
        {
            match self.errors {
            }
            None => new_op.set_attr_value_proto("errors", &vec![18_u8, 7_u8, 114_u8, 101_u8, 112_u8, 108_u8, 97_u8, 99_u8, 101_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_string("errors", attr)})(&value),
        };
        {
            match self.replacement_char {
            }
            None => new_op.set_attr_value_proto("replacement_char", &vec![24_u8, 253_u8, 255_u8, 3_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_int("replacement_char", *attr)})(&value),
        };
        {
            match self.replace_control_characters {
            }
            None => new_op.set_attr_value_proto("replace_control_characters", &vec![40_u8, 0_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_bool("replace_control_characters", *attr)})(&value),
        };
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct UnicodeDecodeWithOffsets {
    input: Edge<String>,
    input_encoding: String,
    errors: Option<String>,
    replacement_char: Option<i64>,
    replace_control_characters: Option<bool>,
    id_: usize,
}

impl UnicodeDecodeWithOffsets {
    pub fn errors(&mut self, errors: &str) -> &mut Self {
        self.errors = Some(errors.to_string());
        &self
    }

    pub fn replacement_char(&mut self, replacement_char: int) -> &mut Self {
        self.replacement_char = Some(replacement_char);
        &self
    }

    pub fn replace_control_characters(&mut self, replace_control_characters: bool) -> &mut Self {
        self.replace_control_characters = Some(replace_control_characters);
        &self
    }

    pub fn finish(self) -> UnicodeDecodeWithOffsetsOp {
        UnicodeDecodeWithOffsetsOp::new(Rc::new(self))
    }

    pub fn new(input: Edge<String>, input_encoding: &str) -> Self {
        Self {
            input,
            input_encoding: input_encoding.to_string()
            errors: None,
            replacement_char: None,
            replace_control_characters: None,
            id_: new_id(),
        }
    }
}

impl UnicodeDecodeOp {
    pub fn new(inner: Rc<UnicodeDecode>) -> Self {
        Self{inner}
    }

    pub fn row_splits(&self) -> Edge<i64> {
        Edge::<i64>::new(self.inner.clone(), 0)
    }

    pub fn char_values(&self) -> Edge<i32> {
        Edge::<i32>::new(self.inner.clone(), 1)
    }
}

struct UnicodeDecodeOp {
    inner: Rc<UnicodeDecode>,
}

impl GraphOperation for UnicodeDecode {
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("UnicodeDecode_{}")?
        };
        let mut new_op = graph.new_operation("UnicodeDecode", &op_name)?;
        {
            (|attr| {new_op.set_attr_string("input_encoding", attr)})(&self.input_encoding)
        }
        {
            match self.errors {
            }
            None => new_op.set_attr_value_proto("errors", &vec![18_u8, 7_u8, 114_u8, 101_u8, 112_u8, 108_u8, 97_u8, 99_u8, 101_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_string("errors", attr)})(&value),
        };
        {
            match self.replacement_char {
            }
            None => new_op.set_attr_value_proto("replacement_char", &vec![24_u8, 253_u8, 255_u8, 3_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_int("replacement_char", *attr)})(&value),
        };
        {
            match self.replace_control_characters {
            }
            None => new_op.set_attr_value_proto("replace_control_characters", &vec![40_u8, 0_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_bool("replace_control_characters", *attr)})(&value),
        };
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct UnicodeDecode {
    input: Edge<String>,
    input_encoding: String,
    errors: Option<String>,
    replacement_char: Option<i64>,
    replace_control_characters: Option<bool>,
    id_: usize,
}

impl UnicodeDecode {
    pub fn errors(&mut self, errors: &str) -> &mut Self {
        self.errors = Some(errors.to_string());
        &self
    }

    pub fn replacement_char(&mut self, replacement_char: int) -> &mut Self {
        self.replacement_char = Some(replacement_char);
        &self
    }

    pub fn replace_control_characters(&mut self, replace_control_characters: bool) -> &mut Self {
        self.replace_control_characters = Some(replace_control_characters);
        &self
    }

    pub fn finish(self) -> UnicodeDecodeOp {
        UnicodeDecodeOp::new(Rc::new(self))
    }

    pub fn new(input: Edge<String>, input_encoding: &str) -> Self {
        Self {
            input,
            input_encoding: input_encoding.to_string()
            errors: None,
            replacement_char: None,
            replace_control_characters: None,
            id_: new_id(),
        }
    }
}

impl UnicodeScriptOp {
    pub fn new(inner: Rc<UnicodeScript>) -> Self {
        Self{inner}
    }

    pub fn output(&self) -> Edge<i32> {
        Edge::<i32>::new(self.inner.clone(), 0)
    }
}

struct UnicodeScriptOp {
    inner: Rc<UnicodeScript>,
}

impl GraphOperation for UnicodeScript {
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("UnicodeScript_{}")?
        };
        let mut new_op = graph.new_operation("UnicodeScript", &op_name)?;
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct UnicodeScript {
    input: Edge<i32>,
    id_: usize,
}

impl UnicodeScript {
    pub fn finish(self) -> UnicodeScriptOp {
        UnicodeScriptOp::new(Rc::new(self))
    }

    pub fn new(input: Edge<i32>) -> Self {
        Self {
            input,
            id_: new_id(),
        }
    }
}

impl<T> SubstrOp<T>
where T: con_or_DT_INT32_or_DT_INT64,
{
    pub fn new(inner: Rc<Substr<T>>) -> Self {
        Self{inner}
    }

    pub fn output(&self) -> Edge<String> {
        Edge::<String>::new(self.inner.clone(), 0)
    }
}

struct SubstrOp<T>
where T: con_or_DT_INT32_or_DT_INT64,
{
    inner: Rc<Substr<T>>,
}

impl<T> GraphOperation for Substr<T>
where T: con_or_DT_INT32_or_DT_INT64,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("Substr_{}")?
        };
        let mut new_op = graph.new_operation("Substr", &op_name)?;
        {
            match self.unit {
            }
            None => new_op.set_attr_value_proto("unit", &vec![18_u8, 4_u8, 66_u8, 89_u8, 84_u8, 69_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_string("unit", attr)})(&value),
        };
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct Substr<T>
where T: con_or_DT_INT32_or_DT_INT64,
{
    input: Edge<String>,
    pos: Edge<T>,
    len: Edge<T>,
    unit: Option<String>,
    id_: usize,
}

impl<T> Substr<T>
where T: con_or_DT_INT32_or_DT_INT64,
{
    pub fn unit(&mut self, unit: &str) -> &mut Self {
        self.unit = Some(unit.to_string());
        &self
    }

    pub fn finish(self) -> SubstrOp<T> {
        SubstrOp::new(Rc::new(self))
    }

    pub fn new(input: Edge<String>, pos: Edge<T>, len: Edge<T>) -> Self {
        Self {
            input,
            pos,
            len,
            unit: None,
            id_: new_id(),
        }
    }
}

impl StringStripOp {
    pub fn new(inner: Rc<StringStrip>) -> Self {
        Self{inner}
    }

    pub fn output(&self) -> Edge<String> {
        Edge::<String>::new(self.inner.clone(), 0)
    }
}

struct StringStripOp {
    inner: Rc<StringStrip>,
}

impl GraphOperation for StringStrip {
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("StringStrip_{}")?
        };
        let mut new_op = graph.new_operation("StringStrip", &op_name)?;
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct StringStrip {
    input: Edge<String>,
    id_: usize,
}

impl StringStrip {
    pub fn finish(self) -> StringStripOp {
        StringStripOp::new(Rc::new(self))
    }

    pub fn new(input: Edge<String>) -> Self {
        Self {
            input,
            id_: new_id(),
        }
    }
}

impl StringSplitOp {
    pub fn new(inner: Rc<StringSplit>) -> Self {
        Self{inner}
    }

    pub fn indices(&self) -> Edge<i64> {
        Edge::<i64>::new(self.inner.clone(), 0)
    }

    pub fn values(&self) -> Edge<String> {
        Edge::<String>::new(self.inner.clone(), 1)
    }

    pub fn shape(&self) -> Edge<i64> {
        Edge::<i64>::new(self.inner.clone(), 2)
    }
}

struct StringSplitOp {
    inner: Rc<StringSplit>,
}

impl GraphOperation for StringSplit {
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("StringSplit_{}")?
        };
        let mut new_op = graph.new_operation("StringSplit", &op_name)?;
        {
            match self.skip_empty {
            }
            None => new_op.set_attr_value_proto("skip_empty", &vec![40_u8, 1_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_bool("skip_empty", *attr)})(&value),
        };
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct StringSplit {
    input: Edge<String>,
    delimiter: Edge<String>,
    skip_empty: Option<bool>,
    id_: usize,
}

impl StringSplit {
    pub fn skip_empty(&mut self, skip_empty: bool) -> &mut Self {
        self.skip_empty = Some(skip_empty);
        &self
    }

    pub fn finish(self) -> StringSplitOp {
        StringSplitOp::new(Rc::new(self))
    }

    pub fn new(input: Edge<String>, delimiter: Edge<String>) -> Self {
        Self {
            input,
            delimiter,
            skip_empty: None,
            id_: new_id(),
        }
    }
}

impl StringToHashBucketOp {
    pub fn new(inner: Rc<StringToHashBucket>) -> Self {
        Self{inner}
    }

    pub fn output(&self) -> Edge<i64> {
        Edge::<i64>::new(self.inner.clone(), 0)
    }
}

struct StringToHashBucketOp {
    inner: Rc<StringToHashBucket>,
}

impl GraphOperation for StringToHashBucket {
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("StringToHashBucket_{}")?
        };
        let mut new_op = graph.new_operation("StringToHashBucket", &op_name)?;
        {
            (|attr| {new_op.set_attr_int("num_buckets", *attr)})(&self.num_buckets)
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct StringToHashBucket {
    string_tensor: Edge<String>,
    num_buckets: i64,
    id_: usize,
}

impl StringToHashBucket {
    pub fn finish(self) -> StringToHashBucketOp {
        StringToHashBucketOp::new(Rc::new(self))
    }

    pub fn new(string_tensor: Edge<String>, num_buckets: int) -> Self {
        Self {
            string_tensor,
            num_buckets: num_buckets
            id_: new_id(),
        }
    }
}

impl StringLengthOp {
    pub fn new(inner: Rc<StringLength>) -> Self {
        Self{inner}
    }

    pub fn output(&self) -> Edge<i32> {
        Edge::<i32>::new(self.inner.clone(), 0)
    }
}

struct StringLengthOp {
    inner: Rc<StringLength>,
}

impl GraphOperation for StringLength {
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("StringLength_{}")?
        };
        let mut new_op = graph.new_operation("StringLength", &op_name)?;
        {
            match self.unit {
            }
            None => new_op.set_attr_value_proto("unit", &vec![18_u8, 4_u8, 66_u8, 89_u8, 84_u8, 69_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_string("unit", attr)})(&value),
        };
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct StringLength {
    input: Edge<String>,
    unit: Option<String>,
    id_: usize,
}

impl StringLength {
    pub fn unit(&mut self, unit: &str) -> &mut Self {
        self.unit = Some(unit.to_string());
        &self
    }

    pub fn finish(self) -> StringLengthOp {
        StringLengthOp::new(Rc::new(self))
    }

    pub fn new(input: Edge<String>) -> Self {
        Self {
            input,
            unit: None,
            id_: new_id(),
        }
    }
}

impl StringToHashBucketStrongOp {
    pub fn new(inner: Rc<StringToHashBucketStrong>) -> Self {
        Self{inner}
    }

    pub fn output(&self) -> Edge<i64> {
        Edge::<i64>::new(self.inner.clone(), 0)
    }
}

struct StringToHashBucketStrongOp {
    inner: Rc<StringToHashBucketStrong>,
}

impl GraphOperation for StringToHashBucketStrong {
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("StringToHashBucketStrong_{}")?
        };
        let mut new_op = graph.new_operation("StringToHashBucketStrong", &op_name)?;
        {
            (|attr| {new_op.set_attr_int("num_buckets", *attr)})(&self.num_buckets)
        }
        {
            (|attrs| {new_op.set_attr_int_list("key", attrs)})(&self.key)
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct StringToHashBucketStrong {
    input: Edge<String>,
    num_buckets: i64,
    key: Vec<i64>,
    id_: usize,
}

impl StringToHashBucketStrong {
    pub fn finish(self) -> StringToHashBucketStrongOp {
        StringToHashBucketStrongOp::new(Rc::new(self))
    }

    pub fn new(input: Edge<String>, num_buckets: int, key: &[int]) -> Self {
        Self {
            input,
            num_buckets: num_buckets
            key: key.to_vec()
            id_: new_id(),
        }
    }
}

impl StringToHashBucketFastOp {
    pub fn new(inner: Rc<StringToHashBucketFast>) -> Self {
        Self{inner}
    }

    pub fn output(&self) -> Edge<i64> {
        Edge::<i64>::new(self.inner.clone(), 0)
    }
}

struct StringToHashBucketFastOp {
    inner: Rc<StringToHashBucketFast>,
}

impl GraphOperation for StringToHashBucketFast {
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("StringToHashBucketFast_{}")?
        };
        let mut new_op = graph.new_operation("StringToHashBucketFast", &op_name)?;
        {
            (|attr| {new_op.set_attr_int("num_buckets", *attr)})(&self.num_buckets)
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct StringToHashBucketFast {
    input: Edge<String>,
    num_buckets: i64,
    id_: usize,
}

impl StringToHashBucketFast {
    pub fn finish(self) -> StringToHashBucketFastOp {
        StringToHashBucketFastOp::new(Rc::new(self))
    }

    pub fn new(input: Edge<String>, num_buckets: int) -> Self {
        Self {
            input,
            num_buckets: num_buckets
            id_: new_id(),
        }
    }
}

impl StaticRegexFullMatchOp {
    pub fn new(inner: Rc<StaticRegexFullMatch>) -> Self {
        Self{inner}
    }

    pub fn output(&self) -> Edge<bool> {
        Edge::<bool>::new(self.inner.clone(), 0)
    }
}

struct StaticRegexFullMatchOp {
    inner: Rc<StaticRegexFullMatch>,
}

impl GraphOperation for StaticRegexFullMatch {
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("StaticRegexFullMatch_{}")?
        };
        let mut new_op = graph.new_operation("StaticRegexFullMatch", &op_name)?;
        {
            (|attr| {new_op.set_attr_string("pattern", attr)})(&self.pattern)
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct StaticRegexFullMatch {
    input: Edge<String>,
    pattern: String,
    id_: usize,
}

impl StaticRegexFullMatch {
    pub fn finish(self) -> StaticRegexFullMatchOp {
        StaticRegexFullMatchOp::new(Rc::new(self))
    }

    pub fn new(input: Edge<String>, pattern: &str) -> Self {
        Self {
            input,
            pattern: pattern.to_string()
            id_: new_id(),
        }
    }
}

impl RegexFullMatchOp {
    pub fn new(inner: Rc<RegexFullMatch>) -> Self {
        Self{inner}
    }

    pub fn output(&self) -> Edge<bool> {
        Edge::<bool>::new(self.inner.clone(), 0)
    }
}

struct RegexFullMatchOp {
    inner: Rc<RegexFullMatch>,
}

impl GraphOperation for RegexFullMatch {
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("RegexFullMatch_{}")?
        };
        let mut new_op = graph.new_operation("RegexFullMatch", &op_name)?;
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct RegexFullMatch {
    input: Edge<String>,
    pattern: Edge<String>,
    id_: usize,
}

impl RegexFullMatch {
    pub fn finish(self) -> RegexFullMatchOp {
        RegexFullMatchOp::new(Rc::new(self))
    }

    pub fn new(input: Edge<String>, pattern: Edge<String>) -> Self {
        Self {
            input,
            pattern,
            id_: new_id(),
        }
    }
}

pub trait con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64 for BFloat16 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64 for f32 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64 for f64 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64 for i16 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64 for i32 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64 for i64 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64 for i8 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64 for u16 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64 for u32 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64 for u64 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64 for u8 {
}

impl<T, Tseed, output_dtype> StatelessMultinomialOp<T, Tseed, output_dtype>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      Tseed: con_or_DT_INT32_or_DT_INT64,
      output_dtype: con_or_DT_INT32_or_DT_INT64,
{
    pub fn new(inner: Rc<StatelessMultinomial<T, Tseed, output_dtype>>) -> Self {
        Self{inner}
    }

    pub fn output(&self) -> Edge<output_dtype> {
        Edge::<output_dtype>::new(self.inner.clone(), 0)
    }
}

struct StatelessMultinomialOp<T, Tseed, output_dtype>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      Tseed: con_or_DT_INT32_or_DT_INT64,
      output_dtype: con_or_DT_INT32_or_DT_INT64,
{
    inner: Rc<StatelessMultinomial<T, Tseed, output_dtype>>,
}

impl<T, Tseed, output_dtype> GraphOperation for StatelessMultinomial<T, Tseed, output_dtype>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      Tseed: con_or_DT_INT32_or_DT_INT64,
      output_dtype: con_or_DT_INT32_or_DT_INT64,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("StatelessMultinomial_{}")?
        };
        let mut new_op = graph.new_operation("StatelessMultinomial", &op_name)?;
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct StatelessMultinomial<T, Tseed, output_dtype>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      Tseed: con_or_DT_INT32_or_DT_INT64,
      output_dtype: con_or_DT_INT32_or_DT_INT64,
{
    logits: Edge<T>,
    num_samples: Edge<i32>,
    seed: Edge<Tseed>,
    id_: usize,
}

impl<T, Tseed, output_dtype> StatelessMultinomial<T, Tseed, output_dtype>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      Tseed: con_or_DT_INT32_or_DT_INT64,
      output_dtype: con_or_DT_INT32_or_DT_INT64,
{
    pub fn finish(self) -> StatelessMultinomialOp<T, Tseed, output_dtype> {
        StatelessMultinomialOp::new(Rc::new(self))
    }

    pub fn new(logits: Edge<T>, num_samples: Edge<i32>, seed: Edge<Tseed>) -> Self {
        Self {
            logits,
            num_samples,
            seed,
            id_: new_id(),
        }
    }
}

impl<T, Tseed, dtype> StatelessRandomUniformIntOp<T, Tseed, dtype>
where dtype: con_or_DT_INT32_or_DT_INT64,
      T: con_or_DT_INT32_or_DT_INT64,
      Tseed: con_or_DT_INT32_or_DT_INT64,
{
    pub fn new(inner: Rc<StatelessRandomUniformInt<T, Tseed, dtype>>) -> Self {
        Self{inner}
    }

    pub fn output(&self) -> Edge<dtype> {
        Edge::<dtype>::new(self.inner.clone(), 0)
    }
}

struct StatelessRandomUniformIntOp<T, Tseed, dtype>
where dtype: con_or_DT_INT32_or_DT_INT64,
      T: con_or_DT_INT32_or_DT_INT64,
      Tseed: con_or_DT_INT32_or_DT_INT64,
{
    inner: Rc<StatelessRandomUniformInt<T, Tseed, dtype>>,
}

impl<T, Tseed, dtype> GraphOperation for StatelessRandomUniformInt<T, Tseed, dtype>
where dtype: con_or_DT_INT32_or_DT_INT64,
      T: con_or_DT_INT32_or_DT_INT64,
      Tseed: con_or_DT_INT32_or_DT_INT64,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("StatelessRandomUniformInt_{}")?
        };
        let mut new_op = graph.new_operation("StatelessRandomUniformInt", &op_name)?;
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct StatelessRandomUniformInt<T, Tseed, dtype>
where dtype: con_or_DT_INT32_or_DT_INT64,
      T: con_or_DT_INT32_or_DT_INT64,
      Tseed: con_or_DT_INT32_or_DT_INT64,
{
    shape: Edge<T>,
    seed: Edge<Tseed>,
    minval: Edge<dtype>,
    maxval: Edge<dtype>,
    id_: usize,
}

impl<T, Tseed, dtype> StatelessRandomUniformInt<T, Tseed, dtype>
where dtype: con_or_DT_INT32_or_DT_INT64,
      T: con_or_DT_INT32_or_DT_INT64,
      Tseed: con_or_DT_INT32_or_DT_INT64,
{
    pub fn finish(self) -> StatelessRandomUniformIntOp<T, Tseed, dtype> {
        StatelessRandomUniformIntOp::new(Rc::new(self))
    }

    pub fn new(shape: Edge<T>, seed: Edge<Tseed>, minval: Edge<dtype>, maxval: Edge<dtype>) -> Self {
        Self {
            shape,
            seed,
            minval,
            maxval,
            id_: new_id(),
        }
    }
}

pub trait con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF for BFloat16 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF for f32 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF for f64 {
}

impl<T, Tseed, dtype> StatelessTruncatedNormalOp<T, Tseed, dtype>
where dtype: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
      T: con_or_DT_INT32_or_DT_INT64,
      Tseed: con_or_DT_INT32_or_DT_INT64,
{
    pub fn new(inner: Rc<StatelessTruncatedNormal<T, Tseed, dtype>>) -> Self {
        Self{inner}
    }

    pub fn output(&self) -> Edge<dtype> {
        Edge::<dtype>::new(self.inner.clone(), 0)
    }
}

struct StatelessTruncatedNormalOp<T, Tseed, dtype>
where dtype: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
      T: con_or_DT_INT32_or_DT_INT64,
      Tseed: con_or_DT_INT32_or_DT_INT64,
{
    inner: Rc<StatelessTruncatedNormal<T, Tseed, dtype>>,
}

impl<T, Tseed, dtype> GraphOperation for StatelessTruncatedNormal<T, Tseed, dtype>
where dtype: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
      T: con_or_DT_INT32_or_DT_INT64,
      Tseed: con_or_DT_INT32_or_DT_INT64,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("StatelessTruncatedNormal_{}")?
        };
        let mut new_op = graph.new_operation("StatelessTruncatedNormal", &op_name)?;
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct StatelessTruncatedNormal<T, Tseed, dtype>
where dtype: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
      T: con_or_DT_INT32_or_DT_INT64,
      Tseed: con_or_DT_INT32_or_DT_INT64,
{
    shape: Edge<T>,
    seed: Edge<Tseed>,
    id_: usize,
}

impl<T, Tseed, dtype> StatelessTruncatedNormal<T, Tseed, dtype>
where dtype: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
      T: con_or_DT_INT32_or_DT_INT64,
      Tseed: con_or_DT_INT32_or_DT_INT64,
{
    pub fn finish(self) -> StatelessTruncatedNormalOp<T, Tseed, dtype> {
        StatelessTruncatedNormalOp::new(Rc::new(self))
    }

    pub fn new(shape: Edge<T>, seed: Edge<Tseed>) -> Self {
        Self {
            shape,
            seed,
            id_: new_id(),
        }
    }
}

impl<T, Tseed, dtype> StatelessRandomNormalOp<T, Tseed, dtype>
where dtype: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
      T: con_or_DT_INT32_or_DT_INT64,
      Tseed: con_or_DT_INT32_or_DT_INT64,
{
    pub fn new(inner: Rc<StatelessRandomNormal<T, Tseed, dtype>>) -> Self {
        Self{inner}
    }

    pub fn output(&self) -> Edge<dtype> {
        Edge::<dtype>::new(self.inner.clone(), 0)
    }
}

struct StatelessRandomNormalOp<T, Tseed, dtype>
where dtype: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
      T: con_or_DT_INT32_or_DT_INT64,
      Tseed: con_or_DT_INT32_or_DT_INT64,
{
    inner: Rc<StatelessRandomNormal<T, Tseed, dtype>>,
}

impl<T, Tseed, dtype> GraphOperation for StatelessRandomNormal<T, Tseed, dtype>
where dtype: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
      T: con_or_DT_INT32_or_DT_INT64,
      Tseed: con_or_DT_INT32_or_DT_INT64,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("StatelessRandomNormal_{}")?
        };
        let mut new_op = graph.new_operation("StatelessRandomNormal", &op_name)?;
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct StatelessRandomNormal<T, Tseed, dtype>
where dtype: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
      T: con_or_DT_INT32_or_DT_INT64,
      Tseed: con_or_DT_INT32_or_DT_INT64,
{
    shape: Edge<T>,
    seed: Edge<Tseed>,
    id_: usize,
}

impl<T, Tseed, dtype> StatelessRandomNormal<T, Tseed, dtype>
where dtype: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
      T: con_or_DT_INT32_or_DT_INT64,
      Tseed: con_or_DT_INT32_or_DT_INT64,
{
    pub fn finish(self) -> StatelessRandomNormalOp<T, Tseed, dtype> {
        StatelessRandomNormalOp::new(Rc::new(self))
    }

    pub fn new(shape: Edge<T>, seed: Edge<Tseed>) -> Self {
        Self {
            shape,
            seed,
            id_: new_id(),
        }
    }
}

impl<T, Tindices> ScatterNdSubOp<T, Tindices>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      Tindices: con_or_DT_INT32_or_DT_INT64,
{
    pub fn new(inner: Rc<ScatterNdSub<T, Tindices>>) -> Self {
        Self{inner}
    }

    pub fn output_ref(&self) -> Edge<T> {
        Edge::<T>::new(self.inner.clone(), 0)
    }
}

struct ScatterNdSubOp<T, Tindices>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      Tindices: con_or_DT_INT32_or_DT_INT64,
{
    inner: Rc<ScatterNdSub<T, Tindices>>,
}

impl<T, Tindices> GraphOperation for ScatterNdSub<T, Tindices>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      Tindices: con_or_DT_INT32_or_DT_INT64,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("ScatterNdSub_{}")?
        };
        let mut new_op = graph.new_operation("ScatterNdSub", &op_name)?;
        {
            match self.use_locking {
            }
            None => new_op.set_attr_value_proto("use_locking", &vec![40_u8, 0_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_bool("use_locking", *attr)})(&value),
        };
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct ScatterNdSub<T, Tindices>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      Tindices: con_or_DT_INT32_or_DT_INT64,
{
    ref_: Edge<T>,
    indices: Edge<Tindices>,
    updates: Edge<T>,
    use_locking: Option<bool>,
    id_: usize,
}

impl<T, Tindices> ScatterNdSub<T, Tindices>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      Tindices: con_or_DT_INT32_or_DT_INT64,
{
    pub fn use_locking(&mut self, use_locking: bool) -> &mut Self {
        self.use_locking = Some(use_locking);
        &self
    }

    pub fn finish(self) -> ScatterNdSubOp<T, Tindices> {
        ScatterNdSubOp::new(Rc::new(self))
    }

    pub fn new(ref_: Edge<T>, indices: Edge<Tindices>, updates: Edge<T>) -> Self {
        Self {
            ref_,
            indices,
            updates,
            use_locking: None,
            id_: new_id(),
        }
    }
}

pub trait con {
}

impl<T, Tindices> ScatterNdUpdateOp<T, Tindices>
where T: con,
      Tindices: con_or_DT_INT32_or_DT_INT64,
{
    pub fn new(inner: Rc<ScatterNdUpdate<T, Tindices>>) -> Self {
        Self{inner}
    }

    pub fn output_ref(&self) -> Edge<T> {
        Edge::<T>::new(self.inner.clone(), 0)
    }
}

struct ScatterNdUpdateOp<T, Tindices>
where T: con,
      Tindices: con_or_DT_INT32_or_DT_INT64,
{
    inner: Rc<ScatterNdUpdate<T, Tindices>>,
}

impl<T, Tindices> GraphOperation for ScatterNdUpdate<T, Tindices>
where T: con,
      Tindices: con_or_DT_INT32_or_DT_INT64,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("ScatterNdUpdate_{}")?
        };
        let mut new_op = graph.new_operation("ScatterNdUpdate", &op_name)?;
        {
            match self.use_locking {
            }
            None => new_op.set_attr_value_proto("use_locking", &vec![40_u8, 1_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_bool("use_locking", *attr)})(&value),
        };
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct ScatterNdUpdate<T, Tindices>
where T: con,
      Tindices: con_or_DT_INT32_or_DT_INT64,
{
    ref_: Edge<T>,
    indices: Edge<Tindices>,
    updates: Edge<T>,
    use_locking: Option<bool>,
    id_: usize,
}

impl<T, Tindices> ScatterNdUpdate<T, Tindices>
where T: con,
      Tindices: con_or_DT_INT32_or_DT_INT64,
{
    pub fn use_locking(&mut self, use_locking: bool) -> &mut Self {
        self.use_locking = Some(use_locking);
        &self
    }

    pub fn finish(self) -> ScatterNdUpdateOp<T, Tindices> {
        ScatterNdUpdateOp::new(Rc::new(self))
    }

    pub fn new(ref_: Edge<T>, indices: Edge<Tindices>, updates: Edge<T>) -> Self {
        Self {
            ref_,
            indices,
            updates,
            use_locking: None,
            id_: new_id(),
        }
    }
}

pub trait con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_INT64_or_DT_BFLOAT16_or_DT_HALF {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_INT64_or_DT_BFLOAT16_or_DT_HALF for BFloat16 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_INT64_or_DT_BFLOAT16_or_DT_HALF for f32 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_INT64_or_DT_BFLOAT16_or_DT_HALF for f64 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_INT64_or_DT_BFLOAT16_or_DT_HALF for i32 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_INT64_or_DT_BFLOAT16_or_DT_HALF for i64 {
}

impl<T, Tindices> ScatterMaxOp<T, Tindices>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_INT64_or_DT_BFLOAT16_or_DT_HALF,
      Tindices: con_or_DT_INT32_or_DT_INT64,
{
    pub fn new(inner: Rc<ScatterMax<T, Tindices>>) -> Self {
        Self{inner}
    }

    pub fn output_ref(&self) -> Edge<T> {
        Edge::<T>::new(self.inner.clone(), 0)
    }
}

struct ScatterMaxOp<T, Tindices>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_INT64_or_DT_BFLOAT16_or_DT_HALF,
      Tindices: con_or_DT_INT32_or_DT_INT64,
{
    inner: Rc<ScatterMax<T, Tindices>>,
}

impl<T, Tindices> GraphOperation for ScatterMax<T, Tindices>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_INT64_or_DT_BFLOAT16_or_DT_HALF,
      Tindices: con_or_DT_INT32_or_DT_INT64,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("ScatterMax_{}")?
        };
        let mut new_op = graph.new_operation("ScatterMax", &op_name)?;
        {
            match self.use_locking {
            }
            None => new_op.set_attr_value_proto("use_locking", &vec![40_u8, 0_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_bool("use_locking", *attr)})(&value),
        };
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct ScatterMax<T, Tindices>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_INT64_or_DT_BFLOAT16_or_DT_HALF,
      Tindices: con_or_DT_INT32_or_DT_INT64,
{
    ref_: Edge<T>,
    indices: Edge<Tindices>,
    updates: Edge<T>,
    use_locking: Option<bool>,
    id_: usize,
}

impl<T, Tindices> ScatterMax<T, Tindices>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_INT64_or_DT_BFLOAT16_or_DT_HALF,
      Tindices: con_or_DT_INT32_or_DT_INT64,
{
    pub fn use_locking(&mut self, use_locking: bool) -> &mut Self {
        self.use_locking = Some(use_locking);
        &self
    }

    pub fn finish(self) -> ScatterMaxOp<T, Tindices> {
        ScatterMaxOp::new(Rc::new(self))
    }

    pub fn new(ref_: Edge<T>, indices: Edge<Tindices>, updates: Edge<T>) -> Self {
        Self {
            ref_,
            indices,
            updates,
            use_locking: None,
            id_: new_id(),
        }
    }
}

impl<T, Tindices> ScatterMinOp<T, Tindices>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_INT64_or_DT_BFLOAT16_or_DT_HALF,
      Tindices: con_or_DT_INT32_or_DT_INT64,
{
    pub fn new(inner: Rc<ScatterMin<T, Tindices>>) -> Self {
        Self{inner}
    }

    pub fn output_ref(&self) -> Edge<T> {
        Edge::<T>::new(self.inner.clone(), 0)
    }
}

struct ScatterMinOp<T, Tindices>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_INT64_or_DT_BFLOAT16_or_DT_HALF,
      Tindices: con_or_DT_INT32_or_DT_INT64,
{
    inner: Rc<ScatterMin<T, Tindices>>,
}

impl<T, Tindices> GraphOperation for ScatterMin<T, Tindices>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_INT64_or_DT_BFLOAT16_or_DT_HALF,
      Tindices: con_or_DT_INT32_or_DT_INT64,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("ScatterMin_{}")?
        };
        let mut new_op = graph.new_operation("ScatterMin", &op_name)?;
        {
            match self.use_locking {
            }
            None => new_op.set_attr_value_proto("use_locking", &vec![40_u8, 0_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_bool("use_locking", *attr)})(&value),
        };
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct ScatterMin<T, Tindices>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_INT64_or_DT_BFLOAT16_or_DT_HALF,
      Tindices: con_or_DT_INT32_or_DT_INT64,
{
    ref_: Edge<T>,
    indices: Edge<Tindices>,
    updates: Edge<T>,
    use_locking: Option<bool>,
    id_: usize,
}

impl<T, Tindices> ScatterMin<T, Tindices>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_INT64_or_DT_BFLOAT16_or_DT_HALF,
      Tindices: con_or_DT_INT32_or_DT_INT64,
{
    pub fn use_locking(&mut self, use_locking: bool) -> &mut Self {
        self.use_locking = Some(use_locking);
        &self
    }

    pub fn finish(self) -> ScatterMinOp<T, Tindices> {
        ScatterMinOp::new(Rc::new(self))
    }

    pub fn new(ref_: Edge<T>, indices: Edge<Tindices>, updates: Edge<T>) -> Self {
        Self {
            ref_,
            indices,
            updates,
            use_locking: None,
            id_: new_id(),
        }
    }
}

impl<T, Tindices> ScatterMulOp<T, Tindices>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      Tindices: con_or_DT_INT32_or_DT_INT64,
{
    pub fn new(inner: Rc<ScatterMul<T, Tindices>>) -> Self {
        Self{inner}
    }

    pub fn output_ref(&self) -> Edge<T> {
        Edge::<T>::new(self.inner.clone(), 0)
    }
}

struct ScatterMulOp<T, Tindices>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      Tindices: con_or_DT_INT32_or_DT_INT64,
{
    inner: Rc<ScatterMul<T, Tindices>>,
}

impl<T, Tindices> GraphOperation for ScatterMul<T, Tindices>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      Tindices: con_or_DT_INT32_or_DT_INT64,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("ScatterMul_{}")?
        };
        let mut new_op = graph.new_operation("ScatterMul", &op_name)?;
        {
            match self.use_locking {
            }
            None => new_op.set_attr_value_proto("use_locking", &vec![40_u8, 0_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_bool("use_locking", *attr)})(&value),
        };
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct ScatterMul<T, Tindices>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      Tindices: con_or_DT_INT32_or_DT_INT64,
{
    ref_: Edge<T>,
    indices: Edge<Tindices>,
    updates: Edge<T>,
    use_locking: Option<bool>,
    id_: usize,
}

impl<T, Tindices> ScatterMul<T, Tindices>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      Tindices: con_or_DT_INT32_or_DT_INT64,
{
    pub fn use_locking(&mut self, use_locking: bool) -> &mut Self {
        self.use_locking = Some(use_locking);
        &self
    }

    pub fn finish(self) -> ScatterMulOp<T, Tindices> {
        ScatterMulOp::new(Rc::new(self))
    }

    pub fn new(ref_: Edge<T>, indices: Edge<Tindices>, updates: Edge<T>) -> Self {
        Self {
            ref_,
            indices,
            updates,
            use_locking: None,
            id_: new_id(),
        }
    }
}

impl<T> AssignSubOp<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
{
    pub fn new(inner: Rc<AssignSub<T>>) -> Self {
        Self{inner}
    }

    pub fn output_ref(&self) -> Edge<T> {
        Edge::<T>::new(self.inner.clone(), 0)
    }
}

struct AssignSubOp<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
{
    inner: Rc<AssignSub<T>>,
}

impl<T> GraphOperation for AssignSub<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("AssignSub_{}")?
        };
        let mut new_op = graph.new_operation("AssignSub", &op_name)?;
        {
            match self.use_locking {
            }
            None => new_op.set_attr_value_proto("use_locking", &vec![40_u8, 0_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_bool("use_locking", *attr)})(&value),
        };
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct AssignSub<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
{
    ref_: Edge<T>,
    value: Edge<T>,
    use_locking: Option<bool>,
    id_: usize,
}

impl<T> AssignSub<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
{
    pub fn use_locking(&mut self, use_locking: bool) -> &mut Self {
        self.use_locking = Some(use_locking);
        &self
    }

    pub fn finish(self) -> AssignSubOp<T> {
        AssignSubOp::new(Rc::new(self))
    }

    pub fn new(ref_: Edge<T>, value: Edge<T>) -> Self {
        Self {
            ref_,
            value,
            use_locking: None,
            id_: new_id(),
        }
    }
}

impl<T> DestroyTemporaryVariableOp<T>
where T: con,
{
    pub fn new(inner: Rc<DestroyTemporaryVariable<T>>) -> Self {
        Self{inner}
    }

    pub fn value(&self) -> Edge<T> {
        Edge::<T>::new(self.inner.clone(), 0)
    }
}

struct DestroyTemporaryVariableOp<T>
where T: con,
{
    inner: Rc<DestroyTemporaryVariable<T>>,
}

impl<T> GraphOperation for DestroyTemporaryVariable<T>
where T: con,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("DestroyTemporaryVariable_{}")?
        };
        let mut new_op = graph.new_operation("DestroyTemporaryVariable", &op_name)?;
        {
            (|attr| {new_op.set_attr_string("var_name", attr)})(&self.var_name)
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct DestroyTemporaryVariable<T>
where T: con,
{
    ref_: Edge<T>,
    var_name: String,
    id_: usize,
}

impl<T> DestroyTemporaryVariable<T>
where T: con,
{
    pub fn finish(self) -> DestroyTemporaryVariableOp<T> {
        DestroyTemporaryVariableOp::new(Rc::new(self))
    }

    pub fn new(ref_: Edge<T>, var_name: &str) -> Self {
        Self {
            ref_,
            var_name: var_name.to_string()
            id_: new_id(),
        }
    }
}

impl BatchIFFT3DOp {
    pub fn new(inner: Rc<BatchIFFT3D>) -> Self {
        Self{inner}
    }

    pub fn output(&self) -> Edge<OtherComplex<f32>> {
        Edge::<OtherComplex::<f32>>::new(self.inner.clone(), 0)
    }
}

struct BatchIFFT3DOp {
    inner: Rc<BatchIFFT3D>,
}

impl GraphOperation for BatchIFFT3D {
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("BatchIFFT3D_{}")?
        };
        let mut new_op = graph.new_operation("BatchIFFT3D", &op_name)?;
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct BatchIFFT3D {
    input: Edge<OtherComplex<f32>>,
    id_: usize,
}

impl BatchIFFT3D {
    pub fn finish(self) -> BatchIFFT3DOp {
        BatchIFFT3DOp::new(Rc::new(self))
    }

    pub fn new(input: Edge<OtherComplex<f32>>) -> Self {
        Self {
            input,
            id_: new_id(),
        }
    }
}

impl BatchFFT3DOp {
    pub fn new(inner: Rc<BatchFFT3D>) -> Self {
        Self{inner}
    }

    pub fn output(&self) -> Edge<OtherComplex<f32>> {
        Edge::<OtherComplex::<f32>>::new(self.inner.clone(), 0)
    }
}

struct BatchFFT3DOp {
    inner: Rc<BatchFFT3D>,
}

impl GraphOperation for BatchFFT3D {
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("BatchFFT3D_{}")?
        };
        let mut new_op = graph.new_operation("BatchFFT3D", &op_name)?;
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct BatchFFT3D {
    input: Edge<OtherComplex<f32>>,
    id_: usize,
}

impl BatchFFT3D {
    pub fn finish(self) -> BatchFFT3DOp {
        BatchFFT3DOp::new(Rc::new(self))
    }

    pub fn new(input: Edge<OtherComplex<f32>>) -> Self {
        Self {
            input,
            id_: new_id(),
        }
    }
}

impl BatchIFFT2DOp {
    pub fn new(inner: Rc<BatchIFFT2D>) -> Self {
        Self{inner}
    }

    pub fn output(&self) -> Edge<OtherComplex<f32>> {
        Edge::<OtherComplex::<f32>>::new(self.inner.clone(), 0)
    }
}

struct BatchIFFT2DOp {
    inner: Rc<BatchIFFT2D>,
}

impl GraphOperation for BatchIFFT2D {
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("BatchIFFT2D_{}")?
        };
        let mut new_op = graph.new_operation("BatchIFFT2D", &op_name)?;
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct BatchIFFT2D {
    input: Edge<OtherComplex<f32>>,
    id_: usize,
}

impl BatchIFFT2D {
    pub fn finish(self) -> BatchIFFT2DOp {
        BatchIFFT2DOp::new(Rc::new(self))
    }

    pub fn new(input: Edge<OtherComplex<f32>>) -> Self {
        Self {
            input,
            id_: new_id(),
        }
    }
}

impl BatchFFT2DOp {
    pub fn new(inner: Rc<BatchFFT2D>) -> Self {
        Self{inner}
    }

    pub fn output(&self) -> Edge<OtherComplex<f32>> {
        Edge::<OtherComplex::<f32>>::new(self.inner.clone(), 0)
    }
}

struct BatchFFT2DOp {
    inner: Rc<BatchFFT2D>,
}

impl GraphOperation for BatchFFT2D {
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("BatchFFT2D_{}")?
        };
        let mut new_op = graph.new_operation("BatchFFT2D", &op_name)?;
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct BatchFFT2D {
    input: Edge<OtherComplex<f32>>,
    id_: usize,
}

impl BatchFFT2D {
    pub fn finish(self) -> BatchFFT2DOp {
        BatchFFT2DOp::new(Rc::new(self))
    }

    pub fn new(input: Edge<OtherComplex<f32>>) -> Self {
        Self {
            input,
            id_: new_id(),
        }
    }
}

impl BatchIFFTOp {
    pub fn new(inner: Rc<BatchIFFT>) -> Self {
        Self{inner}
    }

    pub fn output(&self) -> Edge<OtherComplex<f32>> {
        Edge::<OtherComplex::<f32>>::new(self.inner.clone(), 0)
    }
}

struct BatchIFFTOp {
    inner: Rc<BatchIFFT>,
}

impl GraphOperation for BatchIFFT {
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("BatchIFFT_{}")?
        };
        let mut new_op = graph.new_operation("BatchIFFT", &op_name)?;
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct BatchIFFT {
    input: Edge<OtherComplex<f32>>,
    id_: usize,
}

impl BatchIFFT {
    pub fn finish(self) -> BatchIFFTOp {
        BatchIFFTOp::new(Rc::new(self))
    }

    pub fn new(input: Edge<OtherComplex<f32>>) -> Self {
        Self {
            input,
            id_: new_id(),
        }
    }
}

impl IRFFT3DOp {
    pub fn new(inner: Rc<IRFFT3D>) -> Self {
        Self{inner}
    }

    pub fn output(&self) -> Edge<f32> {
        Edge::<f32>::new(self.inner.clone(), 0)
    }
}

struct IRFFT3DOp {
    inner: Rc<IRFFT3D>,
}

impl GraphOperation for IRFFT3D {
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("IRFFT3D_{}")?
        };
        let mut new_op = graph.new_operation("IRFFT3D", &op_name)?;
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct IRFFT3D {
    input: Edge<OtherComplex<f32>>,
    fft_length: Edge<i32>,
    id_: usize,
}

impl IRFFT3D {
    pub fn finish(self) -> IRFFT3DOp {
        IRFFT3DOp::new(Rc::new(self))
    }

    pub fn new(input: Edge<OtherComplex<f32>>, fft_length: Edge<i32>) -> Self {
        Self {
            input,
            fft_length,
            id_: new_id(),
        }
    }
}

impl IRFFT2DOp {
    pub fn new(inner: Rc<IRFFT2D>) -> Self {
        Self{inner}
    }

    pub fn output(&self) -> Edge<f32> {
        Edge::<f32>::new(self.inner.clone(), 0)
    }
}

struct IRFFT2DOp {
    inner: Rc<IRFFT2D>,
}

impl GraphOperation for IRFFT2D {
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("IRFFT2D_{}")?
        };
        let mut new_op = graph.new_operation("IRFFT2D", &op_name)?;
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct IRFFT2D {
    input: Edge<OtherComplex<f32>>,
    fft_length: Edge<i32>,
    id_: usize,
}

impl IRFFT2D {
    pub fn finish(self) -> IRFFT2DOp {
        IRFFT2DOp::new(Rc::new(self))
    }

    pub fn new(input: Edge<OtherComplex<f32>>, fft_length: Edge<i32>) -> Self {
        Self {
            input,
            fft_length,
            id_: new_id(),
        }
    }
}

impl RFFT2DOp {
    pub fn new(inner: Rc<RFFT2D>) -> Self {
        Self{inner}
    }

    pub fn output(&self) -> Edge<OtherComplex<f32>> {
        Edge::<OtherComplex::<f32>>::new(self.inner.clone(), 0)
    }
}

struct RFFT2DOp {
    inner: Rc<RFFT2D>,
}

impl GraphOperation for RFFT2D {
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("RFFT2D_{}")?
        };
        let mut new_op = graph.new_operation("RFFT2D", &op_name)?;
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct RFFT2D {
    input: Edge<f32>,
    fft_length: Edge<i32>,
    id_: usize,
}

impl RFFT2D {
    pub fn finish(self) -> RFFT2DOp {
        RFFT2DOp::new(Rc::new(self))
    }

    pub fn new(input: Edge<f32>, fft_length: Edge<i32>) -> Self {
        Self {
            input,
            fft_length,
            id_: new_id(),
        }
    }
}

impl RFFTOp {
    pub fn new(inner: Rc<RFFT>) -> Self {
        Self{inner}
    }

    pub fn output(&self) -> Edge<OtherComplex<f32>> {
        Edge::<OtherComplex::<f32>>::new(self.inner.clone(), 0)
    }
}

struct RFFTOp {
    inner: Rc<RFFT>,
}

impl GraphOperation for RFFT {
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("RFFT_{}")?
        };
        let mut new_op = graph.new_operation("RFFT", &op_name)?;
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct RFFT {
    input: Edge<f32>,
    fft_length: Edge<i32>,
    id_: usize,
}

impl RFFT {
    pub fn finish(self) -> RFFTOp {
        RFFTOp::new(Rc::new(self))
    }

    pub fn new(input: Edge<f32>, fft_length: Edge<i32>) -> Self {
        Self {
            input,
            fft_length,
            id_: new_id(),
        }
    }
}

pub trait con_or_DT_COMPLEX64_or_DT_COMPLEX128 {
}

impl con_or_DT_COMPLEX64_or_DT_COMPLEX128 for OtherComplex<f32> {
}

impl con_or_DT_COMPLEX64_or_DT_COMPLEX128 for OtherComplex<f64> {
}

impl<Tcomplex> IFFT2DOp<Tcomplex>
where Tcomplex: con_or_DT_COMPLEX64_or_DT_COMPLEX128,
{
    pub fn new(inner: Rc<IFFT2D<Tcomplex>>) -> Self {
        Self{inner}
    }

    pub fn output(&self) -> Edge<Tcomplex> {
        Edge::<Tcomplex>::new(self.inner.clone(), 0)
    }
}

struct IFFT2DOp<Tcomplex>
where Tcomplex: con_or_DT_COMPLEX64_or_DT_COMPLEX128,
{
    inner: Rc<IFFT2D<Tcomplex>>,
}

impl<Tcomplex> GraphOperation for IFFT2D<Tcomplex>
where Tcomplex: con_or_DT_COMPLEX64_or_DT_COMPLEX128,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("IFFT2D_{}")?
        };
        let mut new_op = graph.new_operation("IFFT2D", &op_name)?;
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct IFFT2D<Tcomplex>
where Tcomplex: con_or_DT_COMPLEX64_or_DT_COMPLEX128,
{
    input: Edge<Tcomplex>,
    id_: usize,
}

impl<Tcomplex> IFFT2D<Tcomplex>
where Tcomplex: con_or_DT_COMPLEX64_or_DT_COMPLEX128,
{
    pub fn finish(self) -> IFFT2DOp<Tcomplex> {
        IFFT2DOp::new(Rc::new(self))
    }

    pub fn new(input: Edge<Tcomplex>) -> Self {
        Self {
            input,
            id_: new_id(),
        }
    }
}

impl<Tcomplex> FFT2DOp<Tcomplex>
where Tcomplex: con_or_DT_COMPLEX64_or_DT_COMPLEX128,
{
    pub fn new(inner: Rc<FFT2D<Tcomplex>>) -> Self {
        Self{inner}
    }

    pub fn output(&self) -> Edge<Tcomplex> {
        Edge::<Tcomplex>::new(self.inner.clone(), 0)
    }
}

struct FFT2DOp<Tcomplex>
where Tcomplex: con_or_DT_COMPLEX64_or_DT_COMPLEX128,
{
    inner: Rc<FFT2D<Tcomplex>>,
}

impl<Tcomplex> GraphOperation for FFT2D<Tcomplex>
where Tcomplex: con_or_DT_COMPLEX64_or_DT_COMPLEX128,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("FFT2D_{}")?
        };
        let mut new_op = graph.new_operation("FFT2D", &op_name)?;
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct FFT2D<Tcomplex>
where Tcomplex: con_or_DT_COMPLEX64_or_DT_COMPLEX128,
{
    input: Edge<Tcomplex>,
    id_: usize,
}

impl<Tcomplex> FFT2D<Tcomplex>
where Tcomplex: con_or_DT_COMPLEX64_or_DT_COMPLEX128,
{
    pub fn finish(self) -> FFT2DOp<Tcomplex> {
        FFT2DOp::new(Rc::new(self))
    }

    pub fn new(input: Edge<Tcomplex>) -> Self {
        Self {
            input,
            id_: new_id(),
        }
    }
}

impl<Tcomplex> IFFTOp<Tcomplex>
where Tcomplex: con_or_DT_COMPLEX64_or_DT_COMPLEX128,
{
    pub fn new(inner: Rc<IFFT<Tcomplex>>) -> Self {
        Self{inner}
    }

    pub fn output(&self) -> Edge<Tcomplex> {
        Edge::<Tcomplex>::new(self.inner.clone(), 0)
    }
}

struct IFFTOp<Tcomplex>
where Tcomplex: con_or_DT_COMPLEX64_or_DT_COMPLEX128,
{
    inner: Rc<IFFT<Tcomplex>>,
}

impl<Tcomplex> GraphOperation for IFFT<Tcomplex>
where Tcomplex: con_or_DT_COMPLEX64_or_DT_COMPLEX128,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("IFFT_{}")?
        };
        let mut new_op = graph.new_operation("IFFT", &op_name)?;
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct IFFT<Tcomplex>
where Tcomplex: con_or_DT_COMPLEX64_or_DT_COMPLEX128,
{
    input: Edge<Tcomplex>,
    id_: usize,
}

impl<Tcomplex> IFFT<Tcomplex>
where Tcomplex: con_or_DT_COMPLEX64_or_DT_COMPLEX128,
{
    pub fn finish(self) -> IFFTOp<Tcomplex> {
        IFFTOp::new(Rc::new(self))
    }

    pub fn new(input: Edge<Tcomplex>) -> Self {
        Self {
            input,
            id_: new_id(),
        }
    }
}

impl<T> SparseFillEmptyRowsOp<T>
where T: con,
{
    pub fn new(inner: Rc<SparseFillEmptyRows<T>>) -> Self {
        Self{inner}
    }

    pub fn output_indices(&self) -> Edge<i64> {
        Edge::<i64>::new(self.inner.clone(), 0)
    }

    pub fn output_values(&self) -> Edge<T> {
        Edge::<T>::new(self.inner.clone(), 1)
    }

    pub fn empty_row_indicator(&self) -> Edge<bool> {
        Edge::<bool>::new(self.inner.clone(), 2)
    }

    pub fn reverse_index_map(&self) -> Edge<i64> {
        Edge::<i64>::new(self.inner.clone(), 3)
    }
}

struct SparseFillEmptyRowsOp<T>
where T: con,
{
    inner: Rc<SparseFillEmptyRows<T>>,
}

impl<T> GraphOperation for SparseFillEmptyRows<T>
where T: con,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("SparseFillEmptyRows_{}")?
        };
        let mut new_op = graph.new_operation("SparseFillEmptyRows", &op_name)?;
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct SparseFillEmptyRows<T>
where T: con,
{
    indices: Edge<i64>,
    values: Edge<T>,
    dense_shape: Edge<i64>,
    default_value: Edge<T>,
    id_: usize,
}

impl<T> SparseFillEmptyRows<T>
where T: con,
{
    pub fn finish(self) -> SparseFillEmptyRowsOp<T> {
        SparseFillEmptyRowsOp::new(Rc::new(self))
    }

    pub fn new(indices: Edge<i64>, values: Edge<T>, dense_shape: Edge<i64>, default_value: Edge<T>) -> Self {
        Self {
            indices,
            values,
            dense_shape,
            default_value,
            id_: new_id(),
        }
    }
}

impl<T> SparseSparseMinimumOp<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
{
    pub fn new(inner: Rc<SparseSparseMinimum<T>>) -> Self {
        Self{inner}
    }

    pub fn output_indices(&self) -> Edge<i64> {
        Edge::<i64>::new(self.inner.clone(), 0)
    }

    pub fn output_values(&self) -> Edge<T> {
        Edge::<T>::new(self.inner.clone(), 1)
    }
}

struct SparseSparseMinimumOp<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
{
    inner: Rc<SparseSparseMinimum<T>>,
}

impl<T> GraphOperation for SparseSparseMinimum<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("SparseSparseMinimum_{}")?
        };
        let mut new_op = graph.new_operation("SparseSparseMinimum", &op_name)?;
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct SparseSparseMinimum<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
{
    a_indices: Edge<i64>,
    a_values: Edge<T>,
    a_shape: Edge<i64>,
    b_indices: Edge<i64>,
    b_values: Edge<T>,
    b_shape: Edge<i64>,
    id_: usize,
}

impl<T> SparseSparseMinimum<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
{
    pub fn finish(self) -> SparseSparseMinimumOp<T> {
        SparseSparseMinimumOp::new(Rc::new(self))
    }

    pub fn new(a_indices: Edge<i64>, a_values: Edge<T>, a_shape: Edge<i64>, b_indices: Edge<i64>, b_values: Edge<T>, b_shape: Edge<i64>) -> Self {
        Self {
            a_indices,
            a_values,
            a_shape,
            b_indices,
            b_values,
            b_shape,
            id_: new_id(),
        }
    }
}

pub trait con_or_DT_FLOAT_or_DT_DOUBLE {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE for f32 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE for f64 {
}

impl<T> SparseSoftmaxOp<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE,
{
    pub fn new(inner: Rc<SparseSoftmax<T>>) -> Self {
        Self{inner}
    }

    pub fn output(&self) -> Edge<T> {
        Edge::<T>::new(self.inner.clone(), 0)
    }
}

struct SparseSoftmaxOp<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE,
{
    inner: Rc<SparseSoftmax<T>>,
}

impl<T> GraphOperation for SparseSoftmax<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("SparseSoftmax_{}")?
        };
        let mut new_op = graph.new_operation("SparseSoftmax", &op_name)?;
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct SparseSoftmax<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE,
{
    sp_indices: Edge<i64>,
    sp_values: Edge<T>,
    sp_shape: Edge<i64>,
    id_: usize,
}

impl<T> SparseSoftmax<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE,
{
    pub fn finish(self) -> SparseSoftmaxOp<T> {
        SparseSoftmaxOp::new(Rc::new(self))
    }

    pub fn new(sp_indices: Edge<i64>, sp_values: Edge<T>, sp_shape: Edge<i64>) -> Self {
        Self {
            sp_indices,
            sp_values,
            sp_shape,
            id_: new_id(),
        }
    }
}

impl<T> SparseDenseCwiseAddOp<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
{
    pub fn new(inner: Rc<SparseDenseCwiseAdd<T>>) -> Self {
        Self{inner}
    }

    pub fn output(&self) -> Edge<T> {
        Edge::<T>::new(self.inner.clone(), 0)
    }
}

struct SparseDenseCwiseAddOp<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
{
    inner: Rc<SparseDenseCwiseAdd<T>>,
}

impl<T> GraphOperation for SparseDenseCwiseAdd<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("SparseDenseCwiseAdd_{}")?
        };
        let mut new_op = graph.new_operation("SparseDenseCwiseAdd", &op_name)?;
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct SparseDenseCwiseAdd<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
{
    sp_indices: Edge<i64>,
    sp_values: Edge<T>,
    sp_shape: Edge<i64>,
    dense: Edge<T>,
    id_: usize,
}

impl<T> SparseDenseCwiseAdd<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
{
    pub fn finish(self) -> SparseDenseCwiseAddOp<T> {
        SparseDenseCwiseAddOp::new(Rc::new(self))
    }

    pub fn new(sp_indices: Edge<i64>, sp_values: Edge<T>, sp_shape: Edge<i64>, dense: Edge<T>) -> Self {
        Self {
            sp_indices,
            sp_values,
            sp_shape,
            dense,
            id_: new_id(),
        }
    }
}

impl<T> ApplyMomentumOp<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
{
    pub fn new(inner: Rc<ApplyMomentum<T>>) -> Self {
        Self{inner}
    }

    pub fn out(&self) -> Edge<T> {
        Edge::<T>::new(self.inner.clone(), 0)
    }
}

struct ApplyMomentumOp<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
{
    inner: Rc<ApplyMomentum<T>>,
}

impl<T> GraphOperation for ApplyMomentum<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("ApplyMomentum_{}")?
        };
        let mut new_op = graph.new_operation("ApplyMomentum", &op_name)?;
        {
            match self.use_locking {
            }
            None => new_op.set_attr_value_proto("use_locking", &vec![40_u8, 0_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_bool("use_locking", *attr)})(&value),
        };
        {
            match self.use_nesterov {
            }
            None => new_op.set_attr_value_proto("use_nesterov", &vec![40_u8, 0_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_bool("use_nesterov", *attr)})(&value),
        };
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct ApplyMomentum<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
{
    var: Edge<T>,
    accum: Edge<T>,
    lr: Edge<T>,
    grad: Edge<T>,
    momentum: Edge<T>,
    use_locking: Option<bool>,
    use_nesterov: Option<bool>,
    id_: usize,
}

impl<T> ApplyMomentum<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
{
    pub fn use_locking(&mut self, use_locking: bool) -> &mut Self {
        self.use_locking = Some(use_locking);
        &self
    }

    pub fn use_nesterov(&mut self, use_nesterov: bool) -> &mut Self {
        self.use_nesterov = Some(use_nesterov);
        &self
    }

    pub fn finish(self) -> ApplyMomentumOp<T> {
        ApplyMomentumOp::new(Rc::new(self))
    }

    pub fn new(var: Edge<T>, accum: Edge<T>, lr: Edge<T>, grad: Edge<T>, momentum: Edge<T>) -> Self {
        Self {
            var,
            accum,
            lr,
            grad,
            momentum,
            use_locking: None,
            use_nesterov: None,
            id_: new_id(),
        }
    }
}

impl<T> SparseDenseCwiseDivOp<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
{
    pub fn new(inner: Rc<SparseDenseCwiseDiv<T>>) -> Self {
        Self{inner}
    }

    pub fn output(&self) -> Edge<T> {
        Edge::<T>::new(self.inner.clone(), 0)
    }
}

struct SparseDenseCwiseDivOp<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
{
    inner: Rc<SparseDenseCwiseDiv<T>>,
}

impl<T> GraphOperation for SparseDenseCwiseDiv<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("SparseDenseCwiseDiv_{}")?
        };
        let mut new_op = graph.new_operation("SparseDenseCwiseDiv", &op_name)?;
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct SparseDenseCwiseDiv<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
{
    sp_indices: Edge<i64>,
    sp_values: Edge<T>,
    sp_shape: Edge<i64>,
    dense: Edge<T>,
    id_: usize,
}

impl<T> SparseDenseCwiseDiv<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
{
    pub fn finish(self) -> SparseDenseCwiseDivOp<T> {
        SparseDenseCwiseDivOp::new(Rc::new(self))
    }

    pub fn new(sp_indices: Edge<i64>, sp_values: Edge<T>, sp_shape: Edge<i64>, dense: Edge<T>) -> Self {
        Self {
            sp_indices,
            sp_values,
            sp_shape,
            dense,
            id_: new_id(),
        }
    }
}

impl<T> SparseDenseCwiseMulOp<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
{
    pub fn new(inner: Rc<SparseDenseCwiseMul<T>>) -> Self {
        Self{inner}
    }

    pub fn output(&self) -> Edge<T> {
        Edge::<T>::new(self.inner.clone(), 0)
    }
}

struct SparseDenseCwiseMulOp<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
{
    inner: Rc<SparseDenseCwiseMul<T>>,
}

impl<T> GraphOperation for SparseDenseCwiseMul<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("SparseDenseCwiseMul_{}")?
        };
        let mut new_op = graph.new_operation("SparseDenseCwiseMul", &op_name)?;
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct SparseDenseCwiseMul<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
{
    sp_indices: Edge<i64>,
    sp_values: Edge<T>,
    sp_shape: Edge<i64>,
    dense: Edge<T>,
    id_: usize,
}

impl<T> SparseDenseCwiseMul<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
{
    pub fn finish(self) -> SparseDenseCwiseMulOp<T> {
        SparseDenseCwiseMulOp::new(Rc::new(self))
    }

    pub fn new(sp_indices: Edge<i64>, sp_values: Edge<T>, sp_shape: Edge<i64>, dense: Edge<T>) -> Self {
        Self {
            sp_indices,
            sp_values,
            sp_shape,
            dense,
            id_: new_id(),
        }
    }
}

impl<T> SparseReduceSumSparseOp<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
{
    pub fn new(inner: Rc<SparseReduceSumSparse<T>>) -> Self {
        Self{inner}
    }

    pub fn output_indices(&self) -> Edge<i64> {
        Edge::<i64>::new(self.inner.clone(), 0)
    }

    pub fn output_values(&self) -> Edge<T> {
        Edge::<T>::new(self.inner.clone(), 1)
    }

    pub fn output_shape(&self) -> Edge<i64> {
        Edge::<i64>::new(self.inner.clone(), 2)
    }
}

struct SparseReduceSumSparseOp<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
{
    inner: Rc<SparseReduceSumSparse<T>>,
}

impl<T> GraphOperation for SparseReduceSumSparse<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("SparseReduceSumSparse_{}")?
        };
        let mut new_op = graph.new_operation("SparseReduceSumSparse", &op_name)?;
        {
            match self.keep_dims {
            }
            None => new_op.set_attr_value_proto("keep_dims", &vec![40_u8, 0_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_bool("keep_dims", *attr)})(&value),
        };
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct SparseReduceSumSparse<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
{
    input_indices: Edge<i64>,
    input_values: Edge<T>,
    input_shape: Edge<i64>,
    reduction_axes: Edge<i32>,
    keep_dims: Option<bool>,
    id_: usize,
}

impl<T> SparseReduceSumSparse<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
{
    pub fn keep_dims(&mut self, keep_dims: bool) -> &mut Self {
        self.keep_dims = Some(keep_dims);
        &self
    }

    pub fn finish(self) -> SparseReduceSumSparseOp<T> {
        SparseReduceSumSparseOp::new(Rc::new(self))
    }

    pub fn new(input_indices: Edge<i64>, input_values: Edge<T>, input_shape: Edge<i64>, reduction_axes: Edge<i32>) -> Self {
        Self {
            input_indices,
            input_values,
            input_shape,
            reduction_axes,
            keep_dims: None,
            id_: new_id(),
        }
    }
}

impl<T> SparseReduceSumOp<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
{
    pub fn new(inner: Rc<SparseReduceSum<T>>) -> Self {
        Self{inner}
    }

    pub fn output(&self) -> Edge<T> {
        Edge::<T>::new(self.inner.clone(), 0)
    }
}

struct SparseReduceSumOp<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
{
    inner: Rc<SparseReduceSum<T>>,
}

impl<T> GraphOperation for SparseReduceSum<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("SparseReduceSum_{}")?
        };
        let mut new_op = graph.new_operation("SparseReduceSum", &op_name)?;
        {
            match self.keep_dims {
            }
            None => new_op.set_attr_value_proto("keep_dims", &vec![40_u8, 0_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_bool("keep_dims", *attr)})(&value),
        };
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct SparseReduceSum<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
{
    input_indices: Edge<i64>,
    input_values: Edge<T>,
    input_shape: Edge<i64>,
    reduction_axes: Edge<i32>,
    keep_dims: Option<bool>,
    id_: usize,
}

impl<T> SparseReduceSum<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
{
    pub fn keep_dims(&mut self, keep_dims: bool) -> &mut Self {
        self.keep_dims = Some(keep_dims);
        &self
    }

    pub fn finish(self) -> SparseReduceSumOp<T> {
        SparseReduceSumOp::new(Rc::new(self))
    }

    pub fn new(input_indices: Edge<i64>, input_values: Edge<T>, input_shape: Edge<i64>, reduction_axes: Edge<i32>) -> Self {
        Self {
            input_indices,
            input_values,
            input_shape,
            reduction_axes,
            keep_dims: None,
            id_: new_id(),
        }
    }
}

impl<T> SparseReduceMaxSparseOp<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
{
    pub fn new(inner: Rc<SparseReduceMaxSparse<T>>) -> Self {
        Self{inner}
    }

    pub fn output_indices(&self) -> Edge<i64> {
        Edge::<i64>::new(self.inner.clone(), 0)
    }

    pub fn output_values(&self) -> Edge<T> {
        Edge::<T>::new(self.inner.clone(), 1)
    }

    pub fn output_shape(&self) -> Edge<i64> {
        Edge::<i64>::new(self.inner.clone(), 2)
    }
}

struct SparseReduceMaxSparseOp<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
{
    inner: Rc<SparseReduceMaxSparse<T>>,
}

impl<T> GraphOperation for SparseReduceMaxSparse<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("SparseReduceMaxSparse_{}")?
        };
        let mut new_op = graph.new_operation("SparseReduceMaxSparse", &op_name)?;
        {
            match self.keep_dims {
            }
            None => new_op.set_attr_value_proto("keep_dims", &vec![40_u8, 0_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_bool("keep_dims", *attr)})(&value),
        };
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct SparseReduceMaxSparse<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
{
    input_indices: Edge<i64>,
    input_values: Edge<T>,
    input_shape: Edge<i64>,
    reduction_axes: Edge<i32>,
    keep_dims: Option<bool>,
    id_: usize,
}

impl<T> SparseReduceMaxSparse<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
{
    pub fn keep_dims(&mut self, keep_dims: bool) -> &mut Self {
        self.keep_dims = Some(keep_dims);
        &self
    }

    pub fn finish(self) -> SparseReduceMaxSparseOp<T> {
        SparseReduceMaxSparseOp::new(Rc::new(self))
    }

    pub fn new(input_indices: Edge<i64>, input_values: Edge<T>, input_shape: Edge<i64>, reduction_axes: Edge<i32>) -> Self {
        Self {
            input_indices,
            input_values,
            input_shape,
            reduction_axes,
            keep_dims: None,
            id_: new_id(),
        }
    }
}

impl<Tindices, T> SparseTensorDenseAddOp<Tindices, T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      Tindices: con_or_DT_INT32_or_DT_INT64,
{
    pub fn new(inner: Rc<SparseTensorDenseAdd<Tindices, T>>) -> Self {
        Self{inner}
    }

    pub fn output(&self) -> Edge<T> {
        Edge::<T>::new(self.inner.clone(), 0)
    }
}

struct SparseTensorDenseAddOp<Tindices, T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      Tindices: con_or_DT_INT32_or_DT_INT64,
{
    inner: Rc<SparseTensorDenseAdd<Tindices, T>>,
}

impl<Tindices, T> GraphOperation for SparseTensorDenseAdd<Tindices, T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      Tindices: con_or_DT_INT32_or_DT_INT64,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("SparseTensorDenseAdd_{}")?
        };
        let mut new_op = graph.new_operation("SparseTensorDenseAdd", &op_name)?;
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct SparseTensorDenseAdd<Tindices, T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      Tindices: con_or_DT_INT32_or_DT_INT64,
{
    a_indices: Edge<Tindices>,
    a_values: Edge<T>,
    a_shape: Edge<Tindices>,
    b: Edge<T>,
    id_: usize,
}

impl<Tindices, T> SparseTensorDenseAdd<Tindices, T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      Tindices: con_or_DT_INT32_or_DT_INT64,
{
    pub fn finish(self) -> SparseTensorDenseAddOp<Tindices, T> {
        SparseTensorDenseAddOp::new(Rc::new(self))
    }

    pub fn new(a_indices: Edge<Tindices>, a_values: Edge<T>, a_shape: Edge<Tindices>, b: Edge<T>) -> Self {
        Self {
            a_indices,
            a_values,
            a_shape,
            b,
            id_: new_id(),
        }
    }
}

impl<T> SparseReorderOp<T>
where T: con,
{
    pub fn new(inner: Rc<SparseReorder<T>>) -> Self {
        Self{inner}
    }

    pub fn output_indices(&self) -> Edge<i64> {
        Edge::<i64>::new(self.inner.clone(), 0)
    }

    pub fn output_values(&self) -> Edge<T> {
        Edge::<T>::new(self.inner.clone(), 1)
    }
}

struct SparseReorderOp<T>
where T: con,
{
    inner: Rc<SparseReorder<T>>,
}

impl<T> GraphOperation for SparseReorder<T>
where T: con,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("SparseReorder_{}")?
        };
        let mut new_op = graph.new_operation("SparseReorder", &op_name)?;
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct SparseReorder<T>
where T: con,
{
    input_indices: Edge<i64>,
    input_values: Edge<T>,
    input_shape: Edge<i64>,
    id_: usize,
}

impl<T> SparseReorder<T>
where T: con,
{
    pub fn finish(self) -> SparseReorderOp<T> {
        SparseReorderOp::new(Rc::new(self))
    }

    pub fn new(input_indices: Edge<i64>, input_values: Edge<T>, input_shape: Edge<i64>) -> Self {
        Self {
            input_indices,
            input_values,
            input_shape,
            id_: new_id(),
        }
    }
}

impl<T> SparseSliceGradOp<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
{
    pub fn new(inner: Rc<SparseSliceGrad<T>>) -> Self {
        Self{inner}
    }

    pub fn val_grad(&self) -> Edge<T> {
        Edge::<T>::new(self.inner.clone(), 0)
    }
}

struct SparseSliceGradOp<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
{
    inner: Rc<SparseSliceGrad<T>>,
}

impl<T> GraphOperation for SparseSliceGrad<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("SparseSliceGrad_{}")?
        };
        let mut new_op = graph.new_operation("SparseSliceGrad", &op_name)?;
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct SparseSliceGrad<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
{
    backprop_val_grad: Edge<T>,
    input_indices: Edge<i64>,
    input_start: Edge<i64>,
    output_indices: Edge<i64>,
    id_: usize,
}

impl<T> SparseSliceGrad<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
{
    pub fn finish(self) -> SparseSliceGradOp<T> {
        SparseSliceGradOp::new(Rc::new(self))
    }

    pub fn new(backprop_val_grad: Edge<T>, input_indices: Edge<i64>, input_start: Edge<i64>, output_indices: Edge<i64>) -> Self {
        Self {
            backprop_val_grad,
            input_indices,
            input_start,
            output_indices,
            id_: new_id(),
        }
    }
}

impl<T> SparseSplitOp<T>
where T: con,
{
    pub fn new(inner: Rc<SparseSplit<T>>) -> Self {
        Self{inner}
    }

    pub fn output_indices(&self) -> Edge<i64> {
        Edge::<i64>::new(self.inner.clone(), 0)
    }

    pub fn output_values(&self) -> Edge<T> {
        Edge::<T>::new(self.inner.clone(), 1)
    }

    pub fn output_shape(&self) -> Edge<i64> {
        Edge::<i64>::new(self.inner.clone(), 2)
    }
}

struct SparseSplitOp<T>
where T: con,
{
    inner: Rc<SparseSplit<T>>,
}

impl<T> GraphOperation for SparseSplit<T>
where T: con,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("SparseSplit_{}")?
        };
        let mut new_op = graph.new_operation("SparseSplit", &op_name)?;
        {
            (|attr| {new_op.set_attr_int("num_split", *attr)})(&self.num_split)
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct SparseSplit<T>
where T: con,
{
    split_dim: Edge<i64>,
    indices: Edge<i64>,
    values: Edge<T>,
    shape: Edge<i64>,
    num_split: i64,
    id_: usize,
}

impl<T> SparseSplit<T>
where T: con,
{
    pub fn finish(self) -> SparseSplitOp<T> {
        SparseSplitOp::new(Rc::new(self))
    }

    pub fn new(split_dim: Edge<i64>, indices: Edge<i64>, values: Edge<T>, shape: Edge<i64>, num_split: int) -> Self {
        Self {
            split_dim,
            indices,
            values,
            shape,
            num_split: num_split
            id_: new_id(),
        }
    }
}

impl IRFFTOp {
    pub fn new(inner: Rc<IRFFT>) -> Self {
        Self{inner}
    }

    pub fn output(&self) -> Edge<f32> {
        Edge::<f32>::new(self.inner.clone(), 0)
    }
}

struct IRFFTOp {
    inner: Rc<IRFFT>,
}

impl GraphOperation for IRFFT {
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("IRFFT_{}")?
        };
        let mut new_op = graph.new_operation("IRFFT", &op_name)?;
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct IRFFT {
    input: Edge<OtherComplex<f32>>,
    fft_length: Edge<i32>,
    id_: usize,
}

impl IRFFT {
    pub fn finish(self) -> IRFFTOp {
        IRFFTOp::new(Rc::new(self))
    }

    pub fn new(input: Edge<OtherComplex<f32>>, fft_length: Edge<i32>) -> Self {
        Self {
            input,
            fft_length,
            id_: new_id(),
        }
    }
}

impl<T> SparseConcatOp<T>
where T: con,
{
    pub fn new(inner: Rc<SparseConcat<T>>) -> Self {
        Self{inner}
    }

    pub fn output_indices(&self) -> Edge<i64> {
        Edge::<i64>::new(self.inner.clone(), 0)
    }

    pub fn output_values(&self) -> Edge<T> {
        Edge::<T>::new(self.inner.clone(), 1)
    }

    pub fn output_shape(&self) -> Edge<i64> {
        Edge::<i64>::new(self.inner.clone(), 2)
    }
}

struct SparseConcatOp<T>
where T: con,
{
    inner: Rc<SparseConcat<T>>,
}

impl<T> GraphOperation for SparseConcat<T>
where T: con,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("SparseConcat_{}")?
        };
        let mut new_op = graph.new_operation("SparseConcat", &op_name)?;
        {
            (|attr| {new_op.set_attr_int("concat_dim", *attr)})(&self.concat_dim)
        }
        {
            (|attr| {new_op.set_attr_int("N", *attr)})(&self.N)
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct SparseConcat<T>
where T: con,
{
    indices: Edge<i64>,
    values: Edge<T>,
    shapes: Edge<i64>,
    concat_dim: i64,
    N: i64,
    id_: usize,
}

impl<T> SparseConcat<T>
where T: con,
{
    pub fn finish(self) -> SparseConcatOp<T> {
        SparseConcatOp::new(Rc::new(self))
    }

    pub fn new(indices: Edge<i64>, values: Edge<T>, shapes: Edge<i64>, concat_dim: int, N: int) -> Self {
        Self {
            indices,
            values,
            shapes,
            concat_dim: concat_dim
            N: N
            id_: new_id(),
        }
    }
}

impl<Tindices, T> SparseToDenseOp<Tindices, T>
where T: con,
      Tindices: con_or_DT_INT32_or_DT_INT64,
{
    pub fn new(inner: Rc<SparseToDense<Tindices, T>>) -> Self {
        Self{inner}
    }

    pub fn dense(&self) -> Edge<T> {
        Edge::<T>::new(self.inner.clone(), 0)
    }
}

struct SparseToDenseOp<Tindices, T>
where T: con,
      Tindices: con_or_DT_INT32_or_DT_INT64,
{
    inner: Rc<SparseToDense<Tindices, T>>,
}

impl<Tindices, T> GraphOperation for SparseToDense<Tindices, T>
where T: con,
      Tindices: con_or_DT_INT32_or_DT_INT64,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("SparseToDense_{}")?
        };
        let mut new_op = graph.new_operation("SparseToDense", &op_name)?;
        {
            match self.validate_indices {
            }
            None => new_op.set_attr_value_proto("validate_indices", &vec![40_u8, 1_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_bool("validate_indices", *attr)})(&value),
        };
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct SparseToDense<Tindices, T>
where T: con,
      Tindices: con_or_DT_INT32_or_DT_INT64,
{
    sparse_indices: Edge<Tindices>,
    output_shape: Edge<Tindices>,
    sparse_values: Edge<T>,
    default_value: Edge<T>,
    validate_indices: Option<bool>,
    id_: usize,
}

impl<Tindices, T> SparseToDense<Tindices, T>
where T: con,
      Tindices: con_or_DT_INT32_or_DT_INT64,
{
    pub fn validate_indices(&mut self, validate_indices: bool) -> &mut Self {
        self.validate_indices = Some(validate_indices);
        &self
    }

    pub fn finish(self) -> SparseToDenseOp<Tindices, T> {
        SparseToDenseOp::new(Rc::new(self))
    }

    pub fn new(sparse_indices: Edge<Tindices>, output_shape: Edge<Tindices>, sparse_values: Edge<T>, default_value: Edge<T>) -> Self {
        Self {
            sparse_indices,
            output_shape,
            sparse_values,
            default_value,
            validate_indices: None,
            id_: new_id(),
        }
    }
}

impl<dtype> DeserializeManySparseOp<dtype>
where dtype: con,
{
    pub fn new(inner: Rc<DeserializeManySparse<dtype>>) -> Self {
        Self{inner}
    }

    pub fn sparse_indices(&self) -> Edge<i64> {
        Edge::<i64>::new(self.inner.clone(), 0)
    }

    pub fn sparse_values(&self) -> Edge<dtype> {
        Edge::<dtype>::new(self.inner.clone(), 1)
    }

    pub fn sparse_shape(&self) -> Edge<i64> {
        Edge::<i64>::new(self.inner.clone(), 2)
    }
}

struct DeserializeManySparseOp<dtype>
where dtype: con,
{
    inner: Rc<DeserializeManySparse<dtype>>,
}

impl<dtype> GraphOperation for DeserializeManySparse<dtype>
where dtype: con,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("DeserializeManySparse_{}")?
        };
        let mut new_op = graph.new_operation("DeserializeManySparse", &op_name)?;
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct DeserializeManySparse<dtype>
where dtype: con,
{
    serialized_sparse: Edge<String>,
    id_: usize,
}

impl<dtype> DeserializeManySparse<dtype>
where dtype: con,
{
    pub fn finish(self) -> DeserializeManySparseOp<dtype> {
        DeserializeManySparseOp::new(Rc::new(self))
    }

    pub fn new(serialized_sparse: Edge<String>) -> Self {
        Self {
            serialized_sparse,
            id_: new_id(),
        }
    }
}

pub trait con_or_DT_STRING_or_DT_VARIANT {
}

impl con_or_DT_STRING_or_DT_VARIANT for String {
}

impl<Tserialized, dtype> DeserializeSparseOp<Tserialized, dtype>
where dtype: con,
      Tserialized: con_or_DT_STRING_or_DT_VARIANT,
{
    pub fn new(inner: Rc<DeserializeSparse<Tserialized, dtype>>) -> Self {
        Self{inner}
    }

    pub fn sparse_indices(&self) -> Edge<i64> {
        Edge::<i64>::new(self.inner.clone(), 0)
    }

    pub fn sparse_values(&self) -> Edge<dtype> {
        Edge::<dtype>::new(self.inner.clone(), 1)
    }

    pub fn sparse_shape(&self) -> Edge<i64> {
        Edge::<i64>::new(self.inner.clone(), 2)
    }
}

struct DeserializeSparseOp<Tserialized, dtype>
where dtype: con,
      Tserialized: con_or_DT_STRING_or_DT_VARIANT,
{
    inner: Rc<DeserializeSparse<Tserialized, dtype>>,
}

impl<Tserialized, dtype> GraphOperation for DeserializeSparse<Tserialized, dtype>
where dtype: con,
      Tserialized: con_or_DT_STRING_or_DT_VARIANT,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("DeserializeSparse_{}")?
        };
        let mut new_op = graph.new_operation("DeserializeSparse", &op_name)?;
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct DeserializeSparse<Tserialized, dtype>
where dtype: con,
      Tserialized: con_or_DT_STRING_or_DT_VARIANT,
{
    serialized_sparse: Edge<Tserialized>,
    id_: usize,
}

impl<Tserialized, dtype> DeserializeSparse<Tserialized, dtype>
where dtype: con,
      Tserialized: con_or_DT_STRING_or_DT_VARIANT,
{
    pub fn finish(self) -> DeserializeSparseOp<Tserialized, dtype> {
        DeserializeSparseOp::new(Rc::new(self))
    }

    pub fn new(serialized_sparse: Edge<Tserialized>) -> Self {
        Self {
            serialized_sparse,
            id_: new_id(),
        }
    }
}

impl<T, out_type> SerializeManySparseOp<T, out_type>
where T: con,
      out_type: con_or_DT_STRING_or_DT_VARIANT,
{
    pub fn new(inner: Rc<SerializeManySparse<T, out_type>>) -> Self {
        Self{inner}
    }

    pub fn serialized_sparse(&self) -> Edge<out_type> {
        Edge::<out_type>::new(self.inner.clone(), 0)
    }
}

struct SerializeManySparseOp<T, out_type>
where T: con,
      out_type: con_or_DT_STRING_or_DT_VARIANT,
{
    inner: Rc<SerializeManySparse<T, out_type>>,
}

impl<T, out_type> GraphOperation for SerializeManySparse<T, out_type>
where T: con,
      out_type: con_or_DT_STRING_or_DT_VARIANT,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("SerializeManySparse_{}")?
        };
        let mut new_op = graph.new_operation("SerializeManySparse", &op_name)?;
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct SerializeManySparse<T, out_type>
where T: con,
      out_type: con_or_DT_STRING_or_DT_VARIANT,
{
    sparse_indices: Edge<i64>,
    sparse_values: Edge<T>,
    sparse_shape: Edge<i64>,
    id_: usize,
}

impl<T, out_type> SerializeManySparse<T, out_type>
where T: con,
      out_type: con_or_DT_STRING_or_DT_VARIANT,
{
    pub fn finish(self) -> SerializeManySparseOp<T, out_type> {
        SerializeManySparseOp::new(Rc::new(self))
    }

    pub fn new(sparse_indices: Edge<i64>, sparse_values: Edge<T>, sparse_shape: Edge<i64>) -> Self {
        Self {
            sparse_indices,
            sparse_values,
            sparse_shape,
            id_: new_id(),
        }
    }
}

impl<Tindices, T> SparseTensorDenseMatMulOp<Tindices, T>
where T: con,
      Tindices: con_or_DT_INT32_or_DT_INT64,
{
    pub fn new(inner: Rc<SparseTensorDenseMatMul<Tindices, T>>) -> Self {
        Self{inner}
    }

    pub fn product(&self) -> Edge<T> {
        Edge::<T>::new(self.inner.clone(), 0)
    }
}

struct SparseTensorDenseMatMulOp<Tindices, T>
where T: con,
      Tindices: con_or_DT_INT32_or_DT_INT64,
{
    inner: Rc<SparseTensorDenseMatMul<Tindices, T>>,
}

impl<Tindices, T> GraphOperation for SparseTensorDenseMatMul<Tindices, T>
where T: con,
      Tindices: con_or_DT_INT32_or_DT_INT64,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("SparseTensorDenseMatMul_{}")?
        };
        let mut new_op = graph.new_operation("SparseTensorDenseMatMul", &op_name)?;
        {
            match self.adjoint_a {
            }
            None => new_op.set_attr_value_proto("adjoint_a", &vec![40_u8, 0_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_bool("adjoint_a", *attr)})(&value),
        };
        {
            match self.adjoint_b {
            }
            None => new_op.set_attr_value_proto("adjoint_b", &vec![40_u8, 0_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_bool("adjoint_b", *attr)})(&value),
        };
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct SparseTensorDenseMatMul<Tindices, T>
where T: con,
      Tindices: con_or_DT_INT32_or_DT_INT64,
{
    a_indices: Edge<Tindices>,
    a_values: Edge<T>,
    a_shape: Edge<i64>,
    b: Edge<T>,
    adjoint_a: Option<bool>,
    adjoint_b: Option<bool>,
    id_: usize,
}

impl<Tindices, T> SparseTensorDenseMatMul<Tindices, T>
where T: con,
      Tindices: con_or_DT_INT32_or_DT_INT64,
{
    pub fn adjoint_a(&mut self, adjoint_a: bool) -> &mut Self {
        self.adjoint_a = Some(adjoint_a);
        &self
    }

    pub fn adjoint_b(&mut self, adjoint_b: bool) -> &mut Self {
        self.adjoint_b = Some(adjoint_b);
        &self
    }

    pub fn finish(self) -> SparseTensorDenseMatMulOp<Tindices, T> {
        SparseTensorDenseMatMulOp::new(Rc::new(self))
    }

    pub fn new(a_indices: Edge<Tindices>, a_values: Edge<T>, a_shape: Edge<i64>, b: Edge<T>) -> Self {
        Self {
            a_indices,
            a_values,
            a_shape,
            b,
            adjoint_a: None,
            adjoint_b: None,
            id_: new_id(),
        }
    }
}

impl<T, Treal> SparseAddOp<T, Treal>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      Treal: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
{
    pub fn new(inner: Rc<SparseAdd<T, Treal>>) -> Self {
        Self{inner}
    }

    pub fn sum_indices(&self) -> Edge<i64> {
        Edge::<i64>::new(self.inner.clone(), 0)
    }

    pub fn sum_values(&self) -> Edge<T> {
        Edge::<T>::new(self.inner.clone(), 1)
    }

    pub fn sum_shape(&self) -> Edge<i64> {
        Edge::<i64>::new(self.inner.clone(), 2)
    }
}

struct SparseAddOp<T, Treal>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      Treal: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
{
    inner: Rc<SparseAdd<T, Treal>>,
}

impl<T, Treal> GraphOperation for SparseAdd<T, Treal>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      Treal: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("SparseAdd_{}")?
        };
        let mut new_op = graph.new_operation("SparseAdd", &op_name)?;
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct SparseAdd<T, Treal>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      Treal: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
{
    a_indices: Edge<i64>,
    a_values: Edge<T>,
    a_shape: Edge<i64>,
    b_indices: Edge<i64>,
    b_values: Edge<T>,
    b_shape: Edge<i64>,
    thresh: Edge<Treal>,
    id_: usize,
}

impl<T, Treal> SparseAdd<T, Treal>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      Treal: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
{
    pub fn finish(self) -> SparseAddOp<T, Treal> {
        SparseAddOp::new(Rc::new(self))
    }

    pub fn new(a_indices: Edge<i64>, a_values: Edge<T>, a_shape: Edge<i64>, b_indices: Edge<i64>, b_values: Edge<T>, b_shape: Edge<i64>, thresh: Edge<Treal>) -> Self {
        Self {
            a_indices,
            a_values,
            a_shape,
            b_indices,
            b_values,
            b_shape,
            thresh,
            id_: new_id(),
        }
    }
}

impl<T> SparseAddGradOp<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
{
    pub fn new(inner: Rc<SparseAddGrad<T>>) -> Self {
        Self{inner}
    }

    pub fn a_val_grad(&self) -> Edge<T> {
        Edge::<T>::new(self.inner.clone(), 0)
    }

    pub fn b_val_grad(&self) -> Edge<T> {
        Edge::<T>::new(self.inner.clone(), 1)
    }
}

struct SparseAddGradOp<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
{
    inner: Rc<SparseAddGrad<T>>,
}

impl<T> GraphOperation for SparseAddGrad<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("SparseAddGrad_{}")?
        };
        let mut new_op = graph.new_operation("SparseAddGrad", &op_name)?;
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct SparseAddGrad<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
{
    backprop_val_grad: Edge<T>,
    a_indices: Edge<i64>,
    b_indices: Edge<i64>,
    sum_indices: Edge<i64>,
    id_: usize,
}

impl<T> SparseAddGrad<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
{
    pub fn finish(self) -> SparseAddGradOp<T> {
        SparseAddGradOp::new(Rc::new(self))
    }

    pub fn new(backprop_val_grad: Edge<T>, a_indices: Edge<i64>, b_indices: Edge<i64>, sum_indices: Edge<i64>) -> Self {
        Self {
            backprop_val_grad,
            a_indices,
            b_indices,
            sum_indices,
            id_: new_id(),
        }
    }
}

pub trait con_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_STRING_or_DT_INT64_or_DT_UINT16 {
}

impl con_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_STRING_or_DT_INT64_or_DT_UINT16 for String {
}

impl con_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_STRING_or_DT_INT64_or_DT_UINT16 for i16 {
}

impl con_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_STRING_or_DT_INT64_or_DT_UINT16 for i32 {
}

impl con_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_STRING_or_DT_INT64_or_DT_UINT16 for i64 {
}

impl con_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_STRING_or_DT_INT64_or_DT_UINT16 for i8 {
}

impl con_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_STRING_or_DT_INT64_or_DT_UINT16 for u16 {
}

impl con_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_STRING_or_DT_INT64_or_DT_UINT16 for u8 {
}

impl<T> SparseToSparseSetOperationOp<T>
where T: con_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_STRING_or_DT_INT64_or_DT_UINT16,
{
    pub fn new(inner: Rc<SparseToSparseSetOperation<T>>) -> Self {
        Self{inner}
    }

    pub fn result_indices(&self) -> Edge<i64> {
        Edge::<i64>::new(self.inner.clone(), 0)
    }

    pub fn result_values(&self) -> Edge<T> {
        Edge::<T>::new(self.inner.clone(), 1)
    }

    pub fn result_shape(&self) -> Edge<i64> {
        Edge::<i64>::new(self.inner.clone(), 2)
    }
}

struct SparseToSparseSetOperationOp<T>
where T: con_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_STRING_or_DT_INT64_or_DT_UINT16,
{
    inner: Rc<SparseToSparseSetOperation<T>>,
}

impl<T> GraphOperation for SparseToSparseSetOperation<T>
where T: con_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_STRING_or_DT_INT64_or_DT_UINT16,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("SparseToSparseSetOperation_{}")?
        };
        let mut new_op = graph.new_operation("SparseToSparseSetOperation", &op_name)?;
        {
            (|attr| {new_op.set_attr_string("set_operation", attr)})(&self.set_operation)
        }
        {
            match self.validate_indices {
            }
            None => new_op.set_attr_value_proto("validate_indices", &vec![40_u8, 1_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_bool("validate_indices", *attr)})(&value),
        };
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct SparseToSparseSetOperation<T>
where T: con_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_STRING_or_DT_INT64_or_DT_UINT16,
{
    set1_indices: Edge<i64>,
    set1_values: Edge<T>,
    set1_shape: Edge<i64>,
    set2_indices: Edge<i64>,
    set2_values: Edge<T>,
    set2_shape: Edge<i64>,
    set_operation: String,
    validate_indices: Option<bool>,
    id_: usize,
}

impl<T> SparseToSparseSetOperation<T>
where T: con_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_STRING_or_DT_INT64_or_DT_UINT16,
{
    pub fn validate_indices(&mut self, validate_indices: bool) -> &mut Self {
        self.validate_indices = Some(validate_indices);
        &self
    }

    pub fn finish(self) -> SparseToSparseSetOperationOp<T> {
        SparseToSparseSetOperationOp::new(Rc::new(self))
    }

    pub fn new(set1_indices: Edge<i64>, set1_values: Edge<T>, set1_shape: Edge<i64>, set2_indices: Edge<i64>, set2_values: Edge<T>, set2_shape: Edge<i64>, set_operation: &str) -> Self {
        Self {
            set1_indices,
            set1_values,
            set1_shape,
            set2_indices,
            set2_values,
            set2_shape,
            set_operation: set_operation.to_string()
            validate_indices: None,
            id_: new_id(),
        }
    }
}

impl<tensor_type> _HostRecvOp<tensor_type>
where tensor_type: con,
{
    pub fn new(inner: Rc<_HostRecv<tensor_type>>) -> Self {
        Self{inner}
    }

    pub fn tensor(&self) -> Edge<tensor_type> {
        Edge::<tensor_type>::new(self.inner.clone(), 0)
    }
}

struct _HostRecvOp<tensor_type>
where tensor_type: con,
{
    inner: Rc<_HostRecv<tensor_type>>,
}

impl<tensor_type> GraphOperation for _HostRecv<tensor_type>
where tensor_type: con,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("_HostRecv_{}")?
        };
        let mut new_op = graph.new_operation("_HostRecv", &op_name)?;
        {
            (|attr| {new_op.set_attr_string("tensor_name", attr)})(&self.tensor_name)
        }
        {
            (|attr| {new_op.set_attr_string("send_device", attr)})(&self.send_device)
        }
        {
            (|attr| {new_op.set_attr_int("send_device_incarnation", *attr)})(&self.send_device_incarnation)
        }
        {
            (|attr| {new_op.set_attr_string("recv_device", attr)})(&self.recv_device)
        }
        {
            match self.client_terminated {
            }
            None => new_op.set_attr_value_proto("client_terminated", &vec![40_u8, 0_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_bool("client_terminated", *attr)})(&value),
        };
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct _HostRecv<tensor_type>
where tensor_type: con,
{
    tensor_name: String,
    send_device: String,
    send_device_incarnation: i64,
    recv_device: String,
    client_terminated: Option<bool>,
    id_: usize,
}

impl<tensor_type> _HostRecv<tensor_type>
where tensor_type: con,
{
    pub fn client_terminated(&mut self, client_terminated: bool) -> &mut Self {
        self.client_terminated = Some(client_terminated);
        &self
    }

    pub fn finish(self) -> _HostRecvOp<tensor_type> {
        _HostRecvOp::new(Rc::new(self))
    }

    pub fn new(tensor_name: &str, send_device: &str, send_device_incarnation: int, recv_device: &str) -> Self {
        Self {
            tensor_name: tensor_name.to_string()
            send_device: send_device.to_string()
            send_device_incarnation: send_device_incarnation
            recv_device: recv_device.to_string()
            client_terminated: None,
            id_: new_id(),
        }
    }
}

impl<T> _HostSendOp<T>
where T: con,
{
    pub fn new(inner: Rc<_HostSend<T>>) -> Self {
        Self{inner}
    }
}

struct _HostSendOp<T>
where T: con,
{
    inner: Rc<_HostSend<T>>,
}

impl<T> GraphOperation for _HostSend<T>
where T: con,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("_HostSend_{}")?
        };
        let mut new_op = graph.new_operation("_HostSend", &op_name)?;
        {
            (|attr| {new_op.set_attr_string("tensor_name", attr)})(&self.tensor_name)
        }
        {
            (|attr| {new_op.set_attr_string("send_device", attr)})(&self.send_device)
        }
        {
            (|attr| {new_op.set_attr_int("send_device_incarnation", *attr)})(&self.send_device_incarnation)
        }
        {
            (|attr| {new_op.set_attr_string("recv_device", attr)})(&self.recv_device)
        }
        {
            match self.client_terminated {
            }
            None => new_op.set_attr_value_proto("client_terminated", &vec![40_u8, 0_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_bool("client_terminated", *attr)})(&value),
        };
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct _HostSend<T>
where T: con,
{
    tensor: Edge<T>,
    tensor_name: String,
    send_device: String,
    send_device_incarnation: i64,
    recv_device: String,
    client_terminated: Option<bool>,
    id_: usize,
}

impl<T> _HostSend<T>
where T: con,
{
    pub fn client_terminated(&mut self, client_terminated: bool) -> &mut Self {
        self.client_terminated = Some(client_terminated);
        &self
    }

    pub fn finish(self) -> _HostSendOp<T> {
        _HostSendOp::new(Rc::new(self))
    }

    pub fn new(tensor: Edge<T>, tensor_name: &str, send_device: &str, send_device_incarnation: int, recv_device: &str) -> Self {
        Self {
            tensor,
            tensor_name: tensor_name.to_string()
            send_device: send_device.to_string()
            send_device_incarnation: send_device_incarnation
            recv_device: recv_device.to_string()
            client_terminated: None,
            id_: new_id(),
        }
    }
}

impl<T> _ScopedAllocatorSplitOp<T>
where T: con,
{
    pub fn new(inner: Rc<_ScopedAllocatorSplit<T>>) -> Self {
        Self{inner}
    }

    pub fn output(&self) -> Edge<T> {
        Edge::<T>::new(self.inner.clone(), 0)
    }
}

struct _ScopedAllocatorSplitOp<T>
where T: con,
{
    inner: Rc<_ScopedAllocatorSplit<T>>,
}

impl<T> GraphOperation for _ScopedAllocatorSplit<T>
where T: con,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("_ScopedAllocatorSplit_{}")?
        };
        let mut new_op = graph.new_operation("_ScopedAllocatorSplit", &op_name)?;
        {
            (|attr| {new_op.set_attr_string("sa_name", attr)})(&self.sa_name)
        }
        {
            (|attr| {new_op.set_attr_int("id", *attr)})(&self.id)
        }
        {
            (|attr| {new_op.set_attr_int("N", *attr)})(&self.N)
        }
        {
            (|attrs| {new_op.set_attr_shape_list("shapes", attrs)})(&self.shapes)
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct _ScopedAllocatorSplit<T>
where T: con,
{
    concat: Edge<T>,
    split: Edge<T>,
    sa_name: String,
    id: i64,
    N: i64,
    shapes: Vec<Shape>,
    id_: usize,
}

impl<T> _ScopedAllocatorSplit<T>
where T: con,
{
    pub fn finish(self) -> _ScopedAllocatorSplitOp<T> {
        _ScopedAllocatorSplitOp::new(Rc::new(self))
    }

    pub fn new(concat: Edge<T>, split: Edge<T>, sa_name: &str, id: int, N: int, shapes: &[Shape]) -> Self {
        Self {
            concat,
            split,
            sa_name: sa_name.to_string()
            id: id
            N: N
            shapes: shapes.to_vec()
            id_: new_id(),
        }
    }
}

impl<T> _ScopedAllocatorConcatOp<T>
where T: con,
{
    pub fn new(inner: Rc<_ScopedAllocatorConcat<T>>) -> Self {
        Self{inner}
    }

    pub fn output(&self) -> Edge<T> {
        Edge::<T>::new(self.inner.clone(), 0)
    }
}

struct _ScopedAllocatorConcatOp<T>
where T: con,
{
    inner: Rc<_ScopedAllocatorConcat<T>>,
}

impl<T> GraphOperation for _ScopedAllocatorConcat<T>
where T: con,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("_ScopedAllocatorConcat_{}")?
        };
        let mut new_op = graph.new_operation("_ScopedAllocatorConcat", &op_name)?;
        {
            (|attr| {new_op.set_attr_shape("shape", attr)})(&self.shape)
        }
        {
            match self.reshape {
            }
            None => new_op.set_attr_value_proto("reshape", &vec![40_u8, 0_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_bool("reshape", *attr)})(&value),
        };
        {
            (|attr| {new_op.set_attr_string("sa_name", attr)})(&self.sa_name)
        }
        {
            (|attr| {new_op.set_attr_int("id", *attr)})(&self.id)
        }
        {
            (|attr| {new_op.set_attr_int("N", *attr)})(&self.N)
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct _ScopedAllocatorConcat<T>
where T: con,
{
    backing: Edge<T>,
    inputs: Edge<T>,
    shape: Shape,
    reshape: Option<bool>,
    sa_name: String,
    id: i64,
    N: i64,
    id_: usize,
}

impl<T> _ScopedAllocatorConcat<T>
where T: con,
{
    pub fn reshape(&mut self, reshape: bool) -> &mut Self {
        self.reshape = Some(reshape);
        &self
    }

    pub fn finish(self) -> _ScopedAllocatorConcatOp<T> {
        _ScopedAllocatorConcatOp::new(Rc::new(self))
    }

    pub fn new(backing: Edge<T>, inputs: Edge<T>, shape: &Shape, sa_name: &str, id: int, N: int) -> Self {
        Self {
            backing,
            inputs,
            shape: shape.clone()
            reshape: None,
            sa_name: sa_name.to_string()
            id: id
            N: N
            id_: new_id(),
        }
    }
}

impl<T> AssignOp<T>
where T: con,
{
    pub fn new(inner: Rc<Assign<T>>) -> Self {
        Self{inner}
    }

    pub fn output_ref(&self) -> Edge<T> {
        Edge::<T>::new(self.inner.clone(), 0)
    }
}

struct AssignOp<T>
where T: con,
{
    inner: Rc<Assign<T>>,
}

impl<T> GraphOperation for Assign<T>
where T: con,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("Assign_{}")?
        };
        let mut new_op = graph.new_operation("Assign", &op_name)?;
        {
            match self.validate_shape {
            }
            None => new_op.set_attr_value_proto("validate_shape", &vec![40_u8, 1_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_bool("validate_shape", *attr)})(&value),
        };
        {
            match self.use_locking {
            }
            None => new_op.set_attr_value_proto("use_locking", &vec![40_u8, 1_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_bool("use_locking", *attr)})(&value),
        };
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct Assign<T>
where T: con,
{
    ref_: Edge<T>,
    value: Edge<T>,
    validate_shape: Option<bool>,
    use_locking: Option<bool>,
    id_: usize,
}

impl<T> Assign<T>
where T: con,
{
    pub fn validate_shape(&mut self, validate_shape: bool) -> &mut Self {
        self.validate_shape = Some(validate_shape);
        &self
    }

    pub fn use_locking(&mut self, use_locking: bool) -> &mut Self {
        self.use_locking = Some(use_locking);
        &self
    }

    pub fn finish(self) -> AssignOp<T> {
        AssignOp::new(Rc::new(self))
    }

    pub fn new(ref_: Edge<T>, value: Edge<T>) -> Self {
        Self {
            ref_,
            value,
            validate_shape: None,
            use_locking: None,
            id_: new_id(),
        }
    }
}

impl<T> RandomShuffleOp<T>
where T: con,
{
    pub fn new(inner: Rc<RandomShuffle<T>>) -> Self {
        Self{inner}
    }

    pub fn output(&self) -> Edge<T> {
        Edge::<T>::new(self.inner.clone(), 0)
    }
}

struct RandomShuffleOp<T>
where T: con,
{
    inner: Rc<RandomShuffle<T>>,
}

impl<T> GraphOperation for RandomShuffle<T>
where T: con,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("RandomShuffle_{}")?
        };
        let mut new_op = graph.new_operation("RandomShuffle", &op_name)?;
        {
            match self.seed {
            }
            None => new_op.set_attr_value_proto("seed", &vec![24_u8, 0_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_int("seed", *attr)})(&value),
        };
        {
            match self.seed2 {
            }
            None => new_op.set_attr_value_proto("seed2", &vec![24_u8, 0_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_int("seed2", *attr)})(&value),
        };
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct RandomShuffle<T>
where T: con,
{
    value: Edge<T>,
    seed: Option<i64>,
    seed2: Option<i64>,
    id_: usize,
}

impl<T> RandomShuffle<T>
where T: con,
{
    pub fn seed(&mut self, seed: int) -> &mut Self {
        self.seed = Some(seed);
        &self
    }

    pub fn seed2(&mut self, seed2: int) -> &mut Self {
        self.seed2 = Some(seed2);
        &self
    }

    pub fn finish(self) -> RandomShuffleOp<T> {
        RandomShuffleOp::new(Rc::new(self))
    }

    pub fn new(value: Edge<T>) -> Self {
        Self {
            value,
            seed: None,
            seed2: None,
            id_: new_id(),
        }
    }
}

impl<T, dtype> TruncatedNormalOp<T, dtype>
where dtype: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
      T: con_or_DT_INT32_or_DT_INT64,
{
    pub fn new(inner: Rc<TruncatedNormal<T, dtype>>) -> Self {
        Self{inner}
    }

    pub fn output(&self) -> Edge<dtype> {
        Edge::<dtype>::new(self.inner.clone(), 0)
    }
}

struct TruncatedNormalOp<T, dtype>
where dtype: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
      T: con_or_DT_INT32_or_DT_INT64,
{
    inner: Rc<TruncatedNormal<T, dtype>>,
}

impl<T, dtype> GraphOperation for TruncatedNormal<T, dtype>
where dtype: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
      T: con_or_DT_INT32_or_DT_INT64,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("TruncatedNormal_{}")?
        };
        let mut new_op = graph.new_operation("TruncatedNormal", &op_name)?;
        {
            match self.seed {
            }
            None => new_op.set_attr_value_proto("seed", &vec![24_u8, 0_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_int("seed", *attr)})(&value),
        };
        {
            match self.seed2 {
            }
            None => new_op.set_attr_value_proto("seed2", &vec![24_u8, 0_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_int("seed2", *attr)})(&value),
        };
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct TruncatedNormal<T, dtype>
where dtype: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
      T: con_or_DT_INT32_or_DT_INT64,
{
    shape: Edge<T>,
    seed: Option<i64>,
    seed2: Option<i64>,
    id_: usize,
}

impl<T, dtype> TruncatedNormal<T, dtype>
where dtype: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
      T: con_or_DT_INT32_or_DT_INT64,
{
    pub fn seed(&mut self, seed: int) -> &mut Self {
        self.seed = Some(seed);
        &self
    }

    pub fn seed2(&mut self, seed2: int) -> &mut Self {
        self.seed2 = Some(seed2);
        &self
    }

    pub fn finish(self) -> TruncatedNormalOp<T, dtype> {
        TruncatedNormalOp::new(Rc::new(self))
    }

    pub fn new(shape: Edge<T>) -> Self {
        Self {
            shape,
            seed: None,
            seed2: None,
            id_: new_id(),
        }
    }
}

impl<T, dtype> RandomStandardNormalOp<T, dtype>
where dtype: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
      T: con_or_DT_INT32_or_DT_INT64,
{
    pub fn new(inner: Rc<RandomStandardNormal<T, dtype>>) -> Self {
        Self{inner}
    }

    pub fn output(&self) -> Edge<dtype> {
        Edge::<dtype>::new(self.inner.clone(), 0)
    }
}

struct RandomStandardNormalOp<T, dtype>
where dtype: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
      T: con_or_DT_INT32_or_DT_INT64,
{
    inner: Rc<RandomStandardNormal<T, dtype>>,
}

impl<T, dtype> GraphOperation for RandomStandardNormal<T, dtype>
where dtype: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
      T: con_or_DT_INT32_or_DT_INT64,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("RandomStandardNormal_{}")?
        };
        let mut new_op = graph.new_operation("RandomStandardNormal", &op_name)?;
        {
            match self.seed {
            }
            None => new_op.set_attr_value_proto("seed", &vec![24_u8, 0_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_int("seed", *attr)})(&value),
        };
        {
            match self.seed2 {
            }
            None => new_op.set_attr_value_proto("seed2", &vec![24_u8, 0_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_int("seed2", *attr)})(&value),
        };
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct RandomStandardNormal<T, dtype>
where dtype: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
      T: con_or_DT_INT32_or_DT_INT64,
{
    shape: Edge<T>,
    seed: Option<i64>,
    seed2: Option<i64>,
    id_: usize,
}

impl<T, dtype> RandomStandardNormal<T, dtype>
where dtype: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
      T: con_or_DT_INT32_or_DT_INT64,
{
    pub fn seed(&mut self, seed: int) -> &mut Self {
        self.seed = Some(seed);
        &self
    }

    pub fn seed2(&mut self, seed2: int) -> &mut Self {
        self.seed2 = Some(seed2);
        &self
    }

    pub fn finish(self) -> RandomStandardNormalOp<T, dtype> {
        RandomStandardNormalOp::new(Rc::new(self))
    }

    pub fn new(shape: Edge<T>) -> Self {
        Self {
            shape,
            seed: None,
            seed2: None,
            id_: new_id(),
        }
    }
}

impl<T, dtype> RandomUniformOp<T, dtype>
where dtype: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
      T: con_or_DT_INT32_or_DT_INT64,
{
    pub fn new(inner: Rc<RandomUniform<T, dtype>>) -> Self {
        Self{inner}
    }

    pub fn output(&self) -> Edge<dtype> {
        Edge::<dtype>::new(self.inner.clone(), 0)
    }
}

struct RandomUniformOp<T, dtype>
where dtype: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
      T: con_or_DT_INT32_or_DT_INT64,
{
    inner: Rc<RandomUniform<T, dtype>>,
}

impl<T, dtype> GraphOperation for RandomUniform<T, dtype>
where dtype: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
      T: con_or_DT_INT32_or_DT_INT64,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("RandomUniform_{}")?
        };
        let mut new_op = graph.new_operation("RandomUniform", &op_name)?;
        {
            match self.seed {
            }
            None => new_op.set_attr_value_proto("seed", &vec![24_u8, 0_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_int("seed", *attr)})(&value),
        };
        {
            match self.seed2 {
            }
            None => new_op.set_attr_value_proto("seed2", &vec![24_u8, 0_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_int("seed2", *attr)})(&value),
        };
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct RandomUniform<T, dtype>
where dtype: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
      T: con_or_DT_INT32_or_DT_INT64,
{
    shape: Edge<T>,
    seed: Option<i64>,
    seed2: Option<i64>,
    id_: usize,
}

impl<T, dtype> RandomUniform<T, dtype>
where dtype: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
      T: con_or_DT_INT32_or_DT_INT64,
{
    pub fn seed(&mut self, seed: int) -> &mut Self {
        self.seed = Some(seed);
        &self
    }

    pub fn seed2(&mut self, seed2: int) -> &mut Self {
        self.seed2 = Some(seed2);
        &self
    }

    pub fn finish(self) -> RandomUniformOp<T, dtype> {
        RandomUniformOp::new(Rc::new(self))
    }

    pub fn new(shape: Edge<T>) -> Self {
        Self {
            shape,
            seed: None,
            seed2: None,
            id_: new_id(),
        }
    }
}

impl<T> RaggedTensorToSparseOp<T>
where T: con,
{
    pub fn new(inner: Rc<RaggedTensorToSparse<T>>) -> Self {
        Self{inner}
    }

    pub fn sparse_indices(&self) -> Edge<i64> {
        Edge::<i64>::new(self.inner.clone(), 0)
    }

    pub fn sparse_values(&self) -> Edge<T> {
        Edge::<T>::new(self.inner.clone(), 1)
    }

    pub fn sparse_dense_shape(&self) -> Edge<i64> {
        Edge::<i64>::new(self.inner.clone(), 2)
    }
}

struct RaggedTensorToSparseOp<T>
where T: con,
{
    inner: Rc<RaggedTensorToSparse<T>>,
}

impl<T> GraphOperation for RaggedTensorToSparse<T>
where T: con,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("RaggedTensorToSparse_{}")?
        };
        let mut new_op = graph.new_operation("RaggedTensorToSparse", &op_name)?;
        {
            (|attr| {new_op.set_attr_int("RAGGED_RANK", *attr)})(&self.RAGGED_RANK)
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct RaggedTensorToSparse<T>
where T: con,
{
    rt_nested_splits: Edge<i64>,
    rt_dense_values: Edge<T>,
    RAGGED_RANK: i64,
    id_: usize,
}

impl<T> RaggedTensorToSparse<T>
where T: con,
{
    pub fn finish(self) -> RaggedTensorToSparseOp<T> {
        RaggedTensorToSparseOp::new(Rc::new(self))
    }

    pub fn new(rt_nested_splits: Edge<i64>, rt_dense_values: Edge<T>, RAGGED_RANK: int) -> Self {
        Self {
            rt_nested_splits,
            rt_dense_values,
            RAGGED_RANK: RAGGED_RANK
            id_: new_id(),
        }
    }
}

impl<Tvalues, Tindices> RaggedGatherOp<Tvalues, Tindices>
where Tvalues: con,
      Tindices: con_or_DT_INT32_or_DT_INT64,
{
    pub fn new(inner: Rc<RaggedGather<Tvalues, Tindices>>) -> Self {
        Self{inner}
    }

    pub fn output_nested_splits(&self) -> Edge<i64> {
        Edge::<i64>::new(self.inner.clone(), 0)
    }

    pub fn output_dense_values(&self) -> Edge<Tvalues> {
        Edge::<Tvalues>::new(self.inner.clone(), 1)
    }
}

struct RaggedGatherOp<Tvalues, Tindices>
where Tvalues: con,
      Tindices: con_or_DT_INT32_or_DT_INT64,
{
    inner: Rc<RaggedGather<Tvalues, Tindices>>,
}

impl<Tvalues, Tindices> GraphOperation for RaggedGather<Tvalues, Tindices>
where Tvalues: con,
      Tindices: con_or_DT_INT32_or_DT_INT64,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("RaggedGather_{}")?
        };
        let mut new_op = graph.new_operation("RaggedGather", &op_name)?;
        {
            (|attr| {new_op.set_attr_int("PARAMS_RAGGED_RANK", *attr)})(&self.PARAMS_RAGGED_RANK)
        }
        {
            (|attr| {new_op.set_attr_int("OUTPUT_RAGGED_RANK", *attr)})(&self.OUTPUT_RAGGED_RANK)
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct RaggedGather<Tvalues, Tindices>
where Tvalues: con,
      Tindices: con_or_DT_INT32_or_DT_INT64,
{
    params_nested_splits: Edge<i64>,
    params_dense_values: Edge<Tvalues>,
    indices: Edge<Tindices>,
    PARAMS_RAGGED_RANK: i64,
    OUTPUT_RAGGED_RANK: i64,
    id_: usize,
}

impl<Tvalues, Tindices> RaggedGather<Tvalues, Tindices>
where Tvalues: con,
      Tindices: con_or_DT_INT32_or_DT_INT64,
{
    pub fn finish(self) -> RaggedGatherOp<Tvalues, Tindices> {
        RaggedGatherOp::new(Rc::new(self))
    }

    pub fn new(params_nested_splits: Edge<i64>, params_dense_values: Edge<Tvalues>, indices: Edge<Tindices>, PARAMS_RAGGED_RANK: int, OUTPUT_RAGGED_RANK: int) -> Self {
        Self {
            params_nested_splits,
            params_dense_values,
            indices,
            PARAMS_RAGGED_RANK: PARAMS_RAGGED_RANK
            OUTPUT_RAGGED_RANK: OUTPUT_RAGGED_RANK
            id_: new_id(),
        }
    }
}

pub trait con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_INT64 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_INT64 for f32 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_INT64 for f64 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_INT64 for i32 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_INT64 for i64 {
}

impl<out_type> StringToNumberOp<out_type>
where out_type: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_INT64,
{
    pub fn new(inner: Rc<StringToNumber<out_type>>) -> Self {
        Self{inner}
    }

    pub fn output(&self) -> Edge<out_type> {
        Edge::<out_type>::new(self.inner.clone(), 0)
    }
}

struct StringToNumberOp<out_type>
where out_type: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_INT64,
{
    inner: Rc<StringToNumber<out_type>>,
}

impl<out_type> GraphOperation for StringToNumber<out_type>
where out_type: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_INT64,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("StringToNumber_{}")?
        };
        let mut new_op = graph.new_operation("StringToNumber", &op_name)?;
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct StringToNumber<out_type>
where out_type: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_INT64,
{
    string_tensor: Edge<String>,
    id_: usize,
}

impl<out_type> StringToNumber<out_type>
where out_type: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_INT64,
{
    pub fn finish(self) -> StringToNumberOp<out_type> {
        StringToNumberOp::new(Rc::new(self))
    }

    pub fn new(string_tensor: Edge<String>) -> Self {
        Self {
            string_tensor,
            id_: new_id(),
        }
    }
}

impl DecodeJSONExampleOp {
    pub fn new(inner: Rc<DecodeJSONExample>) -> Self {
        Self{inner}
    }

    pub fn binary_examples(&self) -> Edge<String> {
        Edge::<String>::new(self.inner.clone(), 0)
    }
}

struct DecodeJSONExampleOp {
    inner: Rc<DecodeJSONExample>,
}

impl GraphOperation for DecodeJSONExample {
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("DecodeJSONExample_{}")?
        };
        let mut new_op = graph.new_operation("DecodeJSONExample", &op_name)?;
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct DecodeJSONExample {
    json_examples: Edge<String>,
    id_: usize,
}

impl DecodeJSONExample {
    pub fn finish(self) -> DecodeJSONExampleOp {
        DecodeJSONExampleOp::new(Rc::new(self))
    }

    pub fn new(json_examples: Edge<String>) -> Self {
        Self {
            json_examples,
            id_: new_id(),
        }
    }
}

pub trait con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_UINT16_or_DT_HALF {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_UINT16_or_DT_HALF for f32 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_UINT16_or_DT_HALF for f64 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_UINT16_or_DT_HALF for i16 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_UINT16_or_DT_HALF for i32 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_UINT16_or_DT_HALF for i64 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_UINT16_or_DT_HALF for i8 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_UINT16_or_DT_HALF for u16 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_UINT16_or_DT_HALF for u8 {
}

impl<out_type> DecodeRawOp<out_type>
where out_type: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_UINT16_or_DT_HALF,
{
    pub fn new(inner: Rc<DecodeRaw<out_type>>) -> Self {
        Self{inner}
    }

    pub fn output(&self) -> Edge<out_type> {
        Edge::<out_type>::new(self.inner.clone(), 0)
    }
}

struct DecodeRawOp<out_type>
where out_type: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_UINT16_or_DT_HALF,
{
    inner: Rc<DecodeRaw<out_type>>,
}

impl<out_type> GraphOperation for DecodeRaw<out_type>
where out_type: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_UINT16_or_DT_HALF,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("DecodeRaw_{}")?
        };
        let mut new_op = graph.new_operation("DecodeRaw", &op_name)?;
        {
            match self.little_endian {
            }
            None => new_op.set_attr_value_proto("little_endian", &vec![40_u8, 1_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_bool("little_endian", *attr)})(&value),
        };
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct DecodeRaw<out_type>
where out_type: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_UINT16_or_DT_HALF,
{
    bytes: Edge<String>,
    little_endian: Option<bool>,
    id_: usize,
}

impl<out_type> DecodeRaw<out_type>
where out_type: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_UINT16_or_DT_HALF,
{
    pub fn little_endian(&mut self, little_endian: bool) -> &mut Self {
        self.little_endian = Some(little_endian);
        &self
    }

    pub fn finish(self) -> DecodeRawOp<out_type> {
        DecodeRawOp::new(Rc::new(self))
    }

    pub fn new(bytes: Edge<String>) -> Self {
        Self {
            bytes,
            little_endian: None,
            id_: new_id(),
        }
    }
}

pub trait con_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_QINT16_or_DT_QUINT16 {
}

impl con_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_QINT16_or_DT_QUINT16 for i16 {
}

impl con_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_QINT16_or_DT_QUINT16 for i32 {
}

impl con_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_QINT16_or_DT_QUINT16 for i8 {
}

impl con_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_QINT16_or_DT_QUINT16 for u16 {
}

impl con_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_QINT16_or_DT_QUINT16 for u8 {
}

impl<Tinput, out_type> QuantizedBatchNormWithGlobalNormalizationOp<Tinput, out_type>
where Tinput: con_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_QINT16_or_DT_QUINT16,
      out_type: con_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_QINT16_or_DT_QUINT16,
{
    pub fn new(inner: Rc<QuantizedBatchNormWithGlobalNormalization<Tinput, out_type>>) -> Self {
        Self{inner}
    }

    pub fn result(&self) -> Edge<out_type> {
        Edge::<out_type>::new(self.inner.clone(), 0)
    }

    pub fn result_min(&self) -> Edge<f32> {
        Edge::<f32>::new(self.inner.clone(), 1)
    }

    pub fn result_max(&self) -> Edge<f32> {
        Edge::<f32>::new(self.inner.clone(), 2)
    }
}

struct QuantizedBatchNormWithGlobalNormalizationOp<Tinput, out_type>
where Tinput: con_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_QINT16_or_DT_QUINT16,
      out_type: con_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_QINT16_or_DT_QUINT16,
{
    inner: Rc<QuantizedBatchNormWithGlobalNormalization<Tinput, out_type>>,
}

impl<Tinput, out_type> GraphOperation for QuantizedBatchNormWithGlobalNormalization<Tinput, out_type>
where Tinput: con_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_QINT16_or_DT_QUINT16,
      out_type: con_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_QINT16_or_DT_QUINT16,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("QuantizedBatchNormWithGlobalNormalization_{}")?
        };
        let mut new_op = graph.new_operation("QuantizedBatchNormWithGlobalNormalization", &op_name)?;
        {
            (|attr| {new_op.set_attr_float("variance_epsilon", *attr)})(&self.variance_epsilon)
        }
        {
            (|attr| {new_op.set_attr_bool("scale_after_normalization", *attr)})(&self.scale_after_normalization)
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct QuantizedBatchNormWithGlobalNormalization<Tinput, out_type>
where Tinput: con_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_QINT16_or_DT_QUINT16,
      out_type: con_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_QINT16_or_DT_QUINT16,
{
    t: Edge<Tinput>,
    t_min: Edge<f32>,
    t_max: Edge<f32>,
    m: Edge<Tinput>,
    m_min: Edge<f32>,
    m_max: Edge<f32>,
    v: Edge<Tinput>,
    v_min: Edge<f32>,
    v_max: Edge<f32>,
    beta: Edge<Tinput>,
    beta_min: Edge<f32>,
    beta_max: Edge<f32>,
    gamma: Edge<Tinput>,
    gamma_min: Edge<f32>,
    gamma_max: Edge<f32>,
    variance_epsilon: f32,
    scale_after_normalization: bool,
    id_: usize,
}

impl<Tinput, out_type> QuantizedBatchNormWithGlobalNormalization<Tinput, out_type>
where Tinput: con_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_QINT16_or_DT_QUINT16,
      out_type: con_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_QINT16_or_DT_QUINT16,
{
    pub fn finish(self) -> QuantizedBatchNormWithGlobalNormalizationOp<Tinput, out_type> {
        QuantizedBatchNormWithGlobalNormalizationOp::new(Rc::new(self))
    }

    pub fn new(t: Edge<Tinput>, t_min: Edge<f32>, t_max: Edge<f32>, m: Edge<Tinput>, m_min: Edge<f32>, m_max: Edge<f32>, v: Edge<Tinput>, v_min: Edge<f32>, v_max: Edge<f32>, beta: Edge<Tinput>, beta_min: Edge<f32>, beta_max: Edge<f32>, gamma: Edge<Tinput>, gamma_min: Edge<f32>, gamma_max: Edge<f32>, variance_epsilon: f32, scale_after_normalization: bool) -> Self {
        Self {
            t,
            t_min,
            t_max,
            m,
            m_min,
            m_max,
            v,
            v_min,
            v_max,
            beta,
            beta_min,
            beta_max,
            gamma,
            gamma_min,
            gamma_max,
            variance_epsilon: variance_epsilon
            scale_after_normalization: scale_after_normalization
            id_: new_id(),
        }
    }
}

impl<Tinput, out_type> QuantizedRelu6Op<Tinput, out_type>
where Tinput: con_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_QINT16_or_DT_QUINT16,
      out_type: con_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_QINT16_or_DT_QUINT16,
{
    pub fn new(inner: Rc<QuantizedRelu6<Tinput, out_type>>) -> Self {
        Self{inner}
    }

    pub fn activations(&self) -> Edge<out_type> {
        Edge::<out_type>::new(self.inner.clone(), 0)
    }

    pub fn min_activations(&self) -> Edge<f32> {
        Edge::<f32>::new(self.inner.clone(), 1)
    }

    pub fn max_activations(&self) -> Edge<f32> {
        Edge::<f32>::new(self.inner.clone(), 2)
    }
}

struct QuantizedRelu6Op<Tinput, out_type>
where Tinput: con_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_QINT16_or_DT_QUINT16,
      out_type: con_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_QINT16_or_DT_QUINT16,
{
    inner: Rc<QuantizedRelu6<Tinput, out_type>>,
}

impl<Tinput, out_type> GraphOperation for QuantizedRelu6<Tinput, out_type>
where Tinput: con_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_QINT16_or_DT_QUINT16,
      out_type: con_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_QINT16_or_DT_QUINT16,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("QuantizedRelu6_{}")?
        };
        let mut new_op = graph.new_operation("QuantizedRelu6", &op_name)?;
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct QuantizedRelu6<Tinput, out_type>
where Tinput: con_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_QINT16_or_DT_QUINT16,
      out_type: con_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_QINT16_or_DT_QUINT16,
{
    features: Edge<Tinput>,
    min_features: Edge<f32>,
    max_features: Edge<f32>,
    id_: usize,
}

impl<Tinput, out_type> QuantizedRelu6<Tinput, out_type>
where Tinput: con_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_QINT16_or_DT_QUINT16,
      out_type: con_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_QINT16_or_DT_QUINT16,
{
    pub fn finish(self) -> QuantizedRelu6Op<Tinput, out_type> {
        QuantizedRelu6Op::new(Rc::new(self))
    }

    pub fn new(features: Edge<Tinput>, min_features: Edge<f32>, max_features: Edge<f32>) -> Self {
        Self {
            features,
            min_features,
            max_features,
            id_: new_id(),
        }
    }
}

impl<Tinput, out_type> QuantizedReluOp<Tinput, out_type>
where Tinput: con_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_QINT16_or_DT_QUINT16,
      out_type: con_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_QINT16_or_DT_QUINT16,
{
    pub fn new(inner: Rc<QuantizedRelu<Tinput, out_type>>) -> Self {
        Self{inner}
    }

    pub fn activations(&self) -> Edge<out_type> {
        Edge::<out_type>::new(self.inner.clone(), 0)
    }

    pub fn min_activations(&self) -> Edge<f32> {
        Edge::<f32>::new(self.inner.clone(), 1)
    }

    pub fn max_activations(&self) -> Edge<f32> {
        Edge::<f32>::new(self.inner.clone(), 2)
    }
}

struct QuantizedReluOp<Tinput, out_type>
where Tinput: con_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_QINT16_or_DT_QUINT16,
      out_type: con_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_QINT16_or_DT_QUINT16,
{
    inner: Rc<QuantizedRelu<Tinput, out_type>>,
}

impl<Tinput, out_type> GraphOperation for QuantizedRelu<Tinput, out_type>
where Tinput: con_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_QINT16_or_DT_QUINT16,
      out_type: con_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_QINT16_or_DT_QUINT16,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("QuantizedRelu_{}")?
        };
        let mut new_op = graph.new_operation("QuantizedRelu", &op_name)?;
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct QuantizedRelu<Tinput, out_type>
where Tinput: con_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_QINT16_or_DT_QUINT16,
      out_type: con_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_QINT16_or_DT_QUINT16,
{
    features: Edge<Tinput>,
    min_features: Edge<f32>,
    max_features: Edge<f32>,
    id_: usize,
}

impl<Tinput, out_type> QuantizedRelu<Tinput, out_type>
where Tinput: con_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_QINT16_or_DT_QUINT16,
      out_type: con_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_QINT16_or_DT_QUINT16,
{
    pub fn finish(self) -> QuantizedReluOp<Tinput, out_type> {
        QuantizedReluOp::new(Rc::new(self))
    }

    pub fn new(features: Edge<Tinput>, min_features: Edge<f32>, max_features: Edge<f32>) -> Self {
        Self {
            features,
            min_features,
            max_features,
            id_: new_id(),
        }
    }
}

impl<T, Tindices> ScatterUpdateOp<T, Tindices>
where T: con,
      Tindices: con_or_DT_INT32_or_DT_INT64,
{
    pub fn new(inner: Rc<ScatterUpdate<T, Tindices>>) -> Self {
        Self{inner}
    }

    pub fn output_ref(&self) -> Edge<T> {
        Edge::<T>::new(self.inner.clone(), 0)
    }
}

struct ScatterUpdateOp<T, Tindices>
where T: con,
      Tindices: con_or_DT_INT32_or_DT_INT64,
{
    inner: Rc<ScatterUpdate<T, Tindices>>,
}

impl<T, Tindices> GraphOperation for ScatterUpdate<T, Tindices>
where T: con,
      Tindices: con_or_DT_INT32_or_DT_INT64,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("ScatterUpdate_{}")?
        };
        let mut new_op = graph.new_operation("ScatterUpdate", &op_name)?;
        {
            match self.use_locking {
            }
            None => new_op.set_attr_value_proto("use_locking", &vec![40_u8, 1_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_bool("use_locking", *attr)})(&value),
        };
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct ScatterUpdate<T, Tindices>
where T: con,
      Tindices: con_or_DT_INT32_or_DT_INT64,
{
    ref_: Edge<T>,
    indices: Edge<Tindices>,
    updates: Edge<T>,
    use_locking: Option<bool>,
    id_: usize,
}

impl<T, Tindices> ScatterUpdate<T, Tindices>
where T: con,
      Tindices: con_or_DT_INT32_or_DT_INT64,
{
    pub fn use_locking(&mut self, use_locking: bool) -> &mut Self {
        self.use_locking = Some(use_locking);
        &self
    }

    pub fn finish(self) -> ScatterUpdateOp<T, Tindices> {
        ScatterUpdateOp::new(Rc::new(self))
    }

    pub fn new(ref_: Edge<T>, indices: Edge<Tindices>, updates: Edge<T>) -> Self {
        Self {
            ref_,
            indices,
            updates,
            use_locking: None,
            id_: new_id(),
        }
    }
}

impl<T> QuantizedMaxPoolOp<T>
where T: con_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_QINT16_or_DT_QUINT16,
{
    pub fn new(inner: Rc<QuantizedMaxPool<T>>) -> Self {
        Self{inner}
    }

    pub fn output(&self) -> Edge<T> {
        Edge::<T>::new(self.inner.clone(), 0)
    }

    pub fn min_output(&self) -> Edge<f32> {
        Edge::<f32>::new(self.inner.clone(), 1)
    }

    pub fn max_output(&self) -> Edge<f32> {
        Edge::<f32>::new(self.inner.clone(), 2)
    }
}

struct QuantizedMaxPoolOp<T>
where T: con_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_QINT16_or_DT_QUINT16,
{
    inner: Rc<QuantizedMaxPool<T>>,
}

impl<T> GraphOperation for QuantizedMaxPool<T>
where T: con_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_QINT16_or_DT_QUINT16,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("QuantizedMaxPool_{}")?
        };
        let mut new_op = graph.new_operation("QuantizedMaxPool", &op_name)?;
        {
            (|attrs| {new_op.set_attr_int_list("ksize", attrs)})(&self.ksize)
        }
        {
            (|attrs| {new_op.set_attr_int_list("strides", attrs)})(&self.strides)
        }
        {
            (|attr| {new_op.set_attr_string("padding", attr)})(&self.padding)
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct QuantizedMaxPool<T>
where T: con_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_QINT16_or_DT_QUINT16,
{
    input: Edge<T>,
    min_input: Edge<f32>,
    max_input: Edge<f32>,
    ksize: Vec<i64>,
    strides: Vec<i64>,
    padding: String,
    id_: usize,
}

impl<T> QuantizedMaxPool<T>
where T: con_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_QINT16_or_DT_QUINT16,
{
    pub fn finish(self) -> QuantizedMaxPoolOp<T> {
        QuantizedMaxPoolOp::new(Rc::new(self))
    }

    pub fn new(input: Edge<T>, min_input: Edge<f32>, max_input: Edge<f32>, ksize: &[int], strides: &[int], padding: &str) -> Self {
        Self {
            input,
            min_input,
            max_input,
            ksize: ksize.to_vec()
            strides: strides.to_vec()
            padding: padding.to_string()
            id_: new_id(),
        }
    }
}

impl<Tinput, Tfilter, out_type> QuantizedConv2DOp<Tinput, Tfilter, out_type>
where Tinput: con_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_QINT16_or_DT_QUINT16,
      Tfilter: con_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_QINT16_or_DT_QUINT16,
      out_type: con_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_QINT16_or_DT_QUINT16,
{
    pub fn new(inner: Rc<QuantizedConv2D<Tinput, Tfilter, out_type>>) -> Self {
        Self{inner}
    }

    pub fn output(&self) -> Edge<out_type> {
        Edge::<out_type>::new(self.inner.clone(), 0)
    }

    pub fn min_output(&self) -> Edge<f32> {
        Edge::<f32>::new(self.inner.clone(), 1)
    }

    pub fn max_output(&self) -> Edge<f32> {
        Edge::<f32>::new(self.inner.clone(), 2)
    }
}

struct QuantizedConv2DOp<Tinput, Tfilter, out_type>
where Tinput: con_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_QINT16_or_DT_QUINT16,
      Tfilter: con_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_QINT16_or_DT_QUINT16,
      out_type: con_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_QINT16_or_DT_QUINT16,
{
    inner: Rc<QuantizedConv2D<Tinput, Tfilter, out_type>>,
}

impl<Tinput, Tfilter, out_type> GraphOperation for QuantizedConv2D<Tinput, Tfilter, out_type>
where Tinput: con_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_QINT16_or_DT_QUINT16,
      Tfilter: con_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_QINT16_or_DT_QUINT16,
      out_type: con_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_QINT16_or_DT_QUINT16,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("QuantizedConv2D_{}")?
        };
        let mut new_op = graph.new_operation("QuantizedConv2D", &op_name)?;
        {
            (|attrs| {new_op.set_attr_int_list("strides", attrs)})(&self.strides)
        }
        {
            (|attr| {new_op.set_attr_string("padding", attr)})(&self.padding)
        }
        {
            match self.dilations {
            }
            None => new_op.set_attr_value_proto("dilations", &vec![10_u8, 0_u8, 26_u8, 4_u8,]);,
            Some(value) => (|attrs| {new_op.set_attr_int_list("dilations", attrs)})(&value),
        };
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct QuantizedConv2D<Tinput, Tfilter, out_type>
where Tinput: con_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_QINT16_or_DT_QUINT16,
      Tfilter: con_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_QINT16_or_DT_QUINT16,
      out_type: con_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_QINT16_or_DT_QUINT16,
{
    input: Edge<Tinput>,
    filter: Edge<Tfilter>,
    min_input: Edge<f32>,
    max_input: Edge<f32>,
    min_filter: Edge<f32>,
    max_filter: Edge<f32>,
    strides: Vec<i64>,
    padding: String,
    dilations: Option<Vec<i64>>,
    id_: usize,
}

impl<Tinput, Tfilter, out_type> QuantizedConv2D<Tinput, Tfilter, out_type>
where Tinput: con_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_QINT16_or_DT_QUINT16,
      Tfilter: con_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_QINT16_or_DT_QUINT16,
      out_type: con_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_QINT16_or_DT_QUINT16,
{
    pub fn dilations(&mut self, dilations: &[int]) -> &mut Self {
        self.dilations = Some(dilations.to_vec());
        &self
    }

    pub fn finish(self) -> QuantizedConv2DOp<Tinput, Tfilter, out_type> {
        QuantizedConv2DOp::new(Rc::new(self))
    }

    pub fn new(input: Edge<Tinput>, filter: Edge<Tfilter>, min_input: Edge<f32>, max_input: Edge<f32>, min_filter: Edge<f32>, max_filter: Edge<f32>, strides: &[int], padding: &str) -> Self {
        Self {
            input,
            filter,
            min_input,
            max_input,
            min_filter,
            max_filter,
            strides: strides.to_vec()
            padding: padding.to_string()
            dilations: None,
            id_: new_id(),
        }
    }
}

impl<T1, T2, out_type> QuantizedBiasAddOp<T1, T2, out_type>
where T1: con_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_QINT16_or_DT_QUINT16,
      T2: con_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_QINT16_or_DT_QUINT16,
      out_type: con_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_QINT16_or_DT_QUINT16,
{
    pub fn new(inner: Rc<QuantizedBiasAdd<T1, T2, out_type>>) -> Self {
        Self{inner}
    }

    pub fn output(&self) -> Edge<out_type> {
        Edge::<out_type>::new(self.inner.clone(), 0)
    }

    pub fn min_out(&self) -> Edge<f32> {
        Edge::<f32>::new(self.inner.clone(), 1)
    }

    pub fn max_out(&self) -> Edge<f32> {
        Edge::<f32>::new(self.inner.clone(), 2)
    }
}

struct QuantizedBiasAddOp<T1, T2, out_type>
where T1: con_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_QINT16_or_DT_QUINT16,
      T2: con_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_QINT16_or_DT_QUINT16,
      out_type: con_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_QINT16_or_DT_QUINT16,
{
    inner: Rc<QuantizedBiasAdd<T1, T2, out_type>>,
}

impl<T1, T2, out_type> GraphOperation for QuantizedBiasAdd<T1, T2, out_type>
where T1: con_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_QINT16_or_DT_QUINT16,
      T2: con_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_QINT16_or_DT_QUINT16,
      out_type: con_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_QINT16_or_DT_QUINT16,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("QuantizedBiasAdd_{}")?
        };
        let mut new_op = graph.new_operation("QuantizedBiasAdd", &op_name)?;
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct QuantizedBiasAdd<T1, T2, out_type>
where T1: con_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_QINT16_or_DT_QUINT16,
      T2: con_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_QINT16_or_DT_QUINT16,
      out_type: con_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_QINT16_or_DT_QUINT16,
{
    input: Edge<T1>,
    bias: Edge<T2>,
    min_input: Edge<f32>,
    max_input: Edge<f32>,
    min_bias: Edge<f32>,
    max_bias: Edge<f32>,
    id_: usize,
}

impl<T1, T2, out_type> QuantizedBiasAdd<T1, T2, out_type>
where T1: con_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_QINT16_or_DT_QUINT16,
      T2: con_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_QINT16_or_DT_QUINT16,
      out_type: con_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_QINT16_or_DT_QUINT16,
{
    pub fn finish(self) -> QuantizedBiasAddOp<T1, T2, out_type> {
        QuantizedBiasAddOp::new(Rc::new(self))
    }

    pub fn new(input: Edge<T1>, bias: Edge<T2>, min_input: Edge<f32>, max_input: Edge<f32>, min_bias: Edge<f32>, max_bias: Edge<f32>) -> Self {
        Self {
            input,
            bias,
            min_input,
            max_input,
            min_bias,
            max_bias,
            id_: new_id(),
        }
    }
}

impl<T> QuantizedAvgPoolOp<T>
where T: con_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_QINT16_or_DT_QUINT16,
{
    pub fn new(inner: Rc<QuantizedAvgPool<T>>) -> Self {
        Self{inner}
    }

    pub fn output(&self) -> Edge<T> {
        Edge::<T>::new(self.inner.clone(), 0)
    }

    pub fn min_output(&self) -> Edge<f32> {
        Edge::<f32>::new(self.inner.clone(), 1)
    }

    pub fn max_output(&self) -> Edge<f32> {
        Edge::<f32>::new(self.inner.clone(), 2)
    }
}

struct QuantizedAvgPoolOp<T>
where T: con_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_QINT16_or_DT_QUINT16,
{
    inner: Rc<QuantizedAvgPool<T>>,
}

impl<T> GraphOperation for QuantizedAvgPool<T>
where T: con_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_QINT16_or_DT_QUINT16,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("QuantizedAvgPool_{}")?
        };
        let mut new_op = graph.new_operation("QuantizedAvgPool", &op_name)?;
        {
            (|attrs| {new_op.set_attr_int_list("ksize", attrs)})(&self.ksize)
        }
        {
            (|attrs| {new_op.set_attr_int_list("strides", attrs)})(&self.strides)
        }
        {
            (|attr| {new_op.set_attr_string("padding", attr)})(&self.padding)
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct QuantizedAvgPool<T>
where T: con_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_QINT16_or_DT_QUINT16,
{
    input: Edge<T>,
    min_input: Edge<f32>,
    max_input: Edge<f32>,
    ksize: Vec<i64>,
    strides: Vec<i64>,
    padding: String,
    id_: usize,
}

impl<T> QuantizedAvgPool<T>
where T: con_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_QINT16_or_DT_QUINT16,
{
    pub fn finish(self) -> QuantizedAvgPoolOp<T> {
        QuantizedAvgPoolOp::new(Rc::new(self))
    }

    pub fn new(input: Edge<T>, min_input: Edge<f32>, max_input: Edge<f32>, ksize: &[int], strides: &[int], padding: &str) -> Self {
        Self {
            input,
            min_input,
            max_input,
            ksize: ksize.to_vec()
            strides: strides.to_vec()
            padding: padding.to_string()
            id_: new_id(),
        }
    }
}

impl<T> FractionalAvgPoolGradOp<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_INT64,
{
    pub fn new(inner: Rc<FractionalAvgPoolGrad<T>>) -> Self {
        Self{inner}
    }

    pub fn output(&self) -> Edge<T> {
        Edge::<T>::new(self.inner.clone(), 0)
    }
}

struct FractionalAvgPoolGradOp<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_INT64,
{
    inner: Rc<FractionalAvgPoolGrad<T>>,
}

impl<T> GraphOperation for FractionalAvgPoolGrad<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_INT64,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("FractionalAvgPoolGrad_{}")?
        };
        let mut new_op = graph.new_operation("FractionalAvgPoolGrad", &op_name)?;
        {
            match self.overlapping {
            }
            None => new_op.set_attr_value_proto("overlapping", &vec![40_u8, 0_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_bool("overlapping", *attr)})(&value),
        };
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct FractionalAvgPoolGrad<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_INT64,
{
    orig_input_tensor_shape: Edge<i64>,
    out_backprop: Edge<T>,
    row_pooling_sequence: Edge<i64>,
    col_pooling_sequence: Edge<i64>,
    overlapping: Option<bool>,
    id_: usize,
}

impl<T> FractionalAvgPoolGrad<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_INT64,
{
    pub fn overlapping(&mut self, overlapping: bool) -> &mut Self {
        self.overlapping = Some(overlapping);
        &self
    }

    pub fn finish(self) -> FractionalAvgPoolGradOp<T> {
        FractionalAvgPoolGradOp::new(Rc::new(self))
    }

    pub fn new(orig_input_tensor_shape: Edge<i64>, out_backprop: Edge<T>, row_pooling_sequence: Edge<i64>, col_pooling_sequence: Edge<i64>) -> Self {
        Self {
            orig_input_tensor_shape,
            out_backprop,
            row_pooling_sequence,
            col_pooling_sequence,
            overlapping: None,
            id_: new_id(),
        }
    }
}

impl<T> TopKV2Op<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
{
    pub fn new(inner: Rc<TopKV2<T>>) -> Self {
        Self{inner}
    }

    pub fn values(&self) -> Edge<T> {
        Edge::<T>::new(self.inner.clone(), 0)
    }

    pub fn indices(&self) -> Edge<i32> {
        Edge::<i32>::new(self.inner.clone(), 1)
    }
}

struct TopKV2Op<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
{
    inner: Rc<TopKV2<T>>,
}

impl<T> GraphOperation for TopKV2<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("TopKV2_{}")?
        };
        let mut new_op = graph.new_operation("TopKV2", &op_name)?;
        {
            match self.sorted {
            }
            None => new_op.set_attr_value_proto("sorted", &vec![40_u8, 1_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_bool("sorted", *attr)})(&value),
        };
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct TopKV2<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
{
    input: Edge<T>,
    k: Edge<i32>,
    sorted: Option<bool>,
    id_: usize,
}

impl<T> TopKV2<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
{
    pub fn sorted(&mut self, sorted: bool) -> &mut Self {
        self.sorted = Some(sorted);
        &self
    }

    pub fn finish(self) -> TopKV2Op<T> {
        TopKV2Op::new(Rc::new(self))
    }

    pub fn new(input: Edge<T>, k: Edge<i32>) -> Self {
        Self {
            input,
            k,
            sorted: None,
            id_: new_id(),
        }
    }
}

impl<T> ApplyProximalGradientDescentOp<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
{
    pub fn new(inner: Rc<ApplyProximalGradientDescent<T>>) -> Self {
        Self{inner}
    }

    pub fn out(&self) -> Edge<T> {
        Edge::<T>::new(self.inner.clone(), 0)
    }
}

struct ApplyProximalGradientDescentOp<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
{
    inner: Rc<ApplyProximalGradientDescent<T>>,
}

impl<T> GraphOperation for ApplyProximalGradientDescent<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("ApplyProximalGradientDescent_{}")?
        };
        let mut new_op = graph.new_operation("ApplyProximalGradientDescent", &op_name)?;
        {
            match self.use_locking {
            }
            None => new_op.set_attr_value_proto("use_locking", &vec![40_u8, 0_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_bool("use_locking", *attr)})(&value),
        };
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct ApplyProximalGradientDescent<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
{
    var: Edge<T>,
    alpha: Edge<T>,
    l1: Edge<T>,
    l2: Edge<T>,
    delta: Edge<T>,
    use_locking: Option<bool>,
    id_: usize,
}

impl<T> ApplyProximalGradientDescent<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
{
    pub fn use_locking(&mut self, use_locking: bool) -> &mut Self {
        self.use_locking = Some(use_locking);
        &self
    }

    pub fn finish(self) -> ApplyProximalGradientDescentOp<T> {
        ApplyProximalGradientDescentOp::new(Rc::new(self))
    }

    pub fn new(var: Edge<T>, alpha: Edge<T>, l1: Edge<T>, l2: Edge<T>, delta: Edge<T>) -> Self {
        Self {
            var,
            alpha,
            l1,
            l2,
            delta,
            use_locking: None,
            id_: new_id(),
        }
    }
}

impl<T> TopKOp<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
{
    pub fn new(inner: Rc<TopK<T>>) -> Self {
        Self{inner}
    }

    pub fn values(&self) -> Edge<T> {
        Edge::<T>::new(self.inner.clone(), 0)
    }

    pub fn indices(&self) -> Edge<i32> {
        Edge::<i32>::new(self.inner.clone(), 1)
    }
}

struct TopKOp<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
{
    inner: Rc<TopK<T>>,
}

impl<T> GraphOperation for TopK<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("TopK_{}")?
        };
        let mut new_op = graph.new_operation("TopK", &op_name)?;
        {
            (|attr| {new_op.set_attr_int("k", *attr)})(&self.k)
        }
        {
            match self.sorted {
            }
            None => new_op.set_attr_value_proto("sorted", &vec![40_u8, 1_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_bool("sorted", *attr)})(&value),
        };
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct TopK<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
{
    input: Edge<T>,
    k: i64,
    sorted: Option<bool>,
    id_: usize,
}

impl<T> TopK<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
{
    pub fn sorted(&mut self, sorted: bool) -> &mut Self {
        self.sorted = Some(sorted);
        &self
    }

    pub fn finish(self) -> TopKOp<T> {
        TopKOp::new(Rc::new(self))
    }

    pub fn new(input: Edge<T>, k: int) -> Self {
        Self {
            input,
            k: k
            sorted: None,
            id_: new_id(),
        }
    }
}

impl<T> InTopKV2Op<T>
where T: con_or_DT_INT32_or_DT_INT64,
{
    pub fn new(inner: Rc<InTopKV2<T>>) -> Self {
        Self{inner}
    }

    pub fn precision(&self) -> Edge<bool> {
        Edge::<bool>::new(self.inner.clone(), 0)
    }
}

struct InTopKV2Op<T>
where T: con_or_DT_INT32_or_DT_INT64,
{
    inner: Rc<InTopKV2<T>>,
}

impl<T> GraphOperation for InTopKV2<T>
where T: con_or_DT_INT32_or_DT_INT64,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("InTopKV2_{}")?
        };
        let mut new_op = graph.new_operation("InTopKV2", &op_name)?;
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct InTopKV2<T>
where T: con_or_DT_INT32_or_DT_INT64,
{
    predictions: Edge<f32>,
    targets: Edge<T>,
    k: Edge<T>,
    id_: usize,
}

impl<T> InTopKV2<T>
where T: con_or_DT_INT32_or_DT_INT64,
{
    pub fn finish(self) -> InTopKV2Op<T> {
        InTopKV2Op::new(Rc::new(self))
    }

    pub fn new(predictions: Edge<f32>, targets: Edge<T>, k: Edge<T>) -> Self {
        Self {
            predictions,
            targets,
            k,
            id_: new_id(),
        }
    }
}

impl<T> InTopKOp<T>
where T: con_or_DT_INT32_or_DT_INT64,
{
    pub fn new(inner: Rc<InTopK<T>>) -> Self {
        Self{inner}
    }

    pub fn precision(&self) -> Edge<bool> {
        Edge::<bool>::new(self.inner.clone(), 0)
    }
}

struct InTopKOp<T>
where T: con_or_DT_INT32_or_DT_INT64,
{
    inner: Rc<InTopK<T>>,
}

impl<T> GraphOperation for InTopK<T>
where T: con_or_DT_INT32_or_DT_INT64,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("InTopK_{}")?
        };
        let mut new_op = graph.new_operation("InTopK", &op_name)?;
        {
            (|attr| {new_op.set_attr_int("k", *attr)})(&self.k)
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct InTopK<T>
where T: con_or_DT_INT32_or_DT_INT64,
{
    predictions: Edge<f32>,
    targets: Edge<T>,
    k: i64,
    id_: usize,
}

impl<T> InTopK<T>
where T: con_or_DT_INT32_or_DT_INT64,
{
    pub fn finish(self) -> InTopKOp<T> {
        InTopKOp::new(Rc::new(self))
    }

    pub fn new(predictions: Edge<f32>, targets: Edge<T>, k: int) -> Self {
        Self {
            predictions,
            targets,
            k: k
            id_: new_id(),
        }
    }
}

impl<T, Tlabels> SparseSoftmaxCrossEntropyWithLogitsOp<T, Tlabels>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
      Tlabels: con_or_DT_INT32_or_DT_INT64,
{
    pub fn new(inner: Rc<SparseSoftmaxCrossEntropyWithLogits<T, Tlabels>>) -> Self {
        Self{inner}
    }

    pub fn loss(&self) -> Edge<T> {
        Edge::<T>::new(self.inner.clone(), 0)
    }

    pub fn backprop(&self) -> Edge<T> {
        Edge::<T>::new(self.inner.clone(), 1)
    }
}

struct SparseSoftmaxCrossEntropyWithLogitsOp<T, Tlabels>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
      Tlabels: con_or_DT_INT32_or_DT_INT64,
{
    inner: Rc<SparseSoftmaxCrossEntropyWithLogits<T, Tlabels>>,
}

impl<T, Tlabels> GraphOperation for SparseSoftmaxCrossEntropyWithLogits<T, Tlabels>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
      Tlabels: con_or_DT_INT32_or_DT_INT64,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("SparseSoftmaxCrossEntropyWithLogits_{}")?
        };
        let mut new_op = graph.new_operation("SparseSoftmaxCrossEntropyWithLogits", &op_name)?;
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct SparseSoftmaxCrossEntropyWithLogits<T, Tlabels>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
      Tlabels: con_or_DT_INT32_or_DT_INT64,
{
    features: Edge<T>,
    labels: Edge<Tlabels>,
    id_: usize,
}

impl<T, Tlabels> SparseSoftmaxCrossEntropyWithLogits<T, Tlabels>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
      Tlabels: con_or_DT_INT32_or_DT_INT64,
{
    pub fn finish(self) -> SparseSoftmaxCrossEntropyWithLogitsOp<T, Tlabels> {
        SparseSoftmaxCrossEntropyWithLogitsOp::new(Rc::new(self))
    }

    pub fn new(features: Edge<T>, labels: Edge<Tlabels>) -> Self {
        Self {
            features,
            labels,
            id_: new_id(),
        }
    }
}

impl<T> SoftmaxCrossEntropyWithLogitsOp<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
{
    pub fn new(inner: Rc<SoftmaxCrossEntropyWithLogits<T>>) -> Self {
        Self{inner}
    }

    pub fn loss(&self) -> Edge<T> {
        Edge::<T>::new(self.inner.clone(), 0)
    }

    pub fn backprop(&self) -> Edge<T> {
        Edge::<T>::new(self.inner.clone(), 1)
    }
}

struct SoftmaxCrossEntropyWithLogitsOp<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
{
    inner: Rc<SoftmaxCrossEntropyWithLogits<T>>,
}

impl<T> GraphOperation for SoftmaxCrossEntropyWithLogits<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("SoftmaxCrossEntropyWithLogits_{}")?
        };
        let mut new_op = graph.new_operation("SoftmaxCrossEntropyWithLogits", &op_name)?;
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct SoftmaxCrossEntropyWithLogits<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
{
    features: Edge<T>,
    labels: Edge<T>,
    id_: usize,
}

impl<T> SoftmaxCrossEntropyWithLogits<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
{
    pub fn finish(self) -> SoftmaxCrossEntropyWithLogitsOp<T> {
        SoftmaxCrossEntropyWithLogitsOp::new(Rc::new(self))
    }

    pub fn new(features: Edge<T>, labels: Edge<T>) -> Self {
        Self {
            features,
            labels,
            id_: new_id(),
        }
    }
}

impl<T> SoftmaxOp<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
{
    pub fn new(inner: Rc<Softmax<T>>) -> Self {
        Self{inner}
    }

    pub fn softmax(&self) -> Edge<T> {
        Edge::<T>::new(self.inner.clone(), 0)
    }
}

struct SoftmaxOp<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
{
    inner: Rc<Softmax<T>>,
}

impl<T> GraphOperation for Softmax<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("Softmax_{}")?
        };
        let mut new_op = graph.new_operation("Softmax", &op_name)?;
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct Softmax<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
{
    logits: Edge<T>,
    id_: usize,
}

impl<T> Softmax<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
{
    pub fn finish(self) -> SoftmaxOp<T> {
        SoftmaxOp::new(Rc::new(self))
    }

    pub fn new(logits: Edge<T>) -> Self {
        Self {
            logits,
            id_: new_id(),
        }
    }
}

impl<T> SoftsignGradOp<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
{
    pub fn new(inner: Rc<SoftsignGrad<T>>) -> Self {
        Self{inner}
    }

    pub fn backprops(&self) -> Edge<T> {
        Edge::<T>::new(self.inner.clone(), 0)
    }
}

struct SoftsignGradOp<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
{
    inner: Rc<SoftsignGrad<T>>,
}

impl<T> GraphOperation for SoftsignGrad<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("SoftsignGrad_{}")?
        };
        let mut new_op = graph.new_operation("SoftsignGrad", &op_name)?;
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct SoftsignGrad<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
{
    gradients: Edge<T>,
    features: Edge<T>,
    id_: usize,
}

impl<T> SoftsignGrad<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
{
    pub fn finish(self) -> SoftsignGradOp<T> {
        SoftsignGradOp::new(Rc::new(self))
    }

    pub fn new(gradients: Edge<T>, features: Edge<T>) -> Self {
        Self {
            gradients,
            features,
            id_: new_id(),
        }
    }
}

impl<T> SetSizeOp<T>
where T: con_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_STRING_or_DT_INT64_or_DT_UINT16,
{
    pub fn new(inner: Rc<SetSize<T>>) -> Self {
        Self{inner}
    }

    pub fn size(&self) -> Edge<i32> {
        Edge::<i32>::new(self.inner.clone(), 0)
    }
}

struct SetSizeOp<T>
where T: con_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_STRING_or_DT_INT64_or_DT_UINT16,
{
    inner: Rc<SetSize<T>>,
}

impl<T> GraphOperation for SetSize<T>
where T: con_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_STRING_or_DT_INT64_or_DT_UINT16,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("SetSize_{}")?
        };
        let mut new_op = graph.new_operation("SetSize", &op_name)?;
        {
            match self.validate_indices {
            }
            None => new_op.set_attr_value_proto("validate_indices", &vec![40_u8, 1_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_bool("validate_indices", *attr)})(&value),
        };
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct SetSize<T>
where T: con_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_STRING_or_DT_INT64_or_DT_UINT16,
{
    set_indices: Edge<i64>,
    set_values: Edge<T>,
    set_shape: Edge<i64>,
    validate_indices: Option<bool>,
    id_: usize,
}

impl<T> SetSize<T>
where T: con_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_STRING_or_DT_INT64_or_DT_UINT16,
{
    pub fn validate_indices(&mut self, validate_indices: bool) -> &mut Self {
        self.validate_indices = Some(validate_indices);
        &self
    }

    pub fn finish(self) -> SetSizeOp<T> {
        SetSizeOp::new(Rc::new(self))
    }

    pub fn new(set_indices: Edge<i64>, set_values: Edge<T>, set_shape: Edge<i64>) -> Self {
        Self {
            set_indices,
            set_values,
            set_shape,
            validate_indices: None,
            id_: new_id(),
        }
    }
}

impl<T> SeluOp<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
{
    pub fn new(inner: Rc<Selu<T>>) -> Self {
        Self{inner}
    }

    pub fn activations(&self) -> Edge<T> {
        Edge::<T>::new(self.inner.clone(), 0)
    }
}

struct SeluOp<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
{
    inner: Rc<Selu<T>>,
}

impl<T> GraphOperation for Selu<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("Selu_{}")?
        };
        let mut new_op = graph.new_operation("Selu", &op_name)?;
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct Selu<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
{
    features: Edge<T>,
    id_: usize,
}

impl<T> Selu<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
{
    pub fn finish(self) -> SeluOp<T> {
        SeluOp::new(Rc::new(self))
    }

    pub fn new(features: Edge<T>) -> Self {
        Self {
            features,
            id_: new_id(),
        }
    }
}

impl StaticRegexReplaceOp {
    pub fn new(inner: Rc<StaticRegexReplace>) -> Self {
        Self{inner}
    }

    pub fn output(&self) -> Edge<String> {
        Edge::<String>::new(self.inner.clone(), 0)
    }
}

struct StaticRegexReplaceOp {
    inner: Rc<StaticRegexReplace>,
}

impl GraphOperation for StaticRegexReplace {
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("StaticRegexReplace_{}")?
        };
        let mut new_op = graph.new_operation("StaticRegexReplace", &op_name)?;
        {
            (|attr| {new_op.set_attr_string("pattern", attr)})(&self.pattern)
        }
        {
            (|attr| {new_op.set_attr_string("rewrite", attr)})(&self.rewrite)
        }
        {
            match self.replace_global {
            }
            None => new_op.set_attr_value_proto("replace_global", &vec![40_u8, 1_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_bool("replace_global", *attr)})(&value),
        };
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct StaticRegexReplace {
    input: Edge<String>,
    pattern: String,
    rewrite: String,
    replace_global: Option<bool>,
    id_: usize,
}

impl StaticRegexReplace {
    pub fn replace_global(&mut self, replace_global: bool) -> &mut Self {
        self.replace_global = Some(replace_global);
        &self
    }

    pub fn finish(self) -> StaticRegexReplaceOp {
        StaticRegexReplaceOp::new(Rc::new(self))
    }

    pub fn new(input: Edge<String>, pattern: &str, rewrite: &str) -> Self {
        Self {
            input,
            pattern: pattern.to_string()
            rewrite: rewrite.to_string()
            replace_global: None,
            id_: new_id(),
        }
    }
}

impl<T> EluGradOp<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
{
    pub fn new(inner: Rc<EluGrad<T>>) -> Self {
        Self{inner}
    }

    pub fn backprops(&self) -> Edge<T> {
        Edge::<T>::new(self.inner.clone(), 0)
    }
}

struct EluGradOp<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
{
    inner: Rc<EluGrad<T>>,
}

impl<T> GraphOperation for EluGrad<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("EluGrad_{}")?
        };
        let mut new_op = graph.new_operation("EluGrad", &op_name)?;
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct EluGrad<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
{
    gradients: Edge<T>,
    outputs: Edge<T>,
    id_: usize,
}

impl<T> EluGrad<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
{
    pub fn finish(self) -> EluGradOp<T> {
        EluGradOp::new(Rc::new(self))
    }

    pub fn new(gradients: Edge<T>, outputs: Edge<T>) -> Self {
        Self {
            gradients,
            outputs,
            id_: new_id(),
        }
    }
}

impl<T> EluOp<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
{
    pub fn new(inner: Rc<Elu<T>>) -> Self {
        Self{inner}
    }

    pub fn activations(&self) -> Edge<T> {
        Edge::<T>::new(self.inner.clone(), 0)
    }
}

struct EluOp<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
{
    inner: Rc<Elu<T>>,
}

impl<T> GraphOperation for Elu<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("Elu_{}")?
        };
        let mut new_op = graph.new_operation("Elu", &op_name)?;
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct Elu<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
{
    features: Edge<T>,
    id_: usize,
}

impl<T> Elu<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
{
    pub fn finish(self) -> EluOp<T> {
        EluOp::new(Rc::new(self))
    }

    pub fn new(features: Edge<T>) -> Self {
        Self {
            features,
            id_: new_id(),
        }
    }
}

impl<T> LeakyReluGradOp<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
{
    pub fn new(inner: Rc<LeakyReluGrad<T>>) -> Self {
        Self{inner}
    }

    pub fn backprops(&self) -> Edge<T> {
        Edge::<T>::new(self.inner.clone(), 0)
    }
}

struct LeakyReluGradOp<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
{
    inner: Rc<LeakyReluGrad<T>>,
}

impl<T> GraphOperation for LeakyReluGrad<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("LeakyReluGrad_{}")?
        };
        let mut new_op = graph.new_operation("LeakyReluGrad", &op_name)?;
        {
            match self.alpha {
            }
            None => new_op.set_attr_value_proto("alpha", &vec![37_u8, 205_u8, 204_u8, 76_u8, 62_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_float("alpha", *attr)})(&value),
        };
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct LeakyReluGrad<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
{
    gradients: Edge<T>,
    features: Edge<T>,
    alpha: Option<f32>,
    id_: usize,
}

impl<T> LeakyReluGrad<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
{
    pub fn alpha(&mut self, alpha: f32) -> &mut Self {
        self.alpha = Some(alpha);
        &self
    }

    pub fn finish(self) -> LeakyReluGradOp<T> {
        LeakyReluGradOp::new(Rc::new(self))
    }

    pub fn new(gradients: Edge<T>, features: Edge<T>) -> Self {
        Self {
            gradients,
            features,
            alpha: None,
            id_: new_id(),
        }
    }
}

impl<T> LeakyReluOp<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
{
    pub fn new(inner: Rc<LeakyRelu<T>>) -> Self {
        Self{inner}
    }

    pub fn activations(&self) -> Edge<T> {
        Edge::<T>::new(self.inner.clone(), 0)
    }
}

struct LeakyReluOp<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
{
    inner: Rc<LeakyRelu<T>>,
}

impl<T> GraphOperation for LeakyRelu<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("LeakyRelu_{}")?
        };
        let mut new_op = graph.new_operation("LeakyRelu", &op_name)?;
        {
            match self.alpha {
            }
            None => new_op.set_attr_value_proto("alpha", &vec![37_u8, 205_u8, 204_u8, 76_u8, 62_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_float("alpha", *attr)})(&value),
        };
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct LeakyRelu<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
{
    features: Edge<T>,
    alpha: Option<f32>,
    id_: usize,
}

impl<T> LeakyRelu<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
{
    pub fn alpha(&mut self, alpha: f32) -> &mut Self {
        self.alpha = Some(alpha);
        &self
    }

    pub fn finish(self) -> LeakyReluOp<T> {
        LeakyReluOp::new(Rc::new(self))
    }

    pub fn new(features: Edge<T>) -> Self {
        Self {
            features,
            alpha: None,
            id_: new_id(),
        }
    }
}

impl<T> Relu6GradOp<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
{
    pub fn new(inner: Rc<Relu6Grad<T>>) -> Self {
        Self{inner}
    }

    pub fn backprops(&self) -> Edge<T> {
        Edge::<T>::new(self.inner.clone(), 0)
    }
}

struct Relu6GradOp<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
{
    inner: Rc<Relu6Grad<T>>,
}

impl<T> GraphOperation for Relu6Grad<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("Relu6Grad_{}")?
        };
        let mut new_op = graph.new_operation("Relu6Grad", &op_name)?;
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct Relu6Grad<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
{
    gradients: Edge<T>,
    features: Edge<T>,
    id_: usize,
}

impl<T> Relu6Grad<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
{
    pub fn finish(self) -> Relu6GradOp<T> {
        Relu6GradOp::new(Rc::new(self))
    }

    pub fn new(gradients: Edge<T>, features: Edge<T>) -> Self {
        Self {
            gradients,
            features,
            id_: new_id(),
        }
    }
}

impl<T> Relu6Op<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
{
    pub fn new(inner: Rc<Relu6<T>>) -> Self {
        Self{inner}
    }

    pub fn activations(&self) -> Edge<T> {
        Edge::<T>::new(self.inner.clone(), 0)
    }
}

struct Relu6Op<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
{
    inner: Rc<Relu6<T>>,
}

impl<T> GraphOperation for Relu6<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("Relu6_{}")?
        };
        let mut new_op = graph.new_operation("Relu6", &op_name)?;
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct Relu6<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
{
    features: Edge<T>,
    id_: usize,
}

impl<T> Relu6<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
{
    pub fn finish(self) -> Relu6Op<T> {
        Relu6Op::new(Rc::new(self))
    }

    pub fn new(features: Edge<T>) -> Self {
        Self {
            features,
            id_: new_id(),
        }
    }
}

impl<T> ReluGradOp<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
{
    pub fn new(inner: Rc<ReluGrad<T>>) -> Self {
        Self{inner}
    }

    pub fn backprops(&self) -> Edge<T> {
        Edge::<T>::new(self.inner.clone(), 0)
    }
}

struct ReluGradOp<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
{
    inner: Rc<ReluGrad<T>>,
}

impl<T> GraphOperation for ReluGrad<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("ReluGrad_{}")?
        };
        let mut new_op = graph.new_operation("ReluGrad", &op_name)?;
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct ReluGrad<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
{
    gradients: Edge<T>,
    features: Edge<T>,
    id_: usize,
}

impl<T> ReluGrad<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
{
    pub fn finish(self) -> ReluGradOp<T> {
        ReluGradOp::new(Rc::new(self))
    }

    pub fn new(gradients: Edge<T>, features: Edge<T>) -> Self {
        Self {
            gradients,
            features,
            id_: new_id(),
        }
    }
}

pub trait con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_QINT8_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_QINT8_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64 for BFloat16 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_QINT8_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64 for f32 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_QINT8_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64 for f64 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_QINT8_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64 for i16 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_QINT8_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64 for i32 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_QINT8_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64 for i64 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_QINT8_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64 for i8 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_QINT8_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64 for u16 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_QINT8_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64 for u32 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_QINT8_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64 for u64 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_QINT8_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64 for u8 {
}

impl<T> ReluOp<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_QINT8_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
{
    pub fn new(inner: Rc<Relu<T>>) -> Self {
        Self{inner}
    }

    pub fn activations(&self) -> Edge<T> {
        Edge::<T>::new(self.inner.clone(), 0)
    }
}

struct ReluOp<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_QINT8_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
{
    inner: Rc<Relu<T>>,
}

impl<T> GraphOperation for Relu<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_QINT8_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("Relu_{}")?
        };
        let mut new_op = graph.new_operation("Relu", &op_name)?;
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct Relu<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_QINT8_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
{
    features: Edge<T>,
    id_: usize,
}

impl<T> Relu<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_QINT8_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
{
    pub fn finish(self) -> ReluOp<T> {
        ReluOp::new(Rc::new(self))
    }

    pub fn new(features: Edge<T>) -> Self {
        Self {
            features,
            id_: new_id(),
        }
    }
}

impl<T> Dilation2DBackpropInputOp<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
{
    pub fn new(inner: Rc<Dilation2DBackpropInput<T>>) -> Self {
        Self{inner}
    }

    pub fn in_backprop(&self) -> Edge<T> {
        Edge::<T>::new(self.inner.clone(), 0)
    }
}

struct Dilation2DBackpropInputOp<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
{
    inner: Rc<Dilation2DBackpropInput<T>>,
}

impl<T> GraphOperation for Dilation2DBackpropInput<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("Dilation2DBackpropInput_{}")?
        };
        let mut new_op = graph.new_operation("Dilation2DBackpropInput", &op_name)?;
        {
            (|attrs| {new_op.set_attr_int_list("strides", attrs)})(&self.strides)
        }
        {
            (|attrs| {new_op.set_attr_int_list("rates", attrs)})(&self.rates)
        }
        {
            (|attr| {new_op.set_attr_string("padding", attr)})(&self.padding)
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct Dilation2DBackpropInput<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
{
    input: Edge<T>,
    filter: Edge<T>,
    out_backprop: Edge<T>,
    strides: Vec<i64>,
    rates: Vec<i64>,
    padding: String,
    id_: usize,
}

impl<T> Dilation2DBackpropInput<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
{
    pub fn finish(self) -> Dilation2DBackpropInputOp<T> {
        Dilation2DBackpropInputOp::new(Rc::new(self))
    }

    pub fn new(input: Edge<T>, filter: Edge<T>, out_backprop: Edge<T>, strides: &[int], rates: &[int], padding: &str) -> Self {
        Self {
            input,
            filter,
            out_backprop,
            strides: strides.to_vec()
            rates: rates.to_vec()
            padding: padding.to_string()
            id_: new_id(),
        }
    }
}

impl<T, Targmax> MaxPoolGradGradWithArgmaxOp<T, Targmax>
where Targmax: con_or_DT_INT32_or_DT_INT64,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
{
    pub fn new(inner: Rc<MaxPoolGradGradWithArgmax<T, Targmax>>) -> Self {
        Self{inner}
    }

    pub fn output(&self) -> Edge<T> {
        Edge::<T>::new(self.inner.clone(), 0)
    }
}

struct MaxPoolGradGradWithArgmaxOp<T, Targmax>
where Targmax: con_or_DT_INT32_or_DT_INT64,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
{
    inner: Rc<MaxPoolGradGradWithArgmax<T, Targmax>>,
}

impl<T, Targmax> GraphOperation for MaxPoolGradGradWithArgmax<T, Targmax>
where Targmax: con_or_DT_INT32_or_DT_INT64,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("MaxPoolGradGradWithArgmax_{}")?
        };
        let mut new_op = graph.new_operation("MaxPoolGradGradWithArgmax", &op_name)?;
        {
            (|attrs| {new_op.set_attr_int_list("ksize", attrs)})(&self.ksize)
        }
        {
            (|attrs| {new_op.set_attr_int_list("strides", attrs)})(&self.strides)
        }
        {
            (|attr| {new_op.set_attr_string("padding", attr)})(&self.padding)
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct MaxPoolGradGradWithArgmax<T, Targmax>
where Targmax: con_or_DT_INT32_or_DT_INT64,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
{
    input: Edge<T>,
    grad: Edge<T>,
    argmax: Edge<Targmax>,
    ksize: Vec<i64>,
    strides: Vec<i64>,
    padding: String,
    id_: usize,
}

impl<T, Targmax> MaxPoolGradGradWithArgmax<T, Targmax>
where Targmax: con_or_DT_INT32_or_DT_INT64,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
{
    pub fn finish(self) -> MaxPoolGradGradWithArgmaxOp<T, Targmax> {
        MaxPoolGradGradWithArgmaxOp::new(Rc::new(self))
    }

    pub fn new(input: Edge<T>, grad: Edge<T>, argmax: Edge<Targmax>, ksize: &[int], strides: &[int], padding: &str) -> Self {
        Self {
            input,
            grad,
            argmax,
            ksize: ksize.to_vec()
            strides: strides.to_vec()
            padding: padding.to_string()
            id_: new_id(),
        }
    }
}

impl<T, Targmax> MaxPoolGradWithArgmaxOp<T, Targmax>
where Targmax: con_or_DT_INT32_or_DT_INT64,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
{
    pub fn new(inner: Rc<MaxPoolGradWithArgmax<T, Targmax>>) -> Self {
        Self{inner}
    }

    pub fn output(&self) -> Edge<T> {
        Edge::<T>::new(self.inner.clone(), 0)
    }
}

struct MaxPoolGradWithArgmaxOp<T, Targmax>
where Targmax: con_or_DT_INT32_or_DT_INT64,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
{
    inner: Rc<MaxPoolGradWithArgmax<T, Targmax>>,
}

impl<T, Targmax> GraphOperation for MaxPoolGradWithArgmax<T, Targmax>
where Targmax: con_or_DT_INT32_or_DT_INT64,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("MaxPoolGradWithArgmax_{}")?
        };
        let mut new_op = graph.new_operation("MaxPoolGradWithArgmax", &op_name)?;
        {
            (|attrs| {new_op.set_attr_int_list("ksize", attrs)})(&self.ksize)
        }
        {
            (|attrs| {new_op.set_attr_int_list("strides", attrs)})(&self.strides)
        }
        {
            (|attr| {new_op.set_attr_string("padding", attr)})(&self.padding)
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct MaxPoolGradWithArgmax<T, Targmax>
where Targmax: con_or_DT_INT32_or_DT_INT64,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
{
    input: Edge<T>,
    grad: Edge<T>,
    argmax: Edge<Targmax>,
    ksize: Vec<i64>,
    strides: Vec<i64>,
    padding: String,
    id_: usize,
}

impl<T, Targmax> MaxPoolGradWithArgmax<T, Targmax>
where Targmax: con_or_DT_INT32_or_DT_INT64,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
{
    pub fn finish(self) -> MaxPoolGradWithArgmaxOp<T, Targmax> {
        MaxPoolGradWithArgmaxOp::new(Rc::new(self))
    }

    pub fn new(input: Edge<T>, grad: Edge<T>, argmax: Edge<Targmax>, ksize: &[int], strides: &[int], padding: &str) -> Self {
        Self {
            input,
            grad,
            argmax,
            ksize: ksize.to_vec()
            strides: strides.to_vec()
            padding: padding.to_string()
            id_: new_id(),
        }
    }
}

impl<out_type> ParseTensorOp<out_type>
where out_type: con,
{
    pub fn new(inner: Rc<ParseTensor<out_type>>) -> Self {
        Self{inner}
    }

    pub fn output(&self) -> Edge<out_type> {
        Edge::<out_type>::new(self.inner.clone(), 0)
    }
}

struct ParseTensorOp<out_type>
where out_type: con,
{
    inner: Rc<ParseTensor<out_type>>,
}

impl<out_type> GraphOperation for ParseTensor<out_type>
where out_type: con,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("ParseTensor_{}")?
        };
        let mut new_op = graph.new_operation("ParseTensor", &op_name)?;
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct ParseTensor<out_type>
where out_type: con,
{
    serialized: Edge<String>,
    id_: usize,
}

impl<out_type> ParseTensor<out_type>
where out_type: con,
{
    pub fn finish(self) -> ParseTensorOp<out_type> {
        ParseTensorOp::new(Rc::new(self))
    }

    pub fn new(serialized: Edge<String>) -> Self {
        Self {
            serialized,
            id_: new_id(),
        }
    }
}

impl<T, Targmax> MaxPoolWithArgmaxOp<T, Targmax>
where Targmax: con_or_DT_INT32_or_DT_INT64,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
{
    pub fn new(inner: Rc<MaxPoolWithArgmax<T, Targmax>>) -> Self {
        Self{inner}
    }

    pub fn output(&self) -> Edge<T> {
        Edge::<T>::new(self.inner.clone(), 0)
    }

    pub fn argmax(&self) -> Edge<Targmax> {
        Edge::<Targmax>::new(self.inner.clone(), 1)
    }
}

struct MaxPoolWithArgmaxOp<T, Targmax>
where Targmax: con_or_DT_INT32_or_DT_INT64,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
{
    inner: Rc<MaxPoolWithArgmax<T, Targmax>>,
}

impl<T, Targmax> GraphOperation for MaxPoolWithArgmax<T, Targmax>
where Targmax: con_or_DT_INT32_or_DT_INT64,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("MaxPoolWithArgmax_{}")?
        };
        let mut new_op = graph.new_operation("MaxPoolWithArgmax", &op_name)?;
        {
            (|attrs| {new_op.set_attr_int_list("ksize", attrs)})(&self.ksize)
        }
        {
            (|attrs| {new_op.set_attr_int_list("strides", attrs)})(&self.strides)
        }
        {
            (|attr| {new_op.set_attr_string("padding", attr)})(&self.padding)
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct MaxPoolWithArgmax<T, Targmax>
where Targmax: con_or_DT_INT32_or_DT_INT64,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
{
    input: Edge<T>,
    ksize: Vec<i64>,
    strides: Vec<i64>,
    padding: String,
    id_: usize,
}

impl<T, Targmax> MaxPoolWithArgmax<T, Targmax>
where Targmax: con_or_DT_INT32_or_DT_INT64,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
{
    pub fn finish(self) -> MaxPoolWithArgmaxOp<T, Targmax> {
        MaxPoolWithArgmaxOp::new(Rc::new(self))
    }

    pub fn new(input: Edge<T>, ksize: &[int], strides: &[int], padding: &str) -> Self {
        Self {
            input,
            ksize: ksize.to_vec()
            strides: strides.to_vec()
            padding: padding.to_string()
            id_: new_id(),
        }
    }
}

impl<T> MaxPoolGradGradV2Op<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
{
    pub fn new(inner: Rc<MaxPoolGradGradV2<T>>) -> Self {
        Self{inner}
    }

    pub fn output(&self) -> Edge<T> {
        Edge::<T>::new(self.inner.clone(), 0)
    }
}

struct MaxPoolGradGradV2Op<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
{
    inner: Rc<MaxPoolGradGradV2<T>>,
}

impl<T> GraphOperation for MaxPoolGradGradV2<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("MaxPoolGradGradV2_{}")?
        };
        let mut new_op = graph.new_operation("MaxPoolGradGradV2", &op_name)?;
        {
            (|attr| {new_op.set_attr_string("padding", attr)})(&self.padding)
        }
        {
            match self.data_format {
            }
            None => new_op.set_attr_value_proto("data_format", &vec![18_u8, 4_u8, 78_u8, 72_u8, 87_u8, 67_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_string("data_format", attr)})(&value),
        };
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct MaxPoolGradGradV2<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
{
    orig_input: Edge<T>,
    orig_output: Edge<T>,
    grad: Edge<T>,
    ksize: Edge<i32>,
    strides: Edge<i32>,
    padding: String,
    data_format: Option<String>,
    id_: usize,
}

impl<T> MaxPoolGradGradV2<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
{
    pub fn data_format(&mut self, data_format: &str) -> &mut Self {
        self.data_format = Some(data_format.to_string());
        &self
    }

    pub fn finish(self) -> MaxPoolGradGradV2Op<T> {
        MaxPoolGradGradV2Op::new(Rc::new(self))
    }

    pub fn new(orig_input: Edge<T>, orig_output: Edge<T>, grad: Edge<T>, ksize: Edge<i32>, strides: Edge<i32>, padding: &str) -> Self {
        Self {
            orig_input,
            orig_output,
            grad,
            ksize,
            strides,
            padding: padding.to_string()
            data_format: None,
            id_: new_id(),
        }
    }
}

impl<T> MaxPoolGradOp<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
{
    pub fn new(inner: Rc<MaxPoolGrad<T>>) -> Self {
        Self{inner}
    }

    pub fn output(&self) -> Edge<T> {
        Edge::<T>::new(self.inner.clone(), 0)
    }
}

struct MaxPoolGradOp<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
{
    inner: Rc<MaxPoolGrad<T>>,
}

impl<T> GraphOperation for MaxPoolGrad<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("MaxPoolGrad_{}")?
        };
        let mut new_op = graph.new_operation("MaxPoolGrad", &op_name)?;
        {
            (|attrs| {new_op.set_attr_int_list("ksize", attrs)})(&self.ksize)
        }
        {
            (|attrs| {new_op.set_attr_int_list("strides", attrs)})(&self.strides)
        }
        {
            (|attr| {new_op.set_attr_string("padding", attr)})(&self.padding)
        }
        {
            match self.data_format {
            }
            None => new_op.set_attr_value_proto("data_format", &vec![18_u8, 4_u8, 78_u8, 72_u8, 87_u8, 67_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_string("data_format", attr)})(&value),
        };
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct MaxPoolGrad<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
{
    orig_input: Edge<T>,
    orig_output: Edge<T>,
    grad: Edge<T>,
    ksize: Vec<i64>,
    strides: Vec<i64>,
    padding: String,
    data_format: Option<String>,
    id_: usize,
}

impl<T> MaxPoolGrad<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
{
    pub fn data_format(&mut self, data_format: &str) -> &mut Self {
        self.data_format = Some(data_format.to_string());
        &self
    }

    pub fn finish(self) -> MaxPoolGradOp<T> {
        MaxPoolGradOp::new(Rc::new(self))
    }

    pub fn new(orig_input: Edge<T>, orig_output: Edge<T>, grad: Edge<T>, ksize: &[int], strides: &[int], padding: &str) -> Self {
        Self {
            orig_input,
            orig_output,
            grad,
            ksize: ksize.to_vec()
            strides: strides.to_vec()
            padding: padding.to_string()
            data_format: None,
            id_: new_id(),
        }
    }
}

pub trait con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_QINT8_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_QINT8_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF for BFloat16 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_QINT8_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF for f32 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_QINT8_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF for f64 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_QINT8_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF for i16 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_QINT8_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF for i32 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_QINT8_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF for i64 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_QINT8_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF for i8 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_QINT8_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF for u16 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_QINT8_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF for u8 {
}

impl<T> MaxPoolOp<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_QINT8_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF,
{
    pub fn new(inner: Rc<MaxPool<T>>) -> Self {
        Self{inner}
    }

    pub fn output(&self) -> Edge<T> {
        Edge::<T>::new(self.inner.clone(), 0)
    }
}

struct MaxPoolOp<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_QINT8_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF,
{
    inner: Rc<MaxPool<T>>,
}

impl<T> GraphOperation for MaxPool<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_QINT8_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("MaxPool_{}")?
        };
        let mut new_op = graph.new_operation("MaxPool", &op_name)?;
        {
            (|attrs| {new_op.set_attr_int_list("ksize", attrs)})(&self.ksize)
        }
        {
            (|attrs| {new_op.set_attr_int_list("strides", attrs)})(&self.strides)
        }
        {
            (|attr| {new_op.set_attr_string("padding", attr)})(&self.padding)
        }
        {
            match self.data_format {
            }
            None => new_op.set_attr_value_proto("data_format", &vec![18_u8, 4_u8, 78_u8, 72_u8, 87_u8, 67_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_string("data_format", attr)})(&value),
        };
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct MaxPool<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_QINT8_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF,
{
    input: Edge<T>,
    ksize: Vec<i64>,
    strides: Vec<i64>,
    padding: String,
    data_format: Option<String>,
    id_: usize,
}

impl<T> MaxPool<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_QINT8_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF,
{
    pub fn data_format(&mut self, data_format: &str) -> &mut Self {
        self.data_format = Some(data_format.to_string());
        &self
    }

    pub fn finish(self) -> MaxPoolOp<T> {
        MaxPoolOp::new(Rc::new(self))
    }

    pub fn new(input: Edge<T>, ksize: &[int], strides: &[int], padding: &str) -> Self {
        Self {
            input,
            ksize: ksize.to_vec()
            strides: strides.to_vec()
            padding: padding.to_string()
            data_format: None,
            id_: new_id(),
        }
    }
}

pub trait con_or_DT_FLOAT_or_DT_BFLOAT16_or_DT_HALF {
}

impl con_or_DT_FLOAT_or_DT_BFLOAT16_or_DT_HALF for BFloat16 {
}

impl con_or_DT_FLOAT_or_DT_BFLOAT16_or_DT_HALF for f32 {
}

impl<T> LRNOp<T>
where T: con_or_DT_FLOAT_or_DT_BFLOAT16_or_DT_HALF,
{
    pub fn new(inner: Rc<LRN<T>>) -> Self {
        Self{inner}
    }

    pub fn output(&self) -> Edge<T> {
        Edge::<T>::new(self.inner.clone(), 0)
    }
}

struct LRNOp<T>
where T: con_or_DT_FLOAT_or_DT_BFLOAT16_or_DT_HALF,
{
    inner: Rc<LRN<T>>,
}

impl<T> GraphOperation for LRN<T>
where T: con_or_DT_FLOAT_or_DT_BFLOAT16_or_DT_HALF,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("LRN_{}")?
        };
        let mut new_op = graph.new_operation("LRN", &op_name)?;
        {
            match self.depth_radius {
            }
            None => new_op.set_attr_value_proto("depth_radius", &vec![24_u8, 5_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_int("depth_radius", *attr)})(&value),
        };
        {
            match self.bias {
            }
            None => new_op.set_attr_value_proto("bias", &vec![37_u8, 0_u8, 0_u8, 128_u8, 63_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_float("bias", *attr)})(&value),
        };
        {
            match self.alpha {
            }
            None => new_op.set_attr_value_proto("alpha", &vec![37_u8, 0_u8, 0_u8, 128_u8, 63_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_float("alpha", *attr)})(&value),
        };
        {
            match self.beta {
            }
            None => new_op.set_attr_value_proto("beta", &vec![37_u8, 0_u8, 0_u8, 0_u8, 63_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_float("beta", *attr)})(&value),
        };
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct LRN<T>
where T: con_or_DT_FLOAT_or_DT_BFLOAT16_or_DT_HALF,
{
    input: Edge<T>,
    depth_radius: Option<i64>,
    bias: Option<f32>,
    alpha: Option<f32>,
    beta: Option<f32>,
    id_: usize,
}

impl<T> LRN<T>
where T: con_or_DT_FLOAT_or_DT_BFLOAT16_or_DT_HALF,
{
    pub fn depth_radius(&mut self, depth_radius: int) -> &mut Self {
        self.depth_radius = Some(depth_radius);
        &self
    }

    pub fn bias(&mut self, bias: f32) -> &mut Self {
        self.bias = Some(bias);
        &self
    }

    pub fn alpha(&mut self, alpha: f32) -> &mut Self {
        self.alpha = Some(alpha);
        &self
    }

    pub fn beta(&mut self, beta: f32) -> &mut Self {
        self.beta = Some(beta);
        &self
    }

    pub fn finish(self) -> LRNOp<T> {
        LRNOp::new(Rc::new(self))
    }

    pub fn new(input: Edge<T>) -> Self {
        Self {
            input,
            depth_radius: None,
            bias: None,
            alpha: None,
            beta: None,
            id_: new_id(),
        }
    }
}

impl<T> DenseToSparseSetOperationOp<T>
where T: con_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_STRING_or_DT_INT64_or_DT_UINT16,
{
    pub fn new(inner: Rc<DenseToSparseSetOperation<T>>) -> Self {
        Self{inner}
    }

    pub fn result_indices(&self) -> Edge<i64> {
        Edge::<i64>::new(self.inner.clone(), 0)
    }

    pub fn result_values(&self) -> Edge<T> {
        Edge::<T>::new(self.inner.clone(), 1)
    }

    pub fn result_shape(&self) -> Edge<i64> {
        Edge::<i64>::new(self.inner.clone(), 2)
    }
}

struct DenseToSparseSetOperationOp<T>
where T: con_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_STRING_or_DT_INT64_or_DT_UINT16,
{
    inner: Rc<DenseToSparseSetOperation<T>>,
}

impl<T> GraphOperation for DenseToSparseSetOperation<T>
where T: con_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_STRING_or_DT_INT64_or_DT_UINT16,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("DenseToSparseSetOperation_{}")?
        };
        let mut new_op = graph.new_operation("DenseToSparseSetOperation", &op_name)?;
        {
            (|attr| {new_op.set_attr_string("set_operation", attr)})(&self.set_operation)
        }
        {
            match self.validate_indices {
            }
            None => new_op.set_attr_value_proto("validate_indices", &vec![40_u8, 1_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_bool("validate_indices", *attr)})(&value),
        };
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct DenseToSparseSetOperation<T>
where T: con_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_STRING_or_DT_INT64_or_DT_UINT16,
{
    set1: Edge<T>,
    set2_indices: Edge<i64>,
    set2_values: Edge<T>,
    set2_shape: Edge<i64>,
    set_operation: String,
    validate_indices: Option<bool>,
    id_: usize,
}

impl<T> DenseToSparseSetOperation<T>
where T: con_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_STRING_or_DT_INT64_or_DT_UINT16,
{
    pub fn validate_indices(&mut self, validate_indices: bool) -> &mut Self {
        self.validate_indices = Some(validate_indices);
        &self
    }

    pub fn finish(self) -> DenseToSparseSetOperationOp<T> {
        DenseToSparseSetOperationOp::new(Rc::new(self))
    }

    pub fn new(set1: Edge<T>, set2_indices: Edge<i64>, set2_values: Edge<T>, set2_shape: Edge<i64>, set_operation: &str) -> Self {
        Self {
            set1,
            set2_indices,
            set2_values,
            set2_shape,
            set_operation: set_operation.to_string()
            validate_indices: None,
            id_: new_id(),
        }
    }
}

impl<T> L2LossOp<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
{
    pub fn new(inner: Rc<L2Loss<T>>) -> Self {
        Self{inner}
    }

    pub fn output(&self) -> Edge<T> {
        Edge::<T>::new(self.inner.clone(), 0)
    }
}

struct L2LossOp<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
{
    inner: Rc<L2Loss<T>>,
}

impl<T> GraphOperation for L2Loss<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("L2Loss_{}")?
        };
        let mut new_op = graph.new_operation("L2Loss", &op_name)?;
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct L2Loss<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
{
    t: Edge<T>,
    id_: usize,
}

impl<T> L2Loss<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
{
    pub fn finish(self) -> L2LossOp<T> {
        L2LossOp::new(Rc::new(self))
    }

    pub fn new(t: Edge<T>) -> Self {
        Self {
            t,
            id_: new_id(),
        }
    }
}

impl<TInput, T> MaxPool3DGradOp<TInput, T>
where T: con_or_DT_FLOAT_or_DT_BFLOAT16_or_DT_HALF,
      TInput: con_or_DT_FLOAT_or_DT_BFLOAT16_or_DT_HALF,
{
    pub fn new(inner: Rc<MaxPool3DGrad<TInput, T>>) -> Self {
        Self{inner}
    }

    pub fn output(&self) -> Edge<T> {
        Edge::<T>::new(self.inner.clone(), 0)
    }
}

struct MaxPool3DGradOp<TInput, T>
where T: con_or_DT_FLOAT_or_DT_BFLOAT16_or_DT_HALF,
      TInput: con_or_DT_FLOAT_or_DT_BFLOAT16_or_DT_HALF,
{
    inner: Rc<MaxPool3DGrad<TInput, T>>,
}

impl<TInput, T> GraphOperation for MaxPool3DGrad<TInput, T>
where T: con_or_DT_FLOAT_or_DT_BFLOAT16_or_DT_HALF,
      TInput: con_or_DT_FLOAT_or_DT_BFLOAT16_or_DT_HALF,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("MaxPool3DGrad_{}")?
        };
        let mut new_op = graph.new_operation("MaxPool3DGrad", &op_name)?;
        {
            (|attrs| {new_op.set_attr_int_list("ksize", attrs)})(&self.ksize)
        }
        {
            (|attrs| {new_op.set_attr_int_list("strides", attrs)})(&self.strides)
        }
        {
            (|attr| {new_op.set_attr_string("padding", attr)})(&self.padding)
        }
        {
            match self.data_format {
            }
            None => new_op.set_attr_value_proto("data_format", &vec![18_u8, 5_u8, 78_u8, 68_u8, 72_u8, 87_u8, 67_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_string("data_format", attr)})(&value),
        };
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct MaxPool3DGrad<TInput, T>
where T: con_or_DT_FLOAT_or_DT_BFLOAT16_or_DT_HALF,
      TInput: con_or_DT_FLOAT_or_DT_BFLOAT16_or_DT_HALF,
{
    orig_input: Edge<TInput>,
    orig_output: Edge<TInput>,
    grad: Edge<T>,
    ksize: Vec<i64>,
    strides: Vec<i64>,
    padding: String,
    data_format: Option<String>,
    id_: usize,
}

impl<TInput, T> MaxPool3DGrad<TInput, T>
where T: con_or_DT_FLOAT_or_DT_BFLOAT16_or_DT_HALF,
      TInput: con_or_DT_FLOAT_or_DT_BFLOAT16_or_DT_HALF,
{
    pub fn data_format(&mut self, data_format: &str) -> &mut Self {
        self.data_format = Some(data_format.to_string());
        &self
    }

    pub fn finish(self) -> MaxPool3DGradOp<TInput, T> {
        MaxPool3DGradOp::new(Rc::new(self))
    }

    pub fn new(orig_input: Edge<TInput>, orig_output: Edge<TInput>, grad: Edge<T>, ksize: &[int], strides: &[int], padding: &str) -> Self {
        Self {
            orig_input,
            orig_output,
            grad,
            ksize: ksize.to_vec()
            strides: strides.to_vec()
            padding: padding.to_string()
            data_format: None,
            id_: new_id(),
        }
    }
}

impl<T> ApplyGradientDescentOp<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
{
    pub fn new(inner: Rc<ApplyGradientDescent<T>>) -> Self {
        Self{inner}
    }

    pub fn out(&self) -> Edge<T> {
        Edge::<T>::new(self.inner.clone(), 0)
    }
}

struct ApplyGradientDescentOp<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
{
    inner: Rc<ApplyGradientDescent<T>>,
}

impl<T> GraphOperation for ApplyGradientDescent<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("ApplyGradientDescent_{}")?
        };
        let mut new_op = graph.new_operation("ApplyGradientDescent", &op_name)?;
        {
            match self.use_locking {
            }
            None => new_op.set_attr_value_proto("use_locking", &vec![40_u8, 0_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_bool("use_locking", *attr)})(&value),
        };
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct ApplyGradientDescent<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
{
    var: Edge<T>,
    alpha: Edge<T>,
    delta: Edge<T>,
    use_locking: Option<bool>,
    id_: usize,
}

impl<T> ApplyGradientDescent<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
{
    pub fn use_locking(&mut self, use_locking: bool) -> &mut Self {
        self.use_locking = Some(use_locking);
        &self
    }

    pub fn finish(self) -> ApplyGradientDescentOp<T> {
        ApplyGradientDescentOp::new(Rc::new(self))
    }

    pub fn new(var: Edge<T>, alpha: Edge<T>, delta: Edge<T>) -> Self {
        Self {
            var,
            alpha,
            delta,
            use_locking: None,
            id_: new_id(),
        }
    }
}

impl<T> MaxPool3DOp<T>
where T: con_or_DT_FLOAT_or_DT_BFLOAT16_or_DT_HALF,
{
    pub fn new(inner: Rc<MaxPool3D<T>>) -> Self {
        Self{inner}
    }

    pub fn output(&self) -> Edge<T> {
        Edge::<T>::new(self.inner.clone(), 0)
    }
}

struct MaxPool3DOp<T>
where T: con_or_DT_FLOAT_or_DT_BFLOAT16_or_DT_HALF,
{
    inner: Rc<MaxPool3D<T>>,
}

impl<T> GraphOperation for MaxPool3D<T>
where T: con_or_DT_FLOAT_or_DT_BFLOAT16_or_DT_HALF,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("MaxPool3D_{}")?
        };
        let mut new_op = graph.new_operation("MaxPool3D", &op_name)?;
        {
            (|attrs| {new_op.set_attr_int_list("ksize", attrs)})(&self.ksize)
        }
        {
            (|attrs| {new_op.set_attr_int_list("strides", attrs)})(&self.strides)
        }
        {
            (|attr| {new_op.set_attr_string("padding", attr)})(&self.padding)
        }
        {
            match self.data_format {
            }
            None => new_op.set_attr_value_proto("data_format", &vec![18_u8, 5_u8, 78_u8, 68_u8, 72_u8, 87_u8, 67_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_string("data_format", attr)})(&value),
        };
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct MaxPool3D<T>
where T: con_or_DT_FLOAT_or_DT_BFLOAT16_or_DT_HALF,
{
    input: Edge<T>,
    ksize: Vec<i64>,
    strides: Vec<i64>,
    padding: String,
    data_format: Option<String>,
    id_: usize,
}

impl<T> MaxPool3D<T>
where T: con_or_DT_FLOAT_or_DT_BFLOAT16_or_DT_HALF,
{
    pub fn data_format(&mut self, data_format: &str) -> &mut Self {
        self.data_format = Some(data_format.to_string());
        &self
    }

    pub fn finish(self) -> MaxPool3DOp<T> {
        MaxPool3DOp::new(Rc::new(self))
    }

    pub fn new(input: Edge<T>, ksize: &[int], strides: &[int], padding: &str) -> Self {
        Self {
            input,
            ksize: ksize.to_vec()
            strides: strides.to_vec()
            padding: padding.to_string()
            data_format: None,
            id_: new_id(),
        }
    }
}

impl<T> AvgPool3DOp<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
{
    pub fn new(inner: Rc<AvgPool3D<T>>) -> Self {
        Self{inner}
    }

    pub fn output(&self) -> Edge<T> {
        Edge::<T>::new(self.inner.clone(), 0)
    }
}

struct AvgPool3DOp<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
{
    inner: Rc<AvgPool3D<T>>,
}

impl<T> GraphOperation for AvgPool3D<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("AvgPool3D_{}")?
        };
        let mut new_op = graph.new_operation("AvgPool3D", &op_name)?;
        {
            (|attrs| {new_op.set_attr_int_list("ksize", attrs)})(&self.ksize)
        }
        {
            (|attrs| {new_op.set_attr_int_list("strides", attrs)})(&self.strides)
        }
        {
            (|attr| {new_op.set_attr_string("padding", attr)})(&self.padding)
        }
        {
            match self.data_format {
            }
            None => new_op.set_attr_value_proto("data_format", &vec![18_u8, 5_u8, 78_u8, 68_u8, 72_u8, 87_u8, 67_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_string("data_format", attr)})(&value),
        };
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct AvgPool3D<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
{
    input: Edge<T>,
    ksize: Vec<i64>,
    strides: Vec<i64>,
    padding: String,
    data_format: Option<String>,
    id_: usize,
}

impl<T> AvgPool3D<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
{
    pub fn data_format(&mut self, data_format: &str) -> &mut Self {
        self.data_format = Some(data_format.to_string());
        &self
    }

    pub fn finish(self) -> AvgPool3DOp<T> {
        AvgPool3DOp::new(Rc::new(self))
    }

    pub fn new(input: Edge<T>, ksize: &[int], strides: &[int], padding: &str) -> Self {
        Self {
            input,
            ksize: ksize.to_vec()
            strides: strides.to_vec()
            padding: padding.to_string()
            data_format: None,
            id_: new_id(),
        }
    }
}

impl<T> MaxPool3DGradGradOp<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
{
    pub fn new(inner: Rc<MaxPool3DGradGrad<T>>) -> Self {
        Self{inner}
    }

    pub fn output(&self) -> Edge<T> {
        Edge::<T>::new(self.inner.clone(), 0)
    }
}

struct MaxPool3DGradGradOp<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
{
    inner: Rc<MaxPool3DGradGrad<T>>,
}

impl<T> GraphOperation for MaxPool3DGradGrad<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("MaxPool3DGradGrad_{}")?
        };
        let mut new_op = graph.new_operation("MaxPool3DGradGrad", &op_name)?;
        {
            (|attrs| {new_op.set_attr_int_list("ksize", attrs)})(&self.ksize)
        }
        {
            (|attrs| {new_op.set_attr_int_list("strides", attrs)})(&self.strides)
        }
        {
            (|attr| {new_op.set_attr_string("padding", attr)})(&self.padding)
        }
        {
            match self.data_format {
            }
            None => new_op.set_attr_value_proto("data_format", &vec![18_u8, 5_u8, 78_u8, 68_u8, 72_u8, 87_u8, 67_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_string("data_format", attr)})(&value),
        };
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct MaxPool3DGradGrad<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
{
    orig_input: Edge<T>,
    orig_output: Edge<T>,
    grad: Edge<T>,
    ksize: Vec<i64>,
    strides: Vec<i64>,
    padding: String,
    data_format: Option<String>,
    id_: usize,
}

impl<T> MaxPool3DGradGrad<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
{
    pub fn data_format(&mut self, data_format: &str) -> &mut Self {
        self.data_format = Some(data_format.to_string());
        &self
    }

    pub fn finish(self) -> MaxPool3DGradGradOp<T> {
        MaxPool3DGradGradOp::new(Rc::new(self))
    }

    pub fn new(orig_input: Edge<T>, orig_output: Edge<T>, grad: Edge<T>, ksize: &[int], strides: &[int], padding: &str) -> Self {
        Self {
            orig_input,
            orig_output,
            grad,
            ksize: ksize.to_vec()
            strides: strides.to_vec()
            padding: padding.to_string()
            data_format: None,
            id_: new_id(),
        }
    }
}

impl<T> Conv3DBackpropFilterV2Op<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
{
    pub fn new(inner: Rc<Conv3DBackpropFilterV2<T>>) -> Self {
        Self{inner}
    }

    pub fn output(&self) -> Edge<T> {
        Edge::<T>::new(self.inner.clone(), 0)
    }
}

struct Conv3DBackpropFilterV2Op<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
{
    inner: Rc<Conv3DBackpropFilterV2<T>>,
}

impl<T> GraphOperation for Conv3DBackpropFilterV2<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("Conv3DBackpropFilterV2_{}")?
        };
        let mut new_op = graph.new_operation("Conv3DBackpropFilterV2", &op_name)?;
        {
            (|attrs| {new_op.set_attr_int_list("strides", attrs)})(&self.strides)
        }
        {
            (|attr| {new_op.set_attr_string("padding", attr)})(&self.padding)
        }
        {
            match self.data_format {
            }
            None => new_op.set_attr_value_proto("data_format", &vec![18_u8, 5_u8, 78_u8, 68_u8, 72_u8, 87_u8, 67_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_string("data_format", attr)})(&value),
        };
        {
            match self.dilations {
            }
            None => new_op.set_attr_value_proto("dilations", &vec![10_u8, 0_u8, 26_u8, 5_u8, 1_u8, 1_u8, 1_u8, 1_u8,]);,
            Some(value) => (|attrs| {new_op.set_attr_int_list("dilations", attrs)})(&value),
        };
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct Conv3DBackpropFilterV2<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
{
    input: Edge<T>,
    filter_sizes: Edge<i32>,
    out_backprop: Edge<T>,
    strides: Vec<i64>,
    padding: String,
    data_format: Option<String>,
    dilations: Option<Vec<i64>>,
    id_: usize,
}

impl<T> Conv3DBackpropFilterV2<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
{
    pub fn data_format(&mut self, data_format: &str) -> &mut Self {
        self.data_format = Some(data_format.to_string());
        &self
    }

    pub fn dilations(&mut self, dilations: &[int]) -> &mut Self {
        self.dilations = Some(dilations.to_vec());
        &self
    }

    pub fn finish(self) -> Conv3DBackpropFilterV2Op<T> {
        Conv3DBackpropFilterV2Op::new(Rc::new(self))
    }

    pub fn new(input: Edge<T>, filter_sizes: Edge<i32>, out_backprop: Edge<T>, strides: &[int], padding: &str) -> Self {
        Self {
            input,
            filter_sizes,
            out_backprop,
            strides: strides.to_vec()
            padding: padding.to_string()
            data_format: None,
            dilations: None,
            id_: new_id(),
        }
    }
}

impl<T> Conv3DOp<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
{
    pub fn new(inner: Rc<Conv3D<T>>) -> Self {
        Self{inner}
    }

    pub fn output(&self) -> Edge<T> {
        Edge::<T>::new(self.inner.clone(), 0)
    }
}

struct Conv3DOp<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
{
    inner: Rc<Conv3D<T>>,
}

impl<T> GraphOperation for Conv3D<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("Conv3D_{}")?
        };
        let mut new_op = graph.new_operation("Conv3D", &op_name)?;
        {
            (|attrs| {new_op.set_attr_int_list("strides", attrs)})(&self.strides)
        }
        {
            (|attr| {new_op.set_attr_string("padding", attr)})(&self.padding)
        }
        {
            match self.data_format {
            }
            None => new_op.set_attr_value_proto("data_format", &vec![18_u8, 5_u8, 78_u8, 68_u8, 72_u8, 87_u8, 67_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_string("data_format", attr)})(&value),
        };
        {
            match self.dilations {
            }
            None => new_op.set_attr_value_proto("dilations", &vec![10_u8, 0_u8, 26_u8, 5_u8, 1_u8, 1_u8, 1_u8, 1_u8,]);,
            Some(value) => (|attrs| {new_op.set_attr_int_list("dilations", attrs)})(&value),
        };
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct Conv3D<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
{
    input: Edge<T>,
    filter: Edge<T>,
    strides: Vec<i64>,
    padding: String,
    data_format: Option<String>,
    dilations: Option<Vec<i64>>,
    id_: usize,
}

impl<T> Conv3D<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
{
    pub fn data_format(&mut self, data_format: &str) -> &mut Self {
        self.data_format = Some(data_format.to_string());
        &self
    }

    pub fn dilations(&mut self, dilations: &[int]) -> &mut Self {
        self.dilations = Some(dilations.to_vec());
        &self
    }

    pub fn finish(self) -> Conv3DOp<T> {
        Conv3DOp::new(Rc::new(self))
    }

    pub fn new(input: Edge<T>, filter: Edge<T>, strides: &[int], padding: &str) -> Self {
        Self {
            input,
            filter,
            strides: strides.to_vec()
            padding: padding.to_string()
            data_format: None,
            dilations: None,
            id_: new_id(),
        }
    }
}

impl<T> DepthwiseConv2dNativeBackpropFilterOp<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
{
    pub fn new(inner: Rc<DepthwiseConv2dNativeBackpropFilter<T>>) -> Self {
        Self{inner}
    }

    pub fn output(&self) -> Edge<T> {
        Edge::<T>::new(self.inner.clone(), 0)
    }
}

struct DepthwiseConv2dNativeBackpropFilterOp<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
{
    inner: Rc<DepthwiseConv2dNativeBackpropFilter<T>>,
}

impl<T> GraphOperation for DepthwiseConv2dNativeBackpropFilter<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("DepthwiseConv2dNativeBackpropFilter_{}")?
        };
        let mut new_op = graph.new_operation("DepthwiseConv2dNativeBackpropFilter", &op_name)?;
        {
            (|attrs| {new_op.set_attr_int_list("strides", attrs)})(&self.strides)
        }
        {
            (|attr| {new_op.set_attr_string("padding", attr)})(&self.padding)
        }
        {
            match self.data_format {
            }
            None => new_op.set_attr_value_proto("data_format", &vec![18_u8, 4_u8, 78_u8, 72_u8, 87_u8, 67_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_string("data_format", attr)})(&value),
        };
        {
            match self.dilations {
            }
            None => new_op.set_attr_value_proto("dilations", &vec![10_u8, 0_u8, 26_u8, 4_u8,]);,
            Some(value) => (|attrs| {new_op.set_attr_int_list("dilations", attrs)})(&value),
        };
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct DepthwiseConv2dNativeBackpropFilter<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
{
    input: Edge<T>,
    filter_sizes: Edge<i32>,
    out_backprop: Edge<T>,
    strides: Vec<i64>,
    padding: String,
    data_format: Option<String>,
    dilations: Option<Vec<i64>>,
    id_: usize,
}

impl<T> DepthwiseConv2dNativeBackpropFilter<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
{
    pub fn data_format(&mut self, data_format: &str) -> &mut Self {
        self.data_format = Some(data_format.to_string());
        &self
    }

    pub fn dilations(&mut self, dilations: &[int]) -> &mut Self {
        self.dilations = Some(dilations.to_vec());
        &self
    }

    pub fn finish(self) -> DepthwiseConv2dNativeBackpropFilterOp<T> {
        DepthwiseConv2dNativeBackpropFilterOp::new(Rc::new(self))
    }

    pub fn new(input: Edge<T>, filter_sizes: Edge<i32>, out_backprop: Edge<T>, strides: &[int], padding: &str) -> Self {
        Self {
            input,
            filter_sizes,
            out_backprop,
            strides: strides.to_vec()
            padding: padding.to_string()
            data_format: None,
            dilations: None,
            id_: new_id(),
        }
    }
}

impl<T> DepthwiseConv2dNativeBackpropInputOp<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
{
    pub fn new(inner: Rc<DepthwiseConv2dNativeBackpropInput<T>>) -> Self {
        Self{inner}
    }

    pub fn output(&self) -> Edge<T> {
        Edge::<T>::new(self.inner.clone(), 0)
    }
}

struct DepthwiseConv2dNativeBackpropInputOp<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
{
    inner: Rc<DepthwiseConv2dNativeBackpropInput<T>>,
}

impl<T> GraphOperation for DepthwiseConv2dNativeBackpropInput<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("DepthwiseConv2dNativeBackpropInput_{}")?
        };
        let mut new_op = graph.new_operation("DepthwiseConv2dNativeBackpropInput", &op_name)?;
        {
            (|attrs| {new_op.set_attr_int_list("strides", attrs)})(&self.strides)
        }
        {
            (|attr| {new_op.set_attr_string("padding", attr)})(&self.padding)
        }
        {
            match self.data_format {
            }
            None => new_op.set_attr_value_proto("data_format", &vec![18_u8, 4_u8, 78_u8, 72_u8, 87_u8, 67_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_string("data_format", attr)})(&value),
        };
        {
            match self.dilations {
            }
            None => new_op.set_attr_value_proto("dilations", &vec![10_u8, 0_u8, 26_u8, 4_u8,]);,
            Some(value) => (|attrs| {new_op.set_attr_int_list("dilations", attrs)})(&value),
        };
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct DepthwiseConv2dNativeBackpropInput<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
{
    input_sizes: Edge<i32>,
    filter: Edge<T>,
    out_backprop: Edge<T>,
    strides: Vec<i64>,
    padding: String,
    data_format: Option<String>,
    dilations: Option<Vec<i64>>,
    id_: usize,
}

impl<T> DepthwiseConv2dNativeBackpropInput<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
{
    pub fn data_format(&mut self, data_format: &str) -> &mut Self {
        self.data_format = Some(data_format.to_string());
        &self
    }

    pub fn dilations(&mut self, dilations: &[int]) -> &mut Self {
        self.dilations = Some(dilations.to_vec());
        &self
    }

    pub fn finish(self) -> DepthwiseConv2dNativeBackpropInputOp<T> {
        DepthwiseConv2dNativeBackpropInputOp::new(Rc::new(self))
    }

    pub fn new(input_sizes: Edge<i32>, filter: Edge<T>, out_backprop: Edge<T>, strides: &[int], padding: &str) -> Self {
        Self {
            input_sizes,
            filter,
            out_backprop,
            strides: strides.to_vec()
            padding: padding.to_string()
            data_format: None,
            dilations: None,
            id_: new_id(),
        }
    }
}

impl<T> DepthwiseConv2dNativeOp<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
{
    pub fn new(inner: Rc<DepthwiseConv2dNative<T>>) -> Self {
        Self{inner}
    }

    pub fn output(&self) -> Edge<T> {
        Edge::<T>::new(self.inner.clone(), 0)
    }
}

struct DepthwiseConv2dNativeOp<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
{
    inner: Rc<DepthwiseConv2dNative<T>>,
}

impl<T> GraphOperation for DepthwiseConv2dNative<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("DepthwiseConv2dNative_{}")?
        };
        let mut new_op = graph.new_operation("DepthwiseConv2dNative", &op_name)?;
        {
            (|attrs| {new_op.set_attr_int_list("strides", attrs)})(&self.strides)
        }
        {
            (|attr| {new_op.set_attr_string("padding", attr)})(&self.padding)
        }
        {
            match self.data_format {
            }
            None => new_op.set_attr_value_proto("data_format", &vec![18_u8, 4_u8, 78_u8, 72_u8, 87_u8, 67_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_string("data_format", attr)})(&value),
        };
        {
            match self.dilations {
            }
            None => new_op.set_attr_value_proto("dilations", &vec![10_u8, 0_u8, 26_u8, 4_u8,]);,
            Some(value) => (|attrs| {new_op.set_attr_int_list("dilations", attrs)})(&value),
        };
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct DepthwiseConv2dNative<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
{
    input: Edge<T>,
    filter: Edge<T>,
    strides: Vec<i64>,
    padding: String,
    data_format: Option<String>,
    dilations: Option<Vec<i64>>,
    id_: usize,
}

impl<T> DepthwiseConv2dNative<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
{
    pub fn data_format(&mut self, data_format: &str) -> &mut Self {
        self.data_format = Some(data_format.to_string());
        &self
    }

    pub fn dilations(&mut self, dilations: &[int]) -> &mut Self {
        self.dilations = Some(dilations.to_vec());
        &self
    }

    pub fn finish(self) -> DepthwiseConv2dNativeOp<T> {
        DepthwiseConv2dNativeOp::new(Rc::new(self))
    }

    pub fn new(input: Edge<T>, filter: Edge<T>, strides: &[int], padding: &str) -> Self {
        Self {
            input,
            filter,
            strides: strides.to_vec()
            padding: padding.to_string()
            data_format: None,
            dilations: None,
            id_: new_id(),
        }
    }
}

pub trait con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_HALF {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_HALF for f32 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_HALF for f64 {
}

impl<T> FusedResizeAndPadConv2DOp<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_HALF,
{
    pub fn new(inner: Rc<FusedResizeAndPadConv2D<T>>) -> Self {
        Self{inner}
    }

    pub fn output(&self) -> Edge<T> {
        Edge::<T>::new(self.inner.clone(), 0)
    }
}

struct FusedResizeAndPadConv2DOp<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_HALF,
{
    inner: Rc<FusedResizeAndPadConv2D<T>>,
}

impl<T> GraphOperation for FusedResizeAndPadConv2D<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_HALF,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("FusedResizeAndPadConv2D_{}")?
        };
        let mut new_op = graph.new_operation("FusedResizeAndPadConv2D", &op_name)?;
        {
            match self.resize_align_corners {
            }
            None => new_op.set_attr_value_proto("resize_align_corners", &vec![40_u8, 0_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_bool("resize_align_corners", *attr)})(&value),
        };
        {
            (|attr| {new_op.set_attr_string("mode", attr)})(&self.mode)
        }
        {
            (|attrs| {new_op.set_attr_int_list("strides", attrs)})(&self.strides)
        }
        {
            (|attr| {new_op.set_attr_string("padding", attr)})(&self.padding)
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct FusedResizeAndPadConv2D<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_HALF,
{
    input: Edge<T>,
    size: Edge<i32>,
    paddings: Edge<i32>,
    filter: Edge<T>,
    resize_align_corners: Option<bool>,
    mode: String,
    strides: Vec<i64>,
    padding: String,
    id_: usize,
}

impl<T> FusedResizeAndPadConv2D<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_HALF,
{
    pub fn resize_align_corners(&mut self, resize_align_corners: bool) -> &mut Self {
        self.resize_align_corners = Some(resize_align_corners);
        &self
    }

    pub fn finish(self) -> FusedResizeAndPadConv2DOp<T> {
        FusedResizeAndPadConv2DOp::new(Rc::new(self))
    }

    pub fn new(input: Edge<T>, size: Edge<i32>, paddings: Edge<i32>, filter: Edge<T>, mode: &str, strides: &[int], padding: &str) -> Self {
        Self {
            input,
            size,
            paddings,
            filter,
            resize_align_corners: None,
            mode: mode.to_string()
            strides: strides.to_vec()
            padding: padding.to_string()
            id_: new_id(),
        }
    }
}

impl<T> DataFormatVecPermuteOp<T>
where T: con_or_DT_INT32_or_DT_INT64,
{
    pub fn new(inner: Rc<DataFormatVecPermute<T>>) -> Self {
        Self{inner}
    }

    pub fn y(&self) -> Edge<T> {
        Edge::<T>::new(self.inner.clone(), 0)
    }
}

struct DataFormatVecPermuteOp<T>
where T: con_or_DT_INT32_or_DT_INT64,
{
    inner: Rc<DataFormatVecPermute<T>>,
}

impl<T> GraphOperation for DataFormatVecPermute<T>
where T: con_or_DT_INT32_or_DT_INT64,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("DataFormatVecPermute_{}")?
        };
        let mut new_op = graph.new_operation("DataFormatVecPermute", &op_name)?;
        {
            match self.src_format {
            }
            None => new_op.set_attr_value_proto("src_format", &vec![18_u8, 4_u8, 78_u8, 72_u8, 87_u8, 67_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_string("src_format", attr)})(&value),
        };
        {
            match self.dst_format {
            }
            None => new_op.set_attr_value_proto("dst_format", &vec![18_u8, 4_u8, 78_u8, 67_u8, 72_u8, 87_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_string("dst_format", attr)})(&value),
        };
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct DataFormatVecPermute<T>
where T: con_or_DT_INT32_or_DT_INT64,
{
    x: Edge<T>,
    src_format: Option<String>,
    dst_format: Option<String>,
    id_: usize,
}

impl<T> DataFormatVecPermute<T>
where T: con_or_DT_INT32_or_DT_INT64,
{
    pub fn src_format(&mut self, src_format: &str) -> &mut Self {
        self.src_format = Some(src_format.to_string());
        &self
    }

    pub fn dst_format(&mut self, dst_format: &str) -> &mut Self {
        self.dst_format = Some(dst_format.to_string());
        &self
    }

    pub fn finish(self) -> DataFormatVecPermuteOp<T> {
        DataFormatVecPermuteOp::new(Rc::new(self))
    }

    pub fn new(x: Edge<T>) -> Self {
        Self {
            x,
            src_format: None,
            dst_format: None,
            id_: new_id(),
        }
    }
}

impl<T> _FusedConv2DOp<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE,
{
    pub fn new(inner: Rc<_FusedConv2D<T>>) -> Self {
        Self{inner}
    }

    pub fn output(&self) -> Edge<T> {
        Edge::<T>::new(self.inner.clone(), 0)
    }
}

struct _FusedConv2DOp<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE,
{
    inner: Rc<_FusedConv2D<T>>,
}

impl<T> GraphOperation for _FusedConv2D<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("_FusedConv2D_{}")?
        };
        let mut new_op = graph.new_operation("_FusedConv2D", &op_name)?;
        {
            (|attr| {new_op.set_attr_int("num_args", *attr)})(&self.num_args)
        }
        {
            (|attrs| {new_op.set_attr_int_list("strides", attrs)})(&self.strides)
        }
        {
            (|attr| {new_op.set_attr_string("padding", attr)})(&self.padding)
        }
        {
            match self.data_format {
            }
            None => new_op.set_attr_value_proto("data_format", &vec![18_u8, 4_u8, 78_u8, 72_u8, 87_u8, 67_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_string("data_format", attr)})(&value),
        };
        {
            match self.dilations {
            }
            None => new_op.set_attr_value_proto("dilations", &vec![10_u8, 0_u8, 26_u8, 4_u8,]);,
            Some(value) => (|attrs| {new_op.set_attr_int_list("dilations", attrs)})(&value),
        };
        {
            match self.fused_ops {
            }
            None => new_op.set_attr_value_proto("fused_ops", &vec![10_u8, 0_u8,]);,
            Some(value) => (|attrs| {new_op.set_attr_string_list("fused_ops", attrs)})(&value),
        };
        {
            match self.epsilon {
            }
            None => new_op.set_attr_value_proto("epsilon", &vec![37_u8, 23_u8, 183_u8, 209_u8, 56_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_float("epsilon", *attr)})(&value),
        };
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct _FusedConv2D<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE,
{
    input: Edge<T>,
    filter: Edge<T>,
    args: Edge<T>,
    num_args: i64,
    strides: Vec<i64>,
    padding: String,
    data_format: Option<String>,
    dilations: Option<Vec<i64>>,
    fused_ops: Option<Vec<String>>,
    epsilon: Option<f32>,
    id_: usize,
}

impl<T> _FusedConv2D<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE,
{
    pub fn data_format(&mut self, data_format: &str) -> &mut Self {
        self.data_format = Some(data_format.to_string());
        &self
    }

    pub fn dilations(&mut self, dilations: &[int]) -> &mut Self {
        self.dilations = Some(dilations.to_vec());
        &self
    }

    pub fn fused_ops(&mut self, fused_ops: &[String]) -> &mut Self {
        self.fused_ops = Some(fused_ops.to_vec());
        &self
    }

    pub fn epsilon(&mut self, epsilon: f32) -> &mut Self {
        self.epsilon = Some(epsilon);
        &self
    }

    pub fn finish(self) -> _FusedConv2DOp<T> {
        _FusedConv2DOp::new(Rc::new(self))
    }

    pub fn new(input: Edge<T>, filter: Edge<T>, args: Edge<T>, num_args: int, strides: &[int], padding: &str) -> Self {
        Self {
            input,
            filter,
            args,
            num_args: num_args
            strides: strides.to_vec()
            padding: padding.to_string()
            data_format: None,
            dilations: None,
            fused_ops: None,
            epsilon: None,
            id_: new_id(),
        }
    }
}

impl<T> Dilation2DOp<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
{
    pub fn new(inner: Rc<Dilation2D<T>>) -> Self {
        Self{inner}
    }

    pub fn output(&self) -> Edge<T> {
        Edge::<T>::new(self.inner.clone(), 0)
    }
}

struct Dilation2DOp<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
{
    inner: Rc<Dilation2D<T>>,
}

impl<T> GraphOperation for Dilation2D<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("Dilation2D_{}")?
        };
        let mut new_op = graph.new_operation("Dilation2D", &op_name)?;
        {
            (|attrs| {new_op.set_attr_int_list("strides", attrs)})(&self.strides)
        }
        {
            (|attrs| {new_op.set_attr_int_list("rates", attrs)})(&self.rates)
        }
        {
            (|attr| {new_op.set_attr_string("padding", attr)})(&self.padding)
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct Dilation2D<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
{
    input: Edge<T>,
    filter: Edge<T>,
    strides: Vec<i64>,
    rates: Vec<i64>,
    padding: String,
    id_: usize,
}

impl<T> Dilation2D<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
{
    pub fn finish(self) -> Dilation2DOp<T> {
        Dilation2DOp::new(Rc::new(self))
    }

    pub fn new(input: Edge<T>, filter: Edge<T>, strides: &[int], rates: &[int], padding: &str) -> Self {
        Self {
            input,
            filter,
            strides: strides.to_vec()
            rates: rates.to_vec()
            padding: padding.to_string()
            id_: new_id(),
        }
    }
}

impl<dtype> ConditionalAccumulatorOp<dtype>
where dtype: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
{
    pub fn new(inner: Rc<ConditionalAccumulator<dtype>>) -> Self {
        Self{inner}
    }

    pub fn handle(&self) -> Edge<String> {
        Edge::<String>::new(self.inner.clone(), 0)
    }
}

struct ConditionalAccumulatorOp<dtype>
where dtype: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
{
    inner: Rc<ConditionalAccumulator<dtype>>,
}

impl<dtype> GraphOperation for ConditionalAccumulator<dtype>
where dtype: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("ConditionalAccumulator_{}")?
        };
        let mut new_op = graph.new_operation("ConditionalAccumulator", &op_name)?;
        {
            (|attr| {new_op.set_attr_shape("shape", attr)})(&self.shape)
        }
        {
            match self.container {
            }
            None => new_op.set_attr_value_proto("container", &vec![18_u8, 0_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_string("container", attr)})(&value),
        };
        {
            match self.shared_name {
            }
            None => new_op.set_attr_value_proto("shared_name", &vec![18_u8, 0_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_string("shared_name", attr)})(&value),
        };
        {
            match self.reduction_type {
            }
            None => new_op.set_attr_value_proto("reduction_type", &vec![18_u8, 4_u8, 77_u8, 69_u8, 65_u8, 78_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_string("reduction_type", attr)})(&value),
        };
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct ConditionalAccumulator<dtype>
where dtype: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
{
    shape: Shape,
    container: Option<String>,
    shared_name: Option<String>,
    reduction_type: Option<String>,
    id_: usize,
}

impl<dtype> ConditionalAccumulator<dtype>
where dtype: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
{
    pub fn container(&mut self, container: &str) -> &mut Self {
        self.container = Some(container.to_string());
        &self
    }

    pub fn shared_name(&mut self, shared_name: &str) -> &mut Self {
        self.shared_name = Some(shared_name.to_string());
        &self
    }

    pub fn reduction_type(&mut self, reduction_type: &str) -> &mut Self {
        self.reduction_type = Some(reduction_type.to_string());
        &self
    }

    pub fn finish(self) -> ConditionalAccumulatorOp<dtype> {
        ConditionalAccumulatorOp::new(Rc::new(self))
    }

    pub fn new(shape: &Shape) -> Self {
        Self {
            shape: shape.clone()
            container: None,
            shared_name: None,
            reduction_type: None,
            id_: new_id(),
        }
    }
}

impl<dtype> TensorArrayConcatV2Op<dtype>
where dtype: con,
{
    pub fn new(inner: Rc<TensorArrayConcatV2<dtype>>) -> Self {
        Self{inner}
    }

    pub fn value(&self) -> Edge<dtype> {
        Edge::<dtype>::new(self.inner.clone(), 0)
    }

    pub fn lengths(&self) -> Edge<i64> {
        Edge::<i64>::new(self.inner.clone(), 1)
    }
}

struct TensorArrayConcatV2Op<dtype>
where dtype: con,
{
    inner: Rc<TensorArrayConcatV2<dtype>>,
}

impl<dtype> GraphOperation for TensorArrayConcatV2<dtype>
where dtype: con,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("TensorArrayConcatV2_{}")?
        };
        let mut new_op = graph.new_operation("TensorArrayConcatV2", &op_name)?;
        {
            match self.element_shape_except0 {
            }
            None => new_op.set_attr_value_proto("element_shape_except0", &vec![58_u8, 0_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_shape("element_shape_except0", attr)})(&value),
        };
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct TensorArrayConcatV2<dtype>
where dtype: con,
{
    handle: Edge<String>,
    flow_in: Edge<f32>,
    element_shape_except0: Option<Shape>,
    id_: usize,
}

impl<dtype> TensorArrayConcatV2<dtype>
where dtype: con,
{
    pub fn element_shape_except0(&mut self, element_shape_except0: &Shape) -> &mut Self {
        self.element_shape_except0 = Some(element_shape_except0.clone());
        &self
    }

    pub fn finish(self) -> TensorArrayConcatV2Op<dtype> {
        TensorArrayConcatV2Op::new(Rc::new(self))
    }

    pub fn new(handle: Edge<String>, flow_in: Edge<f32>) -> Self {
        Self {
            handle,
            flow_in,
            element_shape_except0: None,
            id_: new_id(),
        }
    }
}

impl<T> TensorSummaryV2Op<T>
where T: con,
{
    pub fn new(inner: Rc<TensorSummaryV2<T>>) -> Self {
        Self{inner}
    }

    pub fn summary(&self) -> Edge<String> {
        Edge::<String>::new(self.inner.clone(), 0)
    }
}

struct TensorSummaryV2Op<T>
where T: con,
{
    inner: Rc<TensorSummaryV2<T>>,
}

impl<T> GraphOperation for TensorSummaryV2<T>
where T: con,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("TensorSummaryV2_{}")?
        };
        let mut new_op = graph.new_operation("TensorSummaryV2", &op_name)?;
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct TensorSummaryV2<T>
where T: con,
{
    tag: Edge<String>,
    tensor: Edge<T>,
    serialized_summary_metadata: Edge<String>,
    id_: usize,
}

impl<T> TensorSummaryV2<T>
where T: con,
{
    pub fn finish(self) -> TensorSummaryV2Op<T> {
        TensorSummaryV2Op::new(Rc::new(self))
    }

    pub fn new(tag: Edge<String>, tensor: Edge<T>, serialized_summary_metadata: Edge<String>) -> Self {
        Self {
            tag,
            tensor,
            serialized_summary_metadata,
            id_: new_id(),
        }
    }
}

impl RetrieveTPUEmbeddingProximalAdagradParametersGradAccumDebugOp {
    pub fn new(inner: Rc<RetrieveTPUEmbeddingProximalAdagradParametersGradAccumDebug>) -> Self {
        Self{inner}
    }

    pub fn parameters(&self) -> Edge<f32> {
        Edge::<f32>::new(self.inner.clone(), 0)
    }

    pub fn accumulators(&self) -> Edge<f32> {
        Edge::<f32>::new(self.inner.clone(), 1)
    }

    pub fn gradient_accumulators(&self) -> Edge<f32> {
        Edge::<f32>::new(self.inner.clone(), 2)
    }
}

struct RetrieveTPUEmbeddingProximalAdagradParametersGradAccumDebugOp {
    inner: Rc<RetrieveTPUEmbeddingProximalAdagradParametersGradAccumDebug>,
}

impl GraphOperation for RetrieveTPUEmbeddingProximalAdagradParametersGradAccumDebug {
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("RetrieveTPUEmbeddingProximalAdagradParametersGradAccumDebug_{}")?
        };
        let mut new_op = graph.new_operation("RetrieveTPUEmbeddingProximalAdagradParametersGradAccumDebug", &op_name)?;
        {
            match self.table_id {
            }
            None => new_op.set_attr_value_proto("table_id", &vec![24_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 1_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_int("table_id", *attr)})(&value),
        };
        {
            match self.table_name {
            }
            None => new_op.set_attr_value_proto("table_name", &vec![18_u8, 0_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_string("table_name", attr)})(&value),
        };
        {
            (|attr| {new_op.set_attr_int("num_shards", *attr)})(&self.num_shards)
        }
        {
            (|attr| {new_op.set_attr_int("shard_id", *attr)})(&self.shard_id)
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct RetrieveTPUEmbeddingProximalAdagradParametersGradAccumDebug {
    table_id: Option<i64>,
    table_name: Option<String>,
    num_shards: i64,
    shard_id: i64,
    id_: usize,
}

impl RetrieveTPUEmbeddingProximalAdagradParametersGradAccumDebug {
    pub fn table_id(&mut self, table_id: int) -> &mut Self {
        self.table_id = Some(table_id);
        &self
    }

    pub fn table_name(&mut self, table_name: &str) -> &mut Self {
        self.table_name = Some(table_name.to_string());
        &self
    }

    pub fn finish(self) -> RetrieveTPUEmbeddingProximalAdagradParametersGradAccumDebugOp {
        RetrieveTPUEmbeddingProximalAdagradParametersGradAccumDebugOp::new(Rc::new(self))
    }

    pub fn new(num_shards: int, shard_id: int) -> Self {
        Self {
            table_id: None,
            table_name: None,
            num_shards: num_shards
            shard_id: shard_id
            id_: new_id(),
        }
    }
}

impl<T, Tindices> SparseApplyCenteredRMSPropOp<T, Tindices>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      Tindices: con_or_DT_INT32_or_DT_INT64,
{
    pub fn new(inner: Rc<SparseApplyCenteredRMSProp<T, Tindices>>) -> Self {
        Self{inner}
    }

    pub fn out(&self) -> Edge<T> {
        Edge::<T>::new(self.inner.clone(), 0)
    }
}

struct SparseApplyCenteredRMSPropOp<T, Tindices>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      Tindices: con_or_DT_INT32_or_DT_INT64,
{
    inner: Rc<SparseApplyCenteredRMSProp<T, Tindices>>,
}

impl<T, Tindices> GraphOperation for SparseApplyCenteredRMSProp<T, Tindices>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      Tindices: con_or_DT_INT32_or_DT_INT64,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("SparseApplyCenteredRMSProp_{}")?
        };
        let mut new_op = graph.new_operation("SparseApplyCenteredRMSProp", &op_name)?;
        {
            match self.use_locking {
            }
            None => new_op.set_attr_value_proto("use_locking", &vec![40_u8, 0_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_bool("use_locking", *attr)})(&value),
        };
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct SparseApplyCenteredRMSProp<T, Tindices>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      Tindices: con_or_DT_INT32_or_DT_INT64,
{
    var: Edge<T>,
    mg: Edge<T>,
    ms: Edge<T>,
    mom: Edge<T>,
    lr: Edge<T>,
    rho: Edge<T>,
    momentum: Edge<T>,
    epsilon: Edge<T>,
    grad: Edge<T>,
    indices: Edge<Tindices>,
    use_locking: Option<bool>,
    id_: usize,
}

impl<T, Tindices> SparseApplyCenteredRMSProp<T, Tindices>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      Tindices: con_or_DT_INT32_or_DT_INT64,
{
    pub fn use_locking(&mut self, use_locking: bool) -> &mut Self {
        self.use_locking = Some(use_locking);
        &self
    }

    pub fn finish(self) -> SparseApplyCenteredRMSPropOp<T, Tindices> {
        SparseApplyCenteredRMSPropOp::new(Rc::new(self))
    }

    pub fn new(var: Edge<T>, mg: Edge<T>, ms: Edge<T>, mom: Edge<T>, lr: Edge<T>, rho: Edge<T>, momentum: Edge<T>, epsilon: Edge<T>, grad: Edge<T>, indices: Edge<Tindices>) -> Self {
        Self {
            var,
            mg,
            ms,
            mom,
            lr,
            rho,
            momentum,
            epsilon,
            grad,
            indices,
            use_locking: None,
            id_: new_id(),
        }
    }
}

impl RecordInputOp {
    pub fn new(inner: Rc<RecordInput>) -> Self {
        Self{inner}
    }

    pub fn records(&self) -> Edge<String> {
        Edge::<String>::new(self.inner.clone(), 0)
    }
}

struct RecordInputOp {
    inner: Rc<RecordInput>,
}

impl GraphOperation for RecordInput {
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("RecordInput_{}")?
        };
        let mut new_op = graph.new_operation("RecordInput", &op_name)?;
        {
            (|attr| {new_op.set_attr_string("file_pattern", attr)})(&self.file_pattern)
        }
        {
            match self.file_random_seed {
            }
            None => new_op.set_attr_value_proto("file_random_seed", &vec![24_u8, 173_u8, 2_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_int("file_random_seed", *attr)})(&value),
        };
        {
            match self.file_shuffle_shift_ratio {
            }
            None => new_op.set_attr_value_proto("file_shuffle_shift_ratio", &vec![37_u8, 0_u8, 0_u8, 0_u8, 0_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_float("file_shuffle_shift_ratio", *attr)})(&value),
        };
        {
            match self.file_buffer_size {
            }
            None => new_op.set_attr_value_proto("file_buffer_size", &vec![24_u8, 144_u8, 78_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_int("file_buffer_size", *attr)})(&value),
        };
        {
            match self.file_parallelism {
            }
            None => new_op.set_attr_value_proto("file_parallelism", &vec![24_u8, 16_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_int("file_parallelism", *attr)})(&value),
        };
        {
            match self.batch_size {
            }
            None => new_op.set_attr_value_proto("batch_size", &vec![24_u8, 32_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_int("batch_size", *attr)})(&value),
        };
        {
            match self.compression_type {
            }
            None => new_op.set_attr_value_proto("compression_type", &vec![18_u8, 0_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_string("compression_type", attr)})(&value),
        };
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct RecordInput {
    file_pattern: String,
    file_random_seed: Option<i64>,
    file_shuffle_shift_ratio: Option<f32>,
    file_buffer_size: Option<i64>,
    file_parallelism: Option<i64>,
    batch_size: Option<i64>,
    compression_type: Option<String>,
    id_: usize,
}

impl RecordInput {
    pub fn file_random_seed(&mut self, file_random_seed: int) -> &mut Self {
        self.file_random_seed = Some(file_random_seed);
        &self
    }

    pub fn file_shuffle_shift_ratio(&mut self, file_shuffle_shift_ratio: f32) -> &mut Self {
        self.file_shuffle_shift_ratio = Some(file_shuffle_shift_ratio);
        &self
    }

    pub fn file_buffer_size(&mut self, file_buffer_size: int) -> &mut Self {
        self.file_buffer_size = Some(file_buffer_size);
        &self
    }

    pub fn file_parallelism(&mut self, file_parallelism: int) -> &mut Self {
        self.file_parallelism = Some(file_parallelism);
        &self
    }

    pub fn batch_size(&mut self, batch_size: int) -> &mut Self {
        self.batch_size = Some(batch_size);
        &self
    }

    pub fn compression_type(&mut self, compression_type: &str) -> &mut Self {
        self.compression_type = Some(compression_type.to_string());
        &self
    }

    pub fn finish(self) -> RecordInputOp {
        RecordInputOp::new(Rc::new(self))
    }

    pub fn new(file_pattern: &str) -> Self {
        Self {
            file_pattern: file_pattern.to_string()
            file_random_seed: None,
            file_shuffle_shift_ratio: None,
            file_buffer_size: None,
            file_parallelism: None,
            batch_size: None,
            compression_type: None,
            id_: new_id(),
        }
    }
}

pub trait con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_COMPLEX64_or_DT_INT64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_COMPLEX64_or_DT_INT64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF for BFloat16 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_COMPLEX64_or_DT_INT64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF for OtherComplex<f32> {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_COMPLEX64_or_DT_INT64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF for OtherComplex<f64> {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_COMPLEX64_or_DT_INT64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF for f32 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_COMPLEX64_or_DT_INT64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF for f64 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_COMPLEX64_or_DT_INT64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF for i32 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_COMPLEX64_or_DT_INT64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF for i64 {
}

impl<T> RoundOp<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_COMPLEX64_or_DT_INT64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF,
{
    pub fn new(inner: Rc<Round<T>>) -> Self {
        Self{inner}
    }

    pub fn y(&self) -> Edge<T> {
        Edge::<T>::new(self.inner.clone(), 0)
    }
}

struct RoundOp<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_COMPLEX64_or_DT_INT64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF,
{
    inner: Rc<Round<T>>,
}

impl<T> GraphOperation for Round<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_COMPLEX64_or_DT_INT64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("Round_{}")?
        };
        let mut new_op = graph.new_operation("Round", &op_name)?;
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct Round<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_COMPLEX64_or_DT_INT64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF,
{
    x: Edge<T>,
    id_: usize,
}

impl<T> Round<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_COMPLEX64_or_DT_INT64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF,
{
    pub fn finish(self) -> RoundOp<T> {
        RoundOp::new(Rc::new(self))
    }

    pub fn new(x: Edge<T>) -> Self {
        Self {
            x,
            id_: new_id(),
        }
    }
}

impl<dtypes> OrderedMapClearOp<dtypes>
where dtypes: con,
{
    pub fn new(inner: Rc<OrderedMapClear<dtypes>>) -> Self {
        Self{inner}
    }
}

struct OrderedMapClearOp<dtypes>
where dtypes: con,
{
    inner: Rc<OrderedMapClear<dtypes>>,
}

impl<dtypes> GraphOperation for OrderedMapClear<dtypes>
where dtypes: con,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("OrderedMapClear_{}")?
        };
        let mut new_op = graph.new_operation("OrderedMapClear", &op_name)?;
        {
            match self.capacity {
            }
            None => new_op.set_attr_value_proto("capacity", &vec![24_u8, 0_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_int("capacity", *attr)})(&value),
        };
        {
            match self.memory_limit {
            }
            None => new_op.set_attr_value_proto("memory_limit", &vec![24_u8, 0_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_int("memory_limit", *attr)})(&value),
        };
        {
            match self.container {
            }
            None => new_op.set_attr_value_proto("container", &vec![18_u8, 0_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_string("container", attr)})(&value),
        };
        {
            match self.shared_name {
            }
            None => new_op.set_attr_value_proto("shared_name", &vec![18_u8, 0_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_string("shared_name", attr)})(&value),
        };
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct OrderedMapClear<dtypes>
where dtypes: con,
{
    capacity: Option<i64>,
    memory_limit: Option<i64>,
    container: Option<String>,
    shared_name: Option<String>,
    id_: usize,
}

impl<dtypes> OrderedMapClear<dtypes>
where dtypes: con,
{
    pub fn capacity(&mut self, capacity: int) -> &mut Self {
        self.capacity = Some(capacity);
        &self
    }

    pub fn memory_limit(&mut self, memory_limit: int) -> &mut Self {
        self.memory_limit = Some(memory_limit);
        &self
    }

    pub fn container(&mut self, container: &str) -> &mut Self {
        self.container = Some(container.to_string());
        &self
    }

    pub fn shared_name(&mut self, shared_name: &str) -> &mut Self {
        self.shared_name = Some(shared_name.to_string());
        &self
    }

    pub fn finish(self) -> OrderedMapClearOp<dtypes> {
        OrderedMapClearOp::new(Rc::new(self))
    }

    pub fn new() -> Self {
        Self {
            capacity: None,
            memory_limit: None,
            container: None,
            shared_name: None,
            id_: new_id(),
        }
    }
}

impl<dtypes> MapClearOp<dtypes>
where dtypes: con,
{
    pub fn new(inner: Rc<MapClear<dtypes>>) -> Self {
        Self{inner}
    }
}

struct MapClearOp<dtypes>
where dtypes: con,
{
    inner: Rc<MapClear<dtypes>>,
}

impl<dtypes> GraphOperation for MapClear<dtypes>
where dtypes: con,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("MapClear_{}")?
        };
        let mut new_op = graph.new_operation("MapClear", &op_name)?;
        {
            match self.capacity {
            }
            None => new_op.set_attr_value_proto("capacity", &vec![24_u8, 0_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_int("capacity", *attr)})(&value),
        };
        {
            match self.memory_limit {
            }
            None => new_op.set_attr_value_proto("memory_limit", &vec![24_u8, 0_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_int("memory_limit", *attr)})(&value),
        };
        {
            match self.container {
            }
            None => new_op.set_attr_value_proto("container", &vec![18_u8, 0_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_string("container", attr)})(&value),
        };
        {
            match self.shared_name {
            }
            None => new_op.set_attr_value_proto("shared_name", &vec![18_u8, 0_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_string("shared_name", attr)})(&value),
        };
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct MapClear<dtypes>
where dtypes: con,
{
    capacity: Option<i64>,
    memory_limit: Option<i64>,
    container: Option<String>,
    shared_name: Option<String>,
    id_: usize,
}

impl<dtypes> MapClear<dtypes>
where dtypes: con,
{
    pub fn capacity(&mut self, capacity: int) -> &mut Self {
        self.capacity = Some(capacity);
        &self
    }

    pub fn memory_limit(&mut self, memory_limit: int) -> &mut Self {
        self.memory_limit = Some(memory_limit);
        &self
    }

    pub fn container(&mut self, container: &str) -> &mut Self {
        self.container = Some(container.to_string());
        &self
    }

    pub fn shared_name(&mut self, shared_name: &str) -> &mut Self {
        self.shared_name = Some(shared_name.to_string());
        &self
    }

    pub fn finish(self) -> MapClearOp<dtypes> {
        MapClearOp::new(Rc::new(self))
    }

    pub fn new() -> Self {
        Self {
            capacity: None,
            memory_limit: None,
            container: None,
            shared_name: None,
            id_: new_id(),
        }
    }
}

impl<dtype> TensorArrayV2Op<dtype>
where dtype: con,
{
    pub fn new(inner: Rc<TensorArrayV2<dtype>>) -> Self {
        Self{inner}
    }

    pub fn handle(&self) -> Edge<String> {
        Edge::<String>::new(self.inner.clone(), 0)
    }
}

struct TensorArrayV2Op<dtype>
where dtype: con,
{
    inner: Rc<TensorArrayV2<dtype>>,
}

impl<dtype> GraphOperation for TensorArrayV2<dtype>
where dtype: con,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("TensorArrayV2_{}")?
        };
        let mut new_op = graph.new_operation("TensorArrayV2", &op_name)?;
        {
            match self.element_shape {
            }
            None => new_op.set_attr_value_proto("element_shape", &vec![58_u8, 0_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_shape("element_shape", attr)})(&value),
        };
        {
            match self.dynamic_size {
            }
            None => new_op.set_attr_value_proto("dynamic_size", &vec![40_u8, 0_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_bool("dynamic_size", *attr)})(&value),
        };
        {
            match self.clear_after_read {
            }
            None => new_op.set_attr_value_proto("clear_after_read", &vec![40_u8, 1_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_bool("clear_after_read", *attr)})(&value),
        };
        {
            match self.tensor_array_name {
            }
            None => new_op.set_attr_value_proto("tensor_array_name", &vec![18_u8, 0_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_string("tensor_array_name", attr)})(&value),
        };
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct TensorArrayV2<dtype>
where dtype: con,
{
    size: Edge<i32>,
    element_shape: Option<Shape>,
    dynamic_size: Option<bool>,
    clear_after_read: Option<bool>,
    tensor_array_name: Option<String>,
    id_: usize,
}

impl<dtype> TensorArrayV2<dtype>
where dtype: con,
{
    pub fn element_shape(&mut self, element_shape: &Shape) -> &mut Self {
        self.element_shape = Some(element_shape.clone());
        &self
    }

    pub fn dynamic_size(&mut self, dynamic_size: bool) -> &mut Self {
        self.dynamic_size = Some(dynamic_size);
        &self
    }

    pub fn clear_after_read(&mut self, clear_after_read: bool) -> &mut Self {
        self.clear_after_read = Some(clear_after_read);
        &self
    }

    pub fn tensor_array_name(&mut self, tensor_array_name: &str) -> &mut Self {
        self.tensor_array_name = Some(tensor_array_name.to_string());
        &self
    }

    pub fn finish(self) -> TensorArrayV2Op<dtype> {
        TensorArrayV2Op::new(Rc::new(self))
    }

    pub fn new(size: Edge<i32>) -> Self {
        Self {
            size,
            element_shape: None,
            dynamic_size: None,
            clear_after_read: None,
            tensor_array_name: None,
            id_: new_id(),
        }
    }
}

pub trait con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_COMPLEX64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_COMPLEX64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF for BFloat16 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_COMPLEX64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF for OtherComplex<f32> {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_COMPLEX64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF for OtherComplex<f64> {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_COMPLEX64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF for f32 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_COMPLEX64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF for f64 {
}

impl<T> AcoshOp<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_COMPLEX64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF,
{
    pub fn new(inner: Rc<Acosh<T>>) -> Self {
        Self{inner}
    }

    pub fn y(&self) -> Edge<T> {
        Edge::<T>::new(self.inner.clone(), 0)
    }
}

struct AcoshOp<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_COMPLEX64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF,
{
    inner: Rc<Acosh<T>>,
}

impl<T> GraphOperation for Acosh<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_COMPLEX64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("Acosh_{}")?
        };
        let mut new_op = graph.new_operation("Acosh", &op_name)?;
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct Acosh<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_COMPLEX64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF,
{
    x: Edge<T>,
    id_: usize,
}

impl<T> Acosh<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_COMPLEX64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF,
{
    pub fn finish(self) -> AcoshOp<T> {
        AcoshOp::new(Rc::new(self))
    }

    pub fn new(x: Edge<T>) -> Self {
        Self {
            x,
            id_: new_id(),
        }
    }
}

impl<dtypes> MapSizeOp<dtypes>
where dtypes: con,
{
    pub fn new(inner: Rc<MapSize<dtypes>>) -> Self {
        Self{inner}
    }

    pub fn size(&self) -> Edge<i32> {
        Edge::<i32>::new(self.inner.clone(), 0)
    }
}

struct MapSizeOp<dtypes>
where dtypes: con,
{
    inner: Rc<MapSize<dtypes>>,
}

impl<dtypes> GraphOperation for MapSize<dtypes>
where dtypes: con,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("MapSize_{}")?
        };
        let mut new_op = graph.new_operation("MapSize", &op_name)?;
        {
            match self.capacity {
            }
            None => new_op.set_attr_value_proto("capacity", &vec![24_u8, 0_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_int("capacity", *attr)})(&value),
        };
        {
            match self.memory_limit {
            }
            None => new_op.set_attr_value_proto("memory_limit", &vec![24_u8, 0_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_int("memory_limit", *attr)})(&value),
        };
        {
            match self.container {
            }
            None => new_op.set_attr_value_proto("container", &vec![18_u8, 0_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_string("container", attr)})(&value),
        };
        {
            match self.shared_name {
            }
            None => new_op.set_attr_value_proto("shared_name", &vec![18_u8, 0_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_string("shared_name", attr)})(&value),
        };
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct MapSize<dtypes>
where dtypes: con,
{
    capacity: Option<i64>,
    memory_limit: Option<i64>,
    container: Option<String>,
    shared_name: Option<String>,
    id_: usize,
}

impl<dtypes> MapSize<dtypes>
where dtypes: con,
{
    pub fn capacity(&mut self, capacity: int) -> &mut Self {
        self.capacity = Some(capacity);
        &self
    }

    pub fn memory_limit(&mut self, memory_limit: int) -> &mut Self {
        self.memory_limit = Some(memory_limit);
        &self
    }

    pub fn container(&mut self, container: &str) -> &mut Self {
        self.container = Some(container.to_string());
        &self
    }

    pub fn shared_name(&mut self, shared_name: &str) -> &mut Self {
        self.shared_name = Some(shared_name.to_string());
        &self
    }

    pub fn finish(self) -> MapSizeOp<dtypes> {
        MapSizeOp::new(Rc::new(self))
    }

    pub fn new() -> Self {
        Self {
            capacity: None,
            memory_limit: None,
            container: None,
            shared_name: None,
            id_: new_id(),
        }
    }
}

impl<T, Tshift, Taxis> RollOp<T, Tshift, Taxis>
where T: con,
      Tshift: con_or_DT_INT32_or_DT_INT64,
      Taxis: con_or_DT_INT32_or_DT_INT64,
{
    pub fn new(inner: Rc<Roll<T, Tshift, Taxis>>) -> Self {
        Self{inner}
    }

    pub fn output(&self) -> Edge<T> {
        Edge::<T>::new(self.inner.clone(), 0)
    }
}

struct RollOp<T, Tshift, Taxis>
where T: con,
      Tshift: con_or_DT_INT32_or_DT_INT64,
      Taxis: con_or_DT_INT32_or_DT_INT64,
{
    inner: Rc<Roll<T, Tshift, Taxis>>,
}

impl<T, Tshift, Taxis> GraphOperation for Roll<T, Tshift, Taxis>
where T: con,
      Tshift: con_or_DT_INT32_or_DT_INT64,
      Taxis: con_or_DT_INT32_or_DT_INT64,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("Roll_{}")?
        };
        let mut new_op = graph.new_operation("Roll", &op_name)?;
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct Roll<T, Tshift, Taxis>
where T: con,
      Tshift: con_or_DT_INT32_or_DT_INT64,
      Taxis: con_or_DT_INT32_or_DT_INT64,
{
    input: Edge<T>,
    shift: Edge<Tshift>,
    axis: Edge<Taxis>,
    id_: usize,
}

impl<T, Tshift, Taxis> Roll<T, Tshift, Taxis>
where T: con,
      Tshift: con_or_DT_INT32_or_DT_INT64,
      Taxis: con_or_DT_INT32_or_DT_INT64,
{
    pub fn finish(self) -> RollOp<T, Tshift, Taxis> {
        RollOp::new(Rc::new(self))
    }

    pub fn new(input: Edge<T>, shift: Edge<Tshift>, axis: Edge<Taxis>) -> Self {
        Self {
            input,
            shift,
            axis,
            id_: new_id(),
        }
    }
}

impl<dtypes> StageClearOp<dtypes>
where dtypes: con,
{
    pub fn new(inner: Rc<StageClear<dtypes>>) -> Self {
        Self{inner}
    }
}

struct StageClearOp<dtypes>
where dtypes: con,
{
    inner: Rc<StageClear<dtypes>>,
}

impl<dtypes> GraphOperation for StageClear<dtypes>
where dtypes: con,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("StageClear_{}")?
        };
        let mut new_op = graph.new_operation("StageClear", &op_name)?;
        {
            match self.capacity {
            }
            None => new_op.set_attr_value_proto("capacity", &vec![24_u8, 0_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_int("capacity", *attr)})(&value),
        };
        {
            match self.memory_limit {
            }
            None => new_op.set_attr_value_proto("memory_limit", &vec![24_u8, 0_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_int("memory_limit", *attr)})(&value),
        };
        {
            match self.container {
            }
            None => new_op.set_attr_value_proto("container", &vec![18_u8, 0_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_string("container", attr)})(&value),
        };
        {
            match self.shared_name {
            }
            None => new_op.set_attr_value_proto("shared_name", &vec![18_u8, 0_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_string("shared_name", attr)})(&value),
        };
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct StageClear<dtypes>
where dtypes: con,
{
    capacity: Option<i64>,
    memory_limit: Option<i64>,
    container: Option<String>,
    shared_name: Option<String>,
    id_: usize,
}

impl<dtypes> StageClear<dtypes>
where dtypes: con,
{
    pub fn capacity(&mut self, capacity: int) -> &mut Self {
        self.capacity = Some(capacity);
        &self
    }

    pub fn memory_limit(&mut self, memory_limit: int) -> &mut Self {
        self.memory_limit = Some(memory_limit);
        &self
    }

    pub fn container(&mut self, container: &str) -> &mut Self {
        self.container = Some(container.to_string());
        &self
    }

    pub fn shared_name(&mut self, shared_name: &str) -> &mut Self {
        self.shared_name = Some(shared_name.to_string());
        &self
    }

    pub fn finish(self) -> StageClearOp<dtypes> {
        StageClearOp::new(Rc::new(self))
    }

    pub fn new() -> Self {
        Self {
            capacity: None,
            memory_limit: None,
            container: None,
            shared_name: None,
            id_: new_id(),
        }
    }
}

impl NonMaxSuppressionWithOverlapsOp {
    pub fn new(inner: Rc<NonMaxSuppressionWithOverlaps>) -> Self {
        Self{inner}
    }

    pub fn selected_indices(&self) -> Edge<i32> {
        Edge::<i32>::new(self.inner.clone(), 0)
    }
}

struct NonMaxSuppressionWithOverlapsOp {
    inner: Rc<NonMaxSuppressionWithOverlaps>,
}

impl GraphOperation for NonMaxSuppressionWithOverlaps {
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("NonMaxSuppressionWithOverlaps_{}")?
        };
        let mut new_op = graph.new_operation("NonMaxSuppressionWithOverlaps", &op_name)?;
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct NonMaxSuppressionWithOverlaps {
    overlaps: Edge<f32>,
    scores: Edge<f32>,
    max_output_size: Edge<i32>,
    overlap_threshold: Edge<f32>,
    score_threshold: Edge<f32>,
    id_: usize,
}

impl NonMaxSuppressionWithOverlaps {
    pub fn finish(self) -> NonMaxSuppressionWithOverlapsOp {
        NonMaxSuppressionWithOverlapsOp::new(Rc::new(self))
    }

    pub fn new(overlaps: Edge<f32>, scores: Edge<f32>, max_output_size: Edge<i32>, overlap_threshold: Edge<f32>, score_threshold: Edge<f32>) -> Self {
        Self {
            overlaps,
            scores,
            max_output_size,
            overlap_threshold,
            score_threshold,
            id_: new_id(),
        }
    }
}

impl<T> AvgPoolGradOp<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
{
    pub fn new(inner: Rc<AvgPoolGrad<T>>) -> Self {
        Self{inner}
    }

    pub fn output(&self) -> Edge<T> {
        Edge::<T>::new(self.inner.clone(), 0)
    }
}

struct AvgPoolGradOp<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
{
    inner: Rc<AvgPoolGrad<T>>,
}

impl<T> GraphOperation for AvgPoolGrad<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("AvgPoolGrad_{}")?
        };
        let mut new_op = graph.new_operation("AvgPoolGrad", &op_name)?;
        {
            (|attrs| {new_op.set_attr_int_list("ksize", attrs)})(&self.ksize)
        }
        {
            (|attrs| {new_op.set_attr_int_list("strides", attrs)})(&self.strides)
        }
        {
            (|attr| {new_op.set_attr_string("padding", attr)})(&self.padding)
        }
        {
            match self.data_format {
            }
            None => new_op.set_attr_value_proto("data_format", &vec![18_u8, 4_u8, 78_u8, 72_u8, 87_u8, 67_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_string("data_format", attr)})(&value),
        };
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct AvgPoolGrad<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
{
    orig_input_shape: Edge<i32>,
    grad: Edge<T>,
    ksize: Vec<i64>,
    strides: Vec<i64>,
    padding: String,
    data_format: Option<String>,
    id_: usize,
}

impl<T> AvgPoolGrad<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
{
    pub fn data_format(&mut self, data_format: &str) -> &mut Self {
        self.data_format = Some(data_format.to_string());
        &self
    }

    pub fn finish(self) -> AvgPoolGradOp<T> {
        AvgPoolGradOp::new(Rc::new(self))
    }

    pub fn new(orig_input_shape: Edge<i32>, grad: Edge<T>, ksize: &[int], strides: &[int], padding: &str) -> Self {
        Self {
            orig_input_shape,
            grad,
            ksize: ksize.to_vec()
            strides: strides.to_vec()
            padding: padding.to_string()
            data_format: None,
            id_: new_id(),
        }
    }
}

impl<dtypes> StageSizeOp<dtypes>
where dtypes: con,
{
    pub fn new(inner: Rc<StageSize<dtypes>>) -> Self {
        Self{inner}
    }

    pub fn size(&self) -> Edge<i32> {
        Edge::<i32>::new(self.inner.clone(), 0)
    }
}

struct StageSizeOp<dtypes>
where dtypes: con,
{
    inner: Rc<StageSize<dtypes>>,
}

impl<dtypes> GraphOperation for StageSize<dtypes>
where dtypes: con,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("StageSize_{}")?
        };
        let mut new_op = graph.new_operation("StageSize", &op_name)?;
        {
            match self.capacity {
            }
            None => new_op.set_attr_value_proto("capacity", &vec![24_u8, 0_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_int("capacity", *attr)})(&value),
        };
        {
            match self.memory_limit {
            }
            None => new_op.set_attr_value_proto("memory_limit", &vec![24_u8, 0_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_int("memory_limit", *attr)})(&value),
        };
        {
            match self.container {
            }
            None => new_op.set_attr_value_proto("container", &vec![18_u8, 0_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_string("container", attr)})(&value),
        };
        {
            match self.shared_name {
            }
            None => new_op.set_attr_value_proto("shared_name", &vec![18_u8, 0_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_string("shared_name", attr)})(&value),
        };
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct StageSize<dtypes>
where dtypes: con,
{
    capacity: Option<i64>,
    memory_limit: Option<i64>,
    container: Option<String>,
    shared_name: Option<String>,
    id_: usize,
}

impl<dtypes> StageSize<dtypes>
where dtypes: con,
{
    pub fn capacity(&mut self, capacity: int) -> &mut Self {
        self.capacity = Some(capacity);
        &self
    }

    pub fn memory_limit(&mut self, memory_limit: int) -> &mut Self {
        self.memory_limit = Some(memory_limit);
        &self
    }

    pub fn container(&mut self, container: &str) -> &mut Self {
        self.container = Some(container.to_string());
        &self
    }

    pub fn shared_name(&mut self, shared_name: &str) -> &mut Self {
        self.shared_name = Some(shared_name.to_string());
        &self
    }

    pub fn finish(self) -> StageSizeOp<dtypes> {
        StageSizeOp::new(Rc::new(self))
    }

    pub fn new() -> Self {
        Self {
            capacity: None,
            memory_limit: None,
            container: None,
            shared_name: None,
            id_: new_id(),
        }
    }
}

impl<Tshape, T> Conv3DBackpropInputV2Op<Tshape, T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
      Tshape: con_or_DT_INT32_or_DT_INT64,
{
    pub fn new(inner: Rc<Conv3DBackpropInputV2<Tshape, T>>) -> Self {
        Self{inner}
    }

    pub fn output(&self) -> Edge<T> {
        Edge::<T>::new(self.inner.clone(), 0)
    }
}

struct Conv3DBackpropInputV2Op<Tshape, T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
      Tshape: con_or_DT_INT32_or_DT_INT64,
{
    inner: Rc<Conv3DBackpropInputV2<Tshape, T>>,
}

impl<Tshape, T> GraphOperation for Conv3DBackpropInputV2<Tshape, T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
      Tshape: con_or_DT_INT32_or_DT_INT64,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("Conv3DBackpropInputV2_{}")?
        };
        let mut new_op = graph.new_operation("Conv3DBackpropInputV2", &op_name)?;
        {
            (|attrs| {new_op.set_attr_int_list("strides", attrs)})(&self.strides)
        }
        {
            (|attr| {new_op.set_attr_string("padding", attr)})(&self.padding)
        }
        {
            match self.data_format {
            }
            None => new_op.set_attr_value_proto("data_format", &vec![18_u8, 5_u8, 78_u8, 68_u8, 72_u8, 87_u8, 67_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_string("data_format", attr)})(&value),
        };
        {
            match self.dilations {
            }
            None => new_op.set_attr_value_proto("dilations", &vec![10_u8, 0_u8, 26_u8, 5_u8, 1_u8, 1_u8, 1_u8, 1_u8,]);,
            Some(value) => (|attrs| {new_op.set_attr_int_list("dilations", attrs)})(&value),
        };
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct Conv3DBackpropInputV2<Tshape, T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
      Tshape: con_or_DT_INT32_or_DT_INT64,
{
    input_sizes: Edge<Tshape>,
    filter: Edge<T>,
    out_backprop: Edge<T>,
    strides: Vec<i64>,
    padding: String,
    data_format: Option<String>,
    dilations: Option<Vec<i64>>,
    id_: usize,
}

impl<Tshape, T> Conv3DBackpropInputV2<Tshape, T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
      Tshape: con_or_DT_INT32_or_DT_INT64,
{
    pub fn data_format(&mut self, data_format: &str) -> &mut Self {
        self.data_format = Some(data_format.to_string());
        &self
    }

    pub fn dilations(&mut self, dilations: &[int]) -> &mut Self {
        self.dilations = Some(dilations.to_vec());
        &self
    }

    pub fn finish(self) -> Conv3DBackpropInputV2Op<Tshape, T> {
        Conv3DBackpropInputV2Op::new(Rc::new(self))
    }

    pub fn new(input_sizes: Edge<Tshape>, filter: Edge<T>, out_backprop: Edge<T>, strides: &[int], padding: &str) -> Self {
        Self {
            input_sizes,
            filter,
            out_backprop,
            strides: strides.to_vec()
            padding: padding.to_string()
            data_format: None,
            dilations: None,
            id_: new_id(),
        }
    }
}

impl<T> DepthToSpaceOp<T>
where T: con,
{
    pub fn new(inner: Rc<DepthToSpace<T>>) -> Self {
        Self{inner}
    }

    pub fn output(&self) -> Edge<T> {
        Edge::<T>::new(self.inner.clone(), 0)
    }
}

struct DepthToSpaceOp<T>
where T: con,
{
    inner: Rc<DepthToSpace<T>>,
}

impl<T> GraphOperation for DepthToSpace<T>
where T: con,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("DepthToSpace_{}")?
        };
        let mut new_op = graph.new_operation("DepthToSpace", &op_name)?;
        {
            (|attr| {new_op.set_attr_int("block_size", *attr)})(&self.block_size)
        }
        {
            match self.data_format {
            }
            None => new_op.set_attr_value_proto("data_format", &vec![18_u8, 4_u8, 78_u8, 72_u8, 87_u8, 67_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_string("data_format", attr)})(&value),
        };
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct DepthToSpace<T>
where T: con,
{
    input: Edge<T>,
    block_size: i64,
    data_format: Option<String>,
    id_: usize,
}

impl<T> DepthToSpace<T>
where T: con,
{
    pub fn data_format(&mut self, data_format: &str) -> &mut Self {
        self.data_format = Some(data_format.to_string());
        &self
    }

    pub fn finish(self) -> DepthToSpaceOp<T> {
        DepthToSpaceOp::new(Rc::new(self))
    }

    pub fn new(input: Edge<T>, block_size: int) -> Self {
        Self {
            input,
            block_size: block_size
            data_format: None,
            id_: new_id(),
        }
    }
}

impl BarrierReadySizeOp {
    pub fn new(inner: Rc<BarrierReadySize>) -> Self {
        Self{inner}
    }

    pub fn size(&self) -> Edge<i32> {
        Edge::<i32>::new(self.inner.clone(), 0)
    }
}

struct BarrierReadySizeOp {
    inner: Rc<BarrierReadySize>,
}

impl GraphOperation for BarrierReadySize {
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("BarrierReadySize_{}")?
        };
        let mut new_op = graph.new_operation("BarrierReadySize", &op_name)?;
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct BarrierReadySize {
    handle: Edge<String>,
    id_: usize,
}

impl BarrierReadySize {
    pub fn finish(self) -> BarrierReadySizeOp {
        BarrierReadySizeOp::new(Rc::new(self))
    }

    pub fn new(handle: Edge<String>) -> Self {
        Self {
            handle,
            id_: new_id(),
        }
    }
}

impl FakeQuantWithMinMaxArgsOp {
    pub fn new(inner: Rc<FakeQuantWithMinMaxArgs>) -> Self {
        Self{inner}
    }

    pub fn outputs(&self) -> Edge<f32> {
        Edge::<f32>::new(self.inner.clone(), 0)
    }
}

struct FakeQuantWithMinMaxArgsOp {
    inner: Rc<FakeQuantWithMinMaxArgs>,
}

impl GraphOperation for FakeQuantWithMinMaxArgs {
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("FakeQuantWithMinMaxArgs_{}")?
        };
        let mut new_op = graph.new_operation("FakeQuantWithMinMaxArgs", &op_name)?;
        {
            match self.min {
            }
            None => new_op.set_attr_value_proto("min", &vec![37_u8, 0_u8, 0_u8, 192_u8, 192_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_float("min", *attr)})(&value),
        };
        {
            match self.max {
            }
            None => new_op.set_attr_value_proto("max", &vec![37_u8, 0_u8, 0_u8, 192_u8, 64_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_float("max", *attr)})(&value),
        };
        {
            match self.num_bits {
            }
            None => new_op.set_attr_value_proto("num_bits", &vec![24_u8, 8_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_int("num_bits", *attr)})(&value),
        };
        {
            match self.narrow_range {
            }
            None => new_op.set_attr_value_proto("narrow_range", &vec![40_u8, 0_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_bool("narrow_range", *attr)})(&value),
        };
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct FakeQuantWithMinMaxArgs {
    inputs: Edge<f32>,
    min: Option<f32>,
    max: Option<f32>,
    num_bits: Option<i64>,
    narrow_range: Option<bool>,
    id_: usize,
}

impl FakeQuantWithMinMaxArgs {
    pub fn min(&mut self, min: f32) -> &mut Self {
        self.min = Some(min);
        &self
    }

    pub fn max(&mut self, max: f32) -> &mut Self {
        self.max = Some(max);
        &self
    }

    pub fn num_bits(&mut self, num_bits: int) -> &mut Self {
        self.num_bits = Some(num_bits);
        &self
    }

    pub fn narrow_range(&mut self, narrow_range: bool) -> &mut Self {
        self.narrow_range = Some(narrow_range);
        &self
    }

    pub fn finish(self) -> FakeQuantWithMinMaxArgsOp {
        FakeQuantWithMinMaxArgsOp::new(Rc::new(self))
    }

    pub fn new(inputs: Edge<f32>) -> Self {
        Self {
            inputs,
            min: None,
            max: None,
            num_bits: None,
            narrow_range: None,
            id_: new_id(),
        }
    }
}

impl BarrierCloseOp {
    pub fn new(inner: Rc<BarrierClose>) -> Self {
        Self{inner}
    }
}

struct BarrierCloseOp {
    inner: Rc<BarrierClose>,
}

impl GraphOperation for BarrierClose {
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("BarrierClose_{}")?
        };
        let mut new_op = graph.new_operation("BarrierClose", &op_name)?;
        {
            match self.cancel_pending_enqueues {
            }
            None => new_op.set_attr_value_proto("cancel_pending_enqueues", &vec![40_u8, 0_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_bool("cancel_pending_enqueues", *attr)})(&value),
        };
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct BarrierClose {
    handle: Edge<String>,
    cancel_pending_enqueues: Option<bool>,
    id_: usize,
}

impl BarrierClose {
    pub fn cancel_pending_enqueues(&mut self, cancel_pending_enqueues: bool) -> &mut Self {
        self.cancel_pending_enqueues = Some(cancel_pending_enqueues);
        &self
    }

    pub fn finish(self) -> BarrierCloseOp {
        BarrierCloseOp::new(Rc::new(self))
    }

    pub fn new(handle: Edge<String>) -> Self {
        Self {
            handle,
            cancel_pending_enqueues: None,
            id_: new_id(),
        }
    }
}

impl<T> BarrierInsertManyOp<T>
where T: con,
{
    pub fn new(inner: Rc<BarrierInsertMany<T>>) -> Self {
        Self{inner}
    }
}

struct BarrierInsertManyOp<T>
where T: con,
{
    inner: Rc<BarrierInsertMany<T>>,
}

impl<T> GraphOperation for BarrierInsertMany<T>
where T: con,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("BarrierInsertMany_{}")?
        };
        let mut new_op = graph.new_operation("BarrierInsertMany", &op_name)?;
        {
            (|attr| {new_op.set_attr_int("component_index", *attr)})(&self.component_index)
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct BarrierInsertMany<T>
where T: con,
{
    handle: Edge<String>,
    keys: Edge<String>,
    values: Edge<T>,
    component_index: i64,
    id_: usize,
}

impl<T> BarrierInsertMany<T>
where T: con,
{
    pub fn finish(self) -> BarrierInsertManyOp<T> {
        BarrierInsertManyOp::new(Rc::new(self))
    }

    pub fn new(handle: Edge<String>, keys: Edge<String>, values: Edge<T>, component_index: int) -> Self {
        Self {
            handle,
            keys,
            values,
            component_index: component_index
            id_: new_id(),
        }
    }
}

impl<T> ErfOp<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
{
    pub fn new(inner: Rc<Erf<T>>) -> Self {
        Self{inner}
    }

    pub fn y(&self) -> Edge<T> {
        Edge::<T>::new(self.inner.clone(), 0)
    }
}

struct ErfOp<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
{
    inner: Rc<Erf<T>>,
}

impl<T> GraphOperation for Erf<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("Erf_{}")?
        };
        let mut new_op = graph.new_operation("Erf", &op_name)?;
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct Erf<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
{
    x: Edge<T>,
    id_: usize,
}

impl<T> Erf<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
{
    pub fn finish(self) -> ErfOp<T> {
        ErfOp::new(Rc::new(self))
    }

    pub fn new(x: Edge<T>) -> Self {
        Self {
            x,
            id_: new_id(),
        }
    }
}

impl<T> FloorOp<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
{
    pub fn new(inner: Rc<Floor<T>>) -> Self {
        Self{inner}
    }

    pub fn y(&self) -> Edge<T> {
        Edge::<T>::new(self.inner.clone(), 0)
    }
}

struct FloorOp<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
{
    inner: Rc<Floor<T>>,
}

impl<T> GraphOperation for Floor<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("Floor_{}")?
        };
        let mut new_op = graph.new_operation("Floor", &op_name)?;
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct Floor<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
{
    x: Edge<T>,
    id_: usize,
}

impl<T> Floor<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
{
    pub fn finish(self) -> FloorOp<T> {
        FloorOp::new(Rc::new(self))
    }

    pub fn new(x: Edge<T>) -> Self {
        Self {
            x,
            id_: new_id(),
        }
    }
}

impl TensorArraySizeV2Op {
    pub fn new(inner: Rc<TensorArraySizeV2>) -> Self {
        Self{inner}
    }

    pub fn size(&self) -> Edge<i32> {
        Edge::<i32>::new(self.inner.clone(), 0)
    }
}

struct TensorArraySizeV2Op {
    inner: Rc<TensorArraySizeV2>,
}

impl GraphOperation for TensorArraySizeV2 {
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("TensorArraySizeV2_{}")?
        };
        let mut new_op = graph.new_operation("TensorArraySizeV2", &op_name)?;
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct TensorArraySizeV2 {
    handle: Edge<String>,
    flow_in: Edge<f32>,
    id_: usize,
}

impl TensorArraySizeV2 {
    pub fn finish(self) -> TensorArraySizeV2Op {
        TensorArraySizeV2Op::new(Rc::new(self))
    }

    pub fn new(handle: Edge<String>, flow_in: Edge<f32>) -> Self {
        Self {
            handle,
            flow_in,
            id_: new_id(),
        }
    }
}

impl<dtype> TensorArrayConcatOp<dtype>
where dtype: con,
{
    pub fn new(inner: Rc<TensorArrayConcat<dtype>>) -> Self {
        Self{inner}
    }

    pub fn value(&self) -> Edge<dtype> {
        Edge::<dtype>::new(self.inner.clone(), 0)
    }

    pub fn lengths(&self) -> Edge<i64> {
        Edge::<i64>::new(self.inner.clone(), 1)
    }
}

struct TensorArrayConcatOp<dtype>
where dtype: con,
{
    inner: Rc<TensorArrayConcat<dtype>>,
}

impl<dtype> GraphOperation for TensorArrayConcat<dtype>
where dtype: con,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("TensorArrayConcat_{}")?
        };
        let mut new_op = graph.new_operation("TensorArrayConcat", &op_name)?;
        {
            match self.element_shape_except0 {
            }
            None => new_op.set_attr_value_proto("element_shape_except0", &vec![58_u8, 0_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_shape("element_shape_except0", attr)})(&value),
        };
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct TensorArrayConcat<dtype>
where dtype: con,
{
    handle: Edge<String>,
    flow_in: Edge<f32>,
    element_shape_except0: Option<Shape>,
    id_: usize,
}

impl<dtype> TensorArrayConcat<dtype>
where dtype: con,
{
    pub fn element_shape_except0(&mut self, element_shape_except0: &Shape) -> &mut Self {
        self.element_shape_except0 = Some(element_shape_except0.clone());
        &self
    }

    pub fn finish(self) -> TensorArrayConcatOp<dtype> {
        TensorArrayConcatOp::new(Rc::new(self))
    }

    pub fn new(handle: Edge<String>, flow_in: Edge<f32>) -> Self {
        Self {
            handle,
            flow_in,
            element_shape_except0: None,
            id_: new_id(),
        }
    }
}

pub trait con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_COMPLEX64_or_DT_COMPLEX128 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_COMPLEX64_or_DT_COMPLEX128 for OtherComplex<f32> {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_COMPLEX64_or_DT_COMPLEX128 for OtherComplex<f64> {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_COMPLEX64_or_DT_COMPLEX128 for f32 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_COMPLEX64_or_DT_COMPLEX128 for f64 {
}

impl<T> MatrixSquareRootOp<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_COMPLEX64_or_DT_COMPLEX128,
{
    pub fn new(inner: Rc<MatrixSquareRoot<T>>) -> Self {
        Self{inner}
    }

    pub fn output(&self) -> Edge<T> {
        Edge::<T>::new(self.inner.clone(), 0)
    }
}

struct MatrixSquareRootOp<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_COMPLEX64_or_DT_COMPLEX128,
{
    inner: Rc<MatrixSquareRoot<T>>,
}

impl<T> GraphOperation for MatrixSquareRoot<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_COMPLEX64_or_DT_COMPLEX128,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("MatrixSquareRoot_{}")?
        };
        let mut new_op = graph.new_operation("MatrixSquareRoot", &op_name)?;
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct MatrixSquareRoot<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_COMPLEX64_or_DT_COMPLEX128,
{
    input: Edge<T>,
    id_: usize,
}

impl<T> MatrixSquareRoot<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_COMPLEX64_or_DT_COMPLEX128,
{
    pub fn finish(self) -> MatrixSquareRootOp<T> {
        MatrixSquareRootOp::new(Rc::new(self))
    }

    pub fn new(input: Edge<T>) -> Self {
        Self {
            input,
            id_: new_id(),
        }
    }
}

impl<T, Tindices> SparseApplyAdagradDAOp<T, Tindices>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      Tindices: con_or_DT_INT32_or_DT_INT64,
{
    pub fn new(inner: Rc<SparseApplyAdagradDA<T, Tindices>>) -> Self {
        Self{inner}
    }

    pub fn out(&self) -> Edge<T> {
        Edge::<T>::new(self.inner.clone(), 0)
    }
}

struct SparseApplyAdagradDAOp<T, Tindices>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      Tindices: con_or_DT_INT32_or_DT_INT64,
{
    inner: Rc<SparseApplyAdagradDA<T, Tindices>>,
}

impl<T, Tindices> GraphOperation for SparseApplyAdagradDA<T, Tindices>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      Tindices: con_or_DT_INT32_or_DT_INT64,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("SparseApplyAdagradDA_{}")?
        };
        let mut new_op = graph.new_operation("SparseApplyAdagradDA", &op_name)?;
        {
            match self.use_locking {
            }
            None => new_op.set_attr_value_proto("use_locking", &vec![40_u8, 0_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_bool("use_locking", *attr)})(&value),
        };
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct SparseApplyAdagradDA<T, Tindices>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      Tindices: con_or_DT_INT32_or_DT_INT64,
{
    var: Edge<T>,
    gradient_accumulator: Edge<T>,
    gradient_squared_accumulator: Edge<T>,
    grad: Edge<T>,
    indices: Edge<Tindices>,
    lr: Edge<T>,
    l1: Edge<T>,
    l2: Edge<T>,
    global_step: Edge<i64>,
    use_locking: Option<bool>,
    id_: usize,
}

impl<T, Tindices> SparseApplyAdagradDA<T, Tindices>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      Tindices: con_or_DT_INT32_or_DT_INT64,
{
    pub fn use_locking(&mut self, use_locking: bool) -> &mut Self {
        self.use_locking = Some(use_locking);
        &self
    }

    pub fn finish(self) -> SparseApplyAdagradDAOp<T, Tindices> {
        SparseApplyAdagradDAOp::new(Rc::new(self))
    }

    pub fn new(var: Edge<T>, gradient_accumulator: Edge<T>, gradient_squared_accumulator: Edge<T>, grad: Edge<T>, indices: Edge<Tindices>, lr: Edge<T>, l1: Edge<T>, l2: Edge<T>, global_step: Edge<i64>) -> Self {
        Self {
            var,
            gradient_accumulator,
            gradient_squared_accumulator,
            grad,
            indices,
            lr,
            l1,
            l2,
            global_step,
            use_locking: None,
            id_: new_id(),
        }
    }
}

impl<T> DivNoNanOp<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE,
{
    pub fn new(inner: Rc<DivNoNan<T>>) -> Self {
        Self{inner}
    }

    pub fn z(&self) -> Edge<T> {
        Edge::<T>::new(self.inner.clone(), 0)
    }
}

struct DivNoNanOp<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE,
{
    inner: Rc<DivNoNan<T>>,
}

impl<T> GraphOperation for DivNoNan<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("DivNoNan_{}")?
        };
        let mut new_op = graph.new_operation("DivNoNan", &op_name)?;
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct DivNoNan<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE,
{
    x: Edge<T>,
    y: Edge<T>,
    id_: usize,
}

impl<T> DivNoNan<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE,
{
    pub fn finish(self) -> DivNoNanOp<T> {
        DivNoNanOp::new(Rc::new(self))
    }

    pub fn new(x: Edge<T>, y: Edge<T>) -> Self {
        Self {
            x,
            y,
            id_: new_id(),
        }
    }
}

impl<T> TensorArrayScatterOp<T>
where T: con,
{
    pub fn new(inner: Rc<TensorArrayScatter<T>>) -> Self {
        Self{inner}
    }

    pub fn flow_out(&self) -> Edge<f32> {
        Edge::<f32>::new(self.inner.clone(), 0)
    }
}

struct TensorArrayScatterOp<T>
where T: con,
{
    inner: Rc<TensorArrayScatter<T>>,
}

impl<T> GraphOperation for TensorArrayScatter<T>
where T: con,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("TensorArrayScatter_{}")?
        };
        let mut new_op = graph.new_operation("TensorArrayScatter", &op_name)?;
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct TensorArrayScatter<T>
where T: con,
{
    handle: Edge<String>,
    indices: Edge<i32>,
    value: Edge<T>,
    flow_in: Edge<f32>,
    id_: usize,
}

impl<T> TensorArrayScatter<T>
where T: con,
{
    pub fn finish(self) -> TensorArrayScatterOp<T> {
        TensorArrayScatterOp::new(Rc::new(self))
    }

    pub fn new(handle: Edge<String>, indices: Edge<i32>, value: Edge<T>, flow_in: Edge<f32>) -> Self {
        Self {
            handle,
            indices,
            value,
            flow_in,
            id_: new_id(),
        }
    }
}

impl<T> SparseReduceMaxOp<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
{
    pub fn new(inner: Rc<SparseReduceMax<T>>) -> Self {
        Self{inner}
    }

    pub fn output(&self) -> Edge<T> {
        Edge::<T>::new(self.inner.clone(), 0)
    }
}

struct SparseReduceMaxOp<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
{
    inner: Rc<SparseReduceMax<T>>,
}

impl<T> GraphOperation for SparseReduceMax<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("SparseReduceMax_{}")?
        };
        let mut new_op = graph.new_operation("SparseReduceMax", &op_name)?;
        {
            match self.keep_dims {
            }
            None => new_op.set_attr_value_proto("keep_dims", &vec![40_u8, 0_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_bool("keep_dims", *attr)})(&value),
        };
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct SparseReduceMax<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
{
    input_indices: Edge<i64>,
    input_values: Edge<T>,
    input_shape: Edge<i64>,
    reduction_axes: Edge<i32>,
    keep_dims: Option<bool>,
    id_: usize,
}

impl<T> SparseReduceMax<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
{
    pub fn keep_dims(&mut self, keep_dims: bool) -> &mut Self {
        self.keep_dims = Some(keep_dims);
        &self
    }

    pub fn finish(self) -> SparseReduceMaxOp<T> {
        SparseReduceMaxOp::new(Rc::new(self))
    }

    pub fn new(input_indices: Edge<i64>, input_values: Edge<T>, input_shape: Edge<i64>, reduction_axes: Edge<i32>) -> Self {
        Self {
            input_indices,
            input_values,
            input_shape,
            reduction_axes,
            keep_dims: None,
            id_: new_id(),
        }
    }
}

impl<T> TensorArrayUnpackOp<T>
where T: con,
{
    pub fn new(inner: Rc<TensorArrayUnpack<T>>) -> Self {
        Self{inner}
    }

    pub fn flow_out(&self) -> Edge<f32> {
        Edge::<f32>::new(self.inner.clone(), 0)
    }
}

struct TensorArrayUnpackOp<T>
where T: con,
{
    inner: Rc<TensorArrayUnpack<T>>,
}

impl<T> GraphOperation for TensorArrayUnpack<T>
where T: con,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("TensorArrayUnpack_{}")?
        };
        let mut new_op = graph.new_operation("TensorArrayUnpack", &op_name)?;
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct TensorArrayUnpack<T>
where T: con,
{
    handle: Edge<String>,
    value: Edge<T>,
    flow_in: Edge<f32>,
    id_: usize,
}

impl<T> TensorArrayUnpack<T>
where T: con,
{
    pub fn finish(self) -> TensorArrayUnpackOp<T> {
        TensorArrayUnpackOp::new(Rc::new(self))
    }

    pub fn new(handle: Edge<String>, value: Edge<T>, flow_in: Edge<f32>) -> Self {
        Self {
            handle,
            value,
            flow_in,
            id_: new_id(),
        }
    }
}

impl _ConfigureDistributedTPUOp {
    pub fn new(inner: Rc<_ConfigureDistributedTPU>) -> Self {
        Self{inner}
    }

    pub fn output(&self) -> Edge<String> {
        Edge::<String>::new(self.inner.clone(), 0)
    }
}

struct _ConfigureDistributedTPUOp {
    inner: Rc<_ConfigureDistributedTPU>,
}

impl GraphOperation for _ConfigureDistributedTPU {
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("_ConfigureDistributedTPU_{}")?
        };
        let mut new_op = graph.new_operation("_ConfigureDistributedTPU", &op_name)?;
        {
            (|attr| {new_op.set_attr_int("N", *attr)})(&self.N)
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct _ConfigureDistributedTPU {
    inputs: Edge<i32>,
    N: i64,
    id_: usize,
}

impl _ConfigureDistributedTPU {
    pub fn finish(self) -> _ConfigureDistributedTPUOp {
        _ConfigureDistributedTPUOp::new(Rc::new(self))
    }

    pub fn new(inputs: Edge<i32>, N: int) -> Self {
        Self {
            inputs,
            N: N
            id_: new_id(),
        }
    }
}

impl TensorArrayGradV2Op {
    pub fn new(inner: Rc<TensorArrayGradV2>) -> Self {
        Self{inner}
    }

    pub fn grad_handle(&self) -> Edge<String> {
        Edge::<String>::new(self.inner.clone(), 0)
    }
}

struct TensorArrayGradV2Op {
    inner: Rc<TensorArrayGradV2>,
}

impl GraphOperation for TensorArrayGradV2 {
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("TensorArrayGradV2_{}")?
        };
        let mut new_op = graph.new_operation("TensorArrayGradV2", &op_name)?;
        {
            (|attr| {new_op.set_attr_string("source", attr)})(&self.source)
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct TensorArrayGradV2 {
    handle: Edge<String>,
    flow_in: Edge<f32>,
    source: String,
    id_: usize,
}

impl TensorArrayGradV2 {
    pub fn finish(self) -> TensorArrayGradV2Op {
        TensorArrayGradV2Op::new(Rc::new(self))
    }

    pub fn new(handle: Edge<String>, flow_in: Edge<f32>, source: &str) -> Self {
        Self {
            handle,
            flow_in,
            source: source.to_string()
            id_: new_id(),
        }
    }
}

impl<T> DebugGradientIdentityOp<T>
where T: con,
{
    pub fn new(inner: Rc<DebugGradientIdentity<T>>) -> Self {
        Self{inner}
    }

    pub fn output(&self) -> Edge<T> {
        Edge::<T>::new(self.inner.clone(), 0)
    }
}

struct DebugGradientIdentityOp<T>
where T: con,
{
    inner: Rc<DebugGradientIdentity<T>>,
}

impl<T> GraphOperation for DebugGradientIdentity<T>
where T: con,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("DebugGradientIdentity_{}")?
        };
        let mut new_op = graph.new_operation("DebugGradientIdentity", &op_name)?;
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct DebugGradientIdentity<T>
where T: con,
{
    input: Edge<T>,
    id_: usize,
}

impl<T> DebugGradientIdentity<T>
where T: con,
{
    pub fn finish(self) -> DebugGradientIdentityOp<T> {
        DebugGradientIdentityOp::new(Rc::new(self))
    }

    pub fn new(input: Edge<T>) -> Self {
        Self {
            input,
            id_: new_id(),
        }
    }
}

impl<dtype> TensorArrayOp<dtype>
where dtype: con,
{
    pub fn new(inner: Rc<TensorArray<dtype>>) -> Self {
        Self{inner}
    }

    pub fn handle(&self) -> Edge<String> {
        Edge::<String>::new(self.inner.clone(), 0)
    }
}

struct TensorArrayOp<dtype>
where dtype: con,
{
    inner: Rc<TensorArray<dtype>>,
}

impl<dtype> GraphOperation for TensorArray<dtype>
where dtype: con,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("TensorArray_{}")?
        };
        let mut new_op = graph.new_operation("TensorArray", &op_name)?;
        {
            match self.dynamic_size {
            }
            None => new_op.set_attr_value_proto("dynamic_size", &vec![40_u8, 0_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_bool("dynamic_size", *attr)})(&value),
        };
        {
            match self.clear_after_read {
            }
            None => new_op.set_attr_value_proto("clear_after_read", &vec![40_u8, 1_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_bool("clear_after_read", *attr)})(&value),
        };
        {
            match self.tensor_array_name {
            }
            None => new_op.set_attr_value_proto("tensor_array_name", &vec![18_u8, 0_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_string("tensor_array_name", attr)})(&value),
        };
        {
            match self.element_shape {
            }
            None => new_op.set_attr_value_proto("element_shape", &vec![58_u8, 0_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_shape("element_shape", attr)})(&value),
        };
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct TensorArray<dtype>
where dtype: con,
{
    size: Edge<i32>,
    dynamic_size: Option<bool>,
    clear_after_read: Option<bool>,
    tensor_array_name: Option<String>,
    element_shape: Option<Shape>,
    id_: usize,
}

impl<dtype> TensorArray<dtype>
where dtype: con,
{
    pub fn dynamic_size(&mut self, dynamic_size: bool) -> &mut Self {
        self.dynamic_size = Some(dynamic_size);
        &self
    }

    pub fn clear_after_read(&mut self, clear_after_read: bool) -> &mut Self {
        self.clear_after_read = Some(clear_after_read);
        &self
    }

    pub fn tensor_array_name(&mut self, tensor_array_name: &str) -> &mut Self {
        self.tensor_array_name = Some(tensor_array_name.to_string());
        &self
    }

    pub fn element_shape(&mut self, element_shape: &Shape) -> &mut Self {
        self.element_shape = Some(element_shape.clone());
        &self
    }

    pub fn finish(self) -> TensorArrayOp<dtype> {
        TensorArrayOp::new(Rc::new(self))
    }

    pub fn new(size: Edge<i32>) -> Self {
        Self {
            size,
            dynamic_size: None,
            clear_after_read: None,
            tensor_array_name: None,
            element_shape: None,
            id_: new_id(),
        }
    }
}

impl<T> SeluGradOp<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
{
    pub fn new(inner: Rc<SeluGrad<T>>) -> Self {
        Self{inner}
    }

    pub fn backprops(&self) -> Edge<T> {
        Edge::<T>::new(self.inner.clone(), 0)
    }
}

struct SeluGradOp<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
{
    inner: Rc<SeluGrad<T>>,
}

impl<T> GraphOperation for SeluGrad<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("SeluGrad_{}")?
        };
        let mut new_op = graph.new_operation("SeluGrad", &op_name)?;
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct SeluGrad<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
{
    gradients: Edge<T>,
    outputs: Edge<T>,
    id_: usize,
}

impl<T> SeluGrad<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
{
    pub fn finish(self) -> SeluGradOp<T> {
        SeluGradOp::new(Rc::new(self))
    }

    pub fn new(gradients: Edge<T>, outputs: Edge<T>) -> Self {
        Self {
            gradients,
            outputs,
            id_: new_id(),
        }
    }
}

impl StackCloseOp {
    pub fn new(inner: Rc<StackClose>) -> Self {
        Self{inner}
    }
}

struct StackCloseOp {
    inner: Rc<StackClose>,
}

impl GraphOperation for StackClose {
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("StackClose_{}")?
        };
        let mut new_op = graph.new_operation("StackClose", &op_name)?;
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct StackClose {
    handle: Edge<String>,
    id_: usize,
}

impl StackClose {
    pub fn finish(self) -> StackCloseOp {
        StackCloseOp::new(Rc::new(self))
    }

    pub fn new(handle: Edge<String>) -> Self {
        Self {
            handle,
            id_: new_id(),
        }
    }
}

impl DecodeCompressedOp {
    pub fn new(inner: Rc<DecodeCompressed>) -> Self {
        Self{inner}
    }

    pub fn output(&self) -> Edge<String> {
        Edge::<String>::new(self.inner.clone(), 0)
    }
}

struct DecodeCompressedOp {
    inner: Rc<DecodeCompressed>,
}

impl GraphOperation for DecodeCompressed {
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("DecodeCompressed_{}")?
        };
        let mut new_op = graph.new_operation("DecodeCompressed", &op_name)?;
        {
            match self.compression_type {
            }
            None => new_op.set_attr_value_proto("compression_type", &vec![18_u8, 0_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_string("compression_type", attr)})(&value),
        };
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct DecodeCompressed {
    bytes: Edge<String>,
    compression_type: Option<String>,
    id_: usize,
}

impl DecodeCompressed {
    pub fn compression_type(&mut self, compression_type: &str) -> &mut Self {
        self.compression_type = Some(compression_type.to_string());
        &self
    }

    pub fn finish(self) -> DecodeCompressedOp {
        DecodeCompressedOp::new(Rc::new(self))
    }

    pub fn new(bytes: Edge<String>) -> Self {
        Self {
            bytes,
            compression_type: None,
            id_: new_id(),
        }
    }
}

impl<T> CudnnRNNOp<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_HALF,
{
    pub fn new(inner: Rc<CudnnRNN<T>>) -> Self {
        Self{inner}
    }

    pub fn output(&self) -> Edge<T> {
        Edge::<T>::new(self.inner.clone(), 0)
    }

    pub fn output_h(&self) -> Edge<T> {
        Edge::<T>::new(self.inner.clone(), 1)
    }

    pub fn output_c(&self) -> Edge<T> {
        Edge::<T>::new(self.inner.clone(), 2)
    }

    pub fn reserve_space(&self) -> Edge<T> {
        Edge::<T>::new(self.inner.clone(), 3)
    }
}

struct CudnnRNNOp<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_HALF,
{
    inner: Rc<CudnnRNN<T>>,
}

impl<T> GraphOperation for CudnnRNN<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_HALF,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("CudnnRNN_{}")?
        };
        let mut new_op = graph.new_operation("CudnnRNN", &op_name)?;
        {
            match self.rnn_mode {
            }
            None => new_op.set_attr_value_proto("rnn_mode", &vec![18_u8, 4_u8, 108_u8, 115_u8, 116_u8, 109_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_string("rnn_mode", attr)})(&value),
        };
        {
            match self.input_mode {
            }
            None => new_op.set_attr_value_proto("input_mode", &vec![18_u8, 12_u8, 108_u8, 105_u8, 110_u8, 101_u8, 97_u8, 114_u8, 95_u8, 105_u8, 110_u8, 112_u8, 117_u8, 116_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_string("input_mode", attr)})(&value),
        };
        {
            match self.direction {
            }
            None => new_op.set_attr_value_proto("direction", &vec![18_u8, 14_u8, 117_u8, 110_u8, 105_u8, 100_u8, 105_u8, 114_u8, 101_u8, 99_u8, 116_u8, 105_u8, 111_u8, 110_u8, 97_u8, 108_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_string("direction", attr)})(&value),
        };
        {
            match self.dropout {
            }
            None => new_op.set_attr_value_proto("dropout", &vec![37_u8, 0_u8, 0_u8, 0_u8, 0_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_float("dropout", *attr)})(&value),
        };
        {
            match self.seed {
            }
            None => new_op.set_attr_value_proto("seed", &vec![24_u8, 0_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_int("seed", *attr)})(&value),
        };
        {
            match self.seed2 {
            }
            None => new_op.set_attr_value_proto("seed2", &vec![24_u8, 0_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_int("seed2", *attr)})(&value),
        };
        {
            match self.is_training {
            }
            None => new_op.set_attr_value_proto("is_training", &vec![40_u8, 1_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_bool("is_training", *attr)})(&value),
        };
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct CudnnRNN<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_HALF,
{
    input: Edge<T>,
    input_h: Edge<T>,
    input_c: Edge<T>,
    params: Edge<T>,
    rnn_mode: Option<String>,
    input_mode: Option<String>,
    direction: Option<String>,
    dropout: Option<f32>,
    seed: Option<i64>,
    seed2: Option<i64>,
    is_training: Option<bool>,
    id_: usize,
}

impl<T> CudnnRNN<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_HALF,
{
    pub fn rnn_mode(&mut self, rnn_mode: &str) -> &mut Self {
        self.rnn_mode = Some(rnn_mode.to_string());
        &self
    }

    pub fn input_mode(&mut self, input_mode: &str) -> &mut Self {
        self.input_mode = Some(input_mode.to_string());
        &self
    }

    pub fn direction(&mut self, direction: &str) -> &mut Self {
        self.direction = Some(direction.to_string());
        &self
    }

    pub fn dropout(&mut self, dropout: f32) -> &mut Self {
        self.dropout = Some(dropout);
        &self
    }

    pub fn seed(&mut self, seed: int) -> &mut Self {
        self.seed = Some(seed);
        &self
    }

    pub fn seed2(&mut self, seed2: int) -> &mut Self {
        self.seed2 = Some(seed2);
        &self
    }

    pub fn is_training(&mut self, is_training: bool) -> &mut Self {
        self.is_training = Some(is_training);
        &self
    }

    pub fn finish(self) -> CudnnRNNOp<T> {
        CudnnRNNOp::new(Rc::new(self))
    }

    pub fn new(input: Edge<T>, input_h: Edge<T>, input_c: Edge<T>, params: Edge<T>) -> Self {
        Self {
            input,
            input_h,
            input_c,
            params,
            rnn_mode: None,
            input_mode: None,
            direction: None,
            dropout: None,
            seed: None,
            seed2: None,
            is_training: None,
            id_: new_id(),
        }
    }
}

impl<dtypes> MapIncompleteSizeOp<dtypes>
where dtypes: con,
{
    pub fn new(inner: Rc<MapIncompleteSize<dtypes>>) -> Self {
        Self{inner}
    }

    pub fn size(&self) -> Edge<i32> {
        Edge::<i32>::new(self.inner.clone(), 0)
    }
}

struct MapIncompleteSizeOp<dtypes>
where dtypes: con,
{
    inner: Rc<MapIncompleteSize<dtypes>>,
}

impl<dtypes> GraphOperation for MapIncompleteSize<dtypes>
where dtypes: con,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("MapIncompleteSize_{}")?
        };
        let mut new_op = graph.new_operation("MapIncompleteSize", &op_name)?;
        {
            match self.capacity {
            }
            None => new_op.set_attr_value_proto("capacity", &vec![24_u8, 0_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_int("capacity", *attr)})(&value),
        };
        {
            match self.memory_limit {
            }
            None => new_op.set_attr_value_proto("memory_limit", &vec![24_u8, 0_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_int("memory_limit", *attr)})(&value),
        };
        {
            match self.container {
            }
            None => new_op.set_attr_value_proto("container", &vec![18_u8, 0_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_string("container", attr)})(&value),
        };
        {
            match self.shared_name {
            }
            None => new_op.set_attr_value_proto("shared_name", &vec![18_u8, 0_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_string("shared_name", attr)})(&value),
        };
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct MapIncompleteSize<dtypes>
where dtypes: con,
{
    capacity: Option<i64>,
    memory_limit: Option<i64>,
    container: Option<String>,
    shared_name: Option<String>,
    id_: usize,
}

impl<dtypes> MapIncompleteSize<dtypes>
where dtypes: con,
{
    pub fn capacity(&mut self, capacity: int) -> &mut Self {
        self.capacity = Some(capacity);
        &self
    }

    pub fn memory_limit(&mut self, memory_limit: int) -> &mut Self {
        self.memory_limit = Some(memory_limit);
        &self
    }

    pub fn container(&mut self, container: &str) -> &mut Self {
        self.container = Some(container.to_string());
        &self
    }

    pub fn shared_name(&mut self, shared_name: &str) -> &mut Self {
        self.shared_name = Some(shared_name.to_string());
        &self
    }

    pub fn finish(self) -> MapIncompleteSizeOp<dtypes> {
        MapIncompleteSizeOp::new(Rc::new(self))
    }

    pub fn new() -> Self {
        Self {
            capacity: None,
            memory_limit: None,
            container: None,
            shared_name: None,
            id_: new_id(),
        }
    }
}

impl<T> Conv3DBackpropInputOp<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_HALF,
{
    pub fn new(inner: Rc<Conv3DBackpropInput<T>>) -> Self {
        Self{inner}
    }

    pub fn output(&self) -> Edge<T> {
        Edge::<T>::new(self.inner.clone(), 0)
    }
}

struct Conv3DBackpropInputOp<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_HALF,
{
    inner: Rc<Conv3DBackpropInput<T>>,
}

impl<T> GraphOperation for Conv3DBackpropInput<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_HALF,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("Conv3DBackpropInput_{}")?
        };
        let mut new_op = graph.new_operation("Conv3DBackpropInput", &op_name)?;
        {
            (|attrs| {new_op.set_attr_int_list("strides", attrs)})(&self.strides)
        }
        {
            (|attr| {new_op.set_attr_string("padding", attr)})(&self.padding)
        }
        {
            match self.dilations {
            }
            None => new_op.set_attr_value_proto("dilations", &vec![10_u8, 0_u8, 26_u8, 5_u8, 1_u8, 1_u8, 1_u8, 1_u8,]);,
            Some(value) => (|attrs| {new_op.set_attr_int_list("dilations", attrs)})(&value),
        };
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct Conv3DBackpropInput<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_HALF,
{
    input: Edge<T>,
    filter: Edge<T>,
    out_backprop: Edge<T>,
    strides: Vec<i64>,
    padding: String,
    dilations: Option<Vec<i64>>,
    id_: usize,
}

impl<T> Conv3DBackpropInput<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_HALF,
{
    pub fn dilations(&mut self, dilations: &[int]) -> &mut Self {
        self.dilations = Some(dilations.to_vec());
        &self
    }

    pub fn finish(self) -> Conv3DBackpropInputOp<T> {
        Conv3DBackpropInputOp::new(Rc::new(self))
    }

    pub fn new(input: Edge<T>, filter: Edge<T>, out_backprop: Edge<T>, strides: &[int], padding: &str) -> Self {
        Self {
            input,
            filter,
            out_backprop,
            strides: strides.to_vec()
            padding: padding.to_string()
            dilations: None,
            id_: new_id(),
        }
    }
}

impl<T> StackPushOp<T>
where T: con,
{
    pub fn new(inner: Rc<StackPush<T>>) -> Self {
        Self{inner}
    }

    pub fn output(&self) -> Edge<T> {
        Edge::<T>::new(self.inner.clone(), 0)
    }
}

struct StackPushOp<T>
where T: con,
{
    inner: Rc<StackPush<T>>,
}

impl<T> GraphOperation for StackPush<T>
where T: con,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("StackPush_{}")?
        };
        let mut new_op = graph.new_operation("StackPush", &op_name)?;
        {
            match self.swap_memory {
            }
            None => new_op.set_attr_value_proto("swap_memory", &vec![40_u8, 0_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_bool("swap_memory", *attr)})(&value),
        };
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct StackPush<T>
where T: con,
{
    handle: Edge<String>,
    elem: Edge<T>,
    swap_memory: Option<bool>,
    id_: usize,
}

impl<T> StackPush<T>
where T: con,
{
    pub fn swap_memory(&mut self, swap_memory: bool) -> &mut Self {
        self.swap_memory = Some(swap_memory);
        &self
    }

    pub fn finish(self) -> StackPushOp<T> {
        StackPushOp::new(Rc::new(self))
    }

    pub fn new(handle: Edge<String>, elem: Edge<T>) -> Self {
        Self {
            handle,
            elem,
            swap_memory: None,
            id_: new_id(),
        }
    }
}

impl<T> DenseToDenseSetOperationOp<T>
where T: con_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_STRING_or_DT_INT64_or_DT_UINT16,
{
    pub fn new(inner: Rc<DenseToDenseSetOperation<T>>) -> Self {
        Self{inner}
    }

    pub fn result_indices(&self) -> Edge<i64> {
        Edge::<i64>::new(self.inner.clone(), 0)
    }

    pub fn result_values(&self) -> Edge<T> {
        Edge::<T>::new(self.inner.clone(), 1)
    }

    pub fn result_shape(&self) -> Edge<i64> {
        Edge::<i64>::new(self.inner.clone(), 2)
    }
}

struct DenseToDenseSetOperationOp<T>
where T: con_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_STRING_or_DT_INT64_or_DT_UINT16,
{
    inner: Rc<DenseToDenseSetOperation<T>>,
}

impl<T> GraphOperation for DenseToDenseSetOperation<T>
where T: con_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_STRING_or_DT_INT64_or_DT_UINT16,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("DenseToDenseSetOperation_{}")?
        };
        let mut new_op = graph.new_operation("DenseToDenseSetOperation", &op_name)?;
        {
            (|attr| {new_op.set_attr_string("set_operation", attr)})(&self.set_operation)
        }
        {
            match self.validate_indices {
            }
            None => new_op.set_attr_value_proto("validate_indices", &vec![40_u8, 1_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_bool("validate_indices", *attr)})(&value),
        };
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct DenseToDenseSetOperation<T>
where T: con_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_STRING_or_DT_INT64_or_DT_UINT16,
{
    set1: Edge<T>,
    set2: Edge<T>,
    set_operation: String,
    validate_indices: Option<bool>,
    id_: usize,
}

impl<T> DenseToDenseSetOperation<T>
where T: con_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_STRING_or_DT_INT64_or_DT_UINT16,
{
    pub fn validate_indices(&mut self, validate_indices: bool) -> &mut Self {
        self.validate_indices = Some(validate_indices);
        &self
    }

    pub fn finish(self) -> DenseToDenseSetOperationOp<T> {
        DenseToDenseSetOperationOp::new(Rc::new(self))
    }

    pub fn new(set1: Edge<T>, set2: Edge<T>, set_operation: &str) -> Self {
        Self {
            set1,
            set2,
            set_operation: set_operation.to_string()
            validate_indices: None,
            id_: new_id(),
        }
    }
}

impl ShardedFilenameOp {
    pub fn new(inner: Rc<ShardedFilename>) -> Self {
        Self{inner}
    }

    pub fn filename(&self) -> Edge<String> {
        Edge::<String>::new(self.inner.clone(), 0)
    }
}

struct ShardedFilenameOp {
    inner: Rc<ShardedFilename>,
}

impl GraphOperation for ShardedFilename {
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("ShardedFilename_{}")?
        };
        let mut new_op = graph.new_operation("ShardedFilename", &op_name)?;
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct ShardedFilename {
    basename: Edge<String>,
    shard: Edge<i32>,
    num_shards: Edge<i32>,
    id_: usize,
}

impl ShardedFilename {
    pub fn finish(self) -> ShardedFilenameOp {
        ShardedFilenameOp::new(Rc::new(self))
    }

    pub fn new(basename: Edge<String>, shard: Edge<i32>, num_shards: Edge<i32>) -> Self {
        Self {
            basename,
            shard,
            num_shards,
            id_: new_id(),
        }
    }
}

impl<dtype> SparseAccumulatorApplyGradientOp<dtype>
where dtype: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
{
    pub fn new(inner: Rc<SparseAccumulatorApplyGradient<dtype>>) -> Self {
        Self{inner}
    }
}

struct SparseAccumulatorApplyGradientOp<dtype>
where dtype: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
{
    inner: Rc<SparseAccumulatorApplyGradient<dtype>>,
}

impl<dtype> GraphOperation for SparseAccumulatorApplyGradient<dtype>
where dtype: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("SparseAccumulatorApplyGradient_{}")?
        };
        let mut new_op = graph.new_operation("SparseAccumulatorApplyGradient", &op_name)?;
        {
            (|attr| {new_op.set_attr_bool("has_known_shape", *attr)})(&self.has_known_shape)
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct SparseAccumulatorApplyGradient<dtype>
where dtype: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
{
    handle: Edge<String>,
    local_step: Edge<i64>,
    gradient_indices: Edge<i64>,
    gradient_values: Edge<dtype>,
    gradient_shape: Edge<i64>,
    has_known_shape: bool,
    id_: usize,
}

impl<dtype> SparseAccumulatorApplyGradient<dtype>
where dtype: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
{
    pub fn finish(self) -> SparseAccumulatorApplyGradientOp<dtype> {
        SparseAccumulatorApplyGradientOp::new(Rc::new(self))
    }

    pub fn new(handle: Edge<String>, local_step: Edge<i64>, gradient_indices: Edge<i64>, gradient_values: Edge<dtype>, gradient_shape: Edge<i64>, has_known_shape: bool) -> Self {
        Self {
            handle,
            local_step,
            gradient_indices,
            gradient_values,
            gradient_shape,
            has_known_shape: has_known_shape
            id_: new_id(),
        }
    }
}

impl AccumulatorSetGlobalStepOp {
    pub fn new(inner: Rc<AccumulatorSetGlobalStep>) -> Self {
        Self{inner}
    }
}

struct AccumulatorSetGlobalStepOp {
    inner: Rc<AccumulatorSetGlobalStep>,
}

impl GraphOperation for AccumulatorSetGlobalStep {
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("AccumulatorSetGlobalStep_{}")?
        };
        let mut new_op = graph.new_operation("AccumulatorSetGlobalStep", &op_name)?;
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct AccumulatorSetGlobalStep {
    handle: Edge<String>,
    new_global_step: Edge<i64>,
    id_: usize,
}

impl AccumulatorSetGlobalStep {
    pub fn finish(self) -> AccumulatorSetGlobalStepOp {
        AccumulatorSetGlobalStepOp::new(Rc::new(self))
    }

    pub fn new(handle: Edge<String>, new_global_step: Edge<i64>) -> Self {
        Self {
            handle,
            new_global_step,
            id_: new_id(),
        }
    }
}

impl<T> MatrixDiagPartOp<T>
where T: con,
{
    pub fn new(inner: Rc<MatrixDiagPart<T>>) -> Self {
        Self{inner}
    }

    pub fn diagonal(&self) -> Edge<T> {
        Edge::<T>::new(self.inner.clone(), 0)
    }
}

struct MatrixDiagPartOp<T>
where T: con,
{
    inner: Rc<MatrixDiagPart<T>>,
}

impl<T> GraphOperation for MatrixDiagPart<T>
where T: con,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("MatrixDiagPart_{}")?
        };
        let mut new_op = graph.new_operation("MatrixDiagPart", &op_name)?;
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct MatrixDiagPart<T>
where T: con,
{
    input: Edge<T>,
    id_: usize,
}

impl<T> MatrixDiagPart<T>
where T: con,
{
    pub fn finish(self) -> MatrixDiagPartOp<T> {
        MatrixDiagPartOp::new(Rc::new(self))
    }

    pub fn new(input: Edge<T>) -> Self {
        Self {
            input,
            id_: new_id(),
        }
    }
}

impl<output_type> ExtractJpegShapeOp<output_type>
where output_type: con_or_DT_INT32_or_DT_INT64,
{
    pub fn new(inner: Rc<ExtractJpegShape<output_type>>) -> Self {
        Self{inner}
    }

    pub fn image_shape(&self) -> Edge<output_type> {
        Edge::<output_type>::new(self.inner.clone(), 0)
    }
}

struct ExtractJpegShapeOp<output_type>
where output_type: con_or_DT_INT32_or_DT_INT64,
{
    inner: Rc<ExtractJpegShape<output_type>>,
}

impl<output_type> GraphOperation for ExtractJpegShape<output_type>
where output_type: con_or_DT_INT32_or_DT_INT64,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("ExtractJpegShape_{}")?
        };
        let mut new_op = graph.new_operation("ExtractJpegShape", &op_name)?;
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct ExtractJpegShape<output_type>
where output_type: con_or_DT_INT32_or_DT_INT64,
{
    contents: Edge<String>,
    id_: usize,
}

impl<output_type> ExtractJpegShape<output_type>
where output_type: con_or_DT_INT32_or_DT_INT64,
{
    pub fn finish(self) -> ExtractJpegShapeOp<output_type> {
        ExtractJpegShapeOp::new(Rc::new(self))
    }

    pub fn new(contents: Edge<String>) -> Self {
        Self {
            contents,
            id_: new_id(),
        }
    }
}

impl<elem_type> StackPopOp<elem_type>
where elem_type: con,
{
    pub fn new(inner: Rc<StackPop<elem_type>>) -> Self {
        Self{inner}
    }

    pub fn elem(&self) -> Edge<elem_type> {
        Edge::<elem_type>::new(self.inner.clone(), 0)
    }
}

struct StackPopOp<elem_type>
where elem_type: con,
{
    inner: Rc<StackPop<elem_type>>,
}

impl<elem_type> GraphOperation for StackPop<elem_type>
where elem_type: con,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("StackPop_{}")?
        };
        let mut new_op = graph.new_operation("StackPop", &op_name)?;
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct StackPop<elem_type>
where elem_type: con,
{
    handle: Edge<String>,
    id_: usize,
}

impl<elem_type> StackPop<elem_type>
where elem_type: con,
{
    pub fn finish(self) -> StackPopOp<elem_type> {
        StackPopOp::new(Rc::new(self))
    }

    pub fn new(handle: Edge<String>) -> Self {
        Self {
            handle,
            id_: new_id(),
        }
    }
}

impl<T> InvOp<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_COMPLEX64_or_DT_INT64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF,
{
    pub fn new(inner: Rc<Inv<T>>) -> Self {
        Self{inner}
    }

    pub fn y(&self) -> Edge<T> {
        Edge::<T>::new(self.inner.clone(), 0)
    }
}

struct InvOp<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_COMPLEX64_or_DT_INT64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF,
{
    inner: Rc<Inv<T>>,
}

impl<T> GraphOperation for Inv<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_COMPLEX64_or_DT_INT64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("Inv_{}")?
        };
        let mut new_op = graph.new_operation("Inv", &op_name)?;
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct Inv<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_COMPLEX64_or_DT_INT64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF,
{
    x: Edge<T>,
    id_: usize,
}

impl<T> Inv<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_COMPLEX64_or_DT_INT64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF,
{
    pub fn finish(self) -> InvOp<T> {
        InvOp::new(Rc::new(self))
    }

    pub fn new(x: Edge<T>) -> Self {
        Self {
            x,
            id_: new_id(),
        }
    }
}

impl<T> ParallelDynamicStitchOp<T>
where T: con,
{
    pub fn new(inner: Rc<ParallelDynamicStitch<T>>) -> Self {
        Self{inner}
    }

    pub fn merged(&self) -> Edge<T> {
        Edge::<T>::new(self.inner.clone(), 0)
    }
}

struct ParallelDynamicStitchOp<T>
where T: con,
{
    inner: Rc<ParallelDynamicStitch<T>>,
}

impl<T> GraphOperation for ParallelDynamicStitch<T>
where T: con,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("ParallelDynamicStitch_{}")?
        };
        let mut new_op = graph.new_operation("ParallelDynamicStitch", &op_name)?;
        {
            (|attr| {new_op.set_attr_int("N", *attr)})(&self.N)
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct ParallelDynamicStitch<T>
where T: con,
{
    indices: Edge<i32>,
    data: Edge<T>,
    N: i64,
    id_: usize,
}

impl<T> ParallelDynamicStitch<T>
where T: con,
{
    pub fn finish(self) -> ParallelDynamicStitchOp<T> {
        ParallelDynamicStitchOp::new(Rc::new(self))
    }

    pub fn new(indices: Edge<i32>, data: Edge<T>, N: int) -> Self {
        Self {
            indices,
            data,
            N: N
            id_: new_id(),
        }
    }
}

impl<T> DynamicPartitionOp<T>
where T: con,
{
    pub fn new(inner: Rc<DynamicPartition<T>>) -> Self {
        Self{inner}
    }

    pub fn outputs(&self) -> Edge<T> {
        Edge::<T>::new(self.inner.clone(), 0)
    }
}

struct DynamicPartitionOp<T>
where T: con,
{
    inner: Rc<DynamicPartition<T>>,
}

impl<T> GraphOperation for DynamicPartition<T>
where T: con,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("DynamicPartition_{}")?
        };
        let mut new_op = graph.new_operation("DynamicPartition", &op_name)?;
        {
            (|attr| {new_op.set_attr_int("num_partitions", *attr)})(&self.num_partitions)
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct DynamicPartition<T>
where T: con,
{
    data: Edge<T>,
    partitions: Edge<i32>,
    num_partitions: i64,
    id_: usize,
}

impl<T> DynamicPartition<T>
where T: con,
{
    pub fn finish(self) -> DynamicPartitionOp<T> {
        DynamicPartitionOp::new(Rc::new(self))
    }

    pub fn new(data: Edge<T>, partitions: Edge<i32>, num_partitions: int) -> Self {
        Self {
            data,
            partitions,
            num_partitions: num_partitions
            id_: new_id(),
        }
    }
}

impl<T> BatchCholeskyOp<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE,
{
    pub fn new(inner: Rc<BatchCholesky<T>>) -> Self {
        Self{inner}
    }

    pub fn output(&self) -> Edge<T> {
        Edge::<T>::new(self.inner.clone(), 0)
    }
}

struct BatchCholeskyOp<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE,
{
    inner: Rc<BatchCholesky<T>>,
}

impl<T> GraphOperation for BatchCholesky<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("BatchCholesky_{}")?
        };
        let mut new_op = graph.new_operation("BatchCholesky", &op_name)?;
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct BatchCholesky<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE,
{
    input: Edge<T>,
    id_: usize,
}

impl<T> BatchCholesky<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE,
{
    pub fn finish(self) -> BatchCholeskyOp<T> {
        BatchCholeskyOp::new(Rc::new(self))
    }

    pub fn new(input: Edge<T>) -> Self {
        Self {
            input,
            id_: new_id(),
        }
    }
}

impl<key_dtype, value_dtype> MutableDenseHashTableOp<key_dtype, value_dtype>
where key_dtype: con,
      value_dtype: con,
{
    pub fn new(inner: Rc<MutableDenseHashTable<key_dtype, value_dtype>>) -> Self {
        Self{inner}
    }

    pub fn table_handle(&self) -> Edge<String> {
        Edge::<String>::new(self.inner.clone(), 0)
    }
}

struct MutableDenseHashTableOp<key_dtype, value_dtype>
where key_dtype: con,
      value_dtype: con,
{
    inner: Rc<MutableDenseHashTable<key_dtype, value_dtype>>,
}

impl<key_dtype, value_dtype> GraphOperation for MutableDenseHashTable<key_dtype, value_dtype>
where key_dtype: con,
      value_dtype: con,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("MutableDenseHashTable_{}")?
        };
        let mut new_op = graph.new_operation("MutableDenseHashTable", &op_name)?;
        {
            match self.container {
            }
            None => new_op.set_attr_value_proto("container", &vec![18_u8, 0_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_string("container", attr)})(&value),
        };
        {
            match self.shared_name {
            }
            None => new_op.set_attr_value_proto("shared_name", &vec![18_u8, 0_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_string("shared_name", attr)})(&value),
        };
        {
            match self.use_node_name_sharing {
            }
            None => new_op.set_attr_value_proto("use_node_name_sharing", &vec![40_u8, 0_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_bool("use_node_name_sharing", *attr)})(&value),
        };
        {
            match self.value_shape {
            }
            None => new_op.set_attr_value_proto("value_shape", &vec![58_u8, 0_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_shape("value_shape", attr)})(&value),
        };
        {
            match self.initial_num_buckets {
            }
            None => new_op.set_attr_value_proto("initial_num_buckets", &vec![24_u8, 128_u8, 128_u8, 8_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_int("initial_num_buckets", *attr)})(&value),
        };
        {
            match self.max_load_factor {
            }
            None => new_op.set_attr_value_proto("max_load_factor", &vec![37_u8, 205_u8, 204_u8, 76_u8, 63_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_float("max_load_factor", *attr)})(&value),
        };
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct MutableDenseHashTable<key_dtype, value_dtype>
where key_dtype: con,
      value_dtype: con,
{
    empty_key: Edge<key_dtype>,
    container: Option<String>,
    shared_name: Option<String>,
    use_node_name_sharing: Option<bool>,
    value_shape: Option<Shape>,
    initial_num_buckets: Option<i64>,
    max_load_factor: Option<f32>,
    id_: usize,
}

impl<key_dtype, value_dtype> MutableDenseHashTable<key_dtype, value_dtype>
where key_dtype: con,
      value_dtype: con,
{
    pub fn container(&mut self, container: &str) -> &mut Self {
        self.container = Some(container.to_string());
        &self
    }

    pub fn shared_name(&mut self, shared_name: &str) -> &mut Self {
        self.shared_name = Some(shared_name.to_string());
        &self
    }

    pub fn use_node_name_sharing(&mut self, use_node_name_sharing: bool) -> &mut Self {
        self.use_node_name_sharing = Some(use_node_name_sharing);
        &self
    }

    pub fn value_shape(&mut self, value_shape: &Shape) -> &mut Self {
        self.value_shape = Some(value_shape.clone());
        &self
    }

    pub fn initial_num_buckets(&mut self, initial_num_buckets: int) -> &mut Self {
        self.initial_num_buckets = Some(initial_num_buckets);
        &self
    }

    pub fn max_load_factor(&mut self, max_load_factor: f32) -> &mut Self {
        self.max_load_factor = Some(max_load_factor);
        &self
    }

    pub fn finish(self) -> MutableDenseHashTableOp<key_dtype, value_dtype> {
        MutableDenseHashTableOp::new(Rc::new(self))
    }

    pub fn new(empty_key: Edge<key_dtype>) -> Self {
        Self {
            empty_key,
            container: None,
            shared_name: None,
            use_node_name_sharing: None,
            value_shape: None,
            initial_num_buckets: None,
            max_load_factor: None,
            id_: new_id(),
        }
    }
}

impl UniformCandidateSamplerOp {
    pub fn new(inner: Rc<UniformCandidateSampler>) -> Self {
        Self{inner}
    }

    pub fn sampled_candidates(&self) -> Edge<i64> {
        Edge::<i64>::new(self.inner.clone(), 0)
    }

    pub fn true_expected_count(&self) -> Edge<f32> {
        Edge::<f32>::new(self.inner.clone(), 1)
    }

    pub fn sampled_expected_count(&self) -> Edge<f32> {
        Edge::<f32>::new(self.inner.clone(), 2)
    }
}

struct UniformCandidateSamplerOp {
    inner: Rc<UniformCandidateSampler>,
}

impl GraphOperation for UniformCandidateSampler {
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("UniformCandidateSampler_{}")?
        };
        let mut new_op = graph.new_operation("UniformCandidateSampler", &op_name)?;
        {
            (|attr| {new_op.set_attr_int("num_true", *attr)})(&self.num_true)
        }
        {
            (|attr| {new_op.set_attr_int("num_sampled", *attr)})(&self.num_sampled)
        }
        {
            (|attr| {new_op.set_attr_bool("unique", *attr)})(&self.unique)
        }
        {
            (|attr| {new_op.set_attr_int("range_max", *attr)})(&self.range_max)
        }
        {
            match self.seed {
            }
            None => new_op.set_attr_value_proto("seed", &vec![24_u8, 0_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_int("seed", *attr)})(&value),
        };
        {
            match self.seed2 {
            }
            None => new_op.set_attr_value_proto("seed2", &vec![24_u8, 0_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_int("seed2", *attr)})(&value),
        };
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct UniformCandidateSampler {
    true_classes: Edge<i64>,
    num_true: i64,
    num_sampled: i64,
    unique: bool,
    range_max: i64,
    seed: Option<i64>,
    seed2: Option<i64>,
    id_: usize,
}

impl UniformCandidateSampler {
    pub fn seed(&mut self, seed: int) -> &mut Self {
        self.seed = Some(seed);
        &self
    }

    pub fn seed2(&mut self, seed2: int) -> &mut Self {
        self.seed2 = Some(seed2);
        &self
    }

    pub fn finish(self) -> UniformCandidateSamplerOp {
        UniformCandidateSamplerOp::new(Rc::new(self))
    }

    pub fn new(true_classes: Edge<i64>, num_true: int, num_sampled: int, unique: bool, range_max: int) -> Self {
        Self {
            true_classes,
            num_true: num_true
            num_sampled: num_sampled
            unique: unique
            range_max: range_max
            seed: None,
            seed2: None,
            id_: new_id(),
        }
    }
}

impl<T, Tidx> SparseSegmentMeanOp<T, Tidx>
where T: con_or_DT_FLOAT_or_DT_DOUBLE,
      Tidx: con_or_DT_INT32_or_DT_INT64,
{
    pub fn new(inner: Rc<SparseSegmentMean<T, Tidx>>) -> Self {
        Self{inner}
    }

    pub fn output(&self) -> Edge<T> {
        Edge::<T>::new(self.inner.clone(), 0)
    }
}

struct SparseSegmentMeanOp<T, Tidx>
where T: con_or_DT_FLOAT_or_DT_DOUBLE,
      Tidx: con_or_DT_INT32_or_DT_INT64,
{
    inner: Rc<SparseSegmentMean<T, Tidx>>,
}

impl<T, Tidx> GraphOperation for SparseSegmentMean<T, Tidx>
where T: con_or_DT_FLOAT_or_DT_DOUBLE,
      Tidx: con_or_DT_INT32_or_DT_INT64,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("SparseSegmentMean_{}")?
        };
        let mut new_op = graph.new_operation("SparseSegmentMean", &op_name)?;
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct SparseSegmentMean<T, Tidx>
where T: con_or_DT_FLOAT_or_DT_DOUBLE,
      Tidx: con_or_DT_INT32_or_DT_INT64,
{
    data: Edge<T>,
    indices: Edge<Tidx>,
    segment_ids: Edge<i32>,
    id_: usize,
}

impl<T, Tidx> SparseSegmentMean<T, Tidx>
where T: con_or_DT_FLOAT_or_DT_DOUBLE,
      Tidx: con_or_DT_INT32_or_DT_INT64,
{
    pub fn finish(self) -> SparseSegmentMeanOp<T, Tidx> {
        SparseSegmentMeanOp::new(Rc::new(self))
    }

    pub fn new(data: Edge<T>, indices: Edge<Tidx>, segment_ids: Edge<i32>) -> Self {
        Self {
            data,
            indices,
            segment_ids,
            id_: new_id(),
        }
    }
}

impl<T> BatchCholeskyGradOp<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE,
{
    pub fn new(inner: Rc<BatchCholeskyGrad<T>>) -> Self {
        Self{inner}
    }

    pub fn output(&self) -> Edge<T> {
        Edge::<T>::new(self.inner.clone(), 0)
    }
}

struct BatchCholeskyGradOp<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE,
{
    inner: Rc<BatchCholeskyGrad<T>>,
}

impl<T> GraphOperation for BatchCholeskyGrad<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("BatchCholeskyGrad_{}")?
        };
        let mut new_op = graph.new_operation("BatchCholeskyGrad", &op_name)?;
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct BatchCholeskyGrad<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE,
{
    l: Edge<T>,
    grad: Edge<T>,
    id_: usize,
}

impl<T> BatchCholeskyGrad<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE,
{
    pub fn finish(self) -> BatchCholeskyGradOp<T> {
        BatchCholeskyGradOp::new(Rc::new(self))
    }

    pub fn new(l: Edge<T>, grad: Edge<T>) -> Self {
        Self {
            l,
            grad,
            id_: new_id(),
        }
    }
}

impl CTCLossOp {
    pub fn new(inner: Rc<CTCLoss>) -> Self {
        Self{inner}
    }

    pub fn loss(&self) -> Edge<f32> {
        Edge::<f32>::new(self.inner.clone(), 0)
    }

    pub fn gradient(&self) -> Edge<f32> {
        Edge::<f32>::new(self.inner.clone(), 1)
    }
}

struct CTCLossOp {
    inner: Rc<CTCLoss>,
}

impl GraphOperation for CTCLoss {
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("CTCLoss_{}")?
        };
        let mut new_op = graph.new_operation("CTCLoss", &op_name)?;
        {
            match self.preprocess_collapse_repeated {
            }
            None => new_op.set_attr_value_proto("preprocess_collapse_repeated", &vec![40_u8, 0_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_bool("preprocess_collapse_repeated", *attr)})(&value),
        };
        {
            match self.ctc_merge_repeated {
            }
            None => new_op.set_attr_value_proto("ctc_merge_repeated", &vec![40_u8, 1_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_bool("ctc_merge_repeated", *attr)})(&value),
        };
        {
            match self.ignore_longer_outputs_than_inputs {
            }
            None => new_op.set_attr_value_proto("ignore_longer_outputs_than_inputs", &vec![40_u8, 0_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_bool("ignore_longer_outputs_than_inputs", *attr)})(&value),
        };
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct CTCLoss {
    inputs: Edge<f32>,
    labels_indices: Edge<i64>,
    labels_values: Edge<i32>,
    sequence_length: Edge<i32>,
    preprocess_collapse_repeated: Option<bool>,
    ctc_merge_repeated: Option<bool>,
    ignore_longer_outputs_than_inputs: Option<bool>,
    id_: usize,
}

impl CTCLoss {
    pub fn preprocess_collapse_repeated(&mut self, preprocess_collapse_repeated: bool) -> &mut Self {
        self.preprocess_collapse_repeated = Some(preprocess_collapse_repeated);
        &self
    }

    pub fn ctc_merge_repeated(&mut self, ctc_merge_repeated: bool) -> &mut Self {
        self.ctc_merge_repeated = Some(ctc_merge_repeated);
        &self
    }

    pub fn ignore_longer_outputs_than_inputs(&mut self, ignore_longer_outputs_than_inputs: bool) -> &mut Self {
        self.ignore_longer_outputs_than_inputs = Some(ignore_longer_outputs_than_inputs);
        &self
    }

    pub fn finish(self) -> CTCLossOp {
        CTCLossOp::new(Rc::new(self))
    }

    pub fn new(inputs: Edge<f32>, labels_indices: Edge<i64>, labels_values: Edge<i32>, sequence_length: Edge<i32>) -> Self {
        Self {
            inputs,
            labels_indices,
            labels_values,
            sequence_length,
            preprocess_collapse_repeated: None,
            ctc_merge_repeated: None,
            ignore_longer_outputs_than_inputs: None,
            id_: new_id(),
        }
    }
}

impl<T> SparseFillEmptyRowsGradOp<T>
where T: con,
{
    pub fn new(inner: Rc<SparseFillEmptyRowsGrad<T>>) -> Self {
        Self{inner}
    }

    pub fn d_values(&self) -> Edge<T> {
        Edge::<T>::new(self.inner.clone(), 0)
    }

    pub fn d_default_value(&self) -> Edge<T> {
        Edge::<T>::new(self.inner.clone(), 1)
    }
}

struct SparseFillEmptyRowsGradOp<T>
where T: con,
{
    inner: Rc<SparseFillEmptyRowsGrad<T>>,
}

impl<T> GraphOperation for SparseFillEmptyRowsGrad<T>
where T: con,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("SparseFillEmptyRowsGrad_{}")?
        };
        let mut new_op = graph.new_operation("SparseFillEmptyRowsGrad", &op_name)?;
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct SparseFillEmptyRowsGrad<T>
where T: con,
{
    reverse_index_map: Edge<i64>,
    grad_values: Edge<T>,
    id_: usize,
}

impl<T> SparseFillEmptyRowsGrad<T>
where T: con,
{
    pub fn finish(self) -> SparseFillEmptyRowsGradOp<T> {
        SparseFillEmptyRowsGradOp::new(Rc::new(self))
    }

    pub fn new(reverse_index_map: Edge<i64>, grad_values: Edge<T>) -> Self {
        Self {
            reverse_index_map,
            grad_values,
            id_: new_id(),
        }
    }
}

pub trait con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_BOOL_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_BOOL_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF for BFloat16 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_BOOL_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF for OtherComplex<f32> {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_BOOL_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF for OtherComplex<f64> {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_BOOL_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF for bool {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_BOOL_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF for f32 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_BOOL_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF for f64 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_BOOL_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF for i16 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_BOOL_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF for i32 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_BOOL_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF for i64 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_BOOL_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF for i8 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_BOOL_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF for u16 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_BOOL_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF for u8 {
}

impl<T> OnesLikeOp<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_BOOL_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF,
{
    pub fn new(inner: Rc<OnesLike<T>>) -> Self {
        Self{inner}
    }

    pub fn y(&self) -> Edge<T> {
        Edge::<T>::new(self.inner.clone(), 0)
    }
}

struct OnesLikeOp<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_BOOL_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF,
{
    inner: Rc<OnesLike<T>>,
}

impl<T> GraphOperation for OnesLike<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_BOOL_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("OnesLike_{}")?
        };
        let mut new_op = graph.new_operation("OnesLike", &op_name)?;
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct OnesLike<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_BOOL_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF,
{
    x: Edge<T>,
    id_: usize,
}

impl<T> OnesLike<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_BOOL_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF,
{
    pub fn finish(self) -> OnesLikeOp<T> {
        OnesLikeOp::new(Rc::new(self))
    }

    pub fn new(x: Edge<T>) -> Self {
        Self {
            x,
            id_: new_id(),
        }
    }
}

pub trait con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_INT64_or_DT_BFLOAT16_or_DT_HALF_or_DT_HALF {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_INT64_or_DT_BFLOAT16_or_DT_HALF_or_DT_HALF for BFloat16 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_INT64_or_DT_BFLOAT16_or_DT_HALF_or_DT_HALF for f32 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_INT64_or_DT_BFLOAT16_or_DT_HALF_or_DT_HALF for f64 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_INT64_or_DT_BFLOAT16_or_DT_HALF_or_DT_HALF for i32 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_INT64_or_DT_BFLOAT16_or_DT_HALF_or_DT_HALF for i64 {
}

impl<T> ModOp<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_INT64_or_DT_BFLOAT16_or_DT_HALF_or_DT_HALF,
{
    pub fn new(inner: Rc<Mod<T>>) -> Self {
        Self{inner}
    }

    pub fn z(&self) -> Edge<T> {
        Edge::<T>::new(self.inner.clone(), 0)
    }
}

struct ModOp<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_INT64_or_DT_BFLOAT16_or_DT_HALF_or_DT_HALF,
{
    inner: Rc<Mod<T>>,
}

impl<T> GraphOperation for Mod<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_INT64_or_DT_BFLOAT16_or_DT_HALF_or_DT_HALF,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("Mod_{}")?
        };
        let mut new_op = graph.new_operation("Mod", &op_name)?;
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct Mod<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_INT64_or_DT_BFLOAT16_or_DT_HALF_or_DT_HALF,
{
    x: Edge<T>,
    y: Edge<T>,
    id_: usize,
}

impl<T> Mod<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_INT64_or_DT_BFLOAT16_or_DT_HALF_or_DT_HALF,
{
    pub fn finish(self) -> ModOp<T> {
        ModOp::new(Rc::new(self))
    }

    pub fn new(x: Edge<T>, y: Edge<T>) -> Self {
        Self {
            x,
            y,
            id_: new_id(),
        }
    }
}

impl AbortOp {
    pub fn new(inner: Rc<Abort>) -> Self {
        Self{inner}
    }
}

struct AbortOp {
    inner: Rc<Abort>,
}

impl GraphOperation for Abort {
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("Abort_{}")?
        };
        let mut new_op = graph.new_operation("Abort", &op_name)?;
        {
            match self.error_msg {
            }
            None => new_op.set_attr_value_proto("error_msg", &vec![18_u8, 0_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_string("error_msg", attr)})(&value),
        };
        {
            match self.exit_without_error {
            }
            None => new_op.set_attr_value_proto("exit_without_error", &vec![40_u8, 0_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_bool("exit_without_error", *attr)})(&value),
        };
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct Abort {
    error_msg: Option<String>,
    exit_without_error: Option<bool>,
    id_: usize,
}

impl Abort {
    pub fn error_msg(&mut self, error_msg: &str) -> &mut Self {
        self.error_msg = Some(error_msg.to_string());
        &self
    }

    pub fn exit_without_error(&mut self, exit_without_error: bool) -> &mut Self {
        self.exit_without_error = Some(exit_without_error);
        &self
    }

    pub fn finish(self) -> AbortOp {
        AbortOp::new(Rc::new(self))
    }

    pub fn new() -> Self {
        Self {
            error_msg: None,
            exit_without_error: None,
            id_: new_id(),
        }
    }
}

impl LoadTPUEmbeddingProximalAdagradParametersGradAccumDebugOp {
    pub fn new(inner: Rc<LoadTPUEmbeddingProximalAdagradParametersGradAccumDebug>) -> Self {
        Self{inner}
    }
}

struct LoadTPUEmbeddingProximalAdagradParametersGradAccumDebugOp {
    inner: Rc<LoadTPUEmbeddingProximalAdagradParametersGradAccumDebug>,
}

impl GraphOperation for LoadTPUEmbeddingProximalAdagradParametersGradAccumDebug {
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("LoadTPUEmbeddingProximalAdagradParametersGradAccumDebug_{}")?
        };
        let mut new_op = graph.new_operation("LoadTPUEmbeddingProximalAdagradParametersGradAccumDebug", &op_name)?;
        {
            match self.table_id {
            }
            None => new_op.set_attr_value_proto("table_id", &vec![24_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 1_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_int("table_id", *attr)})(&value),
        };
        {
            match self.table_name {
            }
            None => new_op.set_attr_value_proto("table_name", &vec![18_u8, 0_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_string("table_name", attr)})(&value),
        };
        {
            (|attr| {new_op.set_attr_int("num_shards", *attr)})(&self.num_shards)
        }
        {
            (|attr| {new_op.set_attr_int("shard_id", *attr)})(&self.shard_id)
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct LoadTPUEmbeddingProximalAdagradParametersGradAccumDebug {
    parameters: Edge<f32>,
    accumulators: Edge<f32>,
    gradient_accumulators: Edge<f32>,
    table_id: Option<i64>,
    table_name: Option<String>,
    num_shards: i64,
    shard_id: i64,
    id_: usize,
}

impl LoadTPUEmbeddingProximalAdagradParametersGradAccumDebug {
    pub fn table_id(&mut self, table_id: int) -> &mut Self {
        self.table_id = Some(table_id);
        &self
    }

    pub fn table_name(&mut self, table_name: &str) -> &mut Self {
        self.table_name = Some(table_name.to_string());
        &self
    }

    pub fn finish(self) -> LoadTPUEmbeddingProximalAdagradParametersGradAccumDebugOp {
        LoadTPUEmbeddingProximalAdagradParametersGradAccumDebugOp::new(Rc::new(self))
    }

    pub fn new(parameters: Edge<f32>, accumulators: Edge<f32>, gradient_accumulators: Edge<f32>, num_shards: int, shard_id: int) -> Self {
        Self {
            parameters,
            accumulators,
            gradient_accumulators,
            table_id: None,
            table_name: None,
            num_shards: num_shards
            shard_id: shard_id
            id_: new_id(),
        }
    }
}

impl LoopCondOp {
    pub fn new(inner: Rc<LoopCond>) -> Self {
        Self{inner}
    }

    pub fn output(&self) -> Edge<bool> {
        Edge::<bool>::new(self.inner.clone(), 0)
    }
}

struct LoopCondOp {
    inner: Rc<LoopCond>,
}

impl GraphOperation for LoopCond {
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("LoopCond_{}")?
        };
        let mut new_op = graph.new_operation("LoopCond", &op_name)?;
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct LoopCond {
    input: Edge<bool>,
    id_: usize,
}

impl LoopCond {
    pub fn finish(self) -> LoopCondOp {
        LoopCondOp::new(Rc::new(self))
    }

    pub fn new(input: Edge<bool>) -> Self {
        Self {
            input,
            id_: new_id(),
        }
    }
}

impl<T> SquaredDifferenceOp<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_COMPLEX64_or_DT_INT64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF,
{
    pub fn new(inner: Rc<SquaredDifference<T>>) -> Self {
        Self{inner}
    }

    pub fn z(&self) -> Edge<T> {
        Edge::<T>::new(self.inner.clone(), 0)
    }
}

struct SquaredDifferenceOp<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_COMPLEX64_or_DT_INT64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF,
{
    inner: Rc<SquaredDifference<T>>,
}

impl<T> GraphOperation for SquaredDifference<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_COMPLEX64_or_DT_INT64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("SquaredDifference_{}")?
        };
        let mut new_op = graph.new_operation("SquaredDifference", &op_name)?;
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct SquaredDifference<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_COMPLEX64_or_DT_INT64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF,
{
    x: Edge<T>,
    y: Edge<T>,
    id_: usize,
}

impl<T> SquaredDifference<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_COMPLEX64_or_DT_INT64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF,
{
    pub fn finish(self) -> SquaredDifferenceOp<T> {
        SquaredDifferenceOp::new(Rc::new(self))
    }

    pub fn new(x: Edge<T>, y: Edge<T>) -> Self {
        Self {
            x,
            y,
            id_: new_id(),
        }
    }
}

impl<S, T> RandomGammaOp<S, T>
where S: con_or_DT_INT32_or_DT_INT64,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_HALF,
{
    pub fn new(inner: Rc<RandomGamma<S, T>>) -> Self {
        Self{inner}
    }

    pub fn output(&self) -> Edge<T> {
        Edge::<T>::new(self.inner.clone(), 0)
    }
}

struct RandomGammaOp<S, T>
where S: con_or_DT_INT32_or_DT_INT64,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_HALF,
{
    inner: Rc<RandomGamma<S, T>>,
}

impl<S, T> GraphOperation for RandomGamma<S, T>
where S: con_or_DT_INT32_or_DT_INT64,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_HALF,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("RandomGamma_{}")?
        };
        let mut new_op = graph.new_operation("RandomGamma", &op_name)?;
        {
            match self.seed {
            }
            None => new_op.set_attr_value_proto("seed", &vec![24_u8, 0_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_int("seed", *attr)})(&value),
        };
        {
            match self.seed2 {
            }
            None => new_op.set_attr_value_proto("seed2", &vec![24_u8, 0_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_int("seed2", *attr)})(&value),
        };
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct RandomGamma<S, T>
where S: con_or_DT_INT32_or_DT_INT64,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_HALF,
{
    shape: Edge<S>,
    alpha: Edge<T>,
    seed: Option<i64>,
    seed2: Option<i64>,
    id_: usize,
}

impl<S, T> RandomGamma<S, T>
where S: con_or_DT_INT32_or_DT_INT64,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_HALF,
{
    pub fn seed(&mut self, seed: int) -> &mut Self {
        self.seed = Some(seed);
        &self
    }

    pub fn seed2(&mut self, seed2: int) -> &mut Self {
        self.seed2 = Some(seed2);
        &self
    }

    pub fn finish(self) -> RandomGammaOp<S, T> {
        RandomGammaOp::new(Rc::new(self))
    }

    pub fn new(shape: Edge<S>, alpha: Edge<T>) -> Self {
        Self {
            shape,
            alpha,
            seed: None,
            seed2: None,
            id_: new_id(),
        }
    }
}

impl<Tinput, out_type> QuantizeDownAndShrinkRangeOp<Tinput, out_type>
where Tinput: con_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_QINT16_or_DT_QUINT16,
      out_type: con_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_QINT16_or_DT_QUINT16,
{
    pub fn new(inner: Rc<QuantizeDownAndShrinkRange<Tinput, out_type>>) -> Self {
        Self{inner}
    }

    pub fn output(&self) -> Edge<out_type> {
        Edge::<out_type>::new(self.inner.clone(), 0)
    }

    pub fn output_min(&self) -> Edge<f32> {
        Edge::<f32>::new(self.inner.clone(), 1)
    }

    pub fn output_max(&self) -> Edge<f32> {
        Edge::<f32>::new(self.inner.clone(), 2)
    }
}

struct QuantizeDownAndShrinkRangeOp<Tinput, out_type>
where Tinput: con_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_QINT16_or_DT_QUINT16,
      out_type: con_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_QINT16_or_DT_QUINT16,
{
    inner: Rc<QuantizeDownAndShrinkRange<Tinput, out_type>>,
}

impl<Tinput, out_type> GraphOperation for QuantizeDownAndShrinkRange<Tinput, out_type>
where Tinput: con_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_QINT16_or_DT_QUINT16,
      out_type: con_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_QINT16_or_DT_QUINT16,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("QuantizeDownAndShrinkRange_{}")?
        };
        let mut new_op = graph.new_operation("QuantizeDownAndShrinkRange", &op_name)?;
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct QuantizeDownAndShrinkRange<Tinput, out_type>
where Tinput: con_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_QINT16_or_DT_QUINT16,
      out_type: con_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_QINT16_or_DT_QUINT16,
{
    input: Edge<Tinput>,
    input_min: Edge<f32>,
    input_max: Edge<f32>,
    id_: usize,
}

impl<Tinput, out_type> QuantizeDownAndShrinkRange<Tinput, out_type>
where Tinput: con_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_QINT16_or_DT_QUINT16,
      out_type: con_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_QINT16_or_DT_QUINT16,
{
    pub fn finish(self) -> QuantizeDownAndShrinkRangeOp<Tinput, out_type> {
        QuantizeDownAndShrinkRangeOp::new(Rc::new(self))
    }

    pub fn new(input: Edge<Tinput>, input_min: Edge<f32>, input_max: Edge<f32>) -> Self {
        Self {
            input,
            input_min,
            input_max,
            id_: new_id(),
        }
    }
}

impl FactOp {
    pub fn new(inner: Rc<Fact>) -> Self {
        Self{inner}
    }

    pub fn fact(&self) -> Edge<String> {
        Edge::<String>::new(self.inner.clone(), 0)
    }
}

struct FactOp {
    inner: Rc<Fact>,
}

impl GraphOperation for Fact {
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("Fact_{}")?
        };
        let mut new_op = graph.new_operation("Fact", &op_name)?;
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct Fact {
    id_: usize,
}

impl Fact {
    pub fn finish(self) -> FactOp {
        FactOp::new(Rc::new(self))
    }

    pub fn new() -> Self {
        Self {
            id_: new_id(),
        }
    }
}

impl<T> NextIterationOp<T>
where T: con,
{
    pub fn new(inner: Rc<NextIteration<T>>) -> Self {
        Self{inner}
    }

    pub fn output(&self) -> Edge<T> {
        Edge::<T>::new(self.inner.clone(), 0)
    }
}

struct NextIterationOp<T>
where T: con,
{
    inner: Rc<NextIteration<T>>,
}

impl<T> GraphOperation for NextIteration<T>
where T: con,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("NextIteration_{}")?
        };
        let mut new_op = graph.new_operation("NextIteration", &op_name)?;
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct NextIteration<T>
where T: con,
{
    data: Edge<T>,
    id_: usize,
}

impl<T> NextIteration<T>
where T: con,
{
    pub fn finish(self) -> NextIterationOp<T> {
        NextIterationOp::new(Rc::new(self))
    }

    pub fn new(data: Edge<T>) -> Self {
        Self {
            data,
            id_: new_id(),
        }
    }
}

impl<T> LgammaOp<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
{
    pub fn new(inner: Rc<Lgamma<T>>) -> Self {
        Self{inner}
    }

    pub fn y(&self) -> Edge<T> {
        Edge::<T>::new(self.inner.clone(), 0)
    }
}

struct LgammaOp<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
{
    inner: Rc<Lgamma<T>>,
}

impl<T> GraphOperation for Lgamma<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("Lgamma_{}")?
        };
        let mut new_op = graph.new_operation("Lgamma", &op_name)?;
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct Lgamma<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
{
    x: Edge<T>,
    id_: usize,
}

impl<T> Lgamma<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
{
    pub fn finish(self) -> LgammaOp<T> {
        LgammaOp::new(Rc::new(self))
    }

    pub fn new(x: Edge<T>) -> Self {
        Self {
            x,
            id_: new_id(),
        }
    }
}

impl<T> SnapshotOp<T>
where T: con,
{
    pub fn new(inner: Rc<Snapshot<T>>) -> Self {
        Self{inner}
    }

    pub fn output(&self) -> Edge<T> {
        Edge::<T>::new(self.inner.clone(), 0)
    }
}

struct SnapshotOp<T>
where T: con,
{
    inner: Rc<Snapshot<T>>,
}

impl<T> GraphOperation for Snapshot<T>
where T: con,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("Snapshot_{}")?
        };
        let mut new_op = graph.new_operation("Snapshot", &op_name)?;
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct Snapshot<T>
where T: con,
{
    input: Edge<T>,
    id_: usize,
}

impl<T> Snapshot<T>
where T: con,
{
    pub fn finish(self) -> SnapshotOp<T> {
        SnapshotOp::new(Rc::new(self))
    }

    pub fn new(input: Edge<T>) -> Self {
        Self {
            input,
            id_: new_id(),
        }
    }
}

impl<T> RefExitOp<T>
where T: con,
{
    pub fn new(inner: Rc<RefExit<T>>) -> Self {
        Self{inner}
    }

    pub fn output(&self) -> Edge<T> {
        Edge::<T>::new(self.inner.clone(), 0)
    }
}

struct RefExitOp<T>
where T: con,
{
    inner: Rc<RefExit<T>>,
}

impl<T> GraphOperation for RefExit<T>
where T: con,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("RefExit_{}")?
        };
        let mut new_op = graph.new_operation("RefExit", &op_name)?;
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct RefExit<T>
where T: con,
{
    data: Edge<T>,
    id_: usize,
}

impl<T> RefExit<T>
where T: con,
{
    pub fn finish(self) -> RefExitOp<T> {
        RefExitOp::new(Rc::new(self))
    }

    pub fn new(data: Edge<T>) -> Self {
        Self {
            data,
            id_: new_id(),
        }
    }
}

impl<Tindices, T> ScatterNdOp<Tindices, T>
where T: con,
      Tindices: con_or_DT_INT32_or_DT_INT64,
{
    pub fn new(inner: Rc<ScatterNd<Tindices, T>>) -> Self {
        Self{inner}
    }

    pub fn output(&self) -> Edge<T> {
        Edge::<T>::new(self.inner.clone(), 0)
    }
}

struct ScatterNdOp<Tindices, T>
where T: con,
      Tindices: con_or_DT_INT32_or_DT_INT64,
{
    inner: Rc<ScatterNd<Tindices, T>>,
}

impl<Tindices, T> GraphOperation for ScatterNd<Tindices, T>
where T: con,
      Tindices: con_or_DT_INT32_or_DT_INT64,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("ScatterNd_{}")?
        };
        let mut new_op = graph.new_operation("ScatterNd", &op_name)?;
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct ScatterNd<Tindices, T>
where T: con,
      Tindices: con_or_DT_INT32_or_DT_INT64,
{
    indices: Edge<Tindices>,
    updates: Edge<T>,
    shape: Edge<Tindices>,
    id_: usize,
}

impl<Tindices, T> ScatterNd<Tindices, T>
where T: con,
      Tindices: con_or_DT_INT32_or_DT_INT64,
{
    pub fn finish(self) -> ScatterNdOp<Tindices, T> {
        ScatterNdOp::new(Rc::new(self))
    }

    pub fn new(indices: Edge<Tindices>, updates: Edge<T>, shape: Edge<Tindices>) -> Self {
        Self {
            indices,
            updates,
            shape,
            id_: new_id(),
        }
    }
}

impl<T> RefMergeOp<T>
where T: con,
{
    pub fn new(inner: Rc<RefMerge<T>>) -> Self {
        Self{inner}
    }

    pub fn output(&self) -> Edge<T> {
        Edge::<T>::new(self.inner.clone(), 0)
    }

    pub fn value_index(&self) -> Edge<i32> {
        Edge::<i32>::new(self.inner.clone(), 1)
    }
}

struct RefMergeOp<T>
where T: con,
{
    inner: Rc<RefMerge<T>>,
}

impl<T> GraphOperation for RefMerge<T>
where T: con,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("RefMerge_{}")?
        };
        let mut new_op = graph.new_operation("RefMerge", &op_name)?;
        {
            (|attr| {new_op.set_attr_int("N", *attr)})(&self.N)
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct RefMerge<T>
where T: con,
{
    inputs: Edge<T>,
    N: i64,
    id_: usize,
}

impl<T> RefMerge<T>
where T: con,
{
    pub fn finish(self) -> RefMergeOp<T> {
        RefMergeOp::new(Rc::new(self))
    }

    pub fn new(inputs: Edge<T>, N: int) -> Self {
        Self {
            inputs,
            N: N
            id_: new_id(),
        }
    }
}

impl<T> SwitchOp<T>
where T: con,
{
    pub fn new(inner: Rc<Switch<T>>) -> Self {
        Self{inner}
    }

    pub fn output_false(&self) -> Edge<T> {
        Edge::<T>::new(self.inner.clone(), 0)
    }

    pub fn output_true(&self) -> Edge<T> {
        Edge::<T>::new(self.inner.clone(), 1)
    }
}

struct SwitchOp<T>
where T: con,
{
    inner: Rc<Switch<T>>,
}

impl<T> GraphOperation for Switch<T>
where T: con,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("Switch_{}")?
        };
        let mut new_op = graph.new_operation("Switch", &op_name)?;
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct Switch<T>
where T: con,
{
    data: Edge<T>,
    pred: Edge<bool>,
    id_: usize,
}

impl<T> Switch<T>
where T: con,
{
    pub fn finish(self) -> SwitchOp<T> {
        SwitchOp::new(Rc::new(self))
    }

    pub fn new(data: Edge<T>, pred: Edge<bool>) -> Self {
        Self {
            data,
            pred,
            id_: new_id(),
        }
    }
}

impl DecodeBase64Op {
    pub fn new(inner: Rc<DecodeBase64>) -> Self {
        Self{inner}
    }

    pub fn output(&self) -> Edge<String> {
        Edge::<String>::new(self.inner.clone(), 0)
    }
}

struct DecodeBase64Op {
    inner: Rc<DecodeBase64>,
}

impl GraphOperation for DecodeBase64 {
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("DecodeBase64_{}")?
        };
        let mut new_op = graph.new_operation("DecodeBase64", &op_name)?;
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct DecodeBase64 {
    input: Edge<String>,
    id_: usize,
}

impl DecodeBase64 {
    pub fn finish(self) -> DecodeBase64Op {
        DecodeBase64Op::new(Rc::new(self))
    }

    pub fn new(input: Edge<String>) -> Self {
        Self {
            input,
            id_: new_id(),
        }
    }
}

pub trait con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_INT64_or_DT_HALF {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_INT64_or_DT_HALF for f32 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_INT64_or_DT_HALF for f64 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_INT64_or_DT_HALF for i32 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_INT64_or_DT_HALF for i64 {
}

impl<T> CollectiveBcastRecvOp<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_INT64_or_DT_HALF,
{
    pub fn new(inner: Rc<CollectiveBcastRecv<T>>) -> Self {
        Self{inner}
    }

    pub fn data(&self) -> Edge<T> {
        Edge::<T>::new(self.inner.clone(), 0)
    }
}

struct CollectiveBcastRecvOp<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_INT64_or_DT_HALF,
{
    inner: Rc<CollectiveBcastRecv<T>>,
}

impl<T> GraphOperation for CollectiveBcastRecv<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_INT64_or_DT_HALF,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("CollectiveBcastRecv_{}")?
        };
        let mut new_op = graph.new_operation("CollectiveBcastRecv", &op_name)?;
        {
            (|attr| {new_op.set_attr_int("group_size", *attr)})(&self.group_size)
        }
        {
            (|attr| {new_op.set_attr_int("group_key", *attr)})(&self.group_key)
        }
        {
            (|attr| {new_op.set_attr_int("instance_key", *attr)})(&self.instance_key)
        }
        {
            (|attr| {new_op.set_attr_shape("shape", attr)})(&self.shape)
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct CollectiveBcastRecv<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_INT64_or_DT_HALF,
{
    group_size: i64,
    group_key: i64,
    instance_key: i64,
    shape: Shape,
    id_: usize,
}

impl<T> CollectiveBcastRecv<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_INT64_or_DT_HALF,
{
    pub fn finish(self) -> CollectiveBcastRecvOp<T> {
        CollectiveBcastRecvOp::new(Rc::new(self))
    }

    pub fn new(group_size: int, group_key: int, instance_key: int, shape: &Shape) -> Self {
        Self {
            group_size: group_size
            group_key: group_key
            instance_key: instance_key
            shape: shape.clone()
            id_: new_id(),
        }
    }
}

impl<T> RsqrtOp<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_COMPLEX64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF,
{
    pub fn new(inner: Rc<Rsqrt<T>>) -> Self {
        Self{inner}
    }

    pub fn y(&self) -> Edge<T> {
        Edge::<T>::new(self.inner.clone(), 0)
    }
}

struct RsqrtOp<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_COMPLEX64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF,
{
    inner: Rc<Rsqrt<T>>,
}

impl<T> GraphOperation for Rsqrt<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_COMPLEX64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("Rsqrt_{}")?
        };
        let mut new_op = graph.new_operation("Rsqrt", &op_name)?;
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct Rsqrt<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_COMPLEX64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF,
{
    x: Edge<T>,
    id_: usize,
}

impl<T> Rsqrt<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_COMPLEX64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF,
{
    pub fn finish(self) -> RsqrtOp<T> {
        RsqrtOp::new(Rc::new(self))
    }

    pub fn new(x: Edge<T>) -> Self {
        Self {
            x,
            id_: new_id(),
        }
    }
}

impl<T> RefSwitchOp<T>
where T: con,
{
    pub fn new(inner: Rc<RefSwitch<T>>) -> Self {
        Self{inner}
    }

    pub fn output_false(&self) -> Edge<T> {
        Edge::<T>::new(self.inner.clone(), 0)
    }

    pub fn output_true(&self) -> Edge<T> {
        Edge::<T>::new(self.inner.clone(), 1)
    }
}

struct RefSwitchOp<T>
where T: con,
{
    inner: Rc<RefSwitch<T>>,
}

impl<T> GraphOperation for RefSwitch<T>
where T: con,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("RefSwitch_{}")?
        };
        let mut new_op = graph.new_operation("RefSwitch", &op_name)?;
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct RefSwitch<T>
where T: con,
{
    data: Edge<T>,
    pred: Edge<bool>,
    id_: usize,
}

impl<T> RefSwitch<T>
where T: con,
{
    pub fn finish(self) -> RefSwitchOp<T> {
        RefSwitchOp::new(Rc::new(self))
    }

    pub fn new(data: Edge<T>, pred: Edge<bool>) -> Self {
        Self {
            data,
            pred,
            id_: new_id(),
        }
    }
}

impl<T> CollectiveBcastSendOp<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_INT64_or_DT_HALF,
{
    pub fn new(inner: Rc<CollectiveBcastSend<T>>) -> Self {
        Self{inner}
    }

    pub fn data(&self) -> Edge<T> {
        Edge::<T>::new(self.inner.clone(), 0)
    }
}

struct CollectiveBcastSendOp<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_INT64_or_DT_HALF,
{
    inner: Rc<CollectiveBcastSend<T>>,
}

impl<T> GraphOperation for CollectiveBcastSend<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_INT64_or_DT_HALF,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("CollectiveBcastSend_{}")?
        };
        let mut new_op = graph.new_operation("CollectiveBcastSend", &op_name)?;
        {
            (|attr| {new_op.set_attr_int("group_size", *attr)})(&self.group_size)
        }
        {
            (|attr| {new_op.set_attr_int("group_key", *attr)})(&self.group_key)
        }
        {
            (|attr| {new_op.set_attr_int("instance_key", *attr)})(&self.instance_key)
        }
        {
            (|attr| {new_op.set_attr_shape("shape", attr)})(&self.shape)
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct CollectiveBcastSend<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_INT64_or_DT_HALF,
{
    input: Edge<T>,
    group_size: i64,
    group_key: i64,
    instance_key: i64,
    shape: Shape,
    id_: usize,
}

impl<T> CollectiveBcastSend<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_INT64_or_DT_HALF,
{
    pub fn finish(self) -> CollectiveBcastSendOp<T> {
        CollectiveBcastSendOp::new(Rc::new(self))
    }

    pub fn new(input: Edge<T>, group_size: int, group_key: int, instance_key: int, shape: &Shape) -> Self {
        Self {
            input,
            group_size: group_size
            group_key: group_key
            instance_key: instance_key
            shape: shape.clone()
            id_: new_id(),
        }
    }
}

impl<T> DeepCopyOp<T>
where T: con,
{
    pub fn new(inner: Rc<DeepCopy<T>>) -> Self {
        Self{inner}
    }

    pub fn y(&self) -> Edge<T> {
        Edge::<T>::new(self.inner.clone(), 0)
    }
}

struct DeepCopyOp<T>
where T: con,
{
    inner: Rc<DeepCopy<T>>,
}

impl<T> GraphOperation for DeepCopy<T>
where T: con,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("DeepCopy_{}")?
        };
        let mut new_op = graph.new_operation("DeepCopy", &op_name)?;
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct DeepCopy<T>
where T: con,
{
    x: Edge<T>,
    id_: usize,
}

impl<T> DeepCopy<T>
where T: con,
{
    pub fn finish(self) -> DeepCopyOp<T> {
        DeepCopyOp::new(Rc::new(self))
    }

    pub fn new(x: Edge<T>) -> Self {
        Self {
            x,
            id_: new_id(),
        }
    }
}

impl<T> CollectiveReduceOp<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_INT64_or_DT_HALF,
{
    pub fn new(inner: Rc<CollectiveReduce<T>>) -> Self {
        Self{inner}
    }

    pub fn data(&self) -> Edge<T> {
        Edge::<T>::new(self.inner.clone(), 0)
    }
}

struct CollectiveReduceOp<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_INT64_or_DT_HALF,
{
    inner: Rc<CollectiveReduce<T>>,
}

impl<T> GraphOperation for CollectiveReduce<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_INT64_or_DT_HALF,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("CollectiveReduce_{}")?
        };
        let mut new_op = graph.new_operation("CollectiveReduce", &op_name)?;
        {
            (|attr| {new_op.set_attr_int("group_size", *attr)})(&self.group_size)
        }
        {
            (|attr| {new_op.set_attr_int("group_key", *attr)})(&self.group_key)
        }
        {
            (|attr| {new_op.set_attr_int("instance_key", *attr)})(&self.instance_key)
        }
        {
            (|attr| {new_op.set_attr_string("merge_op", attr)})(&self.merge_op)
        }
        {
            (|attr| {new_op.set_attr_string("final_op", attr)})(&self.final_op)
        }
        {
            (|attrs| {new_op.set_attr_int_list("subdiv_offsets", attrs)})(&self.subdiv_offsets)
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct CollectiveReduce<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_INT64_or_DT_HALF,
{
    input: Edge<T>,
    group_size: i64,
    group_key: i64,
    instance_key: i64,
    merge_op: String,
    final_op: String,
    subdiv_offsets: Vec<i64>,
    id_: usize,
}

impl<T> CollectiveReduce<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_INT64_or_DT_HALF,
{
    pub fn finish(self) -> CollectiveReduceOp<T> {
        CollectiveReduceOp::new(Rc::new(self))
    }

    pub fn new(input: Edge<T>, group_size: int, group_key: int, instance_key: int, merge_op: &str, final_op: &str, subdiv_offsets: &[int]) -> Self {
        Self {
            input,
            group_size: group_size
            group_key: group_key
            instance_key: instance_key
            merge_op: merge_op.to_string()
            final_op: final_op.to_string()
            subdiv_offsets: subdiv_offsets.to_vec()
            id_: new_id(),
        }
    }
}

impl<T> RefEnterOp<T>
where T: con,
{
    pub fn new(inner: Rc<RefEnter<T>>) -> Self {
        Self{inner}
    }

    pub fn output(&self) -> Edge<T> {
        Edge::<T>::new(self.inner.clone(), 0)
    }
}

struct RefEnterOp<T>
where T: con,
{
    inner: Rc<RefEnter<T>>,
}

impl<T> GraphOperation for RefEnter<T>
where T: con,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("RefEnter_{}")?
        };
        let mut new_op = graph.new_operation("RefEnter", &op_name)?;
        {
            (|attr| {new_op.set_attr_string("frame_name", attr)})(&self.frame_name)
        }
        {
            match self.is_constant {
            }
            None => new_op.set_attr_value_proto("is_constant", &vec![40_u8, 0_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_bool("is_constant", *attr)})(&value),
        };
        {
            match self.parallel_iterations {
            }
            None => new_op.set_attr_value_proto("parallel_iterations", &vec![24_u8, 10_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_int("parallel_iterations", *attr)})(&value),
        };
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct RefEnter<T>
where T: con,
{
    data: Edge<T>,
    frame_name: String,
    is_constant: Option<bool>,
    parallel_iterations: Option<i64>,
    id_: usize,
}

impl<T> RefEnter<T>
where T: con,
{
    pub fn is_constant(&mut self, is_constant: bool) -> &mut Self {
        self.is_constant = Some(is_constant);
        &self
    }

    pub fn parallel_iterations(&mut self, parallel_iterations: int) -> &mut Self {
        self.parallel_iterations = Some(parallel_iterations);
        &self
    }

    pub fn finish(self) -> RefEnterOp<T> {
        RefEnterOp::new(Rc::new(self))
    }

    pub fn new(data: Edge<T>, frame_name: &str) -> Self {
        Self {
            data,
            frame_name: frame_name.to_string()
            is_constant: None,
            parallel_iterations: None,
            id_: new_id(),
        }
    }
}

impl FixedUnigramCandidateSamplerOp {
    pub fn new(inner: Rc<FixedUnigramCandidateSampler>) -> Self {
        Self{inner}
    }

    pub fn sampled_candidates(&self) -> Edge<i64> {
        Edge::<i64>::new(self.inner.clone(), 0)
    }

    pub fn true_expected_count(&self) -> Edge<f32> {
        Edge::<f32>::new(self.inner.clone(), 1)
    }

    pub fn sampled_expected_count(&self) -> Edge<f32> {
        Edge::<f32>::new(self.inner.clone(), 2)
    }
}

struct FixedUnigramCandidateSamplerOp {
    inner: Rc<FixedUnigramCandidateSampler>,
}

impl GraphOperation for FixedUnigramCandidateSampler {
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("FixedUnigramCandidateSampler_{}")?
        };
        let mut new_op = graph.new_operation("FixedUnigramCandidateSampler", &op_name)?;
        {
            (|attr| {new_op.set_attr_int("num_true", *attr)})(&self.num_true)
        }
        {
            (|attr| {new_op.set_attr_int("num_sampled", *attr)})(&self.num_sampled)
        }
        {
            (|attr| {new_op.set_attr_bool("unique", *attr)})(&self.unique)
        }
        {
            (|attr| {new_op.set_attr_int("range_max", *attr)})(&self.range_max)
        }
        {
            match self.vocab_file {
            }
            None => new_op.set_attr_value_proto("vocab_file", &vec![18_u8, 0_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_string("vocab_file", attr)})(&value),
        };
        {
            match self.distortion {
            }
            None => new_op.set_attr_value_proto("distortion", &vec![37_u8, 0_u8, 0_u8, 128_u8, 63_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_float("distortion", *attr)})(&value),
        };
        {
            match self.num_reserved_ids {
            }
            None => new_op.set_attr_value_proto("num_reserved_ids", &vec![24_u8, 0_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_int("num_reserved_ids", *attr)})(&value),
        };
        {
            match self.num_shards {
            }
            None => new_op.set_attr_value_proto("num_shards", &vec![24_u8, 1_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_int("num_shards", *attr)})(&value),
        };
        {
            match self.shard {
            }
            None => new_op.set_attr_value_proto("shard", &vec![24_u8, 0_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_int("shard", *attr)})(&value),
        };
        {
            match self.unigrams {
            }
            None => new_op.set_attr_value_proto("unigrams", &vec![10_u8, 0_u8,]);,
            Some(value) => (|attrs| {new_op.set_attr_float_list("unigrams", attrs)})(&value),
        };
        {
            match self.seed {
            }
            None => new_op.set_attr_value_proto("seed", &vec![24_u8, 0_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_int("seed", *attr)})(&value),
        };
        {
            match self.seed2 {
            }
            None => new_op.set_attr_value_proto("seed2", &vec![24_u8, 0_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_int("seed2", *attr)})(&value),
        };
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct FixedUnigramCandidateSampler {
    true_classes: Edge<i64>,
    num_true: i64,
    num_sampled: i64,
    unique: bool,
    range_max: i64,
    vocab_file: Option<String>,
    distortion: Option<f32>,
    num_reserved_ids: Option<i64>,
    num_shards: Option<i64>,
    shard: Option<i64>,
    unigrams: Option<Vec<f32>>,
    seed: Option<i64>,
    seed2: Option<i64>,
    id_: usize,
}

impl FixedUnigramCandidateSampler {
    pub fn vocab_file(&mut self, vocab_file: &str) -> &mut Self {
        self.vocab_file = Some(vocab_file.to_string());
        &self
    }

    pub fn distortion(&mut self, distortion: f32) -> &mut Self {
        self.distortion = Some(distortion);
        &self
    }

    pub fn num_reserved_ids(&mut self, num_reserved_ids: int) -> &mut Self {
        self.num_reserved_ids = Some(num_reserved_ids);
        &self
    }

    pub fn num_shards(&mut self, num_shards: int) -> &mut Self {
        self.num_shards = Some(num_shards);
        &self
    }

    pub fn shard(&mut self, shard: int) -> &mut Self {
        self.shard = Some(shard);
        &self
    }

    pub fn unigrams(&mut self, unigrams: &[f32]) -> &mut Self {
        self.unigrams = Some(unigrams.to_vec());
        &self
    }

    pub fn seed(&mut self, seed: int) -> &mut Self {
        self.seed = Some(seed);
        &self
    }

    pub fn seed2(&mut self, seed2: int) -> &mut Self {
        self.seed2 = Some(seed2);
        &self
    }

    pub fn finish(self) -> FixedUnigramCandidateSamplerOp {
        FixedUnigramCandidateSamplerOp::new(Rc::new(self))
    }

    pub fn new(true_classes: Edge<i64>, num_true: int, num_sampled: int, unique: bool, range_max: int) -> Self {
        Self {
            true_classes,
            num_true: num_true
            num_sampled: num_sampled
            unique: unique
            range_max: range_max
            vocab_file: None,
            distortion: None,
            num_reserved_ids: None,
            num_shards: None,
            shard: None,
            unigrams: None,
            seed: None,
            seed2: None,
            id_: new_id(),
        }
    }
}

impl BarrierIncompleteSizeOp {
    pub fn new(inner: Rc<BarrierIncompleteSize>) -> Self {
        Self{inner}
    }

    pub fn size(&self) -> Edge<i32> {
        Edge::<i32>::new(self.inner.clone(), 0)
    }
}

struct BarrierIncompleteSizeOp {
    inner: Rc<BarrierIncompleteSize>,
}

impl GraphOperation for BarrierIncompleteSize {
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("BarrierIncompleteSize_{}")?
        };
        let mut new_op = graph.new_operation("BarrierIncompleteSize", &op_name)?;
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct BarrierIncompleteSize {
    handle: Edge<String>,
    id_: usize,
}

impl BarrierIncompleteSize {
    pub fn finish(self) -> BarrierIncompleteSizeOp {
        BarrierIncompleteSizeOp::new(Rc::new(self))
    }

    pub fn new(handle: Edge<String>) -> Self {
        Self {
            handle,
            id_: new_id(),
        }
    }
}

impl<T> MaxPoolV2Op<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_QINT8_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF,
{
    pub fn new(inner: Rc<MaxPoolV2<T>>) -> Self {
        Self{inner}
    }

    pub fn output(&self) -> Edge<T> {
        Edge::<T>::new(self.inner.clone(), 0)
    }
}

struct MaxPoolV2Op<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_QINT8_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF,
{
    inner: Rc<MaxPoolV2<T>>,
}

impl<T> GraphOperation for MaxPoolV2<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_QINT8_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("MaxPoolV2_{}")?
        };
        let mut new_op = graph.new_operation("MaxPoolV2", &op_name)?;
        {
            (|attr| {new_op.set_attr_string("padding", attr)})(&self.padding)
        }
        {
            match self.data_format {
            }
            None => new_op.set_attr_value_proto("data_format", &vec![18_u8, 4_u8, 78_u8, 72_u8, 87_u8, 67_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_string("data_format", attr)})(&value),
        };
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct MaxPoolV2<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_QINT8_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF,
{
    input: Edge<T>,
    ksize: Edge<i32>,
    strides: Edge<i32>,
    padding: String,
    data_format: Option<String>,
    id_: usize,
}

impl<T> MaxPoolV2<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_QINT8_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF,
{
    pub fn data_format(&mut self, data_format: &str) -> &mut Self {
        self.data_format = Some(data_format.to_string());
        &self
    }

    pub fn finish(self) -> MaxPoolV2Op<T> {
        MaxPoolV2Op::new(Rc::new(self))
    }

    pub fn new(input: Edge<T>, ksize: Edge<i32>, strides: Edge<i32>, padding: &str) -> Self {
        Self {
            input,
            ksize,
            strides,
            padding: padding.to_string()
            data_format: None,
            id_: new_id(),
        }
    }
}

impl ThreadUnsafeUnigramCandidateSamplerOp {
    pub fn new(inner: Rc<ThreadUnsafeUnigramCandidateSampler>) -> Self {
        Self{inner}
    }

    pub fn sampled_candidates(&self) -> Edge<i64> {
        Edge::<i64>::new(self.inner.clone(), 0)
    }

    pub fn true_expected_count(&self) -> Edge<f32> {
        Edge::<f32>::new(self.inner.clone(), 1)
    }

    pub fn sampled_expected_count(&self) -> Edge<f32> {
        Edge::<f32>::new(self.inner.clone(), 2)
    }
}

struct ThreadUnsafeUnigramCandidateSamplerOp {
    inner: Rc<ThreadUnsafeUnigramCandidateSampler>,
}

impl GraphOperation for ThreadUnsafeUnigramCandidateSampler {
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("ThreadUnsafeUnigramCandidateSampler_{}")?
        };
        let mut new_op = graph.new_operation("ThreadUnsafeUnigramCandidateSampler", &op_name)?;
        {
            (|attr| {new_op.set_attr_int("num_true", *attr)})(&self.num_true)
        }
        {
            (|attr| {new_op.set_attr_int("num_sampled", *attr)})(&self.num_sampled)
        }
        {
            (|attr| {new_op.set_attr_bool("unique", *attr)})(&self.unique)
        }
        {
            (|attr| {new_op.set_attr_int("range_max", *attr)})(&self.range_max)
        }
        {
            match self.seed {
            }
            None => new_op.set_attr_value_proto("seed", &vec![24_u8, 0_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_int("seed", *attr)})(&value),
        };
        {
            match self.seed2 {
            }
            None => new_op.set_attr_value_proto("seed2", &vec![24_u8, 0_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_int("seed2", *attr)})(&value),
        };
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct ThreadUnsafeUnigramCandidateSampler {
    true_classes: Edge<i64>,
    num_true: i64,
    num_sampled: i64,
    unique: bool,
    range_max: i64,
    seed: Option<i64>,
    seed2: Option<i64>,
    id_: usize,
}

impl ThreadUnsafeUnigramCandidateSampler {
    pub fn seed(&mut self, seed: int) -> &mut Self {
        self.seed = Some(seed);
        &self
    }

    pub fn seed2(&mut self, seed2: int) -> &mut Self {
        self.seed2 = Some(seed2);
        &self
    }

    pub fn finish(self) -> ThreadUnsafeUnigramCandidateSamplerOp {
        ThreadUnsafeUnigramCandidateSamplerOp::new(Rc::new(self))
    }

    pub fn new(true_classes: Edge<i64>, num_true: int, num_sampled: int, unique: bool, range_max: int) -> Self {
        Self {
            true_classes,
            num_true: num_true
            num_sampled: num_sampled
            unique: unique
            range_max: range_max
            seed: None,
            seed2: None,
            id_: new_id(),
        }
    }
}

impl QueueIsClosedOp {
    pub fn new(inner: Rc<QueueIsClosed>) -> Self {
        Self{inner}
    }

    pub fn is_closed(&self) -> Edge<bool> {
        Edge::<bool>::new(self.inner.clone(), 0)
    }
}

struct QueueIsClosedOp {
    inner: Rc<QueueIsClosed>,
}

impl GraphOperation for QueueIsClosed {
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("QueueIsClosed_{}")?
        };
        let mut new_op = graph.new_operation("QueueIsClosed", &op_name)?;
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct QueueIsClosed {
    handle: Edge<String>,
    id_: usize,
}

impl QueueIsClosed {
    pub fn finish(self) -> QueueIsClosedOp {
        QueueIsClosedOp::new(Rc::new(self))
    }

    pub fn new(handle: Edge<String>) -> Self {
        Self {
            handle,
            id_: new_id(),
        }
    }
}

impl<component_types> FIFOQueueOp<component_types>
where component_types: con,
{
    pub fn new(inner: Rc<FIFOQueue<component_types>>) -> Self {
        Self{inner}
    }

    pub fn handle(&self) -> Edge<String> {
        Edge::<String>::new(self.inner.clone(), 0)
    }
}

struct FIFOQueueOp<component_types>
where component_types: con,
{
    inner: Rc<FIFOQueue<component_types>>,
}

impl<component_types> GraphOperation for FIFOQueue<component_types>
where component_types: con,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("FIFOQueue_{}")?
        };
        let mut new_op = graph.new_operation("FIFOQueue", &op_name)?;
        {
            match self.shapes {
            }
            None => new_op.set_attr_value_proto("shapes", &vec![10_u8, 0_u8,]);,
            Some(value) => (|attrs| {new_op.set_attr_shape_list("shapes", attrs)})(&value),
        };
        {
            match self.capacity {
            }
            None => new_op.set_attr_value_proto("capacity", &vec![24_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 1_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_int("capacity", *attr)})(&value),
        };
        {
            match self.container {
            }
            None => new_op.set_attr_value_proto("container", &vec![18_u8, 0_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_string("container", attr)})(&value),
        };
        {
            match self.shared_name {
            }
            None => new_op.set_attr_value_proto("shared_name", &vec![18_u8, 0_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_string("shared_name", attr)})(&value),
        };
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct FIFOQueue<component_types>
where component_types: con,
{
    shapes: Option<Vec<Shape>>,
    capacity: Option<i64>,
    container: Option<String>,
    shared_name: Option<String>,
    id_: usize,
}

impl<component_types> FIFOQueue<component_types>
where component_types: con,
{
    pub fn shapes(&mut self, shapes: &[Shape]) -> &mut Self {
        self.shapes = Some(shapes.to_vec());
        &self
    }

    pub fn capacity(&mut self, capacity: int) -> &mut Self {
        self.capacity = Some(capacity);
        &self
    }

    pub fn container(&mut self, container: &str) -> &mut Self {
        self.container = Some(container.to_string());
        &self
    }

    pub fn shared_name(&mut self, shared_name: &str) -> &mut Self {
        self.shared_name = Some(shared_name.to_string());
        &self
    }

    pub fn finish(self) -> FIFOQueueOp<component_types> {
        FIFOQueueOp::new(Rc::new(self))
    }

    pub fn new() -> Self {
        Self {
            shapes: None,
            capacity: None,
            container: None,
            shared_name: None,
            id_: new_id(),
        }
    }
}

impl<T> TPUReplicatedInputOp<T>
where T: con,
{
    pub fn new(inner: Rc<TPUReplicatedInput<T>>) -> Self {
        Self{inner}
    }

    pub fn output(&self) -> Edge<T> {
        Edge::<T>::new(self.inner.clone(), 0)
    }
}

struct TPUReplicatedInputOp<T>
where T: con,
{
    inner: Rc<TPUReplicatedInput<T>>,
}

impl<T> GraphOperation for TPUReplicatedInput<T>
where T: con,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("TPUReplicatedInput_{}")?
        };
        let mut new_op = graph.new_operation("TPUReplicatedInput", &op_name)?;
        {
            (|attr| {new_op.set_attr_int("N", *attr)})(&self.N)
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct TPUReplicatedInput<T>
where T: con,
{
    inputs: Edge<T>,
    N: i64,
    id_: usize,
}

impl<T> TPUReplicatedInput<T>
where T: con,
{
    pub fn finish(self) -> TPUReplicatedInputOp<T> {
        TPUReplicatedInputOp::new(Rc::new(self))
    }

    pub fn new(inputs: Edge<T>, N: int) -> Self {
        Self {
            inputs,
            N: N
            id_: new_id(),
        }
    }
}

impl<T> SpaceToDepthOp<T>
where T: con,
{
    pub fn new(inner: Rc<SpaceToDepth<T>>) -> Self {
        Self{inner}
    }

    pub fn output(&self) -> Edge<T> {
        Edge::<T>::new(self.inner.clone(), 0)
    }
}

struct SpaceToDepthOp<T>
where T: con,
{
    inner: Rc<SpaceToDepth<T>>,
}

impl<T> GraphOperation for SpaceToDepth<T>
where T: con,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("SpaceToDepth_{}")?
        };
        let mut new_op = graph.new_operation("SpaceToDepth", &op_name)?;
        {
            (|attr| {new_op.set_attr_int("block_size", *attr)})(&self.block_size)
        }
        {
            match self.data_format {
            }
            None => new_op.set_attr_value_proto("data_format", &vec![18_u8, 4_u8, 78_u8, 72_u8, 87_u8, 67_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_string("data_format", attr)})(&value),
        };
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct SpaceToDepth<T>
where T: con,
{
    input: Edge<T>,
    block_size: i64,
    data_format: Option<String>,
    id_: usize,
}

impl<T> SpaceToDepth<T>
where T: con,
{
    pub fn data_format(&mut self, data_format: &str) -> &mut Self {
        self.data_format = Some(data_format.to_string());
        &self
    }

    pub fn finish(self) -> SpaceToDepthOp<T> {
        SpaceToDepthOp::new(Rc::new(self))
    }

    pub fn new(input: Edge<T>, block_size: int) -> Self {
        Self {
            input,
            block_size: block_size
            data_format: None,
            id_: new_id(),
        }
    }
}

impl LogUniformCandidateSamplerOp {
    pub fn new(inner: Rc<LogUniformCandidateSampler>) -> Self {
        Self{inner}
    }

    pub fn sampled_candidates(&self) -> Edge<i64> {
        Edge::<i64>::new(self.inner.clone(), 0)
    }

    pub fn true_expected_count(&self) -> Edge<f32> {
        Edge::<f32>::new(self.inner.clone(), 1)
    }

    pub fn sampled_expected_count(&self) -> Edge<f32> {
        Edge::<f32>::new(self.inner.clone(), 2)
    }
}

struct LogUniformCandidateSamplerOp {
    inner: Rc<LogUniformCandidateSampler>,
}

impl GraphOperation for LogUniformCandidateSampler {
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("LogUniformCandidateSampler_{}")?
        };
        let mut new_op = graph.new_operation("LogUniformCandidateSampler", &op_name)?;
        {
            (|attr| {new_op.set_attr_int("num_true", *attr)})(&self.num_true)
        }
        {
            (|attr| {new_op.set_attr_int("num_sampled", *attr)})(&self.num_sampled)
        }
        {
            (|attr| {new_op.set_attr_bool("unique", *attr)})(&self.unique)
        }
        {
            (|attr| {new_op.set_attr_int("range_max", *attr)})(&self.range_max)
        }
        {
            match self.seed {
            }
            None => new_op.set_attr_value_proto("seed", &vec![24_u8, 0_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_int("seed", *attr)})(&value),
        };
        {
            match self.seed2 {
            }
            None => new_op.set_attr_value_proto("seed2", &vec![24_u8, 0_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_int("seed2", *attr)})(&value),
        };
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct LogUniformCandidateSampler {
    true_classes: Edge<i64>,
    num_true: i64,
    num_sampled: i64,
    unique: bool,
    range_max: i64,
    seed: Option<i64>,
    seed2: Option<i64>,
    id_: usize,
}

impl LogUniformCandidateSampler {
    pub fn seed(&mut self, seed: int) -> &mut Self {
        self.seed = Some(seed);
        &self
    }

    pub fn seed2(&mut self, seed2: int) -> &mut Self {
        self.seed2 = Some(seed2);
        &self
    }

    pub fn finish(self) -> LogUniformCandidateSamplerOp {
        LogUniformCandidateSamplerOp::new(Rc::new(self))
    }

    pub fn new(true_classes: Edge<i64>, num_true: int, num_sampled: int, unique: bool, range_max: int) -> Self {
        Self {
            true_classes,
            num_true: num_true
            num_sampled: num_sampled
            unique: unique
            range_max: range_max
            seed: None,
            seed2: None,
            id_: new_id(),
        }
    }
}

impl<S, dtype> RandomPoissonOp<S, dtype>
where S: con_or_DT_INT32_or_DT_INT64,
      dtype: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_HALF,
{
    pub fn new(inner: Rc<RandomPoisson<S, dtype>>) -> Self {
        Self{inner}
    }

    pub fn output(&self) -> Edge<dtype> {
        Edge::<dtype>::new(self.inner.clone(), 0)
    }
}

struct RandomPoissonOp<S, dtype>
where S: con_or_DT_INT32_or_DT_INT64,
      dtype: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_HALF,
{
    inner: Rc<RandomPoisson<S, dtype>>,
}

impl<S, dtype> GraphOperation for RandomPoisson<S, dtype>
where S: con_or_DT_INT32_or_DT_INT64,
      dtype: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_HALF,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("RandomPoisson_{}")?
        };
        let mut new_op = graph.new_operation("RandomPoisson", &op_name)?;
        {
            match self.seed {
            }
            None => new_op.set_attr_value_proto("seed", &vec![24_u8, 0_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_int("seed", *attr)})(&value),
        };
        {
            match self.seed2 {
            }
            None => new_op.set_attr_value_proto("seed2", &vec![24_u8, 0_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_int("seed2", *attr)})(&value),
        };
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct RandomPoisson<S, dtype>
where S: con_or_DT_INT32_or_DT_INT64,
      dtype: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_HALF,
{
    shape: Edge<S>,
    rate: Edge<dtype>,
    seed: Option<i64>,
    seed2: Option<i64>,
    id_: usize,
}

impl<S, dtype> RandomPoisson<S, dtype>
where S: con_or_DT_INT32_or_DT_INT64,
      dtype: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_HALF,
{
    pub fn seed(&mut self, seed: int) -> &mut Self {
        self.seed = Some(seed);
        &self
    }

    pub fn seed2(&mut self, seed2: int) -> &mut Self {
        self.seed2 = Some(seed2);
        &self
    }

    pub fn finish(self) -> RandomPoissonOp<S, dtype> {
        RandomPoissonOp::new(Rc::new(self))
    }

    pub fn new(shape: Edge<S>, rate: Edge<dtype>) -> Self {
        Self {
            shape,
            rate,
            seed: None,
            seed2: None,
            id_: new_id(),
        }
    }
}

impl<Tinput, out_type> QuantizedReluXOp<Tinput, out_type>
where Tinput: con_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_QINT16_or_DT_QUINT16,
      out_type: con_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_QINT16_or_DT_QUINT16,
{
    pub fn new(inner: Rc<QuantizedReluX<Tinput, out_type>>) -> Self {
        Self{inner}
    }

    pub fn activations(&self) -> Edge<out_type> {
        Edge::<out_type>::new(self.inner.clone(), 0)
    }

    pub fn min_activations(&self) -> Edge<f32> {
        Edge::<f32>::new(self.inner.clone(), 1)
    }

    pub fn max_activations(&self) -> Edge<f32> {
        Edge::<f32>::new(self.inner.clone(), 2)
    }
}

struct QuantizedReluXOp<Tinput, out_type>
where Tinput: con_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_QINT16_or_DT_QUINT16,
      out_type: con_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_QINT16_or_DT_QUINT16,
{
    inner: Rc<QuantizedReluX<Tinput, out_type>>,
}

impl<Tinput, out_type> GraphOperation for QuantizedReluX<Tinput, out_type>
where Tinput: con_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_QINT16_or_DT_QUINT16,
      out_type: con_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_QINT16_or_DT_QUINT16,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("QuantizedReluX_{}")?
        };
        let mut new_op = graph.new_operation("QuantizedReluX", &op_name)?;
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct QuantizedReluX<Tinput, out_type>
where Tinput: con_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_QINT16_or_DT_QUINT16,
      out_type: con_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_QINT16_or_DT_QUINT16,
{
    features: Edge<Tinput>,
    max_value: Edge<f32>,
    min_features: Edge<f32>,
    max_features: Edge<f32>,
    id_: usize,
}

impl<Tinput, out_type> QuantizedReluX<Tinput, out_type>
where Tinput: con_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_QINT16_or_DT_QUINT16,
      out_type: con_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_QINT16_or_DT_QUINT16,
{
    pub fn finish(self) -> QuantizedReluXOp<Tinput, out_type> {
        QuantizedReluXOp::new(Rc::new(self))
    }

    pub fn new(features: Edge<Tinput>, max_value: Edge<f32>, min_features: Edge<f32>, max_features: Edge<f32>) -> Self {
        Self {
            features,
            max_value,
            min_features,
            max_features,
            id_: new_id(),
        }
    }
}

impl<T> LessOp<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
{
    pub fn new(inner: Rc<Less<T>>) -> Self {
        Self{inner}
    }

    pub fn z(&self) -> Edge<bool> {
        Edge::<bool>::new(self.inner.clone(), 0)
    }
}

struct LessOp<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
{
    inner: Rc<Less<T>>,
}

impl<T> GraphOperation for Less<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("Less_{}")?
        };
        let mut new_op = graph.new_operation("Less", &op_name)?;
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct Less<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
{
    x: Edge<T>,
    y: Edge<T>,
    id_: usize,
}

impl<T> Less<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
{
    pub fn finish(self) -> LessOp<T> {
        LessOp::new(Rc::new(self))
    }

    pub fn new(x: Edge<T>, y: Edge<T>) -> Self {
        Self {
            x,
            y,
            id_: new_id(),
        }
    }
}

impl<dtype> OutfeedEnqueueOp<dtype>
where dtype: con,
{
    pub fn new(inner: Rc<OutfeedEnqueue<dtype>>) -> Self {
        Self{inner}
    }
}

struct OutfeedEnqueueOp<dtype>
where dtype: con,
{
    inner: Rc<OutfeedEnqueue<dtype>>,
}

impl<dtype> GraphOperation for OutfeedEnqueue<dtype>
where dtype: con,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("OutfeedEnqueue_{}")?
        };
        let mut new_op = graph.new_operation("OutfeedEnqueue", &op_name)?;
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct OutfeedEnqueue<dtype>
where dtype: con,
{
    input: Edge<dtype>,
    id_: usize,
}

impl<dtype> OutfeedEnqueue<dtype>
where dtype: con,
{
    pub fn finish(self) -> OutfeedEnqueueOp<dtype> {
        OutfeedEnqueueOp::new(Rc::new(self))
    }

    pub fn new(input: Edge<dtype>) -> Self {
        Self {
            input,
            id_: new_id(),
        }
    }
}

impl<T> HistogramSummaryOp<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
{
    pub fn new(inner: Rc<HistogramSummary<T>>) -> Self {
        Self{inner}
    }

    pub fn summary(&self) -> Edge<String> {
        Edge::<String>::new(self.inner.clone(), 0)
    }
}

struct HistogramSummaryOp<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
{
    inner: Rc<HistogramSummary<T>>,
}

impl<T> GraphOperation for HistogramSummary<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("HistogramSummary_{}")?
        };
        let mut new_op = graph.new_operation("HistogramSummary", &op_name)?;
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct HistogramSummary<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
{
    tag: Edge<String>,
    values: Edge<T>,
    id_: usize,
}

impl<T> HistogramSummary<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
{
    pub fn finish(self) -> HistogramSummaryOp<T> {
        HistogramSummaryOp::new(Rc::new(self))
    }

    pub fn new(tag: Edge<String>, values: Edge<T>) -> Self {
        Self {
            tag,
            values,
            id_: new_id(),
        }
    }
}

impl _ShutdownDistributedTPUOp {
    pub fn new(inner: Rc<_ShutdownDistributedTPU>) -> Self {
        Self{inner}
    }
}

struct _ShutdownDistributedTPUOp {
    inner: Rc<_ShutdownDistributedTPU>,
}

impl GraphOperation for _ShutdownDistributedTPU {
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("_ShutdownDistributedTPU_{}")?
        };
        let mut new_op = graph.new_operation("_ShutdownDistributedTPU", &op_name)?;
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct _ShutdownDistributedTPU {
    id_: usize,
}

impl _ShutdownDistributedTPU {
    pub fn finish(self) -> _ShutdownDistributedTPUOp {
        _ShutdownDistributedTPUOp::new(Rc::new(self))
    }

    pub fn new() -> Self {
        Self {
            id_: new_id(),
        }
    }
}

impl<T> TensorArrayWriteV2Op<T>
where T: con,
{
    pub fn new(inner: Rc<TensorArrayWriteV2<T>>) -> Self {
        Self{inner}
    }

    pub fn flow_out(&self) -> Edge<f32> {
        Edge::<f32>::new(self.inner.clone(), 0)
    }
}

struct TensorArrayWriteV2Op<T>
where T: con,
{
    inner: Rc<TensorArrayWriteV2<T>>,
}

impl<T> GraphOperation for TensorArrayWriteV2<T>
where T: con,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("TensorArrayWriteV2_{}")?
        };
        let mut new_op = graph.new_operation("TensorArrayWriteV2", &op_name)?;
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct TensorArrayWriteV2<T>
where T: con,
{
    handle: Edge<String>,
    index: Edge<i32>,
    value: Edge<T>,
    flow_in: Edge<f32>,
    id_: usize,
}

impl<T> TensorArrayWriteV2<T>
where T: con,
{
    pub fn finish(self) -> TensorArrayWriteV2Op<T> {
        TensorArrayWriteV2Op::new(Rc::new(self))
    }

    pub fn new(handle: Edge<String>, index: Edge<i32>, value: Edge<T>, flow_in: Edge<f32>) -> Self {
        Self {
            handle,
            index,
            value,
            flow_in,
            id_: new_id(),
        }
    }
}

impl<T, Tindices> XlaDynamicSliceOp<T, Tindices>
where T: con,
      Tindices: con_or_DT_INT32_or_DT_INT64,
{
    pub fn new(inner: Rc<XlaDynamicSlice<T, Tindices>>) -> Self {
        Self{inner}
    }

    pub fn output(&self) -> Edge<T> {
        Edge::<T>::new(self.inner.clone(), 0)
    }
}

struct XlaDynamicSliceOp<T, Tindices>
where T: con,
      Tindices: con_or_DT_INT32_or_DT_INT64,
{
    inner: Rc<XlaDynamicSlice<T, Tindices>>,
}

impl<T, Tindices> GraphOperation for XlaDynamicSlice<T, Tindices>
where T: con,
      Tindices: con_or_DT_INT32_or_DT_INT64,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("XlaDynamicSlice_{}")?
        };
        let mut new_op = graph.new_operation("XlaDynamicSlice", &op_name)?;
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct XlaDynamicSlice<T, Tindices>
where T: con,
      Tindices: con_or_DT_INT32_or_DT_INT64,
{
    input: Edge<T>,
    start_indices: Edge<Tindices>,
    size_indices: Edge<Tindices>,
    id_: usize,
}

impl<T, Tindices> XlaDynamicSlice<T, Tindices>
where T: con,
      Tindices: con_or_DT_INT32_or_DT_INT64,
{
    pub fn finish(self) -> XlaDynamicSliceOp<T, Tindices> {
        XlaDynamicSliceOp::new(Rc::new(self))
    }

    pub fn new(input: Edge<T>, start_indices: Edge<Tindices>, size_indices: Edge<Tindices>) -> Self {
        Self {
            input,
            start_indices,
            size_indices,
            id_: new_id(),
        }
    }
}

impl AdjustHueOp {
    pub fn new(inner: Rc<AdjustHue>) -> Self {
        Self{inner}
    }

    pub fn output(&self) -> Edge<f32> {
        Edge::<f32>::new(self.inner.clone(), 0)
    }
}

struct AdjustHueOp {
    inner: Rc<AdjustHue>,
}

impl GraphOperation for AdjustHue {
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("AdjustHue_{}")?
        };
        let mut new_op = graph.new_operation("AdjustHue", &op_name)?;
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct AdjustHue {
    images: Edge<f32>,
    delta: Edge<f32>,
    id_: usize,
}

impl AdjustHue {
    pub fn finish(self) -> AdjustHueOp {
        AdjustHueOp::new(Rc::new(self))
    }

    pub fn new(images: Edge<f32>, delta: Edge<f32>) -> Self {
        Self {
            images,
            delta,
            id_: new_id(),
        }
    }
}

impl<T> _MklSquaredDifferenceOp<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_COMPLEX64_or_DT_INT64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF,
{
    pub fn new(inner: Rc<_MklSquaredDifference<T>>) -> Self {
        Self{inner}
    }

    pub fn z(&self) -> Edge<T> {
        Edge::<T>::new(self.inner.clone(), 0)
    }

    pub fn mkl_z(&self) -> Edge<u8> {
        Edge::<u8>::new(self.inner.clone(), 1)
    }
}

struct _MklSquaredDifferenceOp<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_COMPLEX64_or_DT_INT64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF,
{
    inner: Rc<_MklSquaredDifference<T>>,
}

impl<T> GraphOperation for _MklSquaredDifference<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_COMPLEX64_or_DT_INT64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("_MklSquaredDifference_{}")?
        };
        let mut new_op = graph.new_operation("_MklSquaredDifference", &op_name)?;
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct _MklSquaredDifference<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_COMPLEX64_or_DT_INT64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF,
{
    x: Edge<T>,
    y: Edge<T>,
    mkl_x: Edge<u8>,
    mkl_y: Edge<u8>,
    id_: usize,
}

impl<T> _MklSquaredDifference<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_COMPLEX64_or_DT_INT64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF,
{
    pub fn finish(self) -> _MklSquaredDifferenceOp<T> {
        _MklSquaredDifferenceOp::new(Rc::new(self))
    }

    pub fn new(x: Edge<T>, y: Edge<T>, mkl_x: Edge<u8>, mkl_y: Edge<u8>) -> Self {
        Self {
            x,
            y,
            mkl_x,
            mkl_y,
            id_: new_id(),
        }
    }
}

impl<component_types> BarrierOp<component_types>
where component_types: con,
{
    pub fn new(inner: Rc<Barrier<component_types>>) -> Self {
        Self{inner}
    }

    pub fn handle(&self) -> Edge<String> {
        Edge::<String>::new(self.inner.clone(), 0)
    }
}

struct BarrierOp<component_types>
where component_types: con,
{
    inner: Rc<Barrier<component_types>>,
}

impl<component_types> GraphOperation for Barrier<component_types>
where component_types: con,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("Barrier_{}")?
        };
        let mut new_op = graph.new_operation("Barrier", &op_name)?;
        {
            match self.shapes {
            }
            None => new_op.set_attr_value_proto("shapes", &vec![10_u8, 0_u8,]);,
            Some(value) => (|attrs| {new_op.set_attr_shape_list("shapes", attrs)})(&value),
        };
        {
            match self.capacity {
            }
            None => new_op.set_attr_value_proto("capacity", &vec![24_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 1_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_int("capacity", *attr)})(&value),
        };
        {
            match self.container {
            }
            None => new_op.set_attr_value_proto("container", &vec![18_u8, 0_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_string("container", attr)})(&value),
        };
        {
            match self.shared_name {
            }
            None => new_op.set_attr_value_proto("shared_name", &vec![18_u8, 0_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_string("shared_name", attr)})(&value),
        };
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct Barrier<component_types>
where component_types: con,
{
    shapes: Option<Vec<Shape>>,
    capacity: Option<i64>,
    container: Option<String>,
    shared_name: Option<String>,
    id_: usize,
}

impl<component_types> Barrier<component_types>
where component_types: con,
{
    pub fn shapes(&mut self, shapes: &[Shape]) -> &mut Self {
        self.shapes = Some(shapes.to_vec());
        &self
    }

    pub fn capacity(&mut self, capacity: int) -> &mut Self {
        self.capacity = Some(capacity);
        &self
    }

    pub fn container(&mut self, container: &str) -> &mut Self {
        self.container = Some(container.to_string());
        &self
    }

    pub fn shared_name(&mut self, shared_name: &str) -> &mut Self {
        self.shared_name = Some(shared_name.to_string());
        &self
    }

    pub fn finish(self) -> BarrierOp<component_types> {
        BarrierOp::new(Rc::new(self))
    }

    pub fn new() -> Self {
        Self {
            shapes: None,
            capacity: None,
            container: None,
            shared_name: None,
            id_: new_id(),
        }
    }
}

impl<dtypes> OrderedMapIncompleteSizeOp<dtypes>
where dtypes: con,
{
    pub fn new(inner: Rc<OrderedMapIncompleteSize<dtypes>>) -> Self {
        Self{inner}
    }

    pub fn size(&self) -> Edge<i32> {
        Edge::<i32>::new(self.inner.clone(), 0)
    }
}

struct OrderedMapIncompleteSizeOp<dtypes>
where dtypes: con,
{
    inner: Rc<OrderedMapIncompleteSize<dtypes>>,
}

impl<dtypes> GraphOperation for OrderedMapIncompleteSize<dtypes>
where dtypes: con,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("OrderedMapIncompleteSize_{}")?
        };
        let mut new_op = graph.new_operation("OrderedMapIncompleteSize", &op_name)?;
        {
            match self.capacity {
            }
            None => new_op.set_attr_value_proto("capacity", &vec![24_u8, 0_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_int("capacity", *attr)})(&value),
        };
        {
            match self.memory_limit {
            }
            None => new_op.set_attr_value_proto("memory_limit", &vec![24_u8, 0_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_int("memory_limit", *attr)})(&value),
        };
        {
            match self.container {
            }
            None => new_op.set_attr_value_proto("container", &vec![18_u8, 0_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_string("container", attr)})(&value),
        };
        {
            match self.shared_name {
            }
            None => new_op.set_attr_value_proto("shared_name", &vec![18_u8, 0_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_string("shared_name", attr)})(&value),
        };
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct OrderedMapIncompleteSize<dtypes>
where dtypes: con,
{
    capacity: Option<i64>,
    memory_limit: Option<i64>,
    container: Option<String>,
    shared_name: Option<String>,
    id_: usize,
}

impl<dtypes> OrderedMapIncompleteSize<dtypes>
where dtypes: con,
{
    pub fn capacity(&mut self, capacity: int) -> &mut Self {
        self.capacity = Some(capacity);
        &self
    }

    pub fn memory_limit(&mut self, memory_limit: int) -> &mut Self {
        self.memory_limit = Some(memory_limit);
        &self
    }

    pub fn container(&mut self, container: &str) -> &mut Self {
        self.container = Some(container.to_string());
        &self
    }

    pub fn shared_name(&mut self, shared_name: &str) -> &mut Self {
        self.shared_name = Some(shared_name.to_string());
        &self
    }

    pub fn finish(self) -> OrderedMapIncompleteSizeOp<dtypes> {
        OrderedMapIncompleteSizeOp::new(Rc::new(self))
    }

    pub fn new() -> Self {
        Self {
            capacity: None,
            memory_limit: None,
            container: None,
            shared_name: None,
            id_: new_id(),
        }
    }
}

impl GcsConfigureBlockCacheOp {
    pub fn new(inner: Rc<GcsConfigureBlockCache>) -> Self {
        Self{inner}
    }
}

struct GcsConfigureBlockCacheOp {
    inner: Rc<GcsConfigureBlockCache>,
}

impl GraphOperation for GcsConfigureBlockCache {
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("GcsConfigureBlockCache_{}")?
        };
        let mut new_op = graph.new_operation("GcsConfigureBlockCache", &op_name)?;
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct GcsConfigureBlockCache {
    max_cache_size: Edge<u64>,
    block_size: Edge<u64>,
    max_staleness: Edge<u64>,
    id_: usize,
}

impl GcsConfigureBlockCache {
    pub fn finish(self) -> GcsConfigureBlockCacheOp {
        GcsConfigureBlockCacheOp::new(Rc::new(self))
    }

    pub fn new(max_cache_size: Edge<u64>, block_size: Edge<u64>, max_staleness: Edge<u64>) -> Self {
        Self {
            max_cache_size,
            block_size,
            max_staleness,
            id_: new_id(),
        }
    }
}

impl<dtypes> OrderedMapSizeOp<dtypes>
where dtypes: con,
{
    pub fn new(inner: Rc<OrderedMapSize<dtypes>>) -> Self {
        Self{inner}
    }

    pub fn size(&self) -> Edge<i32> {
        Edge::<i32>::new(self.inner.clone(), 0)
    }
}

struct OrderedMapSizeOp<dtypes>
where dtypes: con,
{
    inner: Rc<OrderedMapSize<dtypes>>,
}

impl<dtypes> GraphOperation for OrderedMapSize<dtypes>
where dtypes: con,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("OrderedMapSize_{}")?
        };
        let mut new_op = graph.new_operation("OrderedMapSize", &op_name)?;
        {
            match self.capacity {
            }
            None => new_op.set_attr_value_proto("capacity", &vec![24_u8, 0_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_int("capacity", *attr)})(&value),
        };
        {
            match self.memory_limit {
            }
            None => new_op.set_attr_value_proto("memory_limit", &vec![24_u8, 0_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_int("memory_limit", *attr)})(&value),
        };
        {
            match self.container {
            }
            None => new_op.set_attr_value_proto("container", &vec![18_u8, 0_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_string("container", attr)})(&value),
        };
        {
            match self.shared_name {
            }
            None => new_op.set_attr_value_proto("shared_name", &vec![18_u8, 0_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_string("shared_name", attr)})(&value),
        };
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct OrderedMapSize<dtypes>
where dtypes: con,
{
    capacity: Option<i64>,
    memory_limit: Option<i64>,
    container: Option<String>,
    shared_name: Option<String>,
    id_: usize,
}

impl<dtypes> OrderedMapSize<dtypes>
where dtypes: con,
{
    pub fn capacity(&mut self, capacity: int) -> &mut Self {
        self.capacity = Some(capacity);
        &self
    }

    pub fn memory_limit(&mut self, memory_limit: int) -> &mut Self {
        self.memory_limit = Some(memory_limit);
        &self
    }

    pub fn container(&mut self, container: &str) -> &mut Self {
        self.container = Some(container.to_string());
        &self
    }

    pub fn shared_name(&mut self, shared_name: &str) -> &mut Self {
        self.shared_name = Some(shared_name.to_string());
        &self
    }

    pub fn finish(self) -> OrderedMapSizeOp<dtypes> {
        OrderedMapSizeOp::new(Rc::new(self))
    }

    pub fn new() -> Self {
        Self {
            capacity: None,
            memory_limit: None,
            container: None,
            shared_name: None,
            id_: new_id(),
        }
    }
}

impl DecodeBmpOp {
    pub fn new(inner: Rc<DecodeBmp>) -> Self {
        Self{inner}
    }

    pub fn image(&self) -> Edge<u8> {
        Edge::<u8>::new(self.inner.clone(), 0)
    }
}

struct DecodeBmpOp {
    inner: Rc<DecodeBmp>,
}

impl GraphOperation for DecodeBmp {
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("DecodeBmp_{}")?
        };
        let mut new_op = graph.new_operation("DecodeBmp", &op_name)?;
        {
            match self.channels {
            }
            None => new_op.set_attr_value_proto("channels", &vec![24_u8, 0_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_int("channels", *attr)})(&value),
        };
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct DecodeBmp {
    contents: Edge<String>,
    channels: Option<i64>,
    id_: usize,
}

impl DecodeBmp {
    pub fn channels(&mut self, channels: int) -> &mut Self {
        self.channels = Some(channels);
        &self
    }

    pub fn finish(self) -> DecodeBmpOp {
        DecodeBmpOp::new(Rc::new(self))
    }

    pub fn new(contents: Edge<String>) -> Self {
        Self {
            contents,
            channels: None,
            id_: new_id(),
        }
    }
}

impl DecodeJpegOp {
    pub fn new(inner: Rc<DecodeJpeg>) -> Self {
        Self{inner}
    }

    pub fn image(&self) -> Edge<u8> {
        Edge::<u8>::new(self.inner.clone(), 0)
    }
}

struct DecodeJpegOp {
    inner: Rc<DecodeJpeg>,
}

impl GraphOperation for DecodeJpeg {
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("DecodeJpeg_{}")?
        };
        let mut new_op = graph.new_operation("DecodeJpeg", &op_name)?;
        {
            match self.channels {
            }
            None => new_op.set_attr_value_proto("channels", &vec![24_u8, 0_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_int("channels", *attr)})(&value),
        };
        {
            match self.ratio {
            }
            None => new_op.set_attr_value_proto("ratio", &vec![24_u8, 1_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_int("ratio", *attr)})(&value),
        };
        {
            match self.fancy_upscaling {
            }
            None => new_op.set_attr_value_proto("fancy_upscaling", &vec![40_u8, 1_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_bool("fancy_upscaling", *attr)})(&value),
        };
        {
            match self.try_recover_truncated {
            }
            None => new_op.set_attr_value_proto("try_recover_truncated", &vec![40_u8, 0_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_bool("try_recover_truncated", *attr)})(&value),
        };
        {
            match self.acceptable_fraction {
            }
            None => new_op.set_attr_value_proto("acceptable_fraction", &vec![37_u8, 0_u8, 0_u8, 128_u8, 63_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_float("acceptable_fraction", *attr)})(&value),
        };
        {
            match self.dct_method {
            }
            None => new_op.set_attr_value_proto("dct_method", &vec![18_u8, 0_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_string("dct_method", attr)})(&value),
        };
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct DecodeJpeg {
    contents: Edge<String>,
    channels: Option<i64>,
    ratio: Option<i64>,
    fancy_upscaling: Option<bool>,
    try_recover_truncated: Option<bool>,
    acceptable_fraction: Option<f32>,
    dct_method: Option<String>,
    id_: usize,
}

impl DecodeJpeg {
    pub fn channels(&mut self, channels: int) -> &mut Self {
        self.channels = Some(channels);
        &self
    }

    pub fn ratio(&mut self, ratio: int) -> &mut Self {
        self.ratio = Some(ratio);
        &self
    }

    pub fn fancy_upscaling(&mut self, fancy_upscaling: bool) -> &mut Self {
        self.fancy_upscaling = Some(fancy_upscaling);
        &self
    }

    pub fn try_recover_truncated(&mut self, try_recover_truncated: bool) -> &mut Self {
        self.try_recover_truncated = Some(try_recover_truncated);
        &self
    }

    pub fn acceptable_fraction(&mut self, acceptable_fraction: f32) -> &mut Self {
        self.acceptable_fraction = Some(acceptable_fraction);
        &self
    }

    pub fn dct_method(&mut self, dct_method: &str) -> &mut Self {
        self.dct_method = Some(dct_method.to_string());
        &self
    }

    pub fn finish(self) -> DecodeJpegOp {
        DecodeJpegOp::new(Rc::new(self))
    }

    pub fn new(contents: Edge<String>) -> Self {
        Self {
            contents,
            channels: None,
            ratio: None,
            fancy_upscaling: None,
            try_recover_truncated: None,
            acceptable_fraction: None,
            dct_method: None,
            id_: new_id(),
        }
    }
}

impl BoostedTreesMakeStatsSummaryOp {
    pub fn new(inner: Rc<BoostedTreesMakeStatsSummary>) -> Self {
        Self{inner}
    }

    pub fn stats_summary(&self) -> Edge<f32> {
        Edge::<f32>::new(self.inner.clone(), 0)
    }
}

struct BoostedTreesMakeStatsSummaryOp {
    inner: Rc<BoostedTreesMakeStatsSummary>,
}

impl GraphOperation for BoostedTreesMakeStatsSummary {
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("BoostedTreesMakeStatsSummary_{}")?
        };
        let mut new_op = graph.new_operation("BoostedTreesMakeStatsSummary", &op_name)?;
        {
            (|attr| {new_op.set_attr_int("max_splits", *attr)})(&self.max_splits)
        }
        {
            (|attr| {new_op.set_attr_int("num_buckets", *attr)})(&self.num_buckets)
        }
        {
            (|attr| {new_op.set_attr_int("num_features", *attr)})(&self.num_features)
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct BoostedTreesMakeStatsSummary {
    node_ids: Edge<i32>,
    gradients: Edge<f32>,
    hessians: Edge<f32>,
    bucketized_features_list: Edge<i32>,
    max_splits: i64,
    num_buckets: i64,
    num_features: i64,
    id_: usize,
}

impl BoostedTreesMakeStatsSummary {
    pub fn finish(self) -> BoostedTreesMakeStatsSummaryOp {
        BoostedTreesMakeStatsSummaryOp::new(Rc::new(self))
    }

    pub fn new(node_ids: Edge<i32>, gradients: Edge<f32>, hessians: Edge<f32>, bucketized_features_list: Edge<i32>, max_splits: int, num_buckets: int, num_features: int) -> Self {
        Self {
            node_ids,
            gradients,
            hessians,
            bucketized_features_list,
            max_splits: max_splits
            num_buckets: num_buckets
            num_features: num_features
            id_: new_id(),
        }
    }
}

impl RetrieveTPUEmbeddingCenteredRMSPropParametersOp {
    pub fn new(inner: Rc<RetrieveTPUEmbeddingCenteredRMSPropParameters>) -> Self {
        Self{inner}
    }

    pub fn parameters(&self) -> Edge<f32> {
        Edge::<f32>::new(self.inner.clone(), 0)
    }

    pub fn ms(&self) -> Edge<f32> {
        Edge::<f32>::new(self.inner.clone(), 1)
    }

    pub fn mom(&self) -> Edge<f32> {
        Edge::<f32>::new(self.inner.clone(), 2)
    }

    pub fn mg(&self) -> Edge<f32> {
        Edge::<f32>::new(self.inner.clone(), 3)
    }
}

struct RetrieveTPUEmbeddingCenteredRMSPropParametersOp {
    inner: Rc<RetrieveTPUEmbeddingCenteredRMSPropParameters>,
}

impl GraphOperation for RetrieveTPUEmbeddingCenteredRMSPropParameters {
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("RetrieveTPUEmbeddingCenteredRMSPropParameters_{}")?
        };
        let mut new_op = graph.new_operation("RetrieveTPUEmbeddingCenteredRMSPropParameters", &op_name)?;
        {
            match self.table_id {
            }
            None => new_op.set_attr_value_proto("table_id", &vec![24_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 1_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_int("table_id", *attr)})(&value),
        };
        {
            match self.table_name {
            }
            None => new_op.set_attr_value_proto("table_name", &vec![18_u8, 0_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_string("table_name", attr)})(&value),
        };
        {
            (|attr| {new_op.set_attr_int("num_shards", *attr)})(&self.num_shards)
        }
        {
            (|attr| {new_op.set_attr_int("shard_id", *attr)})(&self.shard_id)
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct RetrieveTPUEmbeddingCenteredRMSPropParameters {
    table_id: Option<i64>,
    table_name: Option<String>,
    num_shards: i64,
    shard_id: i64,
    id_: usize,
}

impl RetrieveTPUEmbeddingCenteredRMSPropParameters {
    pub fn table_id(&mut self, table_id: int) -> &mut Self {
        self.table_id = Some(table_id);
        &self
    }

    pub fn table_name(&mut self, table_name: &str) -> &mut Self {
        self.table_name = Some(table_name.to_string());
        &self
    }

    pub fn finish(self) -> RetrieveTPUEmbeddingCenteredRMSPropParametersOp {
        RetrieveTPUEmbeddingCenteredRMSPropParametersOp::new(Rc::new(self))
    }

    pub fn new(num_shards: int, shard_id: int) -> Self {
        Self {
            table_id: None,
            table_name: None,
            num_shards: num_shards
            shard_id: shard_id
            id_: new_id(),
        }
    }
}

impl<T, Tout> ComplexAbsOp<T, Tout>
where T: con_or_DT_COMPLEX64_or_DT_COMPLEX128,
      Tout: con_or_DT_FLOAT_or_DT_DOUBLE,
{
    pub fn new(inner: Rc<ComplexAbs<T, Tout>>) -> Self {
        Self{inner}
    }

    pub fn y(&self) -> Edge<Tout> {
        Edge::<Tout>::new(self.inner.clone(), 0)
    }
}

struct ComplexAbsOp<T, Tout>
where T: con_or_DT_COMPLEX64_or_DT_COMPLEX128,
      Tout: con_or_DT_FLOAT_or_DT_DOUBLE,
{
    inner: Rc<ComplexAbs<T, Tout>>,
}

impl<T, Tout> GraphOperation for ComplexAbs<T, Tout>
where T: con_or_DT_COMPLEX64_or_DT_COMPLEX128,
      Tout: con_or_DT_FLOAT_or_DT_DOUBLE,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("ComplexAbs_{}")?
        };
        let mut new_op = graph.new_operation("ComplexAbs", &op_name)?;
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct ComplexAbs<T, Tout>
where T: con_or_DT_COMPLEX64_or_DT_COMPLEX128,
      Tout: con_or_DT_FLOAT_or_DT_DOUBLE,
{
    x: Edge<T>,
    id_: usize,
}

impl<T, Tout> ComplexAbs<T, Tout>
where T: con_or_DT_COMPLEX64_or_DT_COMPLEX128,
      Tout: con_or_DT_FLOAT_or_DT_DOUBLE,
{
    pub fn finish(self) -> ComplexAbsOp<T, Tout> {
        ComplexAbsOp::new(Rc::new(self))
    }

    pub fn new(x: Edge<T>) -> Self {
        Self {
            x,
            id_: new_id(),
        }
    }
}

impl LogicalAndOp {
    pub fn new(inner: Rc<LogicalAnd>) -> Self {
        Self{inner}
    }

    pub fn z(&self) -> Edge<bool> {
        Edge::<bool>::new(self.inner.clone(), 0)
    }
}

struct LogicalAndOp {
    inner: Rc<LogicalAnd>,
}

impl GraphOperation for LogicalAnd {
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("LogicalAnd_{}")?
        };
        let mut new_op = graph.new_operation("LogicalAnd", &op_name)?;
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct LogicalAnd {
    x: Edge<bool>,
    y: Edge<bool>,
    id_: usize,
}

impl LogicalAnd {
    pub fn finish(self) -> LogicalAndOp {
        LogicalAndOp::new(Rc::new(self))
    }

    pub fn new(x: Edge<bool>, y: Edge<bool>) -> Self {
        Self {
            x,
            y,
            id_: new_id(),
        }
    }
}

impl DeleteSessionTensorOp {
    pub fn new(inner: Rc<DeleteSessionTensor>) -> Self {
        Self{inner}
    }
}

struct DeleteSessionTensorOp {
    inner: Rc<DeleteSessionTensor>,
}

impl GraphOperation for DeleteSessionTensor {
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("DeleteSessionTensor_{}")?
        };
        let mut new_op = graph.new_operation("DeleteSessionTensor", &op_name)?;
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct DeleteSessionTensor {
    handle: Edge<String>,
    id_: usize,
}

impl DeleteSessionTensor {
    pub fn finish(self) -> DeleteSessionTensorOp {
        DeleteSessionTensorOp::new(Rc::new(self))
    }

    pub fn new(handle: Edge<String>) -> Self {
        Self {
            handle,
            id_: new_id(),
        }
    }
}

pub trait con_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_UINT16_or_DT_UINT32_or_DT_UINT64 {
}

impl con_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_UINT16_or_DT_UINT32_or_DT_UINT64 for i16 {
}

impl con_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_UINT16_or_DT_UINT32_or_DT_UINT64 for i32 {
}

impl con_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_UINT16_or_DT_UINT32_or_DT_UINT64 for i64 {
}

impl con_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_UINT16_or_DT_UINT32_or_DT_UINT64 for i8 {
}

impl con_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_UINT16_or_DT_UINT32_or_DT_UINT64 for u16 {
}

impl con_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_UINT16_or_DT_UINT32_or_DT_UINT64 for u32 {
}

impl con_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_UINT16_or_DT_UINT32_or_DT_UINT64 for u64 {
}

impl con_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_UINT16_or_DT_UINT32_or_DT_UINT64 for u8 {
}

impl<T> LeftShiftOp<T>
where T: con_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_UINT16_or_DT_UINT32_or_DT_UINT64,
{
    pub fn new(inner: Rc<LeftShift<T>>) -> Self {
        Self{inner}
    }

    pub fn z(&self) -> Edge<T> {
        Edge::<T>::new(self.inner.clone(), 0)
    }
}

struct LeftShiftOp<T>
where T: con_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_UINT16_or_DT_UINT32_or_DT_UINT64,
{
    inner: Rc<LeftShift<T>>,
}

impl<T> GraphOperation for LeftShift<T>
where T: con_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_UINT16_or_DT_UINT32_or_DT_UINT64,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("LeftShift_{}")?
        };
        let mut new_op = graph.new_operation("LeftShift", &op_name)?;
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct LeftShift<T>
where T: con_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_UINT16_or_DT_UINT32_or_DT_UINT64,
{
    x: Edge<T>,
    y: Edge<T>,
    id_: usize,
}

impl<T> LeftShift<T>
where T: con_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_UINT16_or_DT_UINT32_or_DT_UINT64,
{
    pub fn finish(self) -> LeftShiftOp<T> {
        LeftShiftOp::new(Rc::new(self))
    }

    pub fn new(x: Edge<T>, y: Edge<T>) -> Self {
        Self {
            x,
            y,
            id_: new_id(),
        }
    }
}

impl<T> BitwiseXorOp<T>
where T: con_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_UINT16_or_DT_UINT32_or_DT_UINT64,
{
    pub fn new(inner: Rc<BitwiseXor<T>>) -> Self {
        Self{inner}
    }

    pub fn z(&self) -> Edge<T> {
        Edge::<T>::new(self.inner.clone(), 0)
    }
}

struct BitwiseXorOp<T>
where T: con_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_UINT16_or_DT_UINT32_or_DT_UINT64,
{
    inner: Rc<BitwiseXor<T>>,
}

impl<T> GraphOperation for BitwiseXor<T>
where T: con_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_UINT16_or_DT_UINT32_or_DT_UINT64,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("BitwiseXor_{}")?
        };
        let mut new_op = graph.new_operation("BitwiseXor", &op_name)?;
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct BitwiseXor<T>
where T: con_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_UINT16_or_DT_UINT32_or_DT_UINT64,
{
    x: Edge<T>,
    y: Edge<T>,
    id_: usize,
}

impl<T> BitwiseXor<T>
where T: con_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_UINT16_or_DT_UINT32_or_DT_UINT64,
{
    pub fn finish(self) -> BitwiseXorOp<T> {
        BitwiseXorOp::new(Rc::new(self))
    }

    pub fn new(x: Edge<T>, y: Edge<T>) -> Self {
        Self {
            x,
            y,
            id_: new_id(),
        }
    }
}

impl<T> PopulationCountOp<T>
where T: con_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_UINT16_or_DT_UINT32_or_DT_UINT64,
{
    pub fn new(inner: Rc<PopulationCount<T>>) -> Self {
        Self{inner}
    }

    pub fn y(&self) -> Edge<u8> {
        Edge::<u8>::new(self.inner.clone(), 0)
    }
}

struct PopulationCountOp<T>
where T: con_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_UINT16_or_DT_UINT32_or_DT_UINT64,
{
    inner: Rc<PopulationCount<T>>,
}

impl<T> GraphOperation for PopulationCount<T>
where T: con_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_UINT16_or_DT_UINT32_or_DT_UINT64,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("PopulationCount_{}")?
        };
        let mut new_op = graph.new_operation("PopulationCount", &op_name)?;
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct PopulationCount<T>
where T: con_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_UINT16_or_DT_UINT32_or_DT_UINT64,
{
    x: Edge<T>,
    id_: usize,
}

impl<T> PopulationCount<T>
where T: con_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_UINT16_or_DT_UINT32_or_DT_UINT64,
{
    pub fn finish(self) -> PopulationCountOp<T> {
        PopulationCountOp::new(Rc::new(self))
    }

    pub fn new(x: Edge<T>) -> Self {
        Self {
            x,
            id_: new_id(),
        }
    }
}

impl<T, Tindices> SegmentMeanOp<T, Tindices>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      Tindices: con_or_DT_INT32_or_DT_INT64,
{
    pub fn new(inner: Rc<SegmentMean<T, Tindices>>) -> Self {
        Self{inner}
    }

    pub fn output(&self) -> Edge<T> {
        Edge::<T>::new(self.inner.clone(), 0)
    }
}

struct SegmentMeanOp<T, Tindices>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      Tindices: con_or_DT_INT32_or_DT_INT64,
{
    inner: Rc<SegmentMean<T, Tindices>>,
}

impl<T, Tindices> GraphOperation for SegmentMean<T, Tindices>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      Tindices: con_or_DT_INT32_or_DT_INT64,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("SegmentMean_{}")?
        };
        let mut new_op = graph.new_operation("SegmentMean", &op_name)?;
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct SegmentMean<T, Tindices>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      Tindices: con_or_DT_INT32_or_DT_INT64,
{
    data: Edge<T>,
    segment_ids: Edge<Tindices>,
    id_: usize,
}

impl<T, Tindices> SegmentMean<T, Tindices>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      Tindices: con_or_DT_INT32_or_DT_INT64,
{
    pub fn finish(self) -> SegmentMeanOp<T, Tindices> {
        SegmentMeanOp::new(Rc::new(self))
    }

    pub fn new(data: Edge<T>, segment_ids: Edge<Tindices>) -> Self {
        Self {
            data,
            segment_ids,
            id_: new_id(),
        }
    }
}

impl<T> AvgPool3DGradOp<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
{
    pub fn new(inner: Rc<AvgPool3DGrad<T>>) -> Self {
        Self{inner}
    }

    pub fn output(&self) -> Edge<T> {
        Edge::<T>::new(self.inner.clone(), 0)
    }
}

struct AvgPool3DGradOp<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
{
    inner: Rc<AvgPool3DGrad<T>>,
}

impl<T> GraphOperation for AvgPool3DGrad<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("AvgPool3DGrad_{}")?
        };
        let mut new_op = graph.new_operation("AvgPool3DGrad", &op_name)?;
        {
            (|attrs| {new_op.set_attr_int_list("ksize", attrs)})(&self.ksize)
        }
        {
            (|attrs| {new_op.set_attr_int_list("strides", attrs)})(&self.strides)
        }
        {
            (|attr| {new_op.set_attr_string("padding", attr)})(&self.padding)
        }
        {
            match self.data_format {
            }
            None => new_op.set_attr_value_proto("data_format", &vec![18_u8, 5_u8, 78_u8, 68_u8, 72_u8, 87_u8, 67_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_string("data_format", attr)})(&value),
        };
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct AvgPool3DGrad<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
{
    orig_input_shape: Edge<i32>,
    grad: Edge<T>,
    ksize: Vec<i64>,
    strides: Vec<i64>,
    padding: String,
    data_format: Option<String>,
    id_: usize,
}

impl<T> AvgPool3DGrad<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
{
    pub fn data_format(&mut self, data_format: &str) -> &mut Self {
        self.data_format = Some(data_format.to_string());
        &self
    }

    pub fn finish(self) -> AvgPool3DGradOp<T> {
        AvgPool3DGradOp::new(Rc::new(self))
    }

    pub fn new(orig_input_shape: Edge<i32>, grad: Edge<T>, ksize: &[int], strides: &[int], padding: &str) -> Self {
        Self {
            orig_input_shape,
            grad,
            ksize: ksize.to_vec()
            strides: strides.to_vec()
            padding: padding.to_string()
            data_format: None,
            id_: new_id(),
        }
    }
}

impl<T> UnbatchGradOp<T>
where T: con,
{
    pub fn new(inner: Rc<UnbatchGrad<T>>) -> Self {
        Self{inner}
    }

    pub fn batched_grad(&self) -> Edge<T> {
        Edge::<T>::new(self.inner.clone(), 0)
    }
}

struct UnbatchGradOp<T>
where T: con,
{
    inner: Rc<UnbatchGrad<T>>,
}

impl<T> GraphOperation for UnbatchGrad<T>
where T: con,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("UnbatchGrad_{}")?
        };
        let mut new_op = graph.new_operation("UnbatchGrad", &op_name)?;
        {
            match self.container {
            }
            None => new_op.set_attr_value_proto("container", &vec![18_u8, 0_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_string("container", attr)})(&value),
        };
        {
            match self.shared_name {
            }
            None => new_op.set_attr_value_proto("shared_name", &vec![18_u8, 0_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_string("shared_name", attr)})(&value),
        };
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct UnbatchGrad<T>
where T: con,
{
    original_input: Edge<T>,
    batch_index: Edge<i64>,
    grad: Edge<T>,
    id: Edge<i64>,
    container: Option<String>,
    shared_name: Option<String>,
    id_: usize,
}

impl<T> UnbatchGrad<T>
where T: con,
{
    pub fn container(&mut self, container: &str) -> &mut Self {
        self.container = Some(container.to_string());
        &self
    }

    pub fn shared_name(&mut self, shared_name: &str) -> &mut Self {
        self.shared_name = Some(shared_name.to_string());
        &self
    }

    pub fn finish(self) -> UnbatchGradOp<T> {
        UnbatchGradOp::new(Rc::new(self))
    }

    pub fn new(original_input: Edge<T>, batch_index: Edge<i64>, grad: Edge<T>, id: Edge<i64>) -> Self {
        Self {
            original_input,
            batch_index,
            grad,
            id,
            container: None,
            shared_name: None,
            id_: new_id(),
        }
    }
}

impl<T> DebugGradientRefIdentityOp<T>
where T: con,
{
    pub fn new(inner: Rc<DebugGradientRefIdentity<T>>) -> Self {
        Self{inner}
    }

    pub fn output(&self) -> Edge<T> {
        Edge::<T>::new(self.inner.clone(), 0)
    }
}

struct DebugGradientRefIdentityOp<T>
where T: con,
{
    inner: Rc<DebugGradientRefIdentity<T>>,
}

impl<T> GraphOperation for DebugGradientRefIdentity<T>
where T: con,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("DebugGradientRefIdentity_{}")?
        };
        let mut new_op = graph.new_operation("DebugGradientRefIdentity", &op_name)?;
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct DebugGradientRefIdentity<T>
where T: con,
{
    input: Edge<T>,
    id_: usize,
}

impl<T> DebugGradientRefIdentity<T>
where T: con,
{
    pub fn finish(self) -> DebugGradientRefIdentityOp<T> {
        DebugGradientRefIdentityOp::new(Rc::new(self))
    }

    pub fn new(input: Edge<T>) -> Self {
        Self {
            input,
            id_: new_id(),
        }
    }
}

impl<T> AccumulateNV2Op<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
{
    pub fn new(inner: Rc<AccumulateNV2<T>>) -> Self {
        Self{inner}
    }

    pub fn sum(&self) -> Edge<T> {
        Edge::<T>::new(self.inner.clone(), 0)
    }
}

struct AccumulateNV2Op<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
{
    inner: Rc<AccumulateNV2<T>>,
}

impl<T> GraphOperation for AccumulateNV2<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("AccumulateNV2_{}")?
        };
        let mut new_op = graph.new_operation("AccumulateNV2", &op_name)?;
        {
            (|attr| {new_op.set_attr_int("N", *attr)})(&self.N)
        }
        {
            (|attr| {new_op.set_attr_shape("shape", attr)})(&self.shape)
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct AccumulateNV2<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
{
    inputs: Edge<T>,
    N: i64,
    shape: Shape,
    id_: usize,
}

impl<T> AccumulateNV2<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
{
    pub fn finish(self) -> AccumulateNV2Op<T> {
        AccumulateNV2Op::new(Rc::new(self))
    }

    pub fn new(inputs: Edge<T>, N: int, shape: &Shape) -> Self {
        Self {
            inputs,
            N: N
            shape: shape.clone()
            id_: new_id(),
        }
    }
}

impl<T> XlaSortOp<T>
where T: con,
{
    pub fn new(inner: Rc<XlaSort<T>>) -> Self {
        Self{inner}
    }

    pub fn output(&self) -> Edge<T> {
        Edge::<T>::new(self.inner.clone(), 0)
    }
}

struct XlaSortOp<T>
where T: con,
{
    inner: Rc<XlaSort<T>>,
}

impl<T> GraphOperation for XlaSort<T>
where T: con,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("XlaSort_{}")?
        };
        let mut new_op = graph.new_operation("XlaSort", &op_name)?;
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct XlaSort<T>
where T: con,
{
    input: Edge<T>,
    id_: usize,
}

impl<T> XlaSort<T>
where T: con,
{
    pub fn finish(self) -> XlaSortOp<T> {
        XlaSortOp::new(Rc::new(self))
    }

    pub fn new(input: Edge<T>) -> Self {
        Self {
            input,
            id_: new_id(),
        }
    }
}

impl ReaderResetOp {
    pub fn new(inner: Rc<ReaderReset>) -> Self {
        Self{inner}
    }
}

struct ReaderResetOp {
    inner: Rc<ReaderReset>,
}

impl GraphOperation for ReaderReset {
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("ReaderReset_{}")?
        };
        let mut new_op = graph.new_operation("ReaderReset", &op_name)?;
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct ReaderReset {
    reader_handle: Edge<String>,
    id_: usize,
}

impl ReaderReset {
    pub fn finish(self) -> ReaderResetOp {
        ReaderResetOp::new(Rc::new(self))
    }

    pub fn new(reader_handle: Edge<String>) -> Self {
        Self {
            reader_handle,
            id_: new_id(),
        }
    }
}

impl CTCBeamSearchDecoderOp {
    pub fn new(inner: Rc<CTCBeamSearchDecoder>) -> Self {
        Self{inner}
    }

    pub fn decoded_indices(&self) -> Edge<i64> {
        Edge::<i64>::new(self.inner.clone(), 0)
    }

    pub fn decoded_values(&self) -> Edge<i64> {
        Edge::<i64>::new(self.inner.clone(), 1)
    }

    pub fn decoded_shape(&self) -> Edge<i64> {
        Edge::<i64>::new(self.inner.clone(), 2)
    }

    pub fn log_probability(&self) -> Edge<f32> {
        Edge::<f32>::new(self.inner.clone(), 3)
    }
}

struct CTCBeamSearchDecoderOp {
    inner: Rc<CTCBeamSearchDecoder>,
}

impl GraphOperation for CTCBeamSearchDecoder {
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("CTCBeamSearchDecoder_{}")?
        };
        let mut new_op = graph.new_operation("CTCBeamSearchDecoder", &op_name)?;
        {
            (|attr| {new_op.set_attr_int("beam_width", *attr)})(&self.beam_width)
        }
        {
            (|attr| {new_op.set_attr_int("top_paths", *attr)})(&self.top_paths)
        }
        {
            match self.merge_repeated {
            }
            None => new_op.set_attr_value_proto("merge_repeated", &vec![40_u8, 1_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_bool("merge_repeated", *attr)})(&value),
        };
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct CTCBeamSearchDecoder {
    inputs: Edge<f32>,
    sequence_length: Edge<i32>,
    beam_width: i64,
    top_paths: i64,
    merge_repeated: Option<bool>,
    id_: usize,
}

impl CTCBeamSearchDecoder {
    pub fn merge_repeated(&mut self, merge_repeated: bool) -> &mut Self {
        self.merge_repeated = Some(merge_repeated);
        &self
    }

    pub fn finish(self) -> CTCBeamSearchDecoderOp {
        CTCBeamSearchDecoderOp::new(Rc::new(self))
    }

    pub fn new(inputs: Edge<f32>, sequence_length: Edge<i32>, beam_width: int, top_paths: int) -> Self {
        Self {
            inputs,
            sequence_length,
            beam_width: beam_width
            top_paths: top_paths
            merge_repeated: None,
            id_: new_id(),
        }
    }
}

impl AudioSpectrogramOp {
    pub fn new(inner: Rc<AudioSpectrogram>) -> Self {
        Self{inner}
    }

    pub fn spectrogram(&self) -> Edge<f32> {
        Edge::<f32>::new(self.inner.clone(), 0)
    }
}

struct AudioSpectrogramOp {
    inner: Rc<AudioSpectrogram>,
}

impl GraphOperation for AudioSpectrogram {
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("AudioSpectrogram_{}")?
        };
        let mut new_op = graph.new_operation("AudioSpectrogram", &op_name)?;
        {
            (|attr| {new_op.set_attr_int("window_size", *attr)})(&self.window_size)
        }
        {
            (|attr| {new_op.set_attr_int("stride", *attr)})(&self.stride)
        }
        {
            match self.magnitude_squared {
            }
            None => new_op.set_attr_value_proto("magnitude_squared", &vec![40_u8, 0_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_bool("magnitude_squared", *attr)})(&value),
        };
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct AudioSpectrogram {
    input: Edge<f32>,
    window_size: i64,
    stride: i64,
    magnitude_squared: Option<bool>,
    id_: usize,
}

impl AudioSpectrogram {
    pub fn magnitude_squared(&mut self, magnitude_squared: bool) -> &mut Self {
        self.magnitude_squared = Some(magnitude_squared);
        &self
    }

    pub fn finish(self) -> AudioSpectrogramOp {
        AudioSpectrogramOp::new(Rc::new(self))
    }

    pub fn new(input: Edge<f32>, window_size: int, stride: int) -> Self {
        Self {
            input,
            window_size: window_size
            stride: stride
            magnitude_squared: None,
            id_: new_id(),
        }
    }
}

impl<T> ApplyAdaMaxOp<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
{
    pub fn new(inner: Rc<ApplyAdaMax<T>>) -> Self {
        Self{inner}
    }

    pub fn out(&self) -> Edge<T> {
        Edge::<T>::new(self.inner.clone(), 0)
    }
}

struct ApplyAdaMaxOp<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
{
    inner: Rc<ApplyAdaMax<T>>,
}

impl<T> GraphOperation for ApplyAdaMax<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("ApplyAdaMax_{}")?
        };
        let mut new_op = graph.new_operation("ApplyAdaMax", &op_name)?;
        {
            match self.use_locking {
            }
            None => new_op.set_attr_value_proto("use_locking", &vec![40_u8, 0_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_bool("use_locking", *attr)})(&value),
        };
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct ApplyAdaMax<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
{
    var: Edge<T>,
    m: Edge<T>,
    v: Edge<T>,
    beta1_power: Edge<T>,
    lr: Edge<T>,
    beta1: Edge<T>,
    beta2: Edge<T>,
    epsilon: Edge<T>,
    grad: Edge<T>,
    use_locking: Option<bool>,
    id_: usize,
}

impl<T> ApplyAdaMax<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
{
    pub fn use_locking(&mut self, use_locking: bool) -> &mut Self {
        self.use_locking = Some(use_locking);
        &self
    }

    pub fn finish(self) -> ApplyAdaMaxOp<T> {
        ApplyAdaMaxOp::new(Rc::new(self))
    }

    pub fn new(var: Edge<T>, m: Edge<T>, v: Edge<T>, beta1_power: Edge<T>, lr: Edge<T>, beta1: Edge<T>, beta2: Edge<T>, epsilon: Edge<T>, grad: Edge<T>) -> Self {
        Self {
            var,
            m,
            v,
            beta1_power,
            lr,
            beta1,
            beta2,
            epsilon,
            grad,
            use_locking: None,
            id_: new_id(),
        }
    }
}

impl<T> RandomGammaGradOp<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE,
{
    pub fn new(inner: Rc<RandomGammaGrad<T>>) -> Self {
        Self{inner}
    }

    pub fn output(&self) -> Edge<T> {
        Edge::<T>::new(self.inner.clone(), 0)
    }
}

struct RandomGammaGradOp<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE,
{
    inner: Rc<RandomGammaGrad<T>>,
}

impl<T> GraphOperation for RandomGammaGrad<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("RandomGammaGrad_{}")?
        };
        let mut new_op = graph.new_operation("RandomGammaGrad", &op_name)?;
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct RandomGammaGrad<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE,
{
    alpha: Edge<T>,
    sample: Edge<T>,
    id_: usize,
}

impl<T> RandomGammaGrad<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE,
{
    pub fn finish(self) -> RandomGammaGradOp<T> {
        RandomGammaGradOp::new(Rc::new(self))
    }

    pub fn new(alpha: Edge<T>, sample: Edge<T>) -> Self {
        Self {
            alpha,
            sample,
            id_: new_id(),
        }
    }
}

pub trait con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_STRING_or_DT_COMPLEX64_or_DT_INT64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_STRING_or_DT_COMPLEX64_or_DT_INT64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF for BFloat16 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_STRING_or_DT_COMPLEX64_or_DT_INT64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF for OtherComplex<f32> {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_STRING_or_DT_COMPLEX64_or_DT_INT64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF for OtherComplex<f64> {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_STRING_or_DT_COMPLEX64_or_DT_INT64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF for String {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_STRING_or_DT_COMPLEX64_or_DT_INT64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF for f32 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_STRING_or_DT_COMPLEX64_or_DT_INT64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF for f64 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_STRING_or_DT_COMPLEX64_or_DT_INT64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF for i16 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_STRING_or_DT_COMPLEX64_or_DT_INT64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF for i32 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_STRING_or_DT_COMPLEX64_or_DT_INT64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF for i64 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_STRING_or_DT_COMPLEX64_or_DT_INT64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF for i8 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_STRING_or_DT_COMPLEX64_or_DT_INT64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF for u8 {
}

impl<T> AddOp<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_STRING_or_DT_COMPLEX64_or_DT_INT64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF,
{
    pub fn new(inner: Rc<Add<T>>) -> Self {
        Self{inner}
    }

    pub fn z(&self) -> Edge<T> {
        Edge::<T>::new(self.inner.clone(), 0)
    }
}

struct AddOp<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_STRING_or_DT_COMPLEX64_or_DT_INT64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF,
{
    inner: Rc<Add<T>>,
}

impl<T> GraphOperation for Add<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_STRING_or_DT_COMPLEX64_or_DT_INT64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("Add_{}")?
        };
        let mut new_op = graph.new_operation("Add", &op_name)?;
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct Add<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_STRING_or_DT_COMPLEX64_or_DT_INT64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF,
{
    x: Edge<T>,
    y: Edge<T>,
    id_: usize,
}

impl<T> Add<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_STRING_or_DT_COMPLEX64_or_DT_INT64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF,
{
    pub fn finish(self) -> AddOp<T> {
        AddOp::new(Rc::new(self))
    }

    pub fn new(x: Edge<T>, y: Edge<T>) -> Self {
        Self {
            x,
            y,
            id_: new_id(),
        }
    }
}

impl<T1, T2, Toutput> QuantizedAddOp<T1, T2, Toutput>
where T1: con_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_QINT16_or_DT_QUINT16,
      T2: con_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_QINT16_or_DT_QUINT16,
      Toutput: con_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_QINT16_or_DT_QUINT16,
{
    pub fn new(inner: Rc<QuantizedAdd<T1, T2, Toutput>>) -> Self {
        Self{inner}
    }

    pub fn z(&self) -> Edge<Toutput> {
        Edge::<Toutput>::new(self.inner.clone(), 0)
    }

    pub fn min_z(&self) -> Edge<f32> {
        Edge::<f32>::new(self.inner.clone(), 1)
    }

    pub fn max_z(&self) -> Edge<f32> {
        Edge::<f32>::new(self.inner.clone(), 2)
    }
}

struct QuantizedAddOp<T1, T2, Toutput>
where T1: con_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_QINT16_or_DT_QUINT16,
      T2: con_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_QINT16_or_DT_QUINT16,
      Toutput: con_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_QINT16_or_DT_QUINT16,
{
    inner: Rc<QuantizedAdd<T1, T2, Toutput>>,
}

impl<T1, T2, Toutput> GraphOperation for QuantizedAdd<T1, T2, Toutput>
where T1: con_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_QINT16_or_DT_QUINT16,
      T2: con_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_QINT16_or_DT_QUINT16,
      Toutput: con_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_QINT16_or_DT_QUINT16,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("QuantizedAdd_{}")?
        };
        let mut new_op = graph.new_operation("QuantizedAdd", &op_name)?;
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct QuantizedAdd<T1, T2, Toutput>
where T1: con_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_QINT16_or_DT_QUINT16,
      T2: con_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_QINT16_or_DT_QUINT16,
      Toutput: con_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_QINT16_or_DT_QUINT16,
{
    x: Edge<T1>,
    y: Edge<T2>,
    min_x: Edge<f32>,
    max_x: Edge<f32>,
    min_y: Edge<f32>,
    max_y: Edge<f32>,
    id_: usize,
}

impl<T1, T2, Toutput> QuantizedAdd<T1, T2, Toutput>
where T1: con_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_QINT16_or_DT_QUINT16,
      T2: con_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_QINT16_or_DT_QUINT16,
      Toutput: con_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_QINT16_or_DT_QUINT16,
{
    pub fn finish(self) -> QuantizedAddOp<T1, T2, Toutput> {
        QuantizedAddOp::new(Rc::new(self))
    }

    pub fn new(x: Edge<T1>, y: Edge<T2>, min_x: Edge<f32>, max_x: Edge<f32>, min_y: Edge<f32>, max_y: Edge<f32>) -> Self {
        Self {
            x,
            y,
            min_x,
            max_x,
            min_y,
            max_y,
            id_: new_id(),
        }
    }
}

impl DecodeWavOp {
    pub fn new(inner: Rc<DecodeWav>) -> Self {
        Self{inner}
    }

    pub fn audio(&self) -> Edge<f32> {
        Edge::<f32>::new(self.inner.clone(), 0)
    }

    pub fn sample_rate(&self) -> Edge<i32> {
        Edge::<i32>::new(self.inner.clone(), 1)
    }
}

struct DecodeWavOp {
    inner: Rc<DecodeWav>,
}

impl GraphOperation for DecodeWav {
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("DecodeWav_{}")?
        };
        let mut new_op = graph.new_operation("DecodeWav", &op_name)?;
        {
            match self.desired_channels {
            }
            None => new_op.set_attr_value_proto("desired_channels", &vec![24_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 1_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_int("desired_channels", *attr)})(&value),
        };
        {
            match self.desired_samples {
            }
            None => new_op.set_attr_value_proto("desired_samples", &vec![24_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 1_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_int("desired_samples", *attr)})(&value),
        };
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct DecodeWav {
    contents: Edge<String>,
    desired_channels: Option<i64>,
    desired_samples: Option<i64>,
    id_: usize,
}

impl DecodeWav {
    pub fn desired_channels(&mut self, desired_channels: int) -> &mut Self {
        self.desired_channels = Some(desired_channels);
        &self
    }

    pub fn desired_samples(&mut self, desired_samples: int) -> &mut Self {
        self.desired_samples = Some(desired_samples);
        &self
    }

    pub fn finish(self) -> DecodeWavOp {
        DecodeWavOp::new(Rc::new(self))
    }

    pub fn new(contents: Edge<String>) -> Self {
        Self {
            contents,
            desired_channels: None,
            desired_samples: None,
            id_: new_id(),
        }
    }
}

impl<T, out_idx> UniqueOp<T, out_idx>
where T: con,
      out_idx: con_or_DT_INT32_or_DT_INT64,
{
    pub fn new(inner: Rc<Unique<T, out_idx>>) -> Self {
        Self{inner}
    }

    pub fn y(&self) -> Edge<T> {
        Edge::<T>::new(self.inner.clone(), 0)
    }

    pub fn idx(&self) -> Edge<out_idx> {
        Edge::<out_idx>::new(self.inner.clone(), 1)
    }
}

struct UniqueOp<T, out_idx>
where T: con,
      out_idx: con_or_DT_INT32_or_DT_INT64,
{
    inner: Rc<Unique<T, out_idx>>,
}

impl<T, out_idx> GraphOperation for Unique<T, out_idx>
where T: con,
      out_idx: con_or_DT_INT32_or_DT_INT64,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("Unique_{}")?
        };
        let mut new_op = graph.new_operation("Unique", &op_name)?;
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct Unique<T, out_idx>
where T: con,
      out_idx: con_or_DT_INT32_or_DT_INT64,
{
    x: Edge<T>,
    id_: usize,
}

impl<T, out_idx> Unique<T, out_idx>
where T: con,
      out_idx: con_or_DT_INT32_or_DT_INT64,
{
    pub fn finish(self) -> UniqueOp<T, out_idx> {
        UniqueOp::new(Rc::new(self))
    }

    pub fn new(x: Edge<T>) -> Self {
        Self {
            x,
            id_: new_id(),
        }
    }
}

impl<T> RefSelectOp<T>
where T: con,
{
    pub fn new(inner: Rc<RefSelect<T>>) -> Self {
        Self{inner}
    }

    pub fn output(&self) -> Edge<T> {
        Edge::<T>::new(self.inner.clone(), 0)
    }
}

struct RefSelectOp<T>
where T: con,
{
    inner: Rc<RefSelect<T>>,
}

impl<T> GraphOperation for RefSelect<T>
where T: con,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("RefSelect_{}")?
        };
        let mut new_op = graph.new_operation("RefSelect", &op_name)?;
        {
            (|attr| {new_op.set_attr_int("N", *attr)})(&self.N)
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct RefSelect<T>
where T: con,
{
    index: Edge<i32>,
    inputs: Edge<T>,
    N: i64,
    id_: usize,
}

impl<T> RefSelect<T>
where T: con,
{
    pub fn finish(self) -> RefSelectOp<T> {
        RefSelectOp::new(Rc::new(self))
    }

    pub fn new(index: Edge<i32>, inputs: Edge<T>, N: int) -> Self {
        Self {
            index,
            inputs,
            N: N
            id_: new_id(),
        }
    }
}

impl<T, Tpaddings> MirrorPadOp<T, Tpaddings>
where T: con,
      Tpaddings: con_or_DT_INT32_or_DT_INT64,
{
    pub fn new(inner: Rc<MirrorPad<T, Tpaddings>>) -> Self {
        Self{inner}
    }

    pub fn output(&self) -> Edge<T> {
        Edge::<T>::new(self.inner.clone(), 0)
    }
}

struct MirrorPadOp<T, Tpaddings>
where T: con,
      Tpaddings: con_or_DT_INT32_or_DT_INT64,
{
    inner: Rc<MirrorPad<T, Tpaddings>>,
}

impl<T, Tpaddings> GraphOperation for MirrorPad<T, Tpaddings>
where T: con,
      Tpaddings: con_or_DT_INT32_or_DT_INT64,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("MirrorPad_{}")?
        };
        let mut new_op = graph.new_operation("MirrorPad", &op_name)?;
        {
            (|attr| {new_op.set_attr_string("mode", attr)})(&self.mode)
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct MirrorPad<T, Tpaddings>
where T: con,
      Tpaddings: con_or_DT_INT32_or_DT_INT64,
{
    input: Edge<T>,
    paddings: Edge<Tpaddings>,
    mode: String,
    id_: usize,
}

impl<T, Tpaddings> MirrorPad<T, Tpaddings>
where T: con,
      Tpaddings: con_or_DT_INT32_or_DT_INT64,
{
    pub fn finish(self) -> MirrorPadOp<T, Tpaddings> {
        MirrorPadOp::new(Rc::new(self))
    }

    pub fn new(input: Edge<T>, paddings: Edge<Tpaddings>, mode: &str) -> Self {
        Self {
            input,
            paddings,
            mode: mode.to_string()
            id_: new_id(),
        }
    }
}

impl FakeQuantWithMinMaxVarsPerChannelGradientOp {
    pub fn new(inner: Rc<FakeQuantWithMinMaxVarsPerChannelGradient>) -> Self {
        Self{inner}
    }

    pub fn backprops_wrt_input(&self) -> Edge<f32> {
        Edge::<f32>::new(self.inner.clone(), 0)
    }

    pub fn backprop_wrt_min(&self) -> Edge<f32> {
        Edge::<f32>::new(self.inner.clone(), 1)
    }

    pub fn backprop_wrt_max(&self) -> Edge<f32> {
        Edge::<f32>::new(self.inner.clone(), 2)
    }
}

struct FakeQuantWithMinMaxVarsPerChannelGradientOp {
    inner: Rc<FakeQuantWithMinMaxVarsPerChannelGradient>,
}

impl GraphOperation for FakeQuantWithMinMaxVarsPerChannelGradient {
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("FakeQuantWithMinMaxVarsPerChannelGradient_{}")?
        };
        let mut new_op = graph.new_operation("FakeQuantWithMinMaxVarsPerChannelGradient", &op_name)?;
        {
            match self.num_bits {
            }
            None => new_op.set_attr_value_proto("num_bits", &vec![24_u8, 8_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_int("num_bits", *attr)})(&value),
        };
        {
            match self.narrow_range {
            }
            None => new_op.set_attr_value_proto("narrow_range", &vec![40_u8, 0_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_bool("narrow_range", *attr)})(&value),
        };
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct FakeQuantWithMinMaxVarsPerChannelGradient {
    gradients: Edge<f32>,
    inputs: Edge<f32>,
    min: Edge<f32>,
    max: Edge<f32>,
    num_bits: Option<i64>,
    narrow_range: Option<bool>,
    id_: usize,
}

impl FakeQuantWithMinMaxVarsPerChannelGradient {
    pub fn num_bits(&mut self, num_bits: int) -> &mut Self {
        self.num_bits = Some(num_bits);
        &self
    }

    pub fn narrow_range(&mut self, narrow_range: bool) -> &mut Self {
        self.narrow_range = Some(narrow_range);
        &self
    }

    pub fn finish(self) -> FakeQuantWithMinMaxVarsPerChannelGradientOp {
        FakeQuantWithMinMaxVarsPerChannelGradientOp::new(Rc::new(self))
    }

    pub fn new(gradients: Edge<f32>, inputs: Edge<f32>, min: Edge<f32>, max: Edge<f32>) -> Self {
        Self {
            gradients,
            inputs,
            min,
            max,
            num_bits: None,
            narrow_range: None,
            id_: new_id(),
        }
    }
}

impl<dtype> TensorArrayReadOp<dtype>
where dtype: con,
{
    pub fn new(inner: Rc<TensorArrayRead<dtype>>) -> Self {
        Self{inner}
    }

    pub fn value(&self) -> Edge<dtype> {
        Edge::<dtype>::new(self.inner.clone(), 0)
    }
}

struct TensorArrayReadOp<dtype>
where dtype: con,
{
    inner: Rc<TensorArrayRead<dtype>>,
}

impl<dtype> GraphOperation for TensorArrayRead<dtype>
where dtype: con,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("TensorArrayRead_{}")?
        };
        let mut new_op = graph.new_operation("TensorArrayRead", &op_name)?;
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct TensorArrayRead<dtype>
where dtype: con,
{
    handle: Edge<String>,
    index: Edge<i32>,
    flow_in: Edge<f32>,
    id_: usize,
}

impl<dtype> TensorArrayRead<dtype>
where dtype: con,
{
    pub fn finish(self) -> TensorArrayReadOp<dtype> {
        TensorArrayReadOp::new(Rc::new(self))
    }

    pub fn new(handle: Edge<String>, index: Edge<i32>, flow_in: Edge<f32>) -> Self {
        Self {
            handle,
            index,
            flow_in,
            id_: new_id(),
        }
    }
}

impl<T> BetaincOp<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE,
{
    pub fn new(inner: Rc<Betainc<T>>) -> Self {
        Self{inner}
    }

    pub fn z(&self) -> Edge<T> {
        Edge::<T>::new(self.inner.clone(), 0)
    }
}

struct BetaincOp<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE,
{
    inner: Rc<Betainc<T>>,
}

impl<T> GraphOperation for Betainc<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("Betainc_{}")?
        };
        let mut new_op = graph.new_operation("Betainc", &op_name)?;
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct Betainc<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE,
{
    a: Edge<T>,
    b: Edge<T>,
    x: Edge<T>,
    id_: usize,
}

impl<T> Betainc<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE,
{
    pub fn finish(self) -> BetaincOp<T> {
        BetaincOp::new(Rc::new(self))
    }

    pub fn new(a: Edge<T>, b: Edge<T>, x: Edge<T>) -> Self {
        Self {
            a,
            b,
            x,
            id_: new_id(),
        }
    }
}

impl FakeQuantWithMinMaxVarsPerChannelOp {
    pub fn new(inner: Rc<FakeQuantWithMinMaxVarsPerChannel>) -> Self {
        Self{inner}
    }

    pub fn outputs(&self) -> Edge<f32> {
        Edge::<f32>::new(self.inner.clone(), 0)
    }
}

struct FakeQuantWithMinMaxVarsPerChannelOp {
    inner: Rc<FakeQuantWithMinMaxVarsPerChannel>,
}

impl GraphOperation for FakeQuantWithMinMaxVarsPerChannel {
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("FakeQuantWithMinMaxVarsPerChannel_{}")?
        };
        let mut new_op = graph.new_operation("FakeQuantWithMinMaxVarsPerChannel", &op_name)?;
        {
            match self.num_bits {
            }
            None => new_op.set_attr_value_proto("num_bits", &vec![24_u8, 8_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_int("num_bits", *attr)})(&value),
        };
        {
            match self.narrow_range {
            }
            None => new_op.set_attr_value_proto("narrow_range", &vec![40_u8, 0_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_bool("narrow_range", *attr)})(&value),
        };
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct FakeQuantWithMinMaxVarsPerChannel {
    inputs: Edge<f32>,
    min: Edge<f32>,
    max: Edge<f32>,
    num_bits: Option<i64>,
    narrow_range: Option<bool>,
    id_: usize,
}

impl FakeQuantWithMinMaxVarsPerChannel {
    pub fn num_bits(&mut self, num_bits: int) -> &mut Self {
        self.num_bits = Some(num_bits);
        &self
    }

    pub fn narrow_range(&mut self, narrow_range: bool) -> &mut Self {
        self.narrow_range = Some(narrow_range);
        &self
    }

    pub fn finish(self) -> FakeQuantWithMinMaxVarsPerChannelOp {
        FakeQuantWithMinMaxVarsPerChannelOp::new(Rc::new(self))
    }

    pub fn new(inputs: Edge<f32>, min: Edge<f32>, max: Edge<f32>) -> Self {
        Self {
            inputs,
            min,
            max,
            num_bits: None,
            narrow_range: None,
            id_: new_id(),
        }
    }
}

impl<K, V> XlaKeyValueSortOp<K, V>
where K: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      V: con,
{
    pub fn new(inner: Rc<XlaKeyValueSort<K, V>>) -> Self {
        Self{inner}
    }

    pub fn sorted_keys(&self) -> Edge<K> {
        Edge::<K>::new(self.inner.clone(), 0)
    }

    pub fn sorted_values(&self) -> Edge<V> {
        Edge::<V>::new(self.inner.clone(), 1)
    }
}

struct XlaKeyValueSortOp<K, V>
where K: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      V: con,
{
    inner: Rc<XlaKeyValueSort<K, V>>,
}

impl<K, V> GraphOperation for XlaKeyValueSort<K, V>
where K: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      V: con,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("XlaKeyValueSort_{}")?
        };
        let mut new_op = graph.new_operation("XlaKeyValueSort", &op_name)?;
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct XlaKeyValueSort<K, V>
where K: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      V: con,
{
    keys: Edge<K>,
    values: Edge<V>,
    id_: usize,
}

impl<K, V> XlaKeyValueSort<K, V>
where K: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      V: con,
{
    pub fn finish(self) -> XlaKeyValueSortOp<K, V> {
        XlaKeyValueSortOp::new(Rc::new(self))
    }

    pub fn new(keys: Edge<K>, values: Edge<V>) -> Self {
        Self {
            keys,
            values,
            id_: new_id(),
        }
    }
}

impl LoadTPUEmbeddingFTRLParametersOp {
    pub fn new(inner: Rc<LoadTPUEmbeddingFTRLParameters>) -> Self {
        Self{inner}
    }
}

struct LoadTPUEmbeddingFTRLParametersOp {
    inner: Rc<LoadTPUEmbeddingFTRLParameters>,
}

impl GraphOperation for LoadTPUEmbeddingFTRLParameters {
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("LoadTPUEmbeddingFTRLParameters_{}")?
        };
        let mut new_op = graph.new_operation("LoadTPUEmbeddingFTRLParameters", &op_name)?;
        {
            match self.table_id {
            }
            None => new_op.set_attr_value_proto("table_id", &vec![24_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 1_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_int("table_id", *attr)})(&value),
        };
        {
            match self.table_name {
            }
            None => new_op.set_attr_value_proto("table_name", &vec![18_u8, 0_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_string("table_name", attr)})(&value),
        };
        {
            (|attr| {new_op.set_attr_int("num_shards", *attr)})(&self.num_shards)
        }
        {
            (|attr| {new_op.set_attr_int("shard_id", *attr)})(&self.shard_id)
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct LoadTPUEmbeddingFTRLParameters {
    parameters: Edge<f32>,
    accumulators: Edge<f32>,
    linears: Edge<f32>,
    table_id: Option<i64>,
    table_name: Option<String>,
    num_shards: i64,
    shard_id: i64,
    id_: usize,
}

impl LoadTPUEmbeddingFTRLParameters {
    pub fn table_id(&mut self, table_id: int) -> &mut Self {
        self.table_id = Some(table_id);
        &self
    }

    pub fn table_name(&mut self, table_name: &str) -> &mut Self {
        self.table_name = Some(table_name.to_string());
        &self
    }

    pub fn finish(self) -> LoadTPUEmbeddingFTRLParametersOp {
        LoadTPUEmbeddingFTRLParametersOp::new(Rc::new(self))
    }

    pub fn new(parameters: Edge<f32>, accumulators: Edge<f32>, linears: Edge<f32>, num_shards: int, shard_id: int) -> Self {
        Self {
            parameters,
            accumulators,
            linears,
            table_id: None,
            table_name: None,
            num_shards: num_shards
            shard_id: shard_id
            id_: new_id(),
        }
    }
}

impl<T, Tindices> XlaDynamicUpdateSliceOp<T, Tindices>
where T: con,
      Tindices: con_or_DT_INT32_or_DT_INT64,
{
    pub fn new(inner: Rc<XlaDynamicUpdateSlice<T, Tindices>>) -> Self {
        Self{inner}
    }

    pub fn output(&self) -> Edge<T> {
        Edge::<T>::new(self.inner.clone(), 0)
    }
}

struct XlaDynamicUpdateSliceOp<T, Tindices>
where T: con,
      Tindices: con_or_DT_INT32_or_DT_INT64,
{
    inner: Rc<XlaDynamicUpdateSlice<T, Tindices>>,
}

impl<T, Tindices> GraphOperation for XlaDynamicUpdateSlice<T, Tindices>
where T: con,
      Tindices: con_or_DT_INT32_or_DT_INT64,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("XlaDynamicUpdateSlice_{}")?
        };
        let mut new_op = graph.new_operation("XlaDynamicUpdateSlice", &op_name)?;
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct XlaDynamicUpdateSlice<T, Tindices>
where T: con,
      Tindices: con_or_DT_INT32_or_DT_INT64,
{
    input: Edge<T>,
    update: Edge<T>,
    indices: Edge<Tindices>,
    id_: usize,
}

impl<T, Tindices> XlaDynamicUpdateSlice<T, Tindices>
where T: con,
      Tindices: con_or_DT_INT32_or_DT_INT64,
{
    pub fn finish(self) -> XlaDynamicUpdateSliceOp<T, Tindices> {
        XlaDynamicUpdateSliceOp::new(Rc::new(self))
    }

    pub fn new(input: Edge<T>, update: Edge<T>, indices: Edge<Tindices>) -> Self {
        Self {
            input,
            update,
            indices,
            id_: new_id(),
        }
    }
}

impl<dtype> EmptyOp<dtype>
where dtype: con,
{
    pub fn new(inner: Rc<Empty<dtype>>) -> Self {
        Self{inner}
    }

    pub fn output(&self) -> Edge<dtype> {
        Edge::<dtype>::new(self.inner.clone(), 0)
    }
}

struct EmptyOp<dtype>
where dtype: con,
{
    inner: Rc<Empty<dtype>>,
}

impl<dtype> GraphOperation for Empty<dtype>
where dtype: con,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("Empty_{}")?
        };
        let mut new_op = graph.new_operation("Empty", &op_name)?;
        {
            match self.init {
            }
            None => new_op.set_attr_value_proto("init", &vec![40_u8, 0_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_bool("init", *attr)})(&value),
        };
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct Empty<dtype>
where dtype: con,
{
    shape: Edge<i32>,
    init: Option<bool>,
    id_: usize,
}

impl<dtype> Empty<dtype>
where dtype: con,
{
    pub fn init(&mut self, init: bool) -> &mut Self {
        self.init = Some(init);
        &self
    }

    pub fn finish(self) -> EmptyOp<dtype> {
        EmptyOp::new(Rc::new(self))
    }

    pub fn new(shape: Edge<i32>) -> Self {
        Self {
            shape,
            init: None,
            id_: new_id(),
        }
    }
}

impl RetrieveTPUEmbeddingMDLAdagradLightParametersOp {
    pub fn new(inner: Rc<RetrieveTPUEmbeddingMDLAdagradLightParameters>) -> Self {
        Self{inner}
    }

    pub fn parameters(&self) -> Edge<f32> {
        Edge::<f32>::new(self.inner.clone(), 0)
    }

    pub fn accumulators(&self) -> Edge<f32> {
        Edge::<f32>::new(self.inner.clone(), 1)
    }

    pub fn weights(&self) -> Edge<f32> {
        Edge::<f32>::new(self.inner.clone(), 2)
    }

    pub fn benefits(&self) -> Edge<f32> {
        Edge::<f32>::new(self.inner.clone(), 3)
    }
}

struct RetrieveTPUEmbeddingMDLAdagradLightParametersOp {
    inner: Rc<RetrieveTPUEmbeddingMDLAdagradLightParameters>,
}

impl GraphOperation for RetrieveTPUEmbeddingMDLAdagradLightParameters {
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("RetrieveTPUEmbeddingMDLAdagradLightParameters_{}")?
        };
        let mut new_op = graph.new_operation("RetrieveTPUEmbeddingMDLAdagradLightParameters", &op_name)?;
        {
            match self.table_id {
            }
            None => new_op.set_attr_value_proto("table_id", &vec![24_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 1_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_int("table_id", *attr)})(&value),
        };
        {
            match self.table_name {
            }
            None => new_op.set_attr_value_proto("table_name", &vec![18_u8, 0_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_string("table_name", attr)})(&value),
        };
        {
            (|attr| {new_op.set_attr_int("num_shards", *attr)})(&self.num_shards)
        }
        {
            (|attr| {new_op.set_attr_int("shard_id", *attr)})(&self.shard_id)
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct RetrieveTPUEmbeddingMDLAdagradLightParameters {
    table_id: Option<i64>,
    table_name: Option<String>,
    num_shards: i64,
    shard_id: i64,
    id_: usize,
}

impl RetrieveTPUEmbeddingMDLAdagradLightParameters {
    pub fn table_id(&mut self, table_id: int) -> &mut Self {
        self.table_id = Some(table_id);
        &self
    }

    pub fn table_name(&mut self, table_name: &str) -> &mut Self {
        self.table_name = Some(table_name.to_string());
        &self
    }

    pub fn finish(self) -> RetrieveTPUEmbeddingMDLAdagradLightParametersOp {
        RetrieveTPUEmbeddingMDLAdagradLightParametersOp::new(Rc::new(self))
    }

    pub fn new(num_shards: int, shard_id: int) -> Self {
        Self {
            table_id: None,
            table_name: None,
            num_shards: num_shards
            shard_id: shard_id
            id_: new_id(),
        }
    }
}

impl<T> FractionalAvgPoolOp<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_INT64,
{
    pub fn new(inner: Rc<FractionalAvgPool<T>>) -> Self {
        Self{inner}
    }

    pub fn output(&self) -> Edge<T> {
        Edge::<T>::new(self.inner.clone(), 0)
    }

    pub fn row_pooling_sequence(&self) -> Edge<i64> {
        Edge::<i64>::new(self.inner.clone(), 1)
    }

    pub fn col_pooling_sequence(&self) -> Edge<i64> {
        Edge::<i64>::new(self.inner.clone(), 2)
    }
}

struct FractionalAvgPoolOp<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_INT64,
{
    inner: Rc<FractionalAvgPool<T>>,
}

impl<T> GraphOperation for FractionalAvgPool<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_INT64,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("FractionalAvgPool_{}")?
        };
        let mut new_op = graph.new_operation("FractionalAvgPool", &op_name)?;
        {
            (|attrs| {new_op.set_attr_float_list("pooling_ratio", attrs)})(&self.pooling_ratio)
        }
        {
            match self.pseudo_random {
            }
            None => new_op.set_attr_value_proto("pseudo_random", &vec![40_u8, 0_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_bool("pseudo_random", *attr)})(&value),
        };
        {
            match self.overlapping {
            }
            None => new_op.set_attr_value_proto("overlapping", &vec![40_u8, 0_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_bool("overlapping", *attr)})(&value),
        };
        {
            match self.deterministic {
            }
            None => new_op.set_attr_value_proto("deterministic", &vec![40_u8, 0_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_bool("deterministic", *attr)})(&value),
        };
        {
            match self.seed {
            }
            None => new_op.set_attr_value_proto("seed", &vec![24_u8, 0_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_int("seed", *attr)})(&value),
        };
        {
            match self.seed2 {
            }
            None => new_op.set_attr_value_proto("seed2", &vec![24_u8, 0_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_int("seed2", *attr)})(&value),
        };
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct FractionalAvgPool<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_INT64,
{
    value: Edge<T>,
    pooling_ratio: Vec<f32>,
    pseudo_random: Option<bool>,
    overlapping: Option<bool>,
    deterministic: Option<bool>,
    seed: Option<i64>,
    seed2: Option<i64>,
    id_: usize,
}

impl<T> FractionalAvgPool<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_INT64,
{
    pub fn pseudo_random(&mut self, pseudo_random: bool) -> &mut Self {
        self.pseudo_random = Some(pseudo_random);
        &self
    }

    pub fn overlapping(&mut self, overlapping: bool) -> &mut Self {
        self.overlapping = Some(overlapping);
        &self
    }

    pub fn deterministic(&mut self, deterministic: bool) -> &mut Self {
        self.deterministic = Some(deterministic);
        &self
    }

    pub fn seed(&mut self, seed: int) -> &mut Self {
        self.seed = Some(seed);
        &self
    }

    pub fn seed2(&mut self, seed2: int) -> &mut Self {
        self.seed2 = Some(seed2);
        &self
    }

    pub fn finish(self) -> FractionalAvgPoolOp<T> {
        FractionalAvgPoolOp::new(Rc::new(self))
    }

    pub fn new(value: Edge<T>, pooling_ratio: &[f32]) -> Self {
        Self {
            value,
            pooling_ratio: pooling_ratio.to_vec()
            pseudo_random: None,
            overlapping: None,
            deterministic: None,
            seed: None,
            seed2: None,
            id_: new_id(),
        }
    }
}

impl<T> ExtractVolumePatchesOp<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
{
    pub fn new(inner: Rc<ExtractVolumePatches<T>>) -> Self {
        Self{inner}
    }

    pub fn patches(&self) -> Edge<T> {
        Edge::<T>::new(self.inner.clone(), 0)
    }
}

struct ExtractVolumePatchesOp<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
{
    inner: Rc<ExtractVolumePatches<T>>,
}

impl<T> GraphOperation for ExtractVolumePatches<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("ExtractVolumePatches_{}")?
        };
        let mut new_op = graph.new_operation("ExtractVolumePatches", &op_name)?;
        {
            (|attrs| {new_op.set_attr_int_list("ksizes", attrs)})(&self.ksizes)
        }
        {
            (|attrs| {new_op.set_attr_int_list("strides", attrs)})(&self.strides)
        }
        {
            (|attr| {new_op.set_attr_string("padding", attr)})(&self.padding)
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct ExtractVolumePatches<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
{
    input: Edge<T>,
    ksizes: Vec<i64>,
    strides: Vec<i64>,
    padding: String,
    id_: usize,
}

impl<T> ExtractVolumePatches<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
{
    pub fn finish(self) -> ExtractVolumePatchesOp<T> {
        ExtractVolumePatchesOp::new(Rc::new(self))
    }

    pub fn new(input: Edge<T>, ksizes: &[int], strides: &[int], padding: &str) -> Self {
        Self {
            input,
            ksizes: ksizes.to_vec()
            strides: strides.to_vec()
            padding: padding.to_string()
            id_: new_id(),
        }
    }
}

impl<T> GetSessionHandleOp<T>
where T: con,
{
    pub fn new(inner: Rc<GetSessionHandle<T>>) -> Self {
        Self{inner}
    }

    pub fn handle(&self) -> Edge<String> {
        Edge::<String>::new(self.inner.clone(), 0)
    }
}

struct GetSessionHandleOp<T>
where T: con,
{
    inner: Rc<GetSessionHandle<T>>,
}

impl<T> GraphOperation for GetSessionHandle<T>
where T: con,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("GetSessionHandle_{}")?
        };
        let mut new_op = graph.new_operation("GetSessionHandle", &op_name)?;
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct GetSessionHandle<T>
where T: con,
{
    value: Edge<T>,
    id_: usize,
}

impl<T> GetSessionHandle<T>
where T: con,
{
    pub fn finish(self) -> GetSessionHandleOp<T> {
        GetSessionHandleOp::new(Rc::new(self))
    }

    pub fn new(value: Edge<T>) -> Self {
        Self {
            value,
            id_: new_id(),
        }
    }
}

impl<Tkeys, Tvalues> LookupTableExportOp<Tkeys, Tvalues>
where Tkeys: con,
      Tvalues: con,
{
    pub fn new(inner: Rc<LookupTableExport<Tkeys, Tvalues>>) -> Self {
        Self{inner}
    }

    pub fn keys(&self) -> Edge<Tkeys> {
        Edge::<Tkeys>::new(self.inner.clone(), 0)
    }

    pub fn values(&self) -> Edge<Tvalues> {
        Edge::<Tvalues>::new(self.inner.clone(), 1)
    }
}

struct LookupTableExportOp<Tkeys, Tvalues>
where Tkeys: con,
      Tvalues: con,
{
    inner: Rc<LookupTableExport<Tkeys, Tvalues>>,
}

impl<Tkeys, Tvalues> GraphOperation for LookupTableExport<Tkeys, Tvalues>
where Tkeys: con,
      Tvalues: con,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("LookupTableExport_{}")?
        };
        let mut new_op = graph.new_operation("LookupTableExport", &op_name)?;
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct LookupTableExport<Tkeys, Tvalues>
where Tkeys: con,
      Tvalues: con,
{
    table_handle: Edge<String>,
    id_: usize,
}

impl<Tkeys, Tvalues> LookupTableExport<Tkeys, Tvalues>
where Tkeys: con,
      Tvalues: con,
{
    pub fn finish(self) -> LookupTableExportOp<Tkeys, Tvalues> {
        LookupTableExportOp::new(Rc::new(self))
    }

    pub fn new(table_handle: Edge<String>) -> Self {
        Self {
            table_handle,
            id_: new_id(),
        }
    }
}

impl<T> BatchMatrixInverseOp<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE,
{
    pub fn new(inner: Rc<BatchMatrixInverse<T>>) -> Self {
        Self{inner}
    }

    pub fn output(&self) -> Edge<T> {
        Edge::<T>::new(self.inner.clone(), 0)
    }
}

struct BatchMatrixInverseOp<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE,
{
    inner: Rc<BatchMatrixInverse<T>>,
}

impl<T> GraphOperation for BatchMatrixInverse<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("BatchMatrixInverse_{}")?
        };
        let mut new_op = graph.new_operation("BatchMatrixInverse", &op_name)?;
        {
            match self.adjoint {
            }
            None => new_op.set_attr_value_proto("adjoint", &vec![40_u8, 0_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_bool("adjoint", *attr)})(&value),
        };
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct BatchMatrixInverse<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE,
{
    input: Edge<T>,
    adjoint: Option<bool>,
    id_: usize,
}

impl<T> BatchMatrixInverse<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE,
{
    pub fn adjoint(&mut self, adjoint: bool) -> &mut Self {
        self.adjoint = Some(adjoint);
        &self
    }

    pub fn finish(self) -> BatchMatrixInverseOp<T> {
        BatchMatrixInverseOp::new(Rc::new(self))
    }

    pub fn new(input: Edge<T>) -> Self {
        Self {
            input,
            adjoint: None,
            id_: new_id(),
        }
    }
}

impl<T> TensorArraySplitOp<T>
where T: con,
{
    pub fn new(inner: Rc<TensorArraySplit<T>>) -> Self {
        Self{inner}
    }

    pub fn flow_out(&self) -> Edge<f32> {
        Edge::<f32>::new(self.inner.clone(), 0)
    }
}

struct TensorArraySplitOp<T>
where T: con,
{
    inner: Rc<TensorArraySplit<T>>,
}

impl<T> GraphOperation for TensorArraySplit<T>
where T: con,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("TensorArraySplit_{}")?
        };
        let mut new_op = graph.new_operation("TensorArraySplit", &op_name)?;
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct TensorArraySplit<T>
where T: con,
{
    handle: Edge<String>,
    value: Edge<T>,
    lengths: Edge<i64>,
    flow_in: Edge<f32>,
    id_: usize,
}

impl<T> TensorArraySplit<T>
where T: con,
{
    pub fn finish(self) -> TensorArraySplitOp<T> {
        TensorArraySplitOp::new(Rc::new(self))
    }

    pub fn new(handle: Edge<String>, value: Edge<T>, lengths: Edge<i64>, flow_in: Edge<f32>) -> Self {
        Self {
            handle,
            value,
            lengths,
            flow_in,
            id_: new_id(),
        }
    }
}

impl GenerateVocabRemappingOp {
    pub fn new(inner: Rc<GenerateVocabRemapping>) -> Self {
        Self{inner}
    }

    pub fn remapping(&self) -> Edge<i64> {
        Edge::<i64>::new(self.inner.clone(), 0)
    }

    pub fn num_present(&self) -> Edge<i32> {
        Edge::<i32>::new(self.inner.clone(), 1)
    }
}

struct GenerateVocabRemappingOp {
    inner: Rc<GenerateVocabRemapping>,
}

impl GraphOperation for GenerateVocabRemapping {
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("GenerateVocabRemapping_{}")?
        };
        let mut new_op = graph.new_operation("GenerateVocabRemapping", &op_name)?;
        {
            (|attr| {new_op.set_attr_int("new_vocab_offset", *attr)})(&self.new_vocab_offset)
        }
        {
            (|attr| {new_op.set_attr_int("num_new_vocab", *attr)})(&self.num_new_vocab)
        }
        {
            match self.old_vocab_size {
            }
            None => new_op.set_attr_value_proto("old_vocab_size", &vec![24_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 1_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_int("old_vocab_size", *attr)})(&value),
        };
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct GenerateVocabRemapping {
    new_vocab_file: Edge<String>,
    old_vocab_file: Edge<String>,
    new_vocab_offset: i64,
    num_new_vocab: i64,
    old_vocab_size: Option<i64>,
    id_: usize,
}

impl GenerateVocabRemapping {
    pub fn old_vocab_size(&mut self, old_vocab_size: int) -> &mut Self {
        self.old_vocab_size = Some(old_vocab_size);
        &self
    }

    pub fn finish(self) -> GenerateVocabRemappingOp {
        GenerateVocabRemappingOp::new(Rc::new(self))
    }

    pub fn new(new_vocab_file: Edge<String>, old_vocab_file: Edge<String>, new_vocab_offset: int, num_new_vocab: int) -> Self {
        Self {
            new_vocab_file,
            old_vocab_file,
            new_vocab_offset: new_vocab_offset
            num_new_vocab: num_new_vocab
            old_vocab_size: None,
            id_: new_id(),
        }
    }
}

impl _SetGlobalTPUArrayOp {
    pub fn new(inner: Rc<_SetGlobalTPUArray>) -> Self {
        Self{inner}
    }
}

struct _SetGlobalTPUArrayOp {
    inner: Rc<_SetGlobalTPUArray>,
}

impl GraphOperation for _SetGlobalTPUArray {
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("_SetGlobalTPUArray_{}")?
        };
        let mut new_op = graph.new_operation("_SetGlobalTPUArray", &op_name)?;
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct _SetGlobalTPUArray {
    topology: Edge<String>,
    id_: usize,
}

impl _SetGlobalTPUArray {
    pub fn finish(self) -> _SetGlobalTPUArrayOp {
        _SetGlobalTPUArrayOp::new(Rc::new(self))
    }

    pub fn new(topology: Edge<String>) -> Self {
        Self {
            topology,
            id_: new_id(),
        }
    }
}

impl<dtype> AccumulatorTakeGradientOp<dtype>
where dtype: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
{
    pub fn new(inner: Rc<AccumulatorTakeGradient<dtype>>) -> Self {
        Self{inner}
    }

    pub fn average(&self) -> Edge<dtype> {
        Edge::<dtype>::new(self.inner.clone(), 0)
    }
}

struct AccumulatorTakeGradientOp<dtype>
where dtype: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
{
    inner: Rc<AccumulatorTakeGradient<dtype>>,
}

impl<dtype> GraphOperation for AccumulatorTakeGradient<dtype>
where dtype: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("AccumulatorTakeGradient_{}")?
        };
        let mut new_op = graph.new_operation("AccumulatorTakeGradient", &op_name)?;
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct AccumulatorTakeGradient<dtype>
where dtype: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
{
    handle: Edge<String>,
    num_required: Edge<i32>,
    id_: usize,
}

impl<dtype> AccumulatorTakeGradient<dtype>
where dtype: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
{
    pub fn finish(self) -> AccumulatorTakeGradientOp<dtype> {
        AccumulatorTakeGradientOp::new(Rc::new(self))
    }

    pub fn new(handle: Edge<String>, num_required: Edge<i32>) -> Self {
        Self {
            handle,
            num_required,
            id_: new_id(),
        }
    }
}

impl<T, out_type> SerializeSparseOp<T, out_type>
where T: con,
      out_type: con_or_DT_STRING_or_DT_VARIANT,
{
    pub fn new(inner: Rc<SerializeSparse<T, out_type>>) -> Self {
        Self{inner}
    }

    pub fn serialized_sparse(&self) -> Edge<out_type> {
        Edge::<out_type>::new(self.inner.clone(), 0)
    }
}

struct SerializeSparseOp<T, out_type>
where T: con,
      out_type: con_or_DT_STRING_or_DT_VARIANT,
{
    inner: Rc<SerializeSparse<T, out_type>>,
}

impl<T, out_type> GraphOperation for SerializeSparse<T, out_type>
where T: con,
      out_type: con_or_DT_STRING_or_DT_VARIANT,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("SerializeSparse_{}")?
        };
        let mut new_op = graph.new_operation("SerializeSparse", &op_name)?;
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct SerializeSparse<T, out_type>
where T: con,
      out_type: con_or_DT_STRING_or_DT_VARIANT,
{
    sparse_indices: Edge<i64>,
    sparse_values: Edge<T>,
    sparse_shape: Edge<i64>,
    id_: usize,
}

impl<T, out_type> SerializeSparse<T, out_type>
where T: con,
      out_type: con_or_DT_STRING_or_DT_VARIANT,
{
    pub fn finish(self) -> SerializeSparseOp<T, out_type> {
        SerializeSparseOp::new(Rc::new(self))
    }

    pub fn new(sparse_indices: Edge<i64>, sparse_values: Edge<T>, sparse_shape: Edge<i64>) -> Self {
        Self {
            sparse_indices,
            sparse_values,
            sparse_shape,
            id_: new_id(),
        }
    }
}

impl LearnedUnigramCandidateSamplerOp {
    pub fn new(inner: Rc<LearnedUnigramCandidateSampler>) -> Self {
        Self{inner}
    }

    pub fn sampled_candidates(&self) -> Edge<i64> {
        Edge::<i64>::new(self.inner.clone(), 0)
    }

    pub fn true_expected_count(&self) -> Edge<f32> {
        Edge::<f32>::new(self.inner.clone(), 1)
    }

    pub fn sampled_expected_count(&self) -> Edge<f32> {
        Edge::<f32>::new(self.inner.clone(), 2)
    }
}

struct LearnedUnigramCandidateSamplerOp {
    inner: Rc<LearnedUnigramCandidateSampler>,
}

impl GraphOperation for LearnedUnigramCandidateSampler {
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("LearnedUnigramCandidateSampler_{}")?
        };
        let mut new_op = graph.new_operation("LearnedUnigramCandidateSampler", &op_name)?;
        {
            (|attr| {new_op.set_attr_int("num_true", *attr)})(&self.num_true)
        }
        {
            (|attr| {new_op.set_attr_int("num_sampled", *attr)})(&self.num_sampled)
        }
        {
            (|attr| {new_op.set_attr_bool("unique", *attr)})(&self.unique)
        }
        {
            (|attr| {new_op.set_attr_int("range_max", *attr)})(&self.range_max)
        }
        {
            match self.seed {
            }
            None => new_op.set_attr_value_proto("seed", &vec![24_u8, 0_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_int("seed", *attr)})(&value),
        };
        {
            match self.seed2 {
            }
            None => new_op.set_attr_value_proto("seed2", &vec![24_u8, 0_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_int("seed2", *attr)})(&value),
        };
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct LearnedUnigramCandidateSampler {
    true_classes: Edge<i64>,
    num_true: i64,
    num_sampled: i64,
    unique: bool,
    range_max: i64,
    seed: Option<i64>,
    seed2: Option<i64>,
    id_: usize,
}

impl LearnedUnigramCandidateSampler {
    pub fn seed(&mut self, seed: int) -> &mut Self {
        self.seed = Some(seed);
        &self
    }

    pub fn seed2(&mut self, seed2: int) -> &mut Self {
        self.seed2 = Some(seed2);
        &self
    }

    pub fn finish(self) -> LearnedUnigramCandidateSamplerOp {
        LearnedUnigramCandidateSamplerOp::new(Rc::new(self))
    }

    pub fn new(true_classes: Edge<i64>, num_true: int, num_sampled: int, unique: bool, range_max: int) -> Self {
        Self {
            true_classes,
            num_true: num_true
            num_sampled: num_sampled
            unique: unique
            range_max: range_max
            seed: None,
            seed2: None,
            id_: new_id(),
        }
    }
}

pub trait con_or_DT_FLOAT_or_DT_HALF {
}

impl con_or_DT_FLOAT_or_DT_HALF for f32 {
}

impl<T> DrawBoundingBoxesOp<T>
where T: con_or_DT_FLOAT_or_DT_HALF,
{
    pub fn new(inner: Rc<DrawBoundingBoxes<T>>) -> Self {
        Self{inner}
    }

    pub fn output(&self) -> Edge<T> {
        Edge::<T>::new(self.inner.clone(), 0)
    }
}

struct DrawBoundingBoxesOp<T>
where T: con_or_DT_FLOAT_or_DT_HALF,
{
    inner: Rc<DrawBoundingBoxes<T>>,
}

impl<T> GraphOperation for DrawBoundingBoxes<T>
where T: con_or_DT_FLOAT_or_DT_HALF,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("DrawBoundingBoxes_{}")?
        };
        let mut new_op = graph.new_operation("DrawBoundingBoxes", &op_name)?;
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct DrawBoundingBoxes<T>
where T: con_or_DT_FLOAT_or_DT_HALF,
{
    images: Edge<T>,
    boxes: Edge<f32>,
    id_: usize,
}

impl<T> DrawBoundingBoxes<T>
where T: con_or_DT_FLOAT_or_DT_HALF,
{
    pub fn finish(self) -> DrawBoundingBoxesOp<T> {
        DrawBoundingBoxesOp::new(Rc::new(self))
    }

    pub fn new(images: Edge<T>, boxes: Edge<f32>) -> Self {
        Self {
            images,
            boxes,
            id_: new_id(),
        }
    }
}

impl<T, Tindices> XlaReduceWindowOp<T, Tindices>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      Tindices: con_or_DT_INT32_or_DT_INT64,
{
    pub fn new(inner: Rc<XlaReduceWindow<T, Tindices>>) -> Self {
        Self{inner}
    }

    pub fn output(&self) -> Edge<T> {
        Edge::<T>::new(self.inner.clone(), 0)
    }
}

struct XlaReduceWindowOp<T, Tindices>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      Tindices: con_or_DT_INT32_or_DT_INT64,
{
    inner: Rc<XlaReduceWindow<T, Tindices>>,
}

impl<T, Tindices> GraphOperation for XlaReduceWindow<T, Tindices>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      Tindices: con_or_DT_INT32_or_DT_INT64,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("XlaReduceWindow_{}")?
        };
        let mut new_op = graph.new_operation("XlaReduceWindow", &op_name)?;
        {
            (|attr| {new_op.set_attr_func_name("computation", attr)})(&self.computation)
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct XlaReduceWindow<T, Tindices>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      Tindices: con_or_DT_INT32_or_DT_INT64,
{
    input: Edge<T>,
    init_value: Edge<T>,
    window_dimensions: Edge<Tindices>,
    window_strides: Edge<Tindices>,
    base_dilations: Edge<Tindices>,
    window_dilations: Edge<Tindices>,
    padding: Edge<Tindices>,
    computation: String,
    id_: usize,
}

impl<T, Tindices> XlaReduceWindow<T, Tindices>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      Tindices: con_or_DT_INT32_or_DT_INT64,
{
    pub fn finish(self) -> XlaReduceWindowOp<T, Tindices> {
        XlaReduceWindowOp::new(Rc::new(self))
    }

    pub fn new(input: Edge<T>, init_value: Edge<T>, window_dimensions: Edge<Tindices>, window_strides: Edge<Tindices>, base_dilations: Edge<Tindices>, window_dilations: Edge<Tindices>, padding: Edge<Tindices>, computation: &str) -> Self {
        Self {
            input,
            init_value,
            window_dimensions,
            window_strides,
            base_dilations,
            window_dilations,
            padding,
            computation: computation.to_string()
            id_: new_id(),
        }
    }
}

impl<T, Tindices> XlaSelectAndScatterOp<T, Tindices>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      Tindices: con_or_DT_INT32_or_DT_INT64,
{
    pub fn new(inner: Rc<XlaSelectAndScatter<T, Tindices>>) -> Self {
        Self{inner}
    }

    pub fn output(&self) -> Edge<T> {
        Edge::<T>::new(self.inner.clone(), 0)
    }
}

struct XlaSelectAndScatterOp<T, Tindices>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      Tindices: con_or_DT_INT32_or_DT_INT64,
{
    inner: Rc<XlaSelectAndScatter<T, Tindices>>,
}

impl<T, Tindices> GraphOperation for XlaSelectAndScatter<T, Tindices>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      Tindices: con_or_DT_INT32_or_DT_INT64,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("XlaSelectAndScatter_{}")?
        };
        let mut new_op = graph.new_operation("XlaSelectAndScatter", &op_name)?;
        {
            (|attr| {new_op.set_attr_func_name("select", attr)})(&self.select)
        }
        {
            (|attr| {new_op.set_attr_func_name("scatter", attr)})(&self.scatter)
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct XlaSelectAndScatter<T, Tindices>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      Tindices: con_or_DT_INT32_or_DT_INT64,
{
    operand: Edge<T>,
    window_dimensions: Edge<Tindices>,
    window_strides: Edge<Tindices>,
    padding: Edge<Tindices>,
    source: Edge<T>,
    init_value: Edge<T>,
    select: String,
    scatter: String,
    id_: usize,
}

impl<T, Tindices> XlaSelectAndScatter<T, Tindices>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      Tindices: con_or_DT_INT32_or_DT_INT64,
{
    pub fn finish(self) -> XlaSelectAndScatterOp<T, Tindices> {
        XlaSelectAndScatterOp::new(Rc::new(self))
    }

    pub fn new(operand: Edge<T>, window_dimensions: Edge<Tindices>, window_strides: Edge<Tindices>, padding: Edge<Tindices>, source: Edge<T>, init_value: Edge<T>, select: &str, scatter: &str) -> Self {
        Self {
            operand,
            window_dimensions,
            window_strides,
            padding,
            source,
            init_value,
            select: select.to_string()
            scatter: scatter.to_string()
            id_: new_id(),
        }
    }
}

impl RetrieveTPUEmbeddingAdadeltaParametersGradAccumDebugOp {
    pub fn new(inner: Rc<RetrieveTPUEmbeddingAdadeltaParametersGradAccumDebug>) -> Self {
        Self{inner}
    }

    pub fn parameters(&self) -> Edge<f32> {
        Edge::<f32>::new(self.inner.clone(), 0)
    }

    pub fn accumulators(&self) -> Edge<f32> {
        Edge::<f32>::new(self.inner.clone(), 1)
    }

    pub fn updates(&self) -> Edge<f32> {
        Edge::<f32>::new(self.inner.clone(), 2)
    }

    pub fn gradient_accumulators(&self) -> Edge<f32> {
        Edge::<f32>::new(self.inner.clone(), 3)
    }
}

struct RetrieveTPUEmbeddingAdadeltaParametersGradAccumDebugOp {
    inner: Rc<RetrieveTPUEmbeddingAdadeltaParametersGradAccumDebug>,
}

impl GraphOperation for RetrieveTPUEmbeddingAdadeltaParametersGradAccumDebug {
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("RetrieveTPUEmbeddingAdadeltaParametersGradAccumDebug_{}")?
        };
        let mut new_op = graph.new_operation("RetrieveTPUEmbeddingAdadeltaParametersGradAccumDebug", &op_name)?;
        {
            match self.table_id {
            }
            None => new_op.set_attr_value_proto("table_id", &vec![24_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 1_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_int("table_id", *attr)})(&value),
        };
        {
            match self.table_name {
            }
            None => new_op.set_attr_value_proto("table_name", &vec![18_u8, 0_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_string("table_name", attr)})(&value),
        };
        {
            (|attr| {new_op.set_attr_int("num_shards", *attr)})(&self.num_shards)
        }
        {
            (|attr| {new_op.set_attr_int("shard_id", *attr)})(&self.shard_id)
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct RetrieveTPUEmbeddingAdadeltaParametersGradAccumDebug {
    table_id: Option<i64>,
    table_name: Option<String>,
    num_shards: i64,
    shard_id: i64,
    id_: usize,
}

impl RetrieveTPUEmbeddingAdadeltaParametersGradAccumDebug {
    pub fn table_id(&mut self, table_id: int) -> &mut Self {
        self.table_id = Some(table_id);
        &self
    }

    pub fn table_name(&mut self, table_name: &str) -> &mut Self {
        self.table_name = Some(table_name.to_string());
        &self
    }

    pub fn finish(self) -> RetrieveTPUEmbeddingAdadeltaParametersGradAccumDebugOp {
        RetrieveTPUEmbeddingAdadeltaParametersGradAccumDebugOp::new(Rc::new(self))
    }

    pub fn new(num_shards: int, shard_id: int) -> Self {
        Self {
            table_id: None,
            table_name: None,
            num_shards: num_shards
            shard_id: shard_id
            id_: new_id(),
        }
    }
}

impl<T> RefNextIterationOp<T>
where T: con,
{
    pub fn new(inner: Rc<RefNextIteration<T>>) -> Self {
        Self{inner}
    }

    pub fn output(&self) -> Edge<T> {
        Edge::<T>::new(self.inner.clone(), 0)
    }
}

struct RefNextIterationOp<T>
where T: con,
{
    inner: Rc<RefNextIteration<T>>,
}

impl<T> GraphOperation for RefNextIteration<T>
where T: con,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("RefNextIteration_{}")?
        };
        let mut new_op = graph.new_operation("RefNextIteration", &op_name)?;
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct RefNextIteration<T>
where T: con,
{
    data: Edge<T>,
    id_: usize,
}

impl<T> RefNextIteration<T>
where T: con,
{
    pub fn finish(self) -> RefNextIterationOp<T> {
        RefNextIterationOp::new(Rc::new(self))
    }

    pub fn new(data: Edge<T>) -> Self {
        Self {
            data,
            id_: new_id(),
        }
    }
}

impl<T> ZerosLikeOp<T>
where T: con,
{
    pub fn new(inner: Rc<ZerosLike<T>>) -> Self {
        Self{inner}
    }

    pub fn y(&self) -> Edge<T> {
        Edge::<T>::new(self.inner.clone(), 0)
    }
}

struct ZerosLikeOp<T>
where T: con,
{
    inner: Rc<ZerosLike<T>>,
}

impl<T> GraphOperation for ZerosLike<T>
where T: con,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("ZerosLike_{}")?
        };
        let mut new_op = graph.new_operation("ZerosLike", &op_name)?;
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct ZerosLike<T>
where T: con,
{
    x: Edge<T>,
    id_: usize,
}

impl<T> ZerosLike<T>
where T: con,
{
    pub fn finish(self) -> ZerosLikeOp<T> {
        ZerosLikeOp::new(Rc::new(self))
    }

    pub fn new(x: Edge<T>) -> Self {
        Self {
            x,
            id_: new_id(),
        }
    }
}

impl EnqueueTPUEmbeddingSparseBatchOp {
    pub fn new(inner: Rc<EnqueueTPUEmbeddingSparseBatch>) -> Self {
        Self{inner}
    }
}

struct EnqueueTPUEmbeddingSparseBatchOp {
    inner: Rc<EnqueueTPUEmbeddingSparseBatch>,
}

impl GraphOperation for EnqueueTPUEmbeddingSparseBatch {
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("EnqueueTPUEmbeddingSparseBatch_{}")?
        };
        let mut new_op = graph.new_operation("EnqueueTPUEmbeddingSparseBatch", &op_name)?;
        {
            (|attr| {new_op.set_attr_int("N", *attr)})(&self.N)
        }
        {
            match self.device_ordinal {
            }
            None => new_op.set_attr_value_proto("device_ordinal", &vec![24_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 1_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_int("device_ordinal", *attr)})(&value),
        };
        {
            match self.combiners {
            }
            None => new_op.set_attr_value_proto("combiners", &vec![10_u8, 0_u8,]);,
            Some(value) => (|attrs| {new_op.set_attr_string_list("combiners", attrs)})(&value),
        };
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct EnqueueTPUEmbeddingSparseBatch {
    sample_indices: Edge<i32>,
    embedding_indices: Edge<i32>,
    aggregation_weights: Edge<f32>,
    mode_override: Edge<String>,
    N: i64,
    device_ordinal: Option<i64>,
    combiners: Option<Vec<String>>,
    id_: usize,
}

impl EnqueueTPUEmbeddingSparseBatch {
    pub fn device_ordinal(&mut self, device_ordinal: int) -> &mut Self {
        self.device_ordinal = Some(device_ordinal);
        &self
    }

    pub fn combiners(&mut self, combiners: &[String]) -> &mut Self {
        self.combiners = Some(combiners.to_vec());
        &self
    }

    pub fn finish(self) -> EnqueueTPUEmbeddingSparseBatchOp {
        EnqueueTPUEmbeddingSparseBatchOp::new(Rc::new(self))
    }

    pub fn new(sample_indices: Edge<i32>, embedding_indices: Edge<i32>, aggregation_weights: Edge<f32>, mode_override: Edge<String>, N: int) -> Self {
        Self {
            sample_indices,
            embedding_indices,
            aggregation_weights,
            mode_override,
            N: N
            device_ordinal: None,
            combiners: None,
            id_: new_id(),
        }
    }
}

impl<T, Taxis, out_idx> UniqueV2Op<T, Taxis, out_idx>
where T: con,
      Taxis: con_or_DT_INT32_or_DT_INT64,
      out_idx: con_or_DT_INT32_or_DT_INT64,
{
    pub fn new(inner: Rc<UniqueV2<T, Taxis, out_idx>>) -> Self {
        Self{inner}
    }

    pub fn y(&self) -> Edge<T> {
        Edge::<T>::new(self.inner.clone(), 0)
    }

    pub fn idx(&self) -> Edge<out_idx> {
        Edge::<out_idx>::new(self.inner.clone(), 1)
    }
}

struct UniqueV2Op<T, Taxis, out_idx>
where T: con,
      Taxis: con_or_DT_INT32_or_DT_INT64,
      out_idx: con_or_DT_INT32_or_DT_INT64,
{
    inner: Rc<UniqueV2<T, Taxis, out_idx>>,
}

impl<T, Taxis, out_idx> GraphOperation for UniqueV2<T, Taxis, out_idx>
where T: con,
      Taxis: con_or_DT_INT32_or_DT_INT64,
      out_idx: con_or_DT_INT32_or_DT_INT64,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("UniqueV2_{}")?
        };
        let mut new_op = graph.new_operation("UniqueV2", &op_name)?;
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct UniqueV2<T, Taxis, out_idx>
where T: con,
      Taxis: con_or_DT_INT32_or_DT_INT64,
      out_idx: con_or_DT_INT32_or_DT_INT64,
{
    x: Edge<T>,
    axis: Edge<Taxis>,
    id_: usize,
}

impl<T, Taxis, out_idx> UniqueV2<T, Taxis, out_idx>
where T: con,
      Taxis: con_or_DT_INT32_or_DT_INT64,
      out_idx: con_or_DT_INT32_or_DT_INT64,
{
    pub fn finish(self) -> UniqueV2Op<T, Taxis, out_idx> {
        UniqueV2Op::new(Rc::new(self))
    }

    pub fn new(x: Edge<T>, axis: Edge<Taxis>) -> Self {
        Self {
            x,
            axis,
            id_: new_id(),
        }
    }
}

impl<T> InplaceAddOp<T>
where T: con,
{
    pub fn new(inner: Rc<InplaceAdd<T>>) -> Self {
        Self{inner}
    }

    pub fn y(&self) -> Edge<T> {
        Edge::<T>::new(self.inner.clone(), 0)
    }
}

struct InplaceAddOp<T>
where T: con,
{
    inner: Rc<InplaceAdd<T>>,
}

impl<T> GraphOperation for InplaceAdd<T>
where T: con,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("InplaceAdd_{}")?
        };
        let mut new_op = graph.new_operation("InplaceAdd", &op_name)?;
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct InplaceAdd<T>
where T: con,
{
    x: Edge<T>,
    i: Edge<i32>,
    v: Edge<T>,
    id_: usize,
}

impl<T> InplaceAdd<T>
where T: con,
{
    pub fn finish(self) -> InplaceAddOp<T> {
        InplaceAddOp::new(Rc::new(self))
    }

    pub fn new(x: Edge<T>, i: Edge<i32>, v: Edge<T>) -> Self {
        Self {
            x,
            i,
            v,
            id_: new_id(),
        }
    }
}

impl LogicalOrOp {
    pub fn new(inner: Rc<LogicalOr>) -> Self {
        Self{inner}
    }

    pub fn z(&self) -> Edge<bool> {
        Edge::<bool>::new(self.inner.clone(), 0)
    }
}

struct LogicalOrOp {
    inner: Rc<LogicalOr>,
}

impl GraphOperation for LogicalOr {
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("LogicalOr_{}")?
        };
        let mut new_op = graph.new_operation("LogicalOr", &op_name)?;
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct LogicalOr {
    x: Edge<bool>,
    y: Edge<bool>,
    id_: usize,
}

impl LogicalOr {
    pub fn finish(self) -> LogicalOrOp {
        LogicalOrOp::new(Rc::new(self))
    }

    pub fn new(x: Edge<bool>, y: Edge<bool>) -> Self {
        Self {
            x,
            y,
            id_: new_id(),
        }
    }
}

impl<T> IgammaGradAOp<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE,
{
    pub fn new(inner: Rc<IgammaGradA<T>>) -> Self {
        Self{inner}
    }

    pub fn z(&self) -> Edge<T> {
        Edge::<T>::new(self.inner.clone(), 0)
    }
}

struct IgammaGradAOp<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE,
{
    inner: Rc<IgammaGradA<T>>,
}

impl<T> GraphOperation for IgammaGradA<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("IgammaGradA_{}")?
        };
        let mut new_op = graph.new_operation("IgammaGradA", &op_name)?;
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct IgammaGradA<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE,
{
    a: Edge<T>,
    x: Edge<T>,
    id_: usize,
}

impl<T> IgammaGradA<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE,
{
    pub fn finish(self) -> IgammaGradAOp<T> {
        IgammaGradAOp::new(Rc::new(self))
    }

    pub fn new(a: Edge<T>, x: Edge<T>) -> Self {
        Self {
            a,
            x,
            id_: new_id(),
        }
    }
}

impl<dtype> TakeManySparseFromTensorsMapOp<dtype>
where dtype: con,
{
    pub fn new(inner: Rc<TakeManySparseFromTensorsMap<dtype>>) -> Self {
        Self{inner}
    }

    pub fn sparse_indices(&self) -> Edge<i64> {
        Edge::<i64>::new(self.inner.clone(), 0)
    }

    pub fn sparse_values(&self) -> Edge<dtype> {
        Edge::<dtype>::new(self.inner.clone(), 1)
    }

    pub fn sparse_shape(&self) -> Edge<i64> {
        Edge::<i64>::new(self.inner.clone(), 2)
    }
}

struct TakeManySparseFromTensorsMapOp<dtype>
where dtype: con,
{
    inner: Rc<TakeManySparseFromTensorsMap<dtype>>,
}

impl<dtype> GraphOperation for TakeManySparseFromTensorsMap<dtype>
where dtype: con,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("TakeManySparseFromTensorsMap_{}")?
        };
        let mut new_op = graph.new_operation("TakeManySparseFromTensorsMap", &op_name)?;
        {
            match self.container {
            }
            None => new_op.set_attr_value_proto("container", &vec![18_u8, 0_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_string("container", attr)})(&value),
        };
        {
            match self.shared_name {
            }
            None => new_op.set_attr_value_proto("shared_name", &vec![18_u8, 0_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_string("shared_name", attr)})(&value),
        };
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct TakeManySparseFromTensorsMap<dtype>
where dtype: con,
{
    sparse_handles: Edge<i64>,
    container: Option<String>,
    shared_name: Option<String>,
    id_: usize,
}

impl<dtype> TakeManySparseFromTensorsMap<dtype>
where dtype: con,
{
    pub fn container(&mut self, container: &str) -> &mut Self {
        self.container = Some(container.to_string());
        &self
    }

    pub fn shared_name(&mut self, shared_name: &str) -> &mut Self {
        self.shared_name = Some(shared_name.to_string());
        &self
    }

    pub fn finish(self) -> TakeManySparseFromTensorsMapOp<dtype> {
        TakeManySparseFromTensorsMapOp::new(Rc::new(self))
    }

    pub fn new(sparse_handles: Edge<i64>) -> Self {
        Self {
            sparse_handles,
            container: None,
            shared_name: None,
            id_: new_id(),
        }
    }
}

impl<dtype, value_T> ConstOp<dtype, value_T>
where value_T: AnyTensor,
      dtype: con,
{
    pub fn new(inner: Rc<Const<dtype, value_T>>) -> Self {
        Self{inner}
    }

    pub fn output(&self) -> Edge<dtype> {
        Edge::<dtype>::new(self.inner.clone(), 0)
    }
}

struct ConstOp<dtype, value_T>
where value_T: AnyTensor,
      dtype: con,
{
    inner: Rc<Const<dtype, value_T>>,
}

impl<dtype, value_T> GraphOperation for Const<dtype, value_T>
where value_T: AnyTensor,
      dtype: con,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("Const_{}")?
        };
        let mut new_op = graph.new_operation("Const", &op_name)?;
        {
            (|attr| {new_op.set_attr_tensor("value", attr)})(&self.value)
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct Const<dtype, value_T>
where value_T: AnyTensor,
      dtype: con,
{
    value: value_T,
    id_: usize,
}

impl<dtype, value_T> Const<dtype, value_T>
where value_T: AnyTensor,
      dtype: con,
{
    pub fn finish(self) -> ConstOp<dtype, value_T> {
        ConstOp::new(Rc::new(self))
    }

    pub fn new(value: value_T) -> Self {
        Self {
            value: value
            id_: new_id(),
        }
    }
}

impl EnqueueTPUEmbeddingSparseTensorBatchOp {
    pub fn new(inner: Rc<EnqueueTPUEmbeddingSparseTensorBatch>) -> Self {
        Self{inner}
    }
}

struct EnqueueTPUEmbeddingSparseTensorBatchOp {
    inner: Rc<EnqueueTPUEmbeddingSparseTensorBatch>,
}

impl GraphOperation for EnqueueTPUEmbeddingSparseTensorBatch {
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("EnqueueTPUEmbeddingSparseTensorBatch_{}")?
        };
        let mut new_op = graph.new_operation("EnqueueTPUEmbeddingSparseTensorBatch", &op_name)?;
        {
            (|attr| {new_op.set_attr_int("N", *attr)})(&self.N)
        }
        {
            match self.device_ordinal {
            }
            None => new_op.set_attr_value_proto("device_ordinal", &vec![24_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 1_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_int("device_ordinal", *attr)})(&value),
        };
        {
            match self.combiners {
            }
            None => new_op.set_attr_value_proto("combiners", &vec![10_u8, 0_u8,]);,
            Some(value) => (|attrs| {new_op.set_attr_string_list("combiners", attrs)})(&value),
        };
        {
            (|attrs| {new_op.set_attr_int_list("table_ids", attrs)})(&self.table_ids)
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct EnqueueTPUEmbeddingSparseTensorBatch {
    sample_indices: Edge<i32>,
    embedding_indices: Edge<i32>,
    aggregation_weights: Edge<f32>,
    mode_override: Edge<String>,
    N: i64,
    device_ordinal: Option<i64>,
    combiners: Option<Vec<String>>,
    table_ids: Vec<i64>,
    id_: usize,
}

impl EnqueueTPUEmbeddingSparseTensorBatch {
    pub fn device_ordinal(&mut self, device_ordinal: int) -> &mut Self {
        self.device_ordinal = Some(device_ordinal);
        &self
    }

    pub fn combiners(&mut self, combiners: &[String]) -> &mut Self {
        self.combiners = Some(combiners.to_vec());
        &self
    }

    pub fn finish(self) -> EnqueueTPUEmbeddingSparseTensorBatchOp {
        EnqueueTPUEmbeddingSparseTensorBatchOp::new(Rc::new(self))
    }

    pub fn new(sample_indices: Edge<i32>, embedding_indices: Edge<i32>, aggregation_weights: Edge<f32>, mode_override: Edge<String>, N: int, table_ids: &[int]) -> Self {
        Self {
            sample_indices,
            embedding_indices,
            aggregation_weights,
            mode_override,
            N: N
            device_ordinal: None,
            combiners: None,
            table_ids: table_ids.to_vec()
            id_: new_id(),
        }
    }
}

impl LoadTPUEmbeddingStochasticGradientDescentParametersOp {
    pub fn new(inner: Rc<LoadTPUEmbeddingStochasticGradientDescentParameters>) -> Self {
        Self{inner}
    }
}

struct LoadTPUEmbeddingStochasticGradientDescentParametersOp {
    inner: Rc<LoadTPUEmbeddingStochasticGradientDescentParameters>,
}

impl GraphOperation for LoadTPUEmbeddingStochasticGradientDescentParameters {
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("LoadTPUEmbeddingStochasticGradientDescentParameters_{}")?
        };
        let mut new_op = graph.new_operation("LoadTPUEmbeddingStochasticGradientDescentParameters", &op_name)?;
        {
            match self.table_id {
            }
            None => new_op.set_attr_value_proto("table_id", &vec![24_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 1_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_int("table_id", *attr)})(&value),
        };
        {
            match self.table_name {
            }
            None => new_op.set_attr_value_proto("table_name", &vec![18_u8, 0_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_string("table_name", attr)})(&value),
        };
        {
            (|attr| {new_op.set_attr_int("num_shards", *attr)})(&self.num_shards)
        }
        {
            (|attr| {new_op.set_attr_int("shard_id", *attr)})(&self.shard_id)
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct LoadTPUEmbeddingStochasticGradientDescentParameters {
    parameters: Edge<f32>,
    table_id: Option<i64>,
    table_name: Option<String>,
    num_shards: i64,
    shard_id: i64,
    id_: usize,
}

impl LoadTPUEmbeddingStochasticGradientDescentParameters {
    pub fn table_id(&mut self, table_id: int) -> &mut Self {
        self.table_id = Some(table_id);
        &self
    }

    pub fn table_name(&mut self, table_name: &str) -> &mut Self {
        self.table_name = Some(table_name.to_string());
        &self
    }

    pub fn finish(self) -> LoadTPUEmbeddingStochasticGradientDescentParametersOp {
        LoadTPUEmbeddingStochasticGradientDescentParametersOp::new(Rc::new(self))
    }

    pub fn new(parameters: Edge<f32>, num_shards: int, shard_id: int) -> Self {
        Self {
            parameters,
            table_id: None,
            table_name: None,
            num_shards: num_shards
            shard_id: shard_id
            id_: new_id(),
        }
    }
}

pub trait con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF for BFloat16 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF for OtherComplex<f32> {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF for OtherComplex<f64> {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF for f32 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF for f64 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF for i16 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF for i32 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF for i64 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF for i8 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF for u16 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF for u8 {
}

impl<T> MulOp<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF,
{
    pub fn new(inner: Rc<Mul<T>>) -> Self {
        Self{inner}
    }

    pub fn z(&self) -> Edge<T> {
        Edge::<T>::new(self.inner.clone(), 0)
    }
}

struct MulOp<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF,
{
    inner: Rc<Mul<T>>,
}

impl<T> GraphOperation for Mul<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("Mul_{}")?
        };
        let mut new_op = graph.new_operation("Mul", &op_name)?;
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct Mul<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF,
{
    x: Edge<T>,
    y: Edge<T>,
    id_: usize,
}

impl<T> Mul<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF,
{
    pub fn finish(self) -> MulOp<T> {
        MulOp::new(Rc::new(self))
    }

    pub fn new(x: Edge<T>, y: Edge<T>) -> Self {
        Self {
            x,
            y,
            id_: new_id(),
        }
    }
}

impl<T> BiasAddOp<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
{
    pub fn new(inner: Rc<BiasAdd<T>>) -> Self {
        Self{inner}
    }

    pub fn output(&self) -> Edge<T> {
        Edge::<T>::new(self.inner.clone(), 0)
    }
}

struct BiasAddOp<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
{
    inner: Rc<BiasAdd<T>>,
}

impl<T> GraphOperation for BiasAdd<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("BiasAdd_{}")?
        };
        let mut new_op = graph.new_operation("BiasAdd", &op_name)?;
        {
            match self.data_format {
            }
            None => new_op.set_attr_value_proto("data_format", &vec![18_u8, 4_u8, 78_u8, 72_u8, 87_u8, 67_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_string("data_format", attr)})(&value),
        };
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct BiasAdd<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
{
    value: Edge<T>,
    bias: Edge<T>,
    data_format: Option<String>,
    id_: usize,
}

impl<T> BiasAdd<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
{
    pub fn data_format(&mut self, data_format: &str) -> &mut Self {
        self.data_format = Some(data_format.to_string());
        &self
    }

    pub fn finish(self) -> BiasAddOp<T> {
        BiasAddOp::new(Rc::new(self))
    }

    pub fn new(value: Edge<T>, bias: Edge<T>) -> Self {
        Self {
            value,
            bias,
            data_format: None,
            id_: new_id(),
        }
    }
}

impl<T, Tdim> ExpandDimsOp<T, Tdim>
where T: con,
      Tdim: con_or_DT_INT32_or_DT_INT64,
{
    pub fn new(inner: Rc<ExpandDims<T, Tdim>>) -> Self {
        Self{inner}
    }

    pub fn output(&self) -> Edge<T> {
        Edge::<T>::new(self.inner.clone(), 0)
    }
}

struct ExpandDimsOp<T, Tdim>
where T: con,
      Tdim: con_or_DT_INT32_or_DT_INT64,
{
    inner: Rc<ExpandDims<T, Tdim>>,
}

impl<T, Tdim> GraphOperation for ExpandDims<T, Tdim>
where T: con,
      Tdim: con_or_DT_INT32_or_DT_INT64,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("ExpandDims_{}")?
        };
        let mut new_op = graph.new_operation("ExpandDims", &op_name)?;
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct ExpandDims<T, Tdim>
where T: con,
      Tdim: con_or_DT_INT32_or_DT_INT64,
{
    input: Edge<T>,
    dim: Edge<Tdim>,
    id_: usize,
}

impl<T, Tdim> ExpandDims<T, Tdim>
where T: con,
      Tdim: con_or_DT_INT32_or_DT_INT64,
{
    pub fn finish(self) -> ExpandDimsOp<T, Tdim> {
        ExpandDimsOp::new(Rc::new(self))
    }

    pub fn new(input: Edge<T>, dim: Edge<Tdim>) -> Self {
        Self {
            input,
            dim,
            id_: new_id(),
        }
    }
}

impl<T, Tmultiples> TileOp<T, Tmultiples>
where T: con,
      Tmultiples: con_or_DT_INT32_or_DT_INT64,
{
    pub fn new(inner: Rc<Tile<T, Tmultiples>>) -> Self {
        Self{inner}
    }

    pub fn output(&self) -> Edge<T> {
        Edge::<T>::new(self.inner.clone(), 0)
    }
}

struct TileOp<T, Tmultiples>
where T: con,
      Tmultiples: con_or_DT_INT32_or_DT_INT64,
{
    inner: Rc<Tile<T, Tmultiples>>,
}

impl<T, Tmultiples> GraphOperation for Tile<T, Tmultiples>
where T: con,
      Tmultiples: con_or_DT_INT32_or_DT_INT64,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("Tile_{}")?
        };
        let mut new_op = graph.new_operation("Tile", &op_name)?;
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct Tile<T, Tmultiples>
where T: con,
      Tmultiples: con_or_DT_INT32_or_DT_INT64,
{
    input: Edge<T>,
    multiples: Edge<Tmultiples>,
    id_: usize,
}

impl<T, Tmultiples> Tile<T, Tmultiples>
where T: con,
      Tmultiples: con_or_DT_INT32_or_DT_INT64,
{
    pub fn finish(self) -> TileOp<T, Tmultiples> {
        TileOp::new(Rc::new(self))
    }

    pub fn new(input: Edge<T>, multiples: Edge<Tmultiples>) -> Self {
        Self {
            input,
            multiples,
            id_: new_id(),
        }
    }
}

impl RecvTPUEmbeddingActivationsOp {
    pub fn new(inner: Rc<RecvTPUEmbeddingActivations>) -> Self {
        Self{inner}
    }

    pub fn outputs(&self) -> Edge<f32> {
        Edge::<f32>::new(self.inner.clone(), 0)
    }
}

struct RecvTPUEmbeddingActivationsOp {
    inner: Rc<RecvTPUEmbeddingActivations>,
}

impl GraphOperation for RecvTPUEmbeddingActivations {
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("RecvTPUEmbeddingActivations_{}")?
        };
        let mut new_op = graph.new_operation("RecvTPUEmbeddingActivations", &op_name)?;
        {
            (|attr| {new_op.set_attr_int("num_outputs", *attr)})(&self.num_outputs)
        }
        {
            (|attr| {new_op.set_attr_string("config", attr)})(&self.config)
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct RecvTPUEmbeddingActivations {
    num_outputs: i64,
    config: String,
    id_: usize,
}

impl RecvTPUEmbeddingActivations {
    pub fn finish(self) -> RecvTPUEmbeddingActivationsOp {
        RecvTPUEmbeddingActivationsOp::new(Rc::new(self))
    }

    pub fn new(num_outputs: int, config: &str) -> Self {
        Self {
            num_outputs: num_outputs
            config: config.to_string()
            id_: new_id(),
        }
    }
}

impl WorkerHeartbeatOp {
    pub fn new(inner: Rc<WorkerHeartbeat>) -> Self {
        Self{inner}
    }

    pub fn response(&self) -> Edge<String> {
        Edge::<String>::new(self.inner.clone(), 0)
    }
}

struct WorkerHeartbeatOp {
    inner: Rc<WorkerHeartbeat>,
}

impl GraphOperation for WorkerHeartbeat {
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("WorkerHeartbeat_{}")?
        };
        let mut new_op = graph.new_operation("WorkerHeartbeat", &op_name)?;
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct WorkerHeartbeat {
    request: Edge<String>,
    id_: usize,
}

impl WorkerHeartbeat {
    pub fn finish(self) -> WorkerHeartbeatOp {
        WorkerHeartbeatOp::new(Rc::new(self))
    }

    pub fn new(request: Edge<String>) -> Self {
        Self {
            request,
            id_: new_id(),
        }
    }
}

impl<T> SelectOp<T>
where T: con,
{
    pub fn new(inner: Rc<Select<T>>) -> Self {
        Self{inner}
    }

    pub fn output(&self) -> Edge<T> {
        Edge::<T>::new(self.inner.clone(), 0)
    }
}

struct SelectOp<T>
where T: con,
{
    inner: Rc<Select<T>>,
}

impl<T> GraphOperation for Select<T>
where T: con,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("Select_{}")?
        };
        let mut new_op = graph.new_operation("Select", &op_name)?;
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct Select<T>
where T: con,
{
    condition: Edge<bool>,
    t: Edge<T>,
    e: Edge<T>,
    id_: usize,
}

impl<T> Select<T>
where T: con,
{
    pub fn finish(self) -> SelectOp<T> {
        SelectOp::new(Rc::new(self))
    }

    pub fn new(condition: Edge<bool>, t: Edge<T>, e: Edge<T>) -> Self {
        Self {
            condition,
            t,
            e,
            id_: new_id(),
        }
    }
}

impl<T> RsqrtGradOp<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_COMPLEX64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF,
{
    pub fn new(inner: Rc<RsqrtGrad<T>>) -> Self {
        Self{inner}
    }

    pub fn z(&self) -> Edge<T> {
        Edge::<T>::new(self.inner.clone(), 0)
    }
}

struct RsqrtGradOp<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_COMPLEX64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF,
{
    inner: Rc<RsqrtGrad<T>>,
}

impl<T> GraphOperation for RsqrtGrad<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_COMPLEX64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("RsqrtGrad_{}")?
        };
        let mut new_op = graph.new_operation("RsqrtGrad", &op_name)?;
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct RsqrtGrad<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_COMPLEX64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF,
{
    y: Edge<T>,
    dy: Edge<T>,
    id_: usize,
}

impl<T> RsqrtGrad<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_COMPLEX64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF,
{
    pub fn finish(self) -> RsqrtGradOp<T> {
        RsqrtGradOp::new(Rc::new(self))
    }

    pub fn new(y: Edge<T>, dy: Edge<T>) -> Self {
        Self {
            y,
            dy,
            id_: new_id(),
        }
    }
}

impl<T, Tpaddings> PadV2Op<T, Tpaddings>
where T: con,
      Tpaddings: con_or_DT_INT32_or_DT_INT64,
{
    pub fn new(inner: Rc<PadV2<T, Tpaddings>>) -> Self {
        Self{inner}
    }

    pub fn output(&self) -> Edge<T> {
        Edge::<T>::new(self.inner.clone(), 0)
    }
}

struct PadV2Op<T, Tpaddings>
where T: con,
      Tpaddings: con_or_DT_INT32_or_DT_INT64,
{
    inner: Rc<PadV2<T, Tpaddings>>,
}

impl<T, Tpaddings> GraphOperation for PadV2<T, Tpaddings>
where T: con,
      Tpaddings: con_or_DT_INT32_or_DT_INT64,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("PadV2_{}")?
        };
        let mut new_op = graph.new_operation("PadV2", &op_name)?;
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct PadV2<T, Tpaddings>
where T: con,
      Tpaddings: con_or_DT_INT32_or_DT_INT64,
{
    input: Edge<T>,
    paddings: Edge<Tpaddings>,
    constant_values: Edge<T>,
    id_: usize,
}

impl<T, Tpaddings> PadV2<T, Tpaddings>
where T: con,
      Tpaddings: con_or_DT_INT32_or_DT_INT64,
{
    pub fn finish(self) -> PadV2Op<T, Tpaddings> {
        PadV2Op::new(Rc::new(self))
    }

    pub fn new(input: Edge<T>, paddings: Edge<Tpaddings>, constant_values: Edge<T>) -> Self {
        Self {
            input,
            paddings,
            constant_values,
            id_: new_id(),
        }
    }
}

impl LoadTPUEmbeddingProximalAdagradParametersOp {
    pub fn new(inner: Rc<LoadTPUEmbeddingProximalAdagradParameters>) -> Self {
        Self{inner}
    }
}

struct LoadTPUEmbeddingProximalAdagradParametersOp {
    inner: Rc<LoadTPUEmbeddingProximalAdagradParameters>,
}

impl GraphOperation for LoadTPUEmbeddingProximalAdagradParameters {
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("LoadTPUEmbeddingProximalAdagradParameters_{}")?
        };
        let mut new_op = graph.new_operation("LoadTPUEmbeddingProximalAdagradParameters", &op_name)?;
        {
            match self.table_id {
            }
            None => new_op.set_attr_value_proto("table_id", &vec![24_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 1_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_int("table_id", *attr)})(&value),
        };
        {
            match self.table_name {
            }
            None => new_op.set_attr_value_proto("table_name", &vec![18_u8, 0_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_string("table_name", attr)})(&value),
        };
        {
            (|attr| {new_op.set_attr_int("num_shards", *attr)})(&self.num_shards)
        }
        {
            (|attr| {new_op.set_attr_int("shard_id", *attr)})(&self.shard_id)
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct LoadTPUEmbeddingProximalAdagradParameters {
    parameters: Edge<f32>,
    accumulators: Edge<f32>,
    table_id: Option<i64>,
    table_name: Option<String>,
    num_shards: i64,
    shard_id: i64,
    id_: usize,
}

impl LoadTPUEmbeddingProximalAdagradParameters {
    pub fn table_id(&mut self, table_id: int) -> &mut Self {
        self.table_id = Some(table_id);
        &self
    }

    pub fn table_name(&mut self, table_name: &str) -> &mut Self {
        self.table_name = Some(table_name.to_string());
        &self
    }

    pub fn finish(self) -> LoadTPUEmbeddingProximalAdagradParametersOp {
        LoadTPUEmbeddingProximalAdagradParametersOp::new(Rc::new(self))
    }

    pub fn new(parameters: Edge<f32>, accumulators: Edge<f32>, num_shards: int, shard_id: int) -> Self {
        Self {
            parameters,
            accumulators,
            table_id: None,
            table_name: None,
            num_shards: num_shards
            shard_id: shard_id
            id_: new_id(),
        }
    }
}

impl<T, Tpaddings> MirrorPadGradOp<T, Tpaddings>
where T: con,
      Tpaddings: con_or_DT_INT32_or_DT_INT64,
{
    pub fn new(inner: Rc<MirrorPadGrad<T, Tpaddings>>) -> Self {
        Self{inner}
    }

    pub fn output(&self) -> Edge<T> {
        Edge::<T>::new(self.inner.clone(), 0)
    }
}

struct MirrorPadGradOp<T, Tpaddings>
where T: con,
      Tpaddings: con_or_DT_INT32_or_DT_INT64,
{
    inner: Rc<MirrorPadGrad<T, Tpaddings>>,
}

impl<T, Tpaddings> GraphOperation for MirrorPadGrad<T, Tpaddings>
where T: con,
      Tpaddings: con_or_DT_INT32_or_DT_INT64,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("MirrorPadGrad_{}")?
        };
        let mut new_op = graph.new_operation("MirrorPadGrad", &op_name)?;
        {
            (|attr| {new_op.set_attr_string("mode", attr)})(&self.mode)
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct MirrorPadGrad<T, Tpaddings>
where T: con,
      Tpaddings: con_or_DT_INT32_or_DT_INT64,
{
    input: Edge<T>,
    paddings: Edge<Tpaddings>,
    mode: String,
    id_: usize,
}

impl<T, Tpaddings> MirrorPadGrad<T, Tpaddings>
where T: con,
      Tpaddings: con_or_DT_INT32_or_DT_INT64,
{
    pub fn finish(self) -> MirrorPadGradOp<T, Tpaddings> {
        MirrorPadGradOp::new(Rc::new(self))
    }

    pub fn new(input: Edge<T>, paddings: Edge<Tpaddings>, mode: &str) -> Self {
        Self {
            input,
            paddings,
            mode: mode.to_string()
            id_: new_id(),
        }
    }
}

pub trait con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_STRING_or_DT_COMPLEX64_or_DT_INT64_or_DT_BOOL_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_STRING_or_DT_COMPLEX64_or_DT_INT64_or_DT_BOOL_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF for OtherComplex<f32> {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_STRING_or_DT_COMPLEX64_or_DT_INT64_or_DT_BOOL_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF for OtherComplex<f64> {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_STRING_or_DT_COMPLEX64_or_DT_INT64_or_DT_BOOL_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF for String {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_STRING_or_DT_COMPLEX64_or_DT_INT64_or_DT_BOOL_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF for bool {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_STRING_or_DT_COMPLEX64_or_DT_INT64_or_DT_BOOL_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF for f32 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_STRING_or_DT_COMPLEX64_or_DT_INT64_or_DT_BOOL_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF for f64 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_STRING_or_DT_COMPLEX64_or_DT_INT64_or_DT_BOOL_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF for i16 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_STRING_or_DT_COMPLEX64_or_DT_INT64_or_DT_BOOL_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF for i32 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_STRING_or_DT_COMPLEX64_or_DT_INT64_or_DT_BOOL_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF for i64 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_STRING_or_DT_COMPLEX64_or_DT_INT64_or_DT_BOOL_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF for i8 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_STRING_or_DT_COMPLEX64_or_DT_INT64_or_DT_BOOL_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF for u16 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_STRING_or_DT_COMPLEX64_or_DT_INT64_or_DT_BOOL_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF for u8 {
}

impl<T> ReverseOp<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_STRING_or_DT_COMPLEX64_or_DT_INT64_or_DT_BOOL_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF,
{
    pub fn new(inner: Rc<Reverse<T>>) -> Self {
        Self{inner}
    }

    pub fn output(&self) -> Edge<T> {
        Edge::<T>::new(self.inner.clone(), 0)
    }
}

struct ReverseOp<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_STRING_or_DT_COMPLEX64_or_DT_INT64_or_DT_BOOL_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF,
{
    inner: Rc<Reverse<T>>,
}

impl<T> GraphOperation for Reverse<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_STRING_or_DT_COMPLEX64_or_DT_INT64_or_DT_BOOL_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("Reverse_{}")?
        };
        let mut new_op = graph.new_operation("Reverse", &op_name)?;
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct Reverse<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_STRING_or_DT_COMPLEX64_or_DT_INT64_or_DT_BOOL_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF,
{
    tensor: Edge<T>,
    dims: Edge<bool>,
    id_: usize,
}

impl<T> Reverse<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_STRING_or_DT_COMPLEX64_or_DT_INT64_or_DT_BOOL_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF,
{
    pub fn finish(self) -> ReverseOp<T> {
        ReverseOp::new(Rc::new(self))
    }

    pub fn new(tensor: Edge<T>, dims: Edge<bool>) -> Self {
        Self {
            tensor,
            dims,
            id_: new_id(),
        }
    }
}

impl<T> LogSoftmaxOp<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
{
    pub fn new(inner: Rc<LogSoftmax<T>>) -> Self {
        Self{inner}
    }

    pub fn logsoftmax(&self) -> Edge<T> {
        Edge::<T>::new(self.inner.clone(), 0)
    }
}

struct LogSoftmaxOp<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
{
    inner: Rc<LogSoftmax<T>>,
}

impl<T> GraphOperation for LogSoftmax<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("LogSoftmax_{}")?
        };
        let mut new_op = graph.new_operation("LogSoftmax", &op_name)?;
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct LogSoftmax<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
{
    logits: Edge<T>,
    id_: usize,
}

impl<T> LogSoftmax<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
{
    pub fn finish(self) -> LogSoftmaxOp<T> {
        LogSoftmaxOp::new(Rc::new(self))
    }

    pub fn new(logits: Edge<T>) -> Self {
        Self {
            logits,
            id_: new_id(),
        }
    }
}

impl<T> InvertPermutationOp<T>
where T: con_or_DT_INT32_or_DT_INT64,
{
    pub fn new(inner: Rc<InvertPermutation<T>>) -> Self {
        Self{inner}
    }

    pub fn y(&self) -> Edge<T> {
        Edge::<T>::new(self.inner.clone(), 0)
    }
}

struct InvertPermutationOp<T>
where T: con_or_DT_INT32_or_DT_INT64,
{
    inner: Rc<InvertPermutation<T>>,
}

impl<T> GraphOperation for InvertPermutation<T>
where T: con_or_DT_INT32_or_DT_INT64,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("InvertPermutation_{}")?
        };
        let mut new_op = graph.new_operation("InvertPermutation", &op_name)?;
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct InvertPermutation<T>
where T: con_or_DT_INT32_or_DT_INT64,
{
    x: Edge<T>,
    id_: usize,
}

impl<T> InvertPermutation<T>
where T: con_or_DT_INT32_or_DT_INT64,
{
    pub fn finish(self) -> InvertPermutationOp<T> {
        InvertPermutationOp::new(Rc::new(self))
    }

    pub fn new(x: Edge<T>) -> Self {
        Self {
            x,
            id_: new_id(),
        }
    }
}

impl TensorArrayCloseOp {
    pub fn new(inner: Rc<TensorArrayClose>) -> Self {
        Self{inner}
    }
}

struct TensorArrayCloseOp {
    inner: Rc<TensorArrayClose>,
}

impl GraphOperation for TensorArrayClose {
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("TensorArrayClose_{}")?
        };
        let mut new_op = graph.new_operation("TensorArrayClose", &op_name)?;
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct TensorArrayClose {
    handle: Edge<String>,
    id_: usize,
}

impl TensorArrayClose {
    pub fn finish(self) -> TensorArrayCloseOp {
        TensorArrayCloseOp::new(Rc::new(self))
    }

    pub fn new(handle: Edge<String>) -> Self {
        Self {
            handle,
            id_: new_id(),
        }
    }
}

impl<T> Conv2DOp<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
{
    pub fn new(inner: Rc<Conv2D<T>>) -> Self {
        Self{inner}
    }

    pub fn output(&self) -> Edge<T> {
        Edge::<T>::new(self.inner.clone(), 0)
    }
}

struct Conv2DOp<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
{
    inner: Rc<Conv2D<T>>,
}

impl<T> GraphOperation for Conv2D<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("Conv2D_{}")?
        };
        let mut new_op = graph.new_operation("Conv2D", &op_name)?;
        {
            (|attrs| {new_op.set_attr_int_list("strides", attrs)})(&self.strides)
        }
        {
            match self.use_cudnn_on_gpu {
            }
            None => new_op.set_attr_value_proto("use_cudnn_on_gpu", &vec![40_u8, 1_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_bool("use_cudnn_on_gpu", *attr)})(&value),
        };
        {
            (|attr| {new_op.set_attr_string("padding", attr)})(&self.padding)
        }
        {
            match self.data_format {
            }
            None => new_op.set_attr_value_proto("data_format", &vec![18_u8, 4_u8, 78_u8, 72_u8, 87_u8, 67_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_string("data_format", attr)})(&value),
        };
        {
            match self.dilations {
            }
            None => new_op.set_attr_value_proto("dilations", &vec![10_u8, 0_u8, 26_u8, 4_u8,]);,
            Some(value) => (|attrs| {new_op.set_attr_int_list("dilations", attrs)})(&value),
        };
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct Conv2D<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
{
    input: Edge<T>,
    filter: Edge<T>,
    strides: Vec<i64>,
    use_cudnn_on_gpu: Option<bool>,
    padding: String,
    data_format: Option<String>,
    dilations: Option<Vec<i64>>,
    id_: usize,
}

impl<T> Conv2D<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
{
    pub fn use_cudnn_on_gpu(&mut self, use_cudnn_on_gpu: bool) -> &mut Self {
        self.use_cudnn_on_gpu = Some(use_cudnn_on_gpu);
        &self
    }

    pub fn data_format(&mut self, data_format: &str) -> &mut Self {
        self.data_format = Some(data_format.to_string());
        &self
    }

    pub fn dilations(&mut self, dilations: &[int]) -> &mut Self {
        self.dilations = Some(dilations.to_vec());
        &self
    }

    pub fn finish(self) -> Conv2DOp<T> {
        Conv2DOp::new(Rc::new(self))
    }

    pub fn new(input: Edge<T>, filter: Edge<T>, strides: &[int], padding: &str) -> Self {
        Self {
            input,
            filter,
            strides: strides.to_vec()
            use_cudnn_on_gpu: None,
            padding: padding.to_string()
            data_format: None,
            dilations: None,
            id_: new_id(),
        }
    }
}

impl<T, Tshape> ReshapeOp<T, Tshape>
where T: con,
      Tshape: con_or_DT_INT32_or_DT_INT64,
{
    pub fn new(inner: Rc<Reshape<T, Tshape>>) -> Self {
        Self{inner}
    }

    pub fn output(&self) -> Edge<T> {
        Edge::<T>::new(self.inner.clone(), 0)
    }
}

struct ReshapeOp<T, Tshape>
where T: con,
      Tshape: con_or_DT_INT32_or_DT_INT64,
{
    inner: Rc<Reshape<T, Tshape>>,
}

impl<T, Tshape> GraphOperation for Reshape<T, Tshape>
where T: con,
      Tshape: con_or_DT_INT32_or_DT_INT64,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("Reshape_{}")?
        };
        let mut new_op = graph.new_operation("Reshape", &op_name)?;
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct Reshape<T, Tshape>
where T: con,
      Tshape: con_or_DT_INT32_or_DT_INT64,
{
    tensor: Edge<T>,
    shape: Edge<Tshape>,
    id_: usize,
}

impl<T, Tshape> Reshape<T, Tshape>
where T: con,
      Tshape: con_or_DT_INT32_or_DT_INT64,
{
    pub fn finish(self) -> ReshapeOp<T, Tshape> {
        ReshapeOp::new(Rc::new(self))
    }

    pub fn new(tensor: Edge<T>, shape: Edge<Tshape>) -> Self {
        Self {
            tensor,
            shape,
            id_: new_id(),
        }
    }
}

impl<T> NonMaxSuppressionV2Op<T>
where T: con_or_DT_FLOAT_or_DT_HALF,
{
    pub fn new(inner: Rc<NonMaxSuppressionV2<T>>) -> Self {
        Self{inner}
    }

    pub fn selected_indices(&self) -> Edge<i32> {
        Edge::<i32>::new(self.inner.clone(), 0)
    }
}

struct NonMaxSuppressionV2Op<T>
where T: con_or_DT_FLOAT_or_DT_HALF,
{
    inner: Rc<NonMaxSuppressionV2<T>>,
}

impl<T> GraphOperation for NonMaxSuppressionV2<T>
where T: con_or_DT_FLOAT_or_DT_HALF,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("NonMaxSuppressionV2_{}")?
        };
        let mut new_op = graph.new_operation("NonMaxSuppressionV2", &op_name)?;
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct NonMaxSuppressionV2<T>
where T: con_or_DT_FLOAT_or_DT_HALF,
{
    boxes: Edge<T>,
    scores: Edge<T>,
    max_output_size: Edge<i32>,
    iou_threshold: Edge<f32>,
    id_: usize,
}

impl<T> NonMaxSuppressionV2<T>
where T: con_or_DT_FLOAT_or_DT_HALF,
{
    pub fn finish(self) -> NonMaxSuppressionV2Op<T> {
        NonMaxSuppressionV2Op::new(Rc::new(self))
    }

    pub fn new(boxes: Edge<T>, scores: Edge<T>, max_output_size: Edge<i32>, iou_threshold: Edge<f32>) -> Self {
        Self {
            boxes,
            scores,
            max_output_size,
            iou_threshold,
            id_: new_id(),
        }
    }
}

impl ReduceJoinOp {
    pub fn new(inner: Rc<ReduceJoin>) -> Self {
        Self{inner}
    }

    pub fn output(&self) -> Edge<String> {
        Edge::<String>::new(self.inner.clone(), 0)
    }
}

struct ReduceJoinOp {
    inner: Rc<ReduceJoin>,
}

impl GraphOperation for ReduceJoin {
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("ReduceJoin_{}")?
        };
        let mut new_op = graph.new_operation("ReduceJoin", &op_name)?;
        {
            match self.keep_dims {
            }
            None => new_op.set_attr_value_proto("keep_dims", &vec![40_u8, 0_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_bool("keep_dims", *attr)})(&value),
        };
        {
            match self.separator {
            }
            None => new_op.set_attr_value_proto("separator", &vec![18_u8, 0_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_string("separator", attr)})(&value),
        };
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct ReduceJoin {
    inputs: Edge<String>,
    reduction_indices: Edge<i32>,
    keep_dims: Option<bool>,
    separator: Option<String>,
    id_: usize,
}

impl ReduceJoin {
    pub fn keep_dims(&mut self, keep_dims: bool) -> &mut Self {
        self.keep_dims = Some(keep_dims);
        &self
    }

    pub fn separator(&mut self, separator: &str) -> &mut Self {
        self.separator = Some(separator.to_string());
        &self
    }

    pub fn finish(self) -> ReduceJoinOp {
        ReduceJoinOp::new(Rc::new(self))
    }

    pub fn new(inputs: Edge<String>, reduction_indices: Edge<i32>) -> Self {
        Self {
            inputs,
            reduction_indices,
            keep_dims: None,
            separator: None,
            id_: new_id(),
        }
    }
}

impl ReaderRestoreStateOp {
    pub fn new(inner: Rc<ReaderRestoreState>) -> Self {
        Self{inner}
    }
}

struct ReaderRestoreStateOp {
    inner: Rc<ReaderRestoreState>,
}

impl GraphOperation for ReaderRestoreState {
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("ReaderRestoreState_{}")?
        };
        let mut new_op = graph.new_operation("ReaderRestoreState", &op_name)?;
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct ReaderRestoreState {
    reader_handle: Edge<String>,
    state: Edge<String>,
    id_: usize,
}

impl ReaderRestoreState {
    pub fn finish(self) -> ReaderRestoreStateOp {
        ReaderRestoreStateOp::new(Rc::new(self))
    }

    pub fn new(reader_handle: Edge<String>, state: Edge<String>) -> Self {
        Self {
            reader_handle,
            state,
            id_: new_id(),
        }
    }
}

impl<T, Tlen> ReverseSequenceOp<T, Tlen>
where T: con,
      Tlen: con_or_DT_INT32_or_DT_INT64,
{
    pub fn new(inner: Rc<ReverseSequence<T, Tlen>>) -> Self {
        Self{inner}
    }

    pub fn output(&self) -> Edge<T> {
        Edge::<T>::new(self.inner.clone(), 0)
    }
}

struct ReverseSequenceOp<T, Tlen>
where T: con,
      Tlen: con_or_DT_INT32_or_DT_INT64,
{
    inner: Rc<ReverseSequence<T, Tlen>>,
}

impl<T, Tlen> GraphOperation for ReverseSequence<T, Tlen>
where T: con,
      Tlen: con_or_DT_INT32_or_DT_INT64,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("ReverseSequence_{}")?
        };
        let mut new_op = graph.new_operation("ReverseSequence", &op_name)?;
        {
            (|attr| {new_op.set_attr_int("seq_dim", *attr)})(&self.seq_dim)
        }
        {
            match self.batch_dim {
            }
            None => new_op.set_attr_value_proto("batch_dim", &vec![24_u8, 0_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_int("batch_dim", *attr)})(&value),
        };
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct ReverseSequence<T, Tlen>
where T: con,
      Tlen: con_or_DT_INT32_or_DT_INT64,
{
    input: Edge<T>,
    seq_lengths: Edge<Tlen>,
    seq_dim: i64,
    batch_dim: Option<i64>,
    id_: usize,
}

impl<T, Tlen> ReverseSequence<T, Tlen>
where T: con,
      Tlen: con_or_DT_INT32_or_DT_INT64,
{
    pub fn batch_dim(&mut self, batch_dim: int) -> &mut Self {
        self.batch_dim = Some(batch_dim);
        &self
    }

    pub fn finish(self) -> ReverseSequenceOp<T, Tlen> {
        ReverseSequenceOp::new(Rc::new(self))
    }

    pub fn new(input: Edge<T>, seq_lengths: Edge<Tlen>, seq_dim: int) -> Self {
        Self {
            input,
            seq_lengths,
            seq_dim: seq_dim
            batch_dim: None,
            id_: new_id(),
        }
    }
}

impl<T> XlaSendOp<T>
where T: con,
{
    pub fn new(inner: Rc<XlaSend<T>>) -> Self {
        Self{inner}
    }
}

struct XlaSendOp<T>
where T: con,
{
    inner: Rc<XlaSend<T>>,
}

impl<T> GraphOperation for XlaSend<T>
where T: con,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("XlaSend_{}")?
        };
        let mut new_op = graph.new_operation("XlaSend", &op_name)?;
        {
            (|attr| {new_op.set_attr_string("tensor_name", attr)})(&self.tensor_name)
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct XlaSend<T>
where T: con,
{
    tensor: Edge<T>,
    tensor_name: String,
    id_: usize,
}

impl<T> XlaSend<T>
where T: con,
{
    pub fn finish(self) -> XlaSendOp<T> {
        XlaSendOp::new(Rc::new(self))
    }

    pub fn new(tensor: Edge<T>, tensor_name: &str) -> Self {
        Self {
            tensor,
            tensor_name: tensor_name.to_string()
            id_: new_id(),
        }
    }
}

impl<T> ApplyAdagradDAOp<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
{
    pub fn new(inner: Rc<ApplyAdagradDA<T>>) -> Self {
        Self{inner}
    }

    pub fn out(&self) -> Edge<T> {
        Edge::<T>::new(self.inner.clone(), 0)
    }
}

struct ApplyAdagradDAOp<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
{
    inner: Rc<ApplyAdagradDA<T>>,
}

impl<T> GraphOperation for ApplyAdagradDA<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("ApplyAdagradDA_{}")?
        };
        let mut new_op = graph.new_operation("ApplyAdagradDA", &op_name)?;
        {
            match self.use_locking {
            }
            None => new_op.set_attr_value_proto("use_locking", &vec![40_u8, 0_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_bool("use_locking", *attr)})(&value),
        };
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct ApplyAdagradDA<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
{
    var: Edge<T>,
    gradient_accumulator: Edge<T>,
    gradient_squared_accumulator: Edge<T>,
    grad: Edge<T>,
    lr: Edge<T>,
    l1: Edge<T>,
    l2: Edge<T>,
    global_step: Edge<i64>,
    use_locking: Option<bool>,
    id_: usize,
}

impl<T> ApplyAdagradDA<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
{
    pub fn use_locking(&mut self, use_locking: bool) -> &mut Self {
        self.use_locking = Some(use_locking);
        &self
    }

    pub fn finish(self) -> ApplyAdagradDAOp<T> {
        ApplyAdagradDAOp::new(Rc::new(self))
    }

    pub fn new(var: Edge<T>, gradient_accumulator: Edge<T>, gradient_squared_accumulator: Edge<T>, grad: Edge<T>, lr: Edge<T>, l1: Edge<T>, l2: Edge<T>, global_step: Edge<i64>) -> Self {
        Self {
            var,
            gradient_accumulator,
            gradient_squared_accumulator,
            grad,
            lr,
            l1,
            l2,
            global_step,
            use_locking: None,
            id_: new_id(),
        }
    }
}

impl<T> PackOp<T>
where T: con,
{
    pub fn new(inner: Rc<Pack<T>>) -> Self {
        Self{inner}
    }

    pub fn output(&self) -> Edge<T> {
        Edge::<T>::new(self.inner.clone(), 0)
    }
}

struct PackOp<T>
where T: con,
{
    inner: Rc<Pack<T>>,
}

impl<T> GraphOperation for Pack<T>
where T: con,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("Pack_{}")?
        };
        let mut new_op = graph.new_operation("Pack", &op_name)?;
        {
            (|attr| {new_op.set_attr_int("N", *attr)})(&self.N)
        }
        {
            match self.axis {
            }
            None => new_op.set_attr_value_proto("axis", &vec![24_u8, 0_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_int("axis", *attr)})(&value),
        };
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct Pack<T>
where T: con,
{
    values: Edge<T>,
    N: i64,
    axis: Option<i64>,
    id_: usize,
}

impl<T> Pack<T>
where T: con,
{
    pub fn axis(&mut self, axis: int) -> &mut Self {
        self.axis = Some(axis);
        &self
    }

    pub fn finish(self) -> PackOp<T> {
        PackOp::new(Rc::new(self))
    }

    pub fn new(values: Edge<T>, N: int) -> Self {
        Self {
            values,
            N: N
            axis: None,
            id_: new_id(),
        }
    }
}

impl SparseReshapeOp {
    pub fn new(inner: Rc<SparseReshape>) -> Self {
        Self{inner}
    }

    pub fn output_indices(&self) -> Edge<i64> {
        Edge::<i64>::new(self.inner.clone(), 0)
    }

    pub fn output_shape(&self) -> Edge<i64> {
        Edge::<i64>::new(self.inner.clone(), 1)
    }
}

struct SparseReshapeOp {
    inner: Rc<SparseReshape>,
}

impl GraphOperation for SparseReshape {
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("SparseReshape_{}")?
        };
        let mut new_op = graph.new_operation("SparseReshape", &op_name)?;
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct SparseReshape {
    input_indices: Edge<i64>,
    input_shape: Edge<i64>,
    new_shape: Edge<i64>,
    id_: usize,
}

impl SparseReshape {
    pub fn finish(self) -> SparseReshapeOp {
        SparseReshapeOp::new(Rc::new(self))
    }

    pub fn new(input_indices: Edge<i64>, input_shape: Edge<i64>, new_shape: Edge<i64>) -> Self {
        Self {
            input_indices,
            input_shape,
            new_shape,
            id_: new_id(),
        }
    }
}

impl<T> TensorArraySplitV2Op<T>
where T: con,
{
    pub fn new(inner: Rc<TensorArraySplitV2<T>>) -> Self {
        Self{inner}
    }

    pub fn flow_out(&self) -> Edge<f32> {
        Edge::<f32>::new(self.inner.clone(), 0)
    }
}

struct TensorArraySplitV2Op<T>
where T: con,
{
    inner: Rc<TensorArraySplitV2<T>>,
}

impl<T> GraphOperation for TensorArraySplitV2<T>
where T: con,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("TensorArraySplitV2_{}")?
        };
        let mut new_op = graph.new_operation("TensorArraySplitV2", &op_name)?;
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct TensorArraySplitV2<T>
where T: con,
{
    handle: Edge<String>,
    value: Edge<T>,
    lengths: Edge<i64>,
    flow_in: Edge<f32>,
    id_: usize,
}

impl<T> TensorArraySplitV2<T>
where T: con,
{
    pub fn finish(self) -> TensorArraySplitV2Op<T> {
        TensorArraySplitV2Op::new(Rc::new(self))
    }

    pub fn new(handle: Edge<String>, value: Edge<T>, lengths: Edge<i64>, flow_in: Edge<f32>) -> Self {
        Self {
            handle,
            value,
            lengths,
            flow_in,
            id_: new_id(),
        }
    }
}

impl<T> AssignAddOp<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
{
    pub fn new(inner: Rc<AssignAdd<T>>) -> Self {
        Self{inner}
    }

    pub fn output_ref(&self) -> Edge<T> {
        Edge::<T>::new(self.inner.clone(), 0)
    }
}

struct AssignAddOp<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
{
    inner: Rc<AssignAdd<T>>,
}

impl<T> GraphOperation for AssignAdd<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("AssignAdd_{}")?
        };
        let mut new_op = graph.new_operation("AssignAdd", &op_name)?;
        {
            match self.use_locking {
            }
            None => new_op.set_attr_value_proto("use_locking", &vec![40_u8, 0_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_bool("use_locking", *attr)})(&value),
        };
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct AssignAdd<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
{
    ref_: Edge<T>,
    value: Edge<T>,
    use_locking: Option<bool>,
    id_: usize,
}

impl<T> AssignAdd<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
{
    pub fn use_locking(&mut self, use_locking: bool) -> &mut Self {
        self.use_locking = Some(use_locking);
        &self
    }

    pub fn finish(self) -> AssignAddOp<T> {
        AssignAddOp::new(Rc::new(self))
    }

    pub fn new(ref_: Edge<T>, value: Edge<T>) -> Self {
        Self {
            ref_,
            value,
            use_locking: None,
            id_: new_id(),
        }
    }
}

impl LoadTPUEmbeddingCenteredRMSPropParametersOp {
    pub fn new(inner: Rc<LoadTPUEmbeddingCenteredRMSPropParameters>) -> Self {
        Self{inner}
    }
}

struct LoadTPUEmbeddingCenteredRMSPropParametersOp {
    inner: Rc<LoadTPUEmbeddingCenteredRMSPropParameters>,
}

impl GraphOperation for LoadTPUEmbeddingCenteredRMSPropParameters {
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("LoadTPUEmbeddingCenteredRMSPropParameters_{}")?
        };
        let mut new_op = graph.new_operation("LoadTPUEmbeddingCenteredRMSPropParameters", &op_name)?;
        {
            match self.table_id {
            }
            None => new_op.set_attr_value_proto("table_id", &vec![24_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 1_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_int("table_id", *attr)})(&value),
        };
        {
            match self.table_name {
            }
            None => new_op.set_attr_value_proto("table_name", &vec![18_u8, 0_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_string("table_name", attr)})(&value),
        };
        {
            (|attr| {new_op.set_attr_int("num_shards", *attr)})(&self.num_shards)
        }
        {
            (|attr| {new_op.set_attr_int("shard_id", *attr)})(&self.shard_id)
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct LoadTPUEmbeddingCenteredRMSPropParameters {
    parameters: Edge<f32>,
    ms: Edge<f32>,
    mom: Edge<f32>,
    mg: Edge<f32>,
    table_id: Option<i64>,
    table_name: Option<String>,
    num_shards: i64,
    shard_id: i64,
    id_: usize,
}

impl LoadTPUEmbeddingCenteredRMSPropParameters {
    pub fn table_id(&mut self, table_id: int) -> &mut Self {
        self.table_id = Some(table_id);
        &self
    }

    pub fn table_name(&mut self, table_name: &str) -> &mut Self {
        self.table_name = Some(table_name.to_string());
        &self
    }

    pub fn finish(self) -> LoadTPUEmbeddingCenteredRMSPropParametersOp {
        LoadTPUEmbeddingCenteredRMSPropParametersOp::new(Rc::new(self))
    }

    pub fn new(parameters: Edge<f32>, ms: Edge<f32>, mom: Edge<f32>, mg: Edge<f32>, num_shards: int, shard_id: int) -> Self {
        Self {
            parameters,
            ms,
            mom,
            mg,
            table_id: None,
            table_name: None,
            num_shards: num_shards
            shard_id: shard_id
            id_: new_id(),
        }
    }
}

impl RetrieveTPUEmbeddingRMSPropParametersOp {
    pub fn new(inner: Rc<RetrieveTPUEmbeddingRMSPropParameters>) -> Self {
        Self{inner}
    }

    pub fn parameters(&self) -> Edge<f32> {
        Edge::<f32>::new(self.inner.clone(), 0)
    }

    pub fn ms(&self) -> Edge<f32> {
        Edge::<f32>::new(self.inner.clone(), 1)
    }

    pub fn mom(&self) -> Edge<f32> {
        Edge::<f32>::new(self.inner.clone(), 2)
    }
}

struct RetrieveTPUEmbeddingRMSPropParametersOp {
    inner: Rc<RetrieveTPUEmbeddingRMSPropParameters>,
}

impl GraphOperation for RetrieveTPUEmbeddingRMSPropParameters {
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("RetrieveTPUEmbeddingRMSPropParameters_{}")?
        };
        let mut new_op = graph.new_operation("RetrieveTPUEmbeddingRMSPropParameters", &op_name)?;
        {
            match self.table_id {
            }
            None => new_op.set_attr_value_proto("table_id", &vec![24_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 1_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_int("table_id", *attr)})(&value),
        };
        {
            match self.table_name {
            }
            None => new_op.set_attr_value_proto("table_name", &vec![18_u8, 0_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_string("table_name", attr)})(&value),
        };
        {
            (|attr| {new_op.set_attr_int("num_shards", *attr)})(&self.num_shards)
        }
        {
            (|attr| {new_op.set_attr_int("shard_id", *attr)})(&self.shard_id)
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct RetrieveTPUEmbeddingRMSPropParameters {
    table_id: Option<i64>,
    table_name: Option<String>,
    num_shards: i64,
    shard_id: i64,
    id_: usize,
}

impl RetrieveTPUEmbeddingRMSPropParameters {
    pub fn table_id(&mut self, table_id: int) -> &mut Self {
        self.table_id = Some(table_id);
        &self
    }

    pub fn table_name(&mut self, table_name: &str) -> &mut Self {
        self.table_name = Some(table_name.to_string());
        &self
    }

    pub fn finish(self) -> RetrieveTPUEmbeddingRMSPropParametersOp {
        RetrieveTPUEmbeddingRMSPropParametersOp::new(Rc::new(self))
    }

    pub fn new(num_shards: int, shard_id: int) -> Self {
        Self {
            table_id: None,
            table_name: None,
            num_shards: num_shards
            shard_id: shard_id
            id_: new_id(),
        }
    }
}

impl<dtype> VariableOp<dtype>
where dtype: con,
{
    pub fn new(inner: Rc<Variable<dtype>>) -> Self {
        Self{inner}
    }

    pub fn ref_(&self) -> Edge<dtype> {
        Edge::<dtype>::new(self.inner.clone(), 0)
    }
}

struct VariableOp<dtype>
where dtype: con,
{
    inner: Rc<Variable<dtype>>,
}

impl<dtype> GraphOperation for Variable<dtype>
where dtype: con,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("Variable_{}")?
        };
        let mut new_op = graph.new_operation("Variable", &op_name)?;
        {
            (|attr| {new_op.set_attr_shape("shape", attr)})(&self.shape)
        }
        {
            match self.container {
            }
            None => new_op.set_attr_value_proto("container", &vec![18_u8, 0_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_string("container", attr)})(&value),
        };
        {
            match self.shared_name {
            }
            None => new_op.set_attr_value_proto("shared_name", &vec![18_u8, 0_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_string("shared_name", attr)})(&value),
        };
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct Variable<dtype>
where dtype: con,
{
    shape: Shape,
    container: Option<String>,
    shared_name: Option<String>,
    id_: usize,
}

impl<dtype> Variable<dtype>
where dtype: con,
{
    pub fn container(&mut self, container: &str) -> &mut Self {
        self.container = Some(container.to_string());
        &self
    }

    pub fn shared_name(&mut self, shared_name: &str) -> &mut Self {
        self.shared_name = Some(shared_name.to_string());
        &self
    }

    pub fn finish(self) -> VariableOp<dtype> {
        VariableOp::new(Rc::new(self))
    }

    pub fn new(shape: &Shape) -> Self {
        Self {
            shape: shape.clone()
            container: None,
            shared_name: None,
            id_: new_id(),
        }
    }
}

impl LoadTPUEmbeddingADAMParametersGradAccumDebugOp {
    pub fn new(inner: Rc<LoadTPUEmbeddingADAMParametersGradAccumDebug>) -> Self {
        Self{inner}
    }
}

struct LoadTPUEmbeddingADAMParametersGradAccumDebugOp {
    inner: Rc<LoadTPUEmbeddingADAMParametersGradAccumDebug>,
}

impl GraphOperation for LoadTPUEmbeddingADAMParametersGradAccumDebug {
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("LoadTPUEmbeddingADAMParametersGradAccumDebug_{}")?
        };
        let mut new_op = graph.new_operation("LoadTPUEmbeddingADAMParametersGradAccumDebug", &op_name)?;
        {
            match self.table_id {
            }
            None => new_op.set_attr_value_proto("table_id", &vec![24_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 1_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_int("table_id", *attr)})(&value),
        };
        {
            match self.table_name {
            }
            None => new_op.set_attr_value_proto("table_name", &vec![18_u8, 0_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_string("table_name", attr)})(&value),
        };
        {
            (|attr| {new_op.set_attr_int("num_shards", *attr)})(&self.num_shards)
        }
        {
            (|attr| {new_op.set_attr_int("shard_id", *attr)})(&self.shard_id)
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct LoadTPUEmbeddingADAMParametersGradAccumDebug {
    parameters: Edge<f32>,
    momenta: Edge<f32>,
    velocities: Edge<f32>,
    gradient_accumulators: Edge<f32>,
    table_id: Option<i64>,
    table_name: Option<String>,
    num_shards: i64,
    shard_id: i64,
    id_: usize,
}

impl LoadTPUEmbeddingADAMParametersGradAccumDebug {
    pub fn table_id(&mut self, table_id: int) -> &mut Self {
        self.table_id = Some(table_id);
        &self
    }

    pub fn table_name(&mut self, table_name: &str) -> &mut Self {
        self.table_name = Some(table_name.to_string());
        &self
    }

    pub fn finish(self) -> LoadTPUEmbeddingADAMParametersGradAccumDebugOp {
        LoadTPUEmbeddingADAMParametersGradAccumDebugOp::new(Rc::new(self))
    }

    pub fn new(parameters: Edge<f32>, momenta: Edge<f32>, velocities: Edge<f32>, gradient_accumulators: Edge<f32>, num_shards: int, shard_id: int) -> Self {
        Self {
            parameters,
            momenta,
            velocities,
            gradient_accumulators,
            table_id: None,
            table_name: None,
            num_shards: num_shards
            shard_id: shard_id
            id_: new_id(),
        }
    }
}

impl<T> AddManySparseToTensorsMapOp<T>
where T: con,
{
    pub fn new(inner: Rc<AddManySparseToTensorsMap<T>>) -> Self {
        Self{inner}
    }

    pub fn sparse_handles(&self) -> Edge<i64> {
        Edge::<i64>::new(self.inner.clone(), 0)
    }
}

struct AddManySparseToTensorsMapOp<T>
where T: con,
{
    inner: Rc<AddManySparseToTensorsMap<T>>,
}

impl<T> GraphOperation for AddManySparseToTensorsMap<T>
where T: con,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("AddManySparseToTensorsMap_{}")?
        };
        let mut new_op = graph.new_operation("AddManySparseToTensorsMap", &op_name)?;
        {
            match self.container {
            }
            None => new_op.set_attr_value_proto("container", &vec![18_u8, 0_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_string("container", attr)})(&value),
        };
        {
            match self.shared_name {
            }
            None => new_op.set_attr_value_proto("shared_name", &vec![18_u8, 0_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_string("shared_name", attr)})(&value),
        };
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct AddManySparseToTensorsMap<T>
where T: con,
{
    sparse_indices: Edge<i64>,
    sparse_values: Edge<T>,
    sparse_shape: Edge<i64>,
    container: Option<String>,
    shared_name: Option<String>,
    id_: usize,
}

impl<T> AddManySparseToTensorsMap<T>
where T: con,
{
    pub fn container(&mut self, container: &str) -> &mut Self {
        self.container = Some(container.to_string());
        &self
    }

    pub fn shared_name(&mut self, shared_name: &str) -> &mut Self {
        self.shared_name = Some(shared_name.to_string());
        &self
    }

    pub fn finish(self) -> AddManySparseToTensorsMapOp<T> {
        AddManySparseToTensorsMapOp::new(Rc::new(self))
    }

    pub fn new(sparse_indices: Edge<i64>, sparse_values: Edge<T>, sparse_shape: Edge<i64>) -> Self {
        Self {
            sparse_indices,
            sparse_values,
            sparse_shape,
            container: None,
            shared_name: None,
            id_: new_id(),
        }
    }
}

impl<Tin, Tout> LookupTableImportOp<Tin, Tout>
where Tin: con,
      Tout: con,
{
    pub fn new(inner: Rc<LookupTableImport<Tin, Tout>>) -> Self {
        Self{inner}
    }
}

struct LookupTableImportOp<Tin, Tout>
where Tin: con,
      Tout: con,
{
    inner: Rc<LookupTableImport<Tin, Tout>>,
}

impl<Tin, Tout> GraphOperation for LookupTableImport<Tin, Tout>
where Tin: con,
      Tout: con,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("LookupTableImport_{}")?
        };
        let mut new_op = graph.new_operation("LookupTableImport", &op_name)?;
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct LookupTableImport<Tin, Tout>
where Tin: con,
      Tout: con,
{
    table_handle: Edge<String>,
    keys: Edge<Tin>,
    values: Edge<Tout>,
    id_: usize,
}

impl<Tin, Tout> LookupTableImport<Tin, Tout>
where Tin: con,
      Tout: con,
{
    pub fn finish(self) -> LookupTableImportOp<Tin, Tout> {
        LookupTableImportOp::new(Rc::new(self))
    }

    pub fn new(table_handle: Edge<String>, keys: Edge<Tin>, values: Edge<Tout>) -> Self {
        Self {
            table_handle,
            keys,
            values,
            id_: new_id(),
        }
    }
}

impl LoadTPUEmbeddingAdadeltaParametersOp {
    pub fn new(inner: Rc<LoadTPUEmbeddingAdadeltaParameters>) -> Self {
        Self{inner}
    }
}

struct LoadTPUEmbeddingAdadeltaParametersOp {
    inner: Rc<LoadTPUEmbeddingAdadeltaParameters>,
}

impl GraphOperation for LoadTPUEmbeddingAdadeltaParameters {
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("LoadTPUEmbeddingAdadeltaParameters_{}")?
        };
        let mut new_op = graph.new_operation("LoadTPUEmbeddingAdadeltaParameters", &op_name)?;
        {
            match self.table_id {
            }
            None => new_op.set_attr_value_proto("table_id", &vec![24_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 1_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_int("table_id", *attr)})(&value),
        };
        {
            match self.table_name {
            }
            None => new_op.set_attr_value_proto("table_name", &vec![18_u8, 0_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_string("table_name", attr)})(&value),
        };
        {
            (|attr| {new_op.set_attr_int("num_shards", *attr)})(&self.num_shards)
        }
        {
            (|attr| {new_op.set_attr_int("shard_id", *attr)})(&self.shard_id)
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct LoadTPUEmbeddingAdadeltaParameters {
    parameters: Edge<f32>,
    accumulators: Edge<f32>,
    updates: Edge<f32>,
    table_id: Option<i64>,
    table_name: Option<String>,
    num_shards: i64,
    shard_id: i64,
    id_: usize,
}

impl LoadTPUEmbeddingAdadeltaParameters {
    pub fn table_id(&mut self, table_id: int) -> &mut Self {
        self.table_id = Some(table_id);
        &self
    }

    pub fn table_name(&mut self, table_name: &str) -> &mut Self {
        self.table_name = Some(table_name.to_string());
        &self
    }

    pub fn finish(self) -> LoadTPUEmbeddingAdadeltaParametersOp {
        LoadTPUEmbeddingAdadeltaParametersOp::new(Rc::new(self))
    }

    pub fn new(parameters: Edge<f32>, accumulators: Edge<f32>, updates: Edge<f32>, num_shards: int, shard_id: int) -> Self {
        Self {
            parameters,
            accumulators,
            updates,
            table_id: None,
            table_name: None,
            num_shards: num_shards
            shard_id: shard_id
            id_: new_id(),
        }
    }
}

impl TPUCompilationResultOp {
    pub fn new(inner: Rc<TPUCompilationResult>) -> Self {
        Self{inner}
    }

    pub fn output(&self) -> Edge<String> {
        Edge::<String>::new(self.inner.clone(), 0)
    }
}

struct TPUCompilationResultOp {
    inner: Rc<TPUCompilationResult>,
}

impl GraphOperation for TPUCompilationResult {
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("TPUCompilationResult_{}")?
        };
        let mut new_op = graph.new_operation("TPUCompilationResult", &op_name)?;
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct TPUCompilationResult {
    id_: usize,
}

impl TPUCompilationResult {
    pub fn finish(self) -> TPUCompilationResultOp {
        TPUCompilationResultOp::new(Rc::new(self))
    }

    pub fn new() -> Self {
        Self {
            id_: new_id(),
        }
    }
}

impl GcsConfigureCredentialsOp {
    pub fn new(inner: Rc<GcsConfigureCredentials>) -> Self {
        Self{inner}
    }
}

struct GcsConfigureCredentialsOp {
    inner: Rc<GcsConfigureCredentials>,
}

impl GraphOperation for GcsConfigureCredentials {
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("GcsConfigureCredentials_{}")?
        };
        let mut new_op = graph.new_operation("GcsConfigureCredentials", &op_name)?;
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct GcsConfigureCredentials {
    json: Edge<String>,
    id_: usize,
}

impl GcsConfigureCredentials {
    pub fn finish(self) -> GcsConfigureCredentialsOp {
        GcsConfigureCredentialsOp::new(Rc::new(self))
    }

    pub fn new(json: Edge<String>) -> Self {
        Self {
            json,
            id_: new_id(),
        }
    }
}

impl ReaderNumWorkUnitsCompletedOp {
    pub fn new(inner: Rc<ReaderNumWorkUnitsCompleted>) -> Self {
        Self{inner}
    }

    pub fn units_completed(&self) -> Edge<i64> {
        Edge::<i64>::new(self.inner.clone(), 0)
    }
}

struct ReaderNumWorkUnitsCompletedOp {
    inner: Rc<ReaderNumWorkUnitsCompleted>,
}

impl GraphOperation for ReaderNumWorkUnitsCompleted {
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("ReaderNumWorkUnitsCompleted_{}")?
        };
        let mut new_op = graph.new_operation("ReaderNumWorkUnitsCompleted", &op_name)?;
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct ReaderNumWorkUnitsCompleted {
    reader_handle: Edge<String>,
    id_: usize,
}

impl ReaderNumWorkUnitsCompleted {
    pub fn finish(self) -> ReaderNumWorkUnitsCompletedOp {
        ReaderNumWorkUnitsCompletedOp::new(Rc::new(self))
    }

    pub fn new(reader_handle: Edge<String>) -> Self {
        Self {
            reader_handle,
            id_: new_id(),
        }
    }
}

impl<T> XlaClusterOutputOp<T>
where T: con,
{
    pub fn new(inner: Rc<XlaClusterOutput<T>>) -> Self {
        Self{inner}
    }

    pub fn outputs(&self) -> Edge<T> {
        Edge::<T>::new(self.inner.clone(), 0)
    }
}

struct XlaClusterOutputOp<T>
where T: con,
{
    inner: Rc<XlaClusterOutput<T>>,
}

impl<T> GraphOperation for XlaClusterOutput<T>
where T: con,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("XlaClusterOutput_{}")?
        };
        let mut new_op = graph.new_operation("XlaClusterOutput", &op_name)?;
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct XlaClusterOutput<T>
where T: con,
{
    input: Edge<T>,
    id_: usize,
}

impl<T> XlaClusterOutput<T>
where T: con,
{
    pub fn finish(self) -> XlaClusterOutputOp<T> {
        XlaClusterOutputOp::new(Rc::new(self))
    }

    pub fn new(input: Edge<T>) -> Self {
        Self {
            input,
            id_: new_id(),
        }
    }
}

impl<T, Index> StridedSliceOp<T, Index>
where T: con,
      Index: con_or_DT_INT32_or_DT_INT64,
{
    pub fn new(inner: Rc<StridedSlice<T, Index>>) -> Self {
        Self{inner}
    }

    pub fn output(&self) -> Edge<T> {
        Edge::<T>::new(self.inner.clone(), 0)
    }
}

struct StridedSliceOp<T, Index>
where T: con,
      Index: con_or_DT_INT32_or_DT_INT64,
{
    inner: Rc<StridedSlice<T, Index>>,
}

impl<T, Index> GraphOperation for StridedSlice<T, Index>
where T: con,
      Index: con_or_DT_INT32_or_DT_INT64,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("StridedSlice_{}")?
        };
        let mut new_op = graph.new_operation("StridedSlice", &op_name)?;
        {
            match self.begin_mask {
            }
            None => new_op.set_attr_value_proto("begin_mask", &vec![24_u8, 0_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_int("begin_mask", *attr)})(&value),
        };
        {
            match self.end_mask {
            }
            None => new_op.set_attr_value_proto("end_mask", &vec![24_u8, 0_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_int("end_mask", *attr)})(&value),
        };
        {
            match self.ellipsis_mask {
            }
            None => new_op.set_attr_value_proto("ellipsis_mask", &vec![24_u8, 0_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_int("ellipsis_mask", *attr)})(&value),
        };
        {
            match self.new_axis_mask {
            }
            None => new_op.set_attr_value_proto("new_axis_mask", &vec![24_u8, 0_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_int("new_axis_mask", *attr)})(&value),
        };
        {
            match self.shrink_axis_mask {
            }
            None => new_op.set_attr_value_proto("shrink_axis_mask", &vec![24_u8, 0_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_int("shrink_axis_mask", *attr)})(&value),
        };
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct StridedSlice<T, Index>
where T: con,
      Index: con_or_DT_INT32_or_DT_INT64,
{
    input: Edge<T>,
    begin: Edge<Index>,
    end: Edge<Index>,
    strides: Edge<Index>,
    begin_mask: Option<i64>,
    end_mask: Option<i64>,
    ellipsis_mask: Option<i64>,
    new_axis_mask: Option<i64>,
    shrink_axis_mask: Option<i64>,
    id_: usize,
}

impl<T, Index> StridedSlice<T, Index>
where T: con,
      Index: con_or_DT_INT32_or_DT_INT64,
{
    pub fn begin_mask(&mut self, begin_mask: int) -> &mut Self {
        self.begin_mask = Some(begin_mask);
        &self
    }

    pub fn end_mask(&mut self, end_mask: int) -> &mut Self {
        self.end_mask = Some(end_mask);
        &self
    }

    pub fn ellipsis_mask(&mut self, ellipsis_mask: int) -> &mut Self {
        self.ellipsis_mask = Some(ellipsis_mask);
        &self
    }

    pub fn new_axis_mask(&mut self, new_axis_mask: int) -> &mut Self {
        self.new_axis_mask = Some(new_axis_mask);
        &self
    }

    pub fn shrink_axis_mask(&mut self, shrink_axis_mask: int) -> &mut Self {
        self.shrink_axis_mask = Some(shrink_axis_mask);
        &self
    }

    pub fn finish(self) -> StridedSliceOp<T, Index> {
        StridedSliceOp::new(Rc::new(self))
    }

    pub fn new(input: Edge<T>, begin: Edge<Index>, end: Edge<Index>, strides: Edge<Index>) -> Self {
        Self {
            input,
            begin,
            end,
            strides,
            begin_mask: None,
            end_mask: None,
            ellipsis_mask: None,
            new_axis_mask: None,
            shrink_axis_mask: None,
            id_: new_id(),
        }
    }
}

impl<T> TPUReplicatedOutputOp<T>
where T: con,
{
    pub fn new(inner: Rc<TPUReplicatedOutput<T>>) -> Self {
        Self{inner}
    }

    pub fn outputs(&self) -> Edge<T> {
        Edge::<T>::new(self.inner.clone(), 0)
    }
}

struct TPUReplicatedOutputOp<T>
where T: con,
{
    inner: Rc<TPUReplicatedOutput<T>>,
}

impl<T> GraphOperation for TPUReplicatedOutput<T>
where T: con,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("TPUReplicatedOutput_{}")?
        };
        let mut new_op = graph.new_operation("TPUReplicatedOutput", &op_name)?;
        {
            (|attr| {new_op.set_attr_int("num_replicas", *attr)})(&self.num_replicas)
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct TPUReplicatedOutput<T>
where T: con,
{
    input: Edge<T>,
    num_replicas: i64,
    id_: usize,
}

impl<T> TPUReplicatedOutput<T>
where T: con,
{
    pub fn finish(self) -> TPUReplicatedOutputOp<T> {
        TPUReplicatedOutputOp::new(Rc::new(self))
    }

    pub fn new(input: Edge<T>, num_replicas: int) -> Self {
        Self {
            input,
            num_replicas: num_replicas
            id_: new_id(),
        }
    }
}

pub trait con_or_DT_FLOAT_or_DT_BFLOAT16 {
}

impl con_or_DT_FLOAT_or_DT_BFLOAT16 for BFloat16 {
}

impl con_or_DT_FLOAT_or_DT_BFLOAT16 for f32 {
}

impl<T> CrossReplicaSumOp<T>
where T: con_or_DT_FLOAT_or_DT_BFLOAT16,
{
    pub fn new(inner: Rc<CrossReplicaSum<T>>) -> Self {
        Self{inner}
    }

    pub fn output(&self) -> Edge<T> {
        Edge::<T>::new(self.inner.clone(), 0)
    }
}

struct CrossReplicaSumOp<T>
where T: con_or_DT_FLOAT_or_DT_BFLOAT16,
{
    inner: Rc<CrossReplicaSum<T>>,
}

impl<T> GraphOperation for CrossReplicaSum<T>
where T: con_or_DT_FLOAT_or_DT_BFLOAT16,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("CrossReplicaSum_{}")?
        };
        let mut new_op = graph.new_operation("CrossReplicaSum", &op_name)?;
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct CrossReplicaSum<T>
where T: con_or_DT_FLOAT_or_DT_BFLOAT16,
{
    input: Edge<T>,
    group_assignment: Edge<i32>,
    id_: usize,
}

impl<T> CrossReplicaSum<T>
where T: con_or_DT_FLOAT_or_DT_BFLOAT16,
{
    pub fn finish(self) -> CrossReplicaSumOp<T> {
        CrossReplicaSumOp::new(Rc::new(self))
    }

    pub fn new(input: Edge<T>, group_assignment: Edge<i32>) -> Self {
        Self {
            input,
            group_assignment,
            id_: new_id(),
        }
    }
}

impl FakeQuantWithMinMaxVarsGradientOp {
    pub fn new(inner: Rc<FakeQuantWithMinMaxVarsGradient>) -> Self {
        Self{inner}
    }

    pub fn backprops_wrt_input(&self) -> Edge<f32> {
        Edge::<f32>::new(self.inner.clone(), 0)
    }

    pub fn backprop_wrt_min(&self) -> Edge<f32> {
        Edge::<f32>::new(self.inner.clone(), 1)
    }

    pub fn backprop_wrt_max(&self) -> Edge<f32> {
        Edge::<f32>::new(self.inner.clone(), 2)
    }
}

struct FakeQuantWithMinMaxVarsGradientOp {
    inner: Rc<FakeQuantWithMinMaxVarsGradient>,
}

impl GraphOperation for FakeQuantWithMinMaxVarsGradient {
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("FakeQuantWithMinMaxVarsGradient_{}")?
        };
        let mut new_op = graph.new_operation("FakeQuantWithMinMaxVarsGradient", &op_name)?;
        {
            match self.num_bits {
            }
            None => new_op.set_attr_value_proto("num_bits", &vec![24_u8, 8_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_int("num_bits", *attr)})(&value),
        };
        {
            match self.narrow_range {
            }
            None => new_op.set_attr_value_proto("narrow_range", &vec![40_u8, 0_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_bool("narrow_range", *attr)})(&value),
        };
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct FakeQuantWithMinMaxVarsGradient {
    gradients: Edge<f32>,
    inputs: Edge<f32>,
    min: Edge<f32>,
    max: Edge<f32>,
    num_bits: Option<i64>,
    narrow_range: Option<bool>,
    id_: usize,
}

impl FakeQuantWithMinMaxVarsGradient {
    pub fn num_bits(&mut self, num_bits: int) -> &mut Self {
        self.num_bits = Some(num_bits);
        &self
    }

    pub fn narrow_range(&mut self, narrow_range: bool) -> &mut Self {
        self.narrow_range = Some(narrow_range);
        &self
    }

    pub fn finish(self) -> FakeQuantWithMinMaxVarsGradientOp {
        FakeQuantWithMinMaxVarsGradientOp::new(Rc::new(self))
    }

    pub fn new(gradients: Edge<f32>, inputs: Edge<f32>, min: Edge<f32>, max: Edge<f32>) -> Self {
        Self {
            gradients,
            inputs,
            min,
            max,
            num_bits: None,
            narrow_range: None,
            id_: new_id(),
        }
    }
}

impl InitializeTableFromTextFileOp {
    pub fn new(inner: Rc<InitializeTableFromTextFile>) -> Self {
        Self{inner}
    }
}

struct InitializeTableFromTextFileOp {
    inner: Rc<InitializeTableFromTextFile>,
}

impl GraphOperation for InitializeTableFromTextFile {
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("InitializeTableFromTextFile_{}")?
        };
        let mut new_op = graph.new_operation("InitializeTableFromTextFile", &op_name)?;
        {
            (|attr| {new_op.set_attr_int("key_index", *attr)})(&self.key_index)
        }
        {
            (|attr| {new_op.set_attr_int("value_index", *attr)})(&self.value_index)
        }
        {
            match self.vocab_size {
            }
            None => new_op.set_attr_value_proto("vocab_size", &vec![24_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 1_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_int("vocab_size", *attr)})(&value),
        };
        {
            match self.delimiter {
            }
            None => new_op.set_attr_value_proto("delimiter", &vec![18_u8, 1_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_string("delimiter", attr)})(&value),
        };
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct InitializeTableFromTextFile {
    table_handle: Edge<String>,
    filename: Edge<String>,
    key_index: i64,
    value_index: i64,
    vocab_size: Option<i64>,
    delimiter: Option<String>,
    id_: usize,
}

impl InitializeTableFromTextFile {
    pub fn vocab_size(&mut self, vocab_size: int) -> &mut Self {
        self.vocab_size = Some(vocab_size);
        &self
    }

    pub fn delimiter(&mut self, delimiter: &str) -> &mut Self {
        self.delimiter = Some(delimiter.to_string());
        &self
    }

    pub fn finish(self) -> InitializeTableFromTextFileOp {
        InitializeTableFromTextFileOp::new(Rc::new(self))
    }

    pub fn new(table_handle: Edge<String>, filename: Edge<String>, key_index: int, value_index: int) -> Self {
        Self {
            table_handle,
            filename,
            key_index: key_index
            value_index: value_index
            vocab_size: None,
            delimiter: None,
            id_: new_id(),
        }
    }
}

impl<T> _SendOp<T>
where T: con,
{
    pub fn new(inner: Rc<_Send<T>>) -> Self {
        Self{inner}
    }
}

struct _SendOp<T>
where T: con,
{
    inner: Rc<_Send<T>>,
}

impl<T> GraphOperation for _Send<T>
where T: con,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("_Send_{}")?
        };
        let mut new_op = graph.new_operation("_Send", &op_name)?;
        {
            (|attr| {new_op.set_attr_string("tensor_name", attr)})(&self.tensor_name)
        }
        {
            (|attr| {new_op.set_attr_string("send_device", attr)})(&self.send_device)
        }
        {
            (|attr| {new_op.set_attr_int("send_device_incarnation", *attr)})(&self.send_device_incarnation)
        }
        {
            (|attr| {new_op.set_attr_string("recv_device", attr)})(&self.recv_device)
        }
        {
            match self.client_terminated {
            }
            None => new_op.set_attr_value_proto("client_terminated", &vec![40_u8, 0_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_bool("client_terminated", *attr)})(&value),
        };
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct _Send<T>
where T: con,
{
    tensor: Edge<T>,
    tensor_name: String,
    send_device: String,
    send_device_incarnation: i64,
    recv_device: String,
    client_terminated: Option<bool>,
    id_: usize,
}

impl<T> _Send<T>
where T: con,
{
    pub fn client_terminated(&mut self, client_terminated: bool) -> &mut Self {
        self.client_terminated = Some(client_terminated);
        &self
    }

    pub fn finish(self) -> _SendOp<T> {
        _SendOp::new(Rc::new(self))
    }

    pub fn new(tensor: Edge<T>, tensor_name: &str, send_device: &str, send_device_incarnation: int, recv_device: &str) -> Self {
        Self {
            tensor,
            tensor_name: tensor_name.to_string()
            send_device: send_device.to_string()
            send_device_incarnation: send_device_incarnation
            recv_device: recv_device.to_string()
            client_terminated: None,
            id_: new_id(),
        }
    }
}

impl<T> MinimumOp<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_INT64_or_DT_BFLOAT16_or_DT_HALF,
{
    pub fn new(inner: Rc<Minimum<T>>) -> Self {
        Self{inner}
    }

    pub fn z(&self) -> Edge<T> {
        Edge::<T>::new(self.inner.clone(), 0)
    }
}

struct MinimumOp<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_INT64_or_DT_BFLOAT16_or_DT_HALF,
{
    inner: Rc<Minimum<T>>,
}

impl<T> GraphOperation for Minimum<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_INT64_or_DT_BFLOAT16_or_DT_HALF,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("Minimum_{}")?
        };
        let mut new_op = graph.new_operation("Minimum", &op_name)?;
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct Minimum<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_INT64_or_DT_BFLOAT16_or_DT_HALF,
{
    x: Edge<T>,
    y: Edge<T>,
    id_: usize,
}

impl<T> Minimum<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_INT64_or_DT_BFLOAT16_or_DT_HALF,
{
    pub fn finish(self) -> MinimumOp<T> {
        MinimumOp::new(Rc::new(self))
    }

    pub fn new(x: Edge<T>, y: Edge<T>) -> Self {
        Self {
            x,
            y,
            id_: new_id(),
        }
    }
}

impl<T> ParallelConcatOp<T>
where T: con,
{
    pub fn new(inner: Rc<ParallelConcat<T>>) -> Self {
        Self{inner}
    }

    pub fn output(&self) -> Edge<T> {
        Edge::<T>::new(self.inner.clone(), 0)
    }
}

struct ParallelConcatOp<T>
where T: con,
{
    inner: Rc<ParallelConcat<T>>,
}

impl<T> GraphOperation for ParallelConcat<T>
where T: con,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("ParallelConcat_{}")?
        };
        let mut new_op = graph.new_operation("ParallelConcat", &op_name)?;
        {
            (|attr| {new_op.set_attr_int("N", *attr)})(&self.N)
        }
        {
            (|attr| {new_op.set_attr_shape("shape", attr)})(&self.shape)
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct ParallelConcat<T>
where T: con,
{
    values: Edge<T>,
    N: i64,
    shape: Shape,
    id_: usize,
}

impl<T> ParallelConcat<T>
where T: con,
{
    pub fn finish(self) -> ParallelConcatOp<T> {
        ParallelConcatOp::new(Rc::new(self))
    }

    pub fn new(values: Edge<T>, N: int, shape: &Shape) -> Self {
        Self {
            values,
            N: N
            shape: shape.clone()
            id_: new_id(),
        }
    }
}

impl<dtype> OutfeedDequeueOp<dtype>
where dtype: con,
{
    pub fn new(inner: Rc<OutfeedDequeue<dtype>>) -> Self {
        Self{inner}
    }

    pub fn output(&self) -> Edge<dtype> {
        Edge::<dtype>::new(self.inner.clone(), 0)
    }
}

struct OutfeedDequeueOp<dtype>
where dtype: con,
{
    inner: Rc<OutfeedDequeue<dtype>>,
}

impl<dtype> GraphOperation for OutfeedDequeue<dtype>
where dtype: con,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("OutfeedDequeue_{}")?
        };
        let mut new_op = graph.new_operation("OutfeedDequeue", &op_name)?;
        {
            (|attr| {new_op.set_attr_shape("shape", attr)})(&self.shape)
        }
        {
            match self.device_ordinal {
            }
            None => new_op.set_attr_value_proto("device_ordinal", &vec![24_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 1_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_int("device_ordinal", *attr)})(&value),
        };
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct OutfeedDequeue<dtype>
where dtype: con,
{
    shape: Shape,
    device_ordinal: Option<i64>,
    id_: usize,
}

impl<dtype> OutfeedDequeue<dtype>
where dtype: con,
{
    pub fn device_ordinal(&mut self, device_ordinal: int) -> &mut Self {
        self.device_ordinal = Some(device_ordinal);
        &self
    }

    pub fn finish(self) -> OutfeedDequeueOp<dtype> {
        OutfeedDequeueOp::new(Rc::new(self))
    }

    pub fn new(shape: &Shape) -> Self {
        Self {
            shape: shape.clone()
            device_ordinal: None,
            id_: new_id(),
        }
    }
}

impl RetrieveTPUEmbeddingAdagradParametersGradAccumDebugOp {
    pub fn new(inner: Rc<RetrieveTPUEmbeddingAdagradParametersGradAccumDebug>) -> Self {
        Self{inner}
    }

    pub fn parameters(&self) -> Edge<f32> {
        Edge::<f32>::new(self.inner.clone(), 0)
    }

    pub fn accumulators(&self) -> Edge<f32> {
        Edge::<f32>::new(self.inner.clone(), 1)
    }

    pub fn gradient_accumulators(&self) -> Edge<f32> {
        Edge::<f32>::new(self.inner.clone(), 2)
    }
}

struct RetrieveTPUEmbeddingAdagradParametersGradAccumDebugOp {
    inner: Rc<RetrieveTPUEmbeddingAdagradParametersGradAccumDebug>,
}

impl GraphOperation for RetrieveTPUEmbeddingAdagradParametersGradAccumDebug {
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("RetrieveTPUEmbeddingAdagradParametersGradAccumDebug_{}")?
        };
        let mut new_op = graph.new_operation("RetrieveTPUEmbeddingAdagradParametersGradAccumDebug", &op_name)?;
        {
            match self.table_id {
            }
            None => new_op.set_attr_value_proto("table_id", &vec![24_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 1_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_int("table_id", *attr)})(&value),
        };
        {
            match self.table_name {
            }
            None => new_op.set_attr_value_proto("table_name", &vec![18_u8, 0_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_string("table_name", attr)})(&value),
        };
        {
            (|attr| {new_op.set_attr_int("num_shards", *attr)})(&self.num_shards)
        }
        {
            (|attr| {new_op.set_attr_int("shard_id", *attr)})(&self.shard_id)
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct RetrieveTPUEmbeddingAdagradParametersGradAccumDebug {
    table_id: Option<i64>,
    table_name: Option<String>,
    num_shards: i64,
    shard_id: i64,
    id_: usize,
}

impl RetrieveTPUEmbeddingAdagradParametersGradAccumDebug {
    pub fn table_id(&mut self, table_id: int) -> &mut Self {
        self.table_id = Some(table_id);
        &self
    }

    pub fn table_name(&mut self, table_name: &str) -> &mut Self {
        self.table_name = Some(table_name.to_string());
        &self
    }

    pub fn finish(self) -> RetrieveTPUEmbeddingAdagradParametersGradAccumDebugOp {
        RetrieveTPUEmbeddingAdagradParametersGradAccumDebugOp::new(Rc::new(self))
    }

    pub fn new(num_shards: int, shard_id: int) -> Self {
        Self {
            table_id: None,
            table_name: None,
            num_shards: num_shards
            shard_id: shard_id
            id_: new_id(),
        }
    }
}

impl<T> CholeskyGradOp<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE,
{
    pub fn new(inner: Rc<CholeskyGrad<T>>) -> Self {
        Self{inner}
    }

    pub fn output(&self) -> Edge<T> {
        Edge::<T>::new(self.inner.clone(), 0)
    }
}

struct CholeskyGradOp<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE,
{
    inner: Rc<CholeskyGrad<T>>,
}

impl<T> GraphOperation for CholeskyGrad<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("CholeskyGrad_{}")?
        };
        let mut new_op = graph.new_operation("CholeskyGrad", &op_name)?;
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct CholeskyGrad<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE,
{
    l: Edge<T>,
    grad: Edge<T>,
    id_: usize,
}

impl<T> CholeskyGrad<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE,
{
    pub fn finish(self) -> CholeskyGradOp<T> {
        CholeskyGradOp::new(Rc::new(self))
    }

    pub fn new(l: Edge<T>, grad: Edge<T>) -> Self {
        Self {
            l,
            grad,
            id_: new_id(),
        }
    }
}

impl<T> AtanhOp<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_COMPLEX64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF,
{
    pub fn new(inner: Rc<Atanh<T>>) -> Self {
        Self{inner}
    }

    pub fn y(&self) -> Edge<T> {
        Edge::<T>::new(self.inner.clone(), 0)
    }
}

struct AtanhOp<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_COMPLEX64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF,
{
    inner: Rc<Atanh<T>>,
}

impl<T> GraphOperation for Atanh<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_COMPLEX64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("Atanh_{}")?
        };
        let mut new_op = graph.new_operation("Atanh", &op_name)?;
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct Atanh<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_COMPLEX64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF,
{
    x: Edge<T>,
    id_: usize,
}

impl<T> Atanh<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_COMPLEX64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF,
{
    pub fn finish(self) -> AtanhOp<T> {
        AtanhOp::new(Rc::new(self))
    }

    pub fn new(x: Edge<T>) -> Self {
        Self {
            x,
            id_: new_id(),
        }
    }
}

impl<T> AllToAllOp<T>
where T: con_or_DT_FLOAT_or_DT_BFLOAT16,
{
    pub fn new(inner: Rc<AllToAll<T>>) -> Self {
        Self{inner}
    }

    pub fn output(&self) -> Edge<T> {
        Edge::<T>::new(self.inner.clone(), 0)
    }
}

struct AllToAllOp<T>
where T: con_or_DT_FLOAT_or_DT_BFLOAT16,
{
    inner: Rc<AllToAll<T>>,
}

impl<T> GraphOperation for AllToAll<T>
where T: con_or_DT_FLOAT_or_DT_BFLOAT16,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("AllToAll_{}")?
        };
        let mut new_op = graph.new_operation("AllToAll", &op_name)?;
        {
            (|attr| {new_op.set_attr_int("concat_dimension", *attr)})(&self.concat_dimension)
        }
        {
            (|attr| {new_op.set_attr_int("split_dimension", *attr)})(&self.split_dimension)
        }
        {
            (|attr| {new_op.set_attr_int("split_count", *attr)})(&self.split_count)
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct AllToAll<T>
where T: con_or_DT_FLOAT_or_DT_BFLOAT16,
{
    input: Edge<T>,
    group_assignment: Edge<i32>,
    concat_dimension: i64,
    split_dimension: i64,
    split_count: i64,
    id_: usize,
}

impl<T> AllToAll<T>
where T: con_or_DT_FLOAT_or_DT_BFLOAT16,
{
    pub fn finish(self) -> AllToAllOp<T> {
        AllToAllOp::new(Rc::new(self))
    }

    pub fn new(input: Edge<T>, group_assignment: Edge<i32>, concat_dimension: int, split_dimension: int, split_count: int) -> Self {
        Self {
            input,
            group_assignment,
            concat_dimension: concat_dimension
            split_dimension: split_dimension
            split_count: split_count
            id_: new_id(),
        }
    }
}

impl<T> CudnnRNNV2Op<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_HALF,
{
    pub fn new(inner: Rc<CudnnRNNV2<T>>) -> Self {
        Self{inner}
    }

    pub fn output(&self) -> Edge<T> {
        Edge::<T>::new(self.inner.clone(), 0)
    }

    pub fn output_h(&self) -> Edge<T> {
        Edge::<T>::new(self.inner.clone(), 1)
    }

    pub fn output_c(&self) -> Edge<T> {
        Edge::<T>::new(self.inner.clone(), 2)
    }

    pub fn reserve_space(&self) -> Edge<T> {
        Edge::<T>::new(self.inner.clone(), 3)
    }

    pub fn host_reserved(&self) -> Edge<i8> {
        Edge::<i8>::new(self.inner.clone(), 4)
    }
}

struct CudnnRNNV2Op<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_HALF,
{
    inner: Rc<CudnnRNNV2<T>>,
}

impl<T> GraphOperation for CudnnRNNV2<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_HALF,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("CudnnRNNV2_{}")?
        };
        let mut new_op = graph.new_operation("CudnnRNNV2", &op_name)?;
        {
            match self.rnn_mode {
            }
            None => new_op.set_attr_value_proto("rnn_mode", &vec![18_u8, 4_u8, 108_u8, 115_u8, 116_u8, 109_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_string("rnn_mode", attr)})(&value),
        };
        {
            match self.input_mode {
            }
            None => new_op.set_attr_value_proto("input_mode", &vec![18_u8, 12_u8, 108_u8, 105_u8, 110_u8, 101_u8, 97_u8, 114_u8, 95_u8, 105_u8, 110_u8, 112_u8, 117_u8, 116_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_string("input_mode", attr)})(&value),
        };
        {
            match self.direction {
            }
            None => new_op.set_attr_value_proto("direction", &vec![18_u8, 14_u8, 117_u8, 110_u8, 105_u8, 100_u8, 105_u8, 114_u8, 101_u8, 99_u8, 116_u8, 105_u8, 111_u8, 110_u8, 97_u8, 108_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_string("direction", attr)})(&value),
        };
        {
            match self.dropout {
            }
            None => new_op.set_attr_value_proto("dropout", &vec![37_u8, 0_u8, 0_u8, 0_u8, 0_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_float("dropout", *attr)})(&value),
        };
        {
            match self.seed {
            }
            None => new_op.set_attr_value_proto("seed", &vec![24_u8, 0_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_int("seed", *attr)})(&value),
        };
        {
            match self.seed2 {
            }
            None => new_op.set_attr_value_proto("seed2", &vec![24_u8, 0_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_int("seed2", *attr)})(&value),
        };
        {
            match self.is_training {
            }
            None => new_op.set_attr_value_proto("is_training", &vec![40_u8, 1_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_bool("is_training", *attr)})(&value),
        };
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct CudnnRNNV2<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_HALF,
{
    input: Edge<T>,
    input_h: Edge<T>,
    input_c: Edge<T>,
    params: Edge<T>,
    rnn_mode: Option<String>,
    input_mode: Option<String>,
    direction: Option<String>,
    dropout: Option<f32>,
    seed: Option<i64>,
    seed2: Option<i64>,
    is_training: Option<bool>,
    id_: usize,
}

impl<T> CudnnRNNV2<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_HALF,
{
    pub fn rnn_mode(&mut self, rnn_mode: &str) -> &mut Self {
        self.rnn_mode = Some(rnn_mode.to_string());
        &self
    }

    pub fn input_mode(&mut self, input_mode: &str) -> &mut Self {
        self.input_mode = Some(input_mode.to_string());
        &self
    }

    pub fn direction(&mut self, direction: &str) -> &mut Self {
        self.direction = Some(direction.to_string());
        &self
    }

    pub fn dropout(&mut self, dropout: f32) -> &mut Self {
        self.dropout = Some(dropout);
        &self
    }

    pub fn seed(&mut self, seed: int) -> &mut Self {
        self.seed = Some(seed);
        &self
    }

    pub fn seed2(&mut self, seed2: int) -> &mut Self {
        self.seed2 = Some(seed2);
        &self
    }

    pub fn is_training(&mut self, is_training: bool) -> &mut Self {
        self.is_training = Some(is_training);
        &self
    }

    pub fn finish(self) -> CudnnRNNV2Op<T> {
        CudnnRNNV2Op::new(Rc::new(self))
    }

    pub fn new(input: Edge<T>, input_h: Edge<T>, input_c: Edge<T>, params: Edge<T>) -> Self {
        Self {
            input,
            input_h,
            input_c,
            params,
            rnn_mode: None,
            input_mode: None,
            direction: None,
            dropout: None,
            seed: None,
            seed2: None,
            is_training: None,
            id_: new_id(),
        }
    }
}

impl TPUReplicateMetadataOp {
    pub fn new(inner: Rc<TPUReplicateMetadata>) -> Self {
        Self{inner}
    }
}

struct TPUReplicateMetadataOp {
    inner: Rc<TPUReplicateMetadata>,
}

impl GraphOperation for TPUReplicateMetadata {
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("TPUReplicateMetadata_{}")?
        };
        let mut new_op = graph.new_operation("TPUReplicateMetadata", &op_name)?;
        {
            (|attr| {new_op.set_attr_int("num_replicas", *attr)})(&self.num_replicas)
        }
        {
            match self.num_cores_per_replica {
            }
            None => new_op.set_attr_value_proto("num_cores_per_replica", &vec![24_u8, 1_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_int("num_cores_per_replica", *attr)})(&value),
        };
        {
            match self.topology {
            }
            None => new_op.set_attr_value_proto("topology", &vec![18_u8, 0_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_string("topology", attr)})(&value),
        };
        {
            match self.use_tpu {
            }
            None => new_op.set_attr_value_proto("use_tpu", &vec![40_u8, 1_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_bool("use_tpu", *attr)})(&value),
        };
        {
            match self.device_assignment {
            }
            None => new_op.set_attr_value_proto("device_assignment", &vec![10_u8, 0_u8,]);,
            Some(value) => (|attrs| {new_op.set_attr_int_list("device_assignment", attrs)})(&value),
        };
        {
            match self.computation_shape {
            }
            None => new_op.set_attr_value_proto("computation_shape", &vec![10_u8, 0_u8,]);,
            Some(value) => (|attrs| {new_op.set_attr_int_list("computation_shape", attrs)})(&value),
        };
        {
            match self.host_compute_core {
            }
            None => new_op.set_attr_value_proto("host_compute_core", &vec![10_u8, 0_u8,]);,
            Some(value) => (|attrs| {new_op.set_attr_string_list("host_compute_core", attrs)})(&value),
        };
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct TPUReplicateMetadata {
    num_replicas: i64,
    num_cores_per_replica: Option<i64>,
    topology: Option<String>,
    use_tpu: Option<bool>,
    device_assignment: Option<Vec<i64>>,
    computation_shape: Option<Vec<i64>>,
    host_compute_core: Option<Vec<String>>,
    id_: usize,
}

impl TPUReplicateMetadata {
    pub fn num_cores_per_replica(&mut self, num_cores_per_replica: int) -> &mut Self {
        self.num_cores_per_replica = Some(num_cores_per_replica);
        &self
    }

    pub fn topology(&mut self, topology: &str) -> &mut Self {
        self.topology = Some(topology.to_string());
        &self
    }

    pub fn use_tpu(&mut self, use_tpu: bool) -> &mut Self {
        self.use_tpu = Some(use_tpu);
        &self
    }

    pub fn device_assignment(&mut self, device_assignment: &[int]) -> &mut Self {
        self.device_assignment = Some(device_assignment.to_vec());
        &self
    }

    pub fn computation_shape(&mut self, computation_shape: &[int]) -> &mut Self {
        self.computation_shape = Some(computation_shape.to_vec());
        &self
    }

    pub fn host_compute_core(&mut self, host_compute_core: &[String]) -> &mut Self {
        self.host_compute_core = Some(host_compute_core.to_vec());
        &self
    }

    pub fn finish(self) -> TPUReplicateMetadataOp {
        TPUReplicateMetadataOp::new(Rc::new(self))
    }

    pub fn new(num_replicas: int) -> Self {
        Self {
            num_replicas: num_replicas
            num_cores_per_replica: None,
            topology: None,
            use_tpu: None,
            device_assignment: None,
            computation_shape: None,
            host_compute_core: None,
            id_: new_id(),
        }
    }
}

impl LoadTPUEmbeddingFTRLParametersGradAccumDebugOp {
    pub fn new(inner: Rc<LoadTPUEmbeddingFTRLParametersGradAccumDebug>) -> Self {
        Self{inner}
    }
}

struct LoadTPUEmbeddingFTRLParametersGradAccumDebugOp {
    inner: Rc<LoadTPUEmbeddingFTRLParametersGradAccumDebug>,
}

impl GraphOperation for LoadTPUEmbeddingFTRLParametersGradAccumDebug {
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("LoadTPUEmbeddingFTRLParametersGradAccumDebug_{}")?
        };
        let mut new_op = graph.new_operation("LoadTPUEmbeddingFTRLParametersGradAccumDebug", &op_name)?;
        {
            match self.table_id {
            }
            None => new_op.set_attr_value_proto("table_id", &vec![24_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 1_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_int("table_id", *attr)})(&value),
        };
        {
            match self.table_name {
            }
            None => new_op.set_attr_value_proto("table_name", &vec![18_u8, 0_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_string("table_name", attr)})(&value),
        };
        {
            (|attr| {new_op.set_attr_int("num_shards", *attr)})(&self.num_shards)
        }
        {
            (|attr| {new_op.set_attr_int("shard_id", *attr)})(&self.shard_id)
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct LoadTPUEmbeddingFTRLParametersGradAccumDebug {
    parameters: Edge<f32>,
    accumulators: Edge<f32>,
    linears: Edge<f32>,
    gradient_accumulators: Edge<f32>,
    table_id: Option<i64>,
    table_name: Option<String>,
    num_shards: i64,
    shard_id: i64,
    id_: usize,
}

impl LoadTPUEmbeddingFTRLParametersGradAccumDebug {
    pub fn table_id(&mut self, table_id: int) -> &mut Self {
        self.table_id = Some(table_id);
        &self
    }

    pub fn table_name(&mut self, table_name: &str) -> &mut Self {
        self.table_name = Some(table_name.to_string());
        &self
    }

    pub fn finish(self) -> LoadTPUEmbeddingFTRLParametersGradAccumDebugOp {
        LoadTPUEmbeddingFTRLParametersGradAccumDebugOp::new(Rc::new(self))
    }

    pub fn new(parameters: Edge<f32>, accumulators: Edge<f32>, linears: Edge<f32>, gradient_accumulators: Edge<f32>, num_shards: int, shard_id: int) -> Self {
        Self {
            parameters,
            accumulators,
            linears,
            gradient_accumulators,
            table_id: None,
            table_name: None,
            num_shards: num_shards
            shard_id: shard_id
            id_: new_id(),
        }
    }
}

impl<dtype> IsVariableInitializedOp<dtype>
where dtype: con,
{
    pub fn new(inner: Rc<IsVariableInitialized<dtype>>) -> Self {
        Self{inner}
    }

    pub fn is_initialized(&self) -> Edge<bool> {
        Edge::<bool>::new(self.inner.clone(), 0)
    }
}

struct IsVariableInitializedOp<dtype>
where dtype: con,
{
    inner: Rc<IsVariableInitialized<dtype>>,
}

impl<dtype> GraphOperation for IsVariableInitialized<dtype>
where dtype: con,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("IsVariableInitialized_{}")?
        };
        let mut new_op = graph.new_operation("IsVariableInitialized", &op_name)?;
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct IsVariableInitialized<dtype>
where dtype: con,
{
    ref_: Edge<dtype>,
    id_: usize,
}

impl<dtype> IsVariableInitialized<dtype>
where dtype: con,
{
    pub fn finish(self) -> IsVariableInitializedOp<dtype> {
        IsVariableInitializedOp::new(Rc::new(self))
    }

    pub fn new(ref_: Edge<dtype>) -> Self {
        Self {
            ref_,
            id_: new_id(),
        }
    }
}

impl<T> QuantizeAndDequantizeV2Op<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
{
    pub fn new(inner: Rc<QuantizeAndDequantizeV2<T>>) -> Self {
        Self{inner}
    }

    pub fn output(&self) -> Edge<T> {
        Edge::<T>::new(self.inner.clone(), 0)
    }
}

struct QuantizeAndDequantizeV2Op<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
{
    inner: Rc<QuantizeAndDequantizeV2<T>>,
}

impl<T> GraphOperation for QuantizeAndDequantizeV2<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("QuantizeAndDequantizeV2_{}")?
        };
        let mut new_op = graph.new_operation("QuantizeAndDequantizeV2", &op_name)?;
        {
            match self.signed_input {
            }
            None => new_op.set_attr_value_proto("signed_input", &vec![40_u8, 1_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_bool("signed_input", *attr)})(&value),
        };
        {
            match self.num_bits {
            }
            None => new_op.set_attr_value_proto("num_bits", &vec![24_u8, 8_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_int("num_bits", *attr)})(&value),
        };
        {
            match self.range_given {
            }
            None => new_op.set_attr_value_proto("range_given", &vec![40_u8, 0_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_bool("range_given", *attr)})(&value),
        };
        {
            match self.round_mode {
            }
            None => new_op.set_attr_value_proto("round_mode", &vec![18_u8, 12_u8, 72_u8, 65_u8, 76_u8, 70_u8, 95_u8, 84_u8, 79_u8, 95_u8, 69_u8, 86_u8, 69_u8, 78_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_string("round_mode", attr)})(&value),
        };
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct QuantizeAndDequantizeV2<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
{
    input: Edge<T>,
    input_min: Edge<T>,
    input_max: Edge<T>,
    signed_input: Option<bool>,
    num_bits: Option<i64>,
    range_given: Option<bool>,
    round_mode: Option<String>,
    id_: usize,
}

impl<T> QuantizeAndDequantizeV2<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
{
    pub fn signed_input(&mut self, signed_input: bool) -> &mut Self {
        self.signed_input = Some(signed_input);
        &self
    }

    pub fn num_bits(&mut self, num_bits: int) -> &mut Self {
        self.num_bits = Some(num_bits);
        &self
    }

    pub fn range_given(&mut self, range_given: bool) -> &mut Self {
        self.range_given = Some(range_given);
        &self
    }

    pub fn round_mode(&mut self, round_mode: &str) -> &mut Self {
        self.round_mode = Some(round_mode.to_string());
        &self
    }

    pub fn finish(self) -> QuantizeAndDequantizeV2Op<T> {
        QuantizeAndDequantizeV2Op::new(Rc::new(self))
    }

    pub fn new(input: Edge<T>, input_min: Edge<T>, input_max: Edge<T>) -> Self {
        Self {
            input,
            input_min,
            input_max,
            signed_input: None,
            num_bits: None,
            range_given: None,
            round_mode: None,
            id_: new_id(),
        }
    }
}

impl<T, Tblock_shape, Tpaddings> SpaceToBatchNDOp<T, Tblock_shape, Tpaddings>
where T: con,
      Tblock_shape: con_or_DT_INT32_or_DT_INT64,
      Tpaddings: con_or_DT_INT32_or_DT_INT64,
{
    pub fn new(inner: Rc<SpaceToBatchND<T, Tblock_shape, Tpaddings>>) -> Self {
        Self{inner}
    }

    pub fn output(&self) -> Edge<T> {
        Edge::<T>::new(self.inner.clone(), 0)
    }
}

struct SpaceToBatchNDOp<T, Tblock_shape, Tpaddings>
where T: con,
      Tblock_shape: con_or_DT_INT32_or_DT_INT64,
      Tpaddings: con_or_DT_INT32_or_DT_INT64,
{
    inner: Rc<SpaceToBatchND<T, Tblock_shape, Tpaddings>>,
}

impl<T, Tblock_shape, Tpaddings> GraphOperation for SpaceToBatchND<T, Tblock_shape, Tpaddings>
where T: con,
      Tblock_shape: con_or_DT_INT32_or_DT_INT64,
      Tpaddings: con_or_DT_INT32_or_DT_INT64,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("SpaceToBatchND_{}")?
        };
        let mut new_op = graph.new_operation("SpaceToBatchND", &op_name)?;
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct SpaceToBatchND<T, Tblock_shape, Tpaddings>
where T: con,
      Tblock_shape: con_or_DT_INT32_or_DT_INT64,
      Tpaddings: con_or_DT_INT32_or_DT_INT64,
{
    input: Edge<T>,
    block_shape: Edge<Tblock_shape>,
    paddings: Edge<Tpaddings>,
    id_: usize,
}

impl<T, Tblock_shape, Tpaddings> SpaceToBatchND<T, Tblock_shape, Tpaddings>
where T: con,
      Tblock_shape: con_or_DT_INT32_or_DT_INT64,
      Tpaddings: con_or_DT_INT32_or_DT_INT64,
{
    pub fn finish(self) -> SpaceToBatchNDOp<T, Tblock_shape, Tpaddings> {
        SpaceToBatchNDOp::new(Rc::new(self))
    }

    pub fn new(input: Edge<T>, block_shape: Edge<Tblock_shape>, paddings: Edge<Tpaddings>) -> Self {
        Self {
            input,
            block_shape,
            paddings,
            id_: new_id(),
        }
    }
}

impl<T, Tseed, dtype> StatelessRandomUniformOp<T, Tseed, dtype>
where dtype: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
      T: con_or_DT_INT32_or_DT_INT64,
      Tseed: con_or_DT_INT32_or_DT_INT64,
{
    pub fn new(inner: Rc<StatelessRandomUniform<T, Tseed, dtype>>) -> Self {
        Self{inner}
    }

    pub fn output(&self) -> Edge<dtype> {
        Edge::<dtype>::new(self.inner.clone(), 0)
    }
}

struct StatelessRandomUniformOp<T, Tseed, dtype>
where dtype: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
      T: con_or_DT_INT32_or_DT_INT64,
      Tseed: con_or_DT_INT32_or_DT_INT64,
{
    inner: Rc<StatelessRandomUniform<T, Tseed, dtype>>,
}

impl<T, Tseed, dtype> GraphOperation for StatelessRandomUniform<T, Tseed, dtype>
where dtype: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
      T: con_or_DT_INT32_or_DT_INT64,
      Tseed: con_or_DT_INT32_or_DT_INT64,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("StatelessRandomUniform_{}")?
        };
        let mut new_op = graph.new_operation("StatelessRandomUniform", &op_name)?;
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct StatelessRandomUniform<T, Tseed, dtype>
where dtype: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
      T: con_or_DT_INT32_or_DT_INT64,
      Tseed: con_or_DT_INT32_or_DT_INT64,
{
    shape: Edge<T>,
    seed: Edge<Tseed>,
    id_: usize,
}

impl<T, Tseed, dtype> StatelessRandomUniform<T, Tseed, dtype>
where dtype: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
      T: con_or_DT_INT32_or_DT_INT64,
      Tseed: con_or_DT_INT32_or_DT_INT64,
{
    pub fn finish(self) -> StatelessRandomUniformOp<T, Tseed, dtype> {
        StatelessRandomUniformOp::new(Rc::new(self))
    }

    pub fn new(shape: Edge<T>, seed: Edge<Tseed>) -> Self {
        Self {
            shape,
            seed,
            id_: new_id(),
        }
    }
}

impl<dtype> InfeedDequeueOp<dtype>
where dtype: con,
{
    pub fn new(inner: Rc<InfeedDequeue<dtype>>) -> Self {
        Self{inner}
    }

    pub fn output(&self) -> Edge<dtype> {
        Edge::<dtype>::new(self.inner.clone(), 0)
    }
}

struct InfeedDequeueOp<dtype>
where dtype: con,
{
    inner: Rc<InfeedDequeue<dtype>>,
}

impl<dtype> GraphOperation for InfeedDequeue<dtype>
where dtype: con,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("InfeedDequeue_{}")?
        };
        let mut new_op = graph.new_operation("InfeedDequeue", &op_name)?;
        {
            (|attr| {new_op.set_attr_shape("shape", attr)})(&self.shape)
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct InfeedDequeue<dtype>
where dtype: con,
{
    shape: Shape,
    id_: usize,
}

impl<dtype> InfeedDequeue<dtype>
where dtype: con,
{
    pub fn finish(self) -> InfeedDequeueOp<dtype> {
        InfeedDequeueOp::new(Rc::new(self))
    }

    pub fn new(shape: &Shape) -> Self {
        Self {
            shape: shape.clone()
            id_: new_id(),
        }
    }
}

impl<T> IsFiniteOp<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
{
    pub fn new(inner: Rc<IsFinite<T>>) -> Self {
        Self{inner}
    }

    pub fn y(&self) -> Edge<bool> {
        Edge::<bool>::new(self.inner.clone(), 0)
    }
}

struct IsFiniteOp<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
{
    inner: Rc<IsFinite<T>>,
}

impl<T> GraphOperation for IsFinite<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("IsFinite_{}")?
        };
        let mut new_op = graph.new_operation("IsFinite", &op_name)?;
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct IsFinite<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
{
    x: Edge<T>,
    id_: usize,
}

impl<T> IsFinite<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
{
    pub fn finish(self) -> IsFiniteOp<T> {
        IsFiniteOp::new(Rc::new(self))
    }

    pub fn new(x: Edge<T>) -> Self {
        Self {
            x,
            id_: new_id(),
        }
    }
}

impl<T> GuaranteeConstOp<T>
where T: con,
{
    pub fn new(inner: Rc<GuaranteeConst<T>>) -> Self {
        Self{inner}
    }

    pub fn output(&self) -> Edge<T> {
        Edge::<T>::new(self.inner.clone(), 0)
    }
}

struct GuaranteeConstOp<T>
where T: con,
{
    inner: Rc<GuaranteeConst<T>>,
}

impl<T> GraphOperation for GuaranteeConst<T>
where T: con,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("GuaranteeConst_{}")?
        };
        let mut new_op = graph.new_operation("GuaranteeConst", &op_name)?;
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct GuaranteeConst<T>
where T: con,
{
    input: Edge<T>,
    id_: usize,
}

impl<T> GuaranteeConst<T>
where T: con,
{
    pub fn finish(self) -> GuaranteeConstOp<T> {
        GuaranteeConstOp::new(Rc::new(self))
    }

    pub fn new(input: Edge<T>) -> Self {
        Self {
            input,
            id_: new_id(),
        }
    }
}

impl<Tparams, Tindices> GatherNdOp<Tparams, Tindices>
where Tparams: con,
      Tindices: con_or_DT_INT32_or_DT_INT64,
{
    pub fn new(inner: Rc<GatherNd<Tparams, Tindices>>) -> Self {
        Self{inner}
    }

    pub fn output(&self) -> Edge<Tparams> {
        Edge::<Tparams>::new(self.inner.clone(), 0)
    }
}

struct GatherNdOp<Tparams, Tindices>
where Tparams: con,
      Tindices: con_or_DT_INT32_or_DT_INT64,
{
    inner: Rc<GatherNd<Tparams, Tindices>>,
}

impl<Tparams, Tindices> GraphOperation for GatherNd<Tparams, Tindices>
where Tparams: con,
      Tindices: con_or_DT_INT32_or_DT_INT64,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("GatherNd_{}")?
        };
        let mut new_op = graph.new_operation("GatherNd", &op_name)?;
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct GatherNd<Tparams, Tindices>
where Tparams: con,
      Tindices: con_or_DT_INT32_or_DT_INT64,
{
    params: Edge<Tparams>,
    indices: Edge<Tindices>,
    id_: usize,
}

impl<Tparams, Tindices> GatherNd<Tparams, Tindices>
where Tparams: con,
      Tindices: con_or_DT_INT32_or_DT_INT64,
{
    pub fn finish(self) -> GatherNdOp<Tparams, Tindices> {
        GatherNdOp::new(Rc::new(self))
    }

    pub fn new(params: Edge<Tparams>, indices: Edge<Tindices>) -> Self {
        Self {
            params,
            indices,
            id_: new_id(),
        }
    }
}

impl<T, out_idx> UniqueWithCountsOp<T, out_idx>
where T: con,
      out_idx: con_or_DT_INT32_or_DT_INT64,
{
    pub fn new(inner: Rc<UniqueWithCounts<T, out_idx>>) -> Self {
        Self{inner}
    }

    pub fn y(&self) -> Edge<T> {
        Edge::<T>::new(self.inner.clone(), 0)
    }

    pub fn idx(&self) -> Edge<out_idx> {
        Edge::<out_idx>::new(self.inner.clone(), 1)
    }

    pub fn count(&self) -> Edge<out_idx> {
        Edge::<out_idx>::new(self.inner.clone(), 2)
    }
}

struct UniqueWithCountsOp<T, out_idx>
where T: con,
      out_idx: con_or_DT_INT32_or_DT_INT64,
{
    inner: Rc<UniqueWithCounts<T, out_idx>>,
}

impl<T, out_idx> GraphOperation for UniqueWithCounts<T, out_idx>
where T: con,
      out_idx: con_or_DT_INT32_or_DT_INT64,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("UniqueWithCounts_{}")?
        };
        let mut new_op = graph.new_operation("UniqueWithCounts", &op_name)?;
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct UniqueWithCounts<T, out_idx>
where T: con,
      out_idx: con_or_DT_INT32_or_DT_INT64,
{
    x: Edge<T>,
    id_: usize,
}

impl<T, out_idx> UniqueWithCounts<T, out_idx>
where T: con,
      out_idx: con_or_DT_INT32_or_DT_INT64,
{
    pub fn finish(self) -> UniqueWithCountsOp<T, out_idx> {
        UniqueWithCountsOp::new(Rc::new(self))
    }

    pub fn new(x: Edge<T>) -> Self {
        Self {
            x,
            id_: new_id(),
        }
    }
}

impl<T, out_idx> ListDiffOp<T, out_idx>
where T: con,
      out_idx: con_or_DT_INT32_or_DT_INT64,
{
    pub fn new(inner: Rc<ListDiff<T, out_idx>>) -> Self {
        Self{inner}
    }

    pub fn out(&self) -> Edge<T> {
        Edge::<T>::new(self.inner.clone(), 0)
    }

    pub fn idx(&self) -> Edge<out_idx> {
        Edge::<out_idx>::new(self.inner.clone(), 1)
    }
}

struct ListDiffOp<T, out_idx>
where T: con,
      out_idx: con_or_DT_INT32_or_DT_INT64,
{
    inner: Rc<ListDiff<T, out_idx>>,
}

impl<T, out_idx> GraphOperation for ListDiff<T, out_idx>
where T: con,
      out_idx: con_or_DT_INT32_or_DT_INT64,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("ListDiff_{}")?
        };
        let mut new_op = graph.new_operation("ListDiff", &op_name)?;
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct ListDiff<T, out_idx>
where T: con,
      out_idx: con_or_DT_INT32_or_DT_INT64,
{
    x: Edge<T>,
    y: Edge<T>,
    id_: usize,
}

impl<T, out_idx> ListDiff<T, out_idx>
where T: con,
      out_idx: con_or_DT_INT32_or_DT_INT64,
{
    pub fn finish(self) -> ListDiffOp<T, out_idx> {
        ListDiffOp::new(Rc::new(self))
    }

    pub fn new(x: Edge<T>, y: Edge<T>) -> Self {
        Self {
            x,
            y,
            id_: new_id(),
        }
    }
}

impl LoadTPUEmbeddingAdadeltaParametersGradAccumDebugOp {
    pub fn new(inner: Rc<LoadTPUEmbeddingAdadeltaParametersGradAccumDebug>) -> Self {
        Self{inner}
    }
}

struct LoadTPUEmbeddingAdadeltaParametersGradAccumDebugOp {
    inner: Rc<LoadTPUEmbeddingAdadeltaParametersGradAccumDebug>,
}

impl GraphOperation for LoadTPUEmbeddingAdadeltaParametersGradAccumDebug {
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("LoadTPUEmbeddingAdadeltaParametersGradAccumDebug_{}")?
        };
        let mut new_op = graph.new_operation("LoadTPUEmbeddingAdadeltaParametersGradAccumDebug", &op_name)?;
        {
            match self.table_id {
            }
            None => new_op.set_attr_value_proto("table_id", &vec![24_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 1_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_int("table_id", *attr)})(&value),
        };
        {
            match self.table_name {
            }
            None => new_op.set_attr_value_proto("table_name", &vec![18_u8, 0_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_string("table_name", attr)})(&value),
        };
        {
            (|attr| {new_op.set_attr_int("num_shards", *attr)})(&self.num_shards)
        }
        {
            (|attr| {new_op.set_attr_int("shard_id", *attr)})(&self.shard_id)
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct LoadTPUEmbeddingAdadeltaParametersGradAccumDebug {
    parameters: Edge<f32>,
    accumulators: Edge<f32>,
    updates: Edge<f32>,
    gradient_accumulators: Edge<f32>,
    table_id: Option<i64>,
    table_name: Option<String>,
    num_shards: i64,
    shard_id: i64,
    id_: usize,
}

impl LoadTPUEmbeddingAdadeltaParametersGradAccumDebug {
    pub fn table_id(&mut self, table_id: int) -> &mut Self {
        self.table_id = Some(table_id);
        &self
    }

    pub fn table_name(&mut self, table_name: &str) -> &mut Self {
        self.table_name = Some(table_name.to_string());
        &self
    }

    pub fn finish(self) -> LoadTPUEmbeddingAdadeltaParametersGradAccumDebugOp {
        LoadTPUEmbeddingAdadeltaParametersGradAccumDebugOp::new(Rc::new(self))
    }

    pub fn new(parameters: Edge<f32>, accumulators: Edge<f32>, updates: Edge<f32>, gradient_accumulators: Edge<f32>, num_shards: int, shard_id: int) -> Self {
        Self {
            parameters,
            accumulators,
            updates,
            gradient_accumulators,
            table_id: None,
            table_name: None,
            num_shards: num_shards
            shard_id: shard_id
            id_: new_id(),
        }
    }
}

impl<T, Tidx> BroadcastToOp<T, Tidx>
where T: con,
      Tidx: con_or_DT_INT32_or_DT_INT64,
{
    pub fn new(inner: Rc<BroadcastTo<T, Tidx>>) -> Self {
        Self{inner}
    }

    pub fn output(&self) -> Edge<T> {
        Edge::<T>::new(self.inner.clone(), 0)
    }
}

struct BroadcastToOp<T, Tidx>
where T: con,
      Tidx: con_or_DT_INT32_or_DT_INT64,
{
    inner: Rc<BroadcastTo<T, Tidx>>,
}

impl<T, Tidx> GraphOperation for BroadcastTo<T, Tidx>
where T: con,
      Tidx: con_or_DT_INT32_or_DT_INT64,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("BroadcastTo_{}")?
        };
        let mut new_op = graph.new_operation("BroadcastTo", &op_name)?;
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct BroadcastTo<T, Tidx>
where T: con,
      Tidx: con_or_DT_INT32_or_DT_INT64,
{
    input: Edge<T>,
    shape: Edge<Tidx>,
    id_: usize,
}

impl<T, Tidx> BroadcastTo<T, Tidx>
where T: con,
      Tidx: con_or_DT_INT32_or_DT_INT64,
{
    pub fn finish(self) -> BroadcastToOp<T, Tidx> {
        BroadcastToOp::new(Rc::new(self))
    }

    pub fn new(input: Edge<T>, shape: Edge<Tidx>) -> Self {
        Self {
            input,
            shape,
            id_: new_id(),
        }
    }
}

impl<T> DebugNumericSummaryOp<T>
where T: con,
{
    pub fn new(inner: Rc<DebugNumericSummary<T>>) -> Self {
        Self{inner}
    }

    pub fn output(&self) -> Edge<f64> {
        Edge::<f64>::new(self.inner.clone(), 0)
    }
}

struct DebugNumericSummaryOp<T>
where T: con,
{
    inner: Rc<DebugNumericSummary<T>>,
}

impl<T> GraphOperation for DebugNumericSummary<T>
where T: con,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("DebugNumericSummary_{}")?
        };
        let mut new_op = graph.new_operation("DebugNumericSummary", &op_name)?;
        {
            match self.device_name {
            }
            None => new_op.set_attr_value_proto("device_name", &vec![18_u8, 0_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_string("device_name", attr)})(&value),
        };
        {
            match self.tensor_name {
            }
            None => new_op.set_attr_value_proto("tensor_name", &vec![18_u8, 0_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_string("tensor_name", attr)})(&value),
        };
        {
            match self.debug_urls {
            }
            None => new_op.set_attr_value_proto("debug_urls", &vec![10_u8, 0_u8,]);,
            Some(value) => (|attrs| {new_op.set_attr_string_list("debug_urls", attrs)})(&value),
        };
        {
            match self.lower_bound {
            }
            None => new_op.set_attr_value_proto("lower_bound", &vec![37_u8, 0_u8, 0_u8, 128_u8, 255_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_float("lower_bound", *attr)})(&value),
        };
        {
            match self.upper_bound {
            }
            None => new_op.set_attr_value_proto("upper_bound", &vec![37_u8, 0_u8, 0_u8, 128_u8, 127_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_float("upper_bound", *attr)})(&value),
        };
        {
            match self.mute_if_healthy {
            }
            None => new_op.set_attr_value_proto("mute_if_healthy", &vec![40_u8, 0_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_bool("mute_if_healthy", *attr)})(&value),
        };
        {
            match self.gated_grpc {
            }
            None => new_op.set_attr_value_proto("gated_grpc", &vec![40_u8, 0_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_bool("gated_grpc", *attr)})(&value),
        };
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct DebugNumericSummary<T>
where T: con,
{
    input: Edge<T>,
    device_name: Option<String>,
    tensor_name: Option<String>,
    debug_urls: Option<Vec<String>>,
    lower_bound: Option<f32>,
    upper_bound: Option<f32>,
    mute_if_healthy: Option<bool>,
    gated_grpc: Option<bool>,
    id_: usize,
}

impl<T> DebugNumericSummary<T>
where T: con,
{
    pub fn device_name(&mut self, device_name: &str) -> &mut Self {
        self.device_name = Some(device_name.to_string());
        &self
    }

    pub fn tensor_name(&mut self, tensor_name: &str) -> &mut Self {
        self.tensor_name = Some(tensor_name.to_string());
        &self
    }

    pub fn debug_urls(&mut self, debug_urls: &[String]) -> &mut Self {
        self.debug_urls = Some(debug_urls.to_vec());
        &self
    }

    pub fn lower_bound(&mut self, lower_bound: f32) -> &mut Self {
        self.lower_bound = Some(lower_bound);
        &self
    }

    pub fn upper_bound(&mut self, upper_bound: f32) -> &mut Self {
        self.upper_bound = Some(upper_bound);
        &self
    }

    pub fn mute_if_healthy(&mut self, mute_if_healthy: bool) -> &mut Self {
        self.mute_if_healthy = Some(mute_if_healthy);
        &self
    }

    pub fn gated_grpc(&mut self, gated_grpc: bool) -> &mut Self {
        self.gated_grpc = Some(gated_grpc);
        &self
    }

    pub fn finish(self) -> DebugNumericSummaryOp<T> {
        DebugNumericSummaryOp::new(Rc::new(self))
    }

    pub fn new(input: Edge<T>) -> Self {
        Self {
            input,
            device_name: None,
            tensor_name: None,
            debug_urls: None,
            lower_bound: None,
            upper_bound: None,
            mute_if_healthy: None,
            gated_grpc: None,
            id_: new_id(),
        }
    }
}

impl<T> AddSparseToTensorsMapOp<T>
where T: con,
{
    pub fn new(inner: Rc<AddSparseToTensorsMap<T>>) -> Self {
        Self{inner}
    }

    pub fn sparse_handle(&self) -> Edge<i64> {
        Edge::<i64>::new(self.inner.clone(), 0)
    }
}

struct AddSparseToTensorsMapOp<T>
where T: con,
{
    inner: Rc<AddSparseToTensorsMap<T>>,
}

impl<T> GraphOperation for AddSparseToTensorsMap<T>
where T: con,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("AddSparseToTensorsMap_{}")?
        };
        let mut new_op = graph.new_operation("AddSparseToTensorsMap", &op_name)?;
        {
            match self.container {
            }
            None => new_op.set_attr_value_proto("container", &vec![18_u8, 0_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_string("container", attr)})(&value),
        };
        {
            match self.shared_name {
            }
            None => new_op.set_attr_value_proto("shared_name", &vec![18_u8, 0_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_string("shared_name", attr)})(&value),
        };
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct AddSparseToTensorsMap<T>
where T: con,
{
    sparse_indices: Edge<i64>,
    sparse_values: Edge<T>,
    sparse_shape: Edge<i64>,
    container: Option<String>,
    shared_name: Option<String>,
    id_: usize,
}

impl<T> AddSparseToTensorsMap<T>
where T: con,
{
    pub fn container(&mut self, container: &str) -> &mut Self {
        self.container = Some(container.to_string());
        &self
    }

    pub fn shared_name(&mut self, shared_name: &str) -> &mut Self {
        self.shared_name = Some(shared_name.to_string());
        &self
    }

    pub fn finish(self) -> AddSparseToTensorsMapOp<T> {
        AddSparseToTensorsMapOp::new(Rc::new(self))
    }

    pub fn new(sparse_indices: Edge<i64>, sparse_values: Edge<T>, sparse_shape: Edge<i64>) -> Self {
        Self {
            sparse_indices,
            sparse_values,
            sparse_shape,
            container: None,
            shared_name: None,
            id_: new_id(),
        }
    }
}

impl<T> Dilation2DBackpropFilterOp<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
{
    pub fn new(inner: Rc<Dilation2DBackpropFilter<T>>) -> Self {
        Self{inner}
    }

    pub fn filter_backprop(&self) -> Edge<T> {
        Edge::<T>::new(self.inner.clone(), 0)
    }
}

struct Dilation2DBackpropFilterOp<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
{
    inner: Rc<Dilation2DBackpropFilter<T>>,
}

impl<T> GraphOperation for Dilation2DBackpropFilter<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("Dilation2DBackpropFilter_{}")?
        };
        let mut new_op = graph.new_operation("Dilation2DBackpropFilter", &op_name)?;
        {
            (|attrs| {new_op.set_attr_int_list("strides", attrs)})(&self.strides)
        }
        {
            (|attrs| {new_op.set_attr_int_list("rates", attrs)})(&self.rates)
        }
        {
            (|attr| {new_op.set_attr_string("padding", attr)})(&self.padding)
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct Dilation2DBackpropFilter<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
{
    input: Edge<T>,
    filter: Edge<T>,
    out_backprop: Edge<T>,
    strides: Vec<i64>,
    rates: Vec<i64>,
    padding: String,
    id_: usize,
}

impl<T> Dilation2DBackpropFilter<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
{
    pub fn finish(self) -> Dilation2DBackpropFilterOp<T> {
        Dilation2DBackpropFilterOp::new(Rc::new(self))
    }

    pub fn new(input: Edge<T>, filter: Edge<T>, out_backprop: Edge<T>, strides: &[int], rates: &[int], padding: &str) -> Self {
        Self {
            input,
            filter,
            out_backprop,
            strides: strides.to_vec()
            rates: rates.to_vec()
            padding: padding.to_string()
            id_: new_id(),
        }
    }
}

impl<T, Tindices> ScatterSubOp<T, Tindices>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      Tindices: con_or_DT_INT32_or_DT_INT64,
{
    pub fn new(inner: Rc<ScatterSub<T, Tindices>>) -> Self {
        Self{inner}
    }

    pub fn output_ref(&self) -> Edge<T> {
        Edge::<T>::new(self.inner.clone(), 0)
    }
}

struct ScatterSubOp<T, Tindices>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      Tindices: con_or_DT_INT32_or_DT_INT64,
{
    inner: Rc<ScatterSub<T, Tindices>>,
}

impl<T, Tindices> GraphOperation for ScatterSub<T, Tindices>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      Tindices: con_or_DT_INT32_or_DT_INT64,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("ScatterSub_{}")?
        };
        let mut new_op = graph.new_operation("ScatterSub", &op_name)?;
        {
            match self.use_locking {
            }
            None => new_op.set_attr_value_proto("use_locking", &vec![40_u8, 0_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_bool("use_locking", *attr)})(&value),
        };
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct ScatterSub<T, Tindices>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      Tindices: con_or_DT_INT32_or_DT_INT64,
{
    ref_: Edge<T>,
    indices: Edge<Tindices>,
    updates: Edge<T>,
    use_locking: Option<bool>,
    id_: usize,
}

impl<T, Tindices> ScatterSub<T, Tindices>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      Tindices: con_or_DT_INT32_or_DT_INT64,
{
    pub fn use_locking(&mut self, use_locking: bool) -> &mut Self {
        self.use_locking = Some(use_locking);
        &self
    }

    pub fn finish(self) -> ScatterSubOp<T, Tindices> {
        ScatterSubOp::new(Rc::new(self))
    }

    pub fn new(ref_: Edge<T>, indices: Edge<Tindices>, updates: Edge<T>) -> Self {
        Self {
            ref_,
            indices,
            updates,
            use_locking: None,
            id_: new_id(),
        }
    }
}

impl<T> CudnnRNNBackpropOp<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_HALF,
{
    pub fn new(inner: Rc<CudnnRNNBackprop<T>>) -> Self {
        Self{inner}
    }

    pub fn input_backprop(&self) -> Edge<T> {
        Edge::<T>::new(self.inner.clone(), 0)
    }

    pub fn input_h_backprop(&self) -> Edge<T> {
        Edge::<T>::new(self.inner.clone(), 1)
    }

    pub fn input_c_backprop(&self) -> Edge<T> {
        Edge::<T>::new(self.inner.clone(), 2)
    }

    pub fn params_backprop(&self) -> Edge<T> {
        Edge::<T>::new(self.inner.clone(), 3)
    }
}

struct CudnnRNNBackpropOp<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_HALF,
{
    inner: Rc<CudnnRNNBackprop<T>>,
}

impl<T> GraphOperation for CudnnRNNBackprop<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_HALF,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("CudnnRNNBackprop_{}")?
        };
        let mut new_op = graph.new_operation("CudnnRNNBackprop", &op_name)?;
        {
            match self.rnn_mode {
            }
            None => new_op.set_attr_value_proto("rnn_mode", &vec![18_u8, 4_u8, 108_u8, 115_u8, 116_u8, 109_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_string("rnn_mode", attr)})(&value),
        };
        {
            match self.input_mode {
            }
            None => new_op.set_attr_value_proto("input_mode", &vec![18_u8, 12_u8, 108_u8, 105_u8, 110_u8, 101_u8, 97_u8, 114_u8, 95_u8, 105_u8, 110_u8, 112_u8, 117_u8, 116_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_string("input_mode", attr)})(&value),
        };
        {
            match self.direction {
            }
            None => new_op.set_attr_value_proto("direction", &vec![18_u8, 14_u8, 117_u8, 110_u8, 105_u8, 100_u8, 105_u8, 114_u8, 101_u8, 99_u8, 116_u8, 105_u8, 111_u8, 110_u8, 97_u8, 108_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_string("direction", attr)})(&value),
        };
        {
            match self.dropout {
            }
            None => new_op.set_attr_value_proto("dropout", &vec![37_u8, 0_u8, 0_u8, 0_u8, 0_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_float("dropout", *attr)})(&value),
        };
        {
            match self.seed {
            }
            None => new_op.set_attr_value_proto("seed", &vec![24_u8, 0_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_int("seed", *attr)})(&value),
        };
        {
            match self.seed2 {
            }
            None => new_op.set_attr_value_proto("seed2", &vec![24_u8, 0_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_int("seed2", *attr)})(&value),
        };
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct CudnnRNNBackprop<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_HALF,
{
    input: Edge<T>,
    input_h: Edge<T>,
    input_c: Edge<T>,
    params: Edge<T>,
    output: Edge<T>,
    output_h: Edge<T>,
    output_c: Edge<T>,
    output_backprop: Edge<T>,
    output_h_backprop: Edge<T>,
    output_c_backprop: Edge<T>,
    reserve_space: Edge<T>,
    rnn_mode: Option<String>,
    input_mode: Option<String>,
    direction: Option<String>,
    dropout: Option<f32>,
    seed: Option<i64>,
    seed2: Option<i64>,
    id_: usize,
}

impl<T> CudnnRNNBackprop<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_HALF,
{
    pub fn rnn_mode(&mut self, rnn_mode: &str) -> &mut Self {
        self.rnn_mode = Some(rnn_mode.to_string());
        &self
    }

    pub fn input_mode(&mut self, input_mode: &str) -> &mut Self {
        self.input_mode = Some(input_mode.to_string());
        &self
    }

    pub fn direction(&mut self, direction: &str) -> &mut Self {
        self.direction = Some(direction.to_string());
        &self
    }

    pub fn dropout(&mut self, dropout: f32) -> &mut Self {
        self.dropout = Some(dropout);
        &self
    }

    pub fn seed(&mut self, seed: int) -> &mut Self {
        self.seed = Some(seed);
        &self
    }

    pub fn seed2(&mut self, seed2: int) -> &mut Self {
        self.seed2 = Some(seed2);
        &self
    }

    pub fn finish(self) -> CudnnRNNBackpropOp<T> {
        CudnnRNNBackpropOp::new(Rc::new(self))
    }

    pub fn new(input: Edge<T>, input_h: Edge<T>, input_c: Edge<T>, params: Edge<T>, output: Edge<T>, output_h: Edge<T>, output_c: Edge<T>, output_backprop: Edge<T>, output_h_backprop: Edge<T>, output_c_backprop: Edge<T>, reserve_space: Edge<T>) -> Self {
        Self {
            input,
            input_h,
            input_c,
            params,
            output,
            output_h,
            output_c,
            output_backprop,
            output_h_backprop,
            output_c_backprop,
            reserve_space,
            rnn_mode: None,
            input_mode: None,
            direction: None,
            dropout: None,
            seed: None,
            seed2: None,
            id_: new_id(),
        }
    }
}

impl<dtype> InfeedEnqueueOp<dtype>
where dtype: con,
{
    pub fn new(inner: Rc<InfeedEnqueue<dtype>>) -> Self {
        Self{inner}
    }
}

struct InfeedEnqueueOp<dtype>
where dtype: con,
{
    inner: Rc<InfeedEnqueue<dtype>>,
}

impl<dtype> GraphOperation for InfeedEnqueue<dtype>
where dtype: con,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("InfeedEnqueue_{}")?
        };
        let mut new_op = graph.new_operation("InfeedEnqueue", &op_name)?;
        {
            match self.shape {
            }
            None => new_op.set_attr_value_proto("shape", &vec![58_u8, 0_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_shape("shape", attr)})(&value),
        };
        {
            match self.device_ordinal {
            }
            None => new_op.set_attr_value_proto("device_ordinal", &vec![24_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 1_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_int("device_ordinal", *attr)})(&value),
        };
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct InfeedEnqueue<dtype>
where dtype: con,
{
    input: Edge<dtype>,
    shape: Option<Shape>,
    device_ordinal: Option<i64>,
    id_: usize,
}

impl<dtype> InfeedEnqueue<dtype>
where dtype: con,
{
    pub fn shape(&mut self, shape: &Shape) -> &mut Self {
        self.shape = Some(shape.clone());
        &self
    }

    pub fn device_ordinal(&mut self, device_ordinal: int) -> &mut Self {
        self.device_ordinal = Some(device_ordinal);
        &self
    }

    pub fn finish(self) -> InfeedEnqueueOp<dtype> {
        InfeedEnqueueOp::new(Rc::new(self))
    }

    pub fn new(input: Edge<dtype>) -> Self {
        Self {
            input,
            shape: None,
            device_ordinal: None,
            id_: new_id(),
        }
    }
}

impl PrintV2Op {
    pub fn new(inner: Rc<PrintV2>) -> Self {
        Self{inner}
    }
}

struct PrintV2Op {
    inner: Rc<PrintV2>,
}

impl GraphOperation for PrintV2 {
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("PrintV2_{}")?
        };
        let mut new_op = graph.new_operation("PrintV2", &op_name)?;
        {
            match self.output_stream {
            }
            None => new_op.set_attr_value_proto("output_stream", &vec![18_u8, 6_u8, 115_u8, 116_u8, 100_u8, 101_u8, 114_u8, 114_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_string("output_stream", attr)})(&value),
        };
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct PrintV2 {
    input: Edge<String>,
    output_stream: Option<String>,
    id_: usize,
}

impl PrintV2 {
    pub fn output_stream(&mut self, output_stream: &str) -> &mut Self {
        self.output_stream = Some(output_stream.to_string());
        &self
    }

    pub fn finish(self) -> PrintV2Op {
        PrintV2Op::new(Rc::new(self))
    }

    pub fn new(input: Edge<String>) -> Self {
        Self {
            input,
            output_stream: None,
            id_: new_id(),
        }
    }
}

impl RetrieveTPUEmbeddingFTRLParametersOp {
    pub fn new(inner: Rc<RetrieveTPUEmbeddingFTRLParameters>) -> Self {
        Self{inner}
    }

    pub fn parameters(&self) -> Edge<f32> {
        Edge::<f32>::new(self.inner.clone(), 0)
    }

    pub fn accumulators(&self) -> Edge<f32> {
        Edge::<f32>::new(self.inner.clone(), 1)
    }

    pub fn linears(&self) -> Edge<f32> {
        Edge::<f32>::new(self.inner.clone(), 2)
    }
}

struct RetrieveTPUEmbeddingFTRLParametersOp {
    inner: Rc<RetrieveTPUEmbeddingFTRLParameters>,
}

impl GraphOperation for RetrieveTPUEmbeddingFTRLParameters {
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("RetrieveTPUEmbeddingFTRLParameters_{}")?
        };
        let mut new_op = graph.new_operation("RetrieveTPUEmbeddingFTRLParameters", &op_name)?;
        {
            match self.table_id {
            }
            None => new_op.set_attr_value_proto("table_id", &vec![24_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 1_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_int("table_id", *attr)})(&value),
        };
        {
            match self.table_name {
            }
            None => new_op.set_attr_value_proto("table_name", &vec![18_u8, 0_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_string("table_name", attr)})(&value),
        };
        {
            (|attr| {new_op.set_attr_int("num_shards", *attr)})(&self.num_shards)
        }
        {
            (|attr| {new_op.set_attr_int("shard_id", *attr)})(&self.shard_id)
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct RetrieveTPUEmbeddingFTRLParameters {
    table_id: Option<i64>,
    table_name: Option<String>,
    num_shards: i64,
    shard_id: i64,
    id_: usize,
}

impl RetrieveTPUEmbeddingFTRLParameters {
    pub fn table_id(&mut self, table_id: int) -> &mut Self {
        self.table_id = Some(table_id);
        &self
    }

    pub fn table_name(&mut self, table_name: &str) -> &mut Self {
        self.table_name = Some(table_name.to_string());
        &self
    }

    pub fn finish(self) -> RetrieveTPUEmbeddingFTRLParametersOp {
        RetrieveTPUEmbeddingFTRLParametersOp::new(Rc::new(self))
    }

    pub fn new(num_shards: int, shard_id: int) -> Self {
        Self {
            table_id: None,
            table_name: None,
            num_shards: num_shards
            shard_id: shard_id
            id_: new_id(),
        }
    }
}

impl<T> DebugNanCountOp<T>
where T: con,
{
    pub fn new(inner: Rc<DebugNanCount<T>>) -> Self {
        Self{inner}
    }

    pub fn output(&self) -> Edge<i64> {
        Edge::<i64>::new(self.inner.clone(), 0)
    }
}

struct DebugNanCountOp<T>
where T: con,
{
    inner: Rc<DebugNanCount<T>>,
}

impl<T> GraphOperation for DebugNanCount<T>
where T: con,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("DebugNanCount_{}")?
        };
        let mut new_op = graph.new_operation("DebugNanCount", &op_name)?;
        {
            match self.device_name {
            }
            None => new_op.set_attr_value_proto("device_name", &vec![18_u8, 0_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_string("device_name", attr)})(&value),
        };
        {
            match self.tensor_name {
            }
            None => new_op.set_attr_value_proto("tensor_name", &vec![18_u8, 0_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_string("tensor_name", attr)})(&value),
        };
        {
            match self.debug_urls {
            }
            None => new_op.set_attr_value_proto("debug_urls", &vec![10_u8, 0_u8,]);,
            Some(value) => (|attrs| {new_op.set_attr_string_list("debug_urls", attrs)})(&value),
        };
        {
            match self.gated_grpc {
            }
            None => new_op.set_attr_value_proto("gated_grpc", &vec![40_u8, 0_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_bool("gated_grpc", *attr)})(&value),
        };
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct DebugNanCount<T>
where T: con,
{
    input: Edge<T>,
    device_name: Option<String>,
    tensor_name: Option<String>,
    debug_urls: Option<Vec<String>>,
    gated_grpc: Option<bool>,
    id_: usize,
}

impl<T> DebugNanCount<T>
where T: con,
{
    pub fn device_name(&mut self, device_name: &str) -> &mut Self {
        self.device_name = Some(device_name.to_string());
        &self
    }

    pub fn tensor_name(&mut self, tensor_name: &str) -> &mut Self {
        self.tensor_name = Some(tensor_name.to_string());
        &self
    }

    pub fn debug_urls(&mut self, debug_urls: &[String]) -> &mut Self {
        self.debug_urls = Some(debug_urls.to_vec());
        &self
    }

    pub fn gated_grpc(&mut self, gated_grpc: bool) -> &mut Self {
        self.gated_grpc = Some(gated_grpc);
        &self
    }

    pub fn finish(self) -> DebugNanCountOp<T> {
        DebugNanCountOp::new(Rc::new(self))
    }

    pub fn new(input: Edge<T>) -> Self {
        Self {
            input,
            device_name: None,
            tensor_name: None,
            debug_urls: None,
            gated_grpc: None,
            id_: new_id(),
        }
    }
}

impl<T> ApplyRMSPropOp<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
{
    pub fn new(inner: Rc<ApplyRMSProp<T>>) -> Self {
        Self{inner}
    }

    pub fn out(&self) -> Edge<T> {
        Edge::<T>::new(self.inner.clone(), 0)
    }
}

struct ApplyRMSPropOp<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
{
    inner: Rc<ApplyRMSProp<T>>,
}

impl<T> GraphOperation for ApplyRMSProp<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("ApplyRMSProp_{}")?
        };
        let mut new_op = graph.new_operation("ApplyRMSProp", &op_name)?;
        {
            match self.use_locking {
            }
            None => new_op.set_attr_value_proto("use_locking", &vec![40_u8, 0_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_bool("use_locking", *attr)})(&value),
        };
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct ApplyRMSProp<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
{
    var: Edge<T>,
    ms: Edge<T>,
    mom: Edge<T>,
    lr: Edge<T>,
    rho: Edge<T>,
    momentum: Edge<T>,
    epsilon: Edge<T>,
    grad: Edge<T>,
    use_locking: Option<bool>,
    id_: usize,
}

impl<T> ApplyRMSProp<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
{
    pub fn use_locking(&mut self, use_locking: bool) -> &mut Self {
        self.use_locking = Some(use_locking);
        &self
    }

    pub fn finish(self) -> ApplyRMSPropOp<T> {
        ApplyRMSPropOp::new(Rc::new(self))
    }

    pub fn new(var: Edge<T>, ms: Edge<T>, mom: Edge<T>, lr: Edge<T>, rho: Edge<T>, momentum: Edge<T>, epsilon: Edge<T>, grad: Edge<T>) -> Self {
        Self {
            var,
            ms,
            mom,
            lr,
            rho,
            momentum,
            epsilon,
            grad,
            use_locking: None,
            id_: new_id(),
        }
    }
}

impl FakeQuantWithMinMaxVarsOp {
    pub fn new(inner: Rc<FakeQuantWithMinMaxVars>) -> Self {
        Self{inner}
    }

    pub fn outputs(&self) -> Edge<f32> {
        Edge::<f32>::new(self.inner.clone(), 0)
    }
}

struct FakeQuantWithMinMaxVarsOp {
    inner: Rc<FakeQuantWithMinMaxVars>,
}

impl GraphOperation for FakeQuantWithMinMaxVars {
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("FakeQuantWithMinMaxVars_{}")?
        };
        let mut new_op = graph.new_operation("FakeQuantWithMinMaxVars", &op_name)?;
        {
            match self.num_bits {
            }
            None => new_op.set_attr_value_proto("num_bits", &vec![24_u8, 8_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_int("num_bits", *attr)})(&value),
        };
        {
            match self.narrow_range {
            }
            None => new_op.set_attr_value_proto("narrow_range", &vec![40_u8, 0_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_bool("narrow_range", *attr)})(&value),
        };
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct FakeQuantWithMinMaxVars {
    inputs: Edge<f32>,
    min: Edge<f32>,
    max: Edge<f32>,
    num_bits: Option<i64>,
    narrow_range: Option<bool>,
    id_: usize,
}

impl FakeQuantWithMinMaxVars {
    pub fn num_bits(&mut self, num_bits: int) -> &mut Self {
        self.num_bits = Some(num_bits);
        &self
    }

    pub fn narrow_range(&mut self, narrow_range: bool) -> &mut Self {
        self.narrow_range = Some(narrow_range);
        &self
    }

    pub fn finish(self) -> FakeQuantWithMinMaxVarsOp {
        FakeQuantWithMinMaxVarsOp::new(Rc::new(self))
    }

    pub fn new(inputs: Edge<f32>, min: Edge<f32>, max: Edge<f32>) -> Self {
        Self {
            inputs,
            min,
            max,
            num_bits: None,
            narrow_range: None,
            id_: new_id(),
        }
    }
}

impl<T, Tidx, output_type> ArgMaxOp<T, Tidx, output_type>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      Tidx: con_or_DT_INT32_or_DT_INT64,
      output_type: con_or_DT_INT32_or_DT_INT64,
{
    pub fn new(inner: Rc<ArgMax<T, Tidx, output_type>>) -> Self {
        Self{inner}
    }

    pub fn output(&self) -> Edge<output_type> {
        Edge::<output_type>::new(self.inner.clone(), 0)
    }
}

struct ArgMaxOp<T, Tidx, output_type>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      Tidx: con_or_DT_INT32_or_DT_INT64,
      output_type: con_or_DT_INT32_or_DT_INT64,
{
    inner: Rc<ArgMax<T, Tidx, output_type>>,
}

impl<T, Tidx, output_type> GraphOperation for ArgMax<T, Tidx, output_type>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      Tidx: con_or_DT_INT32_or_DT_INT64,
      output_type: con_or_DT_INT32_or_DT_INT64,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("ArgMax_{}")?
        };
        let mut new_op = graph.new_operation("ArgMax", &op_name)?;
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct ArgMax<T, Tidx, output_type>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      Tidx: con_or_DT_INT32_or_DT_INT64,
      output_type: con_or_DT_INT32_or_DT_INT64,
{
    input: Edge<T>,
    dimension: Edge<Tidx>,
    id_: usize,
}

impl<T, Tidx, output_type> ArgMax<T, Tidx, output_type>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      Tidx: con_or_DT_INT32_or_DT_INT64,
      output_type: con_or_DT_INT32_or_DT_INT64,
{
    pub fn finish(self) -> ArgMaxOp<T, Tidx, output_type> {
        ArgMaxOp::new(Rc::new(self))
    }

    pub fn new(input: Edge<T>, dimension: Edge<Tidx>) -> Self {
        Self {
            input,
            dimension,
            id_: new_id(),
        }
    }
}

impl<T> FractionalMaxPoolOp<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_INT64,
{
    pub fn new(inner: Rc<FractionalMaxPool<T>>) -> Self {
        Self{inner}
    }

    pub fn output(&self) -> Edge<T> {
        Edge::<T>::new(self.inner.clone(), 0)
    }

    pub fn row_pooling_sequence(&self) -> Edge<i64> {
        Edge::<i64>::new(self.inner.clone(), 1)
    }

    pub fn col_pooling_sequence(&self) -> Edge<i64> {
        Edge::<i64>::new(self.inner.clone(), 2)
    }
}

struct FractionalMaxPoolOp<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_INT64,
{
    inner: Rc<FractionalMaxPool<T>>,
}

impl<T> GraphOperation for FractionalMaxPool<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_INT64,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("FractionalMaxPool_{}")?
        };
        let mut new_op = graph.new_operation("FractionalMaxPool", &op_name)?;
        {
            (|attrs| {new_op.set_attr_float_list("pooling_ratio", attrs)})(&self.pooling_ratio)
        }
        {
            match self.pseudo_random {
            }
            None => new_op.set_attr_value_proto("pseudo_random", &vec![40_u8, 0_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_bool("pseudo_random", *attr)})(&value),
        };
        {
            match self.overlapping {
            }
            None => new_op.set_attr_value_proto("overlapping", &vec![40_u8, 0_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_bool("overlapping", *attr)})(&value),
        };
        {
            match self.deterministic {
            }
            None => new_op.set_attr_value_proto("deterministic", &vec![40_u8, 0_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_bool("deterministic", *attr)})(&value),
        };
        {
            match self.seed {
            }
            None => new_op.set_attr_value_proto("seed", &vec![24_u8, 0_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_int("seed", *attr)})(&value),
        };
        {
            match self.seed2 {
            }
            None => new_op.set_attr_value_proto("seed2", &vec![24_u8, 0_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_int("seed2", *attr)})(&value),
        };
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct FractionalMaxPool<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_INT64,
{
    value: Edge<T>,
    pooling_ratio: Vec<f32>,
    pseudo_random: Option<bool>,
    overlapping: Option<bool>,
    deterministic: Option<bool>,
    seed: Option<i64>,
    seed2: Option<i64>,
    id_: usize,
}

impl<T> FractionalMaxPool<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_INT64,
{
    pub fn pseudo_random(&mut self, pseudo_random: bool) -> &mut Self {
        self.pseudo_random = Some(pseudo_random);
        &self
    }

    pub fn overlapping(&mut self, overlapping: bool) -> &mut Self {
        self.overlapping = Some(overlapping);
        &self
    }

    pub fn deterministic(&mut self, deterministic: bool) -> &mut Self {
        self.deterministic = Some(deterministic);
        &self
    }

    pub fn seed(&mut self, seed: int) -> &mut Self {
        self.seed = Some(seed);
        &self
    }

    pub fn seed2(&mut self, seed2: int) -> &mut Self {
        self.seed2 = Some(seed2);
        &self
    }

    pub fn finish(self) -> FractionalMaxPoolOp<T> {
        FractionalMaxPoolOp::new(Rc::new(self))
    }

    pub fn new(value: Edge<T>, pooling_ratio: &[f32]) -> Self {
        Self {
            value,
            pooling_ratio: pooling_ratio.to_vec()
            pseudo_random: None,
            overlapping: None,
            deterministic: None,
            seed: None,
            seed2: None,
            id_: new_id(),
        }
    }
}

pub trait con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_BOOL_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_BOOL_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64 for BFloat16 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_BOOL_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64 for OtherComplex<f32> {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_BOOL_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64 for OtherComplex<f64> {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_BOOL_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64 for bool {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_BOOL_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64 for f32 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_BOOL_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64 for f64 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_BOOL_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64 for i16 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_BOOL_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64 for i32 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_BOOL_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64 for i64 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_BOOL_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64 for i8 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_BOOL_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64 for u16 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_BOOL_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64 for u32 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_BOOL_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64 for u64 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_BOOL_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64 for u8 {
}

impl<T, Tindices> ScatterNdNonAliasingAddOp<T, Tindices>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_BOOL_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      Tindices: con_or_DT_INT32_or_DT_INT64,
{
    pub fn new(inner: Rc<ScatterNdNonAliasingAdd<T, Tindices>>) -> Self {
        Self{inner}
    }

    pub fn output(&self) -> Edge<T> {
        Edge::<T>::new(self.inner.clone(), 0)
    }
}

struct ScatterNdNonAliasingAddOp<T, Tindices>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_BOOL_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      Tindices: con_or_DT_INT32_or_DT_INT64,
{
    inner: Rc<ScatterNdNonAliasingAdd<T, Tindices>>,
}

impl<T, Tindices> GraphOperation for ScatterNdNonAliasingAdd<T, Tindices>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_BOOL_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      Tindices: con_or_DT_INT32_or_DT_INT64,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("ScatterNdNonAliasingAdd_{}")?
        };
        let mut new_op = graph.new_operation("ScatterNdNonAliasingAdd", &op_name)?;
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct ScatterNdNonAliasingAdd<T, Tindices>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_BOOL_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      Tindices: con_or_DT_INT32_or_DT_INT64,
{
    input: Edge<T>,
    indices: Edge<Tindices>,
    updates: Edge<T>,
    id_: usize,
}

impl<T, Tindices> ScatterNdNonAliasingAdd<T, Tindices>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_BOOL_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      Tindices: con_or_DT_INT32_or_DT_INT64,
{
    pub fn finish(self) -> ScatterNdNonAliasingAddOp<T, Tindices> {
        ScatterNdNonAliasingAddOp::new(Rc::new(self))
    }

    pub fn new(input: Edge<T>, indices: Edge<Tindices>, updates: Edge<T>) -> Self {
        Self {
            input,
            indices,
            updates,
            id_: new_id(),
        }
    }
}

impl TensorArraySizeOp {
    pub fn new(inner: Rc<TensorArraySize>) -> Self {
        Self{inner}
    }

    pub fn size(&self) -> Edge<i32> {
        Edge::<i32>::new(self.inner.clone(), 0)
    }
}

struct TensorArraySizeOp {
    inner: Rc<TensorArraySize>,
}

impl GraphOperation for TensorArraySize {
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("TensorArraySize_{}")?
        };
        let mut new_op = graph.new_operation("TensorArraySize", &op_name)?;
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct TensorArraySize {
    handle: Edge<String>,
    flow_in: Edge<f32>,
    id_: usize,
}

impl TensorArraySize {
    pub fn finish(self) -> TensorArraySizeOp {
        TensorArraySizeOp::new(Rc::new(self))
    }

    pub fn new(handle: Edge<String>, flow_in: Edge<f32>) -> Self {
        Self {
            handle,
            flow_in,
            id_: new_id(),
        }
    }
}

impl CTCGreedyDecoderOp {
    pub fn new(inner: Rc<CTCGreedyDecoder>) -> Self {
        Self{inner}
    }

    pub fn decoded_indices(&self) -> Edge<i64> {
        Edge::<i64>::new(self.inner.clone(), 0)
    }

    pub fn decoded_values(&self) -> Edge<i64> {
        Edge::<i64>::new(self.inner.clone(), 1)
    }

    pub fn decoded_shape(&self) -> Edge<i64> {
        Edge::<i64>::new(self.inner.clone(), 2)
    }

    pub fn log_probability(&self) -> Edge<f32> {
        Edge::<f32>::new(self.inner.clone(), 3)
    }
}

struct CTCGreedyDecoderOp {
    inner: Rc<CTCGreedyDecoder>,
}

impl GraphOperation for CTCGreedyDecoder {
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("CTCGreedyDecoder_{}")?
        };
        let mut new_op = graph.new_operation("CTCGreedyDecoder", &op_name)?;
        {
            match self.merge_repeated {
            }
            None => new_op.set_attr_value_proto("merge_repeated", &vec![40_u8, 0_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_bool("merge_repeated", *attr)})(&value),
        };
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct CTCGreedyDecoder {
    inputs: Edge<f32>,
    sequence_length: Edge<i32>,
    merge_repeated: Option<bool>,
    id_: usize,
}

impl CTCGreedyDecoder {
    pub fn merge_repeated(&mut self, merge_repeated: bool) -> &mut Self {
        self.merge_repeated = Some(merge_repeated);
        &self
    }

    pub fn finish(self) -> CTCGreedyDecoderOp {
        CTCGreedyDecoderOp::new(Rc::new(self))
    }

    pub fn new(inputs: Edge<f32>, sequence_length: Edge<i32>) -> Self {
        Self {
            inputs,
            sequence_length,
            merge_repeated: None,
            id_: new_id(),
        }
    }
}

impl LoadTPUEmbeddingMomentumParametersOp {
    pub fn new(inner: Rc<LoadTPUEmbeddingMomentumParameters>) -> Self {
        Self{inner}
    }
}

struct LoadTPUEmbeddingMomentumParametersOp {
    inner: Rc<LoadTPUEmbeddingMomentumParameters>,
}

impl GraphOperation for LoadTPUEmbeddingMomentumParameters {
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("LoadTPUEmbeddingMomentumParameters_{}")?
        };
        let mut new_op = graph.new_operation("LoadTPUEmbeddingMomentumParameters", &op_name)?;
        {
            match self.table_id {
            }
            None => new_op.set_attr_value_proto("table_id", &vec![24_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 1_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_int("table_id", *attr)})(&value),
        };
        {
            match self.table_name {
            }
            None => new_op.set_attr_value_proto("table_name", &vec![18_u8, 0_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_string("table_name", attr)})(&value),
        };
        {
            (|attr| {new_op.set_attr_int("num_shards", *attr)})(&self.num_shards)
        }
        {
            (|attr| {new_op.set_attr_int("shard_id", *attr)})(&self.shard_id)
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct LoadTPUEmbeddingMomentumParameters {
    parameters: Edge<f32>,
    momenta: Edge<f32>,
    table_id: Option<i64>,
    table_name: Option<String>,
    num_shards: i64,
    shard_id: i64,
    id_: usize,
}

impl LoadTPUEmbeddingMomentumParameters {
    pub fn table_id(&mut self, table_id: int) -> &mut Self {
        self.table_id = Some(table_id);
        &self
    }

    pub fn table_name(&mut self, table_name: &str) -> &mut Self {
        self.table_name = Some(table_name.to_string());
        &self
    }

    pub fn finish(self) -> LoadTPUEmbeddingMomentumParametersOp {
        LoadTPUEmbeddingMomentumParametersOp::new(Rc::new(self))
    }

    pub fn new(parameters: Edge<f32>, momenta: Edge<f32>, num_shards: int, shard_id: int) -> Self {
        Self {
            parameters,
            momenta,
            table_id: None,
            table_name: None,
            num_shards: num_shards
            shard_id: shard_id
            id_: new_id(),
        }
    }
}

impl BoostedTreesBucketizeOp {
    pub fn new(inner: Rc<BoostedTreesBucketize>) -> Self {
        Self{inner}
    }

    pub fn buckets(&self) -> Edge<i32> {
        Edge::<i32>::new(self.inner.clone(), 0)
    }
}

struct BoostedTreesBucketizeOp {
    inner: Rc<BoostedTreesBucketize>,
}

impl GraphOperation for BoostedTreesBucketize {
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("BoostedTreesBucketize_{}")?
        };
        let mut new_op = graph.new_operation("BoostedTreesBucketize", &op_name)?;
        {
            (|attr| {new_op.set_attr_int("num_features", *attr)})(&self.num_features)
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct BoostedTreesBucketize {
    float_values: Edge<f32>,
    bucket_boundaries: Edge<f32>,
    num_features: i64,
    id_: usize,
}

impl BoostedTreesBucketize {
    pub fn finish(self) -> BoostedTreesBucketizeOp {
        BoostedTreesBucketizeOp::new(Rc::new(self))
    }

    pub fn new(float_values: Edge<f32>, bucket_boundaries: Edge<f32>, num_features: int) -> Self {
        Self {
            float_values,
            bucket_boundaries,
            num_features: num_features
            id_: new_id(),
        }
    }
}

impl<T, Tindices> ScatterNdAddOp<T, Tindices>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      Tindices: con_or_DT_INT32_or_DT_INT64,
{
    pub fn new(inner: Rc<ScatterNdAdd<T, Tindices>>) -> Self {
        Self{inner}
    }

    pub fn output_ref(&self) -> Edge<T> {
        Edge::<T>::new(self.inner.clone(), 0)
    }
}

struct ScatterNdAddOp<T, Tindices>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      Tindices: con_or_DT_INT32_or_DT_INT64,
{
    inner: Rc<ScatterNdAdd<T, Tindices>>,
}

impl<T, Tindices> GraphOperation for ScatterNdAdd<T, Tindices>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      Tindices: con_or_DT_INT32_or_DT_INT64,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("ScatterNdAdd_{}")?
        };
        let mut new_op = graph.new_operation("ScatterNdAdd", &op_name)?;
        {
            match self.use_locking {
            }
            None => new_op.set_attr_value_proto("use_locking", &vec![40_u8, 0_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_bool("use_locking", *attr)})(&value),
        };
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct ScatterNdAdd<T, Tindices>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      Tindices: con_or_DT_INT32_or_DT_INT64,
{
    ref_: Edge<T>,
    indices: Edge<Tindices>,
    updates: Edge<T>,
    use_locking: Option<bool>,
    id_: usize,
}

impl<T, Tindices> ScatterNdAdd<T, Tindices>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      Tindices: con_or_DT_INT32_or_DT_INT64,
{
    pub fn use_locking(&mut self, use_locking: bool) -> &mut Self {
        self.use_locking = Some(use_locking);
        &self
    }

    pub fn finish(self) -> ScatterNdAddOp<T, Tindices> {
        ScatterNdAddOp::new(Rc::new(self))
    }

    pub fn new(ref_: Edge<T>, indices: Edge<Tindices>, updates: Edge<T>) -> Self {
        Self {
            ref_,
            indices,
            updates,
            use_locking: None,
            id_: new_id(),
        }
    }
}

impl<T, Tindices> ScatterDivOp<T, Tindices>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      Tindices: con_or_DT_INT32_or_DT_INT64,
{
    pub fn new(inner: Rc<ScatterDiv<T, Tindices>>) -> Self {
        Self{inner}
    }

    pub fn output_ref(&self) -> Edge<T> {
        Edge::<T>::new(self.inner.clone(), 0)
    }
}

struct ScatterDivOp<T, Tindices>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      Tindices: con_or_DT_INT32_or_DT_INT64,
{
    inner: Rc<ScatterDiv<T, Tindices>>,
}

impl<T, Tindices> GraphOperation for ScatterDiv<T, Tindices>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      Tindices: con_or_DT_INT32_or_DT_INT64,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("ScatterDiv_{}")?
        };
        let mut new_op = graph.new_operation("ScatterDiv", &op_name)?;
        {
            match self.use_locking {
            }
            None => new_op.set_attr_value_proto("use_locking", &vec![40_u8, 0_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_bool("use_locking", *attr)})(&value),
        };
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct ScatterDiv<T, Tindices>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      Tindices: con_or_DT_INT32_or_DT_INT64,
{
    ref_: Edge<T>,
    indices: Edge<Tindices>,
    updates: Edge<T>,
    use_locking: Option<bool>,
    id_: usize,
}

impl<T, Tindices> ScatterDiv<T, Tindices>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      Tindices: con_or_DT_INT32_or_DT_INT64,
{
    pub fn use_locking(&mut self, use_locking: bool) -> &mut Self {
        self.use_locking = Some(use_locking);
        &self
    }

    pub fn finish(self) -> ScatterDivOp<T, Tindices> {
        ScatterDivOp::new(Rc::new(self))
    }

    pub fn new(ref_: Edge<T>, indices: Edge<Tindices>, updates: Edge<T>) -> Self {
        Self {
            ref_,
            indices,
            updates,
            use_locking: None,
            id_: new_id(),
        }
    }
}

impl<T> AtanOp<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_COMPLEX64_or_DT_INT64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF,
{
    pub fn new(inner: Rc<Atan<T>>) -> Self {
        Self{inner}
    }

    pub fn y(&self) -> Edge<T> {
        Edge::<T>::new(self.inner.clone(), 0)
    }
}

struct AtanOp<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_COMPLEX64_or_DT_INT64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF,
{
    inner: Rc<Atan<T>>,
}

impl<T> GraphOperation for Atan<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_COMPLEX64_or_DT_INT64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("Atan_{}")?
        };
        let mut new_op = graph.new_operation("Atan", &op_name)?;
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct Atan<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_COMPLEX64_or_DT_INT64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF,
{
    x: Edge<T>,
    id_: usize,
}

impl<T> Atan<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_COMPLEX64_or_DT_INT64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF,
{
    pub fn finish(self) -> AtanOp<T> {
        AtanOp::new(Rc::new(self))
    }

    pub fn new(x: Edge<T>) -> Self {
        Self {
            x,
            id_: new_id(),
        }
    }
}

impl EncodeWavOp {
    pub fn new(inner: Rc<EncodeWav>) -> Self {
        Self{inner}
    }

    pub fn contents(&self) -> Edge<String> {
        Edge::<String>::new(self.inner.clone(), 0)
    }
}

struct EncodeWavOp {
    inner: Rc<EncodeWav>,
}

impl GraphOperation for EncodeWav {
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("EncodeWav_{}")?
        };
        let mut new_op = graph.new_operation("EncodeWav", &op_name)?;
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct EncodeWav {
    audio: Edge<f32>,
    sample_rate: Edge<i32>,
    id_: usize,
}

impl EncodeWav {
    pub fn finish(self) -> EncodeWavOp {
        EncodeWavOp::new(Rc::new(self))
    }

    pub fn new(audio: Edge<f32>, sample_rate: Edge<i32>) -> Self {
        Self {
            audio,
            sample_rate,
            id_: new_id(),
        }
    }
}

impl<T> SqueezeOp<T>
where T: con,
{
    pub fn new(inner: Rc<Squeeze<T>>) -> Self {
        Self{inner}
    }

    pub fn output(&self) -> Edge<T> {
        Edge::<T>::new(self.inner.clone(), 0)
    }
}

struct SqueezeOp<T>
where T: con,
{
    inner: Rc<Squeeze<T>>,
}

impl<T> GraphOperation for Squeeze<T>
where T: con,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("Squeeze_{}")?
        };
        let mut new_op = graph.new_operation("Squeeze", &op_name)?;
        {
            match self.squeeze_dims {
            }
            None => new_op.set_attr_value_proto("squeeze_dims", &vec![10_u8, 0_u8,]);,
            Some(value) => (|attrs| {new_op.set_attr_int_list("squeeze_dims", attrs)})(&value),
        };
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct Squeeze<T>
where T: con,
{
    input: Edge<T>,
    squeeze_dims: Option<Vec<i64>>,
    id_: usize,
}

impl<T> Squeeze<T>
where T: con,
{
    pub fn squeeze_dims(&mut self, squeeze_dims: &[int]) -> &mut Self {
        self.squeeze_dims = Some(squeeze_dims.to_vec());
        &self
    }

    pub fn finish(self) -> SqueezeOp<T> {
        SqueezeOp::new(Rc::new(self))
    }

    pub fn new(input: Edge<T>) -> Self {
        Self {
            input,
            squeeze_dims: None,
            id_: new_id(),
        }
    }
}

impl LoadTPUEmbeddingADAMParametersOp {
    pub fn new(inner: Rc<LoadTPUEmbeddingADAMParameters>) -> Self {
        Self{inner}
    }
}

struct LoadTPUEmbeddingADAMParametersOp {
    inner: Rc<LoadTPUEmbeddingADAMParameters>,
}

impl GraphOperation for LoadTPUEmbeddingADAMParameters {
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("LoadTPUEmbeddingADAMParameters_{}")?
        };
        let mut new_op = graph.new_operation("LoadTPUEmbeddingADAMParameters", &op_name)?;
        {
            match self.table_id {
            }
            None => new_op.set_attr_value_proto("table_id", &vec![24_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 1_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_int("table_id", *attr)})(&value),
        };
        {
            match self.table_name {
            }
            None => new_op.set_attr_value_proto("table_name", &vec![18_u8, 0_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_string("table_name", attr)})(&value),
        };
        {
            (|attr| {new_op.set_attr_int("num_shards", *attr)})(&self.num_shards)
        }
        {
            (|attr| {new_op.set_attr_int("shard_id", *attr)})(&self.shard_id)
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct LoadTPUEmbeddingADAMParameters {
    parameters: Edge<f32>,
    momenta: Edge<f32>,
    velocities: Edge<f32>,
    table_id: Option<i64>,
    table_name: Option<String>,
    num_shards: i64,
    shard_id: i64,
    id_: usize,
}

impl LoadTPUEmbeddingADAMParameters {
    pub fn table_id(&mut self, table_id: int) -> &mut Self {
        self.table_id = Some(table_id);
        &self
    }

    pub fn table_name(&mut self, table_name: &str) -> &mut Self {
        self.table_name = Some(table_name.to_string());
        &self
    }

    pub fn finish(self) -> LoadTPUEmbeddingADAMParametersOp {
        LoadTPUEmbeddingADAMParametersOp::new(Rc::new(self))
    }

    pub fn new(parameters: Edge<f32>, momenta: Edge<f32>, velocities: Edge<f32>, num_shards: int, shard_id: int) -> Self {
        Self {
            parameters,
            momenta,
            velocities,
            table_id: None,
            table_name: None,
            num_shards: num_shards
            shard_id: shard_id
            id_: new_id(),
        }
    }
}

impl<T> NcclBroadcastOp<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_INT64_or_DT_HALF,
{
    pub fn new(inner: Rc<NcclBroadcast<T>>) -> Self {
        Self{inner}
    }

    pub fn output(&self) -> Edge<T> {
        Edge::<T>::new(self.inner.clone(), 0)
    }
}

struct NcclBroadcastOp<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_INT64_or_DT_HALF,
{
    inner: Rc<NcclBroadcast<T>>,
}

impl<T> GraphOperation for NcclBroadcast<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_INT64_or_DT_HALF,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("NcclBroadcast_{}")?
        };
        let mut new_op = graph.new_operation("NcclBroadcast", &op_name)?;
        {
            (|attr| {new_op.set_attr_shape("shape", attr)})(&self.shape)
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct NcclBroadcast<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_INT64_or_DT_HALF,
{
    input: Edge<T>,
    shape: Shape,
    id_: usize,
}

impl<T> NcclBroadcast<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_INT64_or_DT_HALF,
{
    pub fn finish(self) -> NcclBroadcastOp<T> {
        NcclBroadcastOp::new(Rc::new(self))
    }

    pub fn new(input: Edge<T>, shape: &Shape) -> Self {
        Self {
            input,
            shape: shape.clone()
            id_: new_id(),
        }
    }
}

impl<T> ResizeAreaOp<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_UINT16_or_DT_HALF,
{
    pub fn new(inner: Rc<ResizeArea<T>>) -> Self {
        Self{inner}
    }

    pub fn resized_images(&self) -> Edge<f32> {
        Edge::<f32>::new(self.inner.clone(), 0)
    }
}

struct ResizeAreaOp<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_UINT16_or_DT_HALF,
{
    inner: Rc<ResizeArea<T>>,
}

impl<T> GraphOperation for ResizeArea<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_UINT16_or_DT_HALF,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("ResizeArea_{}")?
        };
        let mut new_op = graph.new_operation("ResizeArea", &op_name)?;
        {
            match self.align_corners {
            }
            None => new_op.set_attr_value_proto("align_corners", &vec![40_u8, 0_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_bool("align_corners", *attr)})(&value),
        };
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct ResizeArea<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_UINT16_or_DT_HALF,
{
    images: Edge<T>,
    size: Edge<i32>,
    align_corners: Option<bool>,
    id_: usize,
}

impl<T> ResizeArea<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_UINT16_or_DT_HALF,
{
    pub fn align_corners(&mut self, align_corners: bool) -> &mut Self {
        self.align_corners = Some(align_corners);
        &self
    }

    pub fn finish(self) -> ResizeAreaOp<T> {
        ResizeAreaOp::new(Rc::new(self))
    }

    pub fn new(images: Edge<T>, size: Edge<i32>) -> Self {
        Self {
            images,
            size,
            align_corners: None,
            id_: new_id(),
        }
    }
}

impl NegTrainOp {
    pub fn new(inner: Rc<NegTrain>) -> Self {
        Self{inner}
    }
}

struct NegTrainOp {
    inner: Rc<NegTrain>,
}

impl GraphOperation for NegTrain {
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("NegTrain_{}")?
        };
        let mut new_op = graph.new_operation("NegTrain", &op_name)?;
        {
            (|attrs| {new_op.set_attr_int_list("vocab_count", attrs)})(&self.vocab_count)
        }
        {
            (|attr| {new_op.set_attr_int("num_negative_samples", *attr)})(&self.num_negative_samples)
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct NegTrain {
    w_in: Edge<f32>,
    w_out: Edge<f32>,
    examples: Edge<i32>,
    labels: Edge<i32>,
    lr: Edge<f32>,
    vocab_count: Vec<i64>,
    num_negative_samples: i64,
    id_: usize,
}

impl NegTrain {
    pub fn finish(self) -> NegTrainOp {
        NegTrainOp::new(Rc::new(self))
    }

    pub fn new(w_in: Edge<f32>, w_out: Edge<f32>, examples: Edge<i32>, labels: Edge<i32>, lr: Edge<f32>, vocab_count: &[int], num_negative_samples: int) -> Self {
        Self {
            w_in,
            w_out,
            examples,
            labels,
            lr,
            vocab_count: vocab_count.to_vec()
            num_negative_samples: num_negative_samples
            id_: new_id(),
        }
    }
}

impl<T, Tout> RealOp<T, Tout>
where T: con_or_DT_COMPLEX64_or_DT_COMPLEX128,
      Tout: con_or_DT_FLOAT_or_DT_DOUBLE,
{
    pub fn new(inner: Rc<Real<T, Tout>>) -> Self {
        Self{inner}
    }

    pub fn output(&self) -> Edge<Tout> {
        Edge::<Tout>::new(self.inner.clone(), 0)
    }
}

struct RealOp<T, Tout>
where T: con_or_DT_COMPLEX64_or_DT_COMPLEX128,
      Tout: con_or_DT_FLOAT_or_DT_DOUBLE,
{
    inner: Rc<Real<T, Tout>>,
}

impl<T, Tout> GraphOperation for Real<T, Tout>
where T: con_or_DT_COMPLEX64_or_DT_COMPLEX128,
      Tout: con_or_DT_FLOAT_or_DT_DOUBLE,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("Real_{}")?
        };
        let mut new_op = graph.new_operation("Real", &op_name)?;
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct Real<T, Tout>
where T: con_or_DT_COMPLEX64_or_DT_COMPLEX128,
      Tout: con_or_DT_FLOAT_or_DT_DOUBLE,
{
    input: Edge<T>,
    id_: usize,
}

impl<T, Tout> Real<T, Tout>
where T: con_or_DT_COMPLEX64_or_DT_COMPLEX128,
      Tout: con_or_DT_FLOAT_or_DT_DOUBLE,
{
    pub fn finish(self) -> RealOp<T, Tout> {
        RealOp::new(Rc::new(self))
    }

    pub fn new(input: Edge<T>) -> Self {
        Self {
            input,
            id_: new_id(),
        }
    }
}

impl<T> RealDivOp<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF,
{
    pub fn new(inner: Rc<RealDiv<T>>) -> Self {
        Self{inner}
    }

    pub fn z(&self) -> Edge<T> {
        Edge::<T>::new(self.inner.clone(), 0)
    }
}

struct RealDivOp<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF,
{
    inner: Rc<RealDiv<T>>,
}

impl<T> GraphOperation for RealDiv<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("RealDiv_{}")?
        };
        let mut new_op = graph.new_operation("RealDiv", &op_name)?;
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct RealDiv<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF,
{
    x: Edge<T>,
    y: Edge<T>,
    id_: usize,
}

impl<T> RealDiv<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF,
{
    pub fn finish(self) -> RealDivOp<T> {
        RealDivOp::new(Rc::new(self))
    }

    pub fn new(x: Edge<T>, y: Edge<T>) -> Self {
        Self {
            x,
            y,
            id_: new_id(),
        }
    }
}

impl LoadTPUEmbeddingAdagradParametersOp {
    pub fn new(inner: Rc<LoadTPUEmbeddingAdagradParameters>) -> Self {
        Self{inner}
    }
}

struct LoadTPUEmbeddingAdagradParametersOp {
    inner: Rc<LoadTPUEmbeddingAdagradParameters>,
}

impl GraphOperation for LoadTPUEmbeddingAdagradParameters {
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("LoadTPUEmbeddingAdagradParameters_{}")?
        };
        let mut new_op = graph.new_operation("LoadTPUEmbeddingAdagradParameters", &op_name)?;
        {
            match self.table_id {
            }
            None => new_op.set_attr_value_proto("table_id", &vec![24_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 1_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_int("table_id", *attr)})(&value),
        };
        {
            match self.table_name {
            }
            None => new_op.set_attr_value_proto("table_name", &vec![18_u8, 0_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_string("table_name", attr)})(&value),
        };
        {
            (|attr| {new_op.set_attr_int("num_shards", *attr)})(&self.num_shards)
        }
        {
            (|attr| {new_op.set_attr_int("shard_id", *attr)})(&self.shard_id)
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct LoadTPUEmbeddingAdagradParameters {
    parameters: Edge<f32>,
    accumulators: Edge<f32>,
    table_id: Option<i64>,
    table_name: Option<String>,
    num_shards: i64,
    shard_id: i64,
    id_: usize,
}

impl LoadTPUEmbeddingAdagradParameters {
    pub fn table_id(&mut self, table_id: int) -> &mut Self {
        self.table_id = Some(table_id);
        &self
    }

    pub fn table_name(&mut self, table_name: &str) -> &mut Self {
        self.table_name = Some(table_name.to_string());
        &self
    }

    pub fn finish(self) -> LoadTPUEmbeddingAdagradParametersOp {
        LoadTPUEmbeddingAdagradParametersOp::new(Rc::new(self))
    }

    pub fn new(parameters: Edge<f32>, accumulators: Edge<f32>, num_shards: int, shard_id: int) -> Self {
        Self {
            parameters,
            accumulators,
            table_id: None,
            table_name: None,
            num_shards: num_shards
            shard_id: shard_id
            id_: new_id(),
        }
    }
}

impl<T> ApplyAdamOp<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
{
    pub fn new(inner: Rc<ApplyAdam<T>>) -> Self {
        Self{inner}
    }

    pub fn out(&self) -> Edge<T> {
        Edge::<T>::new(self.inner.clone(), 0)
    }
}

struct ApplyAdamOp<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
{
    inner: Rc<ApplyAdam<T>>,
}

impl<T> GraphOperation for ApplyAdam<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("ApplyAdam_{}")?
        };
        let mut new_op = graph.new_operation("ApplyAdam", &op_name)?;
        {
            match self.use_locking {
            }
            None => new_op.set_attr_value_proto("use_locking", &vec![40_u8, 0_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_bool("use_locking", *attr)})(&value),
        };
        {
            match self.use_nesterov {
            }
            None => new_op.set_attr_value_proto("use_nesterov", &vec![40_u8, 0_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_bool("use_nesterov", *attr)})(&value),
        };
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct ApplyAdam<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
{
    var: Edge<T>,
    m: Edge<T>,
    v: Edge<T>,
    beta1_power: Edge<T>,
    beta2_power: Edge<T>,
    lr: Edge<T>,
    beta1: Edge<T>,
    beta2: Edge<T>,
    epsilon: Edge<T>,
    grad: Edge<T>,
    use_locking: Option<bool>,
    use_nesterov: Option<bool>,
    id_: usize,
}

impl<T> ApplyAdam<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
{
    pub fn use_locking(&mut self, use_locking: bool) -> &mut Self {
        self.use_locking = Some(use_locking);
        &self
    }

    pub fn use_nesterov(&mut self, use_nesterov: bool) -> &mut Self {
        self.use_nesterov = Some(use_nesterov);
        &self
    }

    pub fn finish(self) -> ApplyAdamOp<T> {
        ApplyAdamOp::new(Rc::new(self))
    }

    pub fn new(var: Edge<T>, m: Edge<T>, v: Edge<T>, beta1_power: Edge<T>, beta2_power: Edge<T>, lr: Edge<T>, beta1: Edge<T>, beta2: Edge<T>, epsilon: Edge<T>, grad: Edge<T>) -> Self {
        Self {
            var,
            m,
            v,
            beta1_power,
            beta2_power,
            lr,
            beta1,
            beta2,
            epsilon,
            grad,
            use_locking: None,
            use_nesterov: None,
            id_: new_id(),
        }
    }
}

impl<dtype> TemporaryVariableOp<dtype>
where dtype: con,
{
    pub fn new(inner: Rc<TemporaryVariable<dtype>>) -> Self {
        Self{inner}
    }

    pub fn ref_(&self) -> Edge<dtype> {
        Edge::<dtype>::new(self.inner.clone(), 0)
    }
}

struct TemporaryVariableOp<dtype>
where dtype: con,
{
    inner: Rc<TemporaryVariable<dtype>>,
}

impl<dtype> GraphOperation for TemporaryVariable<dtype>
where dtype: con,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("TemporaryVariable_{}")?
        };
        let mut new_op = graph.new_operation("TemporaryVariable", &op_name)?;
        {
            (|attr| {new_op.set_attr_shape("shape", attr)})(&self.shape)
        }
        {
            match self.var_name {
            }
            None => new_op.set_attr_value_proto("var_name", &vec![18_u8, 0_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_string("var_name", attr)})(&value),
        };
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct TemporaryVariable<dtype>
where dtype: con,
{
    shape: Shape,
    var_name: Option<String>,
    id_: usize,
}

impl<dtype> TemporaryVariable<dtype>
where dtype: con,
{
    pub fn var_name(&mut self, var_name: &str) -> &mut Self {
        self.var_name = Some(var_name.to_string());
        &self
    }

    pub fn finish(self) -> TemporaryVariableOp<dtype> {
        TemporaryVariableOp::new(Rc::new(self))
    }

    pub fn new(shape: &Shape) -> Self {
        Self {
            shape: shape.clone()
            var_name: None,
            id_: new_id(),
        }
    }
}

impl<T> ZetaOp<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE,
{
    pub fn new(inner: Rc<Zeta<T>>) -> Self {
        Self{inner}
    }

    pub fn z(&self) -> Edge<T> {
        Edge::<T>::new(self.inner.clone(), 0)
    }
}

struct ZetaOp<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE,
{
    inner: Rc<Zeta<T>>,
}

impl<T> GraphOperation for Zeta<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("Zeta_{}")?
        };
        let mut new_op = graph.new_operation("Zeta", &op_name)?;
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct Zeta<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE,
{
    x: Edge<T>,
    q: Edge<T>,
    id_: usize,
}

impl<T> Zeta<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE,
{
    pub fn finish(self) -> ZetaOp<T> {
        ZetaOp::new(Rc::new(self))
    }

    pub fn new(x: Edge<T>, q: Edge<T>) -> Self {
        Self {
            x,
            q,
            id_: new_id(),
        }
    }
}

impl<T> ReciprocalGradOp<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_COMPLEX64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF,
{
    pub fn new(inner: Rc<ReciprocalGrad<T>>) -> Self {
        Self{inner}
    }

    pub fn z(&self) -> Edge<T> {
        Edge::<T>::new(self.inner.clone(), 0)
    }
}

struct ReciprocalGradOp<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_COMPLEX64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF,
{
    inner: Rc<ReciprocalGrad<T>>,
}

impl<T> GraphOperation for ReciprocalGrad<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_COMPLEX64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("ReciprocalGrad_{}")?
        };
        let mut new_op = graph.new_operation("ReciprocalGrad", &op_name)?;
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct ReciprocalGrad<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_COMPLEX64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF,
{
    y: Edge<T>,
    dy: Edge<T>,
    id_: usize,
}

impl<T> ReciprocalGrad<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_COMPLEX64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF,
{
    pub fn finish(self) -> ReciprocalGradOp<T> {
        ReciprocalGradOp::new(Rc::new(self))
    }

    pub fn new(y: Edge<T>, dy: Edge<T>) -> Self {
        Self {
            y,
            dy,
            id_: new_id(),
        }
    }
}

impl SendTPUEmbeddingGradientsOp {
    pub fn new(inner: Rc<SendTPUEmbeddingGradients>) -> Self {
        Self{inner}
    }
}

struct SendTPUEmbeddingGradientsOp {
    inner: Rc<SendTPUEmbeddingGradients>,
}

impl GraphOperation for SendTPUEmbeddingGradients {
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("SendTPUEmbeddingGradients_{}")?
        };
        let mut new_op = graph.new_operation("SendTPUEmbeddingGradients", &op_name)?;
        {
            (|attr| {new_op.set_attr_int("N", *attr)})(&self.N)
        }
        {
            match self.NN {
            }
            None => new_op.set_attr_value_proto("NN", &vec![24_u8, 0_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_int("NN", *attr)})(&value),
        };
        {
            (|attr| {new_op.set_attr_string("config", attr)})(&self.config)
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct SendTPUEmbeddingGradients {
    inputs: Edge<f32>,
    learning_rates: Edge<f32>,
    N: i64,
    NN: Option<i64>,
    config: String,
    id_: usize,
}

impl SendTPUEmbeddingGradients {
    pub fn NN(&mut self, NN: int) -> &mut Self {
        self.NN = Some(NN);
        &self
    }

    pub fn finish(self) -> SendTPUEmbeddingGradientsOp {
        SendTPUEmbeddingGradientsOp::new(Rc::new(self))
    }

    pub fn new(inputs: Edge<f32>, learning_rates: Edge<f32>, N: int, config: &str) -> Self {
        Self {
            inputs,
            learning_rates,
            N: N
            NN: None,
            config: config.to_string()
            id_: new_id(),
        }
    }
}

impl<T, Tindices> XlaPadOp<T, Tindices>
where T: con,
      Tindices: con_or_DT_INT32_or_DT_INT64,
{
    pub fn new(inner: Rc<XlaPad<T, Tindices>>) -> Self {
        Self{inner}
    }

    pub fn output(&self) -> Edge<T> {
        Edge::<T>::new(self.inner.clone(), 0)
    }
}

struct XlaPadOp<T, Tindices>
where T: con,
      Tindices: con_or_DT_INT32_or_DT_INT64,
{
    inner: Rc<XlaPad<T, Tindices>>,
}

impl<T, Tindices> GraphOperation for XlaPad<T, Tindices>
where T: con,
      Tindices: con_or_DT_INT32_or_DT_INT64,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("XlaPad_{}")?
        };
        let mut new_op = graph.new_operation("XlaPad", &op_name)?;
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct XlaPad<T, Tindices>
where T: con,
      Tindices: con_or_DT_INT32_or_DT_INT64,
{
    input: Edge<T>,
    padding_value: Edge<T>,
    padding_low: Edge<Tindices>,
    padding_high: Edge<Tindices>,
    padding_interior: Edge<Tindices>,
    id_: usize,
}

impl<T, Tindices> XlaPad<T, Tindices>
where T: con,
      Tindices: con_or_DT_INT32_or_DT_INT64,
{
    pub fn finish(self) -> XlaPadOp<T, Tindices> {
        XlaPadOp::new(Rc::new(self))
    }

    pub fn new(input: Edge<T>, padding_value: Edge<T>, padding_low: Edge<Tindices>, padding_high: Edge<Tindices>, padding_interior: Edge<Tindices>) -> Self {
        Self {
            input,
            padding_value,
            padding_low,
            padding_high,
            padding_interior,
            id_: new_id(),
        }
    }
}

impl<T> NegOp<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_COMPLEX64_or_DT_INT64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF,
{
    pub fn new(inner: Rc<Neg<T>>) -> Self {
        Self{inner}
    }

    pub fn y(&self) -> Edge<T> {
        Edge::<T>::new(self.inner.clone(), 0)
    }
}

struct NegOp<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_COMPLEX64_or_DT_INT64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF,
{
    inner: Rc<Neg<T>>,
}

impl<T> GraphOperation for Neg<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_COMPLEX64_or_DT_INT64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("Neg_{}")?
        };
        let mut new_op = graph.new_operation("Neg", &op_name)?;
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct Neg<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_COMPLEX64_or_DT_INT64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF,
{
    x: Edge<T>,
    id_: usize,
}

impl<T> Neg<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_COMPLEX64_or_DT_INT64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF,
{
    pub fn finish(self) -> NegOp<T> {
        NegOp::new(Rc::new(self))
    }

    pub fn new(x: Edge<T>) -> Self {
        Self {
            x,
            id_: new_id(),
        }
    }
}

impl<T> CudnnRNNBackpropV2Op<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_HALF,
{
    pub fn new(inner: Rc<CudnnRNNBackpropV2<T>>) -> Self {
        Self{inner}
    }

    pub fn input_backprop(&self) -> Edge<T> {
        Edge::<T>::new(self.inner.clone(), 0)
    }

    pub fn input_h_backprop(&self) -> Edge<T> {
        Edge::<T>::new(self.inner.clone(), 1)
    }

    pub fn input_c_backprop(&self) -> Edge<T> {
        Edge::<T>::new(self.inner.clone(), 2)
    }

    pub fn params_backprop(&self) -> Edge<T> {
        Edge::<T>::new(self.inner.clone(), 3)
    }
}

struct CudnnRNNBackpropV2Op<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_HALF,
{
    inner: Rc<CudnnRNNBackpropV2<T>>,
}

impl<T> GraphOperation for CudnnRNNBackpropV2<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_HALF,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("CudnnRNNBackpropV2_{}")?
        };
        let mut new_op = graph.new_operation("CudnnRNNBackpropV2", &op_name)?;
        {
            match self.rnn_mode {
            }
            None => new_op.set_attr_value_proto("rnn_mode", &vec![18_u8, 4_u8, 108_u8, 115_u8, 116_u8, 109_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_string("rnn_mode", attr)})(&value),
        };
        {
            match self.input_mode {
            }
            None => new_op.set_attr_value_proto("input_mode", &vec![18_u8, 12_u8, 108_u8, 105_u8, 110_u8, 101_u8, 97_u8, 114_u8, 95_u8, 105_u8, 110_u8, 112_u8, 117_u8, 116_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_string("input_mode", attr)})(&value),
        };
        {
            match self.direction {
            }
            None => new_op.set_attr_value_proto("direction", &vec![18_u8, 14_u8, 117_u8, 110_u8, 105_u8, 100_u8, 105_u8, 114_u8, 101_u8, 99_u8, 116_u8, 105_u8, 111_u8, 110_u8, 97_u8, 108_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_string("direction", attr)})(&value),
        };
        {
            match self.dropout {
            }
            None => new_op.set_attr_value_proto("dropout", &vec![37_u8, 0_u8, 0_u8, 0_u8, 0_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_float("dropout", *attr)})(&value),
        };
        {
            match self.seed {
            }
            None => new_op.set_attr_value_proto("seed", &vec![24_u8, 0_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_int("seed", *attr)})(&value),
        };
        {
            match self.seed2 {
            }
            None => new_op.set_attr_value_proto("seed2", &vec![24_u8, 0_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_int("seed2", *attr)})(&value),
        };
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct CudnnRNNBackpropV2<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_HALF,
{
    input: Edge<T>,
    input_h: Edge<T>,
    input_c: Edge<T>,
    params: Edge<T>,
    output: Edge<T>,
    output_h: Edge<T>,
    output_c: Edge<T>,
    output_backprop: Edge<T>,
    output_h_backprop: Edge<T>,
    output_c_backprop: Edge<T>,
    reserve_space: Edge<T>,
    host_reserved: Edge<i8>,
    rnn_mode: Option<String>,
    input_mode: Option<String>,
    direction: Option<String>,
    dropout: Option<f32>,
    seed: Option<i64>,
    seed2: Option<i64>,
    id_: usize,
}

impl<T> CudnnRNNBackpropV2<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_HALF,
{
    pub fn rnn_mode(&mut self, rnn_mode: &str) -> &mut Self {
        self.rnn_mode = Some(rnn_mode.to_string());
        &self
    }

    pub fn input_mode(&mut self, input_mode: &str) -> &mut Self {
        self.input_mode = Some(input_mode.to_string());
        &self
    }

    pub fn direction(&mut self, direction: &str) -> &mut Self {
        self.direction = Some(direction.to_string());
        &self
    }

    pub fn dropout(&mut self, dropout: f32) -> &mut Self {
        self.dropout = Some(dropout);
        &self
    }

    pub fn seed(&mut self, seed: int) -> &mut Self {
        self.seed = Some(seed);
        &self
    }

    pub fn seed2(&mut self, seed2: int) -> &mut Self {
        self.seed2 = Some(seed2);
        &self
    }

    pub fn finish(self) -> CudnnRNNBackpropV2Op<T> {
        CudnnRNNBackpropV2Op::new(Rc::new(self))
    }

    pub fn new(input: Edge<T>, input_h: Edge<T>, input_c: Edge<T>, params: Edge<T>, output: Edge<T>, output_h: Edge<T>, output_c: Edge<T>, output_backprop: Edge<T>, output_h_backprop: Edge<T>, output_c_backprop: Edge<T>, reserve_space: Edge<T>, host_reserved: Edge<i8>) -> Self {
        Self {
            input,
            input_h,
            input_c,
            params,
            output,
            output_h,
            output_c,
            output_backprop,
            output_h_backprop,
            output_c_backprop,
            reserve_space,
            host_reserved,
            rnn_mode: None,
            input_mode: None,
            direction: None,
            dropout: None,
            seed: None,
            seed2: None,
            id_: new_id(),
        }
    }
}

impl<T> EnsureShapeOp<T>
where T: con,
{
    pub fn new(inner: Rc<EnsureShape<T>>) -> Self {
        Self{inner}
    }

    pub fn output(&self) -> Edge<T> {
        Edge::<T>::new(self.inner.clone(), 0)
    }
}

struct EnsureShapeOp<T>
where T: con,
{
    inner: Rc<EnsureShape<T>>,
}

impl<T> GraphOperation for EnsureShape<T>
where T: con,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("EnsureShape_{}")?
        };
        let mut new_op = graph.new_operation("EnsureShape", &op_name)?;
        {
            (|attr| {new_op.set_attr_shape("shape", attr)})(&self.shape)
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct EnsureShape<T>
where T: con,
{
    input: Edge<T>,
    shape: Shape,
    id_: usize,
}

impl<T> EnsureShape<T>
where T: con,
{
    pub fn finish(self) -> EnsureShapeOp<T> {
        EnsureShapeOp::new(Rc::new(self))
    }

    pub fn new(input: Edge<T>, shape: &Shape) -> Self {
        Self {
            input,
            shape: shape.clone()
            id_: new_id(),
        }
    }
}

impl<Tin, Tout> LookupTableFindOp<Tin, Tout>
where Tin: con,
      Tout: con,
{
    pub fn new(inner: Rc<LookupTableFind<Tin, Tout>>) -> Self {
        Self{inner}
    }

    pub fn values(&self) -> Edge<Tout> {
        Edge::<Tout>::new(self.inner.clone(), 0)
    }
}

struct LookupTableFindOp<Tin, Tout>
where Tin: con,
      Tout: con,
{
    inner: Rc<LookupTableFind<Tin, Tout>>,
}

impl<Tin, Tout> GraphOperation for LookupTableFind<Tin, Tout>
where Tin: con,
      Tout: con,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("LookupTableFind_{}")?
        };
        let mut new_op = graph.new_operation("LookupTableFind", &op_name)?;
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct LookupTableFind<Tin, Tout>
where Tin: con,
      Tout: con,
{
    table_handle: Edge<String>,
    keys: Edge<Tin>,
    default_value: Edge<Tout>,
    id_: usize,
}

impl<Tin, Tout> LookupTableFind<Tin, Tout>
where Tin: con,
      Tout: con,
{
    pub fn finish(self) -> LookupTableFindOp<Tin, Tout> {
        LookupTableFindOp::new(Rc::new(self))
    }

    pub fn new(table_handle: Edge<String>, keys: Edge<Tin>, default_value: Edge<Tout>) -> Self {
        Self {
            table_handle,
            keys,
            default_value,
            id_: new_id(),
        }
    }
}

impl<dtype> SparseConditionalAccumulatorOp<dtype>
where dtype: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
{
    pub fn new(inner: Rc<SparseConditionalAccumulator<dtype>>) -> Self {
        Self{inner}
    }

    pub fn handle(&self) -> Edge<String> {
        Edge::<String>::new(self.inner.clone(), 0)
    }
}

struct SparseConditionalAccumulatorOp<dtype>
where dtype: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
{
    inner: Rc<SparseConditionalAccumulator<dtype>>,
}

impl<dtype> GraphOperation for SparseConditionalAccumulator<dtype>
where dtype: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("SparseConditionalAccumulator_{}")?
        };
        let mut new_op = graph.new_operation("SparseConditionalAccumulator", &op_name)?;
        {
            (|attr| {new_op.set_attr_shape("shape", attr)})(&self.shape)
        }
        {
            match self.container {
            }
            None => new_op.set_attr_value_proto("container", &vec![18_u8, 0_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_string("container", attr)})(&value),
        };
        {
            match self.shared_name {
            }
            None => new_op.set_attr_value_proto("shared_name", &vec![18_u8, 0_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_string("shared_name", attr)})(&value),
        };
        {
            match self.reduction_type {
            }
            None => new_op.set_attr_value_proto("reduction_type", &vec![18_u8, 4_u8, 77_u8, 69_u8, 65_u8, 78_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_string("reduction_type", attr)})(&value),
        };
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct SparseConditionalAccumulator<dtype>
where dtype: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
{
    shape: Shape,
    container: Option<String>,
    shared_name: Option<String>,
    reduction_type: Option<String>,
    id_: usize,
}

impl<dtype> SparseConditionalAccumulator<dtype>
where dtype: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
{
    pub fn container(&mut self, container: &str) -> &mut Self {
        self.container = Some(container.to_string());
        &self
    }

    pub fn shared_name(&mut self, shared_name: &str) -> &mut Self {
        self.shared_name = Some(shared_name.to_string());
        &self
    }

    pub fn reduction_type(&mut self, reduction_type: &str) -> &mut Self {
        self.reduction_type = Some(reduction_type.to_string());
        &self
    }

    pub fn finish(self) -> SparseConditionalAccumulatorOp<dtype> {
        SparseConditionalAccumulatorOp::new(Rc::new(self))
    }

    pub fn new(shape: &Shape) -> Self {
        Self {
            shape: shape.clone()
            container: None,
            shared_name: None,
            reduction_type: None,
            id_: new_id(),
        }
    }
}

impl MfccOp {
    pub fn new(inner: Rc<Mfcc>) -> Self {
        Self{inner}
    }

    pub fn output(&self) -> Edge<f32> {
        Edge::<f32>::new(self.inner.clone(), 0)
    }
}

struct MfccOp {
    inner: Rc<Mfcc>,
}

impl GraphOperation for Mfcc {
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("Mfcc_{}")?
        };
        let mut new_op = graph.new_operation("Mfcc", &op_name)?;
        {
            match self.upper_frequency_limit {
            }
            None => new_op.set_attr_value_proto("upper_frequency_limit", &vec![37_u8, 0_u8, 0_u8, 122_u8, 69_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_float("upper_frequency_limit", *attr)})(&value),
        };
        {
            match self.lower_frequency_limit {
            }
            None => new_op.set_attr_value_proto("lower_frequency_limit", &vec![37_u8, 0_u8, 0_u8, 160_u8, 65_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_float("lower_frequency_limit", *attr)})(&value),
        };
        {
            match self.filterbank_channel_count {
            }
            None => new_op.set_attr_value_proto("filterbank_channel_count", &vec![24_u8, 40_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_int("filterbank_channel_count", *attr)})(&value),
        };
        {
            match self.dct_coefficient_count {
            }
            None => new_op.set_attr_value_proto("dct_coefficient_count", &vec![24_u8, 13_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_int("dct_coefficient_count", *attr)})(&value),
        };
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct Mfcc {
    spectrogram: Edge<f32>,
    sample_rate: Edge<i32>,
    upper_frequency_limit: Option<f32>,
    lower_frequency_limit: Option<f32>,
    filterbank_channel_count: Option<i64>,
    dct_coefficient_count: Option<i64>,
    id_: usize,
}

impl Mfcc {
    pub fn upper_frequency_limit(&mut self, upper_frequency_limit: f32) -> &mut Self {
        self.upper_frequency_limit = Some(upper_frequency_limit);
        &self
    }

    pub fn lower_frequency_limit(&mut self, lower_frequency_limit: f32) -> &mut Self {
        self.lower_frequency_limit = Some(lower_frequency_limit);
        &self
    }

    pub fn filterbank_channel_count(&mut self, filterbank_channel_count: int) -> &mut Self {
        self.filterbank_channel_count = Some(filterbank_channel_count);
        &self
    }

    pub fn dct_coefficient_count(&mut self, dct_coefficient_count: int) -> &mut Self {
        self.dct_coefficient_count = Some(dct_coefficient_count);
        &self
    }

    pub fn finish(self) -> MfccOp {
        MfccOp::new(Rc::new(self))
    }

    pub fn new(spectrogram: Edge<f32>, sample_rate: Edge<i32>) -> Self {
        Self {
            spectrogram,
            sample_rate,
            upper_frequency_limit: None,
            lower_frequency_limit: None,
            filterbank_channel_count: None,
            dct_coefficient_count: None,
            id_: new_id(),
        }
    }
}

impl<component_types> PriorityQueueOp<component_types>
where component_types: con,
{
    pub fn new(inner: Rc<PriorityQueue<component_types>>) -> Self {
        Self{inner}
    }

    pub fn handle(&self) -> Edge<String> {
        Edge::<String>::new(self.inner.clone(), 0)
    }
}

struct PriorityQueueOp<component_types>
where component_types: con,
{
    inner: Rc<PriorityQueue<component_types>>,
}

impl<component_types> GraphOperation for PriorityQueue<component_types>
where component_types: con,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("PriorityQueue_{}")?
        };
        let mut new_op = graph.new_operation("PriorityQueue", &op_name)?;
        {
            (|attrs| {new_op.set_attr_shape_list("shapes", attrs)})(&self.shapes)
        }
        {
            match self.capacity {
            }
            None => new_op.set_attr_value_proto("capacity", &vec![24_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 1_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_int("capacity", *attr)})(&value),
        };
        {
            match self.container {
            }
            None => new_op.set_attr_value_proto("container", &vec![18_u8, 0_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_string("container", attr)})(&value),
        };
        {
            match self.shared_name {
            }
            None => new_op.set_attr_value_proto("shared_name", &vec![18_u8, 0_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_string("shared_name", attr)})(&value),
        };
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct PriorityQueue<component_types>
where component_types: con,
{
    shapes: Vec<Shape>,
    capacity: Option<i64>,
    container: Option<String>,
    shared_name: Option<String>,
    id_: usize,
}

impl<component_types> PriorityQueue<component_types>
where component_types: con,
{
    pub fn capacity(&mut self, capacity: int) -> &mut Self {
        self.capacity = Some(capacity);
        &self
    }

    pub fn container(&mut self, container: &str) -> &mut Self {
        self.container = Some(container.to_string());
        &self
    }

    pub fn shared_name(&mut self, shared_name: &str) -> &mut Self {
        self.shared_name = Some(shared_name.to_string());
        &self
    }

    pub fn finish(self) -> PriorityQueueOp<component_types> {
        PriorityQueueOp::new(Rc::new(self))
    }

    pub fn new(shapes: &[Shape]) -> Self {
        Self {
            shapes: shapes.to_vec()
            capacity: None,
            container: None,
            shared_name: None,
            id_: new_id(),
        }
    }
}

impl<T> ReciprocalOp<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_COMPLEX64_or_DT_INT64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF,
{
    pub fn new(inner: Rc<Reciprocal<T>>) -> Self {
        Self{inner}
    }

    pub fn y(&self) -> Edge<T> {
        Edge::<T>::new(self.inner.clone(), 0)
    }
}

struct ReciprocalOp<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_COMPLEX64_or_DT_INT64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF,
{
    inner: Rc<Reciprocal<T>>,
}

impl<T> GraphOperation for Reciprocal<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_COMPLEX64_or_DT_INT64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("Reciprocal_{}")?
        };
        let mut new_op = graph.new_operation("Reciprocal", &op_name)?;
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct Reciprocal<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_COMPLEX64_or_DT_INT64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF,
{
    x: Edge<T>,
    id_: usize,
}

impl<T> Reciprocal<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_COMPLEX64_or_DT_INT64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF,
{
    pub fn finish(self) -> ReciprocalOp<T> {
        ReciprocalOp::new(Rc::new(self))
    }

    pub fn new(x: Edge<T>) -> Self {
        Self {
            x,
            id_: new_id(),
        }
    }
}

impl<T> BatchMatrixBandPartOp<T>
where T: con,
{
    pub fn new(inner: Rc<BatchMatrixBandPart<T>>) -> Self {
        Self{inner}
    }

    pub fn band(&self) -> Edge<T> {
        Edge::<T>::new(self.inner.clone(), 0)
    }
}

struct BatchMatrixBandPartOp<T>
where T: con,
{
    inner: Rc<BatchMatrixBandPart<T>>,
}

impl<T> GraphOperation for BatchMatrixBandPart<T>
where T: con,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("BatchMatrixBandPart_{}")?
        };
        let mut new_op = graph.new_operation("BatchMatrixBandPart", &op_name)?;
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct BatchMatrixBandPart<T>
where T: con,
{
    input: Edge<T>,
    num_lower: Edge<i64>,
    num_upper: Edge<i64>,
    id_: usize,
}

impl<T> BatchMatrixBandPart<T>
where T: con,
{
    pub fn finish(self) -> BatchMatrixBandPartOp<T> {
        BatchMatrixBandPartOp::new(Rc::new(self))
    }

    pub fn new(input: Edge<T>, num_lower: Edge<i64>, num_upper: Edge<i64>) -> Self {
        Self {
            input,
            num_lower,
            num_upper,
            id_: new_id(),
        }
    }
}

impl _InitializeHostForDistributedTPUOp {
    pub fn new(inner: Rc<_InitializeHostForDistributedTPU>) -> Self {
        Self{inner}
    }

    pub fn tpu_ids(&self) -> Edge<i32> {
        Edge::<i32>::new(self.inner.clone(), 0)
    }
}

struct _InitializeHostForDistributedTPUOp {
    inner: Rc<_InitializeHostForDistributedTPU>,
}

impl GraphOperation for _InitializeHostForDistributedTPU {
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("_InitializeHostForDistributedTPU_{}")?
        };
        let mut new_op = graph.new_operation("_InitializeHostForDistributedTPU", &op_name)?;
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct _InitializeHostForDistributedTPU {
    input: Edge<String>,
    id_: usize,
}

impl _InitializeHostForDistributedTPU {
    pub fn finish(self) -> _InitializeHostForDistributedTPUOp {
        _InitializeHostForDistributedTPUOp::new(Rc::new(self))
    }

    pub fn new(input: Edge<String>) -> Self {
        Self {
            input,
            id_: new_id(),
        }
    }
}

impl ComputeAccidentalHitsOp {
    pub fn new(inner: Rc<ComputeAccidentalHits>) -> Self {
        Self{inner}
    }

    pub fn indices(&self) -> Edge<i32> {
        Edge::<i32>::new(self.inner.clone(), 0)
    }

    pub fn ids(&self) -> Edge<i64> {
        Edge::<i64>::new(self.inner.clone(), 1)
    }

    pub fn weights(&self) -> Edge<f32> {
        Edge::<f32>::new(self.inner.clone(), 2)
    }
}

struct ComputeAccidentalHitsOp {
    inner: Rc<ComputeAccidentalHits>,
}

impl GraphOperation for ComputeAccidentalHits {
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("ComputeAccidentalHits_{}")?
        };
        let mut new_op = graph.new_operation("ComputeAccidentalHits", &op_name)?;
        {
            (|attr| {new_op.set_attr_int("num_true", *attr)})(&self.num_true)
        }
        {
            match self.seed {
            }
            None => new_op.set_attr_value_proto("seed", &vec![24_u8, 0_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_int("seed", *attr)})(&value),
        };
        {
            match self.seed2 {
            }
            None => new_op.set_attr_value_proto("seed2", &vec![24_u8, 0_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_int("seed2", *attr)})(&value),
        };
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct ComputeAccidentalHits {
    true_classes: Edge<i64>,
    sampled_candidates: Edge<i64>,
    num_true: i64,
    seed: Option<i64>,
    seed2: Option<i64>,
    id_: usize,
}

impl ComputeAccidentalHits {
    pub fn seed(&mut self, seed: int) -> &mut Self {
        self.seed = Some(seed);
        &self
    }

    pub fn seed2(&mut self, seed2: int) -> &mut Self {
        self.seed2 = Some(seed2);
        &self
    }

    pub fn finish(self) -> ComputeAccidentalHitsOp {
        ComputeAccidentalHitsOp::new(Rc::new(self))
    }

    pub fn new(true_classes: Edge<i64>, sampled_candidates: Edge<i64>, num_true: int) -> Self {
        Self {
            true_classes,
            sampled_candidates,
            num_true: num_true
            seed: None,
            seed2: None,
            id_: new_id(),
        }
    }
}

impl<T, Tindices> XlaConvOp<T, Tindices>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      Tindices: con_or_DT_INT32_or_DT_INT64,
{
    pub fn new(inner: Rc<XlaConv<T, Tindices>>) -> Self {
        Self{inner}
    }

    pub fn output(&self) -> Edge<T> {
        Edge::<T>::new(self.inner.clone(), 0)
    }
}

struct XlaConvOp<T, Tindices>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      Tindices: con_or_DT_INT32_or_DT_INT64,
{
    inner: Rc<XlaConv<T, Tindices>>,
}

impl<T, Tindices> GraphOperation for XlaConv<T, Tindices>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      Tindices: con_or_DT_INT32_or_DT_INT64,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("XlaConv_{}")?
        };
        let mut new_op = graph.new_operation("XlaConv", &op_name)?;
        {
            (|attr| {new_op.set_attr_string("dimension_numbers", attr)})(&self.dimension_numbers)
        }
        {
            (|attr| {new_op.set_attr_string("precision_config", attr)})(&self.precision_config)
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct XlaConv<T, Tindices>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      Tindices: con_or_DT_INT32_or_DT_INT64,
{
    lhs: Edge<T>,
    rhs: Edge<T>,
    window_strides: Edge<Tindices>,
    padding: Edge<Tindices>,
    lhs_dilation: Edge<Tindices>,
    rhs_dilation: Edge<Tindices>,
    feature_group_count: Edge<Tindices>,
    dimension_numbers: String,
    precision_config: String,
    id_: usize,
}

impl<T, Tindices> XlaConv<T, Tindices>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      Tindices: con_or_DT_INT32_or_DT_INT64,
{
    pub fn finish(self) -> XlaConvOp<T, Tindices> {
        XlaConvOp::new(Rc::new(self))
    }

    pub fn new(lhs: Edge<T>, rhs: Edge<T>, window_strides: Edge<Tindices>, padding: Edge<Tindices>, lhs_dilation: Edge<Tindices>, rhs_dilation: Edge<Tindices>, feature_group_count: Edge<Tindices>, dimension_numbers: &str, precision_config: &str) -> Self {
        Self {
            lhs,
            rhs,
            window_strides,
            padding,
            lhs_dilation,
            rhs_dilation,
            feature_group_count,
            dimension_numbers: dimension_numbers.to_string()
            precision_config: precision_config.to_string()
            id_: new_id(),
        }
    }
}

impl RetrieveTPUEmbeddingMomentumParametersOp {
    pub fn new(inner: Rc<RetrieveTPUEmbeddingMomentumParameters>) -> Self {
        Self{inner}
    }

    pub fn parameters(&self) -> Edge<f32> {
        Edge::<f32>::new(self.inner.clone(), 0)
    }

    pub fn momenta(&self) -> Edge<f32> {
        Edge::<f32>::new(self.inner.clone(), 1)
    }
}

struct RetrieveTPUEmbeddingMomentumParametersOp {
    inner: Rc<RetrieveTPUEmbeddingMomentumParameters>,
}

impl GraphOperation for RetrieveTPUEmbeddingMomentumParameters {
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("RetrieveTPUEmbeddingMomentumParameters_{}")?
        };
        let mut new_op = graph.new_operation("RetrieveTPUEmbeddingMomentumParameters", &op_name)?;
        {
            match self.table_id {
            }
            None => new_op.set_attr_value_proto("table_id", &vec![24_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 1_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_int("table_id", *attr)})(&value),
        };
        {
            match self.table_name {
            }
            None => new_op.set_attr_value_proto("table_name", &vec![18_u8, 0_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_string("table_name", attr)})(&value),
        };
        {
            (|attr| {new_op.set_attr_int("num_shards", *attr)})(&self.num_shards)
        }
        {
            (|attr| {new_op.set_attr_int("shard_id", *attr)})(&self.shard_id)
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct RetrieveTPUEmbeddingMomentumParameters {
    table_id: Option<i64>,
    table_name: Option<String>,
    num_shards: i64,
    shard_id: i64,
    id_: usize,
}

impl RetrieveTPUEmbeddingMomentumParameters {
    pub fn table_id(&mut self, table_id: int) -> &mut Self {
        self.table_id = Some(table_id);
        &self
    }

    pub fn table_name(&mut self, table_name: &str) -> &mut Self {
        self.table_name = Some(table_name.to_string());
        &self
    }

    pub fn finish(self) -> RetrieveTPUEmbeddingMomentumParametersOp {
        RetrieveTPUEmbeddingMomentumParametersOp::new(Rc::new(self))
    }

    pub fn new(num_shards: int, shard_id: int) -> Self {
        Self {
            table_id: None,
            table_name: None,
            num_shards: num_shards
            shard_id: shard_id
            id_: new_id(),
        }
    }
}

impl<dtype> PlaceholderV2Op<dtype>
where dtype: con,
{
    pub fn new(inner: Rc<PlaceholderV2<dtype>>) -> Self {
        Self{inner}
    }

    pub fn output(&self) -> Edge<dtype> {
        Edge::<dtype>::new(self.inner.clone(), 0)
    }
}

struct PlaceholderV2Op<dtype>
where dtype: con,
{
    inner: Rc<PlaceholderV2<dtype>>,
}

impl<dtype> GraphOperation for PlaceholderV2<dtype>
where dtype: con,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("PlaceholderV2_{}")?
        };
        let mut new_op = graph.new_operation("PlaceholderV2", &op_name)?;
        {
            (|attr| {new_op.set_attr_shape("shape", attr)})(&self.shape)
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct PlaceholderV2<dtype>
where dtype: con,
{
    shape: Shape,
    id_: usize,
}

impl<dtype> PlaceholderV2<dtype>
where dtype: con,
{
    pub fn finish(self) -> PlaceholderV2Op<dtype> {
        PlaceholderV2Op::new(Rc::new(self))
    }

    pub fn new(shape: &Shape) -> Self {
        Self {
            shape: shape.clone()
            id_: new_id(),
        }
    }
}

impl<T> BatchMatrixDiagOp<T>
where T: con,
{
    pub fn new(inner: Rc<BatchMatrixDiag<T>>) -> Self {
        Self{inner}
    }

    pub fn output(&self) -> Edge<T> {
        Edge::<T>::new(self.inner.clone(), 0)
    }
}

struct BatchMatrixDiagOp<T>
where T: con,
{
    inner: Rc<BatchMatrixDiag<T>>,
}

impl<T> GraphOperation for BatchMatrixDiag<T>
where T: con,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("BatchMatrixDiag_{}")?
        };
        let mut new_op = graph.new_operation("BatchMatrixDiag", &op_name)?;
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct BatchMatrixDiag<T>
where T: con,
{
    diagonal: Edge<T>,
    id_: usize,
}

impl<T> BatchMatrixDiag<T>
where T: con,
{
    pub fn finish(self) -> BatchMatrixDiagOp<T> {
        BatchMatrixDiagOp::new(Rc::new(self))
    }

    pub fn new(diagonal: Edge<T>) -> Self {
        Self {
            diagonal,
            id_: new_id(),
        }
    }
}

impl FakeQuantWithMinMaxArgsGradientOp {
    pub fn new(inner: Rc<FakeQuantWithMinMaxArgsGradient>) -> Self {
        Self{inner}
    }

    pub fn backprops(&self) -> Edge<f32> {
        Edge::<f32>::new(self.inner.clone(), 0)
    }
}

struct FakeQuantWithMinMaxArgsGradientOp {
    inner: Rc<FakeQuantWithMinMaxArgsGradient>,
}

impl GraphOperation for FakeQuantWithMinMaxArgsGradient {
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("FakeQuantWithMinMaxArgsGradient_{}")?
        };
        let mut new_op = graph.new_operation("FakeQuantWithMinMaxArgsGradient", &op_name)?;
        {
            match self.min {
            }
            None => new_op.set_attr_value_proto("min", &vec![37_u8, 0_u8, 0_u8, 192_u8, 192_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_float("min", *attr)})(&value),
        };
        {
            match self.max {
            }
            None => new_op.set_attr_value_proto("max", &vec![37_u8, 0_u8, 0_u8, 192_u8, 64_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_float("max", *attr)})(&value),
        };
        {
            match self.num_bits {
            }
            None => new_op.set_attr_value_proto("num_bits", &vec![24_u8, 8_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_int("num_bits", *attr)})(&value),
        };
        {
            match self.narrow_range {
            }
            None => new_op.set_attr_value_proto("narrow_range", &vec![40_u8, 0_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_bool("narrow_range", *attr)})(&value),
        };
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct FakeQuantWithMinMaxArgsGradient {
    gradients: Edge<f32>,
    inputs: Edge<f32>,
    min: Option<f32>,
    max: Option<f32>,
    num_bits: Option<i64>,
    narrow_range: Option<bool>,
    id_: usize,
}

impl FakeQuantWithMinMaxArgsGradient {
    pub fn min(&mut self, min: f32) -> &mut Self {
        self.min = Some(min);
        &self
    }

    pub fn max(&mut self, max: f32) -> &mut Self {
        self.max = Some(max);
        &self
    }

    pub fn num_bits(&mut self, num_bits: int) -> &mut Self {
        self.num_bits = Some(num_bits);
        &self
    }

    pub fn narrow_range(&mut self, narrow_range: bool) -> &mut Self {
        self.narrow_range = Some(narrow_range);
        &self
    }

    pub fn finish(self) -> FakeQuantWithMinMaxArgsGradientOp {
        FakeQuantWithMinMaxArgsGradientOp::new(Rc::new(self))
    }

    pub fn new(gradients: Edge<f32>, inputs: Edge<f32>) -> Self {
        Self {
            gradients,
            inputs,
            min: None,
            max: None,
            num_bits: None,
            narrow_range: None,
            id_: new_id(),
        }
    }
}

impl<T> InplaceUpdateOp<T>
where T: con,
{
    pub fn new(inner: Rc<InplaceUpdate<T>>) -> Self {
        Self{inner}
    }

    pub fn y(&self) -> Edge<T> {
        Edge::<T>::new(self.inner.clone(), 0)
    }
}

struct InplaceUpdateOp<T>
where T: con,
{
    inner: Rc<InplaceUpdate<T>>,
}

impl<T> GraphOperation for InplaceUpdate<T>
where T: con,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("InplaceUpdate_{}")?
        };
        let mut new_op = graph.new_operation("InplaceUpdate", &op_name)?;
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct InplaceUpdate<T>
where T: con,
{
    x: Edge<T>,
    i: Edge<i32>,
    v: Edge<T>,
    id_: usize,
}

impl<T> InplaceUpdate<T>
where T: con,
{
    pub fn finish(self) -> InplaceUpdateOp<T> {
        InplaceUpdateOp::new(Rc::new(self))
    }

    pub fn new(x: Edge<T>, i: Edge<i32>, v: Edge<T>) -> Self {
        Self {
            x,
            i,
            v,
            id_: new_id(),
        }
    }
}

impl<T> SigmoidOp<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_COMPLEX64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF,
{
    pub fn new(inner: Rc<Sigmoid<T>>) -> Self {
        Self{inner}
    }

    pub fn y(&self) -> Edge<T> {
        Edge::<T>::new(self.inner.clone(), 0)
    }
}

struct SigmoidOp<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_COMPLEX64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF,
{
    inner: Rc<Sigmoid<T>>,
}

impl<T> GraphOperation for Sigmoid<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_COMPLEX64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("Sigmoid_{}")?
        };
        let mut new_op = graph.new_operation("Sigmoid", &op_name)?;
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct Sigmoid<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_COMPLEX64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF,
{
    x: Edge<T>,
    id_: usize,
}

impl<T> Sigmoid<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_COMPLEX64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF,
{
    pub fn finish(self) -> SigmoidOp<T> {
        SigmoidOp::new(Rc::new(self))
    }

    pub fn new(x: Edge<T>) -> Self {
        Self {
            x,
            id_: new_id(),
        }
    }
}

impl TensorArrayGradOp {
    pub fn new(inner: Rc<TensorArrayGrad>) -> Self {
        Self{inner}
    }

    pub fn grad_handle(&self) -> Edge<String> {
        Edge::<String>::new(self.inner.clone(), 0)
    }
}

struct TensorArrayGradOp {
    inner: Rc<TensorArrayGrad>,
}

impl GraphOperation for TensorArrayGrad {
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("TensorArrayGrad_{}")?
        };
        let mut new_op = graph.new_operation("TensorArrayGrad", &op_name)?;
        {
            (|attr| {new_op.set_attr_string("source", attr)})(&self.source)
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct TensorArrayGrad {
    handle: Edge<String>,
    flow_in: Edge<f32>,
    source: String,
    id_: usize,
}

impl TensorArrayGrad {
    pub fn finish(self) -> TensorArrayGradOp {
        TensorArrayGradOp::new(Rc::new(self))
    }

    pub fn new(handle: Edge<String>, flow_in: Edge<f32>, source: &str) -> Self {
        Self {
            handle,
            flow_in,
            source: source.to_string()
            id_: new_id(),
        }
    }
}

impl<T> QrOp<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_COMPLEX64_or_DT_COMPLEX128,
{
    pub fn new(inner: Rc<Qr<T>>) -> Self {
        Self{inner}
    }

    pub fn q(&self) -> Edge<T> {
        Edge::<T>::new(self.inner.clone(), 0)
    }

    pub fn r(&self) -> Edge<T> {
        Edge::<T>::new(self.inner.clone(), 1)
    }
}

struct QrOp<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_COMPLEX64_or_DT_COMPLEX128,
{
    inner: Rc<Qr<T>>,
}

impl<T> GraphOperation for Qr<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_COMPLEX64_or_DT_COMPLEX128,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("Qr_{}")?
        };
        let mut new_op = graph.new_operation("Qr", &op_name)?;
        {
            match self.full_matrices {
            }
            None => new_op.set_attr_value_proto("full_matrices", &vec![40_u8, 0_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_bool("full_matrices", *attr)})(&value),
        };
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct Qr<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_COMPLEX64_or_DT_COMPLEX128,
{
    input: Edge<T>,
    full_matrices: Option<bool>,
    id_: usize,
}

impl<T> Qr<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_COMPLEX64_or_DT_COMPLEX128,
{
    pub fn full_matrices(&mut self, full_matrices: bool) -> &mut Self {
        self.full_matrices = Some(full_matrices);
        &self
    }

    pub fn finish(self) -> QrOp<T> {
        QrOp::new(Rc::new(self))
    }

    pub fn new(input: Edge<T>) -> Self {
        Self {
            input,
            full_matrices: None,
            id_: new_id(),
        }
    }
}

impl AudioSummaryOp {
    pub fn new(inner: Rc<AudioSummary>) -> Self {
        Self{inner}
    }

    pub fn summary(&self) -> Edge<String> {
        Edge::<String>::new(self.inner.clone(), 0)
    }
}

struct AudioSummaryOp {
    inner: Rc<AudioSummary>,
}

impl GraphOperation for AudioSummary {
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("AudioSummary_{}")?
        };
        let mut new_op = graph.new_operation("AudioSummary", &op_name)?;
        {
            (|attr| {new_op.set_attr_float("sample_rate", *attr)})(&self.sample_rate)
        }
        {
            match self.max_outputs {
            }
            None => new_op.set_attr_value_proto("max_outputs", &vec![24_u8, 3_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_int("max_outputs", *attr)})(&value),
        };
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct AudioSummary {
    tag: Edge<String>,
    tensor: Edge<f32>,
    sample_rate: f32,
    max_outputs: Option<i64>,
    id_: usize,
}

impl AudioSummary {
    pub fn max_outputs(&mut self, max_outputs: int) -> &mut Self {
        self.max_outputs = Some(max_outputs);
        &self
    }

    pub fn finish(self) -> AudioSummaryOp {
        AudioSummaryOp::new(Rc::new(self))
    }

    pub fn new(tag: Edge<String>, tensor: Edge<f32>, sample_rate: f32) -> Self {
        Self {
            tag,
            tensor,
            sample_rate: sample_rate
            max_outputs: None,
            id_: new_id(),
        }
    }
}

impl<T> CollectivePermuteOp<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
{
    pub fn new(inner: Rc<CollectivePermute<T>>) -> Self {
        Self{inner}
    }

    pub fn output(&self) -> Edge<T> {
        Edge::<T>::new(self.inner.clone(), 0)
    }
}

struct CollectivePermuteOp<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
{
    inner: Rc<CollectivePermute<T>>,
}

impl<T> GraphOperation for CollectivePermute<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("CollectivePermute_{}")?
        };
        let mut new_op = graph.new_operation("CollectivePermute", &op_name)?;
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct CollectivePermute<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
{
    input: Edge<T>,
    source_target_pairs: Edge<i32>,
    id_: usize,
}

impl<T> CollectivePermute<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
{
    pub fn finish(self) -> CollectivePermuteOp<T> {
        CollectivePermuteOp::new(Rc::new(self))
    }

    pub fn new(input: Edge<T>, source_target_pairs: Edge<i32>) -> Self {
        Self {
            input,
            source_target_pairs,
            id_: new_id(),
        }
    }
}

pub trait con_or_DT_COMPLEX64_or_DT_COMPLEX128_or_DT_VARIANT {
}

impl con_or_DT_COMPLEX64_or_DT_COMPLEX128_or_DT_VARIANT for OtherComplex<f32> {
}

impl con_or_DT_COMPLEX64_or_DT_COMPLEX128_or_DT_VARIANT for OtherComplex<f64> {
}

impl<T> ConjOp<T>
where T: con_or_DT_COMPLEX64_or_DT_COMPLEX128_or_DT_VARIANT,
{
    pub fn new(inner: Rc<Conj<T>>) -> Self {
        Self{inner}
    }

    pub fn output(&self) -> Edge<T> {
        Edge::<T>::new(self.inner.clone(), 0)
    }
}

struct ConjOp<T>
where T: con_or_DT_COMPLEX64_or_DT_COMPLEX128_or_DT_VARIANT,
{
    inner: Rc<Conj<T>>,
}

impl<T> GraphOperation for Conj<T>
where T: con_or_DT_COMPLEX64_or_DT_COMPLEX128_or_DT_VARIANT,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("Conj_{}")?
        };
        let mut new_op = graph.new_operation("Conj", &op_name)?;
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct Conj<T>
where T: con_or_DT_COMPLEX64_or_DT_COMPLEX128_or_DT_VARIANT,
{
    input: Edge<T>,
    id_: usize,
}

impl<T> Conj<T>
where T: con_or_DT_COMPLEX64_or_DT_COMPLEX128_or_DT_VARIANT,
{
    pub fn finish(self) -> ConjOp<T> {
        ConjOp::new(Rc::new(self))
    }

    pub fn new(input: Edge<T>) -> Self {
        Self {
            input,
            id_: new_id(),
        }
    }
}

impl RetrieveTPUEmbeddingAdadeltaParametersOp {
    pub fn new(inner: Rc<RetrieveTPUEmbeddingAdadeltaParameters>) -> Self {
        Self{inner}
    }

    pub fn parameters(&self) -> Edge<f32> {
        Edge::<f32>::new(self.inner.clone(), 0)
    }

    pub fn accumulators(&self) -> Edge<f32> {
        Edge::<f32>::new(self.inner.clone(), 1)
    }

    pub fn updates(&self) -> Edge<f32> {
        Edge::<f32>::new(self.inner.clone(), 2)
    }
}

struct RetrieveTPUEmbeddingAdadeltaParametersOp {
    inner: Rc<RetrieveTPUEmbeddingAdadeltaParameters>,
}

impl GraphOperation for RetrieveTPUEmbeddingAdadeltaParameters {
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("RetrieveTPUEmbeddingAdadeltaParameters_{}")?
        };
        let mut new_op = graph.new_operation("RetrieveTPUEmbeddingAdadeltaParameters", &op_name)?;
        {
            match self.table_id {
            }
            None => new_op.set_attr_value_proto("table_id", &vec![24_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 1_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_int("table_id", *attr)})(&value),
        };
        {
            match self.table_name {
            }
            None => new_op.set_attr_value_proto("table_name", &vec![18_u8, 0_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_string("table_name", attr)})(&value),
        };
        {
            (|attr| {new_op.set_attr_int("num_shards", *attr)})(&self.num_shards)
        }
        {
            (|attr| {new_op.set_attr_int("shard_id", *attr)})(&self.shard_id)
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct RetrieveTPUEmbeddingAdadeltaParameters {
    table_id: Option<i64>,
    table_name: Option<String>,
    num_shards: i64,
    shard_id: i64,
    id_: usize,
}

impl RetrieveTPUEmbeddingAdadeltaParameters {
    pub fn table_id(&mut self, table_id: int) -> &mut Self {
        self.table_id = Some(table_id);
        &self
    }

    pub fn table_name(&mut self, table_name: &str) -> &mut Self {
        self.table_name = Some(table_name.to_string());
        &self
    }

    pub fn finish(self) -> RetrieveTPUEmbeddingAdadeltaParametersOp {
        RetrieveTPUEmbeddingAdadeltaParametersOp::new(Rc::new(self))
    }

    pub fn new(num_shards: int, shard_id: int) -> Self {
        Self {
            table_id: None,
            table_name: None,
            num_shards: num_shards
            shard_id: shard_id
            id_: new_id(),
        }
    }
}

impl ConfigureDistributedTPUOp {
    pub fn new(inner: Rc<ConfigureDistributedTPU>) -> Self {
        Self{inner}
    }

    pub fn topology(&self) -> Edge<String> {
        Edge::<String>::new(self.inner.clone(), 0)
    }
}

struct ConfigureDistributedTPUOp {
    inner: Rc<ConfigureDistributedTPU>,
}

impl GraphOperation for ConfigureDistributedTPU {
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("ConfigureDistributedTPU_{}")?
        };
        let mut new_op = graph.new_operation("ConfigureDistributedTPU", &op_name)?;
        {
            match self.embedding_config {
            }
            None => new_op.set_attr_value_proto("embedding_config", &vec![18_u8, 0_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_string("embedding_config", attr)})(&value),
        };
        {
            match self.tpu_embedding_config {
            }
            None => new_op.set_attr_value_proto("tpu_embedding_config", &vec![18_u8, 0_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_string("tpu_embedding_config", attr)})(&value),
        };
        {
            match self.is_global_init {
            }
            None => new_op.set_attr_value_proto("is_global_init", &vec![40_u8, 0_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_bool("is_global_init", *attr)})(&value),
        };
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct ConfigureDistributedTPU {
    embedding_config: Option<String>,
    tpu_embedding_config: Option<String>,
    is_global_init: Option<bool>,
    id_: usize,
}

impl ConfigureDistributedTPU {
    pub fn embedding_config(&mut self, embedding_config: &str) -> &mut Self {
        self.embedding_config = Some(embedding_config.to_string());
        &self
    }

    pub fn tpu_embedding_config(&mut self, tpu_embedding_config: &str) -> &mut Self {
        self.tpu_embedding_config = Some(tpu_embedding_config.to_string());
        &self
    }

    pub fn is_global_init(&mut self, is_global_init: bool) -> &mut Self {
        self.is_global_init = Some(is_global_init);
        &self
    }

    pub fn finish(self) -> ConfigureDistributedTPUOp {
        ConfigureDistributedTPUOp::new(Rc::new(self))
    }

    pub fn new() -> Self {
        Self {
            embedding_config: None,
            tpu_embedding_config: None,
            is_global_init: None,
            id_: new_id(),
        }
    }
}

impl BoostedTreesMakeQuantileSummariesOp {
    pub fn new(inner: Rc<BoostedTreesMakeQuantileSummaries>) -> Self {
        Self{inner}
    }

    pub fn summaries(&self) -> Edge<f32> {
        Edge::<f32>::new(self.inner.clone(), 0)
    }
}

struct BoostedTreesMakeQuantileSummariesOp {
    inner: Rc<BoostedTreesMakeQuantileSummaries>,
}

impl GraphOperation for BoostedTreesMakeQuantileSummaries {
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("BoostedTreesMakeQuantileSummaries_{}")?
        };
        let mut new_op = graph.new_operation("BoostedTreesMakeQuantileSummaries", &op_name)?;
        {
            (|attr| {new_op.set_attr_int("num_features", *attr)})(&self.num_features)
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct BoostedTreesMakeQuantileSummaries {
    float_values: Edge<f32>,
    example_weights: Edge<f32>,
    epsilon: Edge<f32>,
    num_features: i64,
    id_: usize,
}

impl BoostedTreesMakeQuantileSummaries {
    pub fn finish(self) -> BoostedTreesMakeQuantileSummariesOp {
        BoostedTreesMakeQuantileSummariesOp::new(Rc::new(self))
    }

    pub fn new(float_values: Edge<f32>, example_weights: Edge<f32>, epsilon: Edge<f32>, num_features: int) -> Self {
        Self {
            float_values,
            example_weights,
            epsilon,
            num_features: num_features
            id_: new_id(),
        }
    }
}

impl NonMaxSuppressionOp {
    pub fn new(inner: Rc<NonMaxSuppression>) -> Self {
        Self{inner}
    }

    pub fn selected_indices(&self) -> Edge<i32> {
        Edge::<i32>::new(self.inner.clone(), 0)
    }
}

struct NonMaxSuppressionOp {
    inner: Rc<NonMaxSuppression>,
}

impl GraphOperation for NonMaxSuppression {
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("NonMaxSuppression_{}")?
        };
        let mut new_op = graph.new_operation("NonMaxSuppression", &op_name)?;
        {
            match self.iou_threshold {
            }
            None => new_op.set_attr_value_proto("iou_threshold", &vec![37_u8, 0_u8, 0_u8, 0_u8, 63_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_float("iou_threshold", *attr)})(&value),
        };
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct NonMaxSuppression {
    boxes: Edge<f32>,
    scores: Edge<f32>,
    max_output_size: Edge<i32>,
    iou_threshold: Option<f32>,
    id_: usize,
}

impl NonMaxSuppression {
    pub fn iou_threshold(&mut self, iou_threshold: f32) -> &mut Self {
        self.iou_threshold = Some(iou_threshold);
        &self
    }

    pub fn finish(self) -> NonMaxSuppressionOp {
        NonMaxSuppressionOp::new(Rc::new(self))
    }

    pub fn new(boxes: Edge<f32>, scores: Edge<f32>, max_output_size: Edge<i32>) -> Self {
        Self {
            boxes,
            scores,
            max_output_size,
            iou_threshold: None,
            id_: new_id(),
        }
    }
}

impl LoadTPUEmbeddingAdagradParametersGradAccumDebugOp {
    pub fn new(inner: Rc<LoadTPUEmbeddingAdagradParametersGradAccumDebug>) -> Self {
        Self{inner}
    }
}

struct LoadTPUEmbeddingAdagradParametersGradAccumDebugOp {
    inner: Rc<LoadTPUEmbeddingAdagradParametersGradAccumDebug>,
}

impl GraphOperation for LoadTPUEmbeddingAdagradParametersGradAccumDebug {
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("LoadTPUEmbeddingAdagradParametersGradAccumDebug_{}")?
        };
        let mut new_op = graph.new_operation("LoadTPUEmbeddingAdagradParametersGradAccumDebug", &op_name)?;
        {
            match self.table_id {
            }
            None => new_op.set_attr_value_proto("table_id", &vec![24_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 1_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_int("table_id", *attr)})(&value),
        };
        {
            match self.table_name {
            }
            None => new_op.set_attr_value_proto("table_name", &vec![18_u8, 0_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_string("table_name", attr)})(&value),
        };
        {
            (|attr| {new_op.set_attr_int("num_shards", *attr)})(&self.num_shards)
        }
        {
            (|attr| {new_op.set_attr_int("shard_id", *attr)})(&self.shard_id)
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct LoadTPUEmbeddingAdagradParametersGradAccumDebug {
    parameters: Edge<f32>,
    accumulators: Edge<f32>,
    gradient_accumulators: Edge<f32>,
    table_id: Option<i64>,
    table_name: Option<String>,
    num_shards: i64,
    shard_id: i64,
    id_: usize,
}

impl LoadTPUEmbeddingAdagradParametersGradAccumDebug {
    pub fn table_id(&mut self, table_id: int) -> &mut Self {
        self.table_id = Some(table_id);
        &self
    }

    pub fn table_name(&mut self, table_name: &str) -> &mut Self {
        self.table_name = Some(table_name.to_string());
        &self
    }

    pub fn finish(self) -> LoadTPUEmbeddingAdagradParametersGradAccumDebugOp {
        LoadTPUEmbeddingAdagradParametersGradAccumDebugOp::new(Rc::new(self))
    }

    pub fn new(parameters: Edge<f32>, accumulators: Edge<f32>, gradient_accumulators: Edge<f32>, num_shards: int, shard_id: int) -> Self {
        Self {
            parameters,
            accumulators,
            gradient_accumulators,
            table_id: None,
            table_name: None,
            num_shards: num_shards
            shard_id: shard_id
            id_: new_id(),
        }
    }
}

impl RetrieveTPUEmbeddingFTRLParametersGradAccumDebugOp {
    pub fn new(inner: Rc<RetrieveTPUEmbeddingFTRLParametersGradAccumDebug>) -> Self {
        Self{inner}
    }

    pub fn parameters(&self) -> Edge<f32> {
        Edge::<f32>::new(self.inner.clone(), 0)
    }

    pub fn accumulators(&self) -> Edge<f32> {
        Edge::<f32>::new(self.inner.clone(), 1)
    }

    pub fn linears(&self) -> Edge<f32> {
        Edge::<f32>::new(self.inner.clone(), 2)
    }

    pub fn gradient_accumulators(&self) -> Edge<f32> {
        Edge::<f32>::new(self.inner.clone(), 3)
    }
}

struct RetrieveTPUEmbeddingFTRLParametersGradAccumDebugOp {
    inner: Rc<RetrieveTPUEmbeddingFTRLParametersGradAccumDebug>,
}

impl GraphOperation for RetrieveTPUEmbeddingFTRLParametersGradAccumDebug {
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("RetrieveTPUEmbeddingFTRLParametersGradAccumDebug_{}")?
        };
        let mut new_op = graph.new_operation("RetrieveTPUEmbeddingFTRLParametersGradAccumDebug", &op_name)?;
        {
            match self.table_id {
            }
            None => new_op.set_attr_value_proto("table_id", &vec![24_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 1_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_int("table_id", *attr)})(&value),
        };
        {
            match self.table_name {
            }
            None => new_op.set_attr_value_proto("table_name", &vec![18_u8, 0_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_string("table_name", attr)})(&value),
        };
        {
            (|attr| {new_op.set_attr_int("num_shards", *attr)})(&self.num_shards)
        }
        {
            (|attr| {new_op.set_attr_int("shard_id", *attr)})(&self.shard_id)
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct RetrieveTPUEmbeddingFTRLParametersGradAccumDebug {
    table_id: Option<i64>,
    table_name: Option<String>,
    num_shards: i64,
    shard_id: i64,
    id_: usize,
}

impl RetrieveTPUEmbeddingFTRLParametersGradAccumDebug {
    pub fn table_id(&mut self, table_id: int) -> &mut Self {
        self.table_id = Some(table_id);
        &self
    }

    pub fn table_name(&mut self, table_name: &str) -> &mut Self {
        self.table_name = Some(table_name.to_string());
        &self
    }

    pub fn finish(self) -> RetrieveTPUEmbeddingFTRLParametersGradAccumDebugOp {
        RetrieveTPUEmbeddingFTRLParametersGradAccumDebugOp::new(Rc::new(self))
    }

    pub fn new(num_shards: int, shard_id: int) -> Self {
        Self {
            table_id: None,
            table_name: None,
            num_shards: num_shards
            shard_id: shard_id
            id_: new_id(),
        }
    }
}

impl BatchFFTOp {
    pub fn new(inner: Rc<BatchFFT>) -> Self {
        Self{inner}
    }

    pub fn output(&self) -> Edge<OtherComplex<f32>> {
        Edge::<OtherComplex::<f32>>::new(self.inner.clone(), 0)
    }
}

struct BatchFFTOp {
    inner: Rc<BatchFFT>,
}

impl GraphOperation for BatchFFT {
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("BatchFFT_{}")?
        };
        let mut new_op = graph.new_operation("BatchFFT", &op_name)?;
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct BatchFFT {
    input: Edge<OtherComplex<f32>>,
    id_: usize,
}

impl BatchFFT {
    pub fn finish(self) -> BatchFFTOp {
        BatchFFTOp::new(Rc::new(self))
    }

    pub fn new(input: Edge<OtherComplex<f32>>) -> Self {
        Self {
            input,
            id_: new_id(),
        }
    }
}

impl LoadTPUEmbeddingMomentumParametersGradAccumDebugOp {
    pub fn new(inner: Rc<LoadTPUEmbeddingMomentumParametersGradAccumDebug>) -> Self {
        Self{inner}
    }
}

struct LoadTPUEmbeddingMomentumParametersGradAccumDebugOp {
    inner: Rc<LoadTPUEmbeddingMomentumParametersGradAccumDebug>,
}

impl GraphOperation for LoadTPUEmbeddingMomentumParametersGradAccumDebug {
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("LoadTPUEmbeddingMomentumParametersGradAccumDebug_{}")?
        };
        let mut new_op = graph.new_operation("LoadTPUEmbeddingMomentumParametersGradAccumDebug", &op_name)?;
        {
            match self.table_id {
            }
            None => new_op.set_attr_value_proto("table_id", &vec![24_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 1_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_int("table_id", *attr)})(&value),
        };
        {
            match self.table_name {
            }
            None => new_op.set_attr_value_proto("table_name", &vec![18_u8, 0_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_string("table_name", attr)})(&value),
        };
        {
            (|attr| {new_op.set_attr_int("num_shards", *attr)})(&self.num_shards)
        }
        {
            (|attr| {new_op.set_attr_int("shard_id", *attr)})(&self.shard_id)
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct LoadTPUEmbeddingMomentumParametersGradAccumDebug {
    parameters: Edge<f32>,
    momenta: Edge<f32>,
    gradient_accumulators: Edge<f32>,
    table_id: Option<i64>,
    table_name: Option<String>,
    num_shards: i64,
    shard_id: i64,
    id_: usize,
}

impl LoadTPUEmbeddingMomentumParametersGradAccumDebug {
    pub fn table_id(&mut self, table_id: int) -> &mut Self {
        self.table_id = Some(table_id);
        &self
    }

    pub fn table_name(&mut self, table_name: &str) -> &mut Self {
        self.table_name = Some(table_name.to_string());
        &self
    }

    pub fn finish(self) -> LoadTPUEmbeddingMomentumParametersGradAccumDebugOp {
        LoadTPUEmbeddingMomentumParametersGradAccumDebugOp::new(Rc::new(self))
    }

    pub fn new(parameters: Edge<f32>, momenta: Edge<f32>, gradient_accumulators: Edge<f32>, num_shards: int, shard_id: int) -> Self {
        Self {
            parameters,
            momenta,
            gradient_accumulators,
            table_id: None,
            table_name: None,
            num_shards: num_shards
            shard_id: shard_id
            id_: new_id(),
        }
    }
}

impl<dtype, value_T> HostConstOp<dtype, value_T>
where value_T: AnyTensor,
      dtype: con,
{
    pub fn new(inner: Rc<HostConst<dtype, value_T>>) -> Self {
        Self{inner}
    }

    pub fn output(&self) -> Edge<dtype> {
        Edge::<dtype>::new(self.inner.clone(), 0)
    }
}

struct HostConstOp<dtype, value_T>
where value_T: AnyTensor,
      dtype: con,
{
    inner: Rc<HostConst<dtype, value_T>>,
}

impl<dtype, value_T> GraphOperation for HostConst<dtype, value_T>
where value_T: AnyTensor,
      dtype: con,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("HostConst_{}")?
        };
        let mut new_op = graph.new_operation("HostConst", &op_name)?;
        {
            (|attr| {new_op.set_attr_tensor("value", attr)})(&self.value)
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct HostConst<dtype, value_T>
where value_T: AnyTensor,
      dtype: con,
{
    value: value_T,
    id_: usize,
}

impl<dtype, value_T> HostConst<dtype, value_T>
where value_T: AnyTensor,
      dtype: con,
{
    pub fn finish(self) -> HostConstOp<dtype, value_T> {
        HostConstOp::new(Rc::new(self))
    }

    pub fn new(value: value_T) -> Self {
        Self {
            value: value
            id_: new_id(),
        }
    }
}

impl<T, Tidx> SumOp<T, Tidx>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      Tidx: con_or_DT_INT32_or_DT_INT64,
{
    pub fn new(inner: Rc<Sum<T, Tidx>>) -> Self {
        Self{inner}
    }

    pub fn output(&self) -> Edge<T> {
        Edge::<T>::new(self.inner.clone(), 0)
    }
}

struct SumOp<T, Tidx>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      Tidx: con_or_DT_INT32_or_DT_INT64,
{
    inner: Rc<Sum<T, Tidx>>,
}

impl<T, Tidx> GraphOperation for Sum<T, Tidx>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      Tidx: con_or_DT_INT32_or_DT_INT64,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("Sum_{}")?
        };
        let mut new_op = graph.new_operation("Sum", &op_name)?;
        {
            match self.keep_dims {
            }
            None => new_op.set_attr_value_proto("keep_dims", &vec![40_u8, 0_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_bool("keep_dims", *attr)})(&value),
        };
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct Sum<T, Tidx>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      Tidx: con_or_DT_INT32_or_DT_INT64,
{
    input: Edge<T>,
    reduction_indices: Edge<Tidx>,
    keep_dims: Option<bool>,
    id_: usize,
}

impl<T, Tidx> Sum<T, Tidx>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      Tidx: con_or_DT_INT32_or_DT_INT64,
{
    pub fn keep_dims(&mut self, keep_dims: bool) -> &mut Self {
        self.keep_dims = Some(keep_dims);
        &self
    }

    pub fn finish(self) -> SumOp<T, Tidx> {
        SumOp::new(Rc::new(self))
    }

    pub fn new(input: Edge<T>, reduction_indices: Edge<Tidx>) -> Self {
        Self {
            input,
            reduction_indices,
            keep_dims: None,
            id_: new_id(),
        }
    }
}

pub trait con_or_DT_FLOAT {
}

impl con_or_DT_FLOAT for f32 {
}

impl<T, U> FusedBatchNormGradV2Op<T, U>
where T: con_or_DT_FLOAT_or_DT_BFLOAT16_or_DT_HALF,
      U: con_or_DT_FLOAT,
{
    pub fn new(inner: Rc<FusedBatchNormGradV2<T, U>>) -> Self {
        Self{inner}
    }

    pub fn x_backprop(&self) -> Edge<T> {
        Edge::<T>::new(self.inner.clone(), 0)
    }

    pub fn scale_backprop(&self) -> Edge<U> {
        Edge::<U>::new(self.inner.clone(), 1)
    }

    pub fn offset_backprop(&self) -> Edge<U> {
        Edge::<U>::new(self.inner.clone(), 2)
    }

    pub fn reserve_space_3(&self) -> Edge<U> {
        Edge::<U>::new(self.inner.clone(), 3)
    }

    pub fn reserve_space_4(&self) -> Edge<U> {
        Edge::<U>::new(self.inner.clone(), 4)
    }
}

struct FusedBatchNormGradV2Op<T, U>
where T: con_or_DT_FLOAT_or_DT_BFLOAT16_or_DT_HALF,
      U: con_or_DT_FLOAT,
{
    inner: Rc<FusedBatchNormGradV2<T, U>>,
}

impl<T, U> GraphOperation for FusedBatchNormGradV2<T, U>
where T: con_or_DT_FLOAT_or_DT_BFLOAT16_or_DT_HALF,
      U: con_or_DT_FLOAT,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("FusedBatchNormGradV2_{}")?
        };
        let mut new_op = graph.new_operation("FusedBatchNormGradV2", &op_name)?;
        {
            match self.epsilon {
            }
            None => new_op.set_attr_value_proto("epsilon", &vec![37_u8, 23_u8, 183_u8, 209_u8, 56_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_float("epsilon", *attr)})(&value),
        };
        {
            match self.data_format {
            }
            None => new_op.set_attr_value_proto("data_format", &vec![18_u8, 4_u8, 78_u8, 72_u8, 87_u8, 67_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_string("data_format", attr)})(&value),
        };
        {
            match self.is_training {
            }
            None => new_op.set_attr_value_proto("is_training", &vec![40_u8, 1_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_bool("is_training", *attr)})(&value),
        };
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct FusedBatchNormGradV2<T, U>
where T: con_or_DT_FLOAT_or_DT_BFLOAT16_or_DT_HALF,
      U: con_or_DT_FLOAT,
{
    y_backprop: Edge<T>,
    x: Edge<T>,
    scale: Edge<f32>,
    reserve_space_1: Edge<U>,
    reserve_space_2: Edge<U>,
    epsilon: Option<f32>,
    data_format: Option<String>,
    is_training: Option<bool>,
    id_: usize,
}

impl<T, U> FusedBatchNormGradV2<T, U>
where T: con_or_DT_FLOAT_or_DT_BFLOAT16_or_DT_HALF,
      U: con_or_DT_FLOAT,
{
    pub fn epsilon(&mut self, epsilon: f32) -> &mut Self {
        self.epsilon = Some(epsilon);
        &self
    }

    pub fn data_format(&mut self, data_format: &str) -> &mut Self {
        self.data_format = Some(data_format.to_string());
        &self
    }

    pub fn is_training(&mut self, is_training: bool) -> &mut Self {
        self.is_training = Some(is_training);
        &self
    }

    pub fn finish(self) -> FusedBatchNormGradV2Op<T, U> {
        FusedBatchNormGradV2Op::new(Rc::new(self))
    }

    pub fn new(y_backprop: Edge<T>, x: Edge<T>, scale: Edge<f32>, reserve_space_1: Edge<U>, reserve_space_2: Edge<U>) -> Self {
        Self {
            y_backprop,
            x,
            scale,
            reserve_space_1,
            reserve_space_2,
            epsilon: None,
            data_format: None,
            is_training: None,
            id_: new_id(),
        }
    }
}

impl<elem_type> StackOp<elem_type>
where elem_type: con,
{
    pub fn new(inner: Rc<Stack<elem_type>>) -> Self {
        Self{inner}
    }

    pub fn handle(&self) -> Edge<String> {
        Edge::<String>::new(self.inner.clone(), 0)
    }
}

struct StackOp<elem_type>
where elem_type: con,
{
    inner: Rc<Stack<elem_type>>,
}

impl<elem_type> GraphOperation for Stack<elem_type>
where elem_type: con,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("Stack_{}")?
        };
        let mut new_op = graph.new_operation("Stack", &op_name)?;
        {
            match self.stack_name {
            }
            None => new_op.set_attr_value_proto("stack_name", &vec![18_u8, 0_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_string("stack_name", attr)})(&value),
        };
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct Stack<elem_type>
where elem_type: con,
{
    stack_name: Option<String>,
    id_: usize,
}

impl<elem_type> Stack<elem_type>
where elem_type: con,
{
    pub fn stack_name(&mut self, stack_name: &str) -> &mut Self {
        self.stack_name = Some(stack_name.to_string());
        &self
    }

    pub fn finish(self) -> StackOp<elem_type> {
        StackOp::new(Rc::new(self))
    }

    pub fn new() -> Self {
        Self {
            stack_name: None,
            id_: new_id(),
        }
    }
}

pub trait con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_COMPLEX64_or_DT_COMPLEX128_or_DT_HALF {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_COMPLEX64_or_DT_COMPLEX128_or_DT_HALF for OtherComplex<f32> {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_COMPLEX64_or_DT_COMPLEX128_or_DT_HALF for OtherComplex<f64> {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_COMPLEX64_or_DT_COMPLEX128_or_DT_HALF for f32 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_COMPLEX64_or_DT_COMPLEX128_or_DT_HALF for f64 {
}

impl<T> XlogyOp<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_COMPLEX64_or_DT_COMPLEX128_or_DT_HALF,
{
    pub fn new(inner: Rc<Xlogy<T>>) -> Self {
        Self{inner}
    }

    pub fn z(&self) -> Edge<T> {
        Edge::<T>::new(self.inner.clone(), 0)
    }
}

struct XlogyOp<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_COMPLEX64_or_DT_COMPLEX128_or_DT_HALF,
{
    inner: Rc<Xlogy<T>>,
}

impl<T> GraphOperation for Xlogy<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_COMPLEX64_or_DT_COMPLEX128_or_DT_HALF,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("Xlogy_{}")?
        };
        let mut new_op = graph.new_operation("Xlogy", &op_name)?;
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct Xlogy<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_COMPLEX64_or_DT_COMPLEX128_or_DT_HALF,
{
    x: Edge<T>,
    y: Edge<T>,
    id_: usize,
}

impl<T> Xlogy<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_COMPLEX64_or_DT_COMPLEX128_or_DT_HALF,
{
    pub fn finish(self) -> XlogyOp<T> {
        XlogyOp::new(Rc::new(self))
    }

    pub fn new(x: Edge<T>, y: Edge<T>) -> Self {
        Self {
            x,
            y,
            id_: new_id(),
        }
    }
}

impl<T> EditDistanceOp<T>
where T: con,
{
    pub fn new(inner: Rc<EditDistance<T>>) -> Self {
        Self{inner}
    }

    pub fn output(&self) -> Edge<f32> {
        Edge::<f32>::new(self.inner.clone(), 0)
    }
}

struct EditDistanceOp<T>
where T: con,
{
    inner: Rc<EditDistance<T>>,
}

impl<T> GraphOperation for EditDistance<T>
where T: con,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("EditDistance_{}")?
        };
        let mut new_op = graph.new_operation("EditDistance", &op_name)?;
        {
            match self.normalize {
            }
            None => new_op.set_attr_value_proto("normalize", &vec![40_u8, 1_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_bool("normalize", *attr)})(&value),
        };
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct EditDistance<T>
where T: con,
{
    hypothesis_indices: Edge<i64>,
    hypothesis_values: Edge<T>,
    hypothesis_shape: Edge<i64>,
    truth_indices: Edge<i64>,
    truth_values: Edge<T>,
    truth_shape: Edge<i64>,
    normalize: Option<bool>,
    id_: usize,
}

impl<T> EditDistance<T>
where T: con,
{
    pub fn normalize(&mut self, normalize: bool) -> &mut Self {
        self.normalize = Some(normalize);
        &self
    }

    pub fn finish(self) -> EditDistanceOp<T> {
        EditDistanceOp::new(Rc::new(self))
    }

    pub fn new(hypothesis_indices: Edge<i64>, hypothesis_values: Edge<T>, hypothesis_shape: Edge<i64>, truth_indices: Edge<i64>, truth_values: Edge<T>, truth_shape: Edge<i64>) -> Self {
        Self {
            hypothesis_indices,
            hypothesis_values,
            hypothesis_shape,
            truth_indices,
            truth_values,
            truth_shape,
            normalize: None,
            id_: new_id(),
        }
    }
}

impl AccumulatorNumAccumulatedOp {
    pub fn new(inner: Rc<AccumulatorNumAccumulated>) -> Self {
        Self{inner}
    }

    pub fn num_accumulated(&self) -> Edge<i32> {
        Edge::<i32>::new(self.inner.clone(), 0)
    }
}

struct AccumulatorNumAccumulatedOp {
    inner: Rc<AccumulatorNumAccumulated>,
}

impl GraphOperation for AccumulatorNumAccumulated {
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("AccumulatorNumAccumulated_{}")?
        };
        let mut new_op = graph.new_operation("AccumulatorNumAccumulated", &op_name)?;
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct AccumulatorNumAccumulated {
    handle: Edge<String>,
    id_: usize,
}

impl AccumulatorNumAccumulated {
    pub fn finish(self) -> AccumulatorNumAccumulatedOp {
        AccumulatorNumAccumulatedOp::new(Rc::new(self))
    }

    pub fn new(handle: Edge<String>) -> Self {
        Self {
            handle,
            id_: new_id(),
        }
    }
}

pub trait con_or_DT_INT32_or_DT_UINT8_or_DT_INT64 {
}

impl con_or_DT_INT32_or_DT_UINT8_or_DT_INT64 for i32 {
}

impl con_or_DT_INT32_or_DT_UINT8_or_DT_INT64 for i64 {
}

impl con_or_DT_INT32_or_DT_UINT8_or_DT_INT64 for u8 {
}

impl<TI, T> OneHotOp<TI, T>
where T: con,
      TI: con_or_DT_INT32_or_DT_UINT8_or_DT_INT64,
{
    pub fn new(inner: Rc<OneHot<TI, T>>) -> Self {
        Self{inner}
    }

    pub fn output(&self) -> Edge<T> {
        Edge::<T>::new(self.inner.clone(), 0)
    }
}

struct OneHotOp<TI, T>
where T: con,
      TI: con_or_DT_INT32_or_DT_UINT8_or_DT_INT64,
{
    inner: Rc<OneHot<TI, T>>,
}

impl<TI, T> GraphOperation for OneHot<TI, T>
where T: con,
      TI: con_or_DT_INT32_or_DT_UINT8_or_DT_INT64,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("OneHot_{}")?
        };
        let mut new_op = graph.new_operation("OneHot", &op_name)?;
        {
            match self.axis {
            }
            None => new_op.set_attr_value_proto("axis", &vec![24_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 1_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_int("axis", *attr)})(&value),
        };
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct OneHot<TI, T>
where T: con,
      TI: con_or_DT_INT32_or_DT_UINT8_or_DT_INT64,
{
    indices: Edge<TI>,
    depth: Edge<i32>,
    on_value: Edge<T>,
    off_value: Edge<T>,
    axis: Option<i64>,
    id_: usize,
}

impl<TI, T> OneHot<TI, T>
where T: con,
      TI: con_or_DT_INT32_or_DT_UINT8_or_DT_INT64,
{
    pub fn axis(&mut self, axis: int) -> &mut Self {
        self.axis = Some(axis);
        &self
    }

    pub fn finish(self) -> OneHotOp<TI, T> {
        OneHotOp::new(Rc::new(self))
    }

    pub fn new(indices: Edge<TI>, depth: Edge<i32>, on_value: Edge<T>, off_value: Edge<T>) -> Self {
        Self {
            indices,
            depth,
            on_value,
            off_value,
            axis: None,
            id_: new_id(),
        }
    }
}

impl<T, Tperm> ConjugateTransposeOp<T, Tperm>
where T: con,
      Tperm: con_or_DT_INT32_or_DT_INT64,
{
    pub fn new(inner: Rc<ConjugateTranspose<T, Tperm>>) -> Self {
        Self{inner}
    }

    pub fn y(&self) -> Edge<T> {
        Edge::<T>::new(self.inner.clone(), 0)
    }
}

struct ConjugateTransposeOp<T, Tperm>
where T: con,
      Tperm: con_or_DT_INT32_or_DT_INT64,
{
    inner: Rc<ConjugateTranspose<T, Tperm>>,
}

impl<T, Tperm> GraphOperation for ConjugateTranspose<T, Tperm>
where T: con,
      Tperm: con_or_DT_INT32_or_DT_INT64,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("ConjugateTranspose_{}")?
        };
        let mut new_op = graph.new_operation("ConjugateTranspose", &op_name)?;
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct ConjugateTranspose<T, Tperm>
where T: con,
      Tperm: con_or_DT_INT32_or_DT_INT64,
{
    x: Edge<T>,
    perm: Edge<Tperm>,
    id_: usize,
}

impl<T, Tperm> ConjugateTranspose<T, Tperm>
where T: con,
      Tperm: con_or_DT_INT32_or_DT_INT64,
{
    pub fn finish(self) -> ConjugateTransposeOp<T, Tperm> {
        ConjugateTransposeOp::new(Rc::new(self))
    }

    pub fn new(x: Edge<T>, perm: Edge<Tperm>) -> Self {
        Self {
            x,
            perm,
            id_: new_id(),
        }
    }
}

pub trait con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BOOL_or_DT_HALF {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BOOL_or_DT_HALF for bool {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BOOL_or_DT_HALF for f32 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BOOL_or_DT_HALF for f64 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BOOL_or_DT_HALF for i16 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BOOL_or_DT_HALF for i32 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BOOL_or_DT_HALF for i64 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BOOL_or_DT_HALF for i8 {
}

impl<T> CompareAndBitpackOp<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BOOL_or_DT_HALF,
{
    pub fn new(inner: Rc<CompareAndBitpack<T>>) -> Self {
        Self{inner}
    }

    pub fn output(&self) -> Edge<u8> {
        Edge::<u8>::new(self.inner.clone(), 0)
    }
}

struct CompareAndBitpackOp<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BOOL_or_DT_HALF,
{
    inner: Rc<CompareAndBitpack<T>>,
}

impl<T> GraphOperation for CompareAndBitpack<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BOOL_or_DT_HALF,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("CompareAndBitpack_{}")?
        };
        let mut new_op = graph.new_operation("CompareAndBitpack", &op_name)?;
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct CompareAndBitpack<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BOOL_or_DT_HALF,
{
    input: Edge<T>,
    threshold: Edge<T>,
    id_: usize,
}

impl<T> CompareAndBitpack<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BOOL_or_DT_HALF,
{
    pub fn finish(self) -> CompareAndBitpackOp<T> {
        CompareAndBitpackOp::new(Rc::new(self))
    }

    pub fn new(input: Edge<T>, threshold: Edge<T>) -> Self {
        Self {
            input,
            threshold,
            id_: new_id(),
        }
    }
}

impl RetrieveTPUEmbeddingAdagradParametersOp {
    pub fn new(inner: Rc<RetrieveTPUEmbeddingAdagradParameters>) -> Self {
        Self{inner}
    }

    pub fn parameters(&self) -> Edge<f32> {
        Edge::<f32>::new(self.inner.clone(), 0)
    }

    pub fn accumulators(&self) -> Edge<f32> {
        Edge::<f32>::new(self.inner.clone(), 1)
    }
}

struct RetrieveTPUEmbeddingAdagradParametersOp {
    inner: Rc<RetrieveTPUEmbeddingAdagradParameters>,
}

impl GraphOperation for RetrieveTPUEmbeddingAdagradParameters {
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("RetrieveTPUEmbeddingAdagradParameters_{}")?
        };
        let mut new_op = graph.new_operation("RetrieveTPUEmbeddingAdagradParameters", &op_name)?;
        {
            match self.table_id {
            }
            None => new_op.set_attr_value_proto("table_id", &vec![24_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 1_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_int("table_id", *attr)})(&value),
        };
        {
            match self.table_name {
            }
            None => new_op.set_attr_value_proto("table_name", &vec![18_u8, 0_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_string("table_name", attr)})(&value),
        };
        {
            (|attr| {new_op.set_attr_int("num_shards", *attr)})(&self.num_shards)
        }
        {
            (|attr| {new_op.set_attr_int("shard_id", *attr)})(&self.shard_id)
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct RetrieveTPUEmbeddingAdagradParameters {
    table_id: Option<i64>,
    table_name: Option<String>,
    num_shards: i64,
    shard_id: i64,
    id_: usize,
}

impl RetrieveTPUEmbeddingAdagradParameters {
    pub fn table_id(&mut self, table_id: int) -> &mut Self {
        self.table_id = Some(table_id);
        &self
    }

    pub fn table_name(&mut self, table_name: &str) -> &mut Self {
        self.table_name = Some(table_name.to_string());
        &self
    }

    pub fn finish(self) -> RetrieveTPUEmbeddingAdagradParametersOp {
        RetrieveTPUEmbeddingAdagradParametersOp::new(Rc::new(self))
    }

    pub fn new(num_shards: int, shard_id: int) -> Self {
        Self {
            table_id: None,
            table_name: None,
            num_shards: num_shards
            shard_id: shard_id
            id_: new_id(),
        }
    }
}

impl<T> CountUpToOp<T>
where T: con_or_DT_INT32_or_DT_INT64,
{
    pub fn new(inner: Rc<CountUpTo<T>>) -> Self {
        Self{inner}
    }

    pub fn output(&self) -> Edge<T> {
        Edge::<T>::new(self.inner.clone(), 0)
    }
}

struct CountUpToOp<T>
where T: con_or_DT_INT32_or_DT_INT64,
{
    inner: Rc<CountUpTo<T>>,
}

impl<T> GraphOperation for CountUpTo<T>
where T: con_or_DT_INT32_or_DT_INT64,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("CountUpTo_{}")?
        };
        let mut new_op = graph.new_operation("CountUpTo", &op_name)?;
        {
            (|attr| {new_op.set_attr_int("limit", *attr)})(&self.limit)
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct CountUpTo<T>
where T: con_or_DT_INT32_or_DT_INT64,
{
    ref_: Edge<T>,
    limit: i64,
    id_: usize,
}

impl<T> CountUpTo<T>
where T: con_or_DT_INT32_or_DT_INT64,
{
    pub fn finish(self) -> CountUpToOp<T> {
        CountUpToOp::new(Rc::new(self))
    }

    pub fn new(ref_: Edge<T>, limit: int) -> Self {
        Self {
            ref_,
            limit: limit
            id_: new_id(),
        }
    }
}

impl<T> CudnnRNNCanonicalToParamsOp<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_HALF,
{
    pub fn new(inner: Rc<CudnnRNNCanonicalToParams<T>>) -> Self {
        Self{inner}
    }

    pub fn params(&self) -> Edge<T> {
        Edge::<T>::new(self.inner.clone(), 0)
    }
}

struct CudnnRNNCanonicalToParamsOp<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_HALF,
{
    inner: Rc<CudnnRNNCanonicalToParams<T>>,
}

impl<T> GraphOperation for CudnnRNNCanonicalToParams<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_HALF,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("CudnnRNNCanonicalToParams_{}")?
        };
        let mut new_op = graph.new_operation("CudnnRNNCanonicalToParams", &op_name)?;
        {
            (|attr| {new_op.set_attr_int("num_params", *attr)})(&self.num_params)
        }
        {
            match self.rnn_mode {
            }
            None => new_op.set_attr_value_proto("rnn_mode", &vec![18_u8, 4_u8, 108_u8, 115_u8, 116_u8, 109_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_string("rnn_mode", attr)})(&value),
        };
        {
            match self.input_mode {
            }
            None => new_op.set_attr_value_proto("input_mode", &vec![18_u8, 12_u8, 108_u8, 105_u8, 110_u8, 101_u8, 97_u8, 114_u8, 95_u8, 105_u8, 110_u8, 112_u8, 117_u8, 116_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_string("input_mode", attr)})(&value),
        };
        {
            match self.direction {
            }
            None => new_op.set_attr_value_proto("direction", &vec![18_u8, 14_u8, 117_u8, 110_u8, 105_u8, 100_u8, 105_u8, 114_u8, 101_u8, 99_u8, 116_u8, 105_u8, 111_u8, 110_u8, 97_u8, 108_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_string("direction", attr)})(&value),
        };
        {
            match self.dropout {
            }
            None => new_op.set_attr_value_proto("dropout", &vec![37_u8, 0_u8, 0_u8, 0_u8, 0_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_float("dropout", *attr)})(&value),
        };
        {
            match self.seed {
            }
            None => new_op.set_attr_value_proto("seed", &vec![24_u8, 0_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_int("seed", *attr)})(&value),
        };
        {
            match self.seed2 {
            }
            None => new_op.set_attr_value_proto("seed2", &vec![24_u8, 0_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_int("seed2", *attr)})(&value),
        };
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct CudnnRNNCanonicalToParams<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_HALF,
{
    num_layers: Edge<i32>,
    num_units: Edge<i32>,
    input_size: Edge<i32>,
    weights: Edge<T>,
    biases: Edge<T>,
    num_params: i64,
    rnn_mode: Option<String>,
    input_mode: Option<String>,
    direction: Option<String>,
    dropout: Option<f32>,
    seed: Option<i64>,
    seed2: Option<i64>,
    id_: usize,
}

impl<T> CudnnRNNCanonicalToParams<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_HALF,
{
    pub fn rnn_mode(&mut self, rnn_mode: &str) -> &mut Self {
        self.rnn_mode = Some(rnn_mode.to_string());
        &self
    }

    pub fn input_mode(&mut self, input_mode: &str) -> &mut Self {
        self.input_mode = Some(input_mode.to_string());
        &self
    }

    pub fn direction(&mut self, direction: &str) -> &mut Self {
        self.direction = Some(direction.to_string());
        &self
    }

    pub fn dropout(&mut self, dropout: f32) -> &mut Self {
        self.dropout = Some(dropout);
        &self
    }

    pub fn seed(&mut self, seed: int) -> &mut Self {
        self.seed = Some(seed);
        &self
    }

    pub fn seed2(&mut self, seed2: int) -> &mut Self {
        self.seed2 = Some(seed2);
        &self
    }

    pub fn finish(self) -> CudnnRNNCanonicalToParamsOp<T> {
        CudnnRNNCanonicalToParamsOp::new(Rc::new(self))
    }

    pub fn new(num_layers: Edge<i32>, num_units: Edge<i32>, input_size: Edge<i32>, weights: Edge<T>, biases: Edge<T>, num_params: int) -> Self {
        Self {
            num_layers,
            num_units,
            input_size,
            weights,
            biases,
            num_params: num_params
            rnn_mode: None,
            input_mode: None,
            direction: None,
            dropout: None,
            seed: None,
            seed2: None,
            id_: new_id(),
        }
    }
}

impl<Ta, Tb> SparseMatMulOp<Ta, Tb>
where Ta: con_or_DT_FLOAT_or_DT_BFLOAT16,
      Tb: con_or_DT_FLOAT_or_DT_BFLOAT16,
{
    pub fn new(inner: Rc<SparseMatMul<Ta, Tb>>) -> Self {
        Self{inner}
    }

    pub fn product(&self) -> Edge<f32> {
        Edge::<f32>::new(self.inner.clone(), 0)
    }
}

struct SparseMatMulOp<Ta, Tb>
where Ta: con_or_DT_FLOAT_or_DT_BFLOAT16,
      Tb: con_or_DT_FLOAT_or_DT_BFLOAT16,
{
    inner: Rc<SparseMatMul<Ta, Tb>>,
}

impl<Ta, Tb> GraphOperation for SparseMatMul<Ta, Tb>
where Ta: con_or_DT_FLOAT_or_DT_BFLOAT16,
      Tb: con_or_DT_FLOAT_or_DT_BFLOAT16,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("SparseMatMul_{}")?
        };
        let mut new_op = graph.new_operation("SparseMatMul", &op_name)?;
        {
            match self.transpose_a {
            }
            None => new_op.set_attr_value_proto("transpose_a", &vec![40_u8, 0_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_bool("transpose_a", *attr)})(&value),
        };
        {
            match self.transpose_b {
            }
            None => new_op.set_attr_value_proto("transpose_b", &vec![40_u8, 0_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_bool("transpose_b", *attr)})(&value),
        };
        {
            match self.a_is_sparse {
            }
            None => new_op.set_attr_value_proto("a_is_sparse", &vec![40_u8, 0_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_bool("a_is_sparse", *attr)})(&value),
        };
        {
            match self.b_is_sparse {
            }
            None => new_op.set_attr_value_proto("b_is_sparse", &vec![40_u8, 0_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_bool("b_is_sparse", *attr)})(&value),
        };
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct SparseMatMul<Ta, Tb>
where Ta: con_or_DT_FLOAT_or_DT_BFLOAT16,
      Tb: con_or_DT_FLOAT_or_DT_BFLOAT16,
{
    a: Edge<Ta>,
    b: Edge<Tb>,
    transpose_a: Option<bool>,
    transpose_b: Option<bool>,
    a_is_sparse: Option<bool>,
    b_is_sparse: Option<bool>,
    id_: usize,
}

impl<Ta, Tb> SparseMatMul<Ta, Tb>
where Ta: con_or_DT_FLOAT_or_DT_BFLOAT16,
      Tb: con_or_DT_FLOAT_or_DT_BFLOAT16,
{
    pub fn transpose_a(&mut self, transpose_a: bool) -> &mut Self {
        self.transpose_a = Some(transpose_a);
        &self
    }

    pub fn transpose_b(&mut self, transpose_b: bool) -> &mut Self {
        self.transpose_b = Some(transpose_b);
        &self
    }

    pub fn a_is_sparse(&mut self, a_is_sparse: bool) -> &mut Self {
        self.a_is_sparse = Some(a_is_sparse);
        &self
    }

    pub fn b_is_sparse(&mut self, b_is_sparse: bool) -> &mut Self {
        self.b_is_sparse = Some(b_is_sparse);
        &self
    }

    pub fn finish(self) -> SparseMatMulOp<Ta, Tb> {
        SparseMatMulOp::new(Rc::new(self))
    }

    pub fn new(a: Edge<Ta>, b: Edge<Tb>) -> Self {
        Self {
            a,
            b,
            transpose_a: None,
            transpose_b: None,
            a_is_sparse: None,
            b_is_sparse: None,
            id_: new_id(),
        }
    }
}

impl TPUEmbeddingActivationsOp {
    pub fn new(inner: Rc<TPUEmbeddingActivations>) -> Self {
        Self{inner}
    }

    pub fn output(&self) -> Edge<f32> {
        Edge::<f32>::new(self.inner.clone(), 0)
    }
}

struct TPUEmbeddingActivationsOp {
    inner: Rc<TPUEmbeddingActivations>,
}

impl GraphOperation for TPUEmbeddingActivations {
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("TPUEmbeddingActivations_{}")?
        };
        let mut new_op = graph.new_operation("TPUEmbeddingActivations", &op_name)?;
        {
            (|attr| {new_op.set_attr_int("table_id", *attr)})(&self.table_id)
        }
        {
            (|attr| {new_op.set_attr_int("lookup_id", *attr)})(&self.lookup_id)
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct TPUEmbeddingActivations {
    embedding_variable: Edge<f32>,
    sliced_activations: Edge<f32>,
    table_id: i64,
    lookup_id: i64,
    id_: usize,
}

impl TPUEmbeddingActivations {
    pub fn finish(self) -> TPUEmbeddingActivationsOp {
        TPUEmbeddingActivationsOp::new(Rc::new(self))
    }

    pub fn new(embedding_variable: Edge<f32>, sliced_activations: Edge<f32>, table_id: int, lookup_id: int) -> Self {
        Self {
            embedding_variable,
            sliced_activations,
            table_id: table_id
            lookup_id: lookup_id
            id_: new_id(),
        }
    }
}

impl<T> InplaceSubOp<T>
where T: con,
{
    pub fn new(inner: Rc<InplaceSub<T>>) -> Self {
        Self{inner}
    }

    pub fn y(&self) -> Edge<T> {
        Edge::<T>::new(self.inner.clone(), 0)
    }
}

struct InplaceSubOp<T>
where T: con,
{
    inner: Rc<InplaceSub<T>>,
}

impl<T> GraphOperation for InplaceSub<T>
where T: con,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("InplaceSub_{}")?
        };
        let mut new_op = graph.new_operation("InplaceSub", &op_name)?;
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct InplaceSub<T>
where T: con,
{
    x: Edge<T>,
    i: Edge<i32>,
    v: Edge<T>,
    id_: usize,
}

impl<T> InplaceSub<T>
where T: con,
{
    pub fn finish(self) -> InplaceSubOp<T> {
        InplaceSubOp::new(Rc::new(self))
    }

    pub fn new(x: Edge<T>, i: Edge<i32>, v: Edge<T>) -> Self {
        Self {
            x,
            i,
            v,
            id_: new_id(),
        }
    }
}

impl LoadTPUEmbeddingRMSPropParametersOp {
    pub fn new(inner: Rc<LoadTPUEmbeddingRMSPropParameters>) -> Self {
        Self{inner}
    }
}

struct LoadTPUEmbeddingRMSPropParametersOp {
    inner: Rc<LoadTPUEmbeddingRMSPropParameters>,
}

impl GraphOperation for LoadTPUEmbeddingRMSPropParameters {
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("LoadTPUEmbeddingRMSPropParameters_{}")?
        };
        let mut new_op = graph.new_operation("LoadTPUEmbeddingRMSPropParameters", &op_name)?;
        {
            match self.table_id {
            }
            None => new_op.set_attr_value_proto("table_id", &vec![24_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 1_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_int("table_id", *attr)})(&value),
        };
        {
            match self.table_name {
            }
            None => new_op.set_attr_value_proto("table_name", &vec![18_u8, 0_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_string("table_name", attr)})(&value),
        };
        {
            (|attr| {new_op.set_attr_int("num_shards", *attr)})(&self.num_shards)
        }
        {
            (|attr| {new_op.set_attr_int("shard_id", *attr)})(&self.shard_id)
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct LoadTPUEmbeddingRMSPropParameters {
    parameters: Edge<f32>,
    ms: Edge<f32>,
    mom: Edge<f32>,
    table_id: Option<i64>,
    table_name: Option<String>,
    num_shards: i64,
    shard_id: i64,
    id_: usize,
}

impl LoadTPUEmbeddingRMSPropParameters {
    pub fn table_id(&mut self, table_id: int) -> &mut Self {
        self.table_id = Some(table_id);
        &self
    }

    pub fn table_name(&mut self, table_name: &str) -> &mut Self {
        self.table_name = Some(table_name.to_string());
        &self
    }

    pub fn finish(self) -> LoadTPUEmbeddingRMSPropParametersOp {
        LoadTPUEmbeddingRMSPropParametersOp::new(Rc::new(self))
    }

    pub fn new(parameters: Edge<f32>, ms: Edge<f32>, mom: Edge<f32>, num_shards: int, shard_id: int) -> Self {
        Self {
            parameters,
            ms,
            mom,
            table_id: None,
            table_name: None,
            num_shards: num_shards
            shard_id: shard_id
            id_: new_id(),
        }
    }
}

impl<T> CopyOp<T>
where T: con,
{
    pub fn new(inner: Rc<Copy<T>>) -> Self {
        Self{inner}
    }

    pub fn output(&self) -> Edge<T> {
        Edge::<T>::new(self.inner.clone(), 0)
    }
}

struct CopyOp<T>
where T: con,
{
    inner: Rc<Copy<T>>,
}

impl<T> GraphOperation for Copy<T>
where T: con,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("Copy_{}")?
        };
        let mut new_op = graph.new_operation("Copy", &op_name)?;
        {
            match self.tensor_name {
            }
            None => new_op.set_attr_value_proto("tensor_name", &vec![18_u8, 0_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_string("tensor_name", attr)})(&value),
        };
        {
            match self.debug_ops_spec {
            }
            None => new_op.set_attr_value_proto("debug_ops_spec", &vec![10_u8, 0_u8,]);,
            Some(value) => (|attrs| {new_op.set_attr_string_list("debug_ops_spec", attrs)})(&value),
        };
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct Copy<T>
where T: con,
{
    input: Edge<T>,
    tensor_name: Option<String>,
    debug_ops_spec: Option<Vec<String>>,
    id_: usize,
}

impl<T> Copy<T>
where T: con,
{
    pub fn tensor_name(&mut self, tensor_name: &str) -> &mut Self {
        self.tensor_name = Some(tensor_name.to_string());
        &self
    }

    pub fn debug_ops_spec(&mut self, debug_ops_spec: &[String]) -> &mut Self {
        self.debug_ops_spec = Some(debug_ops_spec.to_vec());
        &self
    }

    pub fn finish(self) -> CopyOp<T> {
        CopyOp::new(Rc::new(self))
    }

    pub fn new(input: Edge<T>) -> Self {
        Self {
            input,
            tensor_name: None,
            debug_ops_spec: None,
            id_: new_id(),
        }
    }
}

impl<Index, T> StridedSliceGradOp<Index, T>
where T: con,
      Index: con_or_DT_INT32_or_DT_INT64,
{
    pub fn new(inner: Rc<StridedSliceGrad<Index, T>>) -> Self {
        Self{inner}
    }

    pub fn output(&self) -> Edge<T> {
        Edge::<T>::new(self.inner.clone(), 0)
    }
}

struct StridedSliceGradOp<Index, T>
where T: con,
      Index: con_or_DT_INT32_or_DT_INT64,
{
    inner: Rc<StridedSliceGrad<Index, T>>,
}

impl<Index, T> GraphOperation for StridedSliceGrad<Index, T>
where T: con,
      Index: con_or_DT_INT32_or_DT_INT64,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("StridedSliceGrad_{}")?
        };
        let mut new_op = graph.new_operation("StridedSliceGrad", &op_name)?;
        {
            match self.begin_mask {
            }
            None => new_op.set_attr_value_proto("begin_mask", &vec![24_u8, 0_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_int("begin_mask", *attr)})(&value),
        };
        {
            match self.end_mask {
            }
            None => new_op.set_attr_value_proto("end_mask", &vec![24_u8, 0_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_int("end_mask", *attr)})(&value),
        };
        {
            match self.ellipsis_mask {
            }
            None => new_op.set_attr_value_proto("ellipsis_mask", &vec![24_u8, 0_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_int("ellipsis_mask", *attr)})(&value),
        };
        {
            match self.new_axis_mask {
            }
            None => new_op.set_attr_value_proto("new_axis_mask", &vec![24_u8, 0_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_int("new_axis_mask", *attr)})(&value),
        };
        {
            match self.shrink_axis_mask {
            }
            None => new_op.set_attr_value_proto("shrink_axis_mask", &vec![24_u8, 0_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_int("shrink_axis_mask", *attr)})(&value),
        };
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct StridedSliceGrad<Index, T>
where T: con,
      Index: con_or_DT_INT32_or_DT_INT64,
{
    shape: Edge<Index>,
    begin: Edge<Index>,
    end: Edge<Index>,
    strides: Edge<Index>,
    dy: Edge<T>,
    begin_mask: Option<i64>,
    end_mask: Option<i64>,
    ellipsis_mask: Option<i64>,
    new_axis_mask: Option<i64>,
    shrink_axis_mask: Option<i64>,
    id_: usize,
}

impl<Index, T> StridedSliceGrad<Index, T>
where T: con,
      Index: con_or_DT_INT32_or_DT_INT64,
{
    pub fn begin_mask(&mut self, begin_mask: int) -> &mut Self {
        self.begin_mask = Some(begin_mask);
        &self
    }

    pub fn end_mask(&mut self, end_mask: int) -> &mut Self {
        self.end_mask = Some(end_mask);
        &self
    }

    pub fn ellipsis_mask(&mut self, ellipsis_mask: int) -> &mut Self {
        self.ellipsis_mask = Some(ellipsis_mask);
        &self
    }

    pub fn new_axis_mask(&mut self, new_axis_mask: int) -> &mut Self {
        self.new_axis_mask = Some(new_axis_mask);
        &self
    }

    pub fn shrink_axis_mask(&mut self, shrink_axis_mask: int) -> &mut Self {
        self.shrink_axis_mask = Some(shrink_axis_mask);
        &self
    }

    pub fn finish(self) -> StridedSliceGradOp<Index, T> {
        StridedSliceGradOp::new(Rc::new(self))
    }

    pub fn new(shape: Edge<Index>, begin: Edge<Index>, end: Edge<Index>, strides: Edge<Index>, dy: Edge<T>) -> Self {
        Self {
            shape,
            begin,
            end,
            strides,
            dy,
            begin_mask: None,
            end_mask: None,
            ellipsis_mask: None,
            new_axis_mask: None,
            shrink_axis_mask: None,
            id_: new_id(),
        }
    }
}

impl<Tidx> UnravelIndexOp<Tidx>
where Tidx: con_or_DT_INT32_or_DT_INT64,
{
    pub fn new(inner: Rc<UnravelIndex<Tidx>>) -> Self {
        Self{inner}
    }

    pub fn output(&self) -> Edge<Tidx> {
        Edge::<Tidx>::new(self.inner.clone(), 0)
    }
}

struct UnravelIndexOp<Tidx>
where Tidx: con_or_DT_INT32_or_DT_INT64,
{
    inner: Rc<UnravelIndex<Tidx>>,
}

impl<Tidx> GraphOperation for UnravelIndex<Tidx>
where Tidx: con_or_DT_INT32_or_DT_INT64,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("UnravelIndex_{}")?
        };
        let mut new_op = graph.new_operation("UnravelIndex", &op_name)?;
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct UnravelIndex<Tidx>
where Tidx: con_or_DT_INT32_or_DT_INT64,
{
    indices: Edge<Tidx>,
    dims: Edge<Tidx>,
    id_: usize,
}

impl<Tidx> UnravelIndex<Tidx>
where Tidx: con_or_DT_INT32_or_DT_INT64,
{
    pub fn finish(self) -> UnravelIndexOp<Tidx> {
        UnravelIndexOp::new(Rc::new(self))
    }

    pub fn new(indices: Edge<Tidx>, dims: Edge<Tidx>) -> Self {
        Self {
            indices,
            dims,
            id_: new_id(),
        }
    }
}

impl<T, Tindices> TensorScatterUpdateOp<T, Tindices>
where T: con,
      Tindices: con_or_DT_INT32_or_DT_INT64,
{
    pub fn new(inner: Rc<TensorScatterUpdate<T, Tindices>>) -> Self {
        Self{inner}
    }

    pub fn output(&self) -> Edge<T> {
        Edge::<T>::new(self.inner.clone(), 0)
    }
}

struct TensorScatterUpdateOp<T, Tindices>
where T: con,
      Tindices: con_or_DT_INT32_or_DT_INT64,
{
    inner: Rc<TensorScatterUpdate<T, Tindices>>,
}

impl<T, Tindices> GraphOperation for TensorScatterUpdate<T, Tindices>
where T: con,
      Tindices: con_or_DT_INT32_or_DT_INT64,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("TensorScatterUpdate_{}")?
        };
        let mut new_op = graph.new_operation("TensorScatterUpdate", &op_name)?;
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct TensorScatterUpdate<T, Tindices>
where T: con,
      Tindices: con_or_DT_INT32_or_DT_INT64,
{
    tensor: Edge<T>,
    indices: Edge<Tindices>,
    updates: Edge<T>,
    id_: usize,
}

impl<T, Tindices> TensorScatterUpdate<T, Tindices>
where T: con,
      Tindices: con_or_DT_INT32_or_DT_INT64,
{
    pub fn finish(self) -> TensorScatterUpdateOp<T, Tindices> {
        TensorScatterUpdateOp::new(Rc::new(self))
    }

    pub fn new(tensor: Edge<T>, indices: Edge<Tindices>, updates: Edge<T>) -> Self {
        Self {
            tensor,
            indices,
            updates,
            id_: new_id(),
        }
    }
}

impl RpcOp {
    pub fn new(inner: Rc<Rpc>) -> Self {
        Self{inner}
    }

    pub fn response(&self) -> Edge<String> {
        Edge::<String>::new(self.inner.clone(), 0)
    }
}

struct RpcOp {
    inner: Rc<Rpc>,
}

impl GraphOperation for Rpc {
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("Rpc_{}")?
        };
        let mut new_op = graph.new_operation("Rpc", &op_name)?;
        {
            match self.protocol {
            }
            None => new_op.set_attr_value_proto("protocol", &vec![18_u8, 0_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_string("protocol", attr)})(&value),
        };
        {
            match self.fail_fast {
            }
            None => new_op.set_attr_value_proto("fail_fast", &vec![40_u8, 1_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_bool("fail_fast", *attr)})(&value),
        };
        {
            match self.timeout_in_ms {
            }
            None => new_op.set_attr_value_proto("timeout_in_ms", &vec![24_u8, 0_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_int("timeout_in_ms", *attr)})(&value),
        };
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct Rpc {
    address: Edge<String>,
    method: Edge<String>,
    request: Edge<String>,
    protocol: Option<String>,
    fail_fast: Option<bool>,
    timeout_in_ms: Option<i64>,
    id_: usize,
}

impl Rpc {
    pub fn protocol(&mut self, protocol: &str) -> &mut Self {
        self.protocol = Some(protocol.to_string());
        &self
    }

    pub fn fail_fast(&mut self, fail_fast: bool) -> &mut Self {
        self.fail_fast = Some(fail_fast);
        &self
    }

    pub fn timeout_in_ms(&mut self, timeout_in_ms: int) -> &mut Self {
        self.timeout_in_ms = Some(timeout_in_ms);
        &self
    }

    pub fn finish(self) -> RpcOp {
        RpcOp::new(Rc::new(self))
    }

    pub fn new(address: Edge<String>, method: Edge<String>, request: Edge<String>) -> Self {
        Self {
            address,
            method,
            request,
            protocol: None,
            fail_fast: None,
            timeout_in_ms: None,
            id_: new_id(),
        }
    }
}

impl<T> ScalarSummaryOp<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
{
    pub fn new(inner: Rc<ScalarSummary<T>>) -> Self {
        Self{inner}
    }

    pub fn summary(&self) -> Edge<String> {
        Edge::<String>::new(self.inner.clone(), 0)
    }
}

struct ScalarSummaryOp<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
{
    inner: Rc<ScalarSummary<T>>,
}

impl<T> GraphOperation for ScalarSummary<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("ScalarSummary_{}")?
        };
        let mut new_op = graph.new_operation("ScalarSummary", &op_name)?;
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct ScalarSummary<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
{
    tags: Edge<String>,
    values: Edge<T>,
    id_: usize,
}

impl<T> ScalarSummary<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
{
    pub fn finish(self) -> ScalarSummaryOp<T> {
        ScalarSummaryOp::new(Rc::new(self))
    }

    pub fn new(tags: Edge<String>, values: Edge<T>) -> Self {
        Self {
            tags,
            values,
            id_: new_id(),
        }
    }
}

impl<T> TanhGradOp<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_COMPLEX64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF,
{
    pub fn new(inner: Rc<TanhGrad<T>>) -> Self {
        Self{inner}
    }

    pub fn z(&self) -> Edge<T> {
        Edge::<T>::new(self.inner.clone(), 0)
    }
}

struct TanhGradOp<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_COMPLEX64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF,
{
    inner: Rc<TanhGrad<T>>,
}

impl<T> GraphOperation for TanhGrad<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_COMPLEX64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("TanhGrad_{}")?
        };
        let mut new_op = graph.new_operation("TanhGrad", &op_name)?;
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct TanhGrad<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_COMPLEX64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF,
{
    y: Edge<T>,
    dy: Edge<T>,
    id_: usize,
}

impl<T> TanhGrad<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_COMPLEX64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF,
{
    pub fn finish(self) -> TanhGradOp<T> {
        TanhGradOp::new(Rc::new(self))
    }

    pub fn new(y: Edge<T>, dy: Edge<T>) -> Self {
        Self {
            y,
            dy,
            id_: new_id(),
        }
    }
}

impl RetrieveTPUEmbeddingADAMParametersOp {
    pub fn new(inner: Rc<RetrieveTPUEmbeddingADAMParameters>) -> Self {
        Self{inner}
    }

    pub fn parameters(&self) -> Edge<f32> {
        Edge::<f32>::new(self.inner.clone(), 0)
    }

    pub fn momenta(&self) -> Edge<f32> {
        Edge::<f32>::new(self.inner.clone(), 1)
    }

    pub fn velocities(&self) -> Edge<f32> {
        Edge::<f32>::new(self.inner.clone(), 2)
    }
}

struct RetrieveTPUEmbeddingADAMParametersOp {
    inner: Rc<RetrieveTPUEmbeddingADAMParameters>,
}

impl GraphOperation for RetrieveTPUEmbeddingADAMParameters {
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("RetrieveTPUEmbeddingADAMParameters_{}")?
        };
        let mut new_op = graph.new_operation("RetrieveTPUEmbeddingADAMParameters", &op_name)?;
        {
            match self.table_id {
            }
            None => new_op.set_attr_value_proto("table_id", &vec![24_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 1_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_int("table_id", *attr)})(&value),
        };
        {
            match self.table_name {
            }
            None => new_op.set_attr_value_proto("table_name", &vec![18_u8, 0_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_string("table_name", attr)})(&value),
        };
        {
            (|attr| {new_op.set_attr_int("num_shards", *attr)})(&self.num_shards)
        }
        {
            (|attr| {new_op.set_attr_int("shard_id", *attr)})(&self.shard_id)
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct RetrieveTPUEmbeddingADAMParameters {
    table_id: Option<i64>,
    table_name: Option<String>,
    num_shards: i64,
    shard_id: i64,
    id_: usize,
}

impl RetrieveTPUEmbeddingADAMParameters {
    pub fn table_id(&mut self, table_id: int) -> &mut Self {
        self.table_id = Some(table_id);
        &self
    }

    pub fn table_name(&mut self, table_name: &str) -> &mut Self {
        self.table_name = Some(table_name.to_string());
        &self
    }

    pub fn finish(self) -> RetrieveTPUEmbeddingADAMParametersOp {
        RetrieveTPUEmbeddingADAMParametersOp::new(Rc::new(self))
    }

    pub fn new(num_shards: int, shard_id: int) -> Self {
        Self {
            table_id: None,
            table_name: None,
            num_shards: num_shards
            shard_id: shard_id
            id_: new_id(),
        }
    }
}

impl<T> ConcatOp<T>
where T: con,
{
    pub fn new(inner: Rc<Concat<T>>) -> Self {
        Self{inner}
    }

    pub fn output(&self) -> Edge<T> {
        Edge::<T>::new(self.inner.clone(), 0)
    }
}

struct ConcatOp<T>
where T: con,
{
    inner: Rc<Concat<T>>,
}

impl<T> GraphOperation for Concat<T>
where T: con,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("Concat_{}")?
        };
        let mut new_op = graph.new_operation("Concat", &op_name)?;
        {
            (|attr| {new_op.set_attr_int("N", *attr)})(&self.N)
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct Concat<T>
where T: con,
{
    concat_dim: Edge<i32>,
    values: Edge<T>,
    N: i64,
    id_: usize,
}

impl<T> Concat<T>
where T: con,
{
    pub fn finish(self) -> ConcatOp<T> {
        ConcatOp::new(Rc::new(self))
    }

    pub fn new(concat_dim: Edge<i32>, values: Edge<T>, N: int) -> Self {
        Self {
            concat_dim,
            values,
            N: N
            id_: new_id(),
        }
    }
}

impl _WaitForDistributedTPUOp {
    pub fn new(inner: Rc<_WaitForDistributedTPU>) -> Self {
        Self{inner}
    }

    pub fn topology(&self) -> Edge<String> {
        Edge::<String>::new(self.inner.clone(), 0)
    }
}

struct _WaitForDistributedTPUOp {
    inner: Rc<_WaitForDistributedTPU>,
}

impl GraphOperation for _WaitForDistributedTPU {
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("_WaitForDistributedTPU_{}")?
        };
        let mut new_op = graph.new_operation("_WaitForDistributedTPU", &op_name)?;
        {
            match self.startup_timeout_sec {
            }
            None => new_op.set_attr_value_proto("startup_timeout_sec", &vec![24_u8, 20_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_int("startup_timeout_sec", *attr)})(&value),
        };
        {
            (|attr| {new_op.set_attr_int("N", *attr)})(&self.N)
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct _WaitForDistributedTPU {
    inputs: Edge<i32>,
    startup_timeout_sec: Option<i64>,
    N: i64,
    id_: usize,
}

impl _WaitForDistributedTPU {
    pub fn startup_timeout_sec(&mut self, startup_timeout_sec: int) -> &mut Self {
        self.startup_timeout_sec = Some(startup_timeout_sec);
        &self
    }

    pub fn finish(self) -> _WaitForDistributedTPUOp {
        _WaitForDistributedTPUOp::new(Rc::new(self))
    }

    pub fn new(inputs: Edge<i32>, N: int) -> Self {
        Self {
            inputs,
            startup_timeout_sec: None,
            N: N
            id_: new_id(),
        }
    }
}

pub trait con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_STRING_or_DT_COMPLEX64_or_DT_INT64_or_DT_COMPLEX128_or_DT_HALF {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_STRING_or_DT_COMPLEX64_or_DT_INT64_or_DT_COMPLEX128_or_DT_HALF for OtherComplex<f32> {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_STRING_or_DT_COMPLEX64_or_DT_INT64_or_DT_COMPLEX128_or_DT_HALF for OtherComplex<f64> {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_STRING_or_DT_COMPLEX64_or_DT_INT64_or_DT_COMPLEX128_or_DT_HALF for String {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_STRING_or_DT_COMPLEX64_or_DT_INT64_or_DT_COMPLEX128_or_DT_HALF for f32 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_STRING_or_DT_COMPLEX64_or_DT_INT64_or_DT_COMPLEX128_or_DT_HALF for f64 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_STRING_or_DT_COMPLEX64_or_DT_INT64_or_DT_COMPLEX128_or_DT_HALF for i16 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_STRING_or_DT_COMPLEX64_or_DT_INT64_or_DT_COMPLEX128_or_DT_HALF for i32 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_STRING_or_DT_COMPLEX64_or_DT_INT64_or_DT_COMPLEX128_or_DT_HALF for i64 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_STRING_or_DT_COMPLEX64_or_DT_INT64_or_DT_COMPLEX128_or_DT_HALF for i8 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_STRING_or_DT_COMPLEX64_or_DT_INT64_or_DT_COMPLEX128_or_DT_HALF for u8 {
}

impl<T> _MklAddOp<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_STRING_or_DT_COMPLEX64_or_DT_INT64_or_DT_COMPLEX128_or_DT_HALF,
{
    pub fn new(inner: Rc<_MklAdd<T>>) -> Self {
        Self{inner}
    }

    pub fn z(&self) -> Edge<T> {
        Edge::<T>::new(self.inner.clone(), 0)
    }

    pub fn mkl_z(&self) -> Edge<u8> {
        Edge::<u8>::new(self.inner.clone(), 1)
    }
}

struct _MklAddOp<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_STRING_or_DT_COMPLEX64_or_DT_INT64_or_DT_COMPLEX128_or_DT_HALF,
{
    inner: Rc<_MklAdd<T>>,
}

impl<T> GraphOperation for _MklAdd<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_STRING_or_DT_COMPLEX64_or_DT_INT64_or_DT_COMPLEX128_or_DT_HALF,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("_MklAdd_{}")?
        };
        let mut new_op = graph.new_operation("_MklAdd", &op_name)?;
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct _MklAdd<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_STRING_or_DT_COMPLEX64_or_DT_INT64_or_DT_COMPLEX128_or_DT_HALF,
{
    x: Edge<T>,
    y: Edge<T>,
    mkl_x: Edge<u8>,
    mkl_y: Edge<u8>,
    id_: usize,
}

impl<T> _MklAdd<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_STRING_or_DT_COMPLEX64_or_DT_INT64_or_DT_COMPLEX128_or_DT_HALF,
{
    pub fn finish(self) -> _MklAddOp<T> {
        _MklAddOp::new(Rc::new(self))
    }

    pub fn new(x: Edge<T>, y: Edge<T>, mkl_x: Edge<u8>, mkl_y: Edge<u8>) -> Self {
        Self {
            x,
            y,
            mkl_x,
            mkl_y,
            id_: new_id(),
        }
    }
}

impl AllCandidateSamplerOp {
    pub fn new(inner: Rc<AllCandidateSampler>) -> Self {
        Self{inner}
    }

    pub fn sampled_candidates(&self) -> Edge<i64> {
        Edge::<i64>::new(self.inner.clone(), 0)
    }

    pub fn true_expected_count(&self) -> Edge<f32> {
        Edge::<f32>::new(self.inner.clone(), 1)
    }

    pub fn sampled_expected_count(&self) -> Edge<f32> {
        Edge::<f32>::new(self.inner.clone(), 2)
    }
}

struct AllCandidateSamplerOp {
    inner: Rc<AllCandidateSampler>,
}

impl GraphOperation for AllCandidateSampler {
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("AllCandidateSampler_{}")?
        };
        let mut new_op = graph.new_operation("AllCandidateSampler", &op_name)?;
        {
            (|attr| {new_op.set_attr_int("num_true", *attr)})(&self.num_true)
        }
        {
            (|attr| {new_op.set_attr_int("num_sampled", *attr)})(&self.num_sampled)
        }
        {
            (|attr| {new_op.set_attr_bool("unique", *attr)})(&self.unique)
        }
        {
            match self.seed {
            }
            None => new_op.set_attr_value_proto("seed", &vec![24_u8, 0_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_int("seed", *attr)})(&value),
        };
        {
            match self.seed2 {
            }
            None => new_op.set_attr_value_proto("seed2", &vec![24_u8, 0_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_int("seed2", *attr)})(&value),
        };
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct AllCandidateSampler {
    true_classes: Edge<i64>,
    num_true: i64,
    num_sampled: i64,
    unique: bool,
    seed: Option<i64>,
    seed2: Option<i64>,
    id_: usize,
}

impl AllCandidateSampler {
    pub fn seed(&mut self, seed: int) -> &mut Self {
        self.seed = Some(seed);
        &self
    }

    pub fn seed2(&mut self, seed2: int) -> &mut Self {
        self.seed2 = Some(seed2);
        &self
    }

    pub fn finish(self) -> AllCandidateSamplerOp {
        AllCandidateSamplerOp::new(Rc::new(self))
    }

    pub fn new(true_classes: Edge<i64>, num_true: int, num_sampled: int, unique: bool) -> Self {
        Self {
            true_classes,
            num_true: num_true
            num_sampled: num_sampled
            unique: unique
            seed: None,
            seed2: None,
            id_: new_id(),
        }
    }
}

impl DecodeAndCropJpegOp {
    pub fn new(inner: Rc<DecodeAndCropJpeg>) -> Self {
        Self{inner}
    }

    pub fn image(&self) -> Edge<u8> {
        Edge::<u8>::new(self.inner.clone(), 0)
    }
}

struct DecodeAndCropJpegOp {
    inner: Rc<DecodeAndCropJpeg>,
}

impl GraphOperation for DecodeAndCropJpeg {
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("DecodeAndCropJpeg_{}")?
        };
        let mut new_op = graph.new_operation("DecodeAndCropJpeg", &op_name)?;
        {
            match self.channels {
            }
            None => new_op.set_attr_value_proto("channels", &vec![24_u8, 0_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_int("channels", *attr)})(&value),
        };
        {
            match self.ratio {
            }
            None => new_op.set_attr_value_proto("ratio", &vec![24_u8, 1_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_int("ratio", *attr)})(&value),
        };
        {
            match self.fancy_upscaling {
            }
            None => new_op.set_attr_value_proto("fancy_upscaling", &vec![40_u8, 1_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_bool("fancy_upscaling", *attr)})(&value),
        };
        {
            match self.try_recover_truncated {
            }
            None => new_op.set_attr_value_proto("try_recover_truncated", &vec![40_u8, 0_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_bool("try_recover_truncated", *attr)})(&value),
        };
        {
            match self.acceptable_fraction {
            }
            None => new_op.set_attr_value_proto("acceptable_fraction", &vec![37_u8, 0_u8, 0_u8, 128_u8, 63_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_float("acceptable_fraction", *attr)})(&value),
        };
        {
            match self.dct_method {
            }
            None => new_op.set_attr_value_proto("dct_method", &vec![18_u8, 0_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_string("dct_method", attr)})(&value),
        };
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct DecodeAndCropJpeg {
    contents: Edge<String>,
    crop_window: Edge<i32>,
    channels: Option<i64>,
    ratio: Option<i64>,
    fancy_upscaling: Option<bool>,
    try_recover_truncated: Option<bool>,
    acceptable_fraction: Option<f32>,
    dct_method: Option<String>,
    id_: usize,
}

impl DecodeAndCropJpeg {
    pub fn channels(&mut self, channels: int) -> &mut Self {
        self.channels = Some(channels);
        &self
    }

    pub fn ratio(&mut self, ratio: int) -> &mut Self {
        self.ratio = Some(ratio);
        &self
    }

    pub fn fancy_upscaling(&mut self, fancy_upscaling: bool) -> &mut Self {
        self.fancy_upscaling = Some(fancy_upscaling);
        &self
    }

    pub fn try_recover_truncated(&mut self, try_recover_truncated: bool) -> &mut Self {
        self.try_recover_truncated = Some(try_recover_truncated);
        &self
    }

    pub fn acceptable_fraction(&mut self, acceptable_fraction: f32) -> &mut Self {
        self.acceptable_fraction = Some(acceptable_fraction);
        &self
    }

    pub fn dct_method(&mut self, dct_method: &str) -> &mut Self {
        self.dct_method = Some(dct_method.to_string());
        &self
    }

    pub fn finish(self) -> DecodeAndCropJpegOp {
        DecodeAndCropJpegOp::new(Rc::new(self))
    }

    pub fn new(contents: Edge<String>, crop_window: Edge<i32>) -> Self {
        Self {
            contents,
            crop_window,
            channels: None,
            ratio: None,
            fancy_upscaling: None,
            try_recover_truncated: None,
            acceptable_fraction: None,
            dct_method: None,
            id_: new_id(),
        }
    }
}

impl<tensor_type> _RecvOp<tensor_type>
where tensor_type: con,
{
    pub fn new(inner: Rc<_Recv<tensor_type>>) -> Self {
        Self{inner}
    }

    pub fn tensor(&self) -> Edge<tensor_type> {
        Edge::<tensor_type>::new(self.inner.clone(), 0)
    }
}

struct _RecvOp<tensor_type>
where tensor_type: con,
{
    inner: Rc<_Recv<tensor_type>>,
}

impl<tensor_type> GraphOperation for _Recv<tensor_type>
where tensor_type: con,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("_Recv_{}")?
        };
        let mut new_op = graph.new_operation("_Recv", &op_name)?;
        {
            (|attr| {new_op.set_attr_string("tensor_name", attr)})(&self.tensor_name)
        }
        {
            (|attr| {new_op.set_attr_string("send_device", attr)})(&self.send_device)
        }
        {
            (|attr| {new_op.set_attr_int("send_device_incarnation", *attr)})(&self.send_device_incarnation)
        }
        {
            (|attr| {new_op.set_attr_string("recv_device", attr)})(&self.recv_device)
        }
        {
            match self.client_terminated {
            }
            None => new_op.set_attr_value_proto("client_terminated", &vec![40_u8, 0_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_bool("client_terminated", *attr)})(&value),
        };
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct _Recv<tensor_type>
where tensor_type: con,
{
    tensor_name: String,
    send_device: String,
    send_device_incarnation: i64,
    recv_device: String,
    client_terminated: Option<bool>,
    id_: usize,
}

impl<tensor_type> _Recv<tensor_type>
where tensor_type: con,
{
    pub fn client_terminated(&mut self, client_terminated: bool) -> &mut Self {
        self.client_terminated = Some(client_terminated);
        &self
    }

    pub fn finish(self) -> _RecvOp<tensor_type> {
        _RecvOp::new(Rc::new(self))
    }

    pub fn new(tensor_name: &str, send_device: &str, send_device_incarnation: int, recv_device: &str) -> Self {
        Self {
            tensor_name: tensor_name.to_string()
            send_device: send_device.to_string()
            send_device_incarnation: send_device_incarnation
            recv_device: recv_device.to_string()
            client_terminated: None,
            id_: new_id(),
        }
    }
}

impl SdcaFprintOp {
    pub fn new(inner: Rc<SdcaFprint>) -> Self {
        Self{inner}
    }

    pub fn output(&self) -> Edge<i64> {
        Edge::<i64>::new(self.inner.clone(), 0)
    }
}

struct SdcaFprintOp {
    inner: Rc<SdcaFprint>,
}

impl GraphOperation for SdcaFprint {
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("SdcaFprint_{}")?
        };
        let mut new_op = graph.new_operation("SdcaFprint", &op_name)?;
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct SdcaFprint {
    input: Edge<String>,
    id_: usize,
}

impl SdcaFprint {
    pub fn finish(self) -> SdcaFprintOp {
        SdcaFprintOp::new(Rc::new(self))
    }

    pub fn new(input: Edge<String>) -> Self {
        Self {
            input,
            id_: new_id(),
        }
    }
}

impl ReaderReadUpToOp {
    pub fn new(inner: Rc<ReaderReadUpTo>) -> Self {
        Self{inner}
    }

    pub fn keys(&self) -> Edge<String> {
        Edge::<String>::new(self.inner.clone(), 0)
    }

    pub fn values(&self) -> Edge<String> {
        Edge::<String>::new(self.inner.clone(), 1)
    }
}

struct ReaderReadUpToOp {
    inner: Rc<ReaderReadUpTo>,
}

impl GraphOperation for ReaderReadUpTo {
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("ReaderReadUpTo_{}")?
        };
        let mut new_op = graph.new_operation("ReaderReadUpTo", &op_name)?;
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct ReaderReadUpTo {
    reader_handle: Edge<String>,
    queue_handle: Edge<String>,
    num_records: Edge<i64>,
    id_: usize,
}

impl ReaderReadUpTo {
    pub fn finish(self) -> ReaderReadUpToOp {
        ReaderReadUpToOp::new(Rc::new(self))
    }

    pub fn new(reader_handle: Edge<String>, queue_handle: Edge<String>, num_records: Edge<i64>) -> Self {
        Self {
            reader_handle,
            queue_handle,
            num_records,
            id_: new_id(),
        }
    }
}

impl<T, out_type> ShapeOp<T, out_type>
where T: con,
      out_type: con_or_DT_INT32_or_DT_INT64,
{
    pub fn new(inner: Rc<Shape<T, out_type>>) -> Self {
        Self{inner}
    }

    pub fn output(&self) -> Edge<out_type> {
        Edge::<out_type>::new(self.inner.clone(), 0)
    }
}

struct ShapeOp<T, out_type>
where T: con,
      out_type: con_or_DT_INT32_or_DT_INT64,
{
    inner: Rc<Shape<T, out_type>>,
}

impl<T, out_type> GraphOperation for Shape<T, out_type>
where T: con,
      out_type: con_or_DT_INT32_or_DT_INT64,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("Shape_{}")?
        };
        let mut new_op = graph.new_operation("Shape", &op_name)?;
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct Shape<T, out_type>
where T: con,
      out_type: con_or_DT_INT32_or_DT_INT64,
{
    input: Edge<T>,
    id_: usize,
}

impl<T, out_type> Shape<T, out_type>
where T: con,
      out_type: con_or_DT_INT32_or_DT_INT64,
{
    pub fn finish(self) -> ShapeOp<T, out_type> {
        ShapeOp::new(Rc::new(self))
    }

    pub fn new(input: Edge<T>) -> Self {
        Self {
            input,
            id_: new_id(),
        }
    }
}

impl<T> PowOp<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_COMPLEX64_or_DT_INT64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF,
{
    pub fn new(inner: Rc<Pow<T>>) -> Self {
        Self{inner}
    }

    pub fn z(&self) -> Edge<T> {
        Edge::<T>::new(self.inner.clone(), 0)
    }
}

struct PowOp<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_COMPLEX64_or_DT_INT64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF,
{
    inner: Rc<Pow<T>>,
}

impl<T> GraphOperation for Pow<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_COMPLEX64_or_DT_INT64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("Pow_{}")?
        };
        let mut new_op = graph.new_operation("Pow", &op_name)?;
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct Pow<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_COMPLEX64_or_DT_INT64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF,
{
    x: Edge<T>,
    y: Edge<T>,
    id_: usize,
}

impl<T> Pow<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_COMPLEX64_or_DT_INT64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF,
{
    pub fn finish(self) -> PowOp<T> {
        PowOp::new(Rc::new(self))
    }

    pub fn new(x: Edge<T>, y: Edge<T>) -> Self {
        Self {
            x,
            y,
            id_: new_id(),
        }
    }
}

impl<T> QuantizeV2Op<T>
where T: con_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_QINT16_or_DT_QUINT16,
{
    pub fn new(inner: Rc<QuantizeV2<T>>) -> Self {
        Self{inner}
    }

    pub fn output(&self) -> Edge<T> {
        Edge::<T>::new(self.inner.clone(), 0)
    }

    pub fn output_min(&self) -> Edge<f32> {
        Edge::<f32>::new(self.inner.clone(), 1)
    }

    pub fn output_max(&self) -> Edge<f32> {
        Edge::<f32>::new(self.inner.clone(), 2)
    }
}

struct QuantizeV2Op<T>
where T: con_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_QINT16_or_DT_QUINT16,
{
    inner: Rc<QuantizeV2<T>>,
}

impl<T> GraphOperation for QuantizeV2<T>
where T: con_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_QINT16_or_DT_QUINT16,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("QuantizeV2_{}")?
        };
        let mut new_op = graph.new_operation("QuantizeV2", &op_name)?;
        {
            match self.mode {
            }
            None => new_op.set_attr_value_proto("mode", &vec![18_u8, 12_u8, 77_u8, 73_u8, 78_u8, 95_u8, 67_u8, 79_u8, 77_u8, 66_u8, 73_u8, 78_u8, 69_u8, 68_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_string("mode", attr)})(&value),
        };
        {
            match self.round_mode {
            }
            None => new_op.set_attr_value_proto("round_mode", &vec![18_u8, 19_u8, 72_u8, 65_u8, 76_u8, 70_u8, 95_u8, 65_u8, 87_u8, 65_u8, 89_u8, 95_u8, 70_u8, 82_u8, 79_u8, 77_u8, 95_u8, 90_u8, 69_u8, 82_u8, 79_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_string("round_mode", attr)})(&value),
        };
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct QuantizeV2<T>
where T: con_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_QINT16_or_DT_QUINT16,
{
    input: Edge<f32>,
    min_range: Edge<f32>,
    max_range: Edge<f32>,
    mode: Option<String>,
    round_mode: Option<String>,
    id_: usize,
}

impl<T> QuantizeV2<T>
where T: con_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_QINT16_or_DT_QUINT16,
{
    pub fn mode(&mut self, mode: &str) -> &mut Self {
        self.mode = Some(mode.to_string());
        &self
    }

    pub fn round_mode(&mut self, round_mode: &str) -> &mut Self {
        self.round_mode = Some(round_mode.to_string());
        &self
    }

    pub fn finish(self) -> QuantizeV2Op<T> {
        QuantizeV2Op::new(Rc::new(self))
    }

    pub fn new(input: Edge<f32>, min_range: Edge<f32>, max_range: Edge<f32>) -> Self {
        Self {
            input,
            min_range,
            max_range,
            mode: None,
            round_mode: None,
            id_: new_id(),
        }
    }
}

impl<T> SplitOp<T>
where T: con,
{
    pub fn new(inner: Rc<Split<T>>) -> Self {
        Self{inner}
    }

    pub fn output(&self) -> Edge<T> {
        Edge::<T>::new(self.inner.clone(), 0)
    }
}

struct SplitOp<T>
where T: con,
{
    inner: Rc<Split<T>>,
}

impl<T> GraphOperation for Split<T>
where T: con,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("Split_{}")?
        };
        let mut new_op = graph.new_operation("Split", &op_name)?;
        {
            (|attr| {new_op.set_attr_int("num_split", *attr)})(&self.num_split)
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct Split<T>
where T: con,
{
    split_dim: Edge<i32>,
    value: Edge<T>,
    num_split: i64,
    id_: usize,
}

impl<T> Split<T>
where T: con,
{
    pub fn finish(self) -> SplitOp<T> {
        SplitOp::new(Rc::new(self))
    }

    pub fn new(split_dim: Edge<i32>, value: Edge<T>, num_split: int) -> Self {
        Self {
            split_dim,
            value,
            num_split: num_split
            id_: new_id(),
        }
    }
}

impl<T, Tout> ComplexOp<T, Tout>
where T: con_or_DT_FLOAT_or_DT_DOUBLE,
      Tout: con_or_DT_COMPLEX64_or_DT_COMPLEX128,
{
    pub fn new(inner: Rc<Complex<T, Tout>>) -> Self {
        Self{inner}
    }

    pub fn out(&self) -> Edge<Tout> {
        Edge::<Tout>::new(self.inner.clone(), 0)
    }
}

struct ComplexOp<T, Tout>
where T: con_or_DT_FLOAT_or_DT_DOUBLE,
      Tout: con_or_DT_COMPLEX64_or_DT_COMPLEX128,
{
    inner: Rc<Complex<T, Tout>>,
}

impl<T, Tout> GraphOperation for Complex<T, Tout>
where T: con_or_DT_FLOAT_or_DT_DOUBLE,
      Tout: con_or_DT_COMPLEX64_or_DT_COMPLEX128,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("Complex_{}")?
        };
        let mut new_op = graph.new_operation("Complex", &op_name)?;
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct Complex<T, Tout>
where T: con_or_DT_FLOAT_or_DT_DOUBLE,
      Tout: con_or_DT_COMPLEX64_or_DT_COMPLEX128,
{
    real: Edge<T>,
    imag: Edge<T>,
    id_: usize,
}

impl<T, Tout> Complex<T, Tout>
where T: con_or_DT_FLOAT_or_DT_DOUBLE,
      Tout: con_or_DT_COMPLEX64_or_DT_COMPLEX128,
{
    pub fn finish(self) -> ComplexOp<T, Tout> {
        ComplexOp::new(Rc::new(self))
    }

    pub fn new(real: Edge<T>, imag: Edge<T>) -> Self {
        Self {
            real,
            imag,
            id_: new_id(),
        }
    }
}

impl<T, Tout> ImagOp<T, Tout>
where T: con_or_DT_COMPLEX64_or_DT_COMPLEX128,
      Tout: con_or_DT_FLOAT_or_DT_DOUBLE,
{
    pub fn new(inner: Rc<Imag<T, Tout>>) -> Self {
        Self{inner}
    }

    pub fn output(&self) -> Edge<Tout> {
        Edge::<Tout>::new(self.inner.clone(), 0)
    }
}

struct ImagOp<T, Tout>
where T: con_or_DT_COMPLEX64_or_DT_COMPLEX128,
      Tout: con_or_DT_FLOAT_or_DT_DOUBLE,
{
    inner: Rc<Imag<T, Tout>>,
}

impl<T, Tout> GraphOperation for Imag<T, Tout>
where T: con_or_DT_COMPLEX64_or_DT_COMPLEX128,
      Tout: con_or_DT_FLOAT_or_DT_DOUBLE,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("Imag_{}")?
        };
        let mut new_op = graph.new_operation("Imag", &op_name)?;
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct Imag<T, Tout>
where T: con_or_DT_COMPLEX64_or_DT_COMPLEX128,
      Tout: con_or_DT_FLOAT_or_DT_DOUBLE,
{
    input: Edge<T>,
    id_: usize,
}

impl<T, Tout> Imag<T, Tout>
where T: con_or_DT_COMPLEX64_or_DT_COMPLEX128,
      Tout: con_or_DT_FLOAT_or_DT_DOUBLE,
{
    pub fn finish(self) -> ImagOp<T, Tout> {
        ImagOp::new(Rc::new(self))
    }

    pub fn new(input: Edge<T>) -> Self {
        Self {
            input,
            id_: new_id(),
        }
    }
}

impl<T, Tidx, Tnumsegments> SparseSegmentSumWithNumSegmentsOp<T, Tidx, Tnumsegments>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      Tidx: con_or_DT_INT32_or_DT_INT64,
      Tnumsegments: con_or_DT_INT32_or_DT_INT64,
{
    pub fn new(inner: Rc<SparseSegmentSumWithNumSegments<T, Tidx, Tnumsegments>>) -> Self {
        Self{inner}
    }

    pub fn output(&self) -> Edge<T> {
        Edge::<T>::new(self.inner.clone(), 0)
    }
}

struct SparseSegmentSumWithNumSegmentsOp<T, Tidx, Tnumsegments>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      Tidx: con_or_DT_INT32_or_DT_INT64,
      Tnumsegments: con_or_DT_INT32_or_DT_INT64,
{
    inner: Rc<SparseSegmentSumWithNumSegments<T, Tidx, Tnumsegments>>,
}

impl<T, Tidx, Tnumsegments> GraphOperation for SparseSegmentSumWithNumSegments<T, Tidx, Tnumsegments>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      Tidx: con_or_DT_INT32_or_DT_INT64,
      Tnumsegments: con_or_DT_INT32_or_DT_INT64,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("SparseSegmentSumWithNumSegments_{}")?
        };
        let mut new_op = graph.new_operation("SparseSegmentSumWithNumSegments", &op_name)?;
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct SparseSegmentSumWithNumSegments<T, Tidx, Tnumsegments>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      Tidx: con_or_DT_INT32_or_DT_INT64,
      Tnumsegments: con_or_DT_INT32_or_DT_INT64,
{
    data: Edge<T>,
    indices: Edge<Tidx>,
    segment_ids: Edge<i32>,
    num_segments: Edge<Tnumsegments>,
    id_: usize,
}

impl<T, Tidx, Tnumsegments> SparseSegmentSumWithNumSegments<T, Tidx, Tnumsegments>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      Tidx: con_or_DT_INT32_or_DT_INT64,
      Tnumsegments: con_or_DT_INT32_or_DT_INT64,
{
    pub fn finish(self) -> SparseSegmentSumWithNumSegmentsOp<T, Tidx, Tnumsegments> {
        SparseSegmentSumWithNumSegmentsOp::new(Rc::new(self))
    }

    pub fn new(data: Edge<T>, indices: Edge<Tidx>, segment_ids: Edge<i32>, num_segments: Edge<Tnumsegments>) -> Self {
        Self {
            data,
            indices,
            segment_ids,
            num_segments,
            id_: new_id(),
        }
    }
}

impl<T> MergeOp<T>
where T: con,
{
    pub fn new(inner: Rc<Merge<T>>) -> Self {
        Self{inner}
    }

    pub fn output(&self) -> Edge<T> {
        Edge::<T>::new(self.inner.clone(), 0)
    }

    pub fn value_index(&self) -> Edge<i32> {
        Edge::<i32>::new(self.inner.clone(), 1)
    }
}

struct MergeOp<T>
where T: con,
{
    inner: Rc<Merge<T>>,
}

impl<T> GraphOperation for Merge<T>
where T: con,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("Merge_{}")?
        };
        let mut new_op = graph.new_operation("Merge", &op_name)?;
        {
            (|attr| {new_op.set_attr_int("N", *attr)})(&self.N)
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct Merge<T>
where T: con,
{
    inputs: Edge<T>,
    N: i64,
    id_: usize,
}

impl<T> Merge<T>
where T: con,
{
    pub fn finish(self) -> MergeOp<T> {
        MergeOp::new(Rc::new(self))
    }

    pub fn new(inputs: Edge<T>, N: int) -> Self {
        Self {
            inputs,
            N: N
            id_: new_id(),
        }
    }
}

impl<index_type, T> FillOp<index_type, T>
where T: con,
      index_type: con_or_DT_INT32_or_DT_INT64,
{
    pub fn new(inner: Rc<Fill<index_type, T>>) -> Self {
        Self{inner}
    }

    pub fn output(&self) -> Edge<T> {
        Edge::<T>::new(self.inner.clone(), 0)
    }
}

struct FillOp<index_type, T>
where T: con,
      index_type: con_or_DT_INT32_or_DT_INT64,
{
    inner: Rc<Fill<index_type, T>>,
}

impl<index_type, T> GraphOperation for Fill<index_type, T>
where T: con,
      index_type: con_or_DT_INT32_or_DT_INT64,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("Fill_{}")?
        };
        let mut new_op = graph.new_operation("Fill", &op_name)?;
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct Fill<index_type, T>
where T: con,
      index_type: con_or_DT_INT32_or_DT_INT64,
{
    dims: Edge<index_type>,
    value: Edge<T>,
    id_: usize,
}

impl<index_type, T> Fill<index_type, T>
where T: con,
      index_type: con_or_DT_INT32_or_DT_INT64,
{
    pub fn finish(self) -> FillOp<index_type, T> {
        FillOp::new(Rc::new(self))
    }

    pub fn new(dims: Edge<index_type>, value: Edge<T>) -> Self {
        Self {
            dims,
            value,
            id_: new_id(),
        }
    }
}

impl<T, Tindices> TensorScatterSubOp<T, Tindices>
where T: con,
      Tindices: con_or_DT_INT32_or_DT_INT64,
{
    pub fn new(inner: Rc<TensorScatterSub<T, Tindices>>) -> Self {
        Self{inner}
    }

    pub fn output(&self) -> Edge<T> {
        Edge::<T>::new(self.inner.clone(), 0)
    }
}

struct TensorScatterSubOp<T, Tindices>
where T: con,
      Tindices: con_or_DT_INT32_or_DT_INT64,
{
    inner: Rc<TensorScatterSub<T, Tindices>>,
}

impl<T, Tindices> GraphOperation for TensorScatterSub<T, Tindices>
where T: con,
      Tindices: con_or_DT_INT32_or_DT_INT64,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("TensorScatterSub_{}")?
        };
        let mut new_op = graph.new_operation("TensorScatterSub", &op_name)?;
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct TensorScatterSub<T, Tindices>
where T: con,
      Tindices: con_or_DT_INT32_or_DT_INT64,
{
    tensor: Edge<T>,
    indices: Edge<Tindices>,
    updates: Edge<T>,
    id_: usize,
}

impl<T, Tindices> TensorScatterSub<T, Tindices>
where T: con,
      Tindices: con_or_DT_INT32_or_DT_INT64,
{
    pub fn finish(self) -> TensorScatterSubOp<T, Tindices> {
        TensorScatterSubOp::new(Rc::new(self))
    }

    pub fn new(tensor: Edge<T>, indices: Edge<Tindices>, updates: Edge<T>) -> Self {
        Self {
            tensor,
            indices,
            updates,
            id_: new_id(),
        }
    }
}

impl<T> MatrixDiagOp<T>
where T: con,
{
    pub fn new(inner: Rc<MatrixDiag<T>>) -> Self {
        Self{inner}
    }

    pub fn output(&self) -> Edge<T> {
        Edge::<T>::new(self.inner.clone(), 0)
    }
}

struct MatrixDiagOp<T>
where T: con,
{
    inner: Rc<MatrixDiag<T>>,
}

impl<T> GraphOperation for MatrixDiag<T>
where T: con,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("MatrixDiag_{}")?
        };
        let mut new_op = graph.new_operation("MatrixDiag", &op_name)?;
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct MatrixDiag<T>
where T: con,
{
    diagonal: Edge<T>,
    id_: usize,
}

impl<T> MatrixDiag<T>
where T: con,
{
    pub fn finish(self) -> MatrixDiagOp<T> {
        MatrixDiagOp::new(Rc::new(self))
    }

    pub fn new(diagonal: Edge<T>) -> Self {
        Self {
            diagonal,
            id_: new_id(),
        }
    }
}

impl<T> FloorDivOp<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF,
{
    pub fn new(inner: Rc<FloorDiv<T>>) -> Self {
        Self{inner}
    }

    pub fn z(&self) -> Edge<T> {
        Edge::<T>::new(self.inner.clone(), 0)
    }
}

struct FloorDivOp<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF,
{
    inner: Rc<FloorDiv<T>>,
}

impl<T> GraphOperation for FloorDiv<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("FloorDiv_{}")?
        };
        let mut new_op = graph.new_operation("FloorDiv", &op_name)?;
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct FloorDiv<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF,
{
    x: Edge<T>,
    y: Edge<T>,
    id_: usize,
}

impl<T> FloorDiv<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF,
{
    pub fn finish(self) -> FloorDivOp<T> {
        FloorDivOp::new(Rc::new(self))
    }

    pub fn new(x: Edge<T>, y: Edge<T>) -> Self {
        Self {
            x,
            y,
            id_: new_id(),
        }
    }
}

impl<T> XlaReduceOp<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
{
    pub fn new(inner: Rc<XlaReduce<T>>) -> Self {
        Self{inner}
    }

    pub fn output(&self) -> Edge<T> {
        Edge::<T>::new(self.inner.clone(), 0)
    }
}

struct XlaReduceOp<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
{
    inner: Rc<XlaReduce<T>>,
}

impl<T> GraphOperation for XlaReduce<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("XlaReduce_{}")?
        };
        let mut new_op = graph.new_operation("XlaReduce", &op_name)?;
        {
            (|attrs| {new_op.set_attr_int_list("dimensions_to_reduce", attrs)})(&self.dimensions_to_reduce)
        }
        {
            (|attr| {new_op.set_attr_func_name("reducer", attr)})(&self.reducer)
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct XlaReduce<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
{
    input: Edge<T>,
    init_value: Edge<T>,
    dimensions_to_reduce: Vec<i64>,
    reducer: String,
    id_: usize,
}

impl<T> XlaReduce<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
{
    pub fn finish(self) -> XlaReduceOp<T> {
        XlaReduceOp::new(Rc::new(self))
    }

    pub fn new(input: Edge<T>, init_value: Edge<T>, dimensions_to_reduce: &[int], reducer: &str) -> Self {
        Self {
            input,
            init_value,
            dimensions_to_reduce: dimensions_to_reduce.to_vec()
            reducer: reducer.to_string()
            id_: new_id(),
        }
    }
}

impl<Tparams, Tindices> GatherOp<Tparams, Tindices>
where Tparams: con,
      Tindices: con_or_DT_INT32_or_DT_INT64,
{
    pub fn new(inner: Rc<Gather<Tparams, Tindices>>) -> Self {
        Self{inner}
    }

    pub fn output(&self) -> Edge<Tparams> {
        Edge::<Tparams>::new(self.inner.clone(), 0)
    }
}

struct GatherOp<Tparams, Tindices>
where Tparams: con,
      Tindices: con_or_DT_INT32_or_DT_INT64,
{
    inner: Rc<Gather<Tparams, Tindices>>,
}

impl<Tparams, Tindices> GraphOperation for Gather<Tparams, Tindices>
where Tparams: con,
      Tindices: con_or_DT_INT32_or_DT_INT64,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("Gather_{}")?
        };
        let mut new_op = graph.new_operation("Gather", &op_name)?;
        {
            match self.validate_indices {
            }
            None => new_op.set_attr_value_proto("validate_indices", &vec![40_u8, 1_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_bool("validate_indices", *attr)})(&value),
        };
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct Gather<Tparams, Tindices>
where Tparams: con,
      Tindices: con_or_DT_INT32_or_DT_INT64,
{
    params: Edge<Tparams>,
    indices: Edge<Tindices>,
    validate_indices: Option<bool>,
    id_: usize,
}

impl<Tparams, Tindices> Gather<Tparams, Tindices>
where Tparams: con,
      Tindices: con_or_DT_INT32_or_DT_INT64,
{
    pub fn validate_indices(&mut self, validate_indices: bool) -> &mut Self {
        self.validate_indices = Some(validate_indices);
        &self
    }

    pub fn finish(self) -> GatherOp<Tparams, Tindices> {
        GatherOp::new(Rc::new(self))
    }

    pub fn new(params: Edge<Tparams>, indices: Edge<Tindices>) -> Self {
        Self {
            params,
            indices,
            validate_indices: None,
            id_: new_id(),
        }
    }
}

impl<Tparams, Tindices, Taxis> GatherV2Op<Tparams, Tindices, Taxis>
where Tparams: con,
      Tindices: con_or_DT_INT32_or_DT_INT64,
      Taxis: con_or_DT_INT32_or_DT_INT64,
{
    pub fn new(inner: Rc<GatherV2<Tparams, Tindices, Taxis>>) -> Self {
        Self{inner}
    }

    pub fn output(&self) -> Edge<Tparams> {
        Edge::<Tparams>::new(self.inner.clone(), 0)
    }
}

struct GatherV2Op<Tparams, Tindices, Taxis>
where Tparams: con,
      Tindices: con_or_DT_INT32_or_DT_INT64,
      Taxis: con_or_DT_INT32_or_DT_INT64,
{
    inner: Rc<GatherV2<Tparams, Tindices, Taxis>>,
}

impl<Tparams, Tindices, Taxis> GraphOperation for GatherV2<Tparams, Tindices, Taxis>
where Tparams: con,
      Tindices: con_or_DT_INT32_or_DT_INT64,
      Taxis: con_or_DT_INT32_or_DT_INT64,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("GatherV2_{}")?
        };
        let mut new_op = graph.new_operation("GatherV2", &op_name)?;
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct GatherV2<Tparams, Tindices, Taxis>
where Tparams: con,
      Tindices: con_or_DT_INT32_or_DT_INT64,
      Taxis: con_or_DT_INT32_or_DT_INT64,
{
    params: Edge<Tparams>,
    indices: Edge<Tindices>,
    axis: Edge<Taxis>,
    id_: usize,
}

impl<Tparams, Tindices, Taxis> GatherV2<Tparams, Tindices, Taxis>
where Tparams: con,
      Tindices: con_or_DT_INT32_or_DT_INT64,
      Taxis: con_or_DT_INT32_or_DT_INT64,
{
    pub fn finish(self) -> GatherV2Op<Tparams, Tindices, Taxis> {
        GatherV2Op::new(Rc::new(self))
    }

    pub fn new(params: Edge<Tparams>, indices: Edge<Tindices>, axis: Edge<Taxis>) -> Self {
        Self {
            params,
            indices,
            axis,
            id_: new_id(),
        }
    }
}

impl UnicodeEncodeOp {
    pub fn new(inner: Rc<UnicodeEncode>) -> Self {
        Self{inner}
    }

    pub fn output(&self) -> Edge<String> {
        Edge::<String>::new(self.inner.clone(), 0)
    }
}

struct UnicodeEncodeOp {
    inner: Rc<UnicodeEncode>,
}

impl GraphOperation for UnicodeEncode {
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("UnicodeEncode_{}")?
        };
        let mut new_op = graph.new_operation("UnicodeEncode", &op_name)?;
        {
            match self.errors {
            }
            None => new_op.set_attr_value_proto("errors", &vec![18_u8, 7_u8, 114_u8, 101_u8, 112_u8, 108_u8, 97_u8, 99_u8, 101_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_string("errors", attr)})(&value),
        };
        {
            (|attr| {new_op.set_attr_string("output_encoding", attr)})(&self.output_encoding)
        }
        {
            match self.replacement_char {
            }
            None => new_op.set_attr_value_proto("replacement_char", &vec![24_u8, 253_u8, 255_u8, 3_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_int("replacement_char", *attr)})(&value),
        };
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct UnicodeEncode {
    input_values: Edge<i32>,
    input_splits: Edge<i64>,
    errors: Option<String>,
    output_encoding: String,
    replacement_char: Option<i64>,
    id_: usize,
}

impl UnicodeEncode {
    pub fn errors(&mut self, errors: &str) -> &mut Self {
        self.errors = Some(errors.to_string());
        &self
    }

    pub fn replacement_char(&mut self, replacement_char: int) -> &mut Self {
        self.replacement_char = Some(replacement_char);
        &self
    }

    pub fn finish(self) -> UnicodeEncodeOp {
        UnicodeEncodeOp::new(Rc::new(self))
    }

    pub fn new(input_values: Edge<i32>, input_splits: Edge<i64>, output_encoding: &str) -> Self {
        Self {
            input_values,
            input_splits,
            errors: None,
            output_encoding: output_encoding.to_string()
            replacement_char: None,
            id_: new_id(),
        }
    }
}

impl<T> ErfcOp<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
{
    pub fn new(inner: Rc<Erfc<T>>) -> Self {
        Self{inner}
    }

    pub fn y(&self) -> Edge<T> {
        Edge::<T>::new(self.inner.clone(), 0)
    }
}

struct ErfcOp<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
{
    inner: Rc<Erfc<T>>,
}

impl<T> GraphOperation for Erfc<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("Erfc_{}")?
        };
        let mut new_op = graph.new_operation("Erfc", &op_name)?;
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct Erfc<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
{
    x: Edge<T>,
    id_: usize,
}

impl<T> Erfc<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
{
    pub fn finish(self) -> ErfcOp<T> {
        ErfcOp::new(Rc::new(self))
    }

    pub fn new(x: Edge<T>) -> Self {
        Self {
            x,
            id_: new_id(),
        }
    }
}

impl<T> DiagPartOp<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_COMPLEX64_or_DT_INT64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF,
{
    pub fn new(inner: Rc<DiagPart<T>>) -> Self {
        Self{inner}
    }

    pub fn diagonal(&self) -> Edge<T> {
        Edge::<T>::new(self.inner.clone(), 0)
    }
}

struct DiagPartOp<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_COMPLEX64_or_DT_INT64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF,
{
    inner: Rc<DiagPart<T>>,
}

impl<T> GraphOperation for DiagPart<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_COMPLEX64_or_DT_INT64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("DiagPart_{}")?
        };
        let mut new_op = graph.new_operation("DiagPart", &op_name)?;
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct DiagPart<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_COMPLEX64_or_DT_INT64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF,
{
    input: Edge<T>,
    id_: usize,
}

impl<T> DiagPart<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_COMPLEX64_or_DT_INT64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF,
{
    pub fn finish(self) -> DiagPartOp<T> {
        DiagPartOp::new(Rc::new(self))
    }

    pub fn new(input: Edge<T>) -> Self {
        Self {
            input,
            id_: new_id(),
        }
    }
}

impl<T> QuantizedInstanceNormOp<T>
where T: con_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_QINT16_or_DT_QUINT16,
{
    pub fn new(inner: Rc<QuantizedInstanceNorm<T>>) -> Self {
        Self{inner}
    }

    pub fn y(&self) -> Edge<T> {
        Edge::<T>::new(self.inner.clone(), 0)
    }

    pub fn y_min(&self) -> Edge<f32> {
        Edge::<f32>::new(self.inner.clone(), 1)
    }

    pub fn y_max(&self) -> Edge<f32> {
        Edge::<f32>::new(self.inner.clone(), 2)
    }
}

struct QuantizedInstanceNormOp<T>
where T: con_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_QINT16_or_DT_QUINT16,
{
    inner: Rc<QuantizedInstanceNorm<T>>,
}

impl<T> GraphOperation for QuantizedInstanceNorm<T>
where T: con_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_QINT16_or_DT_QUINT16,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("QuantizedInstanceNorm_{}")?
        };
        let mut new_op = graph.new_operation("QuantizedInstanceNorm", &op_name)?;
        {
            match self.output_range_given {
            }
            None => new_op.set_attr_value_proto("output_range_given", &vec![40_u8, 0_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_bool("output_range_given", *attr)})(&value),
        };
        {
            match self.given_y_min {
            }
            None => new_op.set_attr_value_proto("given_y_min", &vec![37_u8, 0_u8, 0_u8, 0_u8, 0_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_float("given_y_min", *attr)})(&value),
        };
        {
            match self.given_y_max {
            }
            None => new_op.set_attr_value_proto("given_y_max", &vec![37_u8, 0_u8, 0_u8, 0_u8, 0_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_float("given_y_max", *attr)})(&value),
        };
        {
            match self.variance_epsilon {
            }
            None => new_op.set_attr_value_proto("variance_epsilon", &vec![37_u8, 172_u8, 197_u8, 39_u8, 55_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_float("variance_epsilon", *attr)})(&value),
        };
        {
            match self.min_separation {
            }
            None => new_op.set_attr_value_proto("min_separation", &vec![37_u8, 111_u8, 18_u8, 131_u8, 58_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_float("min_separation", *attr)})(&value),
        };
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct QuantizedInstanceNorm<T>
where T: con_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_QINT16_or_DT_QUINT16,
{
    x: Edge<T>,
    x_min: Edge<f32>,
    x_max: Edge<f32>,
    output_range_given: Option<bool>,
    given_y_min: Option<f32>,
    given_y_max: Option<f32>,
    variance_epsilon: Option<f32>,
    min_separation: Option<f32>,
    id_: usize,
}

impl<T> QuantizedInstanceNorm<T>
where T: con_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_QINT16_or_DT_QUINT16,
{
    pub fn output_range_given(&mut self, output_range_given: bool) -> &mut Self {
        self.output_range_given = Some(output_range_given);
        &self
    }

    pub fn given_y_min(&mut self, given_y_min: f32) -> &mut Self {
        self.given_y_min = Some(given_y_min);
        &self
    }

    pub fn given_y_max(&mut self, given_y_max: f32) -> &mut Self {
        self.given_y_max = Some(given_y_max);
        &self
    }

    pub fn variance_epsilon(&mut self, variance_epsilon: f32) -> &mut Self {
        self.variance_epsilon = Some(variance_epsilon);
        &self
    }

    pub fn min_separation(&mut self, min_separation: f32) -> &mut Self {
        self.min_separation = Some(min_separation);
        &self
    }

    pub fn finish(self) -> QuantizedInstanceNormOp<T> {
        QuantizedInstanceNormOp::new(Rc::new(self))
    }

    pub fn new(x: Edge<T>, x_min: Edge<f32>, x_max: Edge<f32>) -> Self {
        Self {
            x,
            x_min,
            x_max,
            output_range_given: None,
            given_y_min: None,
            given_y_max: None,
            variance_epsilon: None,
            min_separation: None,
            id_: new_id(),
        }
    }
}

impl<T> RefIdentityOp<T>
where T: con,
{
    pub fn new(inner: Rc<RefIdentity<T>>) -> Self {
        Self{inner}
    }

    pub fn output(&self) -> Edge<T> {
        Edge::<T>::new(self.inner.clone(), 0)
    }
}

struct RefIdentityOp<T>
where T: con,
{
    inner: Rc<RefIdentity<T>>,
}

impl<T> GraphOperation for RefIdentity<T>
where T: con,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("RefIdentity_{}")?
        };
        let mut new_op = graph.new_operation("RefIdentity", &op_name)?;
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct RefIdentity<T>
where T: con,
{
    input: Edge<T>,
    id_: usize,
}

impl<T> RefIdentity<T>
where T: con,
{
    pub fn finish(self) -> RefIdentityOp<T> {
        RefIdentityOp::new(Rc::new(self))
    }

    pub fn new(input: Edge<T>) -> Self {
        Self {
            input,
            id_: new_id(),
        }
    }
}

impl<T> StopGradientOp<T>
where T: con,
{
    pub fn new(inner: Rc<StopGradient<T>>) -> Self {
        Self{inner}
    }

    pub fn output(&self) -> Edge<T> {
        Edge::<T>::new(self.inner.clone(), 0)
    }
}

struct StopGradientOp<T>
where T: con,
{
    inner: Rc<StopGradient<T>>,
}

impl<T> GraphOperation for StopGradient<T>
where T: con,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("StopGradient_{}")?
        };
        let mut new_op = graph.new_operation("StopGradient", &op_name)?;
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct StopGradient<T>
where T: con,
{
    input: Edge<T>,
    id_: usize,
}

impl<T> StopGradient<T>
where T: con,
{
    pub fn finish(self) -> StopGradientOp<T> {
        StopGradientOp::new(Rc::new(self))
    }

    pub fn new(input: Edge<T>) -> Self {
        Self {
            input,
            id_: new_id(),
        }
    }
}

impl<T> AsinOp<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_COMPLEX64_or_DT_INT64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF,
{
    pub fn new(inner: Rc<Asin<T>>) -> Self {
        Self{inner}
    }

    pub fn y(&self) -> Edge<T> {
        Edge::<T>::new(self.inner.clone(), 0)
    }
}

struct AsinOp<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_COMPLEX64_or_DT_INT64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF,
{
    inner: Rc<Asin<T>>,
}

impl<T> GraphOperation for Asin<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_COMPLEX64_or_DT_INT64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("Asin_{}")?
        };
        let mut new_op = graph.new_operation("Asin", &op_name)?;
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct Asin<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_COMPLEX64_or_DT_INT64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF,
{
    x: Edge<T>,
    id_: usize,
}

impl<T> Asin<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_COMPLEX64_or_DT_INT64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF,
{
    pub fn finish(self) -> AsinOp<T> {
        AsinOp::new(Rc::new(self))
    }

    pub fn new(x: Edge<T>) -> Self {
        Self {
            x,
            id_: new_id(),
        }
    }
}

impl<T> PreventGradientOp<T>
where T: con,
{
    pub fn new(inner: Rc<PreventGradient<T>>) -> Self {
        Self{inner}
    }

    pub fn output(&self) -> Edge<T> {
        Edge::<T>::new(self.inner.clone(), 0)
    }
}

struct PreventGradientOp<T>
where T: con,
{
    inner: Rc<PreventGradient<T>>,
}

impl<T> GraphOperation for PreventGradient<T>
where T: con,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("PreventGradient_{}")?
        };
        let mut new_op = graph.new_operation("PreventGradient", &op_name)?;
        {
            match self.message {
            }
            None => new_op.set_attr_value_proto("message", &vec![18_u8, 0_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_string("message", attr)})(&value),
        };
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct PreventGradient<T>
where T: con,
{
    input: Edge<T>,
    message: Option<String>,
    id_: usize,
}

impl<T> PreventGradient<T>
where T: con,
{
    pub fn message(&mut self, message: &str) -> &mut Self {
        self.message = Some(message.to_string());
        &self
    }

    pub fn finish(self) -> PreventGradientOp<T> {
        PreventGradientOp::new(Rc::new(self))
    }

    pub fn new(input: Edge<T>) -> Self {
        Self {
            input,
            message: None,
            id_: new_id(),
        }
    }
}

impl<T, Tidx> ConcatV2Op<T, Tidx>
where T: con,
      Tidx: con_or_DT_INT32_or_DT_INT64,
{
    pub fn new(inner: Rc<ConcatV2<T, Tidx>>) -> Self {
        Self{inner}
    }

    pub fn output(&self) -> Edge<T> {
        Edge::<T>::new(self.inner.clone(), 0)
    }
}

struct ConcatV2Op<T, Tidx>
where T: con,
      Tidx: con_or_DT_INT32_or_DT_INT64,
{
    inner: Rc<ConcatV2<T, Tidx>>,
}

impl<T, Tidx> GraphOperation for ConcatV2<T, Tidx>
where T: con,
      Tidx: con_or_DT_INT32_or_DT_INT64,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("ConcatV2_{}")?
        };
        let mut new_op = graph.new_operation("ConcatV2", &op_name)?;
        {
            (|attr| {new_op.set_attr_int("N", *attr)})(&self.N)
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct ConcatV2<T, Tidx>
where T: con,
      Tidx: con_or_DT_INT32_or_DT_INT64,
{
    values: Edge<T>,
    axis: Edge<Tidx>,
    N: i64,
    id_: usize,
}

impl<T, Tidx> ConcatV2<T, Tidx>
where T: con,
      Tidx: con_or_DT_INT32_or_DT_INT64,
{
    pub fn finish(self) -> ConcatV2Op<T, Tidx> {
        ConcatV2Op::new(Rc::new(self))
    }

    pub fn new(values: Edge<T>, axis: Edge<Tidx>, N: int) -> Self {
        Self {
            values,
            axis,
            N: N
            id_: new_id(),
        }
    }
}

impl ReadFileOp {
    pub fn new(inner: Rc<ReadFile>) -> Self {
        Self{inner}
    }

    pub fn contents(&self) -> Edge<String> {
        Edge::<String>::new(self.inner.clone(), 0)
    }
}

struct ReadFileOp {
    inner: Rc<ReadFile>,
}

impl GraphOperation for ReadFile {
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("ReadFile_{}")?
        };
        let mut new_op = graph.new_operation("ReadFile", &op_name)?;
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct ReadFile {
    filename: Edge<String>,
    id_: usize,
}

impl ReadFile {
    pub fn finish(self) -> ReadFileOp {
        ReadFileOp::new(Rc::new(self))
    }

    pub fn new(filename: Edge<String>) -> Self {
        Self {
            filename,
            id_: new_id(),
        }
    }
}

impl<dtype> PlaceholderWithDefaultOp<dtype>
where dtype: con,
{
    pub fn new(inner: Rc<PlaceholderWithDefault<dtype>>) -> Self {
        Self{inner}
    }

    pub fn output(&self) -> Edge<dtype> {
        Edge::<dtype>::new(self.inner.clone(), 0)
    }
}

struct PlaceholderWithDefaultOp<dtype>
where dtype: con,
{
    inner: Rc<PlaceholderWithDefault<dtype>>,
}

impl<dtype> GraphOperation for PlaceholderWithDefault<dtype>
where dtype: con,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("PlaceholderWithDefault_{}")?
        };
        let mut new_op = graph.new_operation("PlaceholderWithDefault", &op_name)?;
        {
            (|attr| {new_op.set_attr_shape("shape", attr)})(&self.shape)
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct PlaceholderWithDefault<dtype>
where dtype: con,
{
    input: Edge<dtype>,
    shape: Shape,
    id_: usize,
}

impl<dtype> PlaceholderWithDefault<dtype>
where dtype: con,
{
    pub fn finish(self) -> PlaceholderWithDefaultOp<dtype> {
        PlaceholderWithDefaultOp::new(Rc::new(self))
    }

    pub fn new(input: Edge<dtype>, shape: &Shape) -> Self {
        Self {
            input,
            shape: shape.clone()
            id_: new_id(),
        }
    }
}

impl<T1, T2, Toutput, Tactivation> QuantizedMatMulOp<T1, T2, Toutput, Tactivation>
where T1: con_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_QINT16_or_DT_QUINT16,
      T2: con_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_QINT16_or_DT_QUINT16,
      Toutput: con_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_QINT16_or_DT_QUINT16,
      Tactivation: con_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_QINT16_or_DT_QUINT16,
{
    pub fn new(inner: Rc<QuantizedMatMul<T1, T2, Toutput, Tactivation>>) -> Self {
        Self{inner}
    }

    pub fn out(&self) -> Edge<Toutput> {
        Edge::<Toutput>::new(self.inner.clone(), 0)
    }

    pub fn min_out(&self) -> Edge<f32> {
        Edge::<f32>::new(self.inner.clone(), 1)
    }

    pub fn max_out(&self) -> Edge<f32> {
        Edge::<f32>::new(self.inner.clone(), 2)
    }
}

struct QuantizedMatMulOp<T1, T2, Toutput, Tactivation>
where T1: con_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_QINT16_or_DT_QUINT16,
      T2: con_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_QINT16_or_DT_QUINT16,
      Toutput: con_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_QINT16_or_DT_QUINT16,
      Tactivation: con_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_QINT16_or_DT_QUINT16,
{
    inner: Rc<QuantizedMatMul<T1, T2, Toutput, Tactivation>>,
}

impl<T1, T2, Toutput, Tactivation> GraphOperation for QuantizedMatMul<T1, T2, Toutput, Tactivation>
where T1: con_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_QINT16_or_DT_QUINT16,
      T2: con_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_QINT16_or_DT_QUINT16,
      Toutput: con_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_QINT16_or_DT_QUINT16,
      Tactivation: con_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_QINT16_or_DT_QUINT16,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("QuantizedMatMul_{}")?
        };
        let mut new_op = graph.new_operation("QuantizedMatMul", &op_name)?;
        {
            match self.transpose_a {
            }
            None => new_op.set_attr_value_proto("transpose_a", &vec![40_u8, 0_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_bool("transpose_a", *attr)})(&value),
        };
        {
            match self.transpose_b {
            }
            None => new_op.set_attr_value_proto("transpose_b", &vec![40_u8, 0_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_bool("transpose_b", *attr)})(&value),
        };
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct QuantizedMatMul<T1, T2, Toutput, Tactivation>
where T1: con_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_QINT16_or_DT_QUINT16,
      T2: con_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_QINT16_or_DT_QUINT16,
      Toutput: con_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_QINT16_or_DT_QUINT16,
      Tactivation: con_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_QINT16_or_DT_QUINT16,
{
    a: Edge<T1>,
    b: Edge<T2>,
    min_a: Edge<f32>,
    max_a: Edge<f32>,
    min_b: Edge<f32>,
    max_b: Edge<f32>,
    transpose_a: Option<bool>,
    transpose_b: Option<bool>,
    id_: usize,
}

impl<T1, T2, Toutput, Tactivation> QuantizedMatMul<T1, T2, Toutput, Tactivation>
where T1: con_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_QINT16_or_DT_QUINT16,
      T2: con_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_QINT16_or_DT_QUINT16,
      Toutput: con_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_QINT16_or_DT_QUINT16,
      Tactivation: con_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_QINT16_or_DT_QUINT16,
{
    pub fn transpose_a(&mut self, transpose_a: bool) -> &mut Self {
        self.transpose_a = Some(transpose_a);
        &self
    }

    pub fn transpose_b(&mut self, transpose_b: bool) -> &mut Self {
        self.transpose_b = Some(transpose_b);
        &self
    }

    pub fn finish(self) -> QuantizedMatMulOp<T1, T2, Toutput, Tactivation> {
        QuantizedMatMulOp::new(Rc::new(self))
    }

    pub fn new(a: Edge<T1>, b: Edge<T2>, min_a: Edge<f32>, max_a: Edge<f32>, min_b: Edge<f32>, max_b: Edge<f32>) -> Self {
        Self {
            a,
            b,
            min_a,
            max_a,
            min_b,
            max_b,
            transpose_a: None,
            transpose_b: None,
            id_: new_id(),
        }
    }
}

impl<T> BatchMatrixSetDiagOp<T>
where T: con,
{
    pub fn new(inner: Rc<BatchMatrixSetDiag<T>>) -> Self {
        Self{inner}
    }

    pub fn output(&self) -> Edge<T> {
        Edge::<T>::new(self.inner.clone(), 0)
    }
}

struct BatchMatrixSetDiagOp<T>
where T: con,
{
    inner: Rc<BatchMatrixSetDiag<T>>,
}

impl<T> GraphOperation for BatchMatrixSetDiag<T>
where T: con,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("BatchMatrixSetDiag_{}")?
        };
        let mut new_op = graph.new_operation("BatchMatrixSetDiag", &op_name)?;
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct BatchMatrixSetDiag<T>
where T: con,
{
    input: Edge<T>,
    diagonal: Edge<T>,
    id_: usize,
}

impl<T> BatchMatrixSetDiag<T>
where T: con,
{
    pub fn finish(self) -> BatchMatrixSetDiagOp<T> {
        BatchMatrixSetDiagOp::new(Rc::new(self))
    }

    pub fn new(input: Edge<T>, diagonal: Edge<T>) -> Self {
        Self {
            input,
            diagonal,
            id_: new_id(),
        }
    }
}

impl<dtype> XlaRecvOp<dtype>
where dtype: con,
{
    pub fn new(inner: Rc<XlaRecv<dtype>>) -> Self {
        Self{inner}
    }

    pub fn tensor(&self) -> Edge<dtype> {
        Edge::<dtype>::new(self.inner.clone(), 0)
    }
}

struct XlaRecvOp<dtype>
where dtype: con,
{
    inner: Rc<XlaRecv<dtype>>,
}

impl<dtype> GraphOperation for XlaRecv<dtype>
where dtype: con,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("XlaRecv_{}")?
        };
        let mut new_op = graph.new_operation("XlaRecv", &op_name)?;
        {
            (|attr| {new_op.set_attr_string("tensor_name", attr)})(&self.tensor_name)
        }
        {
            (|attr| {new_op.set_attr_shape("shape", attr)})(&self.shape)
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct XlaRecv<dtype>
where dtype: con,
{
    tensor_name: String,
    shape: Shape,
    id_: usize,
}

impl<dtype> XlaRecv<dtype>
where dtype: con,
{
    pub fn finish(self) -> XlaRecvOp<dtype> {
        XlaRecvOp::new(Rc::new(self))
    }

    pub fn new(tensor_name: &str, shape: &Shape) -> Self {
        Self {
            tensor_name: tensor_name.to_string()
            shape: shape.clone()
            id_: new_id(),
        }
    }
}

impl<T> ExtractImagePatchesOp<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
{
    pub fn new(inner: Rc<ExtractImagePatches<T>>) -> Self {
        Self{inner}
    }

    pub fn patches(&self) -> Edge<T> {
        Edge::<T>::new(self.inner.clone(), 0)
    }
}

struct ExtractImagePatchesOp<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
{
    inner: Rc<ExtractImagePatches<T>>,
}

impl<T> GraphOperation for ExtractImagePatches<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("ExtractImagePatches_{}")?
        };
        let mut new_op = graph.new_operation("ExtractImagePatches", &op_name)?;
        {
            (|attrs| {new_op.set_attr_int_list("ksizes", attrs)})(&self.ksizes)
        }
        {
            (|attrs| {new_op.set_attr_int_list("strides", attrs)})(&self.strides)
        }
        {
            (|attrs| {new_op.set_attr_int_list("rates", attrs)})(&self.rates)
        }
        {
            (|attr| {new_op.set_attr_string("padding", attr)})(&self.padding)
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct ExtractImagePatches<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
{
    images: Edge<T>,
    ksizes: Vec<i64>,
    strides: Vec<i64>,
    rates: Vec<i64>,
    padding: String,
    id_: usize,
}

impl<T> ExtractImagePatches<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
{
    pub fn finish(self) -> ExtractImagePatchesOp<T> {
        ExtractImagePatchesOp::new(Rc::new(self))
    }

    pub fn new(images: Edge<T>, ksizes: &[int], strides: &[int], rates: &[int], padding: &str) -> Self {
        Self {
            images,
            ksizes: ksizes.to_vec()
            strides: strides.to_vec()
            rates: rates.to_vec()
            padding: padding.to_string()
            id_: new_id(),
        }
    }
}

impl<T> CudnnRNNParamsToCanonicalOp<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_HALF,
{
    pub fn new(inner: Rc<CudnnRNNParamsToCanonical<T>>) -> Self {
        Self{inner}
    }

    pub fn weights(&self) -> Edge<T> {
        Edge::<T>::new(self.inner.clone(), 0)
    }

    pub fn biases(&self) -> Edge<T> {
        Edge::<T>::new(self.inner.clone(), 1)
    }
}

struct CudnnRNNParamsToCanonicalOp<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_HALF,
{
    inner: Rc<CudnnRNNParamsToCanonical<T>>,
}

impl<T> GraphOperation for CudnnRNNParamsToCanonical<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_HALF,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("CudnnRNNParamsToCanonical_{}")?
        };
        let mut new_op = graph.new_operation("CudnnRNNParamsToCanonical", &op_name)?;
        {
            (|attr| {new_op.set_attr_int("num_params", *attr)})(&self.num_params)
        }
        {
            match self.rnn_mode {
            }
            None => new_op.set_attr_value_proto("rnn_mode", &vec![18_u8, 4_u8, 108_u8, 115_u8, 116_u8, 109_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_string("rnn_mode", attr)})(&value),
        };
        {
            match self.input_mode {
            }
            None => new_op.set_attr_value_proto("input_mode", &vec![18_u8, 12_u8, 108_u8, 105_u8, 110_u8, 101_u8, 97_u8, 114_u8, 95_u8, 105_u8, 110_u8, 112_u8, 117_u8, 116_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_string("input_mode", attr)})(&value),
        };
        {
            match self.direction {
            }
            None => new_op.set_attr_value_proto("direction", &vec![18_u8, 14_u8, 117_u8, 110_u8, 105_u8, 100_u8, 105_u8, 114_u8, 101_u8, 99_u8, 116_u8, 105_u8, 111_u8, 110_u8, 97_u8, 108_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_string("direction", attr)})(&value),
        };
        {
            match self.dropout {
            }
            None => new_op.set_attr_value_proto("dropout", &vec![37_u8, 0_u8, 0_u8, 0_u8, 0_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_float("dropout", *attr)})(&value),
        };
        {
            match self.seed {
            }
            None => new_op.set_attr_value_proto("seed", &vec![24_u8, 0_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_int("seed", *attr)})(&value),
        };
        {
            match self.seed2 {
            }
            None => new_op.set_attr_value_proto("seed2", &vec![24_u8, 0_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_int("seed2", *attr)})(&value),
        };
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct CudnnRNNParamsToCanonical<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_HALF,
{
    num_layers: Edge<i32>,
    num_units: Edge<i32>,
    input_size: Edge<i32>,
    params: Edge<T>,
    num_params: i64,
    rnn_mode: Option<String>,
    input_mode: Option<String>,
    direction: Option<String>,
    dropout: Option<f32>,
    seed: Option<i64>,
    seed2: Option<i64>,
    id_: usize,
}

impl<T> CudnnRNNParamsToCanonical<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_HALF,
{
    pub fn rnn_mode(&mut self, rnn_mode: &str) -> &mut Self {
        self.rnn_mode = Some(rnn_mode.to_string());
        &self
    }

    pub fn input_mode(&mut self, input_mode: &str) -> &mut Self {
        self.input_mode = Some(input_mode.to_string());
        &self
    }

    pub fn direction(&mut self, direction: &str) -> &mut Self {
        self.direction = Some(direction.to_string());
        &self
    }

    pub fn dropout(&mut self, dropout: f32) -> &mut Self {
        self.dropout = Some(dropout);
        &self
    }

    pub fn seed(&mut self, seed: int) -> &mut Self {
        self.seed = Some(seed);
        &self
    }

    pub fn seed2(&mut self, seed2: int) -> &mut Self {
        self.seed2 = Some(seed2);
        &self
    }

    pub fn finish(self) -> CudnnRNNParamsToCanonicalOp<T> {
        CudnnRNNParamsToCanonicalOp::new(Rc::new(self))
    }

    pub fn new(num_layers: Edge<i32>, num_units: Edge<i32>, input_size: Edge<i32>, params: Edge<T>, num_params: int) -> Self {
        Self {
            num_layers,
            num_units,
            input_size,
            params,
            num_params: num_params
            rnn_mode: None,
            input_mode: None,
            direction: None,
            dropout: None,
            seed: None,
            seed2: None,
            id_: new_id(),
        }
    }
}

impl<T, out_type> ShapeNOp<T, out_type>
where T: con,
      out_type: con_or_DT_INT32_or_DT_INT64,
{
    pub fn new(inner: Rc<ShapeN<T, out_type>>) -> Self {
        Self{inner}
    }

    pub fn output(&self) -> Edge<out_type> {
        Edge::<out_type>::new(self.inner.clone(), 0)
    }
}

struct ShapeNOp<T, out_type>
where T: con,
      out_type: con_or_DT_INT32_or_DT_INT64,
{
    inner: Rc<ShapeN<T, out_type>>,
}

impl<T, out_type> GraphOperation for ShapeN<T, out_type>
where T: con,
      out_type: con_or_DT_INT32_or_DT_INT64,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("ShapeN_{}")?
        };
        let mut new_op = graph.new_operation("ShapeN", &op_name)?;
        {
            (|attr| {new_op.set_attr_int("N", *attr)})(&self.N)
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct ShapeN<T, out_type>
where T: con,
      out_type: con_or_DT_INT32_or_DT_INT64,
{
    input: Edge<T>,
    N: i64,
    id_: usize,
}

impl<T, out_type> ShapeN<T, out_type>
where T: con,
      out_type: con_or_DT_INT32_or_DT_INT64,
{
    pub fn finish(self) -> ShapeNOp<T, out_type> {
        ShapeNOp::new(Rc::new(self))
    }

    pub fn new(input: Edge<T>, N: int) -> Self {
        Self {
            input,
            N: N
            id_: new_id(),
        }
    }
}

impl<T> RankOp<T>
where T: con,
{
    pub fn new(inner: Rc<Rank<T>>) -> Self {
        Self{inner}
    }

    pub fn output(&self) -> Edge<i32> {
        Edge::<i32>::new(self.inner.clone(), 0)
    }
}

struct RankOp<T>
where T: con,
{
    inner: Rc<Rank<T>>,
}

impl<T> GraphOperation for Rank<T>
where T: con,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("Rank_{}")?
        };
        let mut new_op = graph.new_operation("Rank", &op_name)?;
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct Rank<T>
where T: con,
{
    input: Edge<T>,
    id_: usize,
}

impl<T> Rank<T>
where T: con,
{
    pub fn finish(self) -> RankOp<T> {
        RankOp::new(Rc::new(self))
    }

    pub fn new(input: Edge<T>) -> Self {
        Self {
            input,
            id_: new_id(),
        }
    }
}

impl<T, out_type> SizeOp<T, out_type>
where T: con,
      out_type: con_or_DT_INT32_or_DT_INT64,
{
    pub fn new(inner: Rc<Size<T, out_type>>) -> Self {
        Self{inner}
    }

    pub fn output(&self) -> Edge<out_type> {
        Edge::<out_type>::new(self.inner.clone(), 0)
    }
}

struct SizeOp<T, out_type>
where T: con,
      out_type: con_or_DT_INT32_or_DT_INT64,
{
    inner: Rc<Size<T, out_type>>,
}

impl<T, out_type> GraphOperation for Size<T, out_type>
where T: con,
      out_type: con_or_DT_INT32_or_DT_INT64,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("Size_{}")?
        };
        let mut new_op = graph.new_operation("Size", &op_name)?;
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct Size<T, out_type>
where T: con,
      out_type: con_or_DT_INT32_or_DT_INT64,
{
    input: Edge<T>,
    id_: usize,
}

impl<T, out_type> Size<T, out_type>
where T: con,
      out_type: con_or_DT_INT32_or_DT_INT64,
{
    pub fn finish(self) -> SizeOp<T, out_type> {
        SizeOp::new(Rc::new(self))
    }

    pub fn new(input: Edge<T>) -> Self {
        Self {
            input,
            id_: new_id(),
        }
    }
}

impl _DisconnectHostFromDistributedTPUSystemOp {
    pub fn new(inner: Rc<_DisconnectHostFromDistributedTPUSystem>) -> Self {
        Self{inner}
    }

    pub fn number_of_tpu_chips(&self) -> Edge<i32> {
        Edge::<i32>::new(self.inner.clone(), 0)
    }
}

struct _DisconnectHostFromDistributedTPUSystemOp {
    inner: Rc<_DisconnectHostFromDistributedTPUSystem>,
}

impl GraphOperation for _DisconnectHostFromDistributedTPUSystem {
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("_DisconnectHostFromDistributedTPUSystem_{}")?
        };
        let mut new_op = graph.new_operation("_DisconnectHostFromDistributedTPUSystem", &op_name)?;
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct _DisconnectHostFromDistributedTPUSystem {
    id_: usize,
}

impl _DisconnectHostFromDistributedTPUSystem {
    pub fn finish(self) -> _DisconnectHostFromDistributedTPUSystemOp {
        _DisconnectHostFromDistributedTPUSystemOp::new(Rc::new(self))
    }

    pub fn new() -> Self {
        Self {
            id_: new_id(),
        }
    }
}

impl<T, Index> SliceOp<T, Index>
where T: con,
      Index: con_or_DT_INT32_or_DT_INT64,
{
    pub fn new(inner: Rc<Slice<T, Index>>) -> Self {
        Self{inner}
    }

    pub fn output(&self) -> Edge<T> {
        Edge::<T>::new(self.inner.clone(), 0)
    }
}

struct SliceOp<T, Index>
where T: con,
      Index: con_or_DT_INT32_or_DT_INT64,
{
    inner: Rc<Slice<T, Index>>,
}

impl<T, Index> GraphOperation for Slice<T, Index>
where T: con,
      Index: con_or_DT_INT32_or_DT_INT64,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("Slice_{}")?
        };
        let mut new_op = graph.new_operation("Slice", &op_name)?;
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct Slice<T, Index>
where T: con,
      Index: con_or_DT_INT32_or_DT_INT64,
{
    input: Edge<T>,
    begin: Edge<Index>,
    size: Edge<Index>,
    id_: usize,
}

impl<T, Index> Slice<T, Index>
where T: con,
      Index: con_or_DT_INT32_or_DT_INT64,
{
    pub fn finish(self) -> SliceOp<T, Index> {
        SliceOp::new(Rc::new(self))
    }

    pub fn new(input: Edge<T>, begin: Edge<Index>, size: Edge<Index>) -> Self {
        Self {
            input,
            begin,
            size,
            id_: new_id(),
        }
    }
}

impl<T> UnbatchOp<T>
where T: con,
{
    pub fn new(inner: Rc<Unbatch<T>>) -> Self {
        Self{inner}
    }

    pub fn unbatched_tensor(&self) -> Edge<T> {
        Edge::<T>::new(self.inner.clone(), 0)
    }
}

struct UnbatchOp<T>
where T: con,
{
    inner: Rc<Unbatch<T>>,
}

impl<T> GraphOperation for Unbatch<T>
where T: con,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("Unbatch_{}")?
        };
        let mut new_op = graph.new_operation("Unbatch", &op_name)?;
        {
            (|attr| {new_op.set_attr_int("timeout_micros", *attr)})(&self.timeout_micros)
        }
        {
            match self.container {
            }
            None => new_op.set_attr_value_proto("container", &vec![18_u8, 0_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_string("container", attr)})(&value),
        };
        {
            match self.shared_name {
            }
            None => new_op.set_attr_value_proto("shared_name", &vec![18_u8, 0_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_string("shared_name", attr)})(&value),
        };
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct Unbatch<T>
where T: con,
{
    batched_tensor: Edge<T>,
    batch_index: Edge<i64>,
    id: Edge<i64>,
    timeout_micros: i64,
    container: Option<String>,
    shared_name: Option<String>,
    id_: usize,
}

impl<T> Unbatch<T>
where T: con,
{
    pub fn container(&mut self, container: &str) -> &mut Self {
        self.container = Some(container.to_string());
        &self
    }

    pub fn shared_name(&mut self, shared_name: &str) -> &mut Self {
        self.shared_name = Some(shared_name.to_string());
        &self
    }

    pub fn finish(self) -> UnbatchOp<T> {
        UnbatchOp::new(Rc::new(self))
    }

    pub fn new(batched_tensor: Edge<T>, batch_index: Edge<i64>, id: Edge<i64>, timeout_micros: int) -> Self {
        Self {
            batched_tensor,
            batch_index,
            id,
            timeout_micros: timeout_micros
            container: None,
            shared_name: None,
            id_: new_id(),
        }
    }
}

impl<T, Tlen> SplitVOp<T, Tlen>
where T: con,
      Tlen: con_or_DT_INT32_or_DT_INT64,
{
    pub fn new(inner: Rc<SplitV<T, Tlen>>) -> Self {
        Self{inner}
    }

    pub fn output(&self) -> Edge<T> {
        Edge::<T>::new(self.inner.clone(), 0)
    }
}

struct SplitVOp<T, Tlen>
where T: con,
      Tlen: con_or_DT_INT32_or_DT_INT64,
{
    inner: Rc<SplitV<T, Tlen>>,
}

impl<T, Tlen> GraphOperation for SplitV<T, Tlen>
where T: con,
      Tlen: con_or_DT_INT32_or_DT_INT64,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("SplitV_{}")?
        };
        let mut new_op = graph.new_operation("SplitV", &op_name)?;
        {
            (|attr| {new_op.set_attr_int("num_split", *attr)})(&self.num_split)
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct SplitV<T, Tlen>
where T: con,
      Tlen: con_or_DT_INT32_or_DT_INT64,
{
    value: Edge<T>,
    size_splits: Edge<Tlen>,
    split_dim: Edge<i32>,
    num_split: i64,
    id_: usize,
}

impl<T, Tlen> SplitV<T, Tlen>
where T: con,
      Tlen: con_or_DT_INT32_or_DT_INT64,
{
    pub fn finish(self) -> SplitVOp<T, Tlen> {
        SplitVOp::new(Rc::new(self))
    }

    pub fn new(value: Edge<T>, size_splits: Edge<Tlen>, split_dim: Edge<i32>, num_split: int) -> Self {
        Self {
            value,
            size_splits,
            split_dim,
            num_split: num_split
            id_: new_id(),
        }
    }
}

impl<T, Index> StridedSliceAssignOp<T, Index>
where T: con,
      Index: con_or_DT_INT32_or_DT_INT64,
{
    pub fn new(inner: Rc<StridedSliceAssign<T, Index>>) -> Self {
        Self{inner}
    }

    pub fn output_ref(&self) -> Edge<T> {
        Edge::<T>::new(self.inner.clone(), 0)
    }
}

struct StridedSliceAssignOp<T, Index>
where T: con,
      Index: con_or_DT_INT32_or_DT_INT64,
{
    inner: Rc<StridedSliceAssign<T, Index>>,
}

impl<T, Index> GraphOperation for StridedSliceAssign<T, Index>
where T: con,
      Index: con_or_DT_INT32_or_DT_INT64,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("StridedSliceAssign_{}")?
        };
        let mut new_op = graph.new_operation("StridedSliceAssign", &op_name)?;
        {
            match self.begin_mask {
            }
            None => new_op.set_attr_value_proto("begin_mask", &vec![24_u8, 0_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_int("begin_mask", *attr)})(&value),
        };
        {
            match self.end_mask {
            }
            None => new_op.set_attr_value_proto("end_mask", &vec![24_u8, 0_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_int("end_mask", *attr)})(&value),
        };
        {
            match self.ellipsis_mask {
            }
            None => new_op.set_attr_value_proto("ellipsis_mask", &vec![24_u8, 0_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_int("ellipsis_mask", *attr)})(&value),
        };
        {
            match self.new_axis_mask {
            }
            None => new_op.set_attr_value_proto("new_axis_mask", &vec![24_u8, 0_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_int("new_axis_mask", *attr)})(&value),
        };
        {
            match self.shrink_axis_mask {
            }
            None => new_op.set_attr_value_proto("shrink_axis_mask", &vec![24_u8, 0_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_int("shrink_axis_mask", *attr)})(&value),
        };
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct StridedSliceAssign<T, Index>
where T: con,
      Index: con_or_DT_INT32_or_DT_INT64,
{
    ref_: Edge<T>,
    begin: Edge<Index>,
    end: Edge<Index>,
    strides: Edge<Index>,
    value: Edge<T>,
    begin_mask: Option<i64>,
    end_mask: Option<i64>,
    ellipsis_mask: Option<i64>,
    new_axis_mask: Option<i64>,
    shrink_axis_mask: Option<i64>,
    id_: usize,
}

impl<T, Index> StridedSliceAssign<T, Index>
where T: con,
      Index: con_or_DT_INT32_or_DT_INT64,
{
    pub fn begin_mask(&mut self, begin_mask: int) -> &mut Self {
        self.begin_mask = Some(begin_mask);
        &self
    }

    pub fn end_mask(&mut self, end_mask: int) -> &mut Self {
        self.end_mask = Some(end_mask);
        &self
    }

    pub fn ellipsis_mask(&mut self, ellipsis_mask: int) -> &mut Self {
        self.ellipsis_mask = Some(ellipsis_mask);
        &self
    }

    pub fn new_axis_mask(&mut self, new_axis_mask: int) -> &mut Self {
        self.new_axis_mask = Some(new_axis_mask);
        &self
    }

    pub fn shrink_axis_mask(&mut self, shrink_axis_mask: int) -> &mut Self {
        self.shrink_axis_mask = Some(shrink_axis_mask);
        &self
    }

    pub fn finish(self) -> StridedSliceAssignOp<T, Index> {
        StridedSliceAssignOp::new(Rc::new(self))
    }

    pub fn new(ref_: Edge<T>, begin: Edge<Index>, end: Edge<Index>, strides: Edge<Index>, value: Edge<T>) -> Self {
        Self {
            ref_,
            begin,
            end,
            strides,
            value,
            begin_mask: None,
            end_mask: None,
            ellipsis_mask: None,
            new_axis_mask: None,
            shrink_axis_mask: None,
            id_: new_id(),
        }
    }
}

impl<T> TensorArrayWriteOp<T>
where T: con,
{
    pub fn new(inner: Rc<TensorArrayWrite<T>>) -> Self {
        Self{inner}
    }

    pub fn flow_out(&self) -> Edge<f32> {
        Edge::<f32>::new(self.inner.clone(), 0)
    }
}

struct TensorArrayWriteOp<T>
where T: con,
{
    inner: Rc<TensorArrayWrite<T>>,
}

impl<T> GraphOperation for TensorArrayWrite<T>
where T: con,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("TensorArrayWrite_{}")?
        };
        let mut new_op = graph.new_operation("TensorArrayWrite", &op_name)?;
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct TensorArrayWrite<T>
where T: con,
{
    handle: Edge<String>,
    index: Edge<i32>,
    value: Edge<T>,
    flow_in: Edge<f32>,
    id_: usize,
}

impl<T> TensorArrayWrite<T>
where T: con,
{
    pub fn finish(self) -> TensorArrayWriteOp<T> {
        TensorArrayWriteOp::new(Rc::new(self))
    }

    pub fn new(handle: Edge<String>, index: Edge<i32>, value: Edge<T>, flow_in: Edge<f32>) -> Self {
        Self {
            handle,
            index,
            value,
            flow_in,
            id_: new_id(),
        }
    }
}

impl<T> TileGradOp<T>
where T: con,
{
    pub fn new(inner: Rc<TileGrad<T>>) -> Self {
        Self{inner}
    }

    pub fn output(&self) -> Edge<T> {
        Edge::<T>::new(self.inner.clone(), 0)
    }
}

struct TileGradOp<T>
where T: con,
{
    inner: Rc<TileGrad<T>>,
}

impl<T> GraphOperation for TileGrad<T>
where T: con,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("TileGrad_{}")?
        };
        let mut new_op = graph.new_operation("TileGrad", &op_name)?;
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct TileGrad<T>
where T: con,
{
    input: Edge<T>,
    multiples: Edge<i32>,
    id_: usize,
}

impl<T> TileGrad<T>
where T: con,
{
    pub fn finish(self) -> TileGradOp<T> {
        TileGradOp::new(Rc::new(self))
    }

    pub fn new(input: Edge<T>, multiples: Edge<i32>) -> Self {
        Self {
            input,
            multiples,
            id_: new_id(),
        }
    }
}

impl StringJoinOp {
    pub fn new(inner: Rc<StringJoin>) -> Self {
        Self{inner}
    }

    pub fn output(&self) -> Edge<String> {
        Edge::<String>::new(self.inner.clone(), 0)
    }
}

struct StringJoinOp {
    inner: Rc<StringJoin>,
}

impl GraphOperation for StringJoin {
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("StringJoin_{}")?
        };
        let mut new_op = graph.new_operation("StringJoin", &op_name)?;
        {
            (|attr| {new_op.set_attr_int("N", *attr)})(&self.N)
        }
        {
            match self.separator {
            }
            None => new_op.set_attr_value_proto("separator", &vec![18_u8, 0_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_string("separator", attr)})(&value),
        };
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct StringJoin {
    inputs: Edge<String>,
    N: i64,
    separator: Option<String>,
    id_: usize,
}

impl StringJoin {
    pub fn separator(&mut self, separator: &str) -> &mut Self {
        self.separator = Some(separator.to_string());
        &self
    }

    pub fn finish(self) -> StringJoinOp {
        StringJoinOp::new(Rc::new(self))
    }

    pub fn new(inputs: Edge<String>, N: int) -> Self {
        Self {
            inputs,
            N: N
            separator: None,
            id_: new_id(),
        }
    }
}

impl<dtype> ImmutableConstOp<dtype>
where dtype: con,
{
    pub fn new(inner: Rc<ImmutableConst<dtype>>) -> Self {
        Self{inner}
    }

    pub fn tensor(&self) -> Edge<dtype> {
        Edge::<dtype>::new(self.inner.clone(), 0)
    }
}

struct ImmutableConstOp<dtype>
where dtype: con,
{
    inner: Rc<ImmutableConst<dtype>>,
}

impl<dtype> GraphOperation for ImmutableConst<dtype>
where dtype: con,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("ImmutableConst_{}")?
        };
        let mut new_op = graph.new_operation("ImmutableConst", &op_name)?;
        {
            (|attr| {new_op.set_attr_shape("shape", attr)})(&self.shape)
        }
        {
            (|attr| {new_op.set_attr_string("memory_region_name", attr)})(&self.memory_region_name)
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct ImmutableConst<dtype>
where dtype: con,
{
    shape: Shape,
    memory_region_name: String,
    id_: usize,
}

impl<dtype> ImmutableConst<dtype>
where dtype: con,
{
    pub fn finish(self) -> ImmutableConstOp<dtype> {
        ImmutableConstOp::new(Rc::new(self))
    }

    pub fn new(shape: &Shape, memory_region_name: &str) -> Self {
        Self {
            shape: shape.clone()
            memory_region_name: memory_region_name.to_string()
            id_: new_id(),
        }
    }
}

impl<T> SparseSparseMaximumOp<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
{
    pub fn new(inner: Rc<SparseSparseMaximum<T>>) -> Self {
        Self{inner}
    }

    pub fn output_indices(&self) -> Edge<i64> {
        Edge::<i64>::new(self.inner.clone(), 0)
    }

    pub fn output_values(&self) -> Edge<T> {
        Edge::<T>::new(self.inner.clone(), 1)
    }
}

struct SparseSparseMaximumOp<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
{
    inner: Rc<SparseSparseMaximum<T>>,
}

impl<T> GraphOperation for SparseSparseMaximum<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("SparseSparseMaximum_{}")?
        };
        let mut new_op = graph.new_operation("SparseSparseMaximum", &op_name)?;
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct SparseSparseMaximum<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
{
    a_indices: Edge<i64>,
    a_values: Edge<T>,
    a_shape: Edge<i64>,
    b_indices: Edge<i64>,
    b_values: Edge<T>,
    b_shape: Edge<i64>,
    id_: usize,
}

impl<T> SparseSparseMaximum<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
{
    pub fn finish(self) -> SparseSparseMaximumOp<T> {
        SparseSparseMaximumOp::new(Rc::new(self))
    }

    pub fn new(a_indices: Edge<i64>, a_values: Edge<T>, a_shape: Edge<i64>, b_indices: Edge<i64>, b_values: Edge<T>, b_shape: Edge<i64>) -> Self {
        Self {
            a_indices,
            a_values,
            a_shape,
            b_indices,
            b_values,
            b_shape,
            id_: new_id(),
        }
    }
}

impl<T> MatrixSetDiagOp<T>
where T: con,
{
    pub fn new(inner: Rc<MatrixSetDiag<T>>) -> Self {
        Self{inner}
    }

    pub fn output(&self) -> Edge<T> {
        Edge::<T>::new(self.inner.clone(), 0)
    }
}

struct MatrixSetDiagOp<T>
where T: con,
{
    inner: Rc<MatrixSetDiag<T>>,
}

impl<T> GraphOperation for MatrixSetDiag<T>
where T: con,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("MatrixSetDiag_{}")?
        };
        let mut new_op = graph.new_operation("MatrixSetDiag", &op_name)?;
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct MatrixSetDiag<T>
where T: con,
{
    input: Edge<T>,
    diagonal: Edge<T>,
    id_: usize,
}

impl<T> MatrixSetDiag<T>
where T: con,
{
    pub fn finish(self) -> MatrixSetDiagOp<T> {
        MatrixSetDiagOp::new(Rc::new(self))
    }

    pub fn new(input: Edge<T>, diagonal: Edge<T>) -> Self {
        Self {
            input,
            diagonal,
            id_: new_id(),
        }
    }
}

impl EncodeBase64Op {
    pub fn new(inner: Rc<EncodeBase64>) -> Self {
        Self{inner}
    }

    pub fn output(&self) -> Edge<String> {
        Edge::<String>::new(self.inner.clone(), 0)
    }
}

struct EncodeBase64Op {
    inner: Rc<EncodeBase64>,
}

impl GraphOperation for EncodeBase64 {
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("EncodeBase64_{}")?
        };
        let mut new_op = graph.new_operation("EncodeBase64", &op_name)?;
        {
            match self.pad {
            }
            None => new_op.set_attr_value_proto("pad", &vec![40_u8, 0_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_bool("pad", *attr)})(&value),
        };
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct EncodeBase64 {
    input: Edge<String>,
    pad: Option<bool>,
    id_: usize,
}

impl EncodeBase64 {
    pub fn pad(&mut self, pad: bool) -> &mut Self {
        self.pad = Some(pad);
        &self
    }

    pub fn finish(self) -> EncodeBase64Op {
        EncodeBase64Op::new(Rc::new(self))
    }

    pub fn new(input: Edge<String>) -> Self {
        Self {
            input,
            pad: None,
            id_: new_id(),
        }
    }
}

impl TensorArrayCloseV2Op {
    pub fn new(inner: Rc<TensorArrayCloseV2>) -> Self {
        Self{inner}
    }
}

struct TensorArrayCloseV2Op {
    inner: Rc<TensorArrayCloseV2>,
}

impl GraphOperation for TensorArrayCloseV2 {
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("TensorArrayCloseV2_{}")?
        };
        let mut new_op = graph.new_operation("TensorArrayCloseV2", &op_name)?;
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct TensorArrayCloseV2 {
    handle: Edge<String>,
    id_: usize,
}

impl TensorArrayCloseV2 {
    pub fn finish(self) -> TensorArrayCloseV2Op {
        TensorArrayCloseV2Op::new(Rc::new(self))
    }

    pub fn new(handle: Edge<String>) -> Self {
        Self {
            handle,
            id_: new_id(),
        }
    }
}

impl<T, output_idx_type> LuOp<T, output_idx_type>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_COMPLEX64_or_DT_COMPLEX128,
      output_idx_type: con_or_DT_INT32_or_DT_INT64,
{
    pub fn new(inner: Rc<Lu<T, output_idx_type>>) -> Self {
        Self{inner}
    }

    pub fn lu(&self) -> Edge<T> {
        Edge::<T>::new(self.inner.clone(), 0)
    }

    pub fn p(&self) -> Edge<output_idx_type> {
        Edge::<output_idx_type>::new(self.inner.clone(), 1)
    }
}

struct LuOp<T, output_idx_type>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_COMPLEX64_or_DT_COMPLEX128,
      output_idx_type: con_or_DT_INT32_or_DT_INT64,
{
    inner: Rc<Lu<T, output_idx_type>>,
}

impl<T, output_idx_type> GraphOperation for Lu<T, output_idx_type>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_COMPLEX64_or_DT_COMPLEX128,
      output_idx_type: con_or_DT_INT32_or_DT_INT64,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("Lu_{}")?
        };
        let mut new_op = graph.new_operation("Lu", &op_name)?;
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct Lu<T, output_idx_type>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_COMPLEX64_or_DT_COMPLEX128,
      output_idx_type: con_or_DT_INT32_or_DT_INT64,
{
    input: Edge<T>,
    id_: usize,
}

impl<T, output_idx_type> Lu<T, output_idx_type>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_COMPLEX64_or_DT_COMPLEX128,
      output_idx_type: con_or_DT_INT32_or_DT_INT64,
{
    pub fn finish(self) -> LuOp<T, output_idx_type> {
        LuOp::new(Rc::new(self))
    }

    pub fn new(input: Edge<T>) -> Self {
        Self {
            input,
            id_: new_id(),
        }
    }
}

impl<T> BroadcastGradientArgsOp<T>
where T: con_or_DT_INT32_or_DT_INT64,
{
    pub fn new(inner: Rc<BroadcastGradientArgs<T>>) -> Self {
        Self{inner}
    }

    pub fn r0(&self) -> Edge<T> {
        Edge::<T>::new(self.inner.clone(), 0)
    }

    pub fn r1(&self) -> Edge<T> {
        Edge::<T>::new(self.inner.clone(), 1)
    }
}

struct BroadcastGradientArgsOp<T>
where T: con_or_DT_INT32_or_DT_INT64,
{
    inner: Rc<BroadcastGradientArgs<T>>,
}

impl<T> GraphOperation for BroadcastGradientArgs<T>
where T: con_or_DT_INT32_or_DT_INT64,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("BroadcastGradientArgs_{}")?
        };
        let mut new_op = graph.new_operation("BroadcastGradientArgs", &op_name)?;
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct BroadcastGradientArgs<T>
where T: con_or_DT_INT32_or_DT_INT64,
{
    s0: Edge<T>,
    s1: Edge<T>,
    id_: usize,
}

impl<T> BroadcastGradientArgs<T>
where T: con_or_DT_INT32_or_DT_INT64,
{
    pub fn finish(self) -> BroadcastGradientArgsOp<T> {
        BroadcastGradientArgsOp::new(Rc::new(self))
    }

    pub fn new(s0: Edge<T>, s1: Edge<T>) -> Self {
        Self {
            s0,
            s1,
            id_: new_id(),
        }
    }
}

impl<T, Tindices> SparseApplyProximalAdagradOp<T, Tindices>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      Tindices: con_or_DT_INT32_or_DT_INT64,
{
    pub fn new(inner: Rc<SparseApplyProximalAdagrad<T, Tindices>>) -> Self {
        Self{inner}
    }

    pub fn out(&self) -> Edge<T> {
        Edge::<T>::new(self.inner.clone(), 0)
    }
}

struct SparseApplyProximalAdagradOp<T, Tindices>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      Tindices: con_or_DT_INT32_or_DT_INT64,
{
    inner: Rc<SparseApplyProximalAdagrad<T, Tindices>>,
}

impl<T, Tindices> GraphOperation for SparseApplyProximalAdagrad<T, Tindices>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      Tindices: con_or_DT_INT32_or_DT_INT64,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("SparseApplyProximalAdagrad_{}")?
        };
        let mut new_op = graph.new_operation("SparseApplyProximalAdagrad", &op_name)?;
        {
            match self.use_locking {
            }
            None => new_op.set_attr_value_proto("use_locking", &vec![40_u8, 0_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_bool("use_locking", *attr)})(&value),
        };
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct SparseApplyProximalAdagrad<T, Tindices>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      Tindices: con_or_DT_INT32_or_DT_INT64,
{
    var: Edge<T>,
    accum: Edge<T>,
    lr: Edge<T>,
    l1: Edge<T>,
    l2: Edge<T>,
    grad: Edge<T>,
    indices: Edge<Tindices>,
    use_locking: Option<bool>,
    id_: usize,
}

impl<T, Tindices> SparseApplyProximalAdagrad<T, Tindices>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      Tindices: con_or_DT_INT32_or_DT_INT64,
{
    pub fn use_locking(&mut self, use_locking: bool) -> &mut Self {
        self.use_locking = Some(use_locking);
        &self
    }

    pub fn finish(self) -> SparseApplyProximalAdagradOp<T, Tindices> {
        SparseApplyProximalAdagradOp::new(Rc::new(self))
    }

    pub fn new(var: Edge<T>, accum: Edge<T>, lr: Edge<T>, l1: Edge<T>, l2: Edge<T>, grad: Edge<T>, indices: Edge<Tindices>) -> Self {
        Self {
            var,
            accum,
            lr,
            l1,
            l2,
            grad,
            indices,
            use_locking: None,
            id_: new_id(),
        }
    }
}

impl<T, Tshape> QuantizedReshapeOp<T, Tshape>
where T: con,
      Tshape: con_or_DT_INT32_or_DT_INT64,
{
    pub fn new(inner: Rc<QuantizedReshape<T, Tshape>>) -> Self {
        Self{inner}
    }

    pub fn output(&self) -> Edge<T> {
        Edge::<T>::new(self.inner.clone(), 0)
    }

    pub fn output_min(&self) -> Edge<f32> {
        Edge::<f32>::new(self.inner.clone(), 1)
    }

    pub fn output_max(&self) -> Edge<f32> {
        Edge::<f32>::new(self.inner.clone(), 2)
    }
}

struct QuantizedReshapeOp<T, Tshape>
where T: con,
      Tshape: con_or_DT_INT32_or_DT_INT64,
{
    inner: Rc<QuantizedReshape<T, Tshape>>,
}

impl<T, Tshape> GraphOperation for QuantizedReshape<T, Tshape>
where T: con,
      Tshape: con_or_DT_INT32_or_DT_INT64,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("QuantizedReshape_{}")?
        };
        let mut new_op = graph.new_operation("QuantizedReshape", &op_name)?;
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct QuantizedReshape<T, Tshape>
where T: con,
      Tshape: con_or_DT_INT32_or_DT_INT64,
{
    tensor: Edge<T>,
    shape: Edge<Tshape>,
    input_min: Edge<f32>,
    input_max: Edge<f32>,
    id_: usize,
}

impl<T, Tshape> QuantizedReshape<T, Tshape>
where T: con,
      Tshape: con_or_DT_INT32_or_DT_INT64,
{
    pub fn finish(self) -> QuantizedReshapeOp<T, Tshape> {
        QuantizedReshapeOp::new(Rc::new(self))
    }

    pub fn new(tensor: Edge<T>, shape: Edge<Tshape>, input_min: Edge<f32>, input_max: Edge<f32>) -> Self {
        Self {
            tensor,
            shape,
            input_min,
            input_max,
            id_: new_id(),
        }
    }
}

impl<T, Tidx> SparseSegmentSqrtNGradOp<T, Tidx>
where T: con_or_DT_FLOAT_or_DT_DOUBLE,
      Tidx: con_or_DT_INT32_or_DT_INT64,
{
    pub fn new(inner: Rc<SparseSegmentSqrtNGrad<T, Tidx>>) -> Self {
        Self{inner}
    }

    pub fn output(&self) -> Edge<T> {
        Edge::<T>::new(self.inner.clone(), 0)
    }
}

struct SparseSegmentSqrtNGradOp<T, Tidx>
where T: con_or_DT_FLOAT_or_DT_DOUBLE,
      Tidx: con_or_DT_INT32_or_DT_INT64,
{
    inner: Rc<SparseSegmentSqrtNGrad<T, Tidx>>,
}

impl<T, Tidx> GraphOperation for SparseSegmentSqrtNGrad<T, Tidx>
where T: con_or_DT_FLOAT_or_DT_DOUBLE,
      Tidx: con_or_DT_INT32_or_DT_INT64,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("SparseSegmentSqrtNGrad_{}")?
        };
        let mut new_op = graph.new_operation("SparseSegmentSqrtNGrad", &op_name)?;
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct SparseSegmentSqrtNGrad<T, Tidx>
where T: con_or_DT_FLOAT_or_DT_DOUBLE,
      Tidx: con_or_DT_INT32_or_DT_INT64,
{
    grad: Edge<T>,
    indices: Edge<Tidx>,
    segment_ids: Edge<i32>,
    output_dim0: Edge<i32>,
    id_: usize,
}

impl<T, Tidx> SparseSegmentSqrtNGrad<T, Tidx>
where T: con_or_DT_FLOAT_or_DT_DOUBLE,
      Tidx: con_or_DT_INT32_or_DT_INT64,
{
    pub fn finish(self) -> SparseSegmentSqrtNGradOp<T, Tidx> {
        SparseSegmentSqrtNGradOp::new(Rc::new(self))
    }

    pub fn new(grad: Edge<T>, indices: Edge<Tidx>, segment_ids: Edge<i32>, output_dim0: Edge<i32>) -> Self {
        Self {
            grad,
            indices,
            segment_ids,
            output_dim0,
            id_: new_id(),
        }
    }
}

impl<T, Tpaddings> PadOp<T, Tpaddings>
where T: con,
      Tpaddings: con_or_DT_INT32_or_DT_INT64,
{
    pub fn new(inner: Rc<Pad<T, Tpaddings>>) -> Self {
        Self{inner}
    }

    pub fn output(&self) -> Edge<T> {
        Edge::<T>::new(self.inner.clone(), 0)
    }
}

struct PadOp<T, Tpaddings>
where T: con,
      Tpaddings: con_or_DT_INT32_or_DT_INT64,
{
    inner: Rc<Pad<T, Tpaddings>>,
}

impl<T, Tpaddings> GraphOperation for Pad<T, Tpaddings>
where T: con,
      Tpaddings: con_or_DT_INT32_or_DT_INT64,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("Pad_{}")?
        };
        let mut new_op = graph.new_operation("Pad", &op_name)?;
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct Pad<T, Tpaddings>
where T: con,
      Tpaddings: con_or_DT_INT32_or_DT_INT64,
{
    input: Edge<T>,
    paddings: Edge<Tpaddings>,
    id_: usize,
}

impl<T, Tpaddings> Pad<T, Tpaddings>
where T: con,
      Tpaddings: con_or_DT_INT32_or_DT_INT64,
{
    pub fn finish(self) -> PadOp<T, Tpaddings> {
        PadOp::new(Rc::new(self))
    }

    pub fn new(input: Edge<T>, paddings: Edge<Tpaddings>) -> Self {
        Self {
            input,
            paddings,
            id_: new_id(),
        }
    }
}

impl<T> _ParallelConcatUpdateOp<T>
where T: con,
{
    pub fn new(inner: Rc<_ParallelConcatUpdate<T>>) -> Self {
        Self{inner}
    }

    pub fn output(&self) -> Edge<T> {
        Edge::<T>::new(self.inner.clone(), 0)
    }
}

struct _ParallelConcatUpdateOp<T>
where T: con,
{
    inner: Rc<_ParallelConcatUpdate<T>>,
}

impl<T> GraphOperation for _ParallelConcatUpdate<T>
where T: con,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("_ParallelConcatUpdate_{}")?
        };
        let mut new_op = graph.new_operation("_ParallelConcatUpdate", &op_name)?;
        {
            (|attr| {new_op.set_attr_int("loc", *attr)})(&self.loc)
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct _ParallelConcatUpdate<T>
where T: con,
{
    value: Edge<T>,
    update: Edge<T>,
    loc: i64,
    id_: usize,
}

impl<T> _ParallelConcatUpdate<T>
where T: con,
{
    pub fn finish(self) -> _ParallelConcatUpdateOp<T> {
        _ParallelConcatUpdateOp::new(Rc::new(self))
    }

    pub fn new(value: Edge<T>, update: Edge<T>, loc: int) -> Self {
        Self {
            value,
            update,
            loc: loc
            id_: new_id(),
        }
    }
}

impl<T> DigammaOp<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
{
    pub fn new(inner: Rc<Digamma<T>>) -> Self {
        Self{inner}
    }

    pub fn y(&self) -> Edge<T> {
        Edge::<T>::new(self.inner.clone(), 0)
    }
}

struct DigammaOp<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
{
    inner: Rc<Digamma<T>>,
}

impl<T> GraphOperation for Digamma<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("Digamma_{}")?
        };
        let mut new_op = graph.new_operation("Digamma", &op_name)?;
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct Digamma<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
{
    x: Edge<T>,
    id_: usize,
}

impl<T> Digamma<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
{
    pub fn finish(self) -> DigammaOp<T> {
        DigammaOp::new(Rc::new(self))
    }

    pub fn new(x: Edge<T>) -> Self {
        Self {
            x,
            id_: new_id(),
        }
    }
}

impl<T> Conv2DBackpropFilterOp<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
{
    pub fn new(inner: Rc<Conv2DBackpropFilter<T>>) -> Self {
        Self{inner}
    }

    pub fn output(&self) -> Edge<T> {
        Edge::<T>::new(self.inner.clone(), 0)
    }
}

struct Conv2DBackpropFilterOp<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
{
    inner: Rc<Conv2DBackpropFilter<T>>,
}

impl<T> GraphOperation for Conv2DBackpropFilter<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("Conv2DBackpropFilter_{}")?
        };
        let mut new_op = graph.new_operation("Conv2DBackpropFilter", &op_name)?;
        {
            (|attrs| {new_op.set_attr_int_list("strides", attrs)})(&self.strides)
        }
        {
            match self.use_cudnn_on_gpu {
            }
            None => new_op.set_attr_value_proto("use_cudnn_on_gpu", &vec![40_u8, 1_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_bool("use_cudnn_on_gpu", *attr)})(&value),
        };
        {
            (|attr| {new_op.set_attr_string("padding", attr)})(&self.padding)
        }
        {
            match self.data_format {
            }
            None => new_op.set_attr_value_proto("data_format", &vec![18_u8, 4_u8, 78_u8, 72_u8, 87_u8, 67_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_string("data_format", attr)})(&value),
        };
        {
            match self.dilations {
            }
            None => new_op.set_attr_value_proto("dilations", &vec![10_u8, 0_u8, 26_u8, 4_u8,]);,
            Some(value) => (|attrs| {new_op.set_attr_int_list("dilations", attrs)})(&value),
        };
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct Conv2DBackpropFilter<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
{
    input: Edge<T>,
    filter_sizes: Edge<i32>,
    out_backprop: Edge<T>,
    strides: Vec<i64>,
    use_cudnn_on_gpu: Option<bool>,
    padding: String,
    data_format: Option<String>,
    dilations: Option<Vec<i64>>,
    id_: usize,
}

impl<T> Conv2DBackpropFilter<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
{
    pub fn use_cudnn_on_gpu(&mut self, use_cudnn_on_gpu: bool) -> &mut Self {
        self.use_cudnn_on_gpu = Some(use_cudnn_on_gpu);
        &self
    }

    pub fn data_format(&mut self, data_format: &str) -> &mut Self {
        self.data_format = Some(data_format.to_string());
        &self
    }

    pub fn dilations(&mut self, dilations: &[int]) -> &mut Self {
        self.dilations = Some(dilations.to_vec());
        &self
    }

    pub fn finish(self) -> Conv2DBackpropFilterOp<T> {
        Conv2DBackpropFilterOp::new(Rc::new(self))
    }

    pub fn new(input: Edge<T>, filter_sizes: Edge<i32>, out_backprop: Edge<T>, strides: &[int], padding: &str) -> Self {
        Self {
            input,
            filter_sizes,
            out_backprop,
            strides: strides.to_vec()
            use_cudnn_on_gpu: None,
            padding: padding.to_string()
            data_format: None,
            dilations: None,
            id_: new_id(),
        }
    }
}

impl<dtype> PlaceholderOp<dtype>
where dtype: con,
{
    pub fn new(inner: Rc<Placeholder<dtype>>) -> Self {
        Self{inner}
    }

    pub fn output(&self) -> Edge<dtype> {
        Edge::<dtype>::new(self.inner.clone(), 0)
    }
}

struct PlaceholderOp<dtype>
where dtype: con,
{
    inner: Rc<Placeholder<dtype>>,
}

impl<dtype> GraphOperation for Placeholder<dtype>
where dtype: con,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("Placeholder_{}")?
        };
        let mut new_op = graph.new_operation("Placeholder", &op_name)?;
        {
            match self.shape {
            }
            None => new_op.set_attr_value_proto("shape", &vec![58_u8, 0_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_shape("shape", attr)})(&value),
        };
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct Placeholder<dtype>
where dtype: con,
{
    shape: Option<Shape>,
    id_: usize,
}

impl<dtype> Placeholder<dtype>
where dtype: con,
{
    pub fn shape(&mut self, shape: &Shape) -> &mut Self {
        self.shape = Some(shape.clone());
        &self
    }

    pub fn finish(self) -> PlaceholderOp<dtype> {
        PlaceholderOp::new(Rc::new(self))
    }

    pub fn new() -> Self {
        Self {
            shape: None,
            id_: new_id(),
        }
    }
}

impl<T> SparseSliceOp<T>
where T: con,
{
    pub fn new(inner: Rc<SparseSlice<T>>) -> Self {
        Self{inner}
    }

    pub fn output_indices(&self) -> Edge<i64> {
        Edge::<i64>::new(self.inner.clone(), 0)
    }

    pub fn output_values(&self) -> Edge<T> {
        Edge::<T>::new(self.inner.clone(), 1)
    }

    pub fn output_shape(&self) -> Edge<i64> {
        Edge::<i64>::new(self.inner.clone(), 2)
    }
}

struct SparseSliceOp<T>
where T: con,
{
    inner: Rc<SparseSlice<T>>,
}

impl<T> GraphOperation for SparseSlice<T>
where T: con,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("SparseSlice_{}")?
        };
        let mut new_op = graph.new_operation("SparseSlice", &op_name)?;
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct SparseSlice<T>
where T: con,
{
    indices: Edge<i64>,
    values: Edge<T>,
    shape: Edge<i64>,
    start: Edge<i64>,
    size: Edge<i64>,
    id_: usize,
}

impl<T> SparseSlice<T>
where T: con,
{
    pub fn finish(self) -> SparseSliceOp<T> {
        SparseSliceOp::new(Rc::new(self))
    }

    pub fn new(indices: Edge<i64>, values: Edge<T>, shape: Edge<i64>, start: Edge<i64>, size: Edge<i64>) -> Self {
        Self {
            indices,
            values,
            shape,
            start,
            size,
            id_: new_id(),
        }
    }
}

impl<T> QuantizedConcatOp<T>
where T: con,
{
    pub fn new(inner: Rc<QuantizedConcat<T>>) -> Self {
        Self{inner}
    }

    pub fn output(&self) -> Edge<T> {
        Edge::<T>::new(self.inner.clone(), 0)
    }

    pub fn output_min(&self) -> Edge<f32> {
        Edge::<f32>::new(self.inner.clone(), 1)
    }

    pub fn output_max(&self) -> Edge<f32> {
        Edge::<f32>::new(self.inner.clone(), 2)
    }
}

struct QuantizedConcatOp<T>
where T: con,
{
    inner: Rc<QuantizedConcat<T>>,
}

impl<T> GraphOperation for QuantizedConcat<T>
where T: con,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("QuantizedConcat_{}")?
        };
        let mut new_op = graph.new_operation("QuantizedConcat", &op_name)?;
        {
            (|attr| {new_op.set_attr_int("N", *attr)})(&self.N)
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct QuantizedConcat<T>
where T: con,
{
    concat_dim: Edge<i32>,
    values: Edge<T>,
    input_mins: Edge<f32>,
    input_maxes: Edge<f32>,
    N: i64,
    id_: usize,
}

impl<T> QuantizedConcat<T>
where T: con,
{
    pub fn finish(self) -> QuantizedConcatOp<T> {
        QuantizedConcatOp::new(Rc::new(self))
    }

    pub fn new(concat_dim: Edge<i32>, values: Edge<T>, input_mins: Edge<f32>, input_maxes: Edge<f32>, N: int) -> Self {
        Self {
            concat_dim,
            values,
            input_mins,
            input_maxes,
            N: N
            id_: new_id(),
        }
    }
}

impl<T, Tpaddings> SpaceToBatchOp<T, Tpaddings>
where T: con,
      Tpaddings: con_or_DT_INT32_or_DT_INT64,
{
    pub fn new(inner: Rc<SpaceToBatch<T, Tpaddings>>) -> Self {
        Self{inner}
    }

    pub fn output(&self) -> Edge<T> {
        Edge::<T>::new(self.inner.clone(), 0)
    }
}

struct SpaceToBatchOp<T, Tpaddings>
where T: con,
      Tpaddings: con_or_DT_INT32_or_DT_INT64,
{
    inner: Rc<SpaceToBatch<T, Tpaddings>>,
}

impl<T, Tpaddings> GraphOperation for SpaceToBatch<T, Tpaddings>
where T: con,
      Tpaddings: con_or_DT_INT32_or_DT_INT64,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("SpaceToBatch_{}")?
        };
        let mut new_op = graph.new_operation("SpaceToBatch", &op_name)?;
        {
            (|attr| {new_op.set_attr_int("block_size", *attr)})(&self.block_size)
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct SpaceToBatch<T, Tpaddings>
where T: con,
      Tpaddings: con_or_DT_INT32_or_DT_INT64,
{
    input: Edge<T>,
    paddings: Edge<Tpaddings>,
    block_size: i64,
    id_: usize,
}

impl<T, Tpaddings> SpaceToBatch<T, Tpaddings>
where T: con,
      Tpaddings: con_or_DT_INT32_or_DT_INT64,
{
    pub fn finish(self) -> SpaceToBatchOp<T, Tpaddings> {
        SpaceToBatchOp::new(Rc::new(self))
    }

    pub fn new(input: Edge<T>, paddings: Edge<Tpaddings>, block_size: int) -> Self {
        Self {
            input,
            paddings,
            block_size: block_size
            id_: new_id(),
        }
    }
}

impl DecodeGifOp {
    pub fn new(inner: Rc<DecodeGif>) -> Self {
        Self{inner}
    }

    pub fn image(&self) -> Edge<u8> {
        Edge::<u8>::new(self.inner.clone(), 0)
    }
}

struct DecodeGifOp {
    inner: Rc<DecodeGif>,
}

impl GraphOperation for DecodeGif {
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("DecodeGif_{}")?
        };
        let mut new_op = graph.new_operation("DecodeGif", &op_name)?;
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct DecodeGif {
    contents: Edge<String>,
    id_: usize,
}

impl DecodeGif {
    pub fn finish(self) -> DecodeGifOp {
        DecodeGifOp::new(Rc::new(self))
    }

    pub fn new(contents: Edge<String>) -> Self {
        Self {
            contents,
            id_: new_id(),
        }
    }
}

impl<T> UnpackOp<T>
where T: con,
{
    pub fn new(inner: Rc<Unpack<T>>) -> Self {
        Self{inner}
    }

    pub fn output(&self) -> Edge<T> {
        Edge::<T>::new(self.inner.clone(), 0)
    }
}

struct UnpackOp<T>
where T: con,
{
    inner: Rc<Unpack<T>>,
}

impl<T> GraphOperation for Unpack<T>
where T: con,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("Unpack_{}")?
        };
        let mut new_op = graph.new_operation("Unpack", &op_name)?;
        {
            (|attr| {new_op.set_attr_int("num", *attr)})(&self.num)
        }
        {
            match self.axis {
            }
            None => new_op.set_attr_value_proto("axis", &vec![24_u8, 0_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_int("axis", *attr)})(&value),
        };
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct Unpack<T>
where T: con,
{
    value: Edge<T>,
    num: i64,
    axis: Option<i64>,
    id_: usize,
}

impl<T> Unpack<T>
where T: con,
{
    pub fn axis(&mut self, axis: int) -> &mut Self {
        self.axis = Some(axis);
        &self
    }

    pub fn finish(self) -> UnpackOp<T> {
        UnpackOp::new(Rc::new(self))
    }

    pub fn new(value: Edge<T>, num: int) -> Self {
        Self {
            value,
            num: num
            axis: None,
            id_: new_id(),
        }
    }
}

impl<T, Tblock_shape, Tcrops> BatchToSpaceNDOp<T, Tblock_shape, Tcrops>
where T: con,
      Tblock_shape: con_or_DT_INT32_or_DT_INT64,
      Tcrops: con_or_DT_INT32_or_DT_INT64,
{
    pub fn new(inner: Rc<BatchToSpaceND<T, Tblock_shape, Tcrops>>) -> Self {
        Self{inner}
    }

    pub fn output(&self) -> Edge<T> {
        Edge::<T>::new(self.inner.clone(), 0)
    }
}

struct BatchToSpaceNDOp<T, Tblock_shape, Tcrops>
where T: con,
      Tblock_shape: con_or_DT_INT32_or_DT_INT64,
      Tcrops: con_or_DT_INT32_or_DT_INT64,
{
    inner: Rc<BatchToSpaceND<T, Tblock_shape, Tcrops>>,
}

impl<T, Tblock_shape, Tcrops> GraphOperation for BatchToSpaceND<T, Tblock_shape, Tcrops>
where T: con,
      Tblock_shape: con_or_DT_INT32_or_DT_INT64,
      Tcrops: con_or_DT_INT32_or_DT_INT64,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("BatchToSpaceND_{}")?
        };
        let mut new_op = graph.new_operation("BatchToSpaceND", &op_name)?;
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct BatchToSpaceND<T, Tblock_shape, Tcrops>
where T: con,
      Tblock_shape: con_or_DT_INT32_or_DT_INT64,
      Tcrops: con_or_DT_INT32_or_DT_INT64,
{
    input: Edge<T>,
    block_shape: Edge<Tblock_shape>,
    crops: Edge<Tcrops>,
    id_: usize,
}

impl<T, Tblock_shape, Tcrops> BatchToSpaceND<T, Tblock_shape, Tcrops>
where T: con,
      Tblock_shape: con_or_DT_INT32_or_DT_INT64,
      Tcrops: con_or_DT_INT32_or_DT_INT64,
{
    pub fn finish(self) -> BatchToSpaceNDOp<T, Tblock_shape, Tcrops> {
        BatchToSpaceNDOp::new(Rc::new(self))
    }

    pub fn new(input: Edge<T>, block_shape: Edge<Tblock_shape>, crops: Edge<Tcrops>) -> Self {
        Self {
            input,
            block_shape,
            crops,
            id_: new_id(),
        }
    }
}

pub trait con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_QINT16_or_DT_QUINT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_QINT16_or_DT_QUINT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64 for BFloat16 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_QINT16_or_DT_QUINT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64 for OtherComplex<f32> {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_QINT16_or_DT_QUINT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64 for OtherComplex<f64> {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_QINT16_or_DT_QUINT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64 for f32 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_QINT16_or_DT_QUINT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64 for f64 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_QINT16_or_DT_QUINT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64 for i16 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_QINT16_or_DT_QUINT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64 for i32 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_QINT16_or_DT_QUINT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64 for i64 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_QINT16_or_DT_QUINT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64 for i8 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_QINT16_or_DT_QUINT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64 for u16 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_QINT16_or_DT_QUINT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64 for u32 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_QINT16_or_DT_QUINT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64 for u64 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_QINT16_or_DT_QUINT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64 for u8 {
}

impl<T, type_> BitcastOp<T, type_>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_QINT16_or_DT_QUINT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      type_: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_QINT16_or_DT_QUINT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
{
    pub fn new(inner: Rc<Bitcast<T, type_>>) -> Self {
        Self{inner}
    }

    pub fn output(&self) -> Edge<type_> {
        Edge::<type_>::new(self.inner.clone(), 0)
    }
}

struct BitcastOp<T, type_>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_QINT16_or_DT_QUINT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      type_: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_QINT16_or_DT_QUINT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
{
    inner: Rc<Bitcast<T, type_>>,
}

impl<T, type_> GraphOperation for Bitcast<T, type_>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_QINT16_or_DT_QUINT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      type_: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_QINT16_or_DT_QUINT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("Bitcast_{}")?
        };
        let mut new_op = graph.new_operation("Bitcast", &op_name)?;
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct Bitcast<T, type_>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_QINT16_or_DT_QUINT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      type_: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_QINT16_or_DT_QUINT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
{
    input: Edge<T>,
    id_: usize,
}

impl<T, type_> Bitcast<T, type_>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_QINT16_or_DT_QUINT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      type_: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_QINT16_or_DT_QUINT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
{
    pub fn finish(self) -> BitcastOp<T, type_> {
        BitcastOp::new(Rc::new(self))
    }

    pub fn new(input: Edge<T>) -> Self {
        Self {
            input,
            id_: new_id(),
        }
    }
}

impl<T> WhereOp<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_BOOL_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
{
    pub fn new(inner: Rc<Where<T>>) -> Self {
        Self{inner}
    }

    pub fn index(&self) -> Edge<i64> {
        Edge::<i64>::new(self.inner.clone(), 0)
    }
}

struct WhereOp<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_BOOL_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
{
    inner: Rc<Where<T>>,
}

impl<T> GraphOperation for Where<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_BOOL_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("Where_{}")?
        };
        let mut new_op = graph.new_operation("Where", &op_name)?;
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct Where<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_BOOL_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
{
    input: Edge<T>,
    id_: usize,
}

impl<T> Where<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_BOOL_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
{
    pub fn finish(self) -> WhereOp<T> {
        WhereOp::new(Rc::new(self))
    }

    pub fn new(input: Edge<T>) -> Self {
        Self {
            input,
            id_: new_id(),
        }
    }
}

impl<T> QuantizeAndDequantizeOp<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
{
    pub fn new(inner: Rc<QuantizeAndDequantize<T>>) -> Self {
        Self{inner}
    }

    pub fn output(&self) -> Edge<T> {
        Edge::<T>::new(self.inner.clone(), 0)
    }
}

struct QuantizeAndDequantizeOp<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
{
    inner: Rc<QuantizeAndDequantize<T>>,
}

impl<T> GraphOperation for QuantizeAndDequantize<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("QuantizeAndDequantize_{}")?
        };
        let mut new_op = graph.new_operation("QuantizeAndDequantize", &op_name)?;
        {
            match self.signed_input {
            }
            None => new_op.set_attr_value_proto("signed_input", &vec![40_u8, 1_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_bool("signed_input", *attr)})(&value),
        };
        {
            match self.num_bits {
            }
            None => new_op.set_attr_value_proto("num_bits", &vec![24_u8, 8_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_int("num_bits", *attr)})(&value),
        };
        {
            match self.range_given {
            }
            None => new_op.set_attr_value_proto("range_given", &vec![40_u8, 0_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_bool("range_given", *attr)})(&value),
        };
        {
            match self.input_min {
            }
            None => new_op.set_attr_value_proto("input_min", &vec![37_u8, 0_u8, 0_u8, 0_u8, 0_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_float("input_min", *attr)})(&value),
        };
        {
            match self.input_max {
            }
            None => new_op.set_attr_value_proto("input_max", &vec![37_u8, 0_u8, 0_u8, 0_u8, 0_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_float("input_max", *attr)})(&value),
        };
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct QuantizeAndDequantize<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
{
    input: Edge<T>,
    signed_input: Option<bool>,
    num_bits: Option<i64>,
    range_given: Option<bool>,
    input_min: Option<f32>,
    input_max: Option<f32>,
    id_: usize,
}

impl<T> QuantizeAndDequantize<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
{
    pub fn signed_input(&mut self, signed_input: bool) -> &mut Self {
        self.signed_input = Some(signed_input);
        &self
    }

    pub fn num_bits(&mut self, num_bits: int) -> &mut Self {
        self.num_bits = Some(num_bits);
        &self
    }

    pub fn range_given(&mut self, range_given: bool) -> &mut Self {
        self.range_given = Some(range_given);
        &self
    }

    pub fn input_min(&mut self, input_min: f32) -> &mut Self {
        self.input_min = Some(input_min);
        &self
    }

    pub fn input_max(&mut self, input_max: f32) -> &mut Self {
        self.input_max = Some(input_max);
        &self
    }

    pub fn finish(self) -> QuantizeAndDequantizeOp<T> {
        QuantizeAndDequantizeOp::new(Rc::new(self))
    }

    pub fn new(input: Edge<T>) -> Self {
        Self {
            input,
            signed_input: None,
            num_bits: None,
            range_given: None,
            input_min: None,
            input_max: None,
            id_: new_id(),
        }
    }
}

impl SdcaOptimizerV2Op {
    pub fn new(inner: Rc<SdcaOptimizerV2>) -> Self {
        Self{inner}
    }

    pub fn out_example_state_data(&self) -> Edge<f32> {
        Edge::<f32>::new(self.inner.clone(), 0)
    }

    pub fn out_delta_sparse_weights(&self) -> Edge<f32> {
        Edge::<f32>::new(self.inner.clone(), 1)
    }

    pub fn out_delta_dense_weights(&self) -> Edge<f32> {
        Edge::<f32>::new(self.inner.clone(), 2)
    }
}

struct SdcaOptimizerV2Op {
    inner: Rc<SdcaOptimizerV2>,
}

impl GraphOperation for SdcaOptimizerV2 {
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("SdcaOptimizerV2_{}")?
        };
        let mut new_op = graph.new_operation("SdcaOptimizerV2", &op_name)?;
        {
            (|attr| {new_op.set_attr_string("loss_type", attr)})(&self.loss_type)
        }
        {
            match self.adaptive {
            }
            None => new_op.set_attr_value_proto("adaptive", &vec![40_u8, 0_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_bool("adaptive", *attr)})(&value),
        };
        {
            (|attr| {new_op.set_attr_int("num_sparse_features", *attr)})(&self.num_sparse_features)
        }
        {
            (|attr| {new_op.set_attr_int("num_sparse_features_with_values", *attr)})(&self.num_sparse_features_with_values)
        }
        {
            (|attr| {new_op.set_attr_int("num_dense_features", *attr)})(&self.num_dense_features)
        }
        {
            (|attr| {new_op.set_attr_float("l1", *attr)})(&self.l1)
        }
        {
            (|attr| {new_op.set_attr_float("l2", *attr)})(&self.l2)
        }
        {
            (|attr| {new_op.set_attr_int("num_loss_partitions", *attr)})(&self.num_loss_partitions)
        }
        {
            (|attr| {new_op.set_attr_int("num_inner_iterations", *attr)})(&self.num_inner_iterations)
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct SdcaOptimizerV2 {
    sparse_example_indices: Edge<i64>,
    sparse_feature_indices: Edge<i64>,
    sparse_feature_values: Edge<f32>,
    dense_features: Edge<f32>,
    example_weights: Edge<f32>,
    example_labels: Edge<f32>,
    sparse_indices: Edge<i64>,
    sparse_weights: Edge<f32>,
    dense_weights: Edge<f32>,
    example_state_data: Edge<f32>,
    loss_type: String,
    adaptive: Option<bool>,
    num_sparse_features: i64,
    num_sparse_features_with_values: i64,
    num_dense_features: i64,
    l1: f32,
    l2: f32,
    num_loss_partitions: i64,
    num_inner_iterations: i64,
    id_: usize,
}

impl SdcaOptimizerV2 {
    pub fn adaptive(&mut self, adaptive: bool) -> &mut Self {
        self.adaptive = Some(adaptive);
        &self
    }

    pub fn finish(self) -> SdcaOptimizerV2Op {
        SdcaOptimizerV2Op::new(Rc::new(self))
    }

    pub fn new(sparse_example_indices: Edge<i64>, sparse_feature_indices: Edge<i64>, sparse_feature_values: Edge<f32>, dense_features: Edge<f32>, example_weights: Edge<f32>, example_labels: Edge<f32>, sparse_indices: Edge<i64>, sparse_weights: Edge<f32>, dense_weights: Edge<f32>, example_state_data: Edge<f32>, loss_type: &str, num_sparse_features: int, num_sparse_features_with_values: int, num_dense_features: int, l1: f32, l2: f32, num_loss_partitions: int, num_inner_iterations: int) -> Self {
        Self {
            sparse_example_indices,
            sparse_feature_indices,
            sparse_feature_values,
            dense_features,
            example_weights,
            example_labels,
            sparse_indices,
            sparse_weights,
            dense_weights,
            example_state_data,
            loss_type: loss_type.to_string()
            adaptive: None,
            num_sparse_features: num_sparse_features
            num_sparse_features_with_values: num_sparse_features_with_values
            num_dense_features: num_dense_features
            l1: l1
            l2: l2
            num_loss_partitions: num_loss_partitions
            num_inner_iterations: num_inner_iterations
            id_: new_id(),
        }
    }
}

impl<T> CopyHostOp<T>
where T: con,
{
    pub fn new(inner: Rc<CopyHost<T>>) -> Self {
        Self{inner}
    }

    pub fn output(&self) -> Edge<T> {
        Edge::<T>::new(self.inner.clone(), 0)
    }
}

struct CopyHostOp<T>
where T: con,
{
    inner: Rc<CopyHost<T>>,
}

impl<T> GraphOperation for CopyHost<T>
where T: con,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("CopyHost_{}")?
        };
        let mut new_op = graph.new_operation("CopyHost", &op_name)?;
        {
            match self.tensor_name {
            }
            None => new_op.set_attr_value_proto("tensor_name", &vec![18_u8, 0_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_string("tensor_name", attr)})(&value),
        };
        {
            match self.debug_ops_spec {
            }
            None => new_op.set_attr_value_proto("debug_ops_spec", &vec![10_u8, 0_u8,]);,
            Some(value) => (|attrs| {new_op.set_attr_string_list("debug_ops_spec", attrs)})(&value),
        };
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct CopyHost<T>
where T: con,
{
    input: Edge<T>,
    tensor_name: Option<String>,
    debug_ops_spec: Option<Vec<String>>,
    id_: usize,
}

impl<T> CopyHost<T>
where T: con,
{
    pub fn tensor_name(&mut self, tensor_name: &str) -> &mut Self {
        self.tensor_name = Some(tensor_name.to_string());
        &self
    }

    pub fn debug_ops_spec(&mut self, debug_ops_spec: &[String]) -> &mut Self {
        self.debug_ops_spec = Some(debug_ops_spec.to_vec());
        &self
    }

    pub fn finish(self) -> CopyHostOp<T> {
        CopyHostOp::new(Rc::new(self))
    }

    pub fn new(input: Edge<T>) -> Self {
        Self {
            input,
            tensor_name: None,
            debug_ops_spec: None,
            id_: new_id(),
        }
    }
}

impl<T> FractionalMaxPoolGradOp<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_INT64,
{
    pub fn new(inner: Rc<FractionalMaxPoolGrad<T>>) -> Self {
        Self{inner}
    }

    pub fn output(&self) -> Edge<T> {
        Edge::<T>::new(self.inner.clone(), 0)
    }
}

struct FractionalMaxPoolGradOp<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_INT64,
{
    inner: Rc<FractionalMaxPoolGrad<T>>,
}

impl<T> GraphOperation for FractionalMaxPoolGrad<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_INT64,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("FractionalMaxPoolGrad_{}")?
        };
        let mut new_op = graph.new_operation("FractionalMaxPoolGrad", &op_name)?;
        {
            match self.overlapping {
            }
            None => new_op.set_attr_value_proto("overlapping", &vec![40_u8, 0_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_bool("overlapping", *attr)})(&value),
        };
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct FractionalMaxPoolGrad<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_INT64,
{
    orig_input: Edge<T>,
    orig_output: Edge<T>,
    out_backprop: Edge<T>,
    row_pooling_sequence: Edge<i64>,
    col_pooling_sequence: Edge<i64>,
    overlapping: Option<bool>,
    id_: usize,
}

impl<T> FractionalMaxPoolGrad<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_INT64,
{
    pub fn overlapping(&mut self, overlapping: bool) -> &mut Self {
        self.overlapping = Some(overlapping);
        &self
    }

    pub fn finish(self) -> FractionalMaxPoolGradOp<T> {
        FractionalMaxPoolGradOp::new(Rc::new(self))
    }

    pub fn new(orig_input: Edge<T>, orig_output: Edge<T>, out_backprop: Edge<T>, row_pooling_sequence: Edge<i64>, col_pooling_sequence: Edge<i64>) -> Self {
        Self {
            orig_input,
            orig_output,
            out_backprop,
            row_pooling_sequence,
            col_pooling_sequence,
            overlapping: None,
            id_: new_id(),
        }
    }
}

impl<T, out_type> UpperBoundOp<T, out_type>
where T: con,
      out_type: con_or_DT_INT32_or_DT_INT64,
{
    pub fn new(inner: Rc<UpperBound<T, out_type>>) -> Self {
        Self{inner}
    }

    pub fn output(&self) -> Edge<out_type> {
        Edge::<out_type>::new(self.inner.clone(), 0)
    }
}

struct UpperBoundOp<T, out_type>
where T: con,
      out_type: con_or_DT_INT32_or_DT_INT64,
{
    inner: Rc<UpperBound<T, out_type>>,
}

impl<T, out_type> GraphOperation for UpperBound<T, out_type>
where T: con,
      out_type: con_or_DT_INT32_or_DT_INT64,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("UpperBound_{}")?
        };
        let mut new_op = graph.new_operation("UpperBound", &op_name)?;
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct UpperBound<T, out_type>
where T: con,
      out_type: con_or_DT_INT32_or_DT_INT64,
{
    sorted_inputs: Edge<T>,
    values: Edge<T>,
    id_: usize,
}

impl<T, out_type> UpperBound<T, out_type>
where T: con,
      out_type: con_or_DT_INT32_or_DT_INT64,
{
    pub fn finish(self) -> UpperBoundOp<T, out_type> {
        UpperBoundOp::new(Rc::new(self))
    }

    pub fn new(sorted_inputs: Edge<T>, values: Edge<T>) -> Self {
        Self {
            sorted_inputs,
            values,
            id_: new_id(),
        }
    }
}

impl RetrieveTPUEmbeddingADAMParametersGradAccumDebugOp {
    pub fn new(inner: Rc<RetrieveTPUEmbeddingADAMParametersGradAccumDebug>) -> Self {
        Self{inner}
    }

    pub fn parameters(&self) -> Edge<f32> {
        Edge::<f32>::new(self.inner.clone(), 0)
    }

    pub fn momenta(&self) -> Edge<f32> {
        Edge::<f32>::new(self.inner.clone(), 1)
    }

    pub fn velocities(&self) -> Edge<f32> {
        Edge::<f32>::new(self.inner.clone(), 2)
    }

    pub fn gradient_accumulators(&self) -> Edge<f32> {
        Edge::<f32>::new(self.inner.clone(), 3)
    }
}

struct RetrieveTPUEmbeddingADAMParametersGradAccumDebugOp {
    inner: Rc<RetrieveTPUEmbeddingADAMParametersGradAccumDebug>,
}

impl GraphOperation for RetrieveTPUEmbeddingADAMParametersGradAccumDebug {
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("RetrieveTPUEmbeddingADAMParametersGradAccumDebug_{}")?
        };
        let mut new_op = graph.new_operation("RetrieveTPUEmbeddingADAMParametersGradAccumDebug", &op_name)?;
        {
            match self.table_id {
            }
            None => new_op.set_attr_value_proto("table_id", &vec![24_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 1_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_int("table_id", *attr)})(&value),
        };
        {
            match self.table_name {
            }
            None => new_op.set_attr_value_proto("table_name", &vec![18_u8, 0_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_string("table_name", attr)})(&value),
        };
        {
            (|attr| {new_op.set_attr_int("num_shards", *attr)})(&self.num_shards)
        }
        {
            (|attr| {new_op.set_attr_int("shard_id", *attr)})(&self.shard_id)
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct RetrieveTPUEmbeddingADAMParametersGradAccumDebug {
    table_id: Option<i64>,
    table_name: Option<String>,
    num_shards: i64,
    shard_id: i64,
    id_: usize,
}

impl RetrieveTPUEmbeddingADAMParametersGradAccumDebug {
    pub fn table_id(&mut self, table_id: int) -> &mut Self {
        self.table_id = Some(table_id);
        &self
    }

    pub fn table_name(&mut self, table_name: &str) -> &mut Self {
        self.table_name = Some(table_name.to_string());
        &self
    }

    pub fn finish(self) -> RetrieveTPUEmbeddingADAMParametersGradAccumDebugOp {
        RetrieveTPUEmbeddingADAMParametersGradAccumDebugOp::new(Rc::new(self))
    }

    pub fn new(num_shards: int, shard_id: int) -> Self {
        Self {
            table_id: None,
            table_name: None,
            num_shards: num_shards
            shard_id: shard_id
            id_: new_id(),
        }
    }
}

impl<dtype> _ParallelConcatStartOp<dtype>
where dtype: con,
{
    pub fn new(inner: Rc<_ParallelConcatStart<dtype>>) -> Self {
        Self{inner}
    }

    pub fn output(&self) -> Edge<dtype> {
        Edge::<dtype>::new(self.inner.clone(), 0)
    }
}

struct _ParallelConcatStartOp<dtype>
where dtype: con,
{
    inner: Rc<_ParallelConcatStart<dtype>>,
}

impl<dtype> GraphOperation for _ParallelConcatStart<dtype>
where dtype: con,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("_ParallelConcatStart_{}")?
        };
        let mut new_op = graph.new_operation("_ParallelConcatStart", &op_name)?;
        {
            (|attr| {new_op.set_attr_shape("shape", attr)})(&self.shape)
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct _ParallelConcatStart<dtype>
where dtype: con,
{
    shape: Shape,
    id_: usize,
}

impl<dtype> _ParallelConcatStart<dtype>
where dtype: con,
{
    pub fn finish(self) -> _ParallelConcatStartOp<dtype> {
        _ParallelConcatStartOp::new(Rc::new(self))
    }

    pub fn new(shape: &Shape) -> Self {
        Self {
            shape: shape.clone()
            id_: new_id(),
        }
    }
}

impl<T, out_type> LowerBoundOp<T, out_type>
where T: con,
      out_type: con_or_DT_INT32_or_DT_INT64,
{
    pub fn new(inner: Rc<LowerBound<T, out_type>>) -> Self {
        Self{inner}
    }

    pub fn output(&self) -> Edge<out_type> {
        Edge::<out_type>::new(self.inner.clone(), 0)
    }
}

struct LowerBoundOp<T, out_type>
where T: con,
      out_type: con_or_DT_INT32_or_DT_INT64,
{
    inner: Rc<LowerBound<T, out_type>>,
}

impl<T, out_type> GraphOperation for LowerBound<T, out_type>
where T: con,
      out_type: con_or_DT_INT32_or_DT_INT64,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("LowerBound_{}")?
        };
        let mut new_op = graph.new_operation("LowerBound", &op_name)?;
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct LowerBound<T, out_type>
where T: con,
      out_type: con_or_DT_INT32_or_DT_INT64,
{
    sorted_inputs: Edge<T>,
    values: Edge<T>,
    id_: usize,
}

impl<T, out_type> LowerBound<T, out_type>
where T: con,
      out_type: con_or_DT_INT32_or_DT_INT64,
{
    pub fn finish(self) -> LowerBoundOp<T, out_type> {
        LowerBoundOp::new(Rc::new(self))
    }

    pub fn new(sorted_inputs: Edge<T>, values: Edge<T>) -> Self {
        Self {
            sorted_inputs,
            values,
            id_: new_id(),
        }
    }
}

impl<T> CheckNumericsOp<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
{
    pub fn new(inner: Rc<CheckNumerics<T>>) -> Self {
        Self{inner}
    }

    pub fn output(&self) -> Edge<T> {
        Edge::<T>::new(self.inner.clone(), 0)
    }
}

struct CheckNumericsOp<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
{
    inner: Rc<CheckNumerics<T>>,
}

impl<T> GraphOperation for CheckNumerics<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("CheckNumerics_{}")?
        };
        let mut new_op = graph.new_operation("CheckNumerics", &op_name)?;
        {
            (|attr| {new_op.set_attr_string("message", attr)})(&self.message)
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct CheckNumerics<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
{
    tensor: Edge<T>,
    message: String,
    id_: usize,
}

impl<T> CheckNumerics<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
{
    pub fn finish(self) -> CheckNumericsOp<T> {
        CheckNumericsOp::new(Rc::new(self))
    }

    pub fn new(tensor: Edge<T>, message: &str) -> Self {
        Self {
            tensor,
            message: message.to_string()
            id_: new_id(),
        }
    }
}

impl<T, Taxis, out_idx> UniqueWithCountsV2Op<T, Taxis, out_idx>
where T: con,
      Taxis: con_or_DT_INT32_or_DT_INT64,
      out_idx: con_or_DT_INT32_or_DT_INT64,
{
    pub fn new(inner: Rc<UniqueWithCountsV2<T, Taxis, out_idx>>) -> Self {
        Self{inner}
    }

    pub fn y(&self) -> Edge<T> {
        Edge::<T>::new(self.inner.clone(), 0)
    }

    pub fn idx(&self) -> Edge<out_idx> {
        Edge::<out_idx>::new(self.inner.clone(), 1)
    }

    pub fn count(&self) -> Edge<out_idx> {
        Edge::<out_idx>::new(self.inner.clone(), 2)
    }
}

struct UniqueWithCountsV2Op<T, Taxis, out_idx>
where T: con,
      Taxis: con_or_DT_INT32_or_DT_INT64,
      out_idx: con_or_DT_INT32_or_DT_INT64,
{
    inner: Rc<UniqueWithCountsV2<T, Taxis, out_idx>>,
}

impl<T, Taxis, out_idx> GraphOperation for UniqueWithCountsV2<T, Taxis, out_idx>
where T: con,
      Taxis: con_or_DT_INT32_or_DT_INT64,
      out_idx: con_or_DT_INT32_or_DT_INT64,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("UniqueWithCountsV2_{}")?
        };
        let mut new_op = graph.new_operation("UniqueWithCountsV2", &op_name)?;
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct UniqueWithCountsV2<T, Taxis, out_idx>
where T: con,
      Taxis: con_or_DT_INT32_or_DT_INT64,
      out_idx: con_or_DT_INT32_or_DT_INT64,
{
    x: Edge<T>,
    axis: Edge<Taxis>,
    id_: usize,
}

impl<T, Taxis, out_idx> UniqueWithCountsV2<T, Taxis, out_idx>
where T: con,
      Taxis: con_or_DT_INT32_or_DT_INT64,
      out_idx: con_or_DT_INT32_or_DT_INT64,
{
    pub fn finish(self) -> UniqueWithCountsV2Op<T, Taxis, out_idx> {
        UniqueWithCountsV2Op::new(Rc::new(self))
    }

    pub fn new(x: Edge<T>, axis: Edge<Taxis>) -> Self {
        Self {
            x,
            axis,
            id_: new_id(),
        }
    }
}

impl LookupTableSizeOp {
    pub fn new(inner: Rc<LookupTableSize>) -> Self {
        Self{inner}
    }

    pub fn size(&self) -> Edge<i64> {
        Edge::<i64>::new(self.inner.clone(), 0)
    }
}

struct LookupTableSizeOp {
    inner: Rc<LookupTableSize>,
}

impl GraphOperation for LookupTableSize {
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("LookupTableSize_{}")?
        };
        let mut new_op = graph.new_operation("LookupTableSize", &op_name)?;
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct LookupTableSize {
    table_handle: Edge<String>,
    id_: usize,
}

impl LookupTableSize {
    pub fn finish(self) -> LookupTableSizeOp {
        LookupTableSizeOp::new(Rc::new(self))
    }

    pub fn new(table_handle: Edge<String>) -> Self {
        Self {
            table_handle,
            id_: new_id(),
        }
    }
}

impl<T> MatrixTriangularSolveOp<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_COMPLEX64_or_DT_COMPLEX128,
{
    pub fn new(inner: Rc<MatrixTriangularSolve<T>>) -> Self {
        Self{inner}
    }

    pub fn output(&self) -> Edge<T> {
        Edge::<T>::new(self.inner.clone(), 0)
    }
}

struct MatrixTriangularSolveOp<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_COMPLEX64_or_DT_COMPLEX128,
{
    inner: Rc<MatrixTriangularSolve<T>>,
}

impl<T> GraphOperation for MatrixTriangularSolve<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_COMPLEX64_or_DT_COMPLEX128,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("MatrixTriangularSolve_{}")?
        };
        let mut new_op = graph.new_operation("MatrixTriangularSolve", &op_name)?;
        {
            match self.lower {
            }
            None => new_op.set_attr_value_proto("lower", &vec![40_u8, 1_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_bool("lower", *attr)})(&value),
        };
        {
            match self.adjoint {
            }
            None => new_op.set_attr_value_proto("adjoint", &vec![40_u8, 0_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_bool("adjoint", *attr)})(&value),
        };
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct MatrixTriangularSolve<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_COMPLEX64_or_DT_COMPLEX128,
{
    matrix: Edge<T>,
    rhs: Edge<T>,
    lower: Option<bool>,
    adjoint: Option<bool>,
    id_: usize,
}

impl<T> MatrixTriangularSolve<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_COMPLEX64_or_DT_COMPLEX128,
{
    pub fn lower(&mut self, lower: bool) -> &mut Self {
        self.lower = Some(lower);
        &self
    }

    pub fn adjoint(&mut self, adjoint: bool) -> &mut Self {
        self.adjoint = Some(adjoint);
        &self
    }

    pub fn finish(self) -> MatrixTriangularSolveOp<T> {
        MatrixTriangularSolveOp::new(Rc::new(self))
    }

    pub fn new(matrix: Edge<T>, rhs: Edge<T>) -> Self {
        Self {
            matrix,
            rhs,
            lower: None,
            adjoint: None,
            id_: new_id(),
        }
    }
}

impl QueueCloseOp {
    pub fn new(inner: Rc<QueueClose>) -> Self {
        Self{inner}
    }
}

struct QueueCloseOp {
    inner: Rc<QueueClose>,
}

impl GraphOperation for QueueClose {
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("QueueClose_{}")?
        };
        let mut new_op = graph.new_operation("QueueClose", &op_name)?;
        {
            match self.cancel_pending_enqueues {
            }
            None => new_op.set_attr_value_proto("cancel_pending_enqueues", &vec![40_u8, 0_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_bool("cancel_pending_enqueues", *attr)})(&value),
        };
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct QueueClose {
    handle: Edge<String>,
    cancel_pending_enqueues: Option<bool>,
    id_: usize,
}

impl QueueClose {
    pub fn cancel_pending_enqueues(&mut self, cancel_pending_enqueues: bool) -> &mut Self {
        self.cancel_pending_enqueues = Some(cancel_pending_enqueues);
        &self
    }

    pub fn finish(self) -> QueueCloseOp {
        QueueCloseOp::new(Rc::new(self))
    }

    pub fn new(handle: Edge<String>) -> Self {
        Self {
            handle,
            cancel_pending_enqueues: None,
            id_: new_id(),
        }
    }
}

impl<T> CropAndResizeGradImageOp<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_HALF,
{
    pub fn new(inner: Rc<CropAndResizeGradImage<T>>) -> Self {
        Self{inner}
    }

    pub fn output(&self) -> Edge<T> {
        Edge::<T>::new(self.inner.clone(), 0)
    }
}

struct CropAndResizeGradImageOp<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_HALF,
{
    inner: Rc<CropAndResizeGradImage<T>>,
}

impl<T> GraphOperation for CropAndResizeGradImage<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_HALF,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("CropAndResizeGradImage_{}")?
        };
        let mut new_op = graph.new_operation("CropAndResizeGradImage", &op_name)?;
        {
            match self.method {
            }
            None => new_op.set_attr_value_proto("method", &vec![18_u8, 8_u8, 98_u8, 105_u8, 108_u8, 105_u8, 110_u8, 101_u8, 97_u8, 114_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_string("method", attr)})(&value),
        };
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct CropAndResizeGradImage<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_HALF,
{
    grads: Edge<f32>,
    boxes: Edge<f32>,
    box_ind: Edge<i32>,
    image_size: Edge<i32>,
    method: Option<String>,
    id_: usize,
}

impl<T> CropAndResizeGradImage<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_HALF,
{
    pub fn method(&mut self, method: &str) -> &mut Self {
        self.method = Some(method.to_string());
        &self
    }

    pub fn finish(self) -> CropAndResizeGradImageOp<T> {
        CropAndResizeGradImageOp::new(Rc::new(self))
    }

    pub fn new(grads: Edge<f32>, boxes: Edge<f32>, box_ind: Edge<i32>, image_size: Edge<i32>) -> Self {
        Self {
            grads,
            boxes,
            box_ind,
            image_size,
            method: None,
            id_: new_id(),
        }
    }
}

impl<T, Tindices> SegmentSumOp<T, Tindices>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      Tindices: con_or_DT_INT32_or_DT_INT64,
{
    pub fn new(inner: Rc<SegmentSum<T, Tindices>>) -> Self {
        Self{inner}
    }

    pub fn output(&self) -> Edge<T> {
        Edge::<T>::new(self.inner.clone(), 0)
    }
}

struct SegmentSumOp<T, Tindices>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      Tindices: con_or_DT_INT32_or_DT_INT64,
{
    inner: Rc<SegmentSum<T, Tindices>>,
}

impl<T, Tindices> GraphOperation for SegmentSum<T, Tindices>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      Tindices: con_or_DT_INT32_or_DT_INT64,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("SegmentSum_{}")?
        };
        let mut new_op = graph.new_operation("SegmentSum", &op_name)?;
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct SegmentSum<T, Tindices>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      Tindices: con_or_DT_INT32_or_DT_INT64,
{
    data: Edge<T>,
    segment_ids: Edge<Tindices>,
    id_: usize,
}

impl<T, Tindices> SegmentSum<T, Tindices>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      Tindices: con_or_DT_INT32_or_DT_INT64,
{
    pub fn finish(self) -> SegmentSumOp<T, Tindices> {
        SegmentSumOp::new(Rc::new(self))
    }

    pub fn new(data: Edge<T>, segment_ids: Edge<Tindices>) -> Self {
        Self {
            data,
            segment_ids,
            id_: new_id(),
        }
    }
}

impl<T> BatchMatrixTriangularSolveOp<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE,
{
    pub fn new(inner: Rc<BatchMatrixTriangularSolve<T>>) -> Self {
        Self{inner}
    }

    pub fn output(&self) -> Edge<T> {
        Edge::<T>::new(self.inner.clone(), 0)
    }
}

struct BatchMatrixTriangularSolveOp<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE,
{
    inner: Rc<BatchMatrixTriangularSolve<T>>,
}

impl<T> GraphOperation for BatchMatrixTriangularSolve<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("BatchMatrixTriangularSolve_{}")?
        };
        let mut new_op = graph.new_operation("BatchMatrixTriangularSolve", &op_name)?;
        {
            match self.lower {
            }
            None => new_op.set_attr_value_proto("lower", &vec![40_u8, 1_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_bool("lower", *attr)})(&value),
        };
        {
            match self.adjoint {
            }
            None => new_op.set_attr_value_proto("adjoint", &vec![40_u8, 0_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_bool("adjoint", *attr)})(&value),
        };
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct BatchMatrixTriangularSolve<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE,
{
    matrix: Edge<T>,
    rhs: Edge<T>,
    lower: Option<bool>,
    adjoint: Option<bool>,
    id_: usize,
}

impl<T> BatchMatrixTriangularSolve<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE,
{
    pub fn lower(&mut self, lower: bool) -> &mut Self {
        self.lower = Some(lower);
        &self
    }

    pub fn adjoint(&mut self, adjoint: bool) -> &mut Self {
        self.adjoint = Some(adjoint);
        &self
    }

    pub fn finish(self) -> BatchMatrixTriangularSolveOp<T> {
        BatchMatrixTriangularSolveOp::new(Rc::new(self))
    }

    pub fn new(matrix: Edge<T>, rhs: Edge<T>) -> Self {
        Self {
            matrix,
            rhs,
            lower: None,
            adjoint: None,
            id_: new_id(),
        }
    }
}

impl ExtractGlimpseOp {
    pub fn new(inner: Rc<ExtractGlimpse>) -> Self {
        Self{inner}
    }

    pub fn glimpse(&self) -> Edge<f32> {
        Edge::<f32>::new(self.inner.clone(), 0)
    }
}

struct ExtractGlimpseOp {
    inner: Rc<ExtractGlimpse>,
}

impl GraphOperation for ExtractGlimpse {
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("ExtractGlimpse_{}")?
        };
        let mut new_op = graph.new_operation("ExtractGlimpse", &op_name)?;
        {
            match self.centered {
            }
            None => new_op.set_attr_value_proto("centered", &vec![40_u8, 1_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_bool("centered", *attr)})(&value),
        };
        {
            match self.normalized {
            }
            None => new_op.set_attr_value_proto("normalized", &vec![40_u8, 1_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_bool("normalized", *attr)})(&value),
        };
        {
            match self.uniform_noise {
            }
            None => new_op.set_attr_value_proto("uniform_noise", &vec![40_u8, 1_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_bool("uniform_noise", *attr)})(&value),
        };
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct ExtractGlimpse {
    input: Edge<f32>,
    size: Edge<i32>,
    offsets: Edge<f32>,
    centered: Option<bool>,
    normalized: Option<bool>,
    uniform_noise: Option<bool>,
    id_: usize,
}

impl ExtractGlimpse {
    pub fn centered(&mut self, centered: bool) -> &mut Self {
        self.centered = Some(centered);
        &self
    }

    pub fn normalized(&mut self, normalized: bool) -> &mut Self {
        self.normalized = Some(normalized);
        &self
    }

    pub fn uniform_noise(&mut self, uniform_noise: bool) -> &mut Self {
        self.uniform_noise = Some(uniform_noise);
        &self
    }

    pub fn finish(self) -> ExtractGlimpseOp {
        ExtractGlimpseOp::new(Rc::new(self))
    }

    pub fn new(input: Edge<f32>, size: Edge<i32>, offsets: Edge<f32>) -> Self {
        Self {
            input,
            size,
            offsets,
            centered: None,
            normalized: None,
            uniform_noise: None,
            id_: new_id(),
        }
    }
}

impl<T, Tindices> XlaBroadcastHelperOp<T, Tindices>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      Tindices: con_or_DT_INT32_or_DT_INT64,
{
    pub fn new(inner: Rc<XlaBroadcastHelper<T, Tindices>>) -> Self {
        Self{inner}
    }

    pub fn lhs_output(&self) -> Edge<T> {
        Edge::<T>::new(self.inner.clone(), 0)
    }

    pub fn rhs_output(&self) -> Edge<T> {
        Edge::<T>::new(self.inner.clone(), 1)
    }
}

struct XlaBroadcastHelperOp<T, Tindices>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      Tindices: con_or_DT_INT32_or_DT_INT64,
{
    inner: Rc<XlaBroadcastHelper<T, Tindices>>,
}

impl<T, Tindices> GraphOperation for XlaBroadcastHelper<T, Tindices>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      Tindices: con_or_DT_INT32_or_DT_INT64,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("XlaBroadcastHelper_{}")?
        };
        let mut new_op = graph.new_operation("XlaBroadcastHelper", &op_name)?;
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct XlaBroadcastHelper<T, Tindices>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      Tindices: con_or_DT_INT32_or_DT_INT64,
{
    lhs: Edge<T>,
    rhs: Edge<T>,
    broadcast_dims: Edge<Tindices>,
    id_: usize,
}

impl<T, Tindices> XlaBroadcastHelper<T, Tindices>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      Tindices: con_or_DT_INT32_or_DT_INT64,
{
    pub fn finish(self) -> XlaBroadcastHelperOp<T, Tindices> {
        XlaBroadcastHelperOp::new(Rc::new(self))
    }

    pub fn new(lhs: Edge<T>, rhs: Edge<T>, broadcast_dims: Edge<Tindices>) -> Self {
        Self {
            lhs,
            rhs,
            broadcast_dims,
            id_: new_id(),
        }
    }
}

impl<T> InvGradOp<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_COMPLEX64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF,
{
    pub fn new(inner: Rc<InvGrad<T>>) -> Self {
        Self{inner}
    }

    pub fn z(&self) -> Edge<T> {
        Edge::<T>::new(self.inner.clone(), 0)
    }
}

struct InvGradOp<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_COMPLEX64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF,
{
    inner: Rc<InvGrad<T>>,
}

impl<T> GraphOperation for InvGrad<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_COMPLEX64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("InvGrad_{}")?
        };
        let mut new_op = graph.new_operation("InvGrad", &op_name)?;
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct InvGrad<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_COMPLEX64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF,
{
    y: Edge<T>,
    dy: Edge<T>,
    id_: usize,
}

impl<T> InvGrad<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_COMPLEX64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF,
{
    pub fn finish(self) -> InvGradOp<T> {
        InvGradOp::new(Rc::new(self))
    }

    pub fn new(y: Edge<T>, dy: Edge<T>) -> Self {
        Self {
            y,
            dy,
            id_: new_id(),
        }
    }
}

impl<component_types> RandomShuffleQueueOp<component_types>
where component_types: con,
{
    pub fn new(inner: Rc<RandomShuffleQueue<component_types>>) -> Self {
        Self{inner}
    }

    pub fn handle(&self) -> Edge<String> {
        Edge::<String>::new(self.inner.clone(), 0)
    }
}

struct RandomShuffleQueueOp<component_types>
where component_types: con,
{
    inner: Rc<RandomShuffleQueue<component_types>>,
}

impl<component_types> GraphOperation for RandomShuffleQueue<component_types>
where component_types: con,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("RandomShuffleQueue_{}")?
        };
        let mut new_op = graph.new_operation("RandomShuffleQueue", &op_name)?;
        {
            match self.shapes {
            }
            None => new_op.set_attr_value_proto("shapes", &vec![10_u8, 0_u8,]);,
            Some(value) => (|attrs| {new_op.set_attr_shape_list("shapes", attrs)})(&value),
        };
        {
            match self.capacity {
            }
            None => new_op.set_attr_value_proto("capacity", &vec![24_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 1_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_int("capacity", *attr)})(&value),
        };
        {
            match self.min_after_dequeue {
            }
            None => new_op.set_attr_value_proto("min_after_dequeue", &vec![24_u8, 0_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_int("min_after_dequeue", *attr)})(&value),
        };
        {
            match self.seed {
            }
            None => new_op.set_attr_value_proto("seed", &vec![24_u8, 0_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_int("seed", *attr)})(&value),
        };
        {
            match self.seed2 {
            }
            None => new_op.set_attr_value_proto("seed2", &vec![24_u8, 0_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_int("seed2", *attr)})(&value),
        };
        {
            match self.container {
            }
            None => new_op.set_attr_value_proto("container", &vec![18_u8, 0_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_string("container", attr)})(&value),
        };
        {
            match self.shared_name {
            }
            None => new_op.set_attr_value_proto("shared_name", &vec![18_u8, 0_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_string("shared_name", attr)})(&value),
        };
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct RandomShuffleQueue<component_types>
where component_types: con,
{
    shapes: Option<Vec<Shape>>,
    capacity: Option<i64>,
    min_after_dequeue: Option<i64>,
    seed: Option<i64>,
    seed2: Option<i64>,
    container: Option<String>,
    shared_name: Option<String>,
    id_: usize,
}

impl<component_types> RandomShuffleQueue<component_types>
where component_types: con,
{
    pub fn shapes(&mut self, shapes: &[Shape]) -> &mut Self {
        self.shapes = Some(shapes.to_vec());
        &self
    }

    pub fn capacity(&mut self, capacity: int) -> &mut Self {
        self.capacity = Some(capacity);
        &self
    }

    pub fn min_after_dequeue(&mut self, min_after_dequeue: int) -> &mut Self {
        self.min_after_dequeue = Some(min_after_dequeue);
        &self
    }

    pub fn seed(&mut self, seed: int) -> &mut Self {
        self.seed = Some(seed);
        &self
    }

    pub fn seed2(&mut self, seed2: int) -> &mut Self {
        self.seed2 = Some(seed2);
        &self
    }

    pub fn container(&mut self, container: &str) -> &mut Self {
        self.container = Some(container.to_string());
        &self
    }

    pub fn shared_name(&mut self, shared_name: &str) -> &mut Self {
        self.shared_name = Some(shared_name.to_string());
        &self
    }

    pub fn finish(self) -> RandomShuffleQueueOp<component_types> {
        RandomShuffleQueueOp::new(Rc::new(self))
    }

    pub fn new() -> Self {
        Self {
            shapes: None,
            capacity: None,
            min_after_dequeue: None,
            seed: None,
            seed2: None,
            container: None,
            shared_name: None,
            id_: new_id(),
        }
    }
}

impl LoadTPUEmbeddingMDLAdagradLightParametersOp {
    pub fn new(inner: Rc<LoadTPUEmbeddingMDLAdagradLightParameters>) -> Self {
        Self{inner}
    }
}

struct LoadTPUEmbeddingMDLAdagradLightParametersOp {
    inner: Rc<LoadTPUEmbeddingMDLAdagradLightParameters>,
}

impl GraphOperation for LoadTPUEmbeddingMDLAdagradLightParameters {
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("LoadTPUEmbeddingMDLAdagradLightParameters_{}")?
        };
        let mut new_op = graph.new_operation("LoadTPUEmbeddingMDLAdagradLightParameters", &op_name)?;
        {
            match self.table_id {
            }
            None => new_op.set_attr_value_proto("table_id", &vec![24_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 1_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_int("table_id", *attr)})(&value),
        };
        {
            match self.table_name {
            }
            None => new_op.set_attr_value_proto("table_name", &vec![18_u8, 0_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_string("table_name", attr)})(&value),
        };
        {
            (|attr| {new_op.set_attr_int("num_shards", *attr)})(&self.num_shards)
        }
        {
            (|attr| {new_op.set_attr_int("shard_id", *attr)})(&self.shard_id)
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct LoadTPUEmbeddingMDLAdagradLightParameters {
    parameters: Edge<f32>,
    accumulators: Edge<f32>,
    weights: Edge<f32>,
    benefits: Edge<f32>,
    table_id: Option<i64>,
    table_name: Option<String>,
    num_shards: i64,
    shard_id: i64,
    id_: usize,
}

impl LoadTPUEmbeddingMDLAdagradLightParameters {
    pub fn table_id(&mut self, table_id: int) -> &mut Self {
        self.table_id = Some(table_id);
        &self
    }

    pub fn table_name(&mut self, table_name: &str) -> &mut Self {
        self.table_name = Some(table_name.to_string());
        &self
    }

    pub fn finish(self) -> LoadTPUEmbeddingMDLAdagradLightParametersOp {
        LoadTPUEmbeddingMDLAdagradLightParametersOp::new(Rc::new(self))
    }

    pub fn new(parameters: Edge<f32>, accumulators: Edge<f32>, weights: Edge<f32>, benefits: Edge<f32>, num_shards: int, shard_id: int) -> Self {
        Self {
            parameters,
            accumulators,
            weights,
            benefits,
            table_id: None,
            table_name: None,
            num_shards: num_shards
            shard_id: shard_id
            id_: new_id(),
        }
    }
}

pub trait con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT8_or_DT_HALF {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT8_or_DT_HALF for f32 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT8_or_DT_HALF for f64 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT8_or_DT_HALF for i32 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT8_or_DT_HALF for i8 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT8_or_DT_HALF for u8 {
}

impl<T> ResizeNearestNeighborGradOp<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT8_or_DT_HALF,
{
    pub fn new(inner: Rc<ResizeNearestNeighborGrad<T>>) -> Self {
        Self{inner}
    }

    pub fn output(&self) -> Edge<T> {
        Edge::<T>::new(self.inner.clone(), 0)
    }
}

struct ResizeNearestNeighborGradOp<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT8_or_DT_HALF,
{
    inner: Rc<ResizeNearestNeighborGrad<T>>,
}

impl<T> GraphOperation for ResizeNearestNeighborGrad<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT8_or_DT_HALF,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("ResizeNearestNeighborGrad_{}")?
        };
        let mut new_op = graph.new_operation("ResizeNearestNeighborGrad", &op_name)?;
        {
            match self.align_corners {
            }
            None => new_op.set_attr_value_proto("align_corners", &vec![40_u8, 0_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_bool("align_corners", *attr)})(&value),
        };
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct ResizeNearestNeighborGrad<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT8_or_DT_HALF,
{
    grads: Edge<T>,
    size: Edge<i32>,
    align_corners: Option<bool>,
    id_: usize,
}

impl<T> ResizeNearestNeighborGrad<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT8_or_DT_HALF,
{
    pub fn align_corners(&mut self, align_corners: bool) -> &mut Self {
        self.align_corners = Some(align_corners);
        &self
    }

    pub fn finish(self) -> ResizeNearestNeighborGradOp<T> {
        ResizeNearestNeighborGradOp::new(Rc::new(self))
    }

    pub fn new(grads: Edge<T>, size: Edge<i32>) -> Self {
        Self {
            grads,
            size,
            align_corners: None,
            id_: new_id(),
        }
    }
}

impl RetrieveTPUEmbeddingMomentumParametersGradAccumDebugOp {
    pub fn new(inner: Rc<RetrieveTPUEmbeddingMomentumParametersGradAccumDebug>) -> Self {
        Self{inner}
    }

    pub fn parameters(&self) -> Edge<f32> {
        Edge::<f32>::new(self.inner.clone(), 0)
    }

    pub fn momenta(&self) -> Edge<f32> {
        Edge::<f32>::new(self.inner.clone(), 1)
    }

    pub fn gradient_accumulators(&self) -> Edge<f32> {
        Edge::<f32>::new(self.inner.clone(), 2)
    }
}

struct RetrieveTPUEmbeddingMomentumParametersGradAccumDebugOp {
    inner: Rc<RetrieveTPUEmbeddingMomentumParametersGradAccumDebug>,
}

impl GraphOperation for RetrieveTPUEmbeddingMomentumParametersGradAccumDebug {
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("RetrieveTPUEmbeddingMomentumParametersGradAccumDebug_{}")?
        };
        let mut new_op = graph.new_operation("RetrieveTPUEmbeddingMomentumParametersGradAccumDebug", &op_name)?;
        {
            match self.table_id {
            }
            None => new_op.set_attr_value_proto("table_id", &vec![24_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 1_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_int("table_id", *attr)})(&value),
        };
        {
            match self.table_name {
            }
            None => new_op.set_attr_value_proto("table_name", &vec![18_u8, 0_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_string("table_name", attr)})(&value),
        };
        {
            (|attr| {new_op.set_attr_int("num_shards", *attr)})(&self.num_shards)
        }
        {
            (|attr| {new_op.set_attr_int("shard_id", *attr)})(&self.shard_id)
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct RetrieveTPUEmbeddingMomentumParametersGradAccumDebug {
    table_id: Option<i64>,
    table_name: Option<String>,
    num_shards: i64,
    shard_id: i64,
    id_: usize,
}

impl RetrieveTPUEmbeddingMomentumParametersGradAccumDebug {
    pub fn table_id(&mut self, table_id: int) -> &mut Self {
        self.table_id = Some(table_id);
        &self
    }

    pub fn table_name(&mut self, table_name: &str) -> &mut Self {
        self.table_name = Some(table_name.to_string());
        &self
    }

    pub fn finish(self) -> RetrieveTPUEmbeddingMomentumParametersGradAccumDebugOp {
        RetrieveTPUEmbeddingMomentumParametersGradAccumDebugOp::new(Rc::new(self))
    }

    pub fn new(num_shards: int, shard_id: int) -> Self {
        Self {
            table_id: None,
            table_name: None,
            num_shards: num_shards
            shard_id: shard_id
            id_: new_id(),
        }
    }
}

impl<T> IsNanOp<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
{
    pub fn new(inner: Rc<IsNan<T>>) -> Self {
        Self{inner}
    }

    pub fn y(&self) -> Edge<bool> {
        Edge::<bool>::new(self.inner.clone(), 0)
    }
}

struct IsNanOp<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
{
    inner: Rc<IsNan<T>>,
}

impl<T> GraphOperation for IsNan<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("IsNan_{}")?
        };
        let mut new_op = graph.new_operation("IsNan", &op_name)?;
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct IsNan<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
{
    x: Edge<T>,
    id_: usize,
}

impl<T> IsNan<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
{
    pub fn finish(self) -> IsNanOp<T> {
        IsNanOp::new(Rc::new(self))
    }

    pub fn new(x: Edge<T>) -> Self {
        Self {
            x,
            id_: new_id(),
        }
    }
}

impl AdjustSaturationOp {
    pub fn new(inner: Rc<AdjustSaturation>) -> Self {
        Self{inner}
    }

    pub fn output(&self) -> Edge<f32> {
        Edge::<f32>::new(self.inner.clone(), 0)
    }
}

struct AdjustSaturationOp {
    inner: Rc<AdjustSaturation>,
}

impl GraphOperation for AdjustSaturation {
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("AdjustSaturation_{}")?
        };
        let mut new_op = graph.new_operation("AdjustSaturation", &op_name)?;
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct AdjustSaturation {
    images: Edge<f32>,
    scale: Edge<f32>,
    id_: usize,
}

impl AdjustSaturation {
    pub fn finish(self) -> AdjustSaturationOp {
        AdjustSaturationOp::new(Rc::new(self))
    }

    pub fn new(images: Edge<f32>, scale: Edge<f32>) -> Self {
        Self {
            images,
            scale,
            id_: new_id(),
        }
    }
}

impl<T> SoftplusGradOp<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
{
    pub fn new(inner: Rc<SoftplusGrad<T>>) -> Self {
        Self{inner}
    }

    pub fn backprops(&self) -> Edge<T> {
        Edge::<T>::new(self.inner.clone(), 0)
    }
}

struct SoftplusGradOp<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
{
    inner: Rc<SoftplusGrad<T>>,
}

impl<T> GraphOperation for SoftplusGrad<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("SoftplusGrad_{}")?
        };
        let mut new_op = graph.new_operation("SoftplusGrad", &op_name)?;
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct SoftplusGrad<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
{
    gradients: Edge<T>,
    features: Edge<T>,
    id_: usize,
}

impl<T> SoftplusGrad<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
{
    pub fn finish(self) -> SoftplusGradOp<T> {
        SoftplusGradOp::new(Rc::new(self))
    }

    pub fn new(gradients: Edge<T>, features: Edge<T>) -> Self {
        Self {
            gradients,
            features,
            id_: new_id(),
        }
    }
}

impl<T> SelfAdjointEigV2Op<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_COMPLEX64_or_DT_COMPLEX128,
{
    pub fn new(inner: Rc<SelfAdjointEigV2<T>>) -> Self {
        Self{inner}
    }

    pub fn e(&self) -> Edge<T> {
        Edge::<T>::new(self.inner.clone(), 0)
    }

    pub fn v(&self) -> Edge<T> {
        Edge::<T>::new(self.inner.clone(), 1)
    }
}

struct SelfAdjointEigV2Op<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_COMPLEX64_or_DT_COMPLEX128,
{
    inner: Rc<SelfAdjointEigV2<T>>,
}

impl<T> GraphOperation for SelfAdjointEigV2<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_COMPLEX64_or_DT_COMPLEX128,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("SelfAdjointEigV2_{}")?
        };
        let mut new_op = graph.new_operation("SelfAdjointEigV2", &op_name)?;
        {
            match self.compute_v {
            }
            None => new_op.set_attr_value_proto("compute_v", &vec![40_u8, 1_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_bool("compute_v", *attr)})(&value),
        };
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct SelfAdjointEigV2<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_COMPLEX64_or_DT_COMPLEX128,
{
    input: Edge<T>,
    compute_v: Option<bool>,
    id_: usize,
}

impl<T> SelfAdjointEigV2<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_COMPLEX64_or_DT_COMPLEX128,
{
    pub fn compute_v(&mut self, compute_v: bool) -> &mut Self {
        self.compute_v = Some(compute_v);
        &self
    }

    pub fn finish(self) -> SelfAdjointEigV2Op<T> {
        SelfAdjointEigV2Op::new(Rc::new(self))
    }

    pub fn new(input: Edge<T>) -> Self {
        Self {
            input,
            compute_v: None,
            id_: new_id(),
        }
    }
}

impl<Tcomplex> FFTOp<Tcomplex>
where Tcomplex: con_or_DT_COMPLEX64_or_DT_COMPLEX128,
{
    pub fn new(inner: Rc<FFT<Tcomplex>>) -> Self {
        Self{inner}
    }

    pub fn output(&self) -> Edge<Tcomplex> {
        Edge::<Tcomplex>::new(self.inner.clone(), 0)
    }
}

struct FFTOp<Tcomplex>
where Tcomplex: con_or_DT_COMPLEX64_or_DT_COMPLEX128,
{
    inner: Rc<FFT<Tcomplex>>,
}

impl<Tcomplex> GraphOperation for FFT<Tcomplex>
where Tcomplex: con_or_DT_COMPLEX64_or_DT_COMPLEX128,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("FFT_{}")?
        };
        let mut new_op = graph.new_operation("FFT", &op_name)?;
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct FFT<Tcomplex>
where Tcomplex: con_or_DT_COMPLEX64_or_DT_COMPLEX128,
{
    input: Edge<Tcomplex>,
    id_: usize,
}

impl<Tcomplex> FFT<Tcomplex>
where Tcomplex: con_or_DT_COMPLEX64_or_DT_COMPLEX128,
{
    pub fn finish(self) -> FFTOp<Tcomplex> {
        FFTOp::new(Rc::new(self))
    }

    pub fn new(input: Edge<Tcomplex>) -> Self {
        Self {
            input,
            id_: new_id(),
        }
    }
}

impl<T, Tindex> MatrixBandPartOp<T, Tindex>
where T: con,
      Tindex: con_or_DT_INT32_or_DT_INT64,
{
    pub fn new(inner: Rc<MatrixBandPart<T, Tindex>>) -> Self {
        Self{inner}
    }

    pub fn band(&self) -> Edge<T> {
        Edge::<T>::new(self.inner.clone(), 0)
    }
}

struct MatrixBandPartOp<T, Tindex>
where T: con,
      Tindex: con_or_DT_INT32_or_DT_INT64,
{
    inner: Rc<MatrixBandPart<T, Tindex>>,
}

impl<T, Tindex> GraphOperation for MatrixBandPart<T, Tindex>
where T: con,
      Tindex: con_or_DT_INT32_or_DT_INT64,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("MatrixBandPart_{}")?
        };
        let mut new_op = graph.new_operation("MatrixBandPart", &op_name)?;
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct MatrixBandPart<T, Tindex>
where T: con,
      Tindex: con_or_DT_INT32_or_DT_INT64,
{
    input: Edge<T>,
    num_lower: Edge<Tindex>,
    num_upper: Edge<Tindex>,
    id_: usize,
}

impl<T, Tindex> MatrixBandPart<T, Tindex>
where T: con,
      Tindex: con_or_DT_INT32_or_DT_INT64,
{
    pub fn finish(self) -> MatrixBandPartOp<T, Tindex> {
        MatrixBandPartOp::new(Rc::new(self))
    }

    pub fn new(input: Edge<T>, num_lower: Edge<Tindex>, num_upper: Edge<Tindex>) -> Self {
        Self {
            input,
            num_lower,
            num_upper,
            id_: new_id(),
        }
    }
}

impl<T, Tindices> TensorScatterAddOp<T, Tindices>
where T: con,
      Tindices: con_or_DT_INT32_or_DT_INT64,
{
    pub fn new(inner: Rc<TensorScatterAdd<T, Tindices>>) -> Self {
        Self{inner}
    }

    pub fn output(&self) -> Edge<T> {
        Edge::<T>::new(self.inner.clone(), 0)
    }
}

struct TensorScatterAddOp<T, Tindices>
where T: con,
      Tindices: con_or_DT_INT32_or_DT_INT64,
{
    inner: Rc<TensorScatterAdd<T, Tindices>>,
}

impl<T, Tindices> GraphOperation for TensorScatterAdd<T, Tindices>
where T: con,
      Tindices: con_or_DT_INT32_or_DT_INT64,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("TensorScatterAdd_{}")?
        };
        let mut new_op = graph.new_operation("TensorScatterAdd", &op_name)?;
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct TensorScatterAdd<T, Tindices>
where T: con,
      Tindices: con_or_DT_INT32_or_DT_INT64,
{
    tensor: Edge<T>,
    indices: Edge<Tindices>,
    updates: Edge<T>,
    id_: usize,
}

impl<T, Tindices> TensorScatterAdd<T, Tindices>
where T: con,
      Tindices: con_or_DT_INT32_or_DT_INT64,
{
    pub fn finish(self) -> TensorScatterAddOp<T, Tindices> {
        TensorScatterAddOp::new(Rc::new(self))
    }

    pub fn new(tensor: Edge<T>, indices: Edge<Tindices>, updates: Edge<T>) -> Self {
        Self {
            tensor,
            indices,
            updates,
            id_: new_id(),
        }
    }
}

impl<T> LogMatrixDeterminantOp<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_COMPLEX64_or_DT_COMPLEX128,
{
    pub fn new(inner: Rc<LogMatrixDeterminant<T>>) -> Self {
        Self{inner}
    }

    pub fn sign(&self) -> Edge<T> {
        Edge::<T>::new(self.inner.clone(), 0)
    }

    pub fn log_abs_determinant(&self) -> Edge<T> {
        Edge::<T>::new(self.inner.clone(), 1)
    }
}

struct LogMatrixDeterminantOp<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_COMPLEX64_or_DT_COMPLEX128,
{
    inner: Rc<LogMatrixDeterminant<T>>,
}

impl<T> GraphOperation for LogMatrixDeterminant<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_COMPLEX64_or_DT_COMPLEX128,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("LogMatrixDeterminant_{}")?
        };
        let mut new_op = graph.new_operation("LogMatrixDeterminant", &op_name)?;
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct LogMatrixDeterminant<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_COMPLEX64_or_DT_COMPLEX128,
{
    input: Edge<T>,
    id_: usize,
}

impl<T> LogMatrixDeterminant<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_COMPLEX64_or_DT_COMPLEX128,
{
    pub fn finish(self) -> LogMatrixDeterminantOp<T> {
        LogMatrixDeterminantOp::new(Rc::new(self))
    }

    pub fn new(input: Edge<T>) -> Self {
        Self {
            input,
            id_: new_id(),
        }
    }
}

pub trait con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF for BFloat16 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF for OtherComplex<f32> {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF for OtherComplex<f64> {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF for f32 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF for f64 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF for i16 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF for i32 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF for i64 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF for i8 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF for u8 {
}

impl<T> AddV2Op<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF,
{
    pub fn new(inner: Rc<AddV2<T>>) -> Self {
        Self{inner}
    }

    pub fn z(&self) -> Edge<T> {
        Edge::<T>::new(self.inner.clone(), 0)
    }
}

struct AddV2Op<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF,
{
    inner: Rc<AddV2<T>>,
}

impl<T> GraphOperation for AddV2<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("AddV2_{}")?
        };
        let mut new_op = graph.new_operation("AddV2", &op_name)?;
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct AddV2<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF,
{
    x: Edge<T>,
    y: Edge<T>,
    id_: usize,
}

impl<T> AddV2<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF,
{
    pub fn finish(self) -> AddV2Op<T> {
        AddV2Op::new(Rc::new(self))
    }

    pub fn new(x: Edge<T>, y: Edge<T>) -> Self {
        Self {
            x,
            y,
            id_: new_id(),
        }
    }
}

impl<T> TensorSummaryOp<T>
where T: con,
{
    pub fn new(inner: Rc<TensorSummary<T>>) -> Self {
        Self{inner}
    }

    pub fn summary(&self) -> Edge<String> {
        Edge::<String>::new(self.inner.clone(), 0)
    }
}

struct TensorSummaryOp<T>
where T: con,
{
    inner: Rc<TensorSummary<T>>,
}

impl<T> GraphOperation for TensorSummary<T>
where T: con,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("TensorSummary_{}")?
        };
        let mut new_op = graph.new_operation("TensorSummary", &op_name)?;
        {
            match self.description {
            }
            None => new_op.set_attr_value_proto("description", &vec![18_u8, 0_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_string("description", attr)})(&value),
        };
        {
            match self.labels {
            }
            None => new_op.set_attr_value_proto("labels", &vec![10_u8, 0_u8,]);,
            Some(value) => (|attrs| {new_op.set_attr_string_list("labels", attrs)})(&value),
        };
        {
            match self.display_name {
            }
            None => new_op.set_attr_value_proto("display_name", &vec![18_u8, 0_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_string("display_name", attr)})(&value),
        };
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct TensorSummary<T>
where T: con,
{
    tensor: Edge<T>,
    description: Option<String>,
    labels: Option<Vec<String>>,
    display_name: Option<String>,
    id_: usize,
}

impl<T> TensorSummary<T>
where T: con,
{
    pub fn description(&mut self, description: &str) -> &mut Self {
        self.description = Some(description.to_string());
        &self
    }

    pub fn labels(&mut self, labels: &[String]) -> &mut Self {
        self.labels = Some(labels.to_vec());
        &self
    }

    pub fn display_name(&mut self, display_name: &str) -> &mut Self {
        self.display_name = Some(display_name.to_string());
        &self
    }

    pub fn finish(self) -> TensorSummaryOp<T> {
        TensorSummaryOp::new(Rc::new(self))
    }

    pub fn new(tensor: Edge<T>) -> Self {
        Self {
            tensor,
            description: None,
            labels: None,
            display_name: None,
            id_: new_id(),
        }
    }
}

impl<T, Tout> RandomUniformIntOp<T, Tout>
where Tout: con_or_DT_INT32_or_DT_INT64,
      T: con_or_DT_INT32_or_DT_INT64,
{
    pub fn new(inner: Rc<RandomUniformInt<T, Tout>>) -> Self {
        Self{inner}
    }

    pub fn output(&self) -> Edge<Tout> {
        Edge::<Tout>::new(self.inner.clone(), 0)
    }
}

struct RandomUniformIntOp<T, Tout>
where Tout: con_or_DT_INT32_or_DT_INT64,
      T: con_or_DT_INT32_or_DT_INT64,
{
    inner: Rc<RandomUniformInt<T, Tout>>,
}

impl<T, Tout> GraphOperation for RandomUniformInt<T, Tout>
where Tout: con_or_DT_INT32_or_DT_INT64,
      T: con_or_DT_INT32_or_DT_INT64,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("RandomUniformInt_{}")?
        };
        let mut new_op = graph.new_operation("RandomUniformInt", &op_name)?;
        {
            match self.seed {
            }
            None => new_op.set_attr_value_proto("seed", &vec![24_u8, 0_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_int("seed", *attr)})(&value),
        };
        {
            match self.seed2 {
            }
            None => new_op.set_attr_value_proto("seed2", &vec![24_u8, 0_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_int("seed2", *attr)})(&value),
        };
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct RandomUniformInt<T, Tout>
where Tout: con_or_DT_INT32_or_DT_INT64,
      T: con_or_DT_INT32_or_DT_INT64,
{
    shape: Edge<T>,
    minval: Edge<Tout>,
    maxval: Edge<Tout>,
    seed: Option<i64>,
    seed2: Option<i64>,
    id_: usize,
}

impl<T, Tout> RandomUniformInt<T, Tout>
where Tout: con_or_DT_INT32_or_DT_INT64,
      T: con_or_DT_INT32_or_DT_INT64,
{
    pub fn seed(&mut self, seed: int) -> &mut Self {
        self.seed = Some(seed);
        &self
    }

    pub fn seed2(&mut self, seed2: int) -> &mut Self {
        self.seed2 = Some(seed2);
        &self
    }

    pub fn finish(self) -> RandomUniformIntOp<T, Tout> {
        RandomUniformIntOp::new(Rc::new(self))
    }

    pub fn new(shape: Edge<T>, minval: Edge<Tout>, maxval: Edge<Tout>) -> Self {
        Self {
            shape,
            minval,
            maxval,
            seed: None,
            seed2: None,
            id_: new_id(),
        }
    }
}

impl<T> DataFormatDimMapOp<T>
where T: con_or_DT_INT32_or_DT_INT64,
{
    pub fn new(inner: Rc<DataFormatDimMap<T>>) -> Self {
        Self{inner}
    }

    pub fn y(&self) -> Edge<T> {
        Edge::<T>::new(self.inner.clone(), 0)
    }
}

struct DataFormatDimMapOp<T>
where T: con_or_DT_INT32_or_DT_INT64,
{
    inner: Rc<DataFormatDimMap<T>>,
}

impl<T> GraphOperation for DataFormatDimMap<T>
where T: con_or_DT_INT32_or_DT_INT64,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("DataFormatDimMap_{}")?
        };
        let mut new_op = graph.new_operation("DataFormatDimMap", &op_name)?;
        {
            match self.src_format {
            }
            None => new_op.set_attr_value_proto("src_format", &vec![18_u8, 4_u8, 78_u8, 72_u8, 87_u8, 67_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_string("src_format", attr)})(&value),
        };
        {
            match self.dst_format {
            }
            None => new_op.set_attr_value_proto("dst_format", &vec![18_u8, 4_u8, 78_u8, 67_u8, 72_u8, 87_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_string("dst_format", attr)})(&value),
        };
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct DataFormatDimMap<T>
where T: con_or_DT_INT32_or_DT_INT64,
{
    x: Edge<T>,
    src_format: Option<String>,
    dst_format: Option<String>,
    id_: usize,
}

impl<T> DataFormatDimMap<T>
where T: con_or_DT_INT32_or_DT_INT64,
{
    pub fn src_format(&mut self, src_format: &str) -> &mut Self {
        self.src_format = Some(src_format.to_string());
        &self
    }

    pub fn dst_format(&mut self, dst_format: &str) -> &mut Self {
        self.dst_format = Some(dst_format.to_string());
        &self
    }

    pub fn finish(self) -> DataFormatDimMapOp<T> {
        DataFormatDimMapOp::new(Rc::new(self))
    }

    pub fn new(x: Edge<T>) -> Self {
        Self {
            x,
            src_format: None,
            dst_format: None,
            id_: new_id(),
        }
    }
}

impl<T> BroadcastArgsOp<T>
where T: con_or_DT_INT32_or_DT_INT64,
{
    pub fn new(inner: Rc<BroadcastArgs<T>>) -> Self {
        Self{inner}
    }

    pub fn r0(&self) -> Edge<T> {
        Edge::<T>::new(self.inner.clone(), 0)
    }
}

struct BroadcastArgsOp<T>
where T: con_or_DT_INT32_or_DT_INT64,
{
    inner: Rc<BroadcastArgs<T>>,
}

impl<T> GraphOperation for BroadcastArgs<T>
where T: con_or_DT_INT32_or_DT_INT64,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("BroadcastArgs_{}")?
        };
        let mut new_op = graph.new_operation("BroadcastArgs", &op_name)?;
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct BroadcastArgs<T>
where T: con_or_DT_INT32_or_DT_INT64,
{
    s0: Edge<T>,
    s1: Edge<T>,
    id_: usize,
}

impl<T> BroadcastArgs<T>
where T: con_or_DT_INT32_or_DT_INT64,
{
    pub fn finish(self) -> BroadcastArgsOp<T> {
        BroadcastArgsOp::new(Rc::new(self))
    }

    pub fn new(s0: Edge<T>, s1: Edge<T>) -> Self {
        Self {
            s0,
            s1,
            id_: new_id(),
        }
    }
}

impl<T, Tidx> CumsumOp<T, Tidx>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      Tidx: con_or_DT_INT32_or_DT_INT64,
{
    pub fn new(inner: Rc<Cumsum<T, Tidx>>) -> Self {
        Self{inner}
    }

    pub fn out(&self) -> Edge<T> {
        Edge::<T>::new(self.inner.clone(), 0)
    }
}

struct CumsumOp<T, Tidx>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      Tidx: con_or_DT_INT32_or_DT_INT64,
{
    inner: Rc<Cumsum<T, Tidx>>,
}

impl<T, Tidx> GraphOperation for Cumsum<T, Tidx>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      Tidx: con_or_DT_INT32_or_DT_INT64,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("Cumsum_{}")?
        };
        let mut new_op = graph.new_operation("Cumsum", &op_name)?;
        {
            match self.exclusive {
            }
            None => new_op.set_attr_value_proto("exclusive", &vec![40_u8, 0_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_bool("exclusive", *attr)})(&value),
        };
        {
            match self.reverse {
            }
            None => new_op.set_attr_value_proto("reverse", &vec![40_u8, 0_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_bool("reverse", *attr)})(&value),
        };
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct Cumsum<T, Tidx>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      Tidx: con_or_DT_INT32_or_DT_INT64,
{
    x: Edge<T>,
    axis: Edge<Tidx>,
    exclusive: Option<bool>,
    reverse: Option<bool>,
    id_: usize,
}

impl<T, Tidx> Cumsum<T, Tidx>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      Tidx: con_or_DT_INT32_or_DT_INT64,
{
    pub fn exclusive(&mut self, exclusive: bool) -> &mut Self {
        self.exclusive = Some(exclusive);
        &self
    }

    pub fn reverse(&mut self, reverse: bool) -> &mut Self {
        self.reverse = Some(reverse);
        &self
    }

    pub fn finish(self) -> CumsumOp<T, Tidx> {
        CumsumOp::new(Rc::new(self))
    }

    pub fn new(x: Edge<T>, axis: Edge<Tidx>) -> Self {
        Self {
            x,
            axis,
            exclusive: None,
            reverse: None,
            id_: new_id(),
        }
    }
}

impl SdcaOptimizerOp {
    pub fn new(inner: Rc<SdcaOptimizer>) -> Self {
        Self{inner}
    }

    pub fn out_example_state_data(&self) -> Edge<f32> {
        Edge::<f32>::new(self.inner.clone(), 0)
    }

    pub fn out_delta_sparse_weights(&self) -> Edge<f32> {
        Edge::<f32>::new(self.inner.clone(), 1)
    }

    pub fn out_delta_dense_weights(&self) -> Edge<f32> {
        Edge::<f32>::new(self.inner.clone(), 2)
    }
}

struct SdcaOptimizerOp {
    inner: Rc<SdcaOptimizer>,
}

impl GraphOperation for SdcaOptimizer {
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("SdcaOptimizer_{}")?
        };
        let mut new_op = graph.new_operation("SdcaOptimizer", &op_name)?;
        {
            (|attr| {new_op.set_attr_string("loss_type", attr)})(&self.loss_type)
        }
        {
            match self.adaptative {
            }
            None => new_op.set_attr_value_proto("adaptative", &vec![40_u8, 0_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_bool("adaptative", *attr)})(&value),
        };
        {
            (|attr| {new_op.set_attr_int("num_sparse_features", *attr)})(&self.num_sparse_features)
        }
        {
            (|attr| {new_op.set_attr_int("num_sparse_features_with_values", *attr)})(&self.num_sparse_features_with_values)
        }
        {
            (|attr| {new_op.set_attr_int("num_dense_features", *attr)})(&self.num_dense_features)
        }
        {
            (|attr| {new_op.set_attr_float("l1", *attr)})(&self.l1)
        }
        {
            (|attr| {new_op.set_attr_float("l2", *attr)})(&self.l2)
        }
        {
            (|attr| {new_op.set_attr_int("num_loss_partitions", *attr)})(&self.num_loss_partitions)
        }
        {
            (|attr| {new_op.set_attr_int("num_inner_iterations", *attr)})(&self.num_inner_iterations)
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct SdcaOptimizer {
    sparse_example_indices: Edge<i64>,
    sparse_feature_indices: Edge<i64>,
    sparse_feature_values: Edge<f32>,
    dense_features: Edge<f32>,
    example_weights: Edge<f32>,
    example_labels: Edge<f32>,
    sparse_indices: Edge<i64>,
    sparse_weights: Edge<f32>,
    dense_weights: Edge<f32>,
    example_state_data: Edge<f32>,
    loss_type: String,
    adaptative: Option<bool>,
    num_sparse_features: i64,
    num_sparse_features_with_values: i64,
    num_dense_features: i64,
    l1: f32,
    l2: f32,
    num_loss_partitions: i64,
    num_inner_iterations: i64,
    id_: usize,
}

impl SdcaOptimizer {
    pub fn adaptative(&mut self, adaptative: bool) -> &mut Self {
        self.adaptative = Some(adaptative);
        &self
    }

    pub fn finish(self) -> SdcaOptimizerOp {
        SdcaOptimizerOp::new(Rc::new(self))
    }

    pub fn new(sparse_example_indices: Edge<i64>, sparse_feature_indices: Edge<i64>, sparse_feature_values: Edge<f32>, dense_features: Edge<f32>, example_weights: Edge<f32>, example_labels: Edge<f32>, sparse_indices: Edge<i64>, sparse_weights: Edge<f32>, dense_weights: Edge<f32>, example_state_data: Edge<f32>, loss_type: &str, num_sparse_features: int, num_sparse_features_with_values: int, num_dense_features: int, l1: f32, l2: f32, num_loss_partitions: int, num_inner_iterations: int) -> Self {
        Self {
            sparse_example_indices,
            sparse_feature_indices,
            sparse_feature_values,
            dense_features,
            example_weights,
            example_labels,
            sparse_indices,
            sparse_weights,
            dense_weights,
            example_state_data,
            loss_type: loss_type.to_string()
            adaptative: None,
            num_sparse_features: num_sparse_features
            num_sparse_features_with_values: num_sparse_features_with_values
            num_dense_features: num_dense_features
            l1: l1
            l2: l2
            num_loss_partitions: num_loss_partitions
            num_inner_iterations: num_inner_iterations
            id_: new_id(),
        }
    }
}

impl<T, Tindices> ScatterAddOp<T, Tindices>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      Tindices: con_or_DT_INT32_or_DT_INT64,
{
    pub fn new(inner: Rc<ScatterAdd<T, Tindices>>) -> Self {
        Self{inner}
    }

    pub fn output_ref(&self) -> Edge<T> {
        Edge::<T>::new(self.inner.clone(), 0)
    }
}

struct ScatterAddOp<T, Tindices>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      Tindices: con_or_DT_INT32_or_DT_INT64,
{
    inner: Rc<ScatterAdd<T, Tindices>>,
}

impl<T, Tindices> GraphOperation for ScatterAdd<T, Tindices>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      Tindices: con_or_DT_INT32_or_DT_INT64,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("ScatterAdd_{}")?
        };
        let mut new_op = graph.new_operation("ScatterAdd", &op_name)?;
        {
            match self.use_locking {
            }
            None => new_op.set_attr_value_proto("use_locking", &vec![40_u8, 0_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_bool("use_locking", *attr)})(&value),
        };
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct ScatterAdd<T, Tindices>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      Tindices: con_or_DT_INT32_or_DT_INT64,
{
    ref_: Edge<T>,
    indices: Edge<Tindices>,
    updates: Edge<T>,
    use_locking: Option<bool>,
    id_: usize,
}

impl<T, Tindices> ScatterAdd<T, Tindices>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      Tindices: con_or_DT_INT32_or_DT_INT64,
{
    pub fn use_locking(&mut self, use_locking: bool) -> &mut Self {
        self.use_locking = Some(use_locking);
        &self
    }

    pub fn finish(self) -> ScatterAddOp<T, Tindices> {
        ScatterAddOp::new(Rc::new(self))
    }

    pub fn new(ref_: Edge<T>, indices: Edge<Tindices>, updates: Edge<T>) -> Self {
        Self {
            ref_,
            indices,
            updates,
            use_locking: None,
            id_: new_id(),
        }
    }
}

impl TextLineReaderOp {
    pub fn new(inner: Rc<TextLineReader>) -> Self {
        Self{inner}
    }

    pub fn reader_handle(&self) -> Edge<String> {
        Edge::<String>::new(self.inner.clone(), 0)
    }
}

struct TextLineReaderOp {
    inner: Rc<TextLineReader>,
}

impl GraphOperation for TextLineReader {
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("TextLineReader_{}")?
        };
        let mut new_op = graph.new_operation("TextLineReader", &op_name)?;
        {
            match self.skip_header_lines {
            }
            None => new_op.set_attr_value_proto("skip_header_lines", &vec![24_u8, 0_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_int("skip_header_lines", *attr)})(&value),
        };
        {
            match self.container {
            }
            None => new_op.set_attr_value_proto("container", &vec![18_u8, 0_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_string("container", attr)})(&value),
        };
        {
            match self.shared_name {
            }
            None => new_op.set_attr_value_proto("shared_name", &vec![18_u8, 0_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_string("shared_name", attr)})(&value),
        };
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct TextLineReader {
    skip_header_lines: Option<i64>,
    container: Option<String>,
    shared_name: Option<String>,
    id_: usize,
}

impl TextLineReader {
    pub fn skip_header_lines(&mut self, skip_header_lines: int) -> &mut Self {
        self.skip_header_lines = Some(skip_header_lines);
        &self
    }

    pub fn container(&mut self, container: &str) -> &mut Self {
        self.container = Some(container.to_string());
        &self
    }

    pub fn shared_name(&mut self, shared_name: &str) -> &mut Self {
        self.shared_name = Some(shared_name.to_string());
        &self
    }

    pub fn finish(self) -> TextLineReaderOp {
        TextLineReaderOp::new(Rc::new(self))
    }

    pub fn new() -> Self {
        Self {
            skip_header_lines: None,
            container: None,
            shared_name: None,
            id_: new_id(),
        }
    }
}

impl<T> SignOp<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_COMPLEX64_or_DT_INT64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF,
{
    pub fn new(inner: Rc<Sign<T>>) -> Self {
        Self{inner}
    }

    pub fn y(&self) -> Edge<T> {
        Edge::<T>::new(self.inner.clone(), 0)
    }
}

struct SignOp<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_COMPLEX64_or_DT_INT64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF,
{
    inner: Rc<Sign<T>>,
}

impl<T> GraphOperation for Sign<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_COMPLEX64_or_DT_INT64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("Sign_{}")?
        };
        let mut new_op = graph.new_operation("Sign", &op_name)?;
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct Sign<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_COMPLEX64_or_DT_INT64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF,
{
    x: Edge<T>,
    id_: usize,
}

impl<T> Sign<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_COMPLEX64_or_DT_INT64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF,
{
    pub fn finish(self) -> SignOp<T> {
        SignOp::new(Rc::new(self))
    }

    pub fn new(x: Edge<T>) -> Self {
        Self {
            x,
            id_: new_id(),
        }
    }
}

impl<T, Tidx> BatchToSpaceOp<T, Tidx>
where T: con,
      Tidx: con_or_DT_INT32_or_DT_INT64,
{
    pub fn new(inner: Rc<BatchToSpace<T, Tidx>>) -> Self {
        Self{inner}
    }

    pub fn output(&self) -> Edge<T> {
        Edge::<T>::new(self.inner.clone(), 0)
    }
}

struct BatchToSpaceOp<T, Tidx>
where T: con,
      Tidx: con_or_DT_INT32_or_DT_INT64,
{
    inner: Rc<BatchToSpace<T, Tidx>>,
}

impl<T, Tidx> GraphOperation for BatchToSpace<T, Tidx>
where T: con,
      Tidx: con_or_DT_INT32_or_DT_INT64,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("BatchToSpace_{}")?
        };
        let mut new_op = graph.new_operation("BatchToSpace", &op_name)?;
        {
            (|attr| {new_op.set_attr_int("block_size", *attr)})(&self.block_size)
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct BatchToSpace<T, Tidx>
where T: con,
      Tidx: con_or_DT_INT32_or_DT_INT64,
{
    input: Edge<T>,
    crops: Edge<Tidx>,
    block_size: i64,
    id_: usize,
}

impl<T, Tidx> BatchToSpace<T, Tidx>
where T: con,
      Tidx: con_or_DT_INT32_or_DT_INT64,
{
    pub fn finish(self) -> BatchToSpaceOp<T, Tidx> {
        BatchToSpaceOp::new(Rc::new(self))
    }

    pub fn new(input: Edge<T>, crops: Edge<Tidx>, block_size: int) -> Self {
        Self {
            input,
            crops,
            block_size: block_size
            id_: new_id(),
        }
    }
}

impl<T> MatrixSolveOp<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_COMPLEX64_or_DT_COMPLEX128,
{
    pub fn new(inner: Rc<MatrixSolve<T>>) -> Self {
        Self{inner}
    }

    pub fn output(&self) -> Edge<T> {
        Edge::<T>::new(self.inner.clone(), 0)
    }
}

struct MatrixSolveOp<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_COMPLEX64_or_DT_COMPLEX128,
{
    inner: Rc<MatrixSolve<T>>,
}

impl<T> GraphOperation for MatrixSolve<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_COMPLEX64_or_DT_COMPLEX128,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("MatrixSolve_{}")?
        };
        let mut new_op = graph.new_operation("MatrixSolve", &op_name)?;
        {
            match self.adjoint {
            }
            None => new_op.set_attr_value_proto("adjoint", &vec![40_u8, 0_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_bool("adjoint", *attr)})(&value),
        };
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct MatrixSolve<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_COMPLEX64_or_DT_COMPLEX128,
{
    matrix: Edge<T>,
    rhs: Edge<T>,
    adjoint: Option<bool>,
    id_: usize,
}

impl<T> MatrixSolve<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_COMPLEX64_or_DT_COMPLEX128,
{
    pub fn adjoint(&mut self, adjoint: bool) -> &mut Self {
        self.adjoint = Some(adjoint);
        &self
    }

    pub fn finish(self) -> MatrixSolveOp<T> {
        MatrixSolveOp::new(Rc::new(self))
    }

    pub fn new(matrix: Edge<T>, rhs: Edge<T>) -> Self {
        Self {
            matrix,
            rhs,
            adjoint: None,
            id_: new_id(),
        }
    }
}

impl<dtype> VariableV2Op<dtype>
where dtype: con,
{
    pub fn new(inner: Rc<VariableV2<dtype>>) -> Self {
        Self{inner}
    }

    pub fn ref_(&self) -> Edge<dtype> {
        Edge::<dtype>::new(self.inner.clone(), 0)
    }
}

struct VariableV2Op<dtype>
where dtype: con,
{
    inner: Rc<VariableV2<dtype>>,
}

impl<dtype> GraphOperation for VariableV2<dtype>
where dtype: con,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("VariableV2_{}")?
        };
        let mut new_op = graph.new_operation("VariableV2", &op_name)?;
        {
            (|attr| {new_op.set_attr_shape("shape", attr)})(&self.shape)
        }
        {
            match self.container {
            }
            None => new_op.set_attr_value_proto("container", &vec![18_u8, 0_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_string("container", attr)})(&value),
        };
        {
            match self.shared_name {
            }
            None => new_op.set_attr_value_proto("shared_name", &vec![18_u8, 0_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_string("shared_name", attr)})(&value),
        };
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct VariableV2<dtype>
where dtype: con,
{
    shape: Shape,
    container: Option<String>,
    shared_name: Option<String>,
    id_: usize,
}

impl<dtype> VariableV2<dtype>
where dtype: con,
{
    pub fn container(&mut self, container: &str) -> &mut Self {
        self.container = Some(container.to_string());
        &self
    }

    pub fn shared_name(&mut self, shared_name: &str) -> &mut Self {
        self.shared_name = Some(shared_name.to_string());
        &self
    }

    pub fn finish(self) -> VariableV2Op<dtype> {
        VariableV2Op::new(Rc::new(self))
    }

    pub fn new(shape: &Shape) -> Self {
        Self {
            shape: shape.clone()
            container: None,
            shared_name: None,
            id_: new_id(),
        }
    }
}

impl<T, Tidx> MaxOp<T, Tidx>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      Tidx: con_or_DT_INT32_or_DT_INT64,
{
    pub fn new(inner: Rc<Max<T, Tidx>>) -> Self {
        Self{inner}
    }

    pub fn output(&self) -> Edge<T> {
        Edge::<T>::new(self.inner.clone(), 0)
    }
}

struct MaxOp<T, Tidx>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      Tidx: con_or_DT_INT32_or_DT_INT64,
{
    inner: Rc<Max<T, Tidx>>,
}

impl<T, Tidx> GraphOperation for Max<T, Tidx>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      Tidx: con_or_DT_INT32_or_DT_INT64,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("Max_{}")?
        };
        let mut new_op = graph.new_operation("Max", &op_name)?;
        {
            match self.keep_dims {
            }
            None => new_op.set_attr_value_proto("keep_dims", &vec![40_u8, 0_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_bool("keep_dims", *attr)})(&value),
        };
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct Max<T, Tidx>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      Tidx: con_or_DT_INT32_or_DT_INT64,
{
    input: Edge<T>,
    reduction_indices: Edge<Tidx>,
    keep_dims: Option<bool>,
    id_: usize,
}

impl<T, Tidx> Max<T, Tidx>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      Tidx: con_or_DT_INT32_or_DT_INT64,
{
    pub fn keep_dims(&mut self, keep_dims: bool) -> &mut Self {
        self.keep_dims = Some(keep_dims);
        &self
    }

    pub fn finish(self) -> MaxOp<T, Tidx> {
        MaxOp::new(Rc::new(self))
    }

    pub fn new(input: Edge<T>, reduction_indices: Edge<Tidx>) -> Self {
        Self {
            input,
            reduction_indices,
            keep_dims: None,
            id_: new_id(),
        }
    }
}

impl StringSplitV2Op {
    pub fn new(inner: Rc<StringSplitV2>) -> Self {
        Self{inner}
    }

    pub fn indices(&self) -> Edge<i64> {
        Edge::<i64>::new(self.inner.clone(), 0)
    }

    pub fn values(&self) -> Edge<String> {
        Edge::<String>::new(self.inner.clone(), 1)
    }

    pub fn shape(&self) -> Edge<i64> {
        Edge::<i64>::new(self.inner.clone(), 2)
    }
}

struct StringSplitV2Op {
    inner: Rc<StringSplitV2>,
}

impl GraphOperation for StringSplitV2 {
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("StringSplitV2_{}")?
        };
        let mut new_op = graph.new_operation("StringSplitV2", &op_name)?;
        {
            match self.maxsplit {
            }
            None => new_op.set_attr_value_proto("maxsplit", &vec![24_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 1_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_int("maxsplit", *attr)})(&value),
        };
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct StringSplitV2 {
    input: Edge<String>,
    sep: Edge<String>,
    maxsplit: Option<i64>,
    id_: usize,
}

impl StringSplitV2 {
    pub fn maxsplit(&mut self, maxsplit: int) -> &mut Self {
        self.maxsplit = Some(maxsplit);
        &self
    }

    pub fn finish(self) -> StringSplitV2Op {
        StringSplitV2Op::new(Rc::new(self))
    }

    pub fn new(input: Edge<String>, sep: Edge<String>) -> Self {
        Self {
            input,
            sep,
            maxsplit: None,
            id_: new_id(),
        }
    }
}

impl<T> _ScopedAllocatorOp<T>
where T: con,
{
    pub fn new(inner: Rc<_ScopedAllocator<T>>) -> Self {
        Self{inner}
    }

    pub fn output(&self) -> Edge<T> {
        Edge::<T>::new(self.inner.clone(), 0)
    }
}

struct _ScopedAllocatorOp<T>
where T: con,
{
    inner: Rc<_ScopedAllocator<T>>,
}

impl<T> GraphOperation for _ScopedAllocator<T>
where T: con,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("_ScopedAllocator_{}")?
        };
        let mut new_op = graph.new_operation("_ScopedAllocator", &op_name)?;
        {
            (|attrs| {new_op.set_attr_shape_list("shapes", attrs)})(&self.shapes)
        }
        {
            (|attr| {new_op.set_attr_shape("shape", attr)})(&self.shape)
        }
        {
            (|attr| {new_op.set_attr_string("sa_name", attr)})(&self.sa_name)
        }
        {
            (|attr| {new_op.set_attr_int("id", *attr)})(&self.id)
        }
        {
            (|attr| {new_op.set_attr_int("expected_call_count", *attr)})(&self.expected_call_count)
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct _ScopedAllocator<T>
where T: con,
{
    shapes: Vec<Shape>,
    shape: Shape,
    sa_name: String,
    id: i64,
    expected_call_count: i64,
    id_: usize,
}

impl<T> _ScopedAllocator<T>
where T: con,
{
    pub fn finish(self) -> _ScopedAllocatorOp<T> {
        _ScopedAllocatorOp::new(Rc::new(self))
    }

    pub fn new(shapes: &[Shape], shape: &Shape, sa_name: &str, id: int, expected_call_count: int) -> Self {
        Self {
            shapes: shapes.to_vec()
            shape: shape.clone()
            sa_name: sa_name.to_string()
            id: id
            expected_call_count: expected_call_count
            id_: new_id(),
        }
    }
}

impl<T> MatrixLogarithmOp<T>
where T: con_or_DT_COMPLEX64_or_DT_COMPLEX128,
{
    pub fn new(inner: Rc<MatrixLogarithm<T>>) -> Self {
        Self{inner}
    }

    pub fn output(&self) -> Edge<T> {
        Edge::<T>::new(self.inner.clone(), 0)
    }
}

struct MatrixLogarithmOp<T>
where T: con_or_DT_COMPLEX64_or_DT_COMPLEX128,
{
    inner: Rc<MatrixLogarithm<T>>,
}

impl<T> GraphOperation for MatrixLogarithm<T>
where T: con_or_DT_COMPLEX64_or_DT_COMPLEX128,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("MatrixLogarithm_{}")?
        };
        let mut new_op = graph.new_operation("MatrixLogarithm", &op_name)?;
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct MatrixLogarithm<T>
where T: con_or_DT_COMPLEX64_or_DT_COMPLEX128,
{
    input: Edge<T>,
    id_: usize,
}

impl<T> MatrixLogarithm<T>
where T: con_or_DT_COMPLEX64_or_DT_COMPLEX128,
{
    pub fn finish(self) -> MatrixLogarithmOp<T> {
        MatrixLogarithmOp::new(Rc::new(self))
    }

    pub fn new(input: Edge<T>) -> Self {
        Self {
            input,
            id_: new_id(),
        }
    }
}

impl<dtype> FakeParamOp<dtype>
where dtype: con,
{
    pub fn new(inner: Rc<FakeParam<dtype>>) -> Self {
        Self{inner}
    }

    pub fn output(&self) -> Edge<dtype> {
        Edge::<dtype>::new(self.inner.clone(), 0)
    }
}

struct FakeParamOp<dtype>
where dtype: con,
{
    inner: Rc<FakeParam<dtype>>,
}

impl<dtype> GraphOperation for FakeParam<dtype>
where dtype: con,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("FakeParam_{}")?
        };
        let mut new_op = graph.new_operation("FakeParam", &op_name)?;
        {
            (|attr| {new_op.set_attr_shape("shape", attr)})(&self.shape)
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct FakeParam<dtype>
where dtype: con,
{
    shape: Shape,
    id_: usize,
}

impl<dtype> FakeParam<dtype>
where dtype: con,
{
    pub fn finish(self) -> FakeParamOp<dtype> {
        FakeParamOp::new(Rc::new(self))
    }

    pub fn new(shape: &Shape) -> Self {
        Self {
            shape: shape.clone()
            id_: new_id(),
        }
    }
}

impl<T> XlaDotOp<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
{
    pub fn new(inner: Rc<XlaDot<T>>) -> Self {
        Self{inner}
    }

    pub fn output(&self) -> Edge<T> {
        Edge::<T>::new(self.inner.clone(), 0)
    }
}

struct XlaDotOp<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
{
    inner: Rc<XlaDot<T>>,
}

impl<T> GraphOperation for XlaDot<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("XlaDot_{}")?
        };
        let mut new_op = graph.new_operation("XlaDot", &op_name)?;
        {
            (|attr| {new_op.set_attr_string("dimension_numbers", attr)})(&self.dimension_numbers)
        }
        {
            (|attr| {new_op.set_attr_string("precision_config", attr)})(&self.precision_config)
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct XlaDot<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
{
    lhs: Edge<T>,
    rhs: Edge<T>,
    dimension_numbers: String,
    precision_config: String,
    id_: usize,
}

impl<T> XlaDot<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
{
    pub fn finish(self) -> XlaDotOp<T> {
        XlaDotOp::new(Rc::new(self))
    }

    pub fn new(lhs: Edge<T>, rhs: Edge<T>, dimension_numbers: &str, precision_config: &str) -> Self {
        Self {
            lhs,
            rhs,
            dimension_numbers: dimension_numbers.to_string()
            precision_config: precision_config.to_string()
            id_: new_id(),
        }
    }
}

impl<T> SoftsignOp<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
{
    pub fn new(inner: Rc<Softsign<T>>) -> Self {
        Self{inner}
    }

    pub fn activations(&self) -> Edge<T> {
        Edge::<T>::new(self.inner.clone(), 0)
    }
}

struct SoftsignOp<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
{
    inner: Rc<Softsign<T>>,
}

impl<T> GraphOperation for Softsign<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("Softsign_{}")?
        };
        let mut new_op = graph.new_operation("Softsign", &op_name)?;
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct Softsign<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
{
    features: Edge<T>,
    id_: usize,
}

impl<T> Softsign<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
{
    pub fn finish(self) -> SoftsignOp<T> {
        SoftsignOp::new(Rc::new(self))
    }

    pub fn new(features: Edge<T>) -> Self {
        Self {
            features,
            id_: new_id(),
        }
    }
}

impl<T> NonMaxSuppressionV4Op<T>
where T: con_or_DT_FLOAT_or_DT_HALF,
{
    pub fn new(inner: Rc<NonMaxSuppressionV4<T>>) -> Self {
        Self{inner}
    }

    pub fn selected_indices(&self) -> Edge<i32> {
        Edge::<i32>::new(self.inner.clone(), 0)
    }

    pub fn valid_outputs(&self) -> Edge<i32> {
        Edge::<i32>::new(self.inner.clone(), 1)
    }
}

struct NonMaxSuppressionV4Op<T>
where T: con_or_DT_FLOAT_or_DT_HALF,
{
    inner: Rc<NonMaxSuppressionV4<T>>,
}

impl<T> GraphOperation for NonMaxSuppressionV4<T>
where T: con_or_DT_FLOAT_or_DT_HALF,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("NonMaxSuppressionV4_{}")?
        };
        let mut new_op = graph.new_operation("NonMaxSuppressionV4", &op_name)?;
        {
            match self.pad_to_max_output_size {
            }
            None => new_op.set_attr_value_proto("pad_to_max_output_size", &vec![40_u8, 0_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_bool("pad_to_max_output_size", *attr)})(&value),
        };
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct NonMaxSuppressionV4<T>
where T: con_or_DT_FLOAT_or_DT_HALF,
{
    boxes: Edge<T>,
    scores: Edge<T>,
    max_output_size: Edge<i32>,
    iou_threshold: Edge<f32>,
    score_threshold: Edge<f32>,
    pad_to_max_output_size: Option<bool>,
    id_: usize,
}

impl<T> NonMaxSuppressionV4<T>
where T: con_or_DT_FLOAT_or_DT_HALF,
{
    pub fn pad_to_max_output_size(&mut self, pad_to_max_output_size: bool) -> &mut Self {
        self.pad_to_max_output_size = Some(pad_to_max_output_size);
        &self
    }

    pub fn finish(self) -> NonMaxSuppressionV4Op<T> {
        NonMaxSuppressionV4Op::new(Rc::new(self))
    }

    pub fn new(boxes: Edge<T>, scores: Edge<T>, max_output_size: Edge<i32>, iou_threshold: Edge<f32>, score_threshold: Edge<f32>) -> Self {
        Self {
            boxes,
            scores,
            max_output_size,
            iou_threshold,
            score_threshold,
            pad_to_max_output_size: None,
            id_: new_id(),
        }
    }
}

impl<T> _ArgOp<T>
where T: con,
{
    pub fn new(inner: Rc<_Arg<T>>) -> Self {
        Self{inner}
    }

    pub fn output(&self) -> Edge<T> {
        Edge::<T>::new(self.inner.clone(), 0)
    }
}

struct _ArgOp<T>
where T: con,
{
    inner: Rc<_Arg<T>>,
}

impl<T> GraphOperation for _Arg<T>
where T: con,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("_Arg_{}")?
        };
        let mut new_op = graph.new_operation("_Arg", &op_name)?;
        {
            (|attr| {new_op.set_attr_int("index", *attr)})(&self.index)
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct _Arg<T>
where T: con,
{
    index: i64,
    id_: usize,
}

impl<T> _Arg<T>
where T: con,
{
    pub fn finish(self) -> _ArgOp<T> {
        _ArgOp::new(Rc::new(self))
    }

    pub fn new(index: int) -> Self {
        Self {
            index: index
            id_: new_id(),
        }
    }
}

impl<T> TruncateDivOp<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF,
{
    pub fn new(inner: Rc<TruncateDiv<T>>) -> Self {
        Self{inner}
    }

    pub fn z(&self) -> Edge<T> {
        Edge::<T>::new(self.inner.clone(), 0)
    }
}

struct TruncateDivOp<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF,
{
    inner: Rc<TruncateDiv<T>>,
}

impl<T> GraphOperation for TruncateDiv<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("TruncateDiv_{}")?
        };
        let mut new_op = graph.new_operation("TruncateDiv", &op_name)?;
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct TruncateDiv<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF,
{
    x: Edge<T>,
    y: Edge<T>,
    id_: usize,
}

impl<T> TruncateDiv<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF,
{
    pub fn finish(self) -> TruncateDivOp<T> {
        TruncateDivOp::new(Rc::new(self))
    }

    pub fn new(x: Edge<T>, y: Edge<T>) -> Self {
        Self {
            x,
            y,
            id_: new_id(),
        }
    }
}

impl<T> _DeviceArgOp<T>
where T: con,
{
    pub fn new(inner: Rc<_DeviceArg<T>>) -> Self {
        Self{inner}
    }

    pub fn output(&self) -> Edge<T> {
        Edge::<T>::new(self.inner.clone(), 0)
    }
}

struct _DeviceArgOp<T>
where T: con,
{
    inner: Rc<_DeviceArg<T>>,
}

impl<T> GraphOperation for _DeviceArg<T>
where T: con,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("_DeviceArg_{}")?
        };
        let mut new_op = graph.new_operation("_DeviceArg", &op_name)?;
        {
            (|attr| {new_op.set_attr_int("index", *attr)})(&self.index)
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct _DeviceArg<T>
where T: con,
{
    index: i64,
    id_: usize,
}

impl<T> _DeviceArg<T>
where T: con,
{
    pub fn finish(self) -> _DeviceArgOp<T> {
        _DeviceArgOp::new(Rc::new(self))
    }

    pub fn new(index: int) -> Self {
        Self {
            index: index
            id_: new_id(),
        }
    }
}

impl RFFT3DOp {
    pub fn new(inner: Rc<RFFT3D>) -> Self {
        Self{inner}
    }

    pub fn output(&self) -> Edge<OtherComplex<f32>> {
        Edge::<OtherComplex::<f32>>::new(self.inner.clone(), 0)
    }
}

struct RFFT3DOp {
    inner: Rc<RFFT3D>,
}

impl GraphOperation for RFFT3D {
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("RFFT3D_{}")?
        };
        let mut new_op = graph.new_operation("RFFT3D", &op_name)?;
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct RFFT3D {
    input: Edge<f32>,
    fft_length: Edge<i32>,
    id_: usize,
}

impl RFFT3D {
    pub fn finish(self) -> RFFT3DOp {
        RFFT3DOp::new(Rc::new(self))
    }

    pub fn new(input: Edge<f32>, fft_length: Edge<i32>) -> Self {
        Self {
            input,
            fft_length,
            id_: new_id(),
        }
    }
}

impl LogicalNotOp {
    pub fn new(inner: Rc<LogicalNot>) -> Self {
        Self{inner}
    }

    pub fn y(&self) -> Edge<bool> {
        Edge::<bool>::new(self.inner.clone(), 0)
    }
}

struct LogicalNotOp {
    inner: Rc<LogicalNot>,
}

impl GraphOperation for LogicalNot {
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("LogicalNot_{}")?
        };
        let mut new_op = graph.new_operation("LogicalNot", &op_name)?;
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct LogicalNot {
    x: Edge<bool>,
    id_: usize,
}

impl LogicalNot {
    pub fn finish(self) -> LogicalNotOp {
        LogicalNotOp::new(Rc::new(self))
    }

    pub fn new(x: Edge<bool>) -> Self {
        Self {
            x,
            id_: new_id(),
        }
    }
}

impl<T> ApplyFtrlOp<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
{
    pub fn new(inner: Rc<ApplyFtrl<T>>) -> Self {
        Self{inner}
    }

    pub fn out(&self) -> Edge<T> {
        Edge::<T>::new(self.inner.clone(), 0)
    }
}

struct ApplyFtrlOp<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
{
    inner: Rc<ApplyFtrl<T>>,
}

impl<T> GraphOperation for ApplyFtrl<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("ApplyFtrl_{}")?
        };
        let mut new_op = graph.new_operation("ApplyFtrl", &op_name)?;
        {
            match self.use_locking {
            }
            None => new_op.set_attr_value_proto("use_locking", &vec![40_u8, 0_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_bool("use_locking", *attr)})(&value),
        };
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct ApplyFtrl<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
{
    var: Edge<T>,
    accum: Edge<T>,
    linear: Edge<T>,
    grad: Edge<T>,
    lr: Edge<T>,
    l1: Edge<T>,
    l2: Edge<T>,
    lr_power: Edge<T>,
    use_locking: Option<bool>,
    id_: usize,
}

impl<T> ApplyFtrl<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
{
    pub fn use_locking(&mut self, use_locking: bool) -> &mut Self {
        self.use_locking = Some(use_locking);
        &self
    }

    pub fn finish(self) -> ApplyFtrlOp<T> {
        ApplyFtrlOp::new(Rc::new(self))
    }

    pub fn new(var: Edge<T>, accum: Edge<T>, linear: Edge<T>, grad: Edge<T>, lr: Edge<T>, l1: Edge<T>, l2: Edge<T>, lr_power: Edge<T>) -> Self {
        Self {
            var,
            accum,
            linear,
            grad,
            lr,
            l1,
            l2,
            lr_power,
            use_locking: None,
            id_: new_id(),
        }
    }
}

impl<T> _RetvalOp<T>
where T: con,
{
    pub fn new(inner: Rc<_Retval<T>>) -> Self {
        Self{inner}
    }
}

struct _RetvalOp<T>
where T: con,
{
    inner: Rc<_Retval<T>>,
}

impl<T> GraphOperation for _Retval<T>
where T: con,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("_Retval_{}")?
        };
        let mut new_op = graph.new_operation("_Retval", &op_name)?;
        {
            (|attr| {new_op.set_attr_int("index", *attr)})(&self.index)
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct _Retval<T>
where T: con,
{
    input: Edge<T>,
    index: i64,
    id_: usize,
}

impl<T> _Retval<T>
where T: con,
{
    pub fn finish(self) -> _RetvalOp<T> {
        _RetvalOp::new(Rc::new(self))
    }

    pub fn new(input: Edge<T>, index: int) -> Self {
        Self {
            input,
            index: index
            id_: new_id(),
        }
    }
}

impl<T> _DeviceRetvalOp<T>
where T: con,
{
    pub fn new(inner: Rc<_DeviceRetval<T>>) -> Self {
        Self{inner}
    }
}

struct _DeviceRetvalOp<T>
where T: con,
{
    inner: Rc<_DeviceRetval<T>>,
}

impl<T> GraphOperation for _DeviceRetval<T>
where T: con,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("_DeviceRetval_{}")?
        };
        let mut new_op = graph.new_operation("_DeviceRetval", &op_name)?;
        {
            (|attr| {new_op.set_attr_int("index", *attr)})(&self.index)
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct _DeviceRetval<T>
where T: con,
{
    input: Edge<T>,
    index: i64,
    id_: usize,
}

impl<T> _DeviceRetval<T>
where T: con,
{
    pub fn finish(self) -> _DeviceRetvalOp<T> {
        _DeviceRetvalOp::new(Rc::new(self))
    }

    pub fn new(input: Edge<T>, index: int) -> Self {
        Self {
            input,
            index: index
            id_: new_id(),
        }
    }
}

impl<T> XdivyOp<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_COMPLEX64_or_DT_COMPLEX128_or_DT_HALF,
{
    pub fn new(inner: Rc<Xdivy<T>>) -> Self {
        Self{inner}
    }

    pub fn z(&self) -> Edge<T> {
        Edge::<T>::new(self.inner.clone(), 0)
    }
}

struct XdivyOp<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_COMPLEX64_or_DT_COMPLEX128_or_DT_HALF,
{
    inner: Rc<Xdivy<T>>,
}

impl<T> GraphOperation for Xdivy<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_COMPLEX64_or_DT_COMPLEX128_or_DT_HALF,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("Xdivy_{}")?
        };
        let mut new_op = graph.new_operation("Xdivy", &op_name)?;
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct Xdivy<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_COMPLEX64_or_DT_COMPLEX128_or_DT_HALF,
{
    x: Edge<T>,
    y: Edge<T>,
    id_: usize,
}

impl<T> Xdivy<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_COMPLEX64_or_DT_COMPLEX128_or_DT_HALF,
{
    pub fn finish(self) -> XdivyOp<T> {
        XdivyOp::new(Rc::new(self))
    }

    pub fn new(x: Edge<T>, y: Edge<T>) -> Self {
        Self {
            x,
            y,
            id_: new_id(),
        }
    }
}

impl<T> CrossOp<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
{
    pub fn new(inner: Rc<Cross<T>>) -> Self {
        Self{inner}
    }

    pub fn product(&self) -> Edge<T> {
        Edge::<T>::new(self.inner.clone(), 0)
    }
}

struct CrossOp<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
{
    inner: Rc<Cross<T>>,
}

impl<T> GraphOperation for Cross<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("Cross_{}")?
        };
        let mut new_op = graph.new_operation("Cross", &op_name)?;
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct Cross<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
{
    a: Edge<T>,
    b: Edge<T>,
    id_: usize,
}

impl<T> Cross<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
{
    pub fn finish(self) -> CrossOp<T> {
        CrossOp::new(Rc::new(self))
    }

    pub fn new(a: Edge<T>, b: Edge<T>) -> Self {
        Self {
            a,
            b,
            id_: new_id(),
        }
    }
}

impl<dtype> TensorArrayGatherOp<dtype>
where dtype: con,
{
    pub fn new(inner: Rc<TensorArrayGather<dtype>>) -> Self {
        Self{inner}
    }

    pub fn value(&self) -> Edge<dtype> {
        Edge::<dtype>::new(self.inner.clone(), 0)
    }
}

struct TensorArrayGatherOp<dtype>
where dtype: con,
{
    inner: Rc<TensorArrayGather<dtype>>,
}

impl<dtype> GraphOperation for TensorArrayGather<dtype>
where dtype: con,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("TensorArrayGather_{}")?
        };
        let mut new_op = graph.new_operation("TensorArrayGather", &op_name)?;
        {
            match self.element_shape {
            }
            None => new_op.set_attr_value_proto("element_shape", &vec![58_u8, 0_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_shape("element_shape", attr)})(&value),
        };
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct TensorArrayGather<dtype>
where dtype: con,
{
    handle: Edge<String>,
    indices: Edge<i32>,
    flow_in: Edge<f32>,
    element_shape: Option<Shape>,
    id_: usize,
}

impl<dtype> TensorArrayGather<dtype>
where dtype: con,
{
    pub fn element_shape(&mut self, element_shape: &Shape) -> &mut Self {
        self.element_shape = Some(element_shape.clone());
        &self
    }

    pub fn finish(self) -> TensorArrayGatherOp<dtype> {
        TensorArrayGatherOp::new(Rc::new(self))
    }

    pub fn new(handle: Edge<String>, indices: Edge<i32>, flow_in: Edge<f32>) -> Self {
        Self {
            handle,
            indices,
            flow_in,
            element_shape: None,
            id_: new_id(),
        }
    }
}

impl<T, Tindices> SegmentProdOp<T, Tindices>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      Tindices: con_or_DT_INT32_or_DT_INT64,
{
    pub fn new(inner: Rc<SegmentProd<T, Tindices>>) -> Self {
        Self{inner}
    }

    pub fn output(&self) -> Edge<T> {
        Edge::<T>::new(self.inner.clone(), 0)
    }
}

struct SegmentProdOp<T, Tindices>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      Tindices: con_or_DT_INT32_or_DT_INT64,
{
    inner: Rc<SegmentProd<T, Tindices>>,
}

impl<T, Tindices> GraphOperation for SegmentProd<T, Tindices>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      Tindices: con_or_DT_INT32_or_DT_INT64,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("SegmentProd_{}")?
        };
        let mut new_op = graph.new_operation("SegmentProd", &op_name)?;
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct SegmentProd<T, Tindices>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      Tindices: con_or_DT_INT32_or_DT_INT64,
{
    data: Edge<T>,
    segment_ids: Edge<Tindices>,
    id_: usize,
}

impl<T, Tindices> SegmentProd<T, Tindices>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      Tindices: con_or_DT_INT32_or_DT_INT64,
{
    pub fn finish(self) -> SegmentProdOp<T, Tindices> {
        SegmentProdOp::new(Rc::new(self))
    }

    pub fn new(data: Edge<T>, segment_ids: Edge<Tindices>) -> Self {
        Self {
            data,
            segment_ids,
            id_: new_id(),
        }
    }
}

impl<Tin, Tout> LookupTableInsertOp<Tin, Tout>
where Tin: con,
      Tout: con,
{
    pub fn new(inner: Rc<LookupTableInsert<Tin, Tout>>) -> Self {
        Self{inner}
    }
}

struct LookupTableInsertOp<Tin, Tout>
where Tin: con,
      Tout: con,
{
    inner: Rc<LookupTableInsert<Tin, Tout>>,
}

impl<Tin, Tout> GraphOperation for LookupTableInsert<Tin, Tout>
where Tin: con,
      Tout: con,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("LookupTableInsert_{}")?
        };
        let mut new_op = graph.new_operation("LookupTableInsert", &op_name)?;
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct LookupTableInsert<Tin, Tout>
where Tin: con,
      Tout: con,
{
    table_handle: Edge<String>,
    keys: Edge<Tin>,
    values: Edge<Tout>,
    id_: usize,
}

impl<Tin, Tout> LookupTableInsert<Tin, Tout>
where Tin: con,
      Tout: con,
{
    pub fn finish(self) -> LookupTableInsertOp<Tin, Tout> {
        LookupTableInsertOp::new(Rc::new(self))
    }

    pub fn new(table_handle: Edge<String>, keys: Edge<Tin>, values: Edge<Tout>) -> Self {
        Self {
            table_handle,
            keys,
            values,
            id_: new_id(),
        }
    }
}

impl<T> BucketizeOp<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_INT64,
{
    pub fn new(inner: Rc<Bucketize<T>>) -> Self {
        Self{inner}
    }

    pub fn output(&self) -> Edge<i32> {
        Edge::<i32>::new(self.inner.clone(), 0)
    }
}

struct BucketizeOp<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_INT64,
{
    inner: Rc<Bucketize<T>>,
}

impl<T> GraphOperation for Bucketize<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_INT64,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("Bucketize_{}")?
        };
        let mut new_op = graph.new_operation("Bucketize", &op_name)?;
        {
            (|attrs| {new_op.set_attr_float_list("boundaries", attrs)})(&self.boundaries)
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct Bucketize<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_INT64,
{
    input: Edge<T>,
    boundaries: Vec<f32>,
    id_: usize,
}

impl<T> Bucketize<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_INT64,
{
    pub fn finish(self) -> BucketizeOp<T> {
        BucketizeOp::new(Rc::new(self))
    }

    pub fn new(input: Edge<T>, boundaries: &[f32]) -> Self {
        Self {
            input,
            boundaries: boundaries.to_vec()
            id_: new_id(),
        }
    }
}

impl<dt> RestoreSliceOp<dt>
where dt: con,
{
    pub fn new(inner: Rc<RestoreSlice<dt>>) -> Self {
        Self{inner}
    }

    pub fn tensor(&self) -> Edge<dt> {
        Edge::<dt>::new(self.inner.clone(), 0)
    }
}

struct RestoreSliceOp<dt>
where dt: con,
{
    inner: Rc<RestoreSlice<dt>>,
}

impl<dt> GraphOperation for RestoreSlice<dt>
where dt: con,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("RestoreSlice_{}")?
        };
        let mut new_op = graph.new_operation("RestoreSlice", &op_name)?;
        {
            match self.preferred_shard {
            }
            None => new_op.set_attr_value_proto("preferred_shard", &vec![24_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 1_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_int("preferred_shard", *attr)})(&value),
        };
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct RestoreSlice<dt>
where dt: con,
{
    file_pattern: Edge<String>,
    tensor_name: Edge<String>,
    shape_and_slice: Edge<String>,
    preferred_shard: Option<i64>,
    id_: usize,
}

impl<dt> RestoreSlice<dt>
where dt: con,
{
    pub fn preferred_shard(&mut self, preferred_shard: int) -> &mut Self {
        self.preferred_shard = Some(preferred_shard);
        &self
    }

    pub fn finish(self) -> RestoreSliceOp<dt> {
        RestoreSliceOp::new(Rc::new(self))
    }

    pub fn new(file_pattern: Edge<String>, tensor_name: Edge<String>, shape_and_slice: Edge<String>) -> Self {
        Self {
            file_pattern,
            tensor_name,
            shape_and_slice,
            preferred_shard: None,
            id_: new_id(),
        }
    }
}

impl RetrieveTPUEmbeddingStochasticGradientDescentParametersOp {
    pub fn new(inner: Rc<RetrieveTPUEmbeddingStochasticGradientDescentParameters>) -> Self {
        Self{inner}
    }

    pub fn parameters(&self) -> Edge<f32> {
        Edge::<f32>::new(self.inner.clone(), 0)
    }
}

struct RetrieveTPUEmbeddingStochasticGradientDescentParametersOp {
    inner: Rc<RetrieveTPUEmbeddingStochasticGradientDescentParameters>,
}

impl GraphOperation for RetrieveTPUEmbeddingStochasticGradientDescentParameters {
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("RetrieveTPUEmbeddingStochasticGradientDescentParameters_{}")?
        };
        let mut new_op = graph.new_operation("RetrieveTPUEmbeddingStochasticGradientDescentParameters", &op_name)?;
        {
            match self.table_id {
            }
            None => new_op.set_attr_value_proto("table_id", &vec![24_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 1_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_int("table_id", *attr)})(&value),
        };
        {
            match self.table_name {
            }
            None => new_op.set_attr_value_proto("table_name", &vec![18_u8, 0_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_string("table_name", attr)})(&value),
        };
        {
            (|attr| {new_op.set_attr_int("num_shards", *attr)})(&self.num_shards)
        }
        {
            (|attr| {new_op.set_attr_int("shard_id", *attr)})(&self.shard_id)
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct RetrieveTPUEmbeddingStochasticGradientDescentParameters {
    table_id: Option<i64>,
    table_name: Option<String>,
    num_shards: i64,
    shard_id: i64,
    id_: usize,
}

impl RetrieveTPUEmbeddingStochasticGradientDescentParameters {
    pub fn table_id(&mut self, table_id: int) -> &mut Self {
        self.table_id = Some(table_id);
        &self
    }

    pub fn table_name(&mut self, table_name: &str) -> &mut Self {
        self.table_name = Some(table_name.to_string());
        &self
    }

    pub fn finish(self) -> RetrieveTPUEmbeddingStochasticGradientDescentParametersOp {
        RetrieveTPUEmbeddingStochasticGradientDescentParametersOp::new(Rc::new(self))
    }

    pub fn new(num_shards: int, shard_id: int) -> Self {
        Self {
            table_id: None,
            table_name: None,
            num_shards: num_shards
            shard_id: shard_id
            id_: new_id(),
        }
    }
}

impl<T, Tidx> CumprodOp<T, Tidx>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      Tidx: con_or_DT_INT32_or_DT_INT64,
{
    pub fn new(inner: Rc<Cumprod<T, Tidx>>) -> Self {
        Self{inner}
    }

    pub fn out(&self) -> Edge<T> {
        Edge::<T>::new(self.inner.clone(), 0)
    }
}

struct CumprodOp<T, Tidx>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      Tidx: con_or_DT_INT32_or_DT_INT64,
{
    inner: Rc<Cumprod<T, Tidx>>,
}

impl<T, Tidx> GraphOperation for Cumprod<T, Tidx>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      Tidx: con_or_DT_INT32_or_DT_INT64,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("Cumprod_{}")?
        };
        let mut new_op = graph.new_operation("Cumprod", &op_name)?;
        {
            match self.exclusive {
            }
            None => new_op.set_attr_value_proto("exclusive", &vec![40_u8, 0_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_bool("exclusive", *attr)})(&value),
        };
        {
            match self.reverse {
            }
            None => new_op.set_attr_value_proto("reverse", &vec![40_u8, 0_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_bool("reverse", *attr)})(&value),
        };
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct Cumprod<T, Tidx>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      Tidx: con_or_DT_INT32_or_DT_INT64,
{
    x: Edge<T>,
    axis: Edge<Tidx>,
    exclusive: Option<bool>,
    reverse: Option<bool>,
    id_: usize,
}

impl<T, Tidx> Cumprod<T, Tidx>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      Tidx: con_or_DT_INT32_or_DT_INT64,
{
    pub fn exclusive(&mut self, exclusive: bool) -> &mut Self {
        self.exclusive = Some(exclusive);
        &self
    }

    pub fn reverse(&mut self, reverse: bool) -> &mut Self {
        self.reverse = Some(reverse);
        &self
    }

    pub fn finish(self) -> CumprodOp<T, Tidx> {
        CumprodOp::new(Rc::new(self))
    }

    pub fn new(x: Edge<T>, axis: Edge<Tidx>) -> Self {
        Self {
            x,
            axis,
            exclusive: None,
            reverse: None,
            id_: new_id(),
        }
    }
}

impl<T> ResizeBicubicOp<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_UINT16_or_DT_HALF,
{
    pub fn new(inner: Rc<ResizeBicubic<T>>) -> Self {
        Self{inner}
    }

    pub fn resized_images(&self) -> Edge<f32> {
        Edge::<f32>::new(self.inner.clone(), 0)
    }
}

struct ResizeBicubicOp<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_UINT16_or_DT_HALF,
{
    inner: Rc<ResizeBicubic<T>>,
}

impl<T> GraphOperation for ResizeBicubic<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_UINT16_or_DT_HALF,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("ResizeBicubic_{}")?
        };
        let mut new_op = graph.new_operation("ResizeBicubic", &op_name)?;
        {
            match self.align_corners {
            }
            None => new_op.set_attr_value_proto("align_corners", &vec![40_u8, 0_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_bool("align_corners", *attr)})(&value),
        };
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct ResizeBicubic<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_UINT16_or_DT_HALF,
{
    images: Edge<T>,
    size: Edge<i32>,
    align_corners: Option<bool>,
    id_: usize,
}

impl<T> ResizeBicubic<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_UINT16_or_DT_HALF,
{
    pub fn align_corners(&mut self, align_corners: bool) -> &mut Self {
        self.align_corners = Some(align_corners);
        &self
    }

    pub fn finish(self) -> ResizeBicubicOp<T> {
        ResizeBicubicOp::new(Rc::new(self))
    }

    pub fn new(images: Edge<T>, size: Edge<i32>) -> Self {
        Self {
            images,
            size,
            align_corners: None,
            id_: new_id(),
        }
    }
}

impl<T> Log1pOp<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_COMPLEX64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF,
{
    pub fn new(inner: Rc<Log1p<T>>) -> Self {
        Self{inner}
    }

    pub fn y(&self) -> Edge<T> {
        Edge::<T>::new(self.inner.clone(), 0)
    }
}

struct Log1pOp<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_COMPLEX64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF,
{
    inner: Rc<Log1p<T>>,
}

impl<T> GraphOperation for Log1p<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_COMPLEX64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("Log1p_{}")?
        };
        let mut new_op = graph.new_operation("Log1p", &op_name)?;
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct Log1p<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_COMPLEX64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF,
{
    x: Edge<T>,
    id_: usize,
}

impl<T> Log1p<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_COMPLEX64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF,
{
    pub fn finish(self) -> Log1pOp<T> {
        Log1pOp::new(Rc::new(self))
    }

    pub fn new(x: Edge<T>) -> Self {
        Self {
            x,
            id_: new_id(),
        }
    }
}

pub trait con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF for BFloat16 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF for f32 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF for f64 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF for i16 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF for i32 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF for i64 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF for i8 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF for u16 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF for u8 {
}

impl<T> ResizeBilinearOp<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF,
{
    pub fn new(inner: Rc<ResizeBilinear<T>>) -> Self {
        Self{inner}
    }

    pub fn resized_images(&self) -> Edge<f32> {
        Edge::<f32>::new(self.inner.clone(), 0)
    }
}

struct ResizeBilinearOp<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF,
{
    inner: Rc<ResizeBilinear<T>>,
}

impl<T> GraphOperation for ResizeBilinear<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("ResizeBilinear_{}")?
        };
        let mut new_op = graph.new_operation("ResizeBilinear", &op_name)?;
        {
            match self.align_corners {
            }
            None => new_op.set_attr_value_proto("align_corners", &vec![40_u8, 0_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_bool("align_corners", *attr)})(&value),
        };
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct ResizeBilinear<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF,
{
    images: Edge<T>,
    size: Edge<i32>,
    align_corners: Option<bool>,
    id_: usize,
}

impl<T> ResizeBilinear<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF,
{
    pub fn align_corners(&mut self, align_corners: bool) -> &mut Self {
        self.align_corners = Some(align_corners);
        &self
    }

    pub fn finish(self) -> ResizeBilinearOp<T> {
        ResizeBilinearOp::new(Rc::new(self))
    }

    pub fn new(images: Edge<T>, size: Edge<i32>) -> Self {
        Self {
            images,
            size,
            align_corners: None,
            id_: new_id(),
        }
    }
}

impl<T, Tidx> ProdOp<T, Tidx>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      Tidx: con_or_DT_INT32_or_DT_INT64,
{
    pub fn new(inner: Rc<Prod<T, Tidx>>) -> Self {
        Self{inner}
    }

    pub fn output(&self) -> Edge<T> {
        Edge::<T>::new(self.inner.clone(), 0)
    }
}

struct ProdOp<T, Tidx>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      Tidx: con_or_DT_INT32_or_DT_INT64,
{
    inner: Rc<Prod<T, Tidx>>,
}

impl<T, Tidx> GraphOperation for Prod<T, Tidx>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      Tidx: con_or_DT_INT32_or_DT_INT64,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("Prod_{}")?
        };
        let mut new_op = graph.new_operation("Prod", &op_name)?;
        {
            match self.keep_dims {
            }
            None => new_op.set_attr_value_proto("keep_dims", &vec![40_u8, 0_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_bool("keep_dims", *attr)})(&value),
        };
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct Prod<T, Tidx>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      Tidx: con_or_DT_INT32_or_DT_INT64,
{
    input: Edge<T>,
    reduction_indices: Edge<Tidx>,
    keep_dims: Option<bool>,
    id_: usize,
}

impl<T, Tidx> Prod<T, Tidx>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      Tidx: con_or_DT_INT32_or_DT_INT64,
{
    pub fn keep_dims(&mut self, keep_dims: bool) -> &mut Self {
        self.keep_dims = Some(keep_dims);
        &self
    }

    pub fn finish(self) -> ProdOp<T, Tidx> {
        ProdOp::new(Rc::new(self))
    }

    pub fn new(input: Edge<T>, reduction_indices: Edge<Tidx>) -> Self {
        Self {
            input,
            reduction_indices,
            keep_dims: None,
            id_: new_id(),
        }
    }
}

impl<component_types> PaddingFIFOQueueOp<component_types>
where component_types: con,
{
    pub fn new(inner: Rc<PaddingFIFOQueue<component_types>>) -> Self {
        Self{inner}
    }

    pub fn handle(&self) -> Edge<String> {
        Edge::<String>::new(self.inner.clone(), 0)
    }
}

struct PaddingFIFOQueueOp<component_types>
where component_types: con,
{
    inner: Rc<PaddingFIFOQueue<component_types>>,
}

impl<component_types> GraphOperation for PaddingFIFOQueue<component_types>
where component_types: con,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("PaddingFIFOQueue_{}")?
        };
        let mut new_op = graph.new_operation("PaddingFIFOQueue", &op_name)?;
        {
            match self.shapes {
            }
            None => new_op.set_attr_value_proto("shapes", &vec![10_u8, 0_u8,]);,
            Some(value) => (|attrs| {new_op.set_attr_shape_list("shapes", attrs)})(&value),
        };
        {
            match self.capacity {
            }
            None => new_op.set_attr_value_proto("capacity", &vec![24_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 1_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_int("capacity", *attr)})(&value),
        };
        {
            match self.container {
            }
            None => new_op.set_attr_value_proto("container", &vec![18_u8, 0_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_string("container", attr)})(&value),
        };
        {
            match self.shared_name {
            }
            None => new_op.set_attr_value_proto("shared_name", &vec![18_u8, 0_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_string("shared_name", attr)})(&value),
        };
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct PaddingFIFOQueue<component_types>
where component_types: con,
{
    shapes: Option<Vec<Shape>>,
    capacity: Option<i64>,
    container: Option<String>,
    shared_name: Option<String>,
    id_: usize,
}

impl<component_types> PaddingFIFOQueue<component_types>
where component_types: con,
{
    pub fn shapes(&mut self, shapes: &[Shape]) -> &mut Self {
        self.shapes = Some(shapes.to_vec());
        &self
    }

    pub fn capacity(&mut self, capacity: int) -> &mut Self {
        self.capacity = Some(capacity);
        &self
    }

    pub fn container(&mut self, container: &str) -> &mut Self {
        self.container = Some(container.to_string());
        &self
    }

    pub fn shared_name(&mut self, shared_name: &str) -> &mut Self {
        self.shared_name = Some(shared_name.to_string());
        &self
    }

    pub fn finish(self) -> PaddingFIFOQueueOp<component_types> {
        PaddingFIFOQueueOp::new(Rc::new(self))
    }

    pub fn new() -> Self {
        Self {
            shapes: None,
            capacity: None,
            container: None,
            shared_name: None,
            id_: new_id(),
        }
    }
}

pub trait con_or_DT_FLOAT_or_DT_QUINT8_or_DT_QINT32 {
}

impl con_or_DT_FLOAT_or_DT_QUINT8_or_DT_QINT32 for f32 {
}

impl con_or_DT_FLOAT_or_DT_QUINT8_or_DT_QINT32 for i32 {
}

impl con_or_DT_FLOAT_or_DT_QUINT8_or_DT_QINT32 for u8 {
}

impl<T> QuantizedResizeBilinearOp<T>
where T: con_or_DT_FLOAT_or_DT_QUINT8_or_DT_QINT32,
{
    pub fn new(inner: Rc<QuantizedResizeBilinear<T>>) -> Self {
        Self{inner}
    }

    pub fn resized_images(&self) -> Edge<T> {
        Edge::<T>::new(self.inner.clone(), 0)
    }

    pub fn out_min(&self) -> Edge<f32> {
        Edge::<f32>::new(self.inner.clone(), 1)
    }

    pub fn out_max(&self) -> Edge<f32> {
        Edge::<f32>::new(self.inner.clone(), 2)
    }
}

struct QuantizedResizeBilinearOp<T>
where T: con_or_DT_FLOAT_or_DT_QUINT8_or_DT_QINT32,
{
    inner: Rc<QuantizedResizeBilinear<T>>,
}

impl<T> GraphOperation for QuantizedResizeBilinear<T>
where T: con_or_DT_FLOAT_or_DT_QUINT8_or_DT_QINT32,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("QuantizedResizeBilinear_{}")?
        };
        let mut new_op = graph.new_operation("QuantizedResizeBilinear", &op_name)?;
        {
            match self.align_corners {
            }
            None => new_op.set_attr_value_proto("align_corners", &vec![40_u8, 0_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_bool("align_corners", *attr)})(&value),
        };
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct QuantizedResizeBilinear<T>
where T: con_or_DT_FLOAT_or_DT_QUINT8_or_DT_QINT32,
{
    images: Edge<T>,
    size: Edge<i32>,
    min: Edge<f32>,
    max: Edge<f32>,
    align_corners: Option<bool>,
    id_: usize,
}

impl<T> QuantizedResizeBilinear<T>
where T: con_or_DT_FLOAT_or_DT_QUINT8_or_DT_QINT32,
{
    pub fn align_corners(&mut self, align_corners: bool) -> &mut Self {
        self.align_corners = Some(align_corners);
        &self
    }

    pub fn finish(self) -> QuantizedResizeBilinearOp<T> {
        QuantizedResizeBilinearOp::new(Rc::new(self))
    }

    pub fn new(images: Edge<T>, size: Edge<i32>, min: Edge<f32>, max: Edge<f32>) -> Self {
        Self {
            images,
            size,
            min,
            max,
            align_corners: None,
            id_: new_id(),
        }
    }
}

impl<dt> RestoreOp<dt>
where dt: con,
{
    pub fn new(inner: Rc<Restore<dt>>) -> Self {
        Self{inner}
    }

    pub fn tensor(&self) -> Edge<dt> {
        Edge::<dt>::new(self.inner.clone(), 0)
    }
}

struct RestoreOp<dt>
where dt: con,
{
    inner: Rc<Restore<dt>>,
}

impl<dt> GraphOperation for Restore<dt>
where dt: con,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("Restore_{}")?
        };
        let mut new_op = graph.new_operation("Restore", &op_name)?;
        {
            match self.preferred_shard {
            }
            None => new_op.set_attr_value_proto("preferred_shard", &vec![24_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 1_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_int("preferred_shard", *attr)})(&value),
        };
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct Restore<dt>
where dt: con,
{
    file_pattern: Edge<String>,
    tensor_name: Edge<String>,
    preferred_shard: Option<i64>,
    id_: usize,
}

impl<dt> Restore<dt>
where dt: con,
{
    pub fn preferred_shard(&mut self, preferred_shard: int) -> &mut Self {
        self.preferred_shard = Some(preferred_shard);
        &self
    }

    pub fn finish(self) -> RestoreOp<dt> {
        RestoreOp::new(Rc::new(self))
    }

    pub fn new(file_pattern: Edge<String>, tensor_name: Edge<String>) -> Self {
        Self {
            file_pattern,
            tensor_name,
            preferred_shard: None,
            id_: new_id(),
        }
    }
}

impl<T> ResizeBilinearGradOp<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
{
    pub fn new(inner: Rc<ResizeBilinearGrad<T>>) -> Self {
        Self{inner}
    }

    pub fn output(&self) -> Edge<T> {
        Edge::<T>::new(self.inner.clone(), 0)
    }
}

struct ResizeBilinearGradOp<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
{
    inner: Rc<ResizeBilinearGrad<T>>,
}

impl<T> GraphOperation for ResizeBilinearGrad<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("ResizeBilinearGrad_{}")?
        };
        let mut new_op = graph.new_operation("ResizeBilinearGrad", &op_name)?;
        {
            match self.align_corners {
            }
            None => new_op.set_attr_value_proto("align_corners", &vec![40_u8, 0_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_bool("align_corners", *attr)})(&value),
        };
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct ResizeBilinearGrad<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
{
    grads: Edge<f32>,
    original_image: Edge<T>,
    align_corners: Option<bool>,
    id_: usize,
}

impl<T> ResizeBilinearGrad<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
{
    pub fn align_corners(&mut self, align_corners: bool) -> &mut Self {
        self.align_corners = Some(align_corners);
        &self
    }

    pub fn finish(self) -> ResizeBilinearGradOp<T> {
        ResizeBilinearGradOp::new(Rc::new(self))
    }

    pub fn new(grads: Edge<f32>, original_image: Edge<T>) -> Self {
        Self {
            grads,
            original_image,
            align_corners: None,
            id_: new_id(),
        }
    }
}

impl<T> CeilOp<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
{
    pub fn new(inner: Rc<Ceil<T>>) -> Self {
        Self{inner}
    }

    pub fn y(&self) -> Edge<T> {
        Edge::<T>::new(self.inner.clone(), 0)
    }
}

struct CeilOp<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
{
    inner: Rc<Ceil<T>>,
}

impl<T> GraphOperation for Ceil<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("Ceil_{}")?
        };
        let mut new_op = graph.new_operation("Ceil", &op_name)?;
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct Ceil<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
{
    x: Edge<T>,
    id_: usize,
}

impl<T> Ceil<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
{
    pub fn finish(self) -> CeilOp<T> {
        CeilOp::new(Rc::new(self))
    }

    pub fn new(x: Edge<T>) -> Self {
        Self {
            x,
            id_: new_id(),
        }
    }
}

impl<T> ResizeNearestNeighborOp<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_UINT16_or_DT_HALF,
{
    pub fn new(inner: Rc<ResizeNearestNeighbor<T>>) -> Self {
        Self{inner}
    }

    pub fn resized_images(&self) -> Edge<T> {
        Edge::<T>::new(self.inner.clone(), 0)
    }
}

struct ResizeNearestNeighborOp<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_UINT16_or_DT_HALF,
{
    inner: Rc<ResizeNearestNeighbor<T>>,
}

impl<T> GraphOperation for ResizeNearestNeighbor<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_UINT16_or_DT_HALF,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("ResizeNearestNeighbor_{}")?
        };
        let mut new_op = graph.new_operation("ResizeNearestNeighbor", &op_name)?;
        {
            match self.align_corners {
            }
            None => new_op.set_attr_value_proto("align_corners", &vec![40_u8, 0_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_bool("align_corners", *attr)})(&value),
        };
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct ResizeNearestNeighbor<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_UINT16_or_DT_HALF,
{
    images: Edge<T>,
    size: Edge<i32>,
    align_corners: Option<bool>,
    id_: usize,
}

impl<T> ResizeNearestNeighbor<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_UINT16_or_DT_HALF,
{
    pub fn align_corners(&mut self, align_corners: bool) -> &mut Self {
        self.align_corners = Some(align_corners);
        &self
    }

    pub fn finish(self) -> ResizeNearestNeighborOp<T> {
        ResizeNearestNeighborOp::new(Rc::new(self))
    }

    pub fn new(images: Edge<T>, size: Edge<i32>) -> Self {
        Self {
            images,
            size,
            align_corners: None,
            id_: new_id(),
        }
    }
}

pub trait con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64 for f32 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64 for f64 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64 for i16 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64 for i32 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64 for i64 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64 for i8 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64 for u8 {
}

impl<T> RandomCropOp<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64,
{
    pub fn new(inner: Rc<RandomCrop<T>>) -> Self {
        Self{inner}
    }

    pub fn output(&self) -> Edge<T> {
        Edge::<T>::new(self.inner.clone(), 0)
    }
}

struct RandomCropOp<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64,
{
    inner: Rc<RandomCrop<T>>,
}

impl<T> GraphOperation for RandomCrop<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("RandomCrop_{}")?
        };
        let mut new_op = graph.new_operation("RandomCrop", &op_name)?;
        {
            match self.seed {
            }
            None => new_op.set_attr_value_proto("seed", &vec![24_u8, 0_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_int("seed", *attr)})(&value),
        };
        {
            match self.seed2 {
            }
            None => new_op.set_attr_value_proto("seed2", &vec![24_u8, 0_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_int("seed2", *attr)})(&value),
        };
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct RandomCrop<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64,
{
    image: Edge<T>,
    size: Edge<i64>,
    seed: Option<i64>,
    seed2: Option<i64>,
    id_: usize,
}

impl<T> RandomCrop<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64,
{
    pub fn seed(&mut self, seed: int) -> &mut Self {
        self.seed = Some(seed);
        &self
    }

    pub fn seed2(&mut self, seed2: int) -> &mut Self {
        self.seed2 = Some(seed2);
        &self
    }

    pub fn finish(self) -> RandomCropOp<T> {
        RandomCropOp::new(Rc::new(self))
    }

    pub fn new(image: Edge<T>, size: Edge<i64>) -> Self {
        Self {
            image,
            size,
            seed: None,
            seed2: None,
            id_: new_id(),
        }
    }
}

impl<T> SerializeTensorOp<T>
where T: con,
{
    pub fn new(inner: Rc<SerializeTensor<T>>) -> Self {
        Self{inner}
    }

    pub fn serialized(&self) -> Edge<String> {
        Edge::<String>::new(self.inner.clone(), 0)
    }
}

struct SerializeTensorOp<T>
where T: con,
{
    inner: Rc<SerializeTensor<T>>,
}

impl<T> GraphOperation for SerializeTensor<T>
where T: con,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("SerializeTensor_{}")?
        };
        let mut new_op = graph.new_operation("SerializeTensor", &op_name)?;
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct SerializeTensor<T>
where T: con,
{
    tensor: Edge<T>,
    id_: usize,
}

impl<T> SerializeTensor<T>
where T: con,
{
    pub fn finish(self) -> SerializeTensorOp<T> {
        SerializeTensorOp::new(Rc::new(self))
    }

    pub fn new(tensor: Edge<T>) -> Self {
        Self {
            tensor,
            id_: new_id(),
        }
    }
}

impl<SrcT, DstT> _HostCastOp<SrcT, DstT>
where SrcT: con,
      DstT: con,
{
    pub fn new(inner: Rc<_HostCast<SrcT, DstT>>) -> Self {
        Self{inner}
    }

    pub fn y(&self) -> Edge<DstT> {
        Edge::<DstT>::new(self.inner.clone(), 0)
    }
}

struct _HostCastOp<SrcT, DstT>
where SrcT: con,
      DstT: con,
{
    inner: Rc<_HostCast<SrcT, DstT>>,
}

impl<SrcT, DstT> GraphOperation for _HostCast<SrcT, DstT>
where SrcT: con,
      DstT: con,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("_HostCast_{}")?
        };
        let mut new_op = graph.new_operation("_HostCast", &op_name)?;
        {
            match self.Truncate {
            }
            None => new_op.set_attr_value_proto("Truncate", &vec![40_u8, 0_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_bool("Truncate", *attr)})(&value),
        };
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct _HostCast<SrcT, DstT>
where SrcT: con,
      DstT: con,
{
    x: Edge<SrcT>,
    Truncate: Option<bool>,
    id_: usize,
}

impl<SrcT, DstT> _HostCast<SrcT, DstT>
where SrcT: con,
      DstT: con,
{
    pub fn Truncate(&mut self, Truncate: bool) -> &mut Self {
        self.Truncate = Some(Truncate);
        &self
    }

    pub fn finish(self) -> _HostCastOp<SrcT, DstT> {
        _HostCastOp::new(Rc::new(self))
    }

    pub fn new(x: Edge<SrcT>) -> Self {
        Self {
            x,
            Truncate: None,
            id_: new_id(),
        }
    }
}

impl<T, output_dtype> MultinomialOp<T, output_dtype>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      output_dtype: con_or_DT_INT32_or_DT_INT64,
{
    pub fn new(inner: Rc<Multinomial<T, output_dtype>>) -> Self {
        Self{inner}
    }

    pub fn output(&self) -> Edge<output_dtype> {
        Edge::<output_dtype>::new(self.inner.clone(), 0)
    }
}

struct MultinomialOp<T, output_dtype>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      output_dtype: con_or_DT_INT32_or_DT_INT64,
{
    inner: Rc<Multinomial<T, output_dtype>>,
}

impl<T, output_dtype> GraphOperation for Multinomial<T, output_dtype>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      output_dtype: con_or_DT_INT32_or_DT_INT64,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("Multinomial_{}")?
        };
        let mut new_op = graph.new_operation("Multinomial", &op_name)?;
        {
            match self.seed {
            }
            None => new_op.set_attr_value_proto("seed", &vec![24_u8, 0_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_int("seed", *attr)})(&value),
        };
        {
            match self.seed2 {
            }
            None => new_op.set_attr_value_proto("seed2", &vec![24_u8, 0_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_int("seed2", *attr)})(&value),
        };
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct Multinomial<T, output_dtype>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      output_dtype: con_or_DT_INT32_or_DT_INT64,
{
    logits: Edge<T>,
    num_samples: Edge<i32>,
    seed: Option<i64>,
    seed2: Option<i64>,
    id_: usize,
}

impl<T, output_dtype> Multinomial<T, output_dtype>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      output_dtype: con_or_DT_INT32_or_DT_INT64,
{
    pub fn seed(&mut self, seed: int) -> &mut Self {
        self.seed = Some(seed);
        &self
    }

    pub fn seed2(&mut self, seed2: int) -> &mut Self {
        self.seed2 = Some(seed2);
        &self
    }

    pub fn finish(self) -> MultinomialOp<T, output_dtype> {
        MultinomialOp::new(Rc::new(self))
    }

    pub fn new(logits: Edge<T>, num_samples: Edge<i32>) -> Self {
        Self {
            logits,
            num_samples,
            seed: None,
            seed2: None,
            id_: new_id(),
        }
    }
}

impl EncodeJpegOp {
    pub fn new(inner: Rc<EncodeJpeg>) -> Self {
        Self{inner}
    }

    pub fn contents(&self) -> Edge<String> {
        Edge::<String>::new(self.inner.clone(), 0)
    }
}

struct EncodeJpegOp {
    inner: Rc<EncodeJpeg>,
}

impl GraphOperation for EncodeJpeg {
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("EncodeJpeg_{}")?
        };
        let mut new_op = graph.new_operation("EncodeJpeg", &op_name)?;
        {
            match self.format {
            }
            None => new_op.set_attr_value_proto("format", &vec![18_u8, 0_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_string("format", attr)})(&value),
        };
        {
            match self.quality {
            }
            None => new_op.set_attr_value_proto("quality", &vec![24_u8, 95_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_int("quality", *attr)})(&value),
        };
        {
            match self.progressive {
            }
            None => new_op.set_attr_value_proto("progressive", &vec![40_u8, 0_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_bool("progressive", *attr)})(&value),
        };
        {
            match self.optimize_size {
            }
            None => new_op.set_attr_value_proto("optimize_size", &vec![40_u8, 0_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_bool("optimize_size", *attr)})(&value),
        };
        {
            match self.chroma_downsampling {
            }
            None => new_op.set_attr_value_proto("chroma_downsampling", &vec![40_u8, 1_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_bool("chroma_downsampling", *attr)})(&value),
        };
        {
            match self.density_unit {
            }
            None => new_op.set_attr_value_proto("density_unit", &vec![18_u8, 2_u8, 105_u8, 110_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_string("density_unit", attr)})(&value),
        };
        {
            match self.x_density {
            }
            None => new_op.set_attr_value_proto("x_density", &vec![24_u8, 172_u8, 2_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_int("x_density", *attr)})(&value),
        };
        {
            match self.y_density {
            }
            None => new_op.set_attr_value_proto("y_density", &vec![24_u8, 172_u8, 2_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_int("y_density", *attr)})(&value),
        };
        {
            match self.xmp_metadata {
            }
            None => new_op.set_attr_value_proto("xmp_metadata", &vec![18_u8, 0_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_string("xmp_metadata", attr)})(&value),
        };
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct EncodeJpeg {
    image: Edge<u8>,
    format: Option<String>,
    quality: Option<i64>,
    progressive: Option<bool>,
    optimize_size: Option<bool>,
    chroma_downsampling: Option<bool>,
    density_unit: Option<String>,
    x_density: Option<i64>,
    y_density: Option<i64>,
    xmp_metadata: Option<String>,
    id_: usize,
}

impl EncodeJpeg {
    pub fn format(&mut self, format: &str) -> &mut Self {
        self.format = Some(format.to_string());
        &self
    }

    pub fn quality(&mut self, quality: int) -> &mut Self {
        self.quality = Some(quality);
        &self
    }

    pub fn progressive(&mut self, progressive: bool) -> &mut Self {
        self.progressive = Some(progressive);
        &self
    }

    pub fn optimize_size(&mut self, optimize_size: bool) -> &mut Self {
        self.optimize_size = Some(optimize_size);
        &self
    }

    pub fn chroma_downsampling(&mut self, chroma_downsampling: bool) -> &mut Self {
        self.chroma_downsampling = Some(chroma_downsampling);
        &self
    }

    pub fn density_unit(&mut self, density_unit: &str) -> &mut Self {
        self.density_unit = Some(density_unit.to_string());
        &self
    }

    pub fn x_density(&mut self, x_density: int) -> &mut Self {
        self.x_density = Some(x_density);
        &self
    }

    pub fn y_density(&mut self, y_density: int) -> &mut Self {
        self.y_density = Some(y_density);
        &self
    }

    pub fn xmp_metadata(&mut self, xmp_metadata: &str) -> &mut Self {
        self.xmp_metadata = Some(xmp_metadata.to_string());
        &self
    }

    pub fn finish(self) -> EncodeJpegOp {
        EncodeJpegOp::new(Rc::new(self))
    }

    pub fn new(image: Edge<u8>) -> Self {
        Self {
            image,
            format: None,
            quality: None,
            progressive: None,
            optimize_size: None,
            chroma_downsampling: None,
            density_unit: None,
            x_density: None,
            y_density: None,
            xmp_metadata: None,
            id_: new_id(),
        }
    }
}

impl<T> BatchNormWithGlobalNormalizationGradOp<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
{
    pub fn new(inner: Rc<BatchNormWithGlobalNormalizationGrad<T>>) -> Self {
        Self{inner}
    }

    pub fn dx(&self) -> Edge<T> {
        Edge::<T>::new(self.inner.clone(), 0)
    }

    pub fn dm(&self) -> Edge<T> {
        Edge::<T>::new(self.inner.clone(), 1)
    }

    pub fn dv(&self) -> Edge<T> {
        Edge::<T>::new(self.inner.clone(), 2)
    }

    pub fn db(&self) -> Edge<T> {
        Edge::<T>::new(self.inner.clone(), 3)
    }

    pub fn dg(&self) -> Edge<T> {
        Edge::<T>::new(self.inner.clone(), 4)
    }
}

struct BatchNormWithGlobalNormalizationGradOp<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
{
    inner: Rc<BatchNormWithGlobalNormalizationGrad<T>>,
}

impl<T> GraphOperation for BatchNormWithGlobalNormalizationGrad<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("BatchNormWithGlobalNormalizationGrad_{}")?
        };
        let mut new_op = graph.new_operation("BatchNormWithGlobalNormalizationGrad", &op_name)?;
        {
            (|attr| {new_op.set_attr_float("variance_epsilon", *attr)})(&self.variance_epsilon)
        }
        {
            (|attr| {new_op.set_attr_bool("scale_after_normalization", *attr)})(&self.scale_after_normalization)
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct BatchNormWithGlobalNormalizationGrad<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
{
    t: Edge<T>,
    m: Edge<T>,
    v: Edge<T>,
    gamma: Edge<T>,
    backprop: Edge<T>,
    variance_epsilon: f32,
    scale_after_normalization: bool,
    id_: usize,
}

impl<T> BatchNormWithGlobalNormalizationGrad<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
{
    pub fn finish(self) -> BatchNormWithGlobalNormalizationGradOp<T> {
        BatchNormWithGlobalNormalizationGradOp::new(Rc::new(self))
    }

    pub fn new(t: Edge<T>, m: Edge<T>, v: Edge<T>, gamma: Edge<T>, backprop: Edge<T>, variance_epsilon: f32, scale_after_normalization: bool) -> Self {
        Self {
            t,
            m,
            v,
            gamma,
            backprop,
            variance_epsilon: variance_epsilon
            scale_after_normalization: scale_after_normalization
            id_: new_id(),
        }
    }
}

impl AdjustContrastv2Op {
    pub fn new(inner: Rc<AdjustContrastv2>) -> Self {
        Self{inner}
    }

    pub fn output(&self) -> Edge<f32> {
        Edge::<f32>::new(self.inner.clone(), 0)
    }
}

struct AdjustContrastv2Op {
    inner: Rc<AdjustContrastv2>,
}

impl GraphOperation for AdjustContrastv2 {
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("AdjustContrastv2_{}")?
        };
        let mut new_op = graph.new_operation("AdjustContrastv2", &op_name)?;
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct AdjustContrastv2 {
    images: Edge<f32>,
    contrast_factor: Edge<f32>,
    id_: usize,
}

impl AdjustContrastv2 {
    pub fn finish(self) -> AdjustContrastv2Op {
        AdjustContrastv2Op::new(Rc::new(self))
    }

    pub fn new(images: Edge<f32>, contrast_factor: Edge<f32>) -> Self {
        Self {
            images,
            contrast_factor,
            id_: new_id(),
        }
    }
}

pub trait con_or_DT_UINT8_or_DT_UINT16 {
}

impl con_or_DT_UINT8_or_DT_UINT16 for u16 {
}

impl con_or_DT_UINT8_or_DT_UINT16 for u8 {
}

impl<dtype> DecodePngOp<dtype>
where dtype: con_or_DT_UINT8_or_DT_UINT16,
{
    pub fn new(inner: Rc<DecodePng<dtype>>) -> Self {
        Self{inner}
    }

    pub fn image(&self) -> Edge<dtype> {
        Edge::<dtype>::new(self.inner.clone(), 0)
    }
}

struct DecodePngOp<dtype>
where dtype: con_or_DT_UINT8_or_DT_UINT16,
{
    inner: Rc<DecodePng<dtype>>,
}

impl<dtype> GraphOperation for DecodePng<dtype>
where dtype: con_or_DT_UINT8_or_DT_UINT16,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("DecodePng_{}")?
        };
        let mut new_op = graph.new_operation("DecodePng", &op_name)?;
        {
            match self.channels {
            }
            None => new_op.set_attr_value_proto("channels", &vec![24_u8, 0_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_int("channels", *attr)})(&value),
        };
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct DecodePng<dtype>
where dtype: con_or_DT_UINT8_or_DT_UINT16,
{
    contents: Edge<String>,
    channels: Option<i64>,
    id_: usize,
}

impl<dtype> DecodePng<dtype>
where dtype: con_or_DT_UINT8_or_DT_UINT16,
{
    pub fn channels(&mut self, channels: int) -> &mut Self {
        self.channels = Some(channels);
        &self
    }

    pub fn finish(self) -> DecodePngOp<dtype> {
        DecodePngOp::new(Rc::new(self))
    }

    pub fn new(contents: Edge<String>) -> Self {
        Self {
            contents,
            channels: None,
            id_: new_id(),
        }
    }
}

impl<T> ApplyProximalAdagradOp<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
{
    pub fn new(inner: Rc<ApplyProximalAdagrad<T>>) -> Self {
        Self{inner}
    }

    pub fn out(&self) -> Edge<T> {
        Edge::<T>::new(self.inner.clone(), 0)
    }
}

struct ApplyProximalAdagradOp<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
{
    inner: Rc<ApplyProximalAdagrad<T>>,
}

impl<T> GraphOperation for ApplyProximalAdagrad<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("ApplyProximalAdagrad_{}")?
        };
        let mut new_op = graph.new_operation("ApplyProximalAdagrad", &op_name)?;
        {
            match self.use_locking {
            }
            None => new_op.set_attr_value_proto("use_locking", &vec![40_u8, 0_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_bool("use_locking", *attr)})(&value),
        };
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct ApplyProximalAdagrad<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
{
    var: Edge<T>,
    accum: Edge<T>,
    lr: Edge<T>,
    l1: Edge<T>,
    l2: Edge<T>,
    grad: Edge<T>,
    use_locking: Option<bool>,
    id_: usize,
}

impl<T> ApplyProximalAdagrad<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
{
    pub fn use_locking(&mut self, use_locking: bool) -> &mut Self {
        self.use_locking = Some(use_locking);
        &self
    }

    pub fn finish(self) -> ApplyProximalAdagradOp<T> {
        ApplyProximalAdagradOp::new(Rc::new(self))
    }

    pub fn new(var: Edge<T>, accum: Edge<T>, lr: Edge<T>, l1: Edge<T>, l2: Edge<T>, grad: Edge<T>) -> Self {
        Self {
            var,
            accum,
            lr,
            l1,
            l2,
            grad,
            use_locking: None,
            id_: new_id(),
        }
    }
}

impl<T> BitwiseOrOp<T>
where T: con_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_UINT16_or_DT_UINT32_or_DT_UINT64,
{
    pub fn new(inner: Rc<BitwiseOr<T>>) -> Self {
        Self{inner}
    }

    pub fn z(&self) -> Edge<T> {
        Edge::<T>::new(self.inner.clone(), 0)
    }
}

struct BitwiseOrOp<T>
where T: con_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_UINT16_or_DT_UINT32_or_DT_UINT64,
{
    inner: Rc<BitwiseOr<T>>,
}

impl<T> GraphOperation for BitwiseOr<T>
where T: con_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_UINT16_or_DT_UINT32_or_DT_UINT64,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("BitwiseOr_{}")?
        };
        let mut new_op = graph.new_operation("BitwiseOr", &op_name)?;
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct BitwiseOr<T>
where T: con_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_UINT16_or_DT_UINT32_or_DT_UINT64,
{
    x: Edge<T>,
    y: Edge<T>,
    id_: usize,
}

impl<T> BitwiseOr<T>
where T: con_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_UINT16_or_DT_UINT32_or_DT_UINT64,
{
    pub fn finish(self) -> BitwiseOrOp<T> {
        BitwiseOrOp::new(Rc::new(self))
    }

    pub fn new(x: Edge<T>, y: Edge<T>) -> Self {
        Self {
            x,
            y,
            id_: new_id(),
        }
    }
}

impl<T> MatrixSolveLsOp<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_COMPLEX64_or_DT_COMPLEX128,
{
    pub fn new(inner: Rc<MatrixSolveLs<T>>) -> Self {
        Self{inner}
    }

    pub fn output(&self) -> Edge<T> {
        Edge::<T>::new(self.inner.clone(), 0)
    }
}

struct MatrixSolveLsOp<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_COMPLEX64_or_DT_COMPLEX128,
{
    inner: Rc<MatrixSolveLs<T>>,
}

impl<T> GraphOperation for MatrixSolveLs<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_COMPLEX64_or_DT_COMPLEX128,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("MatrixSolveLs_{}")?
        };
        let mut new_op = graph.new_operation("MatrixSolveLs", &op_name)?;
        {
            match self.fast {
            }
            None => new_op.set_attr_value_proto("fast", &vec![40_u8, 1_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_bool("fast", *attr)})(&value),
        };
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct MatrixSolveLs<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_COMPLEX64_or_DT_COMPLEX128,
{
    matrix: Edge<T>,
    rhs: Edge<T>,
    l2_regularizer: Edge<f64>,
    fast: Option<bool>,
    id_: usize,
}

impl<T> MatrixSolveLs<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_COMPLEX64_or_DT_COMPLEX128,
{
    pub fn fast(&mut self, fast: bool) -> &mut Self {
        self.fast = Some(fast);
        &self
    }

    pub fn finish(self) -> MatrixSolveLsOp<T> {
        MatrixSolveLsOp::new(Rc::new(self))
    }

    pub fn new(matrix: Edge<T>, rhs: Edge<T>, l2_regularizer: Edge<f64>) -> Self {
        Self {
            matrix,
            rhs,
            l2_regularizer,
            fast: None,
            id_: new_id(),
        }
    }
}

pub trait con_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64 {
}

impl con_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64 for i16 {
}

impl con_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64 for i32 {
}

impl con_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64 for i64 {
}

impl con_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64 for i8 {
}

impl con_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64 for u8 {
}

impl<T> SampleDistortedBoundingBoxOp<T>
where T: con_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64,
{
    pub fn new(inner: Rc<SampleDistortedBoundingBox<T>>) -> Self {
        Self{inner}
    }

    pub fn begin(&self) -> Edge<T> {
        Edge::<T>::new(self.inner.clone(), 0)
    }

    pub fn size(&self) -> Edge<T> {
        Edge::<T>::new(self.inner.clone(), 1)
    }

    pub fn bboxes(&self) -> Edge<f32> {
        Edge::<f32>::new(self.inner.clone(), 2)
    }
}

struct SampleDistortedBoundingBoxOp<T>
where T: con_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64,
{
    inner: Rc<SampleDistortedBoundingBox<T>>,
}

impl<T> GraphOperation for SampleDistortedBoundingBox<T>
where T: con_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("SampleDistortedBoundingBox_{}")?
        };
        let mut new_op = graph.new_operation("SampleDistortedBoundingBox", &op_name)?;
        {
            match self.seed {
            }
            None => new_op.set_attr_value_proto("seed", &vec![24_u8, 0_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_int("seed", *attr)})(&value),
        };
        {
            match self.seed2 {
            }
            None => new_op.set_attr_value_proto("seed2", &vec![24_u8, 0_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_int("seed2", *attr)})(&value),
        };
        {
            match self.min_object_covered {
            }
            None => new_op.set_attr_value_proto("min_object_covered", &vec![37_u8, 205_u8, 204_u8, 204_u8, 61_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_float("min_object_covered", *attr)})(&value),
        };
        {
            match self.aspect_ratio_range {
            }
            None => new_op.set_attr_value_proto("aspect_ratio_range", &vec![10_u8, 0_u8, 34_u8, 8_u8, 0_u8, 0_u8, 64_u8, 63_u8,]);,
            Some(value) => (|attrs| {new_op.set_attr_float_list("aspect_ratio_range", attrs)})(&value),
        };
        {
            match self.area_range {
            }
            None => new_op.set_attr_value_proto("area_range", &vec![10_u8, 0_u8, 34_u8, 8_u8, 205_u8, 204_u8, 76_u8, 61_u8,]);,
            Some(value) => (|attrs| {new_op.set_attr_float_list("area_range", attrs)})(&value),
        };
        {
            match self.max_attempts {
            }
            None => new_op.set_attr_value_proto("max_attempts", &vec![24_u8, 100_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_int("max_attempts", *attr)})(&value),
        };
        {
            match self.use_image_if_no_bounding_boxes {
            }
            None => new_op.set_attr_value_proto("use_image_if_no_bounding_boxes", &vec![40_u8, 0_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_bool("use_image_if_no_bounding_boxes", *attr)})(&value),
        };
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct SampleDistortedBoundingBox<T>
where T: con_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64,
{
    image_size: Edge<T>,
    bounding_boxes: Edge<f32>,
    seed: Option<i64>,
    seed2: Option<i64>,
    min_object_covered: Option<f32>,
    aspect_ratio_range: Option<Vec<f32>>,
    area_range: Option<Vec<f32>>,
    max_attempts: Option<i64>,
    use_image_if_no_bounding_boxes: Option<bool>,
    id_: usize,
}

impl<T> SampleDistortedBoundingBox<T>
where T: con_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64,
{
    pub fn seed(&mut self, seed: int) -> &mut Self {
        self.seed = Some(seed);
        &self
    }

    pub fn seed2(&mut self, seed2: int) -> &mut Self {
        self.seed2 = Some(seed2);
        &self
    }

    pub fn min_object_covered(&mut self, min_object_covered: f32) -> &mut Self {
        self.min_object_covered = Some(min_object_covered);
        &self
    }

    pub fn aspect_ratio_range(&mut self, aspect_ratio_range: &[f32]) -> &mut Self {
        self.aspect_ratio_range = Some(aspect_ratio_range.to_vec());
        &self
    }

    pub fn area_range(&mut self, area_range: &[f32]) -> &mut Self {
        self.area_range = Some(area_range.to_vec());
        &self
    }

    pub fn max_attempts(&mut self, max_attempts: int) -> &mut Self {
        self.max_attempts = Some(max_attempts);
        &self
    }

    pub fn use_image_if_no_bounding_boxes(&mut self, use_image_if_no_bounding_boxes: bool) -> &mut Self {
        self.use_image_if_no_bounding_boxes = Some(use_image_if_no_bounding_boxes);
        &self
    }

    pub fn finish(self) -> SampleDistortedBoundingBoxOp<T> {
        SampleDistortedBoundingBoxOp::new(Rc::new(self))
    }

    pub fn new(image_size: Edge<T>, bounding_boxes: Edge<f32>) -> Self {
        Self {
            image_size,
            bounding_boxes,
            seed: None,
            seed2: None,
            min_object_covered: None,
            aspect_ratio_range: None,
            area_range: None,
            max_attempts: None,
            use_image_if_no_bounding_boxes: None,
            id_: new_id(),
        }
    }
}

impl<T> GreaterOp<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
{
    pub fn new(inner: Rc<Greater<T>>) -> Self {
        Self{inner}
    }

    pub fn z(&self) -> Edge<bool> {
        Edge::<bool>::new(self.inner.clone(), 0)
    }
}

struct GreaterOp<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
{
    inner: Rc<Greater<T>>,
}

impl<T> GraphOperation for Greater<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("Greater_{}")?
        };
        let mut new_op = graph.new_operation("Greater", &op_name)?;
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct Greater<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
{
    x: Edge<T>,
    y: Edge<T>,
    id_: usize,
}

impl<T> Greater<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
{
    pub fn finish(self) -> GreaterOp<T> {
        GreaterOp::new(Rc::new(self))
    }

    pub fn new(x: Edge<T>, y: Edge<T>) -> Self {
        Self {
            x,
            y,
            id_: new_id(),
        }
    }
}

impl<T> SampleDistortedBoundingBoxV2Op<T>
where T: con_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64,
{
    pub fn new(inner: Rc<SampleDistortedBoundingBoxV2<T>>) -> Self {
        Self{inner}
    }

    pub fn begin(&self) -> Edge<T> {
        Edge::<T>::new(self.inner.clone(), 0)
    }

    pub fn size(&self) -> Edge<T> {
        Edge::<T>::new(self.inner.clone(), 1)
    }

    pub fn bboxes(&self) -> Edge<f32> {
        Edge::<f32>::new(self.inner.clone(), 2)
    }
}

struct SampleDistortedBoundingBoxV2Op<T>
where T: con_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64,
{
    inner: Rc<SampleDistortedBoundingBoxV2<T>>,
}

impl<T> GraphOperation for SampleDistortedBoundingBoxV2<T>
where T: con_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("SampleDistortedBoundingBoxV2_{}")?
        };
        let mut new_op = graph.new_operation("SampleDistortedBoundingBoxV2", &op_name)?;
        {
            match self.seed {
            }
            None => new_op.set_attr_value_proto("seed", &vec![24_u8, 0_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_int("seed", *attr)})(&value),
        };
        {
            match self.seed2 {
            }
            None => new_op.set_attr_value_proto("seed2", &vec![24_u8, 0_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_int("seed2", *attr)})(&value),
        };
        {
            match self.aspect_ratio_range {
            }
            None => new_op.set_attr_value_proto("aspect_ratio_range", &vec![10_u8, 0_u8, 34_u8, 8_u8, 0_u8, 0_u8, 64_u8, 63_u8,]);,
            Some(value) => (|attrs| {new_op.set_attr_float_list("aspect_ratio_range", attrs)})(&value),
        };
        {
            match self.area_range {
            }
            None => new_op.set_attr_value_proto("area_range", &vec![10_u8, 0_u8, 34_u8, 8_u8, 205_u8, 204_u8, 76_u8, 61_u8,]);,
            Some(value) => (|attrs| {new_op.set_attr_float_list("area_range", attrs)})(&value),
        };
        {
            match self.max_attempts {
            }
            None => new_op.set_attr_value_proto("max_attempts", &vec![24_u8, 100_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_int("max_attempts", *attr)})(&value),
        };
        {
            match self.use_image_if_no_bounding_boxes {
            }
            None => new_op.set_attr_value_proto("use_image_if_no_bounding_boxes", &vec![40_u8, 0_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_bool("use_image_if_no_bounding_boxes", *attr)})(&value),
        };
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct SampleDistortedBoundingBoxV2<T>
where T: con_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64,
{
    image_size: Edge<T>,
    bounding_boxes: Edge<f32>,
    min_object_covered: Edge<f32>,
    seed: Option<i64>,
    seed2: Option<i64>,
    aspect_ratio_range: Option<Vec<f32>>,
    area_range: Option<Vec<f32>>,
    max_attempts: Option<i64>,
    use_image_if_no_bounding_boxes: Option<bool>,
    id_: usize,
}

impl<T> SampleDistortedBoundingBoxV2<T>
where T: con_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64,
{
    pub fn seed(&mut self, seed: int) -> &mut Self {
        self.seed = Some(seed);
        &self
    }

    pub fn seed2(&mut self, seed2: int) -> &mut Self {
        self.seed2 = Some(seed2);
        &self
    }

    pub fn aspect_ratio_range(&mut self, aspect_ratio_range: &[f32]) -> &mut Self {
        self.aspect_ratio_range = Some(aspect_ratio_range.to_vec());
        &self
    }

    pub fn area_range(&mut self, area_range: &[f32]) -> &mut Self {
        self.area_range = Some(area_range.to_vec());
        &self
    }

    pub fn max_attempts(&mut self, max_attempts: int) -> &mut Self {
        self.max_attempts = Some(max_attempts);
        &self
    }

    pub fn use_image_if_no_bounding_boxes(&mut self, use_image_if_no_bounding_boxes: bool) -> &mut Self {
        self.use_image_if_no_bounding_boxes = Some(use_image_if_no_bounding_boxes);
        &self
    }

    pub fn finish(self) -> SampleDistortedBoundingBoxV2Op<T> {
        SampleDistortedBoundingBoxV2Op::new(Rc::new(self))
    }

    pub fn new(image_size: Edge<T>, bounding_boxes: Edge<f32>, min_object_covered: Edge<f32>) -> Self {
        Self {
            image_size,
            bounding_boxes,
            min_object_covered,
            seed: None,
            seed2: None,
            aspect_ratio_range: None,
            area_range: None,
            max_attempts: None,
            use_image_if_no_bounding_boxes: None,
            id_: new_id(),
        }
    }
}

impl<T> CropAndResizeOp<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_UINT16_or_DT_HALF,
{
    pub fn new(inner: Rc<CropAndResize<T>>) -> Self {
        Self{inner}
    }

    pub fn crops(&self) -> Edge<f32> {
        Edge::<f32>::new(self.inner.clone(), 0)
    }
}

struct CropAndResizeOp<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_UINT16_or_DT_HALF,
{
    inner: Rc<CropAndResize<T>>,
}

impl<T> GraphOperation for CropAndResize<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_UINT16_or_DT_HALF,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("CropAndResize_{}")?
        };
        let mut new_op = graph.new_operation("CropAndResize", &op_name)?;
        {
            match self.method {
            }
            None => new_op.set_attr_value_proto("method", &vec![18_u8, 8_u8, 98_u8, 105_u8, 108_u8, 105_u8, 110_u8, 101_u8, 97_u8, 114_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_string("method", attr)})(&value),
        };
        {
            match self.extrapolation_value {
            }
            None => new_op.set_attr_value_proto("extrapolation_value", &vec![37_u8, 0_u8, 0_u8, 0_u8, 0_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_float("extrapolation_value", *attr)})(&value),
        };
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct CropAndResize<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_UINT16_or_DT_HALF,
{
    image: Edge<T>,
    boxes: Edge<f32>,
    box_ind: Edge<i32>,
    crop_size: Edge<i32>,
    method: Option<String>,
    extrapolation_value: Option<f32>,
    id_: usize,
}

impl<T> CropAndResize<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_UINT16_or_DT_HALF,
{
    pub fn method(&mut self, method: &str) -> &mut Self {
        self.method = Some(method.to_string());
        &self
    }

    pub fn extrapolation_value(&mut self, extrapolation_value: f32) -> &mut Self {
        self.extrapolation_value = Some(extrapolation_value);
        &self
    }

    pub fn finish(self) -> CropAndResizeOp<T> {
        CropAndResizeOp::new(Rc::new(self))
    }

    pub fn new(image: Edge<T>, boxes: Edge<f32>, box_ind: Edge<i32>, crop_size: Edge<i32>) -> Self {
        Self {
            image,
            boxes,
            box_ind,
            crop_size,
            method: None,
            extrapolation_value: None,
            id_: new_id(),
        }
    }
}

impl<Tcomplex> FFT3DOp<Tcomplex>
where Tcomplex: con_or_DT_COMPLEX64_or_DT_COMPLEX128,
{
    pub fn new(inner: Rc<FFT3D<Tcomplex>>) -> Self {
        Self{inner}
    }

    pub fn output(&self) -> Edge<Tcomplex> {
        Edge::<Tcomplex>::new(self.inner.clone(), 0)
    }
}

struct FFT3DOp<Tcomplex>
where Tcomplex: con_or_DT_COMPLEX64_or_DT_COMPLEX128,
{
    inner: Rc<FFT3D<Tcomplex>>,
}

impl<Tcomplex> GraphOperation for FFT3D<Tcomplex>
where Tcomplex: con_or_DT_COMPLEX64_or_DT_COMPLEX128,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("FFT3D_{}")?
        };
        let mut new_op = graph.new_operation("FFT3D", &op_name)?;
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct FFT3D<Tcomplex>
where Tcomplex: con_or_DT_COMPLEX64_or_DT_COMPLEX128,
{
    input: Edge<Tcomplex>,
    id_: usize,
}

impl<Tcomplex> FFT3D<Tcomplex>
where Tcomplex: con_or_DT_COMPLEX64_or_DT_COMPLEX128,
{
    pub fn finish(self) -> FFT3DOp<Tcomplex> {
        FFT3DOp::new(Rc::new(self))
    }

    pub fn new(input: Edge<Tcomplex>) -> Self {
        Self {
            input,
            id_: new_id(),
        }
    }
}

impl<T> CropAndResizeGradBoxesOp<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_UINT16_or_DT_HALF,
{
    pub fn new(inner: Rc<CropAndResizeGradBoxes<T>>) -> Self {
        Self{inner}
    }

    pub fn output(&self) -> Edge<f32> {
        Edge::<f32>::new(self.inner.clone(), 0)
    }
}

struct CropAndResizeGradBoxesOp<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_UINT16_or_DT_HALF,
{
    inner: Rc<CropAndResizeGradBoxes<T>>,
}

impl<T> GraphOperation for CropAndResizeGradBoxes<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_UINT16_or_DT_HALF,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("CropAndResizeGradBoxes_{}")?
        };
        let mut new_op = graph.new_operation("CropAndResizeGradBoxes", &op_name)?;
        {
            match self.method {
            }
            None => new_op.set_attr_value_proto("method", &vec![18_u8, 8_u8, 98_u8, 105_u8, 108_u8, 105_u8, 110_u8, 101_u8, 97_u8, 114_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_string("method", attr)})(&value),
        };
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct CropAndResizeGradBoxes<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_UINT16_or_DT_HALF,
{
    grads: Edge<f32>,
    image: Edge<T>,
    boxes: Edge<f32>,
    box_ind: Edge<i32>,
    method: Option<String>,
    id_: usize,
}

impl<T> CropAndResizeGradBoxes<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_UINT16_or_DT_HALF,
{
    pub fn method(&mut self, method: &str) -> &mut Self {
        self.method = Some(method.to_string());
        &self
    }

    pub fn finish(self) -> CropAndResizeGradBoxesOp<T> {
        CropAndResizeGradBoxesOp::new(Rc::new(self))
    }

    pub fn new(grads: Edge<f32>, image: Edge<T>, boxes: Edge<f32>, box_ind: Edge<i32>) -> Self {
        Self {
            grads,
            image,
            boxes,
            box_ind,
            method: None,
            id_: new_id(),
        }
    }
}

impl<T> NonMaxSuppressionV3Op<T>
where T: con_or_DT_FLOAT_or_DT_HALF,
{
    pub fn new(inner: Rc<NonMaxSuppressionV3<T>>) -> Self {
        Self{inner}
    }

    pub fn selected_indices(&self) -> Edge<i32> {
        Edge::<i32>::new(self.inner.clone(), 0)
    }
}

struct NonMaxSuppressionV3Op<T>
where T: con_or_DT_FLOAT_or_DT_HALF,
{
    inner: Rc<NonMaxSuppressionV3<T>>,
}

impl<T> GraphOperation for NonMaxSuppressionV3<T>
where T: con_or_DT_FLOAT_or_DT_HALF,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("NonMaxSuppressionV3_{}")?
        };
        let mut new_op = graph.new_operation("NonMaxSuppressionV3", &op_name)?;
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct NonMaxSuppressionV3<T>
where T: con_or_DT_FLOAT_or_DT_HALF,
{
    boxes: Edge<T>,
    scores: Edge<T>,
    max_output_size: Edge<i32>,
    iou_threshold: Edge<f32>,
    score_threshold: Edge<f32>,
    id_: usize,
}

impl<T> NonMaxSuppressionV3<T>
where T: con_or_DT_FLOAT_or_DT_HALF,
{
    pub fn finish(self) -> NonMaxSuppressionV3Op<T> {
        NonMaxSuppressionV3Op::new(Rc::new(self))
    }

    pub fn new(boxes: Edge<T>, scores: Edge<T>, max_output_size: Edge<i32>, iou_threshold: Edge<f32>, score_threshold: Edge<f32>) -> Self {
        Self {
            boxes,
            scores,
            max_output_size,
            iou_threshold,
            score_threshold,
            id_: new_id(),
        }
    }
}

impl NoOpOp {
    pub fn new(inner: Rc<NoOp>) -> Self {
        Self{inner}
    }
}

struct NoOpOp {
    inner: Rc<NoOp>,
}

impl GraphOperation for NoOp {
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("NoOp_{}")?
        };
        let mut new_op = graph.new_operation("NoOp", &op_name)?;
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct NoOp {
    id_: usize,
}

impl NoOp {
    pub fn finish(self) -> NoOpOp {
        NoOpOp::new(Rc::new(self))
    }

    pub fn new() -> Self {
        Self {
            id_: new_id(),
        }
    }
}

impl MergeV2CheckpointsOp {
    pub fn new(inner: Rc<MergeV2Checkpoints>) -> Self {
        Self{inner}
    }
}

struct MergeV2CheckpointsOp {
    inner: Rc<MergeV2Checkpoints>,
}

impl GraphOperation for MergeV2Checkpoints {
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("MergeV2Checkpoints_{}")?
        };
        let mut new_op = graph.new_operation("MergeV2Checkpoints", &op_name)?;
        {
            match self.delete_old_dirs {
            }
            None => new_op.set_attr_value_proto("delete_old_dirs", &vec![40_u8, 1_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_bool("delete_old_dirs", *attr)})(&value),
        };
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct MergeV2Checkpoints {
    checkpoint_prefixes: Edge<String>,
    destination_prefix: Edge<String>,
    delete_old_dirs: Option<bool>,
    id_: usize,
}

impl MergeV2Checkpoints {
    pub fn delete_old_dirs(&mut self, delete_old_dirs: bool) -> &mut Self {
        self.delete_old_dirs = Some(delete_old_dirs);
        &self
    }

    pub fn finish(self) -> MergeV2CheckpointsOp {
        MergeV2CheckpointsOp::new(Rc::new(self))
    }

    pub fn new(checkpoint_prefixes: Edge<String>, destination_prefix: Edge<String>) -> Self {
        Self {
            checkpoint_prefixes,
            destination_prefix,
            delete_old_dirs: None,
            id_: new_id(),
        }
    }
}

impl ShardedFilespecOp {
    pub fn new(inner: Rc<ShardedFilespec>) -> Self {
        Self{inner}
    }

    pub fn filename(&self) -> Edge<String> {
        Edge::<String>::new(self.inner.clone(), 0)
    }
}

struct ShardedFilespecOp {
    inner: Rc<ShardedFilespec>,
}

impl GraphOperation for ShardedFilespec {
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("ShardedFilespec_{}")?
        };
        let mut new_op = graph.new_operation("ShardedFilespec", &op_name)?;
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct ShardedFilespec {
    basename: Edge<String>,
    num_shards: Edge<i32>,
    id_: usize,
}

impl ShardedFilespec {
    pub fn finish(self) -> ShardedFilespecOp {
        ShardedFilespecOp::new(Rc::new(self))
    }

    pub fn new(basename: Edge<String>, num_shards: Edge<i32>) -> Self {
        Self {
            basename,
            num_shards,
            id_: new_id(),
        }
    }
}

impl WholeFileReaderOp {
    pub fn new(inner: Rc<WholeFileReader>) -> Self {
        Self{inner}
    }

    pub fn reader_handle(&self) -> Edge<String> {
        Edge::<String>::new(self.inner.clone(), 0)
    }
}

struct WholeFileReaderOp {
    inner: Rc<WholeFileReader>,
}

impl GraphOperation for WholeFileReader {
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("WholeFileReader_{}")?
        };
        let mut new_op = graph.new_operation("WholeFileReader", &op_name)?;
        {
            match self.container {
            }
            None => new_op.set_attr_value_proto("container", &vec![18_u8, 0_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_string("container", attr)})(&value),
        };
        {
            match self.shared_name {
            }
            None => new_op.set_attr_value_proto("shared_name", &vec![18_u8, 0_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_string("shared_name", attr)})(&value),
        };
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct WholeFileReader {
    container: Option<String>,
    shared_name: Option<String>,
    id_: usize,
}

impl WholeFileReader {
    pub fn container(&mut self, container: &str) -> &mut Self {
        self.container = Some(container.to_string());
        &self
    }

    pub fn shared_name(&mut self, shared_name: &str) -> &mut Self {
        self.shared_name = Some(shared_name.to_string());
        &self
    }

    pub fn finish(self) -> WholeFileReaderOp {
        WholeFileReaderOp::new(Rc::new(self))
    }

    pub fn new() -> Self {
        Self {
            container: None,
            shared_name: None,
            id_: new_id(),
        }
    }
}

impl LoadAndRemapMatrixOp {
    pub fn new(inner: Rc<LoadAndRemapMatrix>) -> Self {
        Self{inner}
    }

    pub fn output_matrix(&self) -> Edge<f32> {
        Edge::<f32>::new(self.inner.clone(), 0)
    }
}

struct LoadAndRemapMatrixOp {
    inner: Rc<LoadAndRemapMatrix>,
}

impl GraphOperation for LoadAndRemapMatrix {
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("LoadAndRemapMatrix_{}")?
        };
        let mut new_op = graph.new_operation("LoadAndRemapMatrix", &op_name)?;
        {
            (|attr| {new_op.set_attr_int("num_rows", *attr)})(&self.num_rows)
        }
        {
            (|attr| {new_op.set_attr_int("num_cols", *attr)})(&self.num_cols)
        }
        {
            match self.max_rows_in_memory {
            }
            None => new_op.set_attr_value_proto("max_rows_in_memory", &vec![24_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 1_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_int("max_rows_in_memory", *attr)})(&value),
        };
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct LoadAndRemapMatrix {
    ckpt_path: Edge<String>,
    old_tensor_name: Edge<String>,
    row_remapping: Edge<i64>,
    col_remapping: Edge<i64>,
    initializing_values: Edge<f32>,
    num_rows: i64,
    num_cols: i64,
    max_rows_in_memory: Option<i64>,
    id_: usize,
}

impl LoadAndRemapMatrix {
    pub fn max_rows_in_memory(&mut self, max_rows_in_memory: int) -> &mut Self {
        self.max_rows_in_memory = Some(max_rows_in_memory);
        &self
    }

    pub fn finish(self) -> LoadAndRemapMatrixOp {
        LoadAndRemapMatrixOp::new(Rc::new(self))
    }

    pub fn new(ckpt_path: Edge<String>, old_tensor_name: Edge<String>, row_remapping: Edge<i64>, col_remapping: Edge<i64>, initializing_values: Edge<f32>, num_rows: int, num_cols: int) -> Self {
        Self {
            ckpt_path,
            old_tensor_name,
            row_remapping,
            col_remapping,
            initializing_values,
            num_rows: num_rows
            num_cols: num_cols
            max_rows_in_memory: None,
            id_: new_id(),
        }
    }
}

impl FixedLengthRecordReaderOp {
    pub fn new(inner: Rc<FixedLengthRecordReader>) -> Self {
        Self{inner}
    }

    pub fn reader_handle(&self) -> Edge<String> {
        Edge::<String>::new(self.inner.clone(), 0)
    }
}

struct FixedLengthRecordReaderOp {
    inner: Rc<FixedLengthRecordReader>,
}

impl GraphOperation for FixedLengthRecordReader {
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("FixedLengthRecordReader_{}")?
        };
        let mut new_op = graph.new_operation("FixedLengthRecordReader", &op_name)?;
        {
            match self.header_bytes {
            }
            None => new_op.set_attr_value_proto("header_bytes", &vec![24_u8, 0_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_int("header_bytes", *attr)})(&value),
        };
        {
            (|attr| {new_op.set_attr_int("record_bytes", *attr)})(&self.record_bytes)
        }
        {
            match self.footer_bytes {
            }
            None => new_op.set_attr_value_proto("footer_bytes", &vec![24_u8, 0_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_int("footer_bytes", *attr)})(&value),
        };
        {
            match self.hop_bytes {
            }
            None => new_op.set_attr_value_proto("hop_bytes", &vec![24_u8, 0_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_int("hop_bytes", *attr)})(&value),
        };
        {
            match self.container {
            }
            None => new_op.set_attr_value_proto("container", &vec![18_u8, 0_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_string("container", attr)})(&value),
        };
        {
            match self.shared_name {
            }
            None => new_op.set_attr_value_proto("shared_name", &vec![18_u8, 0_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_string("shared_name", attr)})(&value),
        };
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct FixedLengthRecordReader {
    header_bytes: Option<i64>,
    record_bytes: i64,
    footer_bytes: Option<i64>,
    hop_bytes: Option<i64>,
    container: Option<String>,
    shared_name: Option<String>,
    id_: usize,
}

impl FixedLengthRecordReader {
    pub fn header_bytes(&mut self, header_bytes: int) -> &mut Self {
        self.header_bytes = Some(header_bytes);
        &self
    }

    pub fn footer_bytes(&mut self, footer_bytes: int) -> &mut Self {
        self.footer_bytes = Some(footer_bytes);
        &self
    }

    pub fn hop_bytes(&mut self, hop_bytes: int) -> &mut Self {
        self.hop_bytes = Some(hop_bytes);
        &self
    }

    pub fn container(&mut self, container: &str) -> &mut Self {
        self.container = Some(container.to_string());
        &self
    }

    pub fn shared_name(&mut self, shared_name: &str) -> &mut Self {
        self.shared_name = Some(shared_name.to_string());
        &self
    }

    pub fn finish(self) -> FixedLengthRecordReaderOp {
        FixedLengthRecordReaderOp::new(Rc::new(self))
    }

    pub fn new(record_bytes: int) -> Self {
        Self {
            header_bytes: None,
            record_bytes: record_bytes
            footer_bytes: None,
            hop_bytes: None,
            container: None,
            shared_name: None,
            id_: new_id(),
        }
    }
}

impl<SrcT, DstT> CastOp<SrcT, DstT>
where SrcT: con,
      DstT: con,
{
    pub fn new(inner: Rc<Cast<SrcT, DstT>>) -> Self {
        Self{inner}
    }

    pub fn y(&self) -> Edge<DstT> {
        Edge::<DstT>::new(self.inner.clone(), 0)
    }
}

struct CastOp<SrcT, DstT>
where SrcT: con,
      DstT: con,
{
    inner: Rc<Cast<SrcT, DstT>>,
}

impl<SrcT, DstT> GraphOperation for Cast<SrcT, DstT>
where SrcT: con,
      DstT: con,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("Cast_{}")?
        };
        let mut new_op = graph.new_operation("Cast", &op_name)?;
        {
            match self.Truncate {
            }
            None => new_op.set_attr_value_proto("Truncate", &vec![40_u8, 0_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_bool("Truncate", *attr)})(&value),
        };
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct Cast<SrcT, DstT>
where SrcT: con,
      DstT: con,
{
    x: Edge<SrcT>,
    Truncate: Option<bool>,
    id_: usize,
}

impl<SrcT, DstT> Cast<SrcT, DstT>
where SrcT: con,
      DstT: con,
{
    pub fn Truncate(&mut self, Truncate: bool) -> &mut Self {
        self.Truncate = Some(Truncate);
        &self
    }

    pub fn finish(self) -> CastOp<SrcT, DstT> {
        CastOp::new(Rc::new(self))
    }

    pub fn new(x: Edge<SrcT>) -> Self {
        Self {
            x,
            Truncate: None,
            id_: new_id(),
        }
    }
}

impl TFRecordReaderOp {
    pub fn new(inner: Rc<TFRecordReader>) -> Self {
        Self{inner}
    }

    pub fn reader_handle(&self) -> Edge<String> {
        Edge::<String>::new(self.inner.clone(), 0)
    }
}

struct TFRecordReaderOp {
    inner: Rc<TFRecordReader>,
}

impl GraphOperation for TFRecordReader {
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("TFRecordReader_{}")?
        };
        let mut new_op = graph.new_operation("TFRecordReader", &op_name)?;
        {
            match self.container {
            }
            None => new_op.set_attr_value_proto("container", &vec![18_u8, 0_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_string("container", attr)})(&value),
        };
        {
            match self.shared_name {
            }
            None => new_op.set_attr_value_proto("shared_name", &vec![18_u8, 0_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_string("shared_name", attr)})(&value),
        };
        {
            match self.compression_type {
            }
            None => new_op.set_attr_value_proto("compression_type", &vec![18_u8, 0_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_string("compression_type", attr)})(&value),
        };
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct TFRecordReader {
    container: Option<String>,
    shared_name: Option<String>,
    compression_type: Option<String>,
    id_: usize,
}

impl TFRecordReader {
    pub fn container(&mut self, container: &str) -> &mut Self {
        self.container = Some(container.to_string());
        &self
    }

    pub fn shared_name(&mut self, shared_name: &str) -> &mut Self {
        self.shared_name = Some(shared_name.to_string());
        &self
    }

    pub fn compression_type(&mut self, compression_type: &str) -> &mut Self {
        self.compression_type = Some(compression_type.to_string());
        &self
    }

    pub fn finish(self) -> TFRecordReaderOp {
        TFRecordReaderOp::new(Rc::new(self))
    }

    pub fn new() -> Self {
        Self {
            container: None,
            shared_name: None,
            compression_type: None,
            id_: new_id(),
        }
    }
}

impl<T> SinhOp<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_COMPLEX64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF,
{
    pub fn new(inner: Rc<Sinh<T>>) -> Self {
        Self{inner}
    }

    pub fn y(&self) -> Edge<T> {
        Edge::<T>::new(self.inner.clone(), 0)
    }
}

struct SinhOp<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_COMPLEX64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF,
{
    inner: Rc<Sinh<T>>,
}

impl<T> GraphOperation for Sinh<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_COMPLEX64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("Sinh_{}")?
        };
        let mut new_op = graph.new_operation("Sinh", &op_name)?;
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct Sinh<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_COMPLEX64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF,
{
    x: Edge<T>,
    id_: usize,
}

impl<T> Sinh<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_COMPLEX64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF,
{
    pub fn finish(self) -> SinhOp<T> {
        SinhOp::new(Rc::new(self))
    }

    pub fn new(x: Edge<T>) -> Self {
        Self {
            x,
            id_: new_id(),
        }
    }
}

impl<T, Tidx> SparseSegmentSumOp<T, Tidx>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      Tidx: con_or_DT_INT32_or_DT_INT64,
{
    pub fn new(inner: Rc<SparseSegmentSum<T, Tidx>>) -> Self {
        Self{inner}
    }

    pub fn output(&self) -> Edge<T> {
        Edge::<T>::new(self.inner.clone(), 0)
    }
}

struct SparseSegmentSumOp<T, Tidx>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      Tidx: con_or_DT_INT32_or_DT_INT64,
{
    inner: Rc<SparseSegmentSum<T, Tidx>>,
}

impl<T, Tidx> GraphOperation for SparseSegmentSum<T, Tidx>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      Tidx: con_or_DT_INT32_or_DT_INT64,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("SparseSegmentSum_{}")?
        };
        let mut new_op = graph.new_operation("SparseSegmentSum", &op_name)?;
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct SparseSegmentSum<T, Tidx>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      Tidx: con_or_DT_INT32_or_DT_INT64,
{
    data: Edge<T>,
    indices: Edge<Tidx>,
    segment_ids: Edge<i32>,
    id_: usize,
}

impl<T, Tidx> SparseSegmentSum<T, Tidx>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      Tidx: con_or_DT_INT32_or_DT_INT64,
{
    pub fn finish(self) -> SparseSegmentSumOp<T, Tidx> {
        SparseSegmentSumOp::new(Rc::new(self))
    }

    pub fn new(data: Edge<T>, indices: Edge<Tidx>, segment_ids: Edge<i32>) -> Self {
        Self {
            data,
            indices,
            segment_ids,
            id_: new_id(),
        }
    }
}

impl LMDBReaderOp {
    pub fn new(inner: Rc<LMDBReader>) -> Self {
        Self{inner}
    }

    pub fn reader_handle(&self) -> Edge<String> {
        Edge::<String>::new(self.inner.clone(), 0)
    }
}

struct LMDBReaderOp {
    inner: Rc<LMDBReader>,
}

impl GraphOperation for LMDBReader {
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("LMDBReader_{}")?
        };
        let mut new_op = graph.new_operation("LMDBReader", &op_name)?;
        {
            match self.container {
            }
            None => new_op.set_attr_value_proto("container", &vec![18_u8, 0_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_string("container", attr)})(&value),
        };
        {
            match self.shared_name {
            }
            None => new_op.set_attr_value_proto("shared_name", &vec![18_u8, 0_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_string("shared_name", attr)})(&value),
        };
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct LMDBReader {
    container: Option<String>,
    shared_name: Option<String>,
    id_: usize,
}

impl LMDBReader {
    pub fn container(&mut self, container: &str) -> &mut Self {
        self.container = Some(container.to_string());
        &self
    }

    pub fn shared_name(&mut self, shared_name: &str) -> &mut Self {
        self.shared_name = Some(shared_name.to_string());
        &self
    }

    pub fn finish(self) -> LMDBReaderOp {
        LMDBReaderOp::new(Rc::new(self))
    }

    pub fn new() -> Self {
        Self {
            container: None,
            shared_name: None,
            id_: new_id(),
        }
    }
}

impl<S, R, dtype> RandomPoissonV2Op<S, R, dtype>
where S: con_or_DT_INT32_or_DT_INT64,
      R: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_INT64_or_DT_HALF,
      dtype: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_INT64_or_DT_HALF,
{
    pub fn new(inner: Rc<RandomPoissonV2<S, R, dtype>>) -> Self {
        Self{inner}
    }

    pub fn output(&self) -> Edge<dtype> {
        Edge::<dtype>::new(self.inner.clone(), 0)
    }
}

struct RandomPoissonV2Op<S, R, dtype>
where S: con_or_DT_INT32_or_DT_INT64,
      R: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_INT64_or_DT_HALF,
      dtype: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_INT64_or_DT_HALF,
{
    inner: Rc<RandomPoissonV2<S, R, dtype>>,
}

impl<S, R, dtype> GraphOperation for RandomPoissonV2<S, R, dtype>
where S: con_or_DT_INT32_or_DT_INT64,
      R: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_INT64_or_DT_HALF,
      dtype: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_INT64_or_DT_HALF,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("RandomPoissonV2_{}")?
        };
        let mut new_op = graph.new_operation("RandomPoissonV2", &op_name)?;
        {
            match self.seed {
            }
            None => new_op.set_attr_value_proto("seed", &vec![24_u8, 0_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_int("seed", *attr)})(&value),
        };
        {
            match self.seed2 {
            }
            None => new_op.set_attr_value_proto("seed2", &vec![24_u8, 0_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_int("seed2", *attr)})(&value),
        };
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct RandomPoissonV2<S, R, dtype>
where S: con_or_DT_INT32_or_DT_INT64,
      R: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_INT64_or_DT_HALF,
      dtype: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_INT64_or_DT_HALF,
{
    shape: Edge<S>,
    rate: Edge<R>,
    seed: Option<i64>,
    seed2: Option<i64>,
    id_: usize,
}

impl<S, R, dtype> RandomPoissonV2<S, R, dtype>
where S: con_or_DT_INT32_or_DT_INT64,
      R: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_INT64_or_DT_HALF,
      dtype: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_INT64_or_DT_HALF,
{
    pub fn seed(&mut self, seed: int) -> &mut Self {
        self.seed = Some(seed);
        &self
    }

    pub fn seed2(&mut self, seed2: int) -> &mut Self {
        self.seed2 = Some(seed2);
        &self
    }

    pub fn finish(self) -> RandomPoissonV2Op<S, R, dtype> {
        RandomPoissonV2Op::new(Rc::new(self))
    }

    pub fn new(shape: Edge<S>, rate: Edge<R>) -> Self {
        Self {
            shape,
            rate,
            seed: None,
            seed2: None,
            id_: new_id(),
        }
    }
}

impl RetrieveTPUEmbeddingRMSPropParametersGradAccumDebugOp {
    pub fn new(inner: Rc<RetrieveTPUEmbeddingRMSPropParametersGradAccumDebug>) -> Self {
        Self{inner}
    }

    pub fn parameters(&self) -> Edge<f32> {
        Edge::<f32>::new(self.inner.clone(), 0)
    }

    pub fn ms(&self) -> Edge<f32> {
        Edge::<f32>::new(self.inner.clone(), 1)
    }

    pub fn mom(&self) -> Edge<f32> {
        Edge::<f32>::new(self.inner.clone(), 2)
    }

    pub fn gradient_accumulators(&self) -> Edge<f32> {
        Edge::<f32>::new(self.inner.clone(), 3)
    }
}

struct RetrieveTPUEmbeddingRMSPropParametersGradAccumDebugOp {
    inner: Rc<RetrieveTPUEmbeddingRMSPropParametersGradAccumDebug>,
}

impl GraphOperation for RetrieveTPUEmbeddingRMSPropParametersGradAccumDebug {
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("RetrieveTPUEmbeddingRMSPropParametersGradAccumDebug_{}")?
        };
        let mut new_op = graph.new_operation("RetrieveTPUEmbeddingRMSPropParametersGradAccumDebug", &op_name)?;
        {
            match self.table_id {
            }
            None => new_op.set_attr_value_proto("table_id", &vec![24_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 1_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_int("table_id", *attr)})(&value),
        };
        {
            match self.table_name {
            }
            None => new_op.set_attr_value_proto("table_name", &vec![18_u8, 0_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_string("table_name", attr)})(&value),
        };
        {
            (|attr| {new_op.set_attr_int("num_shards", *attr)})(&self.num_shards)
        }
        {
            (|attr| {new_op.set_attr_int("shard_id", *attr)})(&self.shard_id)
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct RetrieveTPUEmbeddingRMSPropParametersGradAccumDebug {
    table_id: Option<i64>,
    table_name: Option<String>,
    num_shards: i64,
    shard_id: i64,
    id_: usize,
}

impl RetrieveTPUEmbeddingRMSPropParametersGradAccumDebug {
    pub fn table_id(&mut self, table_id: int) -> &mut Self {
        self.table_id = Some(table_id);
        &self
    }

    pub fn table_name(&mut self, table_name: &str) -> &mut Self {
        self.table_name = Some(table_name.to_string());
        &self
    }

    pub fn finish(self) -> RetrieveTPUEmbeddingRMSPropParametersGradAccumDebugOp {
        RetrieveTPUEmbeddingRMSPropParametersGradAccumDebugOp::new(Rc::new(self))
    }

    pub fn new(num_shards: int, shard_id: int) -> Self {
        Self {
            table_id: None,
            table_name: None,
            num_shards: num_shards
            shard_id: shard_id
            id_: new_id(),
        }
    }
}

impl IdentityReaderOp {
    pub fn new(inner: Rc<IdentityReader>) -> Self {
        Self{inner}
    }

    pub fn reader_handle(&self) -> Edge<String> {
        Edge::<String>::new(self.inner.clone(), 0)
    }
}

struct IdentityReaderOp {
    inner: Rc<IdentityReader>,
}

impl GraphOperation for IdentityReader {
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("IdentityReader_{}")?
        };
        let mut new_op = graph.new_operation("IdentityReader", &op_name)?;
        {
            match self.container {
            }
            None => new_op.set_attr_value_proto("container", &vec![18_u8, 0_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_string("container", attr)})(&value),
        };
        {
            match self.shared_name {
            }
            None => new_op.set_attr_value_proto("shared_name", &vec![18_u8, 0_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_string("shared_name", attr)})(&value),
        };
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct IdentityReader {
    container: Option<String>,
    shared_name: Option<String>,
    id_: usize,
}

impl IdentityReader {
    pub fn container(&mut self, container: &str) -> &mut Self {
        self.container = Some(container.to_string());
        &self
    }

    pub fn shared_name(&mut self, shared_name: &str) -> &mut Self {
        self.shared_name = Some(shared_name.to_string());
        &self
    }

    pub fn finish(self) -> IdentityReaderOp {
        IdentityReaderOp::new(Rc::new(self))
    }

    pub fn new() -> Self {
        Self {
            container: None,
            shared_name: None,
            id_: new_id(),
        }
    }
}

impl<T> QuantizeAndDequantizeV3Op<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
{
    pub fn new(inner: Rc<QuantizeAndDequantizeV3<T>>) -> Self {
        Self{inner}
    }

    pub fn output(&self) -> Edge<T> {
        Edge::<T>::new(self.inner.clone(), 0)
    }
}

struct QuantizeAndDequantizeV3Op<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
{
    inner: Rc<QuantizeAndDequantizeV3<T>>,
}

impl<T> GraphOperation for QuantizeAndDequantizeV3<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("QuantizeAndDequantizeV3_{}")?
        };
        let mut new_op = graph.new_operation("QuantizeAndDequantizeV3", &op_name)?;
        {
            match self.signed_input {
            }
            None => new_op.set_attr_value_proto("signed_input", &vec![40_u8, 1_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_bool("signed_input", *attr)})(&value),
        };
        {
            match self.range_given {
            }
            None => new_op.set_attr_value_proto("range_given", &vec![40_u8, 1_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_bool("range_given", *attr)})(&value),
        };
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct QuantizeAndDequantizeV3<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
{
    input: Edge<T>,
    input_min: Edge<T>,
    input_max: Edge<T>,
    num_bits: Edge<i32>,
    signed_input: Option<bool>,
    range_given: Option<bool>,
    id_: usize,
}

impl<T> QuantizeAndDequantizeV3<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
{
    pub fn signed_input(&mut self, signed_input: bool) -> &mut Self {
        self.signed_input = Some(signed_input);
        &self
    }

    pub fn range_given(&mut self, range_given: bool) -> &mut Self {
        self.range_given = Some(range_given);
        &self
    }

    pub fn finish(self) -> QuantizeAndDequantizeV3Op<T> {
        QuantizeAndDequantizeV3Op::new(Rc::new(self))
    }

    pub fn new(input: Edge<T>, input_min: Edge<T>, input_max: Edge<T>, num_bits: Edge<i32>) -> Self {
        Self {
            input,
            input_min,
            input_max,
            num_bits,
            signed_input: None,
            range_given: None,
            id_: new_id(),
        }
    }
}

impl ReaderReadOp {
    pub fn new(inner: Rc<ReaderRead>) -> Self {
        Self{inner}
    }

    pub fn key(&self) -> Edge<String> {
        Edge::<String>::new(self.inner.clone(), 0)
    }

    pub fn value(&self) -> Edge<String> {
        Edge::<String>::new(self.inner.clone(), 1)
    }
}

struct ReaderReadOp {
    inner: Rc<ReaderRead>,
}

impl GraphOperation for ReaderRead {
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("ReaderRead_{}")?
        };
        let mut new_op = graph.new_operation("ReaderRead", &op_name)?;
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct ReaderRead {
    reader_handle: Edge<String>,
    queue_handle: Edge<String>,
    id_: usize,
}

impl ReaderRead {
    pub fn finish(self) -> ReaderReadOp {
        ReaderReadOp::new(Rc::new(self))
    }

    pub fn new(reader_handle: Edge<String>, queue_handle: Edge<String>) -> Self {
        Self {
            reader_handle,
            queue_handle,
            id_: new_id(),
        }
    }
}

impl ReaderNumRecordsProducedOp {
    pub fn new(inner: Rc<ReaderNumRecordsProduced>) -> Self {
        Self{inner}
    }

    pub fn records_produced(&self) -> Edge<i64> {
        Edge::<i64>::new(self.inner.clone(), 0)
    }
}

struct ReaderNumRecordsProducedOp {
    inner: Rc<ReaderNumRecordsProduced>,
}

impl GraphOperation for ReaderNumRecordsProduced {
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("ReaderNumRecordsProduced_{}")?
        };
        let mut new_op = graph.new_operation("ReaderNumRecordsProduced", &op_name)?;
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct ReaderNumRecordsProduced {
    reader_handle: Edge<String>,
    id_: usize,
}

impl ReaderNumRecordsProduced {
    pub fn finish(self) -> ReaderNumRecordsProducedOp {
        ReaderNumRecordsProducedOp::new(Rc::new(self))
    }

    pub fn new(reader_handle: Edge<String>) -> Self {
        Self {
            reader_handle,
            id_: new_id(),
        }
    }
}

impl<T> TanOp<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_COMPLEX64_or_DT_INT64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF,
{
    pub fn new(inner: Rc<Tan<T>>) -> Self {
        Self{inner}
    }

    pub fn y(&self) -> Edge<T> {
        Edge::<T>::new(self.inner.clone(), 0)
    }
}

struct TanOp<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_COMPLEX64_or_DT_INT64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF,
{
    inner: Rc<Tan<T>>,
}

impl<T> GraphOperation for Tan<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_COMPLEX64_or_DT_INT64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("Tan_{}")?
        };
        let mut new_op = graph.new_operation("Tan", &op_name)?;
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct Tan<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_COMPLEX64_or_DT_INT64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF,
{
    x: Edge<T>,
    id_: usize,
}

impl<T> Tan<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_COMPLEX64_or_DT_INT64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF,
{
    pub fn finish(self) -> TanOp<T> {
        TanOp::new(Rc::new(self))
    }

    pub fn new(x: Edge<T>) -> Self {
        Self {
            x,
            id_: new_id(),
        }
    }
}

impl ReaderSerializeStateOp {
    pub fn new(inner: Rc<ReaderSerializeState>) -> Self {
        Self{inner}
    }

    pub fn state(&self) -> Edge<String> {
        Edge::<String>::new(self.inner.clone(), 0)
    }
}

struct ReaderSerializeStateOp {
    inner: Rc<ReaderSerializeState>,
}

impl GraphOperation for ReaderSerializeState {
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("ReaderSerializeState_{}")?
        };
        let mut new_op = graph.new_operation("ReaderSerializeState", &op_name)?;
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct ReaderSerializeState {
    reader_handle: Edge<String>,
    id_: usize,
}

impl ReaderSerializeState {
    pub fn finish(self) -> ReaderSerializeStateOp {
        ReaderSerializeStateOp::new(Rc::new(self))
    }

    pub fn new(reader_handle: Edge<String>) -> Self {
        Self {
            reader_handle,
            id_: new_id(),
        }
    }
}

impl<T> ExitOp<T>
where T: con,
{
    pub fn new(inner: Rc<Exit<T>>) -> Self {
        Self{inner}
    }

    pub fn output(&self) -> Edge<T> {
        Edge::<T>::new(self.inner.clone(), 0)
    }
}

struct ExitOp<T>
where T: con,
{
    inner: Rc<Exit<T>>,
}

impl<T> GraphOperation for Exit<T>
where T: con,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("Exit_{}")?
        };
        let mut new_op = graph.new_operation("Exit", &op_name)?;
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct Exit<T>
where T: con,
{
    data: Edge<T>,
    id_: usize,
}

impl<T> Exit<T>
where T: con,
{
    pub fn finish(self) -> ExitOp<T> {
        ExitOp::new(Rc::new(self))
    }

    pub fn new(data: Edge<T>) -> Self {
        Self {
            data,
            id_: new_id(),
        }
    }
}

impl RetrieveTPUEmbeddingProximalAdagradParametersOp {
    pub fn new(inner: Rc<RetrieveTPUEmbeddingProximalAdagradParameters>) -> Self {
        Self{inner}
    }

    pub fn parameters(&self) -> Edge<f32> {
        Edge::<f32>::new(self.inner.clone(), 0)
    }

    pub fn accumulators(&self) -> Edge<f32> {
        Edge::<f32>::new(self.inner.clone(), 1)
    }
}

struct RetrieveTPUEmbeddingProximalAdagradParametersOp {
    inner: Rc<RetrieveTPUEmbeddingProximalAdagradParameters>,
}

impl GraphOperation for RetrieveTPUEmbeddingProximalAdagradParameters {
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("RetrieveTPUEmbeddingProximalAdagradParameters_{}")?
        };
        let mut new_op = graph.new_operation("RetrieveTPUEmbeddingProximalAdagradParameters", &op_name)?;
        {
            match self.table_id {
            }
            None => new_op.set_attr_value_proto("table_id", &vec![24_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 1_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_int("table_id", *attr)})(&value),
        };
        {
            match self.table_name {
            }
            None => new_op.set_attr_value_proto("table_name", &vec![18_u8, 0_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_string("table_name", attr)})(&value),
        };
        {
            (|attr| {new_op.set_attr_int("num_shards", *attr)})(&self.num_shards)
        }
        {
            (|attr| {new_op.set_attr_int("shard_id", *attr)})(&self.shard_id)
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct RetrieveTPUEmbeddingProximalAdagradParameters {
    table_id: Option<i64>,
    table_name: Option<String>,
    num_shards: i64,
    shard_id: i64,
    id_: usize,
}

impl RetrieveTPUEmbeddingProximalAdagradParameters {
    pub fn table_id(&mut self, table_id: int) -> &mut Self {
        self.table_id = Some(table_id);
        &self
    }

    pub fn table_name(&mut self, table_name: &str) -> &mut Self {
        self.table_name = Some(table_name.to_string());
        &self
    }

    pub fn finish(self) -> RetrieveTPUEmbeddingProximalAdagradParametersOp {
        RetrieveTPUEmbeddingProximalAdagradParametersOp::new(Rc::new(self))
    }

    pub fn new(num_shards: int, shard_id: int) -> Self {
        Self {
            table_id: None,
            table_name: None,
            num_shards: num_shards
            shard_id: shard_id
            id_: new_id(),
        }
    }
}

impl<T> MaxPoolGradV2Op<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
{
    pub fn new(inner: Rc<MaxPoolGradV2<T>>) -> Self {
        Self{inner}
    }

    pub fn output(&self) -> Edge<T> {
        Edge::<T>::new(self.inner.clone(), 0)
    }
}

struct MaxPoolGradV2Op<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
{
    inner: Rc<MaxPoolGradV2<T>>,
}

impl<T> GraphOperation for MaxPoolGradV2<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("MaxPoolGradV2_{}")?
        };
        let mut new_op = graph.new_operation("MaxPoolGradV2", &op_name)?;
        {
            (|attr| {new_op.set_attr_string("padding", attr)})(&self.padding)
        }
        {
            match self.data_format {
            }
            None => new_op.set_attr_value_proto("data_format", &vec![18_u8, 4_u8, 78_u8, 72_u8, 87_u8, 67_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_string("data_format", attr)})(&value),
        };
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct MaxPoolGradV2<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
{
    orig_input: Edge<T>,
    orig_output: Edge<T>,
    grad: Edge<T>,
    ksize: Edge<i32>,
    strides: Edge<i32>,
    padding: String,
    data_format: Option<String>,
    id_: usize,
}

impl<T> MaxPoolGradV2<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
{
    pub fn data_format(&mut self, data_format: &str) -> &mut Self {
        self.data_format = Some(data_format.to_string());
        &self
    }

    pub fn finish(self) -> MaxPoolGradV2Op<T> {
        MaxPoolGradV2Op::new(Rc::new(self))
    }

    pub fn new(orig_input: Edge<T>, orig_output: Edge<T>, grad: Edge<T>, ksize: Edge<i32>, strides: Edge<i32>, padding: &str) -> Self {
        Self {
            orig_input,
            orig_output,
            grad,
            ksize,
            strides,
            padding: padding.to_string()
            data_format: None,
            id_: new_id(),
        }
    }
}

impl<dtype> AccumulatorApplyGradientOp<dtype>
where dtype: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
{
    pub fn new(inner: Rc<AccumulatorApplyGradient<dtype>>) -> Self {
        Self{inner}
    }
}

struct AccumulatorApplyGradientOp<dtype>
where dtype: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
{
    inner: Rc<AccumulatorApplyGradient<dtype>>,
}

impl<dtype> GraphOperation for AccumulatorApplyGradient<dtype>
where dtype: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("AccumulatorApplyGradient_{}")?
        };
        let mut new_op = graph.new_operation("AccumulatorApplyGradient", &op_name)?;
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct AccumulatorApplyGradient<dtype>
where dtype: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
{
    handle: Edge<String>,
    local_step: Edge<i64>,
    gradient: Edge<dtype>,
    id_: usize,
}

impl<dtype> AccumulatorApplyGradient<dtype>
where dtype: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
{
    pub fn finish(self) -> AccumulatorApplyGradientOp<dtype> {
        AccumulatorApplyGradientOp::new(Rc::new(self))
    }

    pub fn new(handle: Edge<String>, local_step: Edge<i64>, gradient: Edge<dtype>) -> Self {
        Self {
            handle,
            local_step,
            gradient,
            id_: new_id(),
        }
    }
}

impl<T> AbsOp<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_INT64_or_DT_BFLOAT16_or_DT_HALF,
{
    pub fn new(inner: Rc<Abs<T>>) -> Self {
        Self{inner}
    }

    pub fn y(&self) -> Edge<T> {
        Edge::<T>::new(self.inner.clone(), 0)
    }
}

struct AbsOp<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_INT64_or_DT_BFLOAT16_or_DT_HALF,
{
    inner: Rc<Abs<T>>,
}

impl<T> GraphOperation for Abs<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_INT64_or_DT_BFLOAT16_or_DT_HALF,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("Abs_{}")?
        };
        let mut new_op = graph.new_operation("Abs", &op_name)?;
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct Abs<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_INT64_or_DT_BFLOAT16_or_DT_HALF,
{
    x: Edge<T>,
    id_: usize,
}

impl<T> Abs<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_INT64_or_DT_BFLOAT16_or_DT_HALF,
{
    pub fn finish(self) -> AbsOp<T> {
        AbsOp::new(Rc::new(self))
    }

    pub fn new(x: Edge<T>) -> Self {
        Self {
            x,
            id_: new_id(),
        }
    }
}

impl<T> CholeskyOp<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_COMPLEX64_or_DT_COMPLEX128,
{
    pub fn new(inner: Rc<Cholesky<T>>) -> Self {
        Self{inner}
    }

    pub fn output(&self) -> Edge<T> {
        Edge::<T>::new(self.inner.clone(), 0)
    }
}

struct CholeskyOp<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_COMPLEX64_or_DT_COMPLEX128,
{
    inner: Rc<Cholesky<T>>,
}

impl<T> GraphOperation for Cholesky<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_COMPLEX64_or_DT_COMPLEX128,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("Cholesky_{}")?
        };
        let mut new_op = graph.new_operation("Cholesky", &op_name)?;
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct Cholesky<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_COMPLEX64_or_DT_COMPLEX128,
{
    input: Edge<T>,
    id_: usize,
}

impl<T> Cholesky<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_COMPLEX64_or_DT_COMPLEX128,
{
    pub fn finish(self) -> CholeskyOp<T> {
        CholeskyOp::new(Rc::new(self))
    }

    pub fn new(input: Edge<T>) -> Self {
        Self {
            input,
            id_: new_id(),
        }
    }
}

impl<T, Tindices> SparseApplyProximalGradientDescentOp<T, Tindices>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      Tindices: con_or_DT_INT32_or_DT_INT64,
{
    pub fn new(inner: Rc<SparseApplyProximalGradientDescent<T, Tindices>>) -> Self {
        Self{inner}
    }

    pub fn out(&self) -> Edge<T> {
        Edge::<T>::new(self.inner.clone(), 0)
    }
}

struct SparseApplyProximalGradientDescentOp<T, Tindices>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      Tindices: con_or_DT_INT32_or_DT_INT64,
{
    inner: Rc<SparseApplyProximalGradientDescent<T, Tindices>>,
}

impl<T, Tindices> GraphOperation for SparseApplyProximalGradientDescent<T, Tindices>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      Tindices: con_or_DT_INT32_or_DT_INT64,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("SparseApplyProximalGradientDescent_{}")?
        };
        let mut new_op = graph.new_operation("SparseApplyProximalGradientDescent", &op_name)?;
        {
            match self.use_locking {
            }
            None => new_op.set_attr_value_proto("use_locking", &vec![40_u8, 0_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_bool("use_locking", *attr)})(&value),
        };
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct SparseApplyProximalGradientDescent<T, Tindices>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      Tindices: con_or_DT_INT32_or_DT_INT64,
{
    var: Edge<T>,
    alpha: Edge<T>,
    l1: Edge<T>,
    l2: Edge<T>,
    grad: Edge<T>,
    indices: Edge<Tindices>,
    use_locking: Option<bool>,
    id_: usize,
}

impl<T, Tindices> SparseApplyProximalGradientDescent<T, Tindices>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      Tindices: con_or_DT_INT32_or_DT_INT64,
{
    pub fn use_locking(&mut self, use_locking: bool) -> &mut Self {
        self.use_locking = Some(use_locking);
        &self
    }

    pub fn finish(self) -> SparseApplyProximalGradientDescentOp<T, Tindices> {
        SparseApplyProximalGradientDescentOp::new(Rc::new(self))
    }

    pub fn new(var: Edge<T>, alpha: Edge<T>, l1: Edge<T>, l2: Edge<T>, grad: Edge<T>, indices: Edge<Tindices>) -> Self {
        Self {
            var,
            alpha,
            l1,
            l2,
            grad,
            indices,
            use_locking: None,
            id_: new_id(),
        }
    }
}

impl MatchingFilesOp {
    pub fn new(inner: Rc<MatchingFiles>) -> Self {
        Self{inner}
    }

    pub fn filenames(&self) -> Edge<String> {
        Edge::<String>::new(self.inner.clone(), 0)
    }
}

struct MatchingFilesOp {
    inner: Rc<MatchingFiles>,
}

impl GraphOperation for MatchingFiles {
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("MatchingFiles_{}")?
        };
        let mut new_op = graph.new_operation("MatchingFiles", &op_name)?;
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct MatchingFiles {
    pattern: Edge<String>,
    id_: usize,
}

impl MatchingFiles {
    pub fn finish(self) -> MatchingFilesOp {
        MatchingFilesOp::new(Rc::new(self))
    }

    pub fn new(pattern: Edge<String>) -> Self {
        Self {
            pattern,
            id_: new_id(),
        }
    }
}

impl BigQueryReaderOp {
    pub fn new(inner: Rc<BigQueryReader>) -> Self {
        Self{inner}
    }

    pub fn reader_handle(&self) -> Edge<String> {
        Edge::<String>::new(self.inner.clone(), 0)
    }
}

struct BigQueryReaderOp {
    inner: Rc<BigQueryReader>,
}

impl GraphOperation for BigQueryReader {
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("BigQueryReader_{}")?
        };
        let mut new_op = graph.new_operation("BigQueryReader", &op_name)?;
        {
            match self.container {
            }
            None => new_op.set_attr_value_proto("container", &vec![18_u8, 0_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_string("container", attr)})(&value),
        };
        {
            match self.shared_name {
            }
            None => new_op.set_attr_value_proto("shared_name", &vec![18_u8, 0_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_string("shared_name", attr)})(&value),
        };
        {
            (|attr| {new_op.set_attr_string("project_id", attr)})(&self.project_id)
        }
        {
            (|attr| {new_op.set_attr_string("dataset_id", attr)})(&self.dataset_id)
        }
        {
            (|attr| {new_op.set_attr_string("table_id", attr)})(&self.table_id)
        }
        {
            (|attrs| {new_op.set_attr_string_list("columns", attrs)})(&self.columns)
        }
        {
            (|attr| {new_op.set_attr_int("timestamp_millis", *attr)})(&self.timestamp_millis)
        }
        {
            match self.test_end_point {
            }
            None => new_op.set_attr_value_proto("test_end_point", &vec![18_u8, 0_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_string("test_end_point", attr)})(&value),
        };
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct BigQueryReader {
    container: Option<String>,
    shared_name: Option<String>,
    project_id: String,
    dataset_id: String,
    table_id: String,
    columns: Vec<String>,
    timestamp_millis: i64,
    test_end_point: Option<String>,
    id_: usize,
}

impl BigQueryReader {
    pub fn container(&mut self, container: &str) -> &mut Self {
        self.container = Some(container.to_string());
        &self
    }

    pub fn shared_name(&mut self, shared_name: &str) -> &mut Self {
        self.shared_name = Some(shared_name.to_string());
        &self
    }

    pub fn test_end_point(&mut self, test_end_point: &str) -> &mut Self {
        self.test_end_point = Some(test_end_point.to_string());
        &self
    }

    pub fn finish(self) -> BigQueryReaderOp {
        BigQueryReaderOp::new(Rc::new(self))
    }

    pub fn new(project_id: &str, dataset_id: &str, table_id: &str, columns: &[String], timestamp_millis: int) -> Self {
        Self {
            container: None,
            shared_name: None,
            project_id: project_id.to_string()
            dataset_id: dataset_id.to_string()
            table_id: table_id.to_string()
            columns: columns.to_vec()
            timestamp_millis: timestamp_millis
            test_end_point: None,
            id_: new_id(),
        }
    }
}

impl<T> MatrixDeterminantOp<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_COMPLEX64_or_DT_COMPLEX128,
{
    pub fn new(inner: Rc<MatrixDeterminant<T>>) -> Self {
        Self{inner}
    }

    pub fn output(&self) -> Edge<T> {
        Edge::<T>::new(self.inner.clone(), 0)
    }
}

struct MatrixDeterminantOp<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_COMPLEX64_or_DT_COMPLEX128,
{
    inner: Rc<MatrixDeterminant<T>>,
}

impl<T> GraphOperation for MatrixDeterminant<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_COMPLEX64_or_DT_COMPLEX128,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("MatrixDeterminant_{}")?
        };
        let mut new_op = graph.new_operation("MatrixDeterminant", &op_name)?;
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct MatrixDeterminant<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_COMPLEX64_or_DT_COMPLEX128,
{
    input: Edge<T>,
    id_: usize,
}

impl<T> MatrixDeterminant<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_COMPLEX64_or_DT_COMPLEX128,
{
    pub fn finish(self) -> MatrixDeterminantOp<T> {
        MatrixDeterminantOp::new(Rc::new(self))
    }

    pub fn new(input: Edge<T>) -> Self {
        Self {
            input,
            id_: new_id(),
        }
    }
}

impl<T> MatrixInverseOp<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_COMPLEX64_or_DT_COMPLEX128,
{
    pub fn new(inner: Rc<MatrixInverse<T>>) -> Self {
        Self{inner}
    }

    pub fn output(&self) -> Edge<T> {
        Edge::<T>::new(self.inner.clone(), 0)
    }
}

struct MatrixInverseOp<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_COMPLEX64_or_DT_COMPLEX128,
{
    inner: Rc<MatrixInverse<T>>,
}

impl<T> GraphOperation for MatrixInverse<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_COMPLEX64_or_DT_COMPLEX128,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("MatrixInverse_{}")?
        };
        let mut new_op = graph.new_operation("MatrixInverse", &op_name)?;
        {
            match self.adjoint {
            }
            None => new_op.set_attr_value_proto("adjoint", &vec![40_u8, 0_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_bool("adjoint", *attr)})(&value),
        };
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct MatrixInverse<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_COMPLEX64_or_DT_COMPLEX128,
{
    input: Edge<T>,
    adjoint: Option<bool>,
    id_: usize,
}

impl<T> MatrixInverse<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_COMPLEX64_or_DT_COMPLEX128,
{
    pub fn adjoint(&mut self, adjoint: bool) -> &mut Self {
        self.adjoint = Some(adjoint);
        &self
    }

    pub fn finish(self) -> MatrixInverseOp<T> {
        MatrixInverseOp::new(Rc::new(self))
    }

    pub fn new(input: Edge<T>) -> Self {
        Self {
            input,
            adjoint: None,
            id_: new_id(),
        }
    }
}

impl<dtype> GetSessionTensorOp<dtype>
where dtype: con,
{
    pub fn new(inner: Rc<GetSessionTensor<dtype>>) -> Self {
        Self{inner}
    }

    pub fn value(&self) -> Edge<dtype> {
        Edge::<dtype>::new(self.inner.clone(), 0)
    }
}

struct GetSessionTensorOp<dtype>
where dtype: con,
{
    inner: Rc<GetSessionTensor<dtype>>,
}

impl<dtype> GraphOperation for GetSessionTensor<dtype>
where dtype: con,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("GetSessionTensor_{}")?
        };
        let mut new_op = graph.new_operation("GetSessionTensor", &op_name)?;
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct GetSessionTensor<dtype>
where dtype: con,
{
    handle: Edge<String>,
    id_: usize,
}

impl<dtype> GetSessionTensor<dtype>
where dtype: con,
{
    pub fn finish(self) -> GetSessionTensorOp<dtype> {
        GetSessionTensorOp::new(Rc::new(self))
    }

    pub fn new(handle: Edge<String>) -> Self {
        Self {
            handle,
            id_: new_id(),
        }
    }
}

impl<T> SqrtGradOp<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_COMPLEX64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF,
{
    pub fn new(inner: Rc<SqrtGrad<T>>) -> Self {
        Self{inner}
    }

    pub fn z(&self) -> Edge<T> {
        Edge::<T>::new(self.inner.clone(), 0)
    }
}

struct SqrtGradOp<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_COMPLEX64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF,
{
    inner: Rc<SqrtGrad<T>>,
}

impl<T> GraphOperation for SqrtGrad<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_COMPLEX64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("SqrtGrad_{}")?
        };
        let mut new_op = graph.new_operation("SqrtGrad", &op_name)?;
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct SqrtGrad<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_COMPLEX64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF,
{
    y: Edge<T>,
    dy: Edge<T>,
    id_: usize,
}

impl<T> SqrtGrad<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_COMPLEX64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF,
{
    pub fn finish(self) -> SqrtGradOp<T> {
        SqrtGradOp::new(Rc::new(self))
    }

    pub fn new(y: Edge<T>, dy: Edge<T>) -> Self {
        Self {
            y,
            dy,
            id_: new_id(),
        }
    }
}

pub trait con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_INT64_or_DT_BFLOAT16 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_INT64_or_DT_BFLOAT16 for BFloat16 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_INT64_or_DT_BFLOAT16 for f32 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_INT64_or_DT_BFLOAT16 for f64 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_INT64_or_DT_BFLOAT16 for i32 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_INT64_or_DT_BFLOAT16 for i64 {
}

impl<T> RaggedRangeOp<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_INT64_or_DT_BFLOAT16,
{
    pub fn new(inner: Rc<RaggedRange<T>>) -> Self {
        Self{inner}
    }

    pub fn rt_nested_splits(&self) -> Edge<i64> {
        Edge::<i64>::new(self.inner.clone(), 0)
    }

    pub fn rt_dense_values(&self) -> Edge<T> {
        Edge::<T>::new(self.inner.clone(), 1)
    }
}

struct RaggedRangeOp<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_INT64_or_DT_BFLOAT16,
{
    inner: Rc<RaggedRange<T>>,
}

impl<T> GraphOperation for RaggedRange<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_INT64_or_DT_BFLOAT16,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("RaggedRange_{}")?
        };
        let mut new_op = graph.new_operation("RaggedRange", &op_name)?;
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct RaggedRange<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_INT64_or_DT_BFLOAT16,
{
    starts: Edge<T>,
    limits: Edge<T>,
    deltas: Edge<T>,
    id_: usize,
}

impl<T> RaggedRange<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_INT64_or_DT_BFLOAT16,
{
    pub fn finish(self) -> RaggedRangeOp<T> {
        RaggedRangeOp::new(Rc::new(self))
    }

    pub fn new(starts: Edge<T>, limits: Edge<T>, deltas: Edge<T>) -> Self {
        Self {
            starts,
            limits,
            deltas,
            id_: new_id(),
        }
    }
}

impl<T> MatrixExponentialOp<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_COMPLEX64_or_DT_COMPLEX128,
{
    pub fn new(inner: Rc<MatrixExponential<T>>) -> Self {
        Self{inner}
    }

    pub fn output(&self) -> Edge<T> {
        Edge::<T>::new(self.inner.clone(), 0)
    }
}

struct MatrixExponentialOp<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_COMPLEX64_or_DT_COMPLEX128,
{
    inner: Rc<MatrixExponential<T>>,
}

impl<T> GraphOperation for MatrixExponential<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_COMPLEX64_or_DT_COMPLEX128,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("MatrixExponential_{}")?
        };
        let mut new_op = graph.new_operation("MatrixExponential", &op_name)?;
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct MatrixExponential<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_COMPLEX64_or_DT_COMPLEX128,
{
    input: Edge<T>,
    id_: usize,
}

impl<T> MatrixExponential<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_COMPLEX64_or_DT_COMPLEX128,
{
    pub fn finish(self) -> MatrixExponentialOp<T> {
        MatrixExponentialOp::new(Rc::new(self))
    }

    pub fn new(input: Edge<T>) -> Self {
        Self {
            input,
            id_: new_id(),
        }
    }
}

impl<Tidx> AllOp<Tidx>
where Tidx: con_or_DT_INT32_or_DT_INT64,
{
    pub fn new(inner: Rc<All<Tidx>>) -> Self {
        Self{inner}
    }

    pub fn output(&self) -> Edge<bool> {
        Edge::<bool>::new(self.inner.clone(), 0)
    }
}

struct AllOp<Tidx>
where Tidx: con_or_DT_INT32_or_DT_INT64,
{
    inner: Rc<All<Tidx>>,
}

impl<Tidx> GraphOperation for All<Tidx>
where Tidx: con_or_DT_INT32_or_DT_INT64,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("All_{}")?
        };
        let mut new_op = graph.new_operation("All", &op_name)?;
        {
            match self.keep_dims {
            }
            None => new_op.set_attr_value_proto("keep_dims", &vec![40_u8, 0_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_bool("keep_dims", *attr)})(&value),
        };
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct All<Tidx>
where Tidx: con_or_DT_INT32_or_DT_INT64,
{
    input: Edge<bool>,
    reduction_indices: Edge<Tidx>,
    keep_dims: Option<bool>,
    id_: usize,
}

impl<Tidx> All<Tidx>
where Tidx: con_or_DT_INT32_or_DT_INT64,
{
    pub fn keep_dims(&mut self, keep_dims: bool) -> &mut Self {
        self.keep_dims = Some(keep_dims);
        &self
    }

    pub fn finish(self) -> AllOp<Tidx> {
        AllOp::new(Rc::new(self))
    }

    pub fn new(input: Edge<bool>, reduction_indices: Edge<Tidx>) -> Self {
        Self {
            input,
            reduction_indices,
            keep_dims: None,
            id_: new_id(),
        }
    }
}

impl<T> SelfAdjointEigOp<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE,
{
    pub fn new(inner: Rc<SelfAdjointEig<T>>) -> Self {
        Self{inner}
    }

    pub fn output(&self) -> Edge<T> {
        Edge::<T>::new(self.inner.clone(), 0)
    }
}

struct SelfAdjointEigOp<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE,
{
    inner: Rc<SelfAdjointEig<T>>,
}

impl<T> GraphOperation for SelfAdjointEig<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("SelfAdjointEig_{}")?
        };
        let mut new_op = graph.new_operation("SelfAdjointEig", &op_name)?;
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct SelfAdjointEig<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE,
{
    input: Edge<T>,
    id_: usize,
}

impl<T> SelfAdjointEig<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE,
{
    pub fn finish(self) -> SelfAdjointEigOp<T> {
        SelfAdjointEigOp::new(Rc::new(self))
    }

    pub fn new(input: Edge<T>) -> Self {
        Self {
            input,
            id_: new_id(),
        }
    }
}

impl<T> BatchSelfAdjointEigV2Op<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE,
{
    pub fn new(inner: Rc<BatchSelfAdjointEigV2<T>>) -> Self {
        Self{inner}
    }

    pub fn e(&self) -> Edge<T> {
        Edge::<T>::new(self.inner.clone(), 0)
    }

    pub fn v(&self) -> Edge<T> {
        Edge::<T>::new(self.inner.clone(), 1)
    }
}

struct BatchSelfAdjointEigV2Op<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE,
{
    inner: Rc<BatchSelfAdjointEigV2<T>>,
}

impl<T> GraphOperation for BatchSelfAdjointEigV2<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("BatchSelfAdjointEigV2_{}")?
        };
        let mut new_op = graph.new_operation("BatchSelfAdjointEigV2", &op_name)?;
        {
            match self.compute_v {
            }
            None => new_op.set_attr_value_proto("compute_v", &vec![40_u8, 1_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_bool("compute_v", *attr)})(&value),
        };
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct BatchSelfAdjointEigV2<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE,
{
    input: Edge<T>,
    compute_v: Option<bool>,
    id_: usize,
}

impl<T> BatchSelfAdjointEigV2<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE,
{
    pub fn compute_v(&mut self, compute_v: bool) -> &mut Self {
        self.compute_v = Some(compute_v);
        &self
    }

    pub fn finish(self) -> BatchSelfAdjointEigV2Op<T> {
        BatchSelfAdjointEigV2Op::new(Rc::new(self))
    }

    pub fn new(input: Edge<T>) -> Self {
        Self {
            input,
            compute_v: None,
            id_: new_id(),
        }
    }
}

impl<T> SvdOp<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_COMPLEX64_or_DT_COMPLEX128,
{
    pub fn new(inner: Rc<Svd<T>>) -> Self {
        Self{inner}
    }

    pub fn s(&self) -> Edge<T> {
        Edge::<T>::new(self.inner.clone(), 0)
    }

    pub fn u(&self) -> Edge<T> {
        Edge::<T>::new(self.inner.clone(), 1)
    }

    pub fn v(&self) -> Edge<T> {
        Edge::<T>::new(self.inner.clone(), 2)
    }
}

struct SvdOp<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_COMPLEX64_or_DT_COMPLEX128,
{
    inner: Rc<Svd<T>>,
}

impl<T> GraphOperation for Svd<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_COMPLEX64_or_DT_COMPLEX128,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("Svd_{}")?
        };
        let mut new_op = graph.new_operation("Svd", &op_name)?;
        {
            match self.compute_uv {
            }
            None => new_op.set_attr_value_proto("compute_uv", &vec![40_u8, 1_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_bool("compute_uv", *attr)})(&value),
        };
        {
            match self.full_matrices {
            }
            None => new_op.set_attr_value_proto("full_matrices", &vec![40_u8, 0_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_bool("full_matrices", *attr)})(&value),
        };
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct Svd<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_COMPLEX64_or_DT_COMPLEX128,
{
    input: Edge<T>,
    compute_uv: Option<bool>,
    full_matrices: Option<bool>,
    id_: usize,
}

impl<T> Svd<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_COMPLEX64_or_DT_COMPLEX128,
{
    pub fn compute_uv(&mut self, compute_uv: bool) -> &mut Self {
        self.compute_uv = Some(compute_uv);
        &self
    }

    pub fn full_matrices(&mut self, full_matrices: bool) -> &mut Self {
        self.full_matrices = Some(full_matrices);
        &self
    }

    pub fn finish(self) -> SvdOp<T> {
        SvdOp::new(Rc::new(self))
    }

    pub fn new(input: Edge<T>) -> Self {
        Self {
            input,
            compute_uv: None,
            full_matrices: None,
            id_: new_id(),
        }
    }
}

impl<T> BatchSelfAdjointEigOp<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE,
{
    pub fn new(inner: Rc<BatchSelfAdjointEig<T>>) -> Self {
        Self{inner}
    }

    pub fn output(&self) -> Edge<T> {
        Edge::<T>::new(self.inner.clone(), 0)
    }
}

struct BatchSelfAdjointEigOp<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE,
{
    inner: Rc<BatchSelfAdjointEig<T>>,
}

impl<T> GraphOperation for BatchSelfAdjointEig<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("BatchSelfAdjointEig_{}")?
        };
        let mut new_op = graph.new_operation("BatchSelfAdjointEig", &op_name)?;
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct BatchSelfAdjointEig<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE,
{
    input: Edge<T>,
    id_: usize,
}

impl<T> BatchSelfAdjointEig<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE,
{
    pub fn finish(self) -> BatchSelfAdjointEigOp<T> {
        BatchSelfAdjointEigOp::new(Rc::new(self))
    }

    pub fn new(input: Edge<T>) -> Self {
        Self {
            input,
            id_: new_id(),
        }
    }
}

impl<T> BatchMatrixSolveOp<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE,
{
    pub fn new(inner: Rc<BatchMatrixSolve<T>>) -> Self {
        Self{inner}
    }

    pub fn output(&self) -> Edge<T> {
        Edge::<T>::new(self.inner.clone(), 0)
    }
}

struct BatchMatrixSolveOp<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE,
{
    inner: Rc<BatchMatrixSolve<T>>,
}

impl<T> GraphOperation for BatchMatrixSolve<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("BatchMatrixSolve_{}")?
        };
        let mut new_op = graph.new_operation("BatchMatrixSolve", &op_name)?;
        {
            match self.adjoint {
            }
            None => new_op.set_attr_value_proto("adjoint", &vec![40_u8, 0_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_bool("adjoint", *attr)})(&value),
        };
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct BatchMatrixSolve<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE,
{
    matrix: Edge<T>,
    rhs: Edge<T>,
    adjoint: Option<bool>,
    id_: usize,
}

impl<T> BatchMatrixSolve<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE,
{
    pub fn adjoint(&mut self, adjoint: bool) -> &mut Self {
        self.adjoint = Some(adjoint);
        &self
    }

    pub fn finish(self) -> BatchMatrixSolveOp<T> {
        BatchMatrixSolveOp::new(Rc::new(self))
    }

    pub fn new(matrix: Edge<T>, rhs: Edge<T>) -> Self {
        Self {
            matrix,
            rhs,
            adjoint: None,
            id_: new_id(),
        }
    }
}

impl<T> BatchMatrixSolveLsOp<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE,
{
    pub fn new(inner: Rc<BatchMatrixSolveLs<T>>) -> Self {
        Self{inner}
    }

    pub fn output(&self) -> Edge<T> {
        Edge::<T>::new(self.inner.clone(), 0)
    }
}

struct BatchMatrixSolveLsOp<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE,
{
    inner: Rc<BatchMatrixSolveLs<T>>,
}

impl<T> GraphOperation for BatchMatrixSolveLs<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("BatchMatrixSolveLs_{}")?
        };
        let mut new_op = graph.new_operation("BatchMatrixSolveLs", &op_name)?;
        {
            match self.fast {
            }
            None => new_op.set_attr_value_proto("fast", &vec![40_u8, 1_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_bool("fast", *attr)})(&value),
        };
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct BatchMatrixSolveLs<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE,
{
    matrix: Edge<T>,
    rhs: Edge<T>,
    l2_regularizer: Edge<f64>,
    fast: Option<bool>,
    id_: usize,
}

impl<T> BatchMatrixSolveLs<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE,
{
    pub fn fast(&mut self, fast: bool) -> &mut Self {
        self.fast = Some(fast);
        &self
    }

    pub fn finish(self) -> BatchMatrixSolveLsOp<T> {
        BatchMatrixSolveLsOp::new(Rc::new(self))
    }

    pub fn new(matrix: Edge<T>, rhs: Edge<T>, l2_regularizer: Edge<f64>) -> Self {
        Self {
            matrix,
            rhs,
            l2_regularizer,
            fast: None,
            id_: new_id(),
        }
    }
}

impl<T> RGBToHSVOp<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
{
    pub fn new(inner: Rc<RGBToHSV<T>>) -> Self {
        Self{inner}
    }

    pub fn output(&self) -> Edge<T> {
        Edge::<T>::new(self.inner.clone(), 0)
    }
}

struct RGBToHSVOp<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
{
    inner: Rc<RGBToHSV<T>>,
}

impl<T> GraphOperation for RGBToHSV<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("RGBToHSV_{}")?
        };
        let mut new_op = graph.new_operation("RGBToHSV", &op_name)?;
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct RGBToHSV<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
{
    images: Edge<T>,
    id_: usize,
}

impl<T> RGBToHSV<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
{
    pub fn finish(self) -> RGBToHSVOp<T> {
        RGBToHSVOp::new(Rc::new(self))
    }

    pub fn new(images: Edge<T>) -> Self {
        Self {
            images,
            id_: new_id(),
        }
    }
}

impl<T> BatchSvdOp<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_COMPLEX64_or_DT_COMPLEX128,
{
    pub fn new(inner: Rc<BatchSvd<T>>) -> Self {
        Self{inner}
    }

    pub fn s(&self) -> Edge<T> {
        Edge::<T>::new(self.inner.clone(), 0)
    }

    pub fn u(&self) -> Edge<T> {
        Edge::<T>::new(self.inner.clone(), 1)
    }

    pub fn v(&self) -> Edge<T> {
        Edge::<T>::new(self.inner.clone(), 2)
    }
}

struct BatchSvdOp<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_COMPLEX64_or_DT_COMPLEX128,
{
    inner: Rc<BatchSvd<T>>,
}

impl<T> GraphOperation for BatchSvd<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_COMPLEX64_or_DT_COMPLEX128,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("BatchSvd_{}")?
        };
        let mut new_op = graph.new_operation("BatchSvd", &op_name)?;
        {
            match self.compute_uv {
            }
            None => new_op.set_attr_value_proto("compute_uv", &vec![40_u8, 1_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_bool("compute_uv", *attr)})(&value),
        };
        {
            match self.full_matrices {
            }
            None => new_op.set_attr_value_proto("full_matrices", &vec![40_u8, 0_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_bool("full_matrices", *attr)})(&value),
        };
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct BatchSvd<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_COMPLEX64_or_DT_COMPLEX128,
{
    input: Edge<T>,
    compute_uv: Option<bool>,
    full_matrices: Option<bool>,
    id_: usize,
}

impl<T> BatchSvd<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_COMPLEX64_or_DT_COMPLEX128,
{
    pub fn compute_uv(&mut self, compute_uv: bool) -> &mut Self {
        self.compute_uv = Some(compute_uv);
        &self
    }

    pub fn full_matrices(&mut self, full_matrices: bool) -> &mut Self {
        self.full_matrices = Some(full_matrices);
        &self
    }

    pub fn finish(self) -> BatchSvdOp<T> {
        BatchSvdOp::new(Rc::new(self))
    }

    pub fn new(input: Edge<T>) -> Self {
        Self {
            input,
            compute_uv: None,
            full_matrices: None,
            id_: new_id(),
        }
    }
}

impl<Tcomplex> IFFT3DOp<Tcomplex>
where Tcomplex: con_or_DT_COMPLEX64_or_DT_COMPLEX128,
{
    pub fn new(inner: Rc<IFFT3D<Tcomplex>>) -> Self {
        Self{inner}
    }

    pub fn output(&self) -> Edge<Tcomplex> {
        Edge::<Tcomplex>::new(self.inner.clone(), 0)
    }
}

struct IFFT3DOp<Tcomplex>
where Tcomplex: con_or_DT_COMPLEX64_or_DT_COMPLEX128,
{
    inner: Rc<IFFT3D<Tcomplex>>,
}

impl<Tcomplex> GraphOperation for IFFT3D<Tcomplex>
where Tcomplex: con_or_DT_COMPLEX64_or_DT_COMPLEX128,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("IFFT3D_{}")?
        };
        let mut new_op = graph.new_operation("IFFT3D", &op_name)?;
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct IFFT3D<Tcomplex>
where Tcomplex: con_or_DT_COMPLEX64_or_DT_COMPLEX128,
{
    input: Edge<Tcomplex>,
    id_: usize,
}

impl<Tcomplex> IFFT3D<Tcomplex>
where Tcomplex: con_or_DT_COMPLEX64_or_DT_COMPLEX128,
{
    pub fn finish(self) -> IFFT3DOp<Tcomplex> {
        IFFT3DOp::new(Rc::new(self))
    }

    pub fn new(input: Edge<Tcomplex>) -> Self {
        Self {
            input,
            id_: new_id(),
        }
    }
}

impl<T> InvertOp<T>
where T: con_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_UINT16_or_DT_UINT32_or_DT_UINT64,
{
    pub fn new(inner: Rc<Invert<T>>) -> Self {
        Self{inner}
    }

    pub fn y(&self) -> Edge<T> {
        Edge::<T>::new(self.inner.clone(), 0)
    }
}

struct InvertOp<T>
where T: con_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_UINT16_or_DT_UINT32_or_DT_UINT64,
{
    inner: Rc<Invert<T>>,
}

impl<T> GraphOperation for Invert<T>
where T: con_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_UINT16_or_DT_UINT32_or_DT_UINT64,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("Invert_{}")?
        };
        let mut new_op = graph.new_operation("Invert", &op_name)?;
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct Invert<T>
where T: con_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_UINT16_or_DT_UINT32_or_DT_UINT64,
{
    x: Edge<T>,
    id_: usize,
}

impl<T> Invert<T>
where T: con_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_UINT16_or_DT_UINT32_or_DT_UINT64,
{
    pub fn finish(self) -> InvertOp<T> {
        InvertOp::new(Rc::new(self))
    }

    pub fn new(x: Edge<T>) -> Self {
        Self {
            x,
            id_: new_id(),
        }
    }
}

impl<T> DequantizeOp<T>
where T: con_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_QINT16_or_DT_QUINT16,
{
    pub fn new(inner: Rc<Dequantize<T>>) -> Self {
        Self{inner}
    }

    pub fn output(&self) -> Edge<f32> {
        Edge::<f32>::new(self.inner.clone(), 0)
    }
}

struct DequantizeOp<T>
where T: con_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_QINT16_or_DT_QUINT16,
{
    inner: Rc<Dequantize<T>>,
}

impl<T> GraphOperation for Dequantize<T>
where T: con_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_QINT16_or_DT_QUINT16,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("Dequantize_{}")?
        };
        let mut new_op = graph.new_operation("Dequantize", &op_name)?;
        {
            match self.mode {
            }
            None => new_op.set_attr_value_proto("mode", &vec![18_u8, 12_u8, 77_u8, 73_u8, 78_u8, 95_u8, 67_u8, 79_u8, 77_u8, 66_u8, 73_u8, 78_u8, 69_u8, 68_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_string("mode", attr)})(&value),
        };
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct Dequantize<T>
where T: con_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_QINT16_or_DT_QUINT16,
{
    input: Edge<T>,
    min_range: Edge<f32>,
    max_range: Edge<f32>,
    mode: Option<String>,
    id_: usize,
}

impl<T> Dequantize<T>
where T: con_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_QINT16_or_DT_QUINT16,
{
    pub fn mode(&mut self, mode: &str) -> &mut Self {
        self.mode = Some(mode.to_string());
        &self
    }

    pub fn finish(self) -> DequantizeOp<T> {
        DequantizeOp::new(Rc::new(self))
    }

    pub fn new(input: Edge<T>, min_range: Edge<f32>, max_range: Edge<f32>) -> Self {
        Self {
            input,
            min_range,
            max_range,
            mode: None,
            id_: new_id(),
        }
    }
}

impl<key_dtype, value_dtype> MutableHashTableOfTensorsOp<key_dtype, value_dtype>
where key_dtype: con,
      value_dtype: con,
{
    pub fn new(inner: Rc<MutableHashTableOfTensors<key_dtype, value_dtype>>) -> Self {
        Self{inner}
    }

    pub fn table_handle(&self) -> Edge<String> {
        Edge::<String>::new(self.inner.clone(), 0)
    }
}

struct MutableHashTableOfTensorsOp<key_dtype, value_dtype>
where key_dtype: con,
      value_dtype: con,
{
    inner: Rc<MutableHashTableOfTensors<key_dtype, value_dtype>>,
}

impl<key_dtype, value_dtype> GraphOperation for MutableHashTableOfTensors<key_dtype, value_dtype>
where key_dtype: con,
      value_dtype: con,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("MutableHashTableOfTensors_{}")?
        };
        let mut new_op = graph.new_operation("MutableHashTableOfTensors", &op_name)?;
        {
            match self.container {
            }
            None => new_op.set_attr_value_proto("container", &vec![18_u8, 0_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_string("container", attr)})(&value),
        };
        {
            match self.shared_name {
            }
            None => new_op.set_attr_value_proto("shared_name", &vec![18_u8, 0_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_string("shared_name", attr)})(&value),
        };
        {
            match self.use_node_name_sharing {
            }
            None => new_op.set_attr_value_proto("use_node_name_sharing", &vec![40_u8, 0_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_bool("use_node_name_sharing", *attr)})(&value),
        };
        {
            match self.value_shape {
            }
            None => new_op.set_attr_value_proto("value_shape", &vec![58_u8, 0_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_shape("value_shape", attr)})(&value),
        };
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct MutableHashTableOfTensors<key_dtype, value_dtype>
where key_dtype: con,
      value_dtype: con,
{
    container: Option<String>,
    shared_name: Option<String>,
    use_node_name_sharing: Option<bool>,
    value_shape: Option<Shape>,
    id_: usize,
}

impl<key_dtype, value_dtype> MutableHashTableOfTensors<key_dtype, value_dtype>
where key_dtype: con,
      value_dtype: con,
{
    pub fn container(&mut self, container: &str) -> &mut Self {
        self.container = Some(container.to_string());
        &self
    }

    pub fn shared_name(&mut self, shared_name: &str) -> &mut Self {
        self.shared_name = Some(shared_name.to_string());
        &self
    }

    pub fn use_node_name_sharing(&mut self, use_node_name_sharing: bool) -> &mut Self {
        self.use_node_name_sharing = Some(use_node_name_sharing);
        &self
    }

    pub fn value_shape(&mut self, value_shape: &Shape) -> &mut Self {
        self.value_shape = Some(value_shape.clone());
        &self
    }

    pub fn finish(self) -> MutableHashTableOfTensorsOp<key_dtype, value_dtype> {
        MutableHashTableOfTensorsOp::new(Rc::new(self))
    }

    pub fn new() -> Self {
        Self {
            container: None,
            shared_name: None,
            use_node_name_sharing: None,
            value_shape: None,
            id_: new_id(),
        }
    }
}

impl<T> MaxPoolGradGradOp<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
{
    pub fn new(inner: Rc<MaxPoolGradGrad<T>>) -> Self {
        Self{inner}
    }

    pub fn output(&self) -> Edge<T> {
        Edge::<T>::new(self.inner.clone(), 0)
    }
}

struct MaxPoolGradGradOp<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
{
    inner: Rc<MaxPoolGradGrad<T>>,
}

impl<T> GraphOperation for MaxPoolGradGrad<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("MaxPoolGradGrad_{}")?
        };
        let mut new_op = graph.new_operation("MaxPoolGradGrad", &op_name)?;
        {
            (|attrs| {new_op.set_attr_int_list("ksize", attrs)})(&self.ksize)
        }
        {
            (|attrs| {new_op.set_attr_int_list("strides", attrs)})(&self.strides)
        }
        {
            (|attr| {new_op.set_attr_string("padding", attr)})(&self.padding)
        }
        {
            match self.data_format {
            }
            None => new_op.set_attr_value_proto("data_format", &vec![18_u8, 4_u8, 78_u8, 72_u8, 87_u8, 67_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_string("data_format", attr)})(&value),
        };
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct MaxPoolGradGrad<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
{
    orig_input: Edge<T>,
    orig_output: Edge<T>,
    grad: Edge<T>,
    ksize: Vec<i64>,
    strides: Vec<i64>,
    padding: String,
    data_format: Option<String>,
    id_: usize,
}

impl<T> MaxPoolGradGrad<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
{
    pub fn data_format(&mut self, data_format: &str) -> &mut Self {
        self.data_format = Some(data_format.to_string());
        &self
    }

    pub fn finish(self) -> MaxPoolGradGradOp<T> {
        MaxPoolGradGradOp::new(Rc::new(self))
    }

    pub fn new(orig_input: Edge<T>, orig_output: Edge<T>, grad: Edge<T>, ksize: &[int], strides: &[int], padding: &str) -> Self {
        Self {
            orig_input,
            orig_output,
            grad,
            ksize: ksize.to_vec()
            strides: strides.to_vec()
            padding: padding.to_string()
            data_format: None,
            id_: new_id(),
        }
    }
}

impl<T> RightShiftOp<T>
where T: con_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_UINT16_or_DT_UINT32_or_DT_UINT64,
{
    pub fn new(inner: Rc<RightShift<T>>) -> Self {
        Self{inner}
    }

    pub fn z(&self) -> Edge<T> {
        Edge::<T>::new(self.inner.clone(), 0)
    }
}

struct RightShiftOp<T>
where T: con_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_UINT16_or_DT_UINT32_or_DT_UINT64,
{
    inner: Rc<RightShift<T>>,
}

impl<T> GraphOperation for RightShift<T>
where T: con_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_UINT16_or_DT_UINT32_or_DT_UINT64,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("RightShift_{}")?
        };
        let mut new_op = graph.new_operation("RightShift", &op_name)?;
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct RightShift<T>
where T: con_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_UINT16_or_DT_UINT32_or_DT_UINT64,
{
    x: Edge<T>,
    y: Edge<T>,
    id_: usize,
}

impl<T> RightShift<T>
where T: con_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_UINT16_or_DT_UINT32_or_DT_UINT64,
{
    pub fn finish(self) -> RightShiftOp<T> {
        RightShiftOp::new(Rc::new(self))
    }

    pub fn new(x: Edge<T>, y: Edge<T>) -> Self {
        Self {
            x,
            y,
            id_: new_id(),
        }
    }
}

impl<T> ApplyAdagradOp<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
{
    pub fn new(inner: Rc<ApplyAdagrad<T>>) -> Self {
        Self{inner}
    }

    pub fn out(&self) -> Edge<T> {
        Edge::<T>::new(self.inner.clone(), 0)
    }
}

struct ApplyAdagradOp<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
{
    inner: Rc<ApplyAdagrad<T>>,
}

impl<T> GraphOperation for ApplyAdagrad<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("ApplyAdagrad_{}")?
        };
        let mut new_op = graph.new_operation("ApplyAdagrad", &op_name)?;
        {
            match self.use_locking {
            }
            None => new_op.set_attr_value_proto("use_locking", &vec![40_u8, 0_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_bool("use_locking", *attr)})(&value),
        };
        {
            match self.update_slots {
            }
            None => new_op.set_attr_value_proto("update_slots", &vec![40_u8, 1_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_bool("update_slots", *attr)})(&value),
        };
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct ApplyAdagrad<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
{
    var: Edge<T>,
    accum: Edge<T>,
    lr: Edge<T>,
    grad: Edge<T>,
    use_locking: Option<bool>,
    update_slots: Option<bool>,
    id_: usize,
}

impl<T> ApplyAdagrad<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
{
    pub fn use_locking(&mut self, use_locking: bool) -> &mut Self {
        self.use_locking = Some(use_locking);
        &self
    }

    pub fn update_slots(&mut self, update_slots: bool) -> &mut Self {
        self.update_slots = Some(update_slots);
        &self
    }

    pub fn finish(self) -> ApplyAdagradOp<T> {
        ApplyAdagradOp::new(Rc::new(self))
    }

    pub fn new(var: Edge<T>, accum: Edge<T>, lr: Edge<T>, grad: Edge<T>) -> Self {
        Self {
            var,
            accum,
            lr,
            grad,
            use_locking: None,
            update_slots: None,
            id_: new_id(),
        }
    }
}

impl AudioSummaryV2Op {
    pub fn new(inner: Rc<AudioSummaryV2>) -> Self {
        Self{inner}
    }

    pub fn summary(&self) -> Edge<String> {
        Edge::<String>::new(self.inner.clone(), 0)
    }
}

struct AudioSummaryV2Op {
    inner: Rc<AudioSummaryV2>,
}

impl GraphOperation for AudioSummaryV2 {
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("AudioSummaryV2_{}")?
        };
        let mut new_op = graph.new_operation("AudioSummaryV2", &op_name)?;
        {
            match self.max_outputs {
            }
            None => new_op.set_attr_value_proto("max_outputs", &vec![24_u8, 3_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_int("max_outputs", *attr)})(&value),
        };
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct AudioSummaryV2 {
    tag: Edge<String>,
    tensor: Edge<f32>,
    sample_rate: Edge<f32>,
    max_outputs: Option<i64>,
    id_: usize,
}

impl AudioSummaryV2 {
    pub fn max_outputs(&mut self, max_outputs: int) -> &mut Self {
        self.max_outputs = Some(max_outputs);
        &self
    }

    pub fn finish(self) -> AudioSummaryV2Op {
        AudioSummaryV2Op::new(Rc::new(self))
    }

    pub fn new(tag: Edge<String>, tensor: Edge<f32>, sample_rate: Edge<f32>) -> Self {
        Self {
            tag,
            tensor,
            sample_rate,
            max_outputs: None,
            id_: new_id(),
        }
    }
}

impl<T, dtype> ParameterizedTruncatedNormalOp<T, dtype>
where dtype: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
      T: con_or_DT_INT32_or_DT_INT64,
{
    pub fn new(inner: Rc<ParameterizedTruncatedNormal<T, dtype>>) -> Self {
        Self{inner}
    }

    pub fn output(&self) -> Edge<dtype> {
        Edge::<dtype>::new(self.inner.clone(), 0)
    }
}

struct ParameterizedTruncatedNormalOp<T, dtype>
where dtype: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
      T: con_or_DT_INT32_or_DT_INT64,
{
    inner: Rc<ParameterizedTruncatedNormal<T, dtype>>,
}

impl<T, dtype> GraphOperation for ParameterizedTruncatedNormal<T, dtype>
where dtype: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
      T: con_or_DT_INT32_or_DT_INT64,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("ParameterizedTruncatedNormal_{}")?
        };
        let mut new_op = graph.new_operation("ParameterizedTruncatedNormal", &op_name)?;
        {
            match self.seed {
            }
            None => new_op.set_attr_value_proto("seed", &vec![24_u8, 0_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_int("seed", *attr)})(&value),
        };
        {
            match self.seed2 {
            }
            None => new_op.set_attr_value_proto("seed2", &vec![24_u8, 0_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_int("seed2", *attr)})(&value),
        };
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct ParameterizedTruncatedNormal<T, dtype>
where dtype: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
      T: con_or_DT_INT32_or_DT_INT64,
{
    shape: Edge<T>,
    means: Edge<dtype>,
    stdevs: Edge<dtype>,
    minvals: Edge<dtype>,
    maxvals: Edge<dtype>,
    seed: Option<i64>,
    seed2: Option<i64>,
    id_: usize,
}

impl<T, dtype> ParameterizedTruncatedNormal<T, dtype>
where dtype: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
      T: con_or_DT_INT32_or_DT_INT64,
{
    pub fn seed(&mut self, seed: int) -> &mut Self {
        self.seed = Some(seed);
        &self
    }

    pub fn seed2(&mut self, seed2: int) -> &mut Self {
        self.seed2 = Some(seed2);
        &self
    }

    pub fn finish(self) -> ParameterizedTruncatedNormalOp<T, dtype> {
        ParameterizedTruncatedNormalOp::new(Rc::new(self))
    }

    pub fn new(shape: Edge<T>, means: Edge<dtype>, stdevs: Edge<dtype>, minvals: Edge<dtype>, maxvals: Edge<dtype>) -> Self {
        Self {
            shape,
            means,
            stdevs,
            minvals,
            maxvals,
            seed: None,
            seed2: None,
            id_: new_id(),
        }
    }
}

impl<T> DiagOp<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_COMPLEX64_or_DT_INT64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF,
{
    pub fn new(inner: Rc<Diag<T>>) -> Self {
        Self{inner}
    }

    pub fn output(&self) -> Edge<T> {
        Edge::<T>::new(self.inner.clone(), 0)
    }
}

struct DiagOp<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_COMPLEX64_or_DT_INT64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF,
{
    inner: Rc<Diag<T>>,
}

impl<T> GraphOperation for Diag<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_COMPLEX64_or_DT_INT64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("Diag_{}")?
        };
        let mut new_op = graph.new_operation("Diag", &op_name)?;
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct Diag<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_COMPLEX64_or_DT_INT64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF,
{
    diagonal: Edge<T>,
    id_: usize,
}

impl<T> Diag<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_COMPLEX64_or_DT_INT64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF,
{
    pub fn finish(self) -> DiagOp<T> {
        DiagOp::new(Rc::new(self))
    }

    pub fn new(diagonal: Edge<T>) -> Self {
        Self {
            diagonal,
            id_: new_id(),
        }
    }
}

pub trait con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_BOOL_or_DT_COMPLEX128 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_BOOL_or_DT_COMPLEX128 for OtherComplex<f32> {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_BOOL_or_DT_COMPLEX128 for OtherComplex<f64> {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_BOOL_or_DT_COMPLEX128 for bool {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_BOOL_or_DT_COMPLEX128 for f32 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_BOOL_or_DT_COMPLEX128 for f64 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_BOOL_or_DT_COMPLEX128 for i16 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_BOOL_or_DT_COMPLEX128 for i32 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_BOOL_or_DT_COMPLEX128 for i64 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_BOOL_or_DT_COMPLEX128 for i8 {
}

impl<T> AsStringOp<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_BOOL_or_DT_COMPLEX128,
{
    pub fn new(inner: Rc<AsString<T>>) -> Self {
        Self{inner}
    }

    pub fn output(&self) -> Edge<String> {
        Edge::<String>::new(self.inner.clone(), 0)
    }
}

struct AsStringOp<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_BOOL_or_DT_COMPLEX128,
{
    inner: Rc<AsString<T>>,
}

impl<T> GraphOperation for AsString<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_BOOL_or_DT_COMPLEX128,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("AsString_{}")?
        };
        let mut new_op = graph.new_operation("AsString", &op_name)?;
        {
            match self.precision {
            }
            None => new_op.set_attr_value_proto("precision", &vec![24_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 1_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_int("precision", *attr)})(&value),
        };
        {
            match self.scientific {
            }
            None => new_op.set_attr_value_proto("scientific", &vec![40_u8, 0_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_bool("scientific", *attr)})(&value),
        };
        {
            match self.shortest {
            }
            None => new_op.set_attr_value_proto("shortest", &vec![40_u8, 0_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_bool("shortest", *attr)})(&value),
        };
        {
            match self.width {
            }
            None => new_op.set_attr_value_proto("width", &vec![24_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 1_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_int("width", *attr)})(&value),
        };
        {
            match self.fill {
            }
            None => new_op.set_attr_value_proto("fill", &vec![18_u8, 0_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_string("fill", attr)})(&value),
        };
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct AsString<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_BOOL_or_DT_COMPLEX128,
{
    input: Edge<T>,
    precision: Option<i64>,
    scientific: Option<bool>,
    shortest: Option<bool>,
    width: Option<i64>,
    fill: Option<String>,
    id_: usize,
}

impl<T> AsString<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_BOOL_or_DT_COMPLEX128,
{
    pub fn precision(&mut self, precision: int) -> &mut Self {
        self.precision = Some(precision);
        &self
    }

    pub fn scientific(&mut self, scientific: bool) -> &mut Self {
        self.scientific = Some(scientific);
        &self
    }

    pub fn shortest(&mut self, shortest: bool) -> &mut Self {
        self.shortest = Some(shortest);
        &self
    }

    pub fn width(&mut self, width: int) -> &mut Self {
        self.width = Some(width);
        &self
    }

    pub fn fill(&mut self, fill: &str) -> &mut Self {
        self.fill = Some(fill.to_string());
        &self
    }

    pub fn finish(self) -> AsStringOp<T> {
        AsStringOp::new(Rc::new(self))
    }

    pub fn new(input: Edge<T>) -> Self {
        Self {
            input,
            precision: None,
            scientific: None,
            shortest: None,
            width: None,
            fill: None,
            id_: new_id(),
        }
    }
}

impl<T> TensorArrayScatterV2Op<T>
where T: con,
{
    pub fn new(inner: Rc<TensorArrayScatterV2<T>>) -> Self {
        Self{inner}
    }

    pub fn flow_out(&self) -> Edge<f32> {
        Edge::<f32>::new(self.inner.clone(), 0)
    }
}

struct TensorArrayScatterV2Op<T>
where T: con,
{
    inner: Rc<TensorArrayScatterV2<T>>,
}

impl<T> GraphOperation for TensorArrayScatterV2<T>
where T: con,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("TensorArrayScatterV2_{}")?
        };
        let mut new_op = graph.new_operation("TensorArrayScatterV2", &op_name)?;
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct TensorArrayScatterV2<T>
where T: con,
{
    handle: Edge<String>,
    indices: Edge<i32>,
    value: Edge<T>,
    flow_in: Edge<f32>,
    id_: usize,
}

impl<T> TensorArrayScatterV2<T>
where T: con,
{
    pub fn finish(self) -> TensorArrayScatterV2Op<T> {
        TensorArrayScatterV2Op::new(Rc::new(self))
    }

    pub fn new(handle: Edge<String>, indices: Edge<i32>, value: Edge<T>, flow_in: Edge<f32>) -> Self {
        Self {
            handle,
            indices,
            value,
            flow_in,
            id_: new_id(),
        }
    }
}

pub trait con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_UINT8_or_DT_HALF {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_UINT8_or_DT_HALF for f32 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_UINT8_or_DT_HALF for f64 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_UINT8_or_DT_HALF for u8 {
}

impl<T> ImageSummaryOp<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_UINT8_or_DT_HALF,
{
    pub fn new(inner: Rc<ImageSummary<T>>) -> Self {
        Self{inner}
    }

    pub fn summary(&self) -> Edge<String> {
        Edge::<String>::new(self.inner.clone(), 0)
    }
}

struct ImageSummaryOp<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_UINT8_or_DT_HALF,
{
    inner: Rc<ImageSummary<T>>,
}

impl<T> GraphOperation for ImageSummary<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_UINT8_or_DT_HALF,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("ImageSummary_{}")?
        };
        let mut new_op = graph.new_operation("ImageSummary", &op_name)?;
        {
            match self.max_images {
            }
            None => new_op.set_attr_value_proto("max_images", &vec![24_u8, 3_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_int("max_images", *attr)})(&value),
        };
        {
            match self.bad_color {
            }
            None => new_op.set_attr_value_proto("bad_color", &vec![66_u8, 0_u8, 8_u8, 4_u8, 18_u8, 0_u8, 18_u8, 0_u8, 8_u8, 4_u8, 58_u8, 6_u8, 255_u8, 1_u8, 0_u8, 0_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_tensor("bad_color", attr)})(&value),
        };
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct ImageSummary<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_UINT8_or_DT_HALF,
{
    tag: Edge<String>,
    tensor: Edge<T>,
    max_images: Option<i64>,
    bad_color: Option<bad_color_T>,
    id_: usize,
}

impl<T> ImageSummary<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_UINT8_or_DT_HALF,
{
    pub fn max_images(&mut self, max_images: int) -> &mut Self {
        self.max_images = Some(max_images);
        &self
    }

    pub fn bad_color<bad_color_T>(&mut self, bad_color: bad_color_T) -> &mut Self
    where bad_color_T: AnyTensor,
    {
        self.bad_color = Some(bad_color);
        &self
    }

    pub fn finish(self) -> ImageSummaryOp<T> {
        ImageSummaryOp::new(Rc::new(self))
    }

    pub fn new(tag: Edge<String>, tensor: Edge<T>) -> Self {
        Self {
            tag,
            tensor,
            max_images: None,
            bad_color: None,
            id_: new_id(),
        }
    }
}

impl<T> AvgPoolOp<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
{
    pub fn new(inner: Rc<AvgPool<T>>) -> Self {
        Self{inner}
    }

    pub fn output(&self) -> Edge<T> {
        Edge::<T>::new(self.inner.clone(), 0)
    }
}

struct AvgPoolOp<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
{
    inner: Rc<AvgPool<T>>,
}

impl<T> GraphOperation for AvgPool<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("AvgPool_{}")?
        };
        let mut new_op = graph.new_operation("AvgPool", &op_name)?;
        {
            (|attrs| {new_op.set_attr_int_list("ksize", attrs)})(&self.ksize)
        }
        {
            (|attrs| {new_op.set_attr_int_list("strides", attrs)})(&self.strides)
        }
        {
            (|attr| {new_op.set_attr_string("padding", attr)})(&self.padding)
        }
        {
            match self.data_format {
            }
            None => new_op.set_attr_value_proto("data_format", &vec![18_u8, 4_u8, 78_u8, 72_u8, 87_u8, 67_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_string("data_format", attr)})(&value),
        };
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct AvgPool<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
{
    value: Edge<T>,
    ksize: Vec<i64>,
    strides: Vec<i64>,
    padding: String,
    data_format: Option<String>,
    id_: usize,
}

impl<T> AvgPool<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
{
    pub fn data_format(&mut self, data_format: &str) -> &mut Self {
        self.data_format = Some(data_format.to_string());
        &self
    }

    pub fn finish(self) -> AvgPoolOp<T> {
        AvgPoolOp::new(Rc::new(self))
    }

    pub fn new(value: Edge<T>, ksize: &[int], strides: &[int], padding: &str) -> Self {
        Self {
            value,
            ksize: ksize.to_vec()
            strides: strides.to_vec()
            padding: padding.to_string()
            data_format: None,
            id_: new_id(),
        }
    }
}

impl MergeSummaryOp {
    pub fn new(inner: Rc<MergeSummary>) -> Self {
        Self{inner}
    }

    pub fn summary(&self) -> Edge<String> {
        Edge::<String>::new(self.inner.clone(), 0)
    }
}

struct MergeSummaryOp {
    inner: Rc<MergeSummary>,
}

impl GraphOperation for MergeSummary {
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("MergeSummary_{}")?
        };
        let mut new_op = graph.new_operation("MergeSummary", &op_name)?;
        {
            (|attr| {new_op.set_attr_int("N", *attr)})(&self.N)
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct MergeSummary {
    inputs: Edge<String>,
    N: i64,
    id_: usize,
}

impl MergeSummary {
    pub fn finish(self) -> MergeSummaryOp {
        MergeSummaryOp::new(Rc::new(self))
    }

    pub fn new(inputs: Edge<String>, N: int) -> Self {
        Self {
            inputs,
            N: N
            id_: new_id(),
        }
    }
}

impl TimestampOp {
    pub fn new(inner: Rc<Timestamp>) -> Self {
        Self{inner}
    }

    pub fn ts(&self) -> Edge<f64> {
        Edge::<f64>::new(self.inner.clone(), 0)
    }
}

struct TimestampOp {
    inner: Rc<Timestamp>,
}

impl GraphOperation for Timestamp {
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("Timestamp_{}")?
        };
        let mut new_op = graph.new_operation("Timestamp", &op_name)?;
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct Timestamp {
    id_: usize,
}

impl Timestamp {
    pub fn finish(self) -> TimestampOp {
        TimestampOp::new(Rc::new(self))
    }

    pub fn new() -> Self {
        Self {
            id_: new_id(),
        }
    }
}

impl<T> BatchMatrixDiagPartOp<T>
where T: con,
{
    pub fn new(inner: Rc<BatchMatrixDiagPart<T>>) -> Self {
        Self{inner}
    }

    pub fn diagonal(&self) -> Edge<T> {
        Edge::<T>::new(self.inner.clone(), 0)
    }
}

struct BatchMatrixDiagPartOp<T>
where T: con,
{
    inner: Rc<BatchMatrixDiagPart<T>>,
}

impl<T> GraphOperation for BatchMatrixDiagPart<T>
where T: con,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("BatchMatrixDiagPart_{}")?
        };
        let mut new_op = graph.new_operation("BatchMatrixDiagPart", &op_name)?;
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct BatchMatrixDiagPart<T>
where T: con,
{
    input: Edge<T>,
    id_: usize,
}

impl<T> BatchMatrixDiagPart<T>
where T: con,
{
    pub fn finish(self) -> BatchMatrixDiagPartOp<T> {
        BatchMatrixDiagPartOp::new(Rc::new(self))
    }

    pub fn new(input: Edge<T>) -> Self {
        Self {
            input,
            id_: new_id(),
        }
    }
}

impl<T, Tindices> SegmentMinOp<T, Tindices>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      Tindices: con_or_DT_INT32_or_DT_INT64,
{
    pub fn new(inner: Rc<SegmentMin<T, Tindices>>) -> Self {
        Self{inner}
    }

    pub fn output(&self) -> Edge<T> {
        Edge::<T>::new(self.inner.clone(), 0)
    }
}

struct SegmentMinOp<T, Tindices>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      Tindices: con_or_DT_INT32_or_DT_INT64,
{
    inner: Rc<SegmentMin<T, Tindices>>,
}

impl<T, Tindices> GraphOperation for SegmentMin<T, Tindices>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      Tindices: con_or_DT_INT32_or_DT_INT64,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("SegmentMin_{}")?
        };
        let mut new_op = graph.new_operation("SegmentMin", &op_name)?;
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct SegmentMin<T, Tindices>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      Tindices: con_or_DT_INT32_or_DT_INT64,
{
    data: Edge<T>,
    segment_ids: Edge<Tindices>,
    id_: usize,
}

impl<T, Tindices> SegmentMin<T, Tindices>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      Tindices: con_or_DT_INT32_or_DT_INT64,
{
    pub fn finish(self) -> SegmentMinOp<T, Tindices> {
        SegmentMinOp::new(Rc::new(self))
    }

    pub fn new(data: Edge<T>, segment_ids: Edge<Tindices>) -> Self {
        Self {
            data,
            segment_ids,
            id_: new_id(),
        }
    }
}

impl<T> ResizeBicubicGradOp<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE,
{
    pub fn new(inner: Rc<ResizeBicubicGrad<T>>) -> Self {
        Self{inner}
    }

    pub fn output(&self) -> Edge<T> {
        Edge::<T>::new(self.inner.clone(), 0)
    }
}

struct ResizeBicubicGradOp<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE,
{
    inner: Rc<ResizeBicubicGrad<T>>,
}

impl<T> GraphOperation for ResizeBicubicGrad<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("ResizeBicubicGrad_{}")?
        };
        let mut new_op = graph.new_operation("ResizeBicubicGrad", &op_name)?;
        {
            match self.align_corners {
            }
            None => new_op.set_attr_value_proto("align_corners", &vec![40_u8, 0_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_bool("align_corners", *attr)})(&value),
        };
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct ResizeBicubicGrad<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE,
{
    grads: Edge<f32>,
    original_image: Edge<T>,
    align_corners: Option<bool>,
    id_: usize,
}

impl<T> ResizeBicubicGrad<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE,
{
    pub fn align_corners(&mut self, align_corners: bool) -> &mut Self {
        self.align_corners = Some(align_corners);
        &self
    }

    pub fn finish(self) -> ResizeBicubicGradOp<T> {
        ResizeBicubicGradOp::new(Rc::new(self))
    }

    pub fn new(grads: Edge<f32>, original_image: Edge<T>) -> Self {
        Self {
            grads,
            original_image,
            align_corners: None,
            id_: new_id(),
        }
    }
}

impl<key_dtype, value_dtype> HashTableOp<key_dtype, value_dtype>
where key_dtype: con,
      value_dtype: con,
{
    pub fn new(inner: Rc<HashTable<key_dtype, value_dtype>>) -> Self {
        Self{inner}
    }

    pub fn table_handle(&self) -> Edge<String> {
        Edge::<String>::new(self.inner.clone(), 0)
    }
}

struct HashTableOp<key_dtype, value_dtype>
where key_dtype: con,
      value_dtype: con,
{
    inner: Rc<HashTable<key_dtype, value_dtype>>,
}

impl<key_dtype, value_dtype> GraphOperation for HashTable<key_dtype, value_dtype>
where key_dtype: con,
      value_dtype: con,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("HashTable_{}")?
        };
        let mut new_op = graph.new_operation("HashTable", &op_name)?;
        {
            match self.container {
            }
            None => new_op.set_attr_value_proto("container", &vec![18_u8, 0_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_string("container", attr)})(&value),
        };
        {
            match self.shared_name {
            }
            None => new_op.set_attr_value_proto("shared_name", &vec![18_u8, 0_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_string("shared_name", attr)})(&value),
        };
        {
            match self.use_node_name_sharing {
            }
            None => new_op.set_attr_value_proto("use_node_name_sharing", &vec![40_u8, 0_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_bool("use_node_name_sharing", *attr)})(&value),
        };
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct HashTable<key_dtype, value_dtype>
where key_dtype: con,
      value_dtype: con,
{
    container: Option<String>,
    shared_name: Option<String>,
    use_node_name_sharing: Option<bool>,
    id_: usize,
}

impl<key_dtype, value_dtype> HashTable<key_dtype, value_dtype>
where key_dtype: con,
      value_dtype: con,
{
    pub fn container(&mut self, container: &str) -> &mut Self {
        self.container = Some(container.to_string());
        &self
    }

    pub fn shared_name(&mut self, shared_name: &str) -> &mut Self {
        self.shared_name = Some(shared_name.to_string());
        &self
    }

    pub fn use_node_name_sharing(&mut self, use_node_name_sharing: bool) -> &mut Self {
        self.use_node_name_sharing = Some(use_node_name_sharing);
        &self
    }

    pub fn finish(self) -> HashTableOp<key_dtype, value_dtype> {
        HashTableOp::new(Rc::new(self))
    }

    pub fn new() -> Self {
        Self {
            container: None,
            shared_name: None,
            use_node_name_sharing: None,
            id_: new_id(),
        }
    }
}

impl<key_dtype, value_dtype> MutableHashTableOp<key_dtype, value_dtype>
where key_dtype: con,
      value_dtype: con,
{
    pub fn new(inner: Rc<MutableHashTable<key_dtype, value_dtype>>) -> Self {
        Self{inner}
    }

    pub fn table_handle(&self) -> Edge<String> {
        Edge::<String>::new(self.inner.clone(), 0)
    }
}

struct MutableHashTableOp<key_dtype, value_dtype>
where key_dtype: con,
      value_dtype: con,
{
    inner: Rc<MutableHashTable<key_dtype, value_dtype>>,
}

impl<key_dtype, value_dtype> GraphOperation for MutableHashTable<key_dtype, value_dtype>
where key_dtype: con,
      value_dtype: con,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("MutableHashTable_{}")?
        };
        let mut new_op = graph.new_operation("MutableHashTable", &op_name)?;
        {
            match self.container {
            }
            None => new_op.set_attr_value_proto("container", &vec![18_u8, 0_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_string("container", attr)})(&value),
        };
        {
            match self.shared_name {
            }
            None => new_op.set_attr_value_proto("shared_name", &vec![18_u8, 0_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_string("shared_name", attr)})(&value),
        };
        {
            match self.use_node_name_sharing {
            }
            None => new_op.set_attr_value_proto("use_node_name_sharing", &vec![40_u8, 0_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_bool("use_node_name_sharing", *attr)})(&value),
        };
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct MutableHashTable<key_dtype, value_dtype>
where key_dtype: con,
      value_dtype: con,
{
    container: Option<String>,
    shared_name: Option<String>,
    use_node_name_sharing: Option<bool>,
    id_: usize,
}

impl<key_dtype, value_dtype> MutableHashTable<key_dtype, value_dtype>
where key_dtype: con,
      value_dtype: con,
{
    pub fn container(&mut self, container: &str) -> &mut Self {
        self.container = Some(container.to_string());
        &self
    }

    pub fn shared_name(&mut self, shared_name: &str) -> &mut Self {
        self.shared_name = Some(shared_name.to_string());
        &self
    }

    pub fn use_node_name_sharing(&mut self, use_node_name_sharing: bool) -> &mut Self {
        self.use_node_name_sharing = Some(use_node_name_sharing);
        &self
    }

    pub fn finish(self) -> MutableHashTableOp<key_dtype, value_dtype> {
        MutableHashTableOp::new(Rc::new(self))
    }

    pub fn new() -> Self {
        Self {
            container: None,
            shared_name: None,
            use_node_name_sharing: None,
            id_: new_id(),
        }
    }
}

impl<Tkey, Tval> InitializeTableOp<Tkey, Tval>
where Tkey: con,
      Tval: con,
{
    pub fn new(inner: Rc<InitializeTable<Tkey, Tval>>) -> Self {
        Self{inner}
    }
}

struct InitializeTableOp<Tkey, Tval>
where Tkey: con,
      Tval: con,
{
    inner: Rc<InitializeTable<Tkey, Tval>>,
}

impl<Tkey, Tval> GraphOperation for InitializeTable<Tkey, Tval>
where Tkey: con,
      Tval: con,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("InitializeTable_{}")?
        };
        let mut new_op = graph.new_operation("InitializeTable", &op_name)?;
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct InitializeTable<Tkey, Tval>
where Tkey: con,
      Tval: con,
{
    table_handle: Edge<String>,
    keys: Edge<Tkey>,
    values: Edge<Tval>,
    id_: usize,
}

impl<Tkey, Tval> InitializeTable<Tkey, Tval>
where Tkey: con,
      Tval: con,
{
    pub fn finish(self) -> InitializeTableOp<Tkey, Tval> {
        InitializeTableOp::new(Rc::new(self))
    }

    pub fn new(table_handle: Edge<String>, keys: Edge<Tkey>, values: Edge<Tval>) -> Self {
        Self {
            table_handle,
            keys,
            values,
            id_: new_id(),
        }
    }
}

impl ShutdownDistributedTPUOp {
    pub fn new(inner: Rc<ShutdownDistributedTPU>) -> Self {
        Self{inner}
    }
}

struct ShutdownDistributedTPUOp {
    inner: Rc<ShutdownDistributedTPU>,
}

impl GraphOperation for ShutdownDistributedTPU {
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("ShutdownDistributedTPU_{}")?
        };
        let mut new_op = graph.new_operation("ShutdownDistributedTPU", &op_name)?;
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct ShutdownDistributedTPU {
    id_: usize,
}

impl ShutdownDistributedTPU {
    pub fn finish(self) -> ShutdownDistributedTPUOp {
        ShutdownDistributedTPUOp::new(Rc::new(self))
    }

    pub fn new() -> Self {
        Self {
            id_: new_id(),
        }
    }
}

impl<T> AdjustContrastOp<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64,
{
    pub fn new(inner: Rc<AdjustContrast<T>>) -> Self {
        Self{inner}
    }

    pub fn output(&self) -> Edge<f32> {
        Edge::<f32>::new(self.inner.clone(), 0)
    }
}

struct AdjustContrastOp<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64,
{
    inner: Rc<AdjustContrast<T>>,
}

impl<T> GraphOperation for AdjustContrast<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("AdjustContrast_{}")?
        };
        let mut new_op = graph.new_operation("AdjustContrast", &op_name)?;
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct AdjustContrast<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64,
{
    images: Edge<T>,
    contrast_factor: Edge<f32>,
    min_value: Edge<f32>,
    max_value: Edge<f32>,
    id_: usize,
}

impl<T> AdjustContrast<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64,
{
    pub fn finish(self) -> AdjustContrastOp<T> {
        AdjustContrastOp::new(Rc::new(self))
    }

    pub fn new(images: Edge<T>, contrast_factor: Edge<f32>, min_value: Edge<f32>, max_value: Edge<f32>) -> Self {
        Self {
            images,
            contrast_factor,
            min_value,
            max_value,
            id_: new_id(),
        }
    }
}

impl TryRpcOp {
    pub fn new(inner: Rc<TryRpc>) -> Self {
        Self{inner}
    }

    pub fn response(&self) -> Edge<String> {
        Edge::<String>::new(self.inner.clone(), 0)
    }

    pub fn status_code(&self) -> Edge<i32> {
        Edge::<i32>::new(self.inner.clone(), 1)
    }

    pub fn status_message(&self) -> Edge<String> {
        Edge::<String>::new(self.inner.clone(), 2)
    }
}

struct TryRpcOp {
    inner: Rc<TryRpc>,
}

impl GraphOperation for TryRpc {
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("TryRpc_{}")?
        };
        let mut new_op = graph.new_operation("TryRpc", &op_name)?;
        {
            match self.protocol {
            }
            None => new_op.set_attr_value_proto("protocol", &vec![18_u8, 0_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_string("protocol", attr)})(&value),
        };
        {
            match self.fail_fast {
            }
            None => new_op.set_attr_value_proto("fail_fast", &vec![40_u8, 1_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_bool("fail_fast", *attr)})(&value),
        };
        {
            match self.timeout_in_ms {
            }
            None => new_op.set_attr_value_proto("timeout_in_ms", &vec![24_u8, 0_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_int("timeout_in_ms", *attr)})(&value),
        };
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct TryRpc {
    address: Edge<String>,
    method: Edge<String>,
    request: Edge<String>,
    protocol: Option<String>,
    fail_fast: Option<bool>,
    timeout_in_ms: Option<i64>,
    id_: usize,
}

impl TryRpc {
    pub fn protocol(&mut self, protocol: &str) -> &mut Self {
        self.protocol = Some(protocol.to_string());
        &self
    }

    pub fn fail_fast(&mut self, fail_fast: bool) -> &mut Self {
        self.fail_fast = Some(fail_fast);
        &self
    }

    pub fn timeout_in_ms(&mut self, timeout_in_ms: int) -> &mut Self {
        self.timeout_in_ms = Some(timeout_in_ms);
        &self
    }

    pub fn finish(self) -> TryRpcOp {
        TryRpcOp::new(Rc::new(self))
    }

    pub fn new(address: Edge<String>, method: Edge<String>, request: Edge<String>) -> Self {
        Self {
            address,
            method,
            request,
            protocol: None,
            fail_fast: None,
            timeout_in_ms: None,
            id_: new_id(),
        }
    }
}

impl<T> EnterOp<T>
where T: con,
{
    pub fn new(inner: Rc<Enter<T>>) -> Self {
        Self{inner}
    }

    pub fn output(&self) -> Edge<T> {
        Edge::<T>::new(self.inner.clone(), 0)
    }
}

struct EnterOp<T>
where T: con,
{
    inner: Rc<Enter<T>>,
}

impl<T> GraphOperation for Enter<T>
where T: con,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("Enter_{}")?
        };
        let mut new_op = graph.new_operation("Enter", &op_name)?;
        {
            (|attr| {new_op.set_attr_string("frame_name", attr)})(&self.frame_name)
        }
        {
            match self.is_constant {
            }
            None => new_op.set_attr_value_proto("is_constant", &vec![40_u8, 0_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_bool("is_constant", *attr)})(&value),
        };
        {
            match self.parallel_iterations {
            }
            None => new_op.set_attr_value_proto("parallel_iterations", &vec![24_u8, 10_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_int("parallel_iterations", *attr)})(&value),
        };
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct Enter<T>
where T: con,
{
    data: Edge<T>,
    frame_name: String,
    is_constant: Option<bool>,
    parallel_iterations: Option<i64>,
    id_: usize,
}

impl<T> Enter<T>
where T: con,
{
    pub fn is_constant(&mut self, is_constant: bool) -> &mut Self {
        self.is_constant = Some(is_constant);
        &self
    }

    pub fn parallel_iterations(&mut self, parallel_iterations: int) -> &mut Self {
        self.parallel_iterations = Some(parallel_iterations);
        &self
    }

    pub fn finish(self) -> EnterOp<T> {
        EnterOp::new(Rc::new(self))
    }

    pub fn new(data: Edge<T>, frame_name: &str) -> Self {
        Self {
            data,
            frame_name: frame_name.to_string()
            is_constant: None,
            parallel_iterations: None,
            id_: new_id(),
        }
    }
}

impl<T> BatchMatrixDeterminantOp<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_COMPLEX64_or_DT_COMPLEX128,
{
    pub fn new(inner: Rc<BatchMatrixDeterminant<T>>) -> Self {
        Self{inner}
    }

    pub fn output(&self) -> Edge<T> {
        Edge::<T>::new(self.inner.clone(), 0)
    }
}

struct BatchMatrixDeterminantOp<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_COMPLEX64_or_DT_COMPLEX128,
{
    inner: Rc<BatchMatrixDeterminant<T>>,
}

impl<T> GraphOperation for BatchMatrixDeterminant<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_COMPLEX64_or_DT_COMPLEX128,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("BatchMatrixDeterminant_{}")?
        };
        let mut new_op = graph.new_operation("BatchMatrixDeterminant", &op_name)?;
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct BatchMatrixDeterminant<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_COMPLEX64_or_DT_COMPLEX128,
{
    input: Edge<T>,
    id_: usize,
}

impl<T> BatchMatrixDeterminant<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_COMPLEX64_or_DT_COMPLEX128,
{
    pub fn finish(self) -> BatchMatrixDeterminantOp<T> {
        BatchMatrixDeterminantOp::new(Rc::new(self))
    }

    pub fn new(input: Edge<T>) -> Self {
        Self {
            input,
            id_: new_id(),
        }
    }
}

pub trait con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_VARIANT_or_DT_UINT32_or_DT_UINT64 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_VARIANT_or_DT_UINT32_or_DT_UINT64 for BFloat16 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_VARIANT_or_DT_UINT32_or_DT_UINT64 for OtherComplex<f32> {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_VARIANT_or_DT_UINT32_or_DT_UINT64 for OtherComplex<f64> {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_VARIANT_or_DT_UINT32_or_DT_UINT64 for f32 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_VARIANT_or_DT_UINT32_or_DT_UINT64 for f64 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_VARIANT_or_DT_UINT32_or_DT_UINT64 for i16 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_VARIANT_or_DT_UINT32_or_DT_UINT64 for i32 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_VARIANT_or_DT_UINT32_or_DT_UINT64 for i64 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_VARIANT_or_DT_UINT32_or_DT_UINT64 for i8 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_VARIANT_or_DT_UINT32_or_DT_UINT64 for u16 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_VARIANT_or_DT_UINT32_or_DT_UINT64 for u32 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_VARIANT_or_DT_UINT32_or_DT_UINT64 for u64 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_VARIANT_or_DT_UINT32_or_DT_UINT64 for u8 {
}

impl<T> AddNOp<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_VARIANT_or_DT_UINT32_or_DT_UINT64,
{
    pub fn new(inner: Rc<AddN<T>>) -> Self {
        Self{inner}
    }

    pub fn sum(&self) -> Edge<T> {
        Edge::<T>::new(self.inner.clone(), 0)
    }
}

struct AddNOp<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_VARIANT_or_DT_UINT32_or_DT_UINT64,
{
    inner: Rc<AddN<T>>,
}

impl<T> GraphOperation for AddN<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_VARIANT_or_DT_UINT32_or_DT_UINT64,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("AddN_{}")?
        };
        let mut new_op = graph.new_operation("AddN", &op_name)?;
        {
            (|attr| {new_op.set_attr_int("N", *attr)})(&self.N)
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct AddN<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_VARIANT_or_DT_UINT32_or_DT_UINT64,
{
    inputs: Edge<T>,
    N: i64,
    id_: usize,
}

impl<T> AddN<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_VARIANT_or_DT_UINT32_or_DT_UINT64,
{
    pub fn finish(self) -> AddNOp<T> {
        AddNOp::new(Rc::new(self))
    }

    pub fn new(inputs: Edge<T>, N: int) -> Self {
        Self {
            inputs,
            N: N
            id_: new_id(),
        }
    }
}

impl<T> BatchMatMulOp<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_COMPLEX64_or_DT_INT64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF,
{
    pub fn new(inner: Rc<BatchMatMul<T>>) -> Self {
        Self{inner}
    }

    pub fn output(&self) -> Edge<T> {
        Edge::<T>::new(self.inner.clone(), 0)
    }
}

struct BatchMatMulOp<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_COMPLEX64_or_DT_INT64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF,
{
    inner: Rc<BatchMatMul<T>>,
}

impl<T> GraphOperation for BatchMatMul<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_COMPLEX64_or_DT_INT64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("BatchMatMul_{}")?
        };
        let mut new_op = graph.new_operation("BatchMatMul", &op_name)?;
        {
            match self.adj_x {
            }
            None => new_op.set_attr_value_proto("adj_x", &vec![40_u8, 0_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_bool("adj_x", *attr)})(&value),
        };
        {
            match self.adj_y {
            }
            None => new_op.set_attr_value_proto("adj_y", &vec![40_u8, 0_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_bool("adj_y", *attr)})(&value),
        };
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct BatchMatMul<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_COMPLEX64_or_DT_INT64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF,
{
    x: Edge<T>,
    y: Edge<T>,
    adj_x: Option<bool>,
    adj_y: Option<bool>,
    id_: usize,
}

impl<T> BatchMatMul<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_COMPLEX64_or_DT_INT64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF,
{
    pub fn adj_x(&mut self, adj_x: bool) -> &mut Self {
        self.adj_x = Some(adj_x);
        &self
    }

    pub fn adj_y(&mut self, adj_y: bool) -> &mut Self {
        self.adj_y = Some(adj_y);
        &self
    }

    pub fn finish(self) -> BatchMatMulOp<T> {
        BatchMatMulOp::new(Rc::new(self))
    }

    pub fn new(x: Edge<T>, y: Edge<T>) -> Self {
        Self {
            x,
            y,
            adj_x: None,
            adj_y: None,
            id_: new_id(),
        }
    }
}

impl<T> SquareOp<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_COMPLEX64_or_DT_INT64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF,
{
    pub fn new(inner: Rc<Square<T>>) -> Self {
        Self{inner}
    }

    pub fn y(&self) -> Edge<T> {
        Edge::<T>::new(self.inner.clone(), 0)
    }
}

struct SquareOp<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_COMPLEX64_or_DT_INT64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF,
{
    inner: Rc<Square<T>>,
}

impl<T> GraphOperation for Square<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_COMPLEX64_or_DT_INT64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("Square_{}")?
        };
        let mut new_op = graph.new_operation("Square", &op_name)?;
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct Square<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_COMPLEX64_or_DT_INT64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF,
{
    x: Edge<T>,
    id_: usize,
}

impl<T> Square<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_COMPLEX64_or_DT_INT64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF,
{
    pub fn finish(self) -> SquareOp<T> {
        SquareOp::new(Rc::new(self))
    }

    pub fn new(x: Edge<T>) -> Self {
        Self {
            x,
            id_: new_id(),
        }
    }
}

impl<T> Conv3DBackpropFilterOp<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_HALF,
{
    pub fn new(inner: Rc<Conv3DBackpropFilter<T>>) -> Self {
        Self{inner}
    }

    pub fn output(&self) -> Edge<T> {
        Edge::<T>::new(self.inner.clone(), 0)
    }
}

struct Conv3DBackpropFilterOp<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_HALF,
{
    inner: Rc<Conv3DBackpropFilter<T>>,
}

impl<T> GraphOperation for Conv3DBackpropFilter<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_HALF,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("Conv3DBackpropFilter_{}")?
        };
        let mut new_op = graph.new_operation("Conv3DBackpropFilter", &op_name)?;
        {
            (|attrs| {new_op.set_attr_int_list("strides", attrs)})(&self.strides)
        }
        {
            (|attr| {new_op.set_attr_string("padding", attr)})(&self.padding)
        }
        {
            match self.dilations {
            }
            None => new_op.set_attr_value_proto("dilations", &vec![10_u8, 0_u8, 26_u8, 5_u8, 1_u8, 1_u8, 1_u8, 1_u8,]);,
            Some(value) => (|attrs| {new_op.set_attr_int_list("dilations", attrs)})(&value),
        };
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct Conv3DBackpropFilter<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_HALF,
{
    input: Edge<T>,
    filter: Edge<T>,
    out_backprop: Edge<T>,
    strides: Vec<i64>,
    padding: String,
    dilations: Option<Vec<i64>>,
    id_: usize,
}

impl<T> Conv3DBackpropFilter<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_HALF,
{
    pub fn dilations(&mut self, dilations: &[int]) -> &mut Self {
        self.dilations = Some(dilations.to_vec());
        &self
    }

    pub fn finish(self) -> Conv3DBackpropFilterOp<T> {
        Conv3DBackpropFilterOp::new(Rc::new(self))
    }

    pub fn new(input: Edge<T>, filter: Edge<T>, out_backprop: Edge<T>, strides: &[int], padding: &str) -> Self {
        Self {
            input,
            filter,
            out_backprop,
            strides: strides.to_vec()
            padding: padding.to_string()
            dilations: None,
            id_: new_id(),
        }
    }
}

impl<T> SqrtOp<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_COMPLEX64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF,
{
    pub fn new(inner: Rc<Sqrt<T>>) -> Self {
        Self{inner}
    }

    pub fn y(&self) -> Edge<T> {
        Edge::<T>::new(self.inner.clone(), 0)
    }
}

struct SqrtOp<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_COMPLEX64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF,
{
    inner: Rc<Sqrt<T>>,
}

impl<T> GraphOperation for Sqrt<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_COMPLEX64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("Sqrt_{}")?
        };
        let mut new_op = graph.new_operation("Sqrt", &op_name)?;
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct Sqrt<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_COMPLEX64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF,
{
    x: Edge<T>,
    id_: usize,
}

impl<T> Sqrt<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_COMPLEX64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF,
{
    pub fn finish(self) -> SqrtOp<T> {
        SqrtOp::new(Rc::new(self))
    }

    pub fn new(x: Edge<T>) -> Self {
        Self {
            x,
            id_: new_id(),
        }
    }
}

impl<T> ExpOp<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_COMPLEX64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF,
{
    pub fn new(inner: Rc<Exp<T>>) -> Self {
        Self{inner}
    }

    pub fn y(&self) -> Edge<T> {
        Edge::<T>::new(self.inner.clone(), 0)
    }
}

struct ExpOp<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_COMPLEX64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF,
{
    inner: Rc<Exp<T>>,
}

impl<T> GraphOperation for Exp<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_COMPLEX64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("Exp_{}")?
        };
        let mut new_op = graph.new_operation("Exp", &op_name)?;
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct Exp<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_COMPLEX64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF,
{
    x: Edge<T>,
    id_: usize,
}

impl<T> Exp<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_COMPLEX64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF,
{
    pub fn finish(self) -> ExpOp<T> {
        ExpOp::new(Rc::new(self))
    }

    pub fn new(x: Edge<T>) -> Self {
        Self {
            x,
            id_: new_id(),
        }
    }
}

impl<T> NthElementOp<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
{
    pub fn new(inner: Rc<NthElement<T>>) -> Self {
        Self{inner}
    }

    pub fn values(&self) -> Edge<T> {
        Edge::<T>::new(self.inner.clone(), 0)
    }
}

struct NthElementOp<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
{
    inner: Rc<NthElement<T>>,
}

impl<T> GraphOperation for NthElement<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("NthElement_{}")?
        };
        let mut new_op = graph.new_operation("NthElement", &op_name)?;
        {
            match self.reverse {
            }
            None => new_op.set_attr_value_proto("reverse", &vec![40_u8, 0_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_bool("reverse", *attr)})(&value),
        };
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct NthElement<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
{
    input: Edge<T>,
    n: Edge<i32>,
    reverse: Option<bool>,
    id_: usize,
}

impl<T> NthElement<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
{
    pub fn reverse(&mut self, reverse: bool) -> &mut Self {
        self.reverse = Some(reverse);
        &self
    }

    pub fn finish(self) -> NthElementOp<T> {
        NthElementOp::new(Rc::new(self))
    }

    pub fn new(input: Edge<T>, n: Edge<i32>) -> Self {
        Self {
            input,
            n,
            reverse: None,
            id_: new_id(),
        }
    }
}

impl<T, Tindices, Tnumsegments> UnsortedSegmentMaxOp<T, Tindices, Tnumsegments>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      Tindices: con_or_DT_INT32_or_DT_INT64,
      Tnumsegments: con_or_DT_INT32_or_DT_INT64,
{
    pub fn new(inner: Rc<UnsortedSegmentMax<T, Tindices, Tnumsegments>>) -> Self {
        Self{inner}
    }

    pub fn output(&self) -> Edge<T> {
        Edge::<T>::new(self.inner.clone(), 0)
    }
}

struct UnsortedSegmentMaxOp<T, Tindices, Tnumsegments>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      Tindices: con_or_DT_INT32_or_DT_INT64,
      Tnumsegments: con_or_DT_INT32_or_DT_INT64,
{
    inner: Rc<UnsortedSegmentMax<T, Tindices, Tnumsegments>>,
}

impl<T, Tindices, Tnumsegments> GraphOperation for UnsortedSegmentMax<T, Tindices, Tnumsegments>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      Tindices: con_or_DT_INT32_or_DT_INT64,
      Tnumsegments: con_or_DT_INT32_or_DT_INT64,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("UnsortedSegmentMax_{}")?
        };
        let mut new_op = graph.new_operation("UnsortedSegmentMax", &op_name)?;
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct UnsortedSegmentMax<T, Tindices, Tnumsegments>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      Tindices: con_or_DT_INT32_or_DT_INT64,
      Tnumsegments: con_or_DT_INT32_or_DT_INT64,
{
    data: Edge<T>,
    segment_ids: Edge<Tindices>,
    num_segments: Edge<Tnumsegments>,
    id_: usize,
}

impl<T, Tindices, Tnumsegments> UnsortedSegmentMax<T, Tindices, Tnumsegments>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      Tindices: con_or_DT_INT32_or_DT_INT64,
      Tnumsegments: con_or_DT_INT32_or_DT_INT64,
{
    pub fn finish(self) -> UnsortedSegmentMaxOp<T, Tindices, Tnumsegments> {
        UnsortedSegmentMaxOp::new(Rc::new(self))
    }

    pub fn new(data: Edge<T>, segment_ids: Edge<Tindices>, num_segments: Edge<Tnumsegments>) -> Self {
        Self {
            data,
            segment_ids,
            num_segments,
            id_: new_id(),
        }
    }
}

impl<T> SoftplusOp<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
{
    pub fn new(inner: Rc<Softplus<T>>) -> Self {
        Self{inner}
    }

    pub fn activations(&self) -> Edge<T> {
        Edge::<T>::new(self.inner.clone(), 0)
    }
}

struct SoftplusOp<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
{
    inner: Rc<Softplus<T>>,
}

impl<T> GraphOperation for Softplus<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("Softplus_{}")?
        };
        let mut new_op = graph.new_operation("Softplus", &op_name)?;
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct Softplus<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
{
    features: Edge<T>,
    id_: usize,
}

impl<T> Softplus<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
{
    pub fn finish(self) -> SoftplusOp<T> {
        SoftplusOp::new(Rc::new(self))
    }

    pub fn new(features: Edge<T>) -> Self {
        Self {
            features,
            id_: new_id(),
        }
    }
}

impl<T> Expm1Op<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_COMPLEX64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF,
{
    pub fn new(inner: Rc<Expm1<T>>) -> Self {
        Self{inner}
    }

    pub fn y(&self) -> Edge<T> {
        Edge::<T>::new(self.inner.clone(), 0)
    }
}

struct Expm1Op<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_COMPLEX64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF,
{
    inner: Rc<Expm1<T>>,
}

impl<T> GraphOperation for Expm1<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_COMPLEX64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("Expm1_{}")?
        };
        let mut new_op = graph.new_operation("Expm1", &op_name)?;
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct Expm1<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_COMPLEX64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF,
{
    x: Edge<T>,
    id_: usize,
}

impl<T> Expm1<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_COMPLEX64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF,
{
    pub fn finish(self) -> Expm1Op<T> {
        Expm1Op::new(Rc::new(self))
    }

    pub fn new(x: Edge<T>) -> Self {
        Self {
            x,
            id_: new_id(),
        }
    }
}

impl<T> LogOp<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_COMPLEX64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF,
{
    pub fn new(inner: Rc<Log<T>>) -> Self {
        Self{inner}
    }

    pub fn y(&self) -> Edge<T> {
        Edge::<T>::new(self.inner.clone(), 0)
    }
}

struct LogOp<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_COMPLEX64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF,
{
    inner: Rc<Log<T>>,
}

impl<T> GraphOperation for Log<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_COMPLEX64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("Log_{}")?
        };
        let mut new_op = graph.new_operation("Log", &op_name)?;
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct Log<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_COMPLEX64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF,
{
    x: Edge<T>,
    id_: usize,
}

impl<T> Log<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_COMPLEX64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF,
{
    pub fn finish(self) -> LogOp<T> {
        LogOp::new(Rc::new(self))
    }

    pub fn new(x: Edge<T>) -> Self {
        Self {
            x,
            id_: new_id(),
        }
    }
}

impl<T, Tidx, Tnumsegments> SparseSegmentMeanWithNumSegmentsOp<T, Tidx, Tnumsegments>
where T: con_or_DT_FLOAT_or_DT_DOUBLE,
      Tidx: con_or_DT_INT32_or_DT_INT64,
      Tnumsegments: con_or_DT_INT32_or_DT_INT64,
{
    pub fn new(inner: Rc<SparseSegmentMeanWithNumSegments<T, Tidx, Tnumsegments>>) -> Self {
        Self{inner}
    }

    pub fn output(&self) -> Edge<T> {
        Edge::<T>::new(self.inner.clone(), 0)
    }
}

struct SparseSegmentMeanWithNumSegmentsOp<T, Tidx, Tnumsegments>
where T: con_or_DT_FLOAT_or_DT_DOUBLE,
      Tidx: con_or_DT_INT32_or_DT_INT64,
      Tnumsegments: con_or_DT_INT32_or_DT_INT64,
{
    inner: Rc<SparseSegmentMeanWithNumSegments<T, Tidx, Tnumsegments>>,
}

impl<T, Tidx, Tnumsegments> GraphOperation for SparseSegmentMeanWithNumSegments<T, Tidx, Tnumsegments>
where T: con_or_DT_FLOAT_or_DT_DOUBLE,
      Tidx: con_or_DT_INT32_or_DT_INT64,
      Tnumsegments: con_or_DT_INT32_or_DT_INT64,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("SparseSegmentMeanWithNumSegments_{}")?
        };
        let mut new_op = graph.new_operation("SparseSegmentMeanWithNumSegments", &op_name)?;
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct SparseSegmentMeanWithNumSegments<T, Tidx, Tnumsegments>
where T: con_or_DT_FLOAT_or_DT_DOUBLE,
      Tidx: con_or_DT_INT32_or_DT_INT64,
      Tnumsegments: con_or_DT_INT32_or_DT_INT64,
{
    data: Edge<T>,
    indices: Edge<Tidx>,
    segment_ids: Edge<i32>,
    num_segments: Edge<Tnumsegments>,
    id_: usize,
}

impl<T, Tidx, Tnumsegments> SparseSegmentMeanWithNumSegments<T, Tidx, Tnumsegments>
where T: con_or_DT_FLOAT_or_DT_DOUBLE,
      Tidx: con_or_DT_INT32_or_DT_INT64,
      Tnumsegments: con_or_DT_INT32_or_DT_INT64,
{
    pub fn finish(self) -> SparseSegmentMeanWithNumSegmentsOp<T, Tidx, Tnumsegments> {
        SparseSegmentMeanWithNumSegmentsOp::new(Rc::new(self))
    }

    pub fn new(data: Edge<T>, indices: Edge<Tidx>, segment_ids: Edge<i32>, num_segments: Edge<Tnumsegments>) -> Self {
        Self {
            data,
            indices,
            segment_ids,
            num_segments,
            id_: new_id(),
        }
    }
}

impl<T> CoshOp<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_COMPLEX64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF,
{
    pub fn new(inner: Rc<Cosh<T>>) -> Self {
        Self{inner}
    }

    pub fn y(&self) -> Edge<T> {
        Edge::<T>::new(self.inner.clone(), 0)
    }
}

struct CoshOp<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_COMPLEX64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF,
{
    inner: Rc<Cosh<T>>,
}

impl<T> GraphOperation for Cosh<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_COMPLEX64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("Cosh_{}")?
        };
        let mut new_op = graph.new_operation("Cosh", &op_name)?;
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct Cosh<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_COMPLEX64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF,
{
    x: Edge<T>,
    id_: usize,
}

impl<T> Cosh<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_COMPLEX64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF,
{
    pub fn finish(self) -> CoshOp<T> {
        CoshOp::new(Rc::new(self))
    }

    pub fn new(x: Edge<T>) -> Self {
        Self {
            x,
            id_: new_id(),
        }
    }
}

impl<T, Tindices> SegmentMaxOp<T, Tindices>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      Tindices: con_or_DT_INT32_or_DT_INT64,
{
    pub fn new(inner: Rc<SegmentMax<T, Tindices>>) -> Self {
        Self{inner}
    }

    pub fn output(&self) -> Edge<T> {
        Edge::<T>::new(self.inner.clone(), 0)
    }
}

struct SegmentMaxOp<T, Tindices>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      Tindices: con_or_DT_INT32_or_DT_INT64,
{
    inner: Rc<SegmentMax<T, Tindices>>,
}

impl<T, Tindices> GraphOperation for SegmentMax<T, Tindices>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      Tindices: con_or_DT_INT32_or_DT_INT64,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("SegmentMax_{}")?
        };
        let mut new_op = graph.new_operation("SegmentMax", &op_name)?;
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct SegmentMax<T, Tindices>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      Tindices: con_or_DT_INT32_or_DT_INT64,
{
    data: Edge<T>,
    segment_ids: Edge<Tindices>,
    id_: usize,
}

impl<T, Tindices> SegmentMax<T, Tindices>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      Tindices: con_or_DT_INT32_or_DT_INT64,
{
    pub fn finish(self) -> SegmentMaxOp<T, Tindices> {
        SegmentMaxOp::new(Rc::new(self))
    }

    pub fn new(data: Edge<T>, segment_ids: Edge<Tindices>) -> Self {
        Self {
            data,
            segment_ids,
            id_: new_id(),
        }
    }
}

impl<T> TanhOp<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_COMPLEX64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF,
{
    pub fn new(inner: Rc<Tanh<T>>) -> Self {
        Self{inner}
    }

    pub fn y(&self) -> Edge<T> {
        Edge::<T>::new(self.inner.clone(), 0)
    }
}

struct TanhOp<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_COMPLEX64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF,
{
    inner: Rc<Tanh<T>>,
}

impl<T> GraphOperation for Tanh<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_COMPLEX64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("Tanh_{}")?
        };
        let mut new_op = graph.new_operation("Tanh", &op_name)?;
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct Tanh<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_COMPLEX64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF,
{
    x: Edge<T>,
    id_: usize,
}

impl<T> Tanh<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_COMPLEX64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF,
{
    pub fn finish(self) -> TanhOp<T> {
        TanhOp::new(Rc::new(self))
    }

    pub fn new(x: Edge<T>) -> Self {
        Self {
            x,
            id_: new_id(),
        }
    }
}

impl UnicodeTranscodeOp {
    pub fn new(inner: Rc<UnicodeTranscode>) -> Self {
        Self{inner}
    }

    pub fn output(&self) -> Edge<String> {
        Edge::<String>::new(self.inner.clone(), 0)
    }
}

struct UnicodeTranscodeOp {
    inner: Rc<UnicodeTranscode>,
}

impl GraphOperation for UnicodeTranscode {
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("UnicodeTranscode_{}")?
        };
        let mut new_op = graph.new_operation("UnicodeTranscode", &op_name)?;
        {
            (|attr| {new_op.set_attr_string("input_encoding", attr)})(&self.input_encoding)
        }
        {
            (|attr| {new_op.set_attr_string("output_encoding", attr)})(&self.output_encoding)
        }
        {
            match self.errors {
            }
            None => new_op.set_attr_value_proto("errors", &vec![18_u8, 7_u8, 114_u8, 101_u8, 112_u8, 108_u8, 97_u8, 99_u8, 101_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_string("errors", attr)})(&value),
        };
        {
            match self.replacement_char {
            }
            None => new_op.set_attr_value_proto("replacement_char", &vec![24_u8, 253_u8, 255_u8, 3_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_int("replacement_char", *attr)})(&value),
        };
        {
            match self.replace_control_characters {
            }
            None => new_op.set_attr_value_proto("replace_control_characters", &vec![40_u8, 0_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_bool("replace_control_characters", *attr)})(&value),
        };
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct UnicodeTranscode {
    input: Edge<String>,
    input_encoding: String,
    output_encoding: String,
    errors: Option<String>,
    replacement_char: Option<i64>,
    replace_control_characters: Option<bool>,
    id_: usize,
}

impl UnicodeTranscode {
    pub fn errors(&mut self, errors: &str) -> &mut Self {
        self.errors = Some(errors.to_string());
        &self
    }

    pub fn replacement_char(&mut self, replacement_char: int) -> &mut Self {
        self.replacement_char = Some(replacement_char);
        &self
    }

    pub fn replace_control_characters(&mut self, replace_control_characters: bool) -> &mut Self {
        self.replace_control_characters = Some(replace_control_characters);
        &self
    }

    pub fn finish(self) -> UnicodeTranscodeOp {
        UnicodeTranscodeOp::new(Rc::new(self))
    }

    pub fn new(input: Edge<String>, input_encoding: &str, output_encoding: &str) -> Self {
        Self {
            input,
            input_encoding: input_encoding.to_string()
            output_encoding: output_encoding.to_string()
            errors: None,
            replacement_char: None,
            replace_control_characters: None,
            id_: new_id(),
        }
    }
}

impl<T> AsinhOp<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_COMPLEX64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF,
{
    pub fn new(inner: Rc<Asinh<T>>) -> Self {
        Self{inner}
    }

    pub fn y(&self) -> Edge<T> {
        Edge::<T>::new(self.inner.clone(), 0)
    }
}

struct AsinhOp<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_COMPLEX64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF,
{
    inner: Rc<Asinh<T>>,
}

impl<T> GraphOperation for Asinh<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_COMPLEX64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("Asinh_{}")?
        };
        let mut new_op = graph.new_operation("Asinh", &op_name)?;
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct Asinh<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_COMPLEX64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF,
{
    x: Edge<T>,
    id_: usize,
}

impl<T> Asinh<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_COMPLEX64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF,
{
    pub fn finish(self) -> AsinhOp<T> {
        AsinhOp::new(Rc::new(self))
    }

    pub fn new(x: Edge<T>) -> Self {
        Self {
            x,
            id_: new_id(),
        }
    }
}

impl<T> HSVToRGBOp<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
{
    pub fn new(inner: Rc<HSVToRGB<T>>) -> Self {
        Self{inner}
    }

    pub fn output(&self) -> Edge<T> {
        Edge::<T>::new(self.inner.clone(), 0)
    }
}

struct HSVToRGBOp<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
{
    inner: Rc<HSVToRGB<T>>,
}

impl<T> GraphOperation for HSVToRGB<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("HSVToRGB_{}")?
        };
        let mut new_op = graph.new_operation("HSVToRGB", &op_name)?;
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct HSVToRGB<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
{
    images: Edge<T>,
    id_: usize,
}

impl<T> HSVToRGB<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
{
    pub fn finish(self) -> HSVToRGBOp<T> {
        HSVToRGBOp::new(Rc::new(self))
    }

    pub fn new(images: Edge<T>) -> Self {
        Self {
            images,
            id_: new_id(),
        }
    }
}

impl<T> SigmoidGradOp<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_COMPLEX64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF,
{
    pub fn new(inner: Rc<SigmoidGrad<T>>) -> Self {
        Self{inner}
    }

    pub fn z(&self) -> Edge<T> {
        Edge::<T>::new(self.inner.clone(), 0)
    }
}

struct SigmoidGradOp<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_COMPLEX64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF,
{
    inner: Rc<SigmoidGrad<T>>,
}

impl<T> GraphOperation for SigmoidGrad<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_COMPLEX64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("SigmoidGrad_{}")?
        };
        let mut new_op = graph.new_operation("SigmoidGrad", &op_name)?;
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct SigmoidGrad<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_COMPLEX64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF,
{
    y: Edge<T>,
    dy: Edge<T>,
    id_: usize,
}

impl<T> SigmoidGrad<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_COMPLEX64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF,
{
    pub fn finish(self) -> SigmoidGradOp<T> {
        SigmoidGradOp::new(Rc::new(self))
    }

    pub fn new(y: Edge<T>, dy: Edge<T>) -> Self {
        Self {
            y,
            dy,
            id_: new_id(),
        }
    }
}

impl<T> SinOp<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_COMPLEX64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF,
{
    pub fn new(inner: Rc<Sin<T>>) -> Self {
        Self{inner}
    }

    pub fn y(&self) -> Edge<T> {
        Edge::<T>::new(self.inner.clone(), 0)
    }
}

struct SinOp<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_COMPLEX64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF,
{
    inner: Rc<Sin<T>>,
}

impl<T> GraphOperation for Sin<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_COMPLEX64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("Sin_{}")?
        };
        let mut new_op = graph.new_operation("Sin", &op_name)?;
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct Sin<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_COMPLEX64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF,
{
    x: Edge<T>,
    id_: usize,
}

impl<T> Sin<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_COMPLEX64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF,
{
    pub fn finish(self) -> SinOp<T> {
        SinOp::new(Rc::new(self))
    }

    pub fn new(x: Edge<T>) -> Self {
        Self {
            x,
            id_: new_id(),
        }
    }
}

impl<T> AcosOp<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_COMPLEX64_or_DT_INT64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF,
{
    pub fn new(inner: Rc<Acos<T>>) -> Self {
        Self{inner}
    }

    pub fn y(&self) -> Edge<T> {
        Edge::<T>::new(self.inner.clone(), 0)
    }
}

struct AcosOp<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_COMPLEX64_or_DT_INT64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF,
{
    inner: Rc<Acos<T>>,
}

impl<T> GraphOperation for Acos<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_COMPLEX64_or_DT_INT64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("Acos_{}")?
        };
        let mut new_op = graph.new_operation("Acos", &op_name)?;
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct Acos<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_COMPLEX64_or_DT_INT64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF,
{
    x: Edge<T>,
    id_: usize,
}

impl<T> Acos<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_COMPLEX64_or_DT_INT64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF,
{
    pub fn finish(self) -> AcosOp<T> {
        AcosOp::new(Rc::new(self))
    }

    pub fn new(x: Edge<T>) -> Self {
        Self {
            x,
            id_: new_id(),
        }
    }
}

impl<T> BesselI0eOp<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
{
    pub fn new(inner: Rc<BesselI0e<T>>) -> Self {
        Self{inner}
    }

    pub fn y(&self) -> Edge<T> {
        Edge::<T>::new(self.inner.clone(), 0)
    }
}

struct BesselI0eOp<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
{
    inner: Rc<BesselI0e<T>>,
}

impl<T> GraphOperation for BesselI0e<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("BesselI0e_{}")?
        };
        let mut new_op = graph.new_operation("BesselI0e", &op_name)?;
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct BesselI0e<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
{
    x: Edge<T>,
    id_: usize,
}

impl<T> BesselI0e<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
{
    pub fn finish(self) -> BesselI0eOp<T> {
        BesselI0eOp::new(Rc::new(self))
    }

    pub fn new(x: Edge<T>) -> Self {
        Self {
            x,
            id_: new_id(),
        }
    }
}

impl<T, Tperm> TransposeOp<T, Tperm>
where T: con,
      Tperm: con_or_DT_INT32_or_DT_INT64,
{
    pub fn new(inner: Rc<Transpose<T, Tperm>>) -> Self {
        Self{inner}
    }

    pub fn y(&self) -> Edge<T> {
        Edge::<T>::new(self.inner.clone(), 0)
    }
}

struct TransposeOp<T, Tperm>
where T: con,
      Tperm: con_or_DT_INT32_or_DT_INT64,
{
    inner: Rc<Transpose<T, Tperm>>,
}

impl<T, Tperm> GraphOperation for Transpose<T, Tperm>
where T: con,
      Tperm: con_or_DT_INT32_or_DT_INT64,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("Transpose_{}")?
        };
        let mut new_op = graph.new_operation("Transpose", &op_name)?;
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct Transpose<T, Tperm>
where T: con,
      Tperm: con_or_DT_INT32_or_DT_INT64,
{
    x: Edge<T>,
    perm: Edge<Tperm>,
    id_: usize,
}

impl<T, Tperm> Transpose<T, Tperm>
where T: con,
      Tperm: con_or_DT_INT32_or_DT_INT64,
{
    pub fn finish(self) -> TransposeOp<T, Tperm> {
        TransposeOp::new(Rc::new(self))
    }

    pub fn new(x: Edge<T>, perm: Edge<Tperm>) -> Self {
        Self {
            x,
            perm,
            id_: new_id(),
        }
    }
}

impl<T, Tidx> MinOp<T, Tidx>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      Tidx: con_or_DT_INT32_or_DT_INT64,
{
    pub fn new(inner: Rc<Min<T, Tidx>>) -> Self {
        Self{inner}
    }

    pub fn output(&self) -> Edge<T> {
        Edge::<T>::new(self.inner.clone(), 0)
    }
}

struct MinOp<T, Tidx>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      Tidx: con_or_DT_INT32_or_DT_INT64,
{
    inner: Rc<Min<T, Tidx>>,
}

impl<T, Tidx> GraphOperation for Min<T, Tidx>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      Tidx: con_or_DT_INT32_or_DT_INT64,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("Min_{}")?
        };
        let mut new_op = graph.new_operation("Min", &op_name)?;
        {
            match self.keep_dims {
            }
            None => new_op.set_attr_value_proto("keep_dims", &vec![40_u8, 0_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_bool("keep_dims", *attr)})(&value),
        };
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct Min<T, Tidx>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      Tidx: con_or_DT_INT32_or_DT_INT64,
{
    input: Edge<T>,
    reduction_indices: Edge<Tidx>,
    keep_dims: Option<bool>,
    id_: usize,
}

impl<T, Tidx> Min<T, Tidx>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      Tidx: con_or_DT_INT32_or_DT_INT64,
{
    pub fn keep_dims(&mut self, keep_dims: bool) -> &mut Self {
        self.keep_dims = Some(keep_dims);
        &self
    }

    pub fn finish(self) -> MinOp<T, Tidx> {
        MinOp::new(Rc::new(self))
    }

    pub fn new(input: Edge<T>, reduction_indices: Edge<Tidx>) -> Self {
        Self {
            input,
            reduction_indices,
            keep_dims: None,
            id_: new_id(),
        }
    }
}

impl<T> BesselI1eOp<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
{
    pub fn new(inner: Rc<BesselI1e<T>>) -> Self {
        Self{inner}
    }

    pub fn y(&self) -> Edge<T> {
        Edge::<T>::new(self.inner.clone(), 0)
    }
}

struct BesselI1eOp<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
{
    inner: Rc<BesselI1e<T>>,
}

impl<T> GraphOperation for BesselI1e<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("BesselI1e_{}")?
        };
        let mut new_op = graph.new_operation("BesselI1e", &op_name)?;
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct BesselI1e<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
{
    x: Edge<T>,
    id_: usize,
}

impl<T> BesselI1e<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
{
    pub fn finish(self) -> BesselI1eOp<T> {
        BesselI1eOp::new(Rc::new(self))
    }

    pub fn new(x: Edge<T>) -> Self {
        Self {
            x,
            id_: new_id(),
        }
    }
}

impl<T> _UnaryOpsCompositionOp<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_HALF,
{
    pub fn new(inner: Rc<_UnaryOpsComposition<T>>) -> Self {
        Self{inner}
    }

    pub fn y(&self) -> Edge<T> {
        Edge::<T>::new(self.inner.clone(), 0)
    }
}

struct _UnaryOpsCompositionOp<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_HALF,
{
    inner: Rc<_UnaryOpsComposition<T>>,
}

impl<T> GraphOperation for _UnaryOpsComposition<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_HALF,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("_UnaryOpsComposition_{}")?
        };
        let mut new_op = graph.new_operation("_UnaryOpsComposition", &op_name)?;
        {
            (|attrs| {new_op.set_attr_string_list("op_names", attrs)})(&self.op_names)
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct _UnaryOpsComposition<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_HALF,
{
    x: Edge<T>,
    op_names: Vec<String>,
    id_: usize,
}

impl<T> _UnaryOpsComposition<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_HALF,
{
    pub fn finish(self) -> _UnaryOpsCompositionOp<T> {
        _UnaryOpsCompositionOp::new(Rc::new(self))
    }

    pub fn new(x: Edge<T>, op_names: &[String]) -> Self {
        Self {
            x,
            op_names: op_names.to_vec()
            id_: new_id(),
        }
    }
}

impl<T> IsInfOp<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
{
    pub fn new(inner: Rc<IsInf<T>>) -> Self {
        Self{inner}
    }

    pub fn y(&self) -> Edge<bool> {
        Edge::<bool>::new(self.inner.clone(), 0)
    }
}

struct IsInfOp<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
{
    inner: Rc<IsInf<T>>,
}

impl<T> GraphOperation for IsInf<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("IsInf_{}")?
        };
        let mut new_op = graph.new_operation("IsInf", &op_name)?;
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct IsInf<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
{
    x: Edge<T>,
    id_: usize,
}

impl<T> IsInf<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
{
    pub fn finish(self) -> IsInfOp<T> {
        IsInfOp::new(Rc::new(self))
    }

    pub fn new(x: Edge<T>) -> Self {
        Self {
            x,
            id_: new_id(),
        }
    }
}

impl<T> RintOp<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
{
    pub fn new(inner: Rc<Rint<T>>) -> Self {
        Self{inner}
    }

    pub fn y(&self) -> Edge<T> {
        Edge::<T>::new(self.inner.clone(), 0)
    }
}

struct RintOp<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
{
    inner: Rc<Rint<T>>,
}

impl<T> GraphOperation for Rint<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("Rint_{}")?
        };
        let mut new_op = graph.new_operation("Rint", &op_name)?;
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct Rint<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
{
    x: Edge<T>,
    id_: usize,
}

impl<T> Rint<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
{
    pub fn finish(self) -> RintOp<T> {
        RintOp::new(Rc::new(self))
    }

    pub fn new(x: Edge<T>) -> Self {
        Self {
            x,
            id_: new_id(),
        }
    }
}

impl<T> SubOp<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF,
{
    pub fn new(inner: Rc<Sub<T>>) -> Self {
        Self{inner}
    }

    pub fn z(&self) -> Edge<T> {
        Edge::<T>::new(self.inner.clone(), 0)
    }
}

struct SubOp<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF,
{
    inner: Rc<Sub<T>>,
}

impl<T> GraphOperation for Sub<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("Sub_{}")?
        };
        let mut new_op = graph.new_operation("Sub", &op_name)?;
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct Sub<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF,
{
    x: Edge<T>,
    y: Edge<T>,
    id_: usize,
}

impl<T> Sub<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF,
{
    pub fn finish(self) -> SubOp<T> {
        SubOp::new(Rc::new(self))
    }

    pub fn new(x: Edge<T>, y: Edge<T>) -> Self {
        Self {
            x,
            y,
            id_: new_id(),
        }
    }
}

impl<T> _MklSubOp<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_COMPLEX64_or_DT_INT64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF,
{
    pub fn new(inner: Rc<_MklSub<T>>) -> Self {
        Self{inner}
    }

    pub fn z(&self) -> Edge<T> {
        Edge::<T>::new(self.inner.clone(), 0)
    }

    pub fn mkl_z(&self) -> Edge<u8> {
        Edge::<u8>::new(self.inner.clone(), 1)
    }
}

struct _MklSubOp<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_COMPLEX64_or_DT_INT64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF,
{
    inner: Rc<_MklSub<T>>,
}

impl<T> GraphOperation for _MklSub<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_COMPLEX64_or_DT_INT64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("_MklSub_{}")?
        };
        let mut new_op = graph.new_operation("_MklSub", &op_name)?;
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct _MklSub<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_COMPLEX64_or_DT_INT64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF,
{
    x: Edge<T>,
    y: Edge<T>,
    mkl_x: Edge<u8>,
    mkl_y: Edge<u8>,
    id_: usize,
}

impl<T> _MklSub<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_COMPLEX64_or_DT_INT64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF,
{
    pub fn finish(self) -> _MklSubOp<T> {
        _MklSubOp::new(Rc::new(self))
    }

    pub fn new(x: Edge<T>, y: Edge<T>, mkl_x: Edge<u8>, mkl_y: Edge<u8>) -> Self {
        Self {
            x,
            y,
            mkl_x,
            mkl_y,
            id_: new_id(),
        }
    }
}

impl BoostedTreesCalculateBestGainsPerFeatureOp {
    pub fn new(inner: Rc<BoostedTreesCalculateBestGainsPerFeature>) -> Self {
        Self{inner}
    }

    pub fn node_ids_list(&self) -> Edge<i32> {
        Edge::<i32>::new(self.inner.clone(), 0)
    }

    pub fn gains_list(&self) -> Edge<f32> {
        Edge::<f32>::new(self.inner.clone(), 1)
    }

    pub fn thresholds_list(&self) -> Edge<i32> {
        Edge::<i32>::new(self.inner.clone(), 2)
    }

    pub fn left_node_contribs_list(&self) -> Edge<f32> {
        Edge::<f32>::new(self.inner.clone(), 3)
    }

    pub fn right_node_contribs_list(&self) -> Edge<f32> {
        Edge::<f32>::new(self.inner.clone(), 4)
    }
}

struct BoostedTreesCalculateBestGainsPerFeatureOp {
    inner: Rc<BoostedTreesCalculateBestGainsPerFeature>,
}

impl GraphOperation for BoostedTreesCalculateBestGainsPerFeature {
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("BoostedTreesCalculateBestGainsPerFeature_{}")?
        };
        let mut new_op = graph.new_operation("BoostedTreesCalculateBestGainsPerFeature", &op_name)?;
        {
            (|attr| {new_op.set_attr_int("max_splits", *attr)})(&self.max_splits)
        }
        {
            (|attr| {new_op.set_attr_int("num_features", *attr)})(&self.num_features)
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct BoostedTreesCalculateBestGainsPerFeature {
    node_id_range: Edge<i32>,
    stats_summary_list: Edge<f32>,
    l1: Edge<f32>,
    l2: Edge<f32>,
    tree_complexity: Edge<f32>,
    min_node_weight: Edge<f32>,
    max_splits: i64,
    num_features: i64,
    id_: usize,
}

impl BoostedTreesCalculateBestGainsPerFeature {
    pub fn finish(self) -> BoostedTreesCalculateBestGainsPerFeatureOp {
        BoostedTreesCalculateBestGainsPerFeatureOp::new(Rc::new(self))
    }

    pub fn new(node_id_range: Edge<i32>, stats_summary_list: Edge<f32>, l1: Edge<f32>, l2: Edge<f32>, tree_complexity: Edge<f32>, min_node_weight: Edge<f32>, max_splits: int, num_features: int) -> Self {
        Self {
            node_id_range,
            stats_summary_list,
            l1,
            l2,
            tree_complexity,
            min_node_weight,
            max_splits: max_splits
            num_features: num_features
            id_: new_id(),
        }
    }
}

impl<T> EncodePngOp<T>
where T: con_or_DT_UINT8_or_DT_UINT16,
{
    pub fn new(inner: Rc<EncodePng<T>>) -> Self {
        Self{inner}
    }

    pub fn contents(&self) -> Edge<String> {
        Edge::<String>::new(self.inner.clone(), 0)
    }
}

struct EncodePngOp<T>
where T: con_or_DT_UINT8_or_DT_UINT16,
{
    inner: Rc<EncodePng<T>>,
}

impl<T> GraphOperation for EncodePng<T>
where T: con_or_DT_UINT8_or_DT_UINT16,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("EncodePng_{}")?
        };
        let mut new_op = graph.new_operation("EncodePng", &op_name)?;
        {
            match self.compression {
            }
            None => new_op.set_attr_value_proto("compression", &vec![24_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 1_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_int("compression", *attr)})(&value),
        };
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct EncodePng<T>
where T: con_or_DT_UINT8_or_DT_UINT16,
{
    image: Edge<T>,
    compression: Option<i64>,
    id_: usize,
}

impl<T> EncodePng<T>
where T: con_or_DT_UINT8_or_DT_UINT16,
{
    pub fn compression(&mut self, compression: int) -> &mut Self {
        self.compression = Some(compression);
        &self
    }

    pub fn finish(self) -> EncodePngOp<T> {
        EncodePngOp::new(Rc::new(self))
    }

    pub fn new(image: Edge<T>) -> Self {
        Self {
            image,
            compression: None,
            id_: new_id(),
        }
    }
}

impl<T> _MklMulOp<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF,
{
    pub fn new(inner: Rc<_MklMul<T>>) -> Self {
        Self{inner}
    }

    pub fn z(&self) -> Edge<T> {
        Edge::<T>::new(self.inner.clone(), 0)
    }

    pub fn mkl_z(&self) -> Edge<u8> {
        Edge::<u8>::new(self.inner.clone(), 1)
    }
}

struct _MklMulOp<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF,
{
    inner: Rc<_MklMul<T>>,
}

impl<T> GraphOperation for _MklMul<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("_MklMul_{}")?
        };
        let mut new_op = graph.new_operation("_MklMul", &op_name)?;
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct _MklMul<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF,
{
    x: Edge<T>,
    y: Edge<T>,
    mkl_x: Edge<u8>,
    mkl_y: Edge<u8>,
    id_: usize,
}

impl<T> _MklMul<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF,
{
    pub fn finish(self) -> _MklMulOp<T> {
        _MklMulOp::new(Rc::new(self))
    }

    pub fn new(x: Edge<T>, y: Edge<T>, mkl_x: Edge<u8>, mkl_y: Edge<u8>) -> Self {
        Self {
            x,
            y,
            mkl_x,
            mkl_y,
            id_: new_id(),
        }
    }
}

impl<T> DivOp<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF,
{
    pub fn new(inner: Rc<Div<T>>) -> Self {
        Self{inner}
    }

    pub fn z(&self) -> Edge<T> {
        Edge::<T>::new(self.inner.clone(), 0)
    }
}

struct DivOp<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF,
{
    inner: Rc<Div<T>>,
}

impl<T> GraphOperation for Div<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("Div_{}")?
        };
        let mut new_op = graph.new_operation("Div", &op_name)?;
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct Div<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF,
{
    x: Edge<T>,
    y: Edge<T>,
    id_: usize,
}

impl<T> Div<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF,
{
    pub fn finish(self) -> DivOp<T> {
        DivOp::new(Rc::new(self))
    }

    pub fn new(x: Edge<T>, y: Edge<T>) -> Self {
        Self {
            x,
            y,
            id_: new_id(),
        }
    }
}

impl<dtype> TensorArrayPackOp<dtype>
where dtype: con,
{
    pub fn new(inner: Rc<TensorArrayPack<dtype>>) -> Self {
        Self{inner}
    }

    pub fn value(&self) -> Edge<dtype> {
        Edge::<dtype>::new(self.inner.clone(), 0)
    }
}

struct TensorArrayPackOp<dtype>
where dtype: con,
{
    inner: Rc<TensorArrayPack<dtype>>,
}

impl<dtype> GraphOperation for TensorArrayPack<dtype>
where dtype: con,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("TensorArrayPack_{}")?
        };
        let mut new_op = graph.new_operation("TensorArrayPack", &op_name)?;
        {
            match self.element_shape {
            }
            None => new_op.set_attr_value_proto("element_shape", &vec![58_u8, 0_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_shape("element_shape", attr)})(&value),
        };
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct TensorArrayPack<dtype>
where dtype: con,
{
    handle: Edge<String>,
    flow_in: Edge<f32>,
    element_shape: Option<Shape>,
    id_: usize,
}

impl<dtype> TensorArrayPack<dtype>
where dtype: con,
{
    pub fn element_shape(&mut self, element_shape: &Shape) -> &mut Self {
        self.element_shape = Some(element_shape.clone());
        &self
    }

    pub fn finish(self) -> TensorArrayPackOp<dtype> {
        TensorArrayPackOp::new(Rc::new(self))
    }

    pub fn new(handle: Edge<String>, flow_in: Edge<f32>) -> Self {
        Self {
            handle,
            flow_in,
            element_shape: None,
            id_: new_id(),
        }
    }
}

impl<T> MaximumOp<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_INT64_or_DT_BFLOAT16_or_DT_HALF,
{
    pub fn new(inner: Rc<Maximum<T>>) -> Self {
        Self{inner}
    }

    pub fn z(&self) -> Edge<T> {
        Edge::<T>::new(self.inner.clone(), 0)
    }
}

struct MaximumOp<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_INT64_or_DT_BFLOAT16_or_DT_HALF,
{
    inner: Rc<Maximum<T>>,
}

impl<T> GraphOperation for Maximum<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_INT64_or_DT_BFLOAT16_or_DT_HALF,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("Maximum_{}")?
        };
        let mut new_op = graph.new_operation("Maximum", &op_name)?;
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct Maximum<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_INT64_or_DT_BFLOAT16_or_DT_HALF,
{
    x: Edge<T>,
    y: Edge<T>,
    id_: usize,
}

impl<T> Maximum<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_INT64_or_DT_BFLOAT16_or_DT_HALF,
{
    pub fn finish(self) -> MaximumOp<T> {
        MaximumOp::new(Rc::new(self))
    }

    pub fn new(x: Edge<T>, y: Edge<T>) -> Self {
        Self {
            x,
            y,
            id_: new_id(),
        }
    }
}

impl WriteFileOp {
    pub fn new(inner: Rc<WriteFile>) -> Self {
        Self{inner}
    }
}

struct WriteFileOp {
    inner: Rc<WriteFile>,
}

impl GraphOperation for WriteFile {
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("WriteFile_{}")?
        };
        let mut new_op = graph.new_operation("WriteFile", &op_name)?;
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct WriteFile {
    filename: Edge<String>,
    contents: Edge<String>,
    id_: usize,
}

impl WriteFile {
    pub fn finish(self) -> WriteFileOp {
        WriteFileOp::new(Rc::new(self))
    }

    pub fn new(filename: Edge<String>, contents: Edge<String>) -> Self {
        Self {
            filename,
            contents,
            id_: new_id(),
        }
    }
}

impl<T> _MklMaximumOp<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_INT64_or_DT_HALF,
{
    pub fn new(inner: Rc<_MklMaximum<T>>) -> Self {
        Self{inner}
    }

    pub fn z(&self) -> Edge<T> {
        Edge::<T>::new(self.inner.clone(), 0)
    }

    pub fn mkl_z(&self) -> Edge<u8> {
        Edge::<u8>::new(self.inner.clone(), 1)
    }
}

struct _MklMaximumOp<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_INT64_or_DT_HALF,
{
    inner: Rc<_MklMaximum<T>>,
}

impl<T> GraphOperation for _MklMaximum<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_INT64_or_DT_HALF,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("_MklMaximum_{}")?
        };
        let mut new_op = graph.new_operation("_MklMaximum", &op_name)?;
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct _MklMaximum<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_INT64_or_DT_HALF,
{
    x: Edge<T>,
    y: Edge<T>,
    mkl_x: Edge<u8>,
    mkl_y: Edge<u8>,
    id_: usize,
}

impl<T> _MklMaximum<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_INT64_or_DT_HALF,
{
    pub fn finish(self) -> _MklMaximumOp<T> {
        _MklMaximumOp::new(Rc::new(self))
    }

    pub fn new(x: Edge<T>, y: Edge<T>, mkl_x: Edge<u8>, mkl_y: Edge<u8>) -> Self {
        Self {
            x,
            y,
            mkl_x,
            mkl_y,
            id_: new_id(),
        }
    }
}

impl<dtype> SparseAccumulatorTakeGradientOp<dtype>
where dtype: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
{
    pub fn new(inner: Rc<SparseAccumulatorTakeGradient<dtype>>) -> Self {
        Self{inner}
    }

    pub fn indices(&self) -> Edge<i64> {
        Edge::<i64>::new(self.inner.clone(), 0)
    }

    pub fn values(&self) -> Edge<dtype> {
        Edge::<dtype>::new(self.inner.clone(), 1)
    }

    pub fn shape(&self) -> Edge<i64> {
        Edge::<i64>::new(self.inner.clone(), 2)
    }
}

struct SparseAccumulatorTakeGradientOp<dtype>
where dtype: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
{
    inner: Rc<SparseAccumulatorTakeGradient<dtype>>,
}

impl<dtype> GraphOperation for SparseAccumulatorTakeGradient<dtype>
where dtype: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("SparseAccumulatorTakeGradient_{}")?
        };
        let mut new_op = graph.new_operation("SparseAccumulatorTakeGradient", &op_name)?;
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct SparseAccumulatorTakeGradient<dtype>
where dtype: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
{
    handle: Edge<String>,
    num_required: Edge<i32>,
    id_: usize,
}

impl<dtype> SparseAccumulatorTakeGradient<dtype>
where dtype: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
{
    pub fn finish(self) -> SparseAccumulatorTakeGradientOp<dtype> {
        SparseAccumulatorTakeGradientOp::new(Rc::new(self))
    }

    pub fn new(handle: Edge<String>, num_required: Edge<i32>) -> Self {
        Self {
            handle,
            num_required,
            id_: new_id(),
        }
    }
}

impl<T> FloorModOp<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_INT64_or_DT_BFLOAT16_or_DT_HALF,
{
    pub fn new(inner: Rc<FloorMod<T>>) -> Self {
        Self{inner}
    }

    pub fn z(&self) -> Edge<T> {
        Edge::<T>::new(self.inner.clone(), 0)
    }
}

struct FloorModOp<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_INT64_or_DT_BFLOAT16_or_DT_HALF,
{
    inner: Rc<FloorMod<T>>,
}

impl<T> GraphOperation for FloorMod<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_INT64_or_DT_BFLOAT16_or_DT_HALF,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("FloorMod_{}")?
        };
        let mut new_op = graph.new_operation("FloorMod", &op_name)?;
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct FloorMod<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_INT64_or_DT_BFLOAT16_or_DT_HALF,
{
    x: Edge<T>,
    y: Edge<T>,
    id_: usize,
}

impl<T> FloorMod<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_INT64_or_DT_BFLOAT16_or_DT_HALF,
{
    pub fn finish(self) -> FloorModOp<T> {
        FloorModOp::new(Rc::new(self))
    }

    pub fn new(x: Edge<T>, y: Edge<T>) -> Self {
        Self {
            x,
            y,
            id_: new_id(),
        }
    }
}

impl<T> TruncateModOp<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_INT64_or_DT_BFLOAT16_or_DT_HALF,
{
    pub fn new(inner: Rc<TruncateMod<T>>) -> Self {
        Self{inner}
    }

    pub fn z(&self) -> Edge<T> {
        Edge::<T>::new(self.inner.clone(), 0)
    }
}

struct TruncateModOp<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_INT64_or_DT_BFLOAT16_or_DT_HALF,
{
    inner: Rc<TruncateMod<T>>,
}

impl<T> GraphOperation for TruncateMod<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_INT64_or_DT_BFLOAT16_or_DT_HALF,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("TruncateMod_{}")?
        };
        let mut new_op = graph.new_operation("TruncateMod", &op_name)?;
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct TruncateMod<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_INT64_or_DT_BFLOAT16_or_DT_HALF,
{
    x: Edge<T>,
    y: Edge<T>,
    id_: usize,
}

impl<T> TruncateMod<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_INT64_or_DT_BFLOAT16_or_DT_HALF,
{
    pub fn finish(self) -> TruncateModOp<T> {
        TruncateModOp::new(Rc::new(self))
    }

    pub fn new(x: Edge<T>, y: Edge<T>) -> Self {
        Self {
            x,
            y,
            id_: new_id(),
        }
    }
}

impl LoadTPUEmbeddingRMSPropParametersGradAccumDebugOp {
    pub fn new(inner: Rc<LoadTPUEmbeddingRMSPropParametersGradAccumDebug>) -> Self {
        Self{inner}
    }
}

struct LoadTPUEmbeddingRMSPropParametersGradAccumDebugOp {
    inner: Rc<LoadTPUEmbeddingRMSPropParametersGradAccumDebug>,
}

impl GraphOperation for LoadTPUEmbeddingRMSPropParametersGradAccumDebug {
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("LoadTPUEmbeddingRMSPropParametersGradAccumDebug_{}")?
        };
        let mut new_op = graph.new_operation("LoadTPUEmbeddingRMSPropParametersGradAccumDebug", &op_name)?;
        {
            match self.table_id {
            }
            None => new_op.set_attr_value_proto("table_id", &vec![24_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 1_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_int("table_id", *attr)})(&value),
        };
        {
            match self.table_name {
            }
            None => new_op.set_attr_value_proto("table_name", &vec![18_u8, 0_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_string("table_name", attr)})(&value),
        };
        {
            (|attr| {new_op.set_attr_int("num_shards", *attr)})(&self.num_shards)
        }
        {
            (|attr| {new_op.set_attr_int("shard_id", *attr)})(&self.shard_id)
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct LoadTPUEmbeddingRMSPropParametersGradAccumDebug {
    parameters: Edge<f32>,
    ms: Edge<f32>,
    mom: Edge<f32>,
    gradient_accumulators: Edge<f32>,
    table_id: Option<i64>,
    table_name: Option<String>,
    num_shards: i64,
    shard_id: i64,
    id_: usize,
}

impl LoadTPUEmbeddingRMSPropParametersGradAccumDebug {
    pub fn table_id(&mut self, table_id: int) -> &mut Self {
        self.table_id = Some(table_id);
        &self
    }

    pub fn table_name(&mut self, table_name: &str) -> &mut Self {
        self.table_name = Some(table_name.to_string());
        &self
    }

    pub fn finish(self) -> LoadTPUEmbeddingRMSPropParametersGradAccumDebugOp {
        LoadTPUEmbeddingRMSPropParametersGradAccumDebugOp::new(Rc::new(self))
    }

    pub fn new(parameters: Edge<f32>, ms: Edge<f32>, mom: Edge<f32>, gradient_accumulators: Edge<f32>, num_shards: int, shard_id: int) -> Self {
        Self {
            parameters,
            ms,
            mom,
            gradient_accumulators,
            table_id: None,
            table_name: None,
            num_shards: num_shards
            shard_id: shard_id
            id_: new_id(),
        }
    }
}

impl ConcatOffsetOp {
    pub fn new(inner: Rc<ConcatOffset>) -> Self {
        Self{inner}
    }

    pub fn offset(&self) -> Edge<i32> {
        Edge::<i32>::new(self.inner.clone(), 0)
    }
}

struct ConcatOffsetOp {
    inner: Rc<ConcatOffset>,
}

impl GraphOperation for ConcatOffset {
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("ConcatOffset_{}")?
        };
        let mut new_op = graph.new_operation("ConcatOffset", &op_name)?;
        {
            (|attr| {new_op.set_attr_int("N", *attr)})(&self.N)
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct ConcatOffset {
    concat_dim: Edge<i32>,
    shape: Edge<i32>,
    N: i64,
    id_: usize,
}

impl ConcatOffset {
    pub fn finish(self) -> ConcatOffsetOp {
        ConcatOffsetOp::new(Rc::new(self))
    }

    pub fn new(concat_dim: Edge<i32>, shape: Edge<i32>, N: int) -> Self {
        Self {
            concat_dim,
            shape,
            N: N
            id_: new_id(),
        }
    }
}

impl<T> IgammaOp<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE,
{
    pub fn new(inner: Rc<Igamma<T>>) -> Self {
        Self{inner}
    }

    pub fn z(&self) -> Edge<T> {
        Edge::<T>::new(self.inner.clone(), 0)
    }
}

struct IgammaOp<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE,
{
    inner: Rc<Igamma<T>>,
}

impl<T> GraphOperation for Igamma<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("Igamma_{}")?
        };
        let mut new_op = graph.new_operation("Igamma", &op_name)?;
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct Igamma<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE,
{
    a: Edge<T>,
    x: Edge<T>,
    id_: usize,
}

impl<T> Igamma<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE,
{
    pub fn finish(self) -> IgammaOp<T> {
        IgammaOp::new(Rc::new(self))
    }

    pub fn new(a: Edge<T>, x: Edge<T>) -> Self {
        Self {
            a,
            x,
            id_: new_id(),
        }
    }
}

impl<T> PolygammaOp<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE,
{
    pub fn new(inner: Rc<Polygamma<T>>) -> Self {
        Self{inner}
    }

    pub fn z(&self) -> Edge<T> {
        Edge::<T>::new(self.inner.clone(), 0)
    }
}

struct PolygammaOp<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE,
{
    inner: Rc<Polygamma<T>>,
}

impl<T> GraphOperation for Polygamma<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("Polygamma_{}")?
        };
        let mut new_op = graph.new_operation("Polygamma", &op_name)?;
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct Polygamma<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE,
{
    a: Edge<T>,
    x: Edge<T>,
    id_: usize,
}

impl<T> Polygamma<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE,
{
    pub fn finish(self) -> PolygammaOp<T> {
        PolygammaOp::new(Rc::new(self))
    }

    pub fn new(a: Edge<T>, x: Edge<T>) -> Self {
        Self {
            a,
            x,
            id_: new_id(),
        }
    }
}

impl<T> IdentityOp<T>
where T: con,
{
    pub fn new(inner: Rc<Identity<T>>) -> Self {
        Self{inner}
    }

    pub fn output(&self) -> Edge<T> {
        Edge::<T>::new(self.inner.clone(), 0)
    }
}

struct IdentityOp<T>
where T: con,
{
    inner: Rc<Identity<T>>,
}

impl<T> GraphOperation for Identity<T>
where T: con,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("Identity_{}")?
        };
        let mut new_op = graph.new_operation("Identity", &op_name)?;
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct Identity<T>
where T: con,
{
    input: Edge<T>,
    id_: usize,
}

impl<T> Identity<T>
where T: con,
{
    pub fn finish(self) -> IdentityOp<T> {
        IdentityOp::new(Rc::new(self))
    }

    pub fn new(input: Edge<T>) -> Self {
        Self {
            input,
            id_: new_id(),
        }
    }
}

impl<T> Atan2Op<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
{
    pub fn new(inner: Rc<Atan2<T>>) -> Self {
        Self{inner}
    }

    pub fn z(&self) -> Edge<T> {
        Edge::<T>::new(self.inner.clone(), 0)
    }
}

struct Atan2Op<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
{
    inner: Rc<Atan2<T>>,
}

impl<T> GraphOperation for Atan2<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("Atan2_{}")?
        };
        let mut new_op = graph.new_operation("Atan2", &op_name)?;
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct Atan2<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
{
    y: Edge<T>,
    x: Edge<T>,
    id_: usize,
}

impl<T> Atan2<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
{
    pub fn finish(self) -> Atan2Op<T> {
        Atan2Op::new(Rc::new(self))
    }

    pub fn new(y: Edge<T>, x: Edge<T>) -> Self {
        Self {
            y,
            x,
            id_: new_id(),
        }
    }
}

impl EnqueueTPUEmbeddingIntegerBatchOp {
    pub fn new(inner: Rc<EnqueueTPUEmbeddingIntegerBatch>) -> Self {
        Self{inner}
    }
}

struct EnqueueTPUEmbeddingIntegerBatchOp {
    inner: Rc<EnqueueTPUEmbeddingIntegerBatch>,
}

impl GraphOperation for EnqueueTPUEmbeddingIntegerBatch {
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("EnqueueTPUEmbeddingIntegerBatch_{}")?
        };
        let mut new_op = graph.new_operation("EnqueueTPUEmbeddingIntegerBatch", &op_name)?;
        {
            (|attr| {new_op.set_attr_int("N", *attr)})(&self.N)
        }
        {
            match self.device_ordinal {
            }
            None => new_op.set_attr_value_proto("device_ordinal", &vec![24_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 1_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_int("device_ordinal", *attr)})(&value),
        };
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct EnqueueTPUEmbeddingIntegerBatch {
    batch: Edge<i32>,
    mode_override: Edge<String>,
    N: i64,
    device_ordinal: Option<i64>,
    id_: usize,
}

impl EnqueueTPUEmbeddingIntegerBatch {
    pub fn device_ordinal(&mut self, device_ordinal: int) -> &mut Self {
        self.device_ordinal = Some(device_ordinal);
        &self
    }

    pub fn finish(self) -> EnqueueTPUEmbeddingIntegerBatchOp {
        EnqueueTPUEmbeddingIntegerBatchOp::new(Rc::new(self))
    }

    pub fn new(batch: Edge<i32>, mode_override: Edge<String>, N: int) -> Self {
        Self {
            batch,
            mode_override,
            N: N
            device_ordinal: None,
            id_: new_id(),
        }
    }
}

impl<T> LessEqualOp<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
{
    pub fn new(inner: Rc<LessEqual<T>>) -> Self {
        Self{inner}
    }

    pub fn z(&self) -> Edge<bool> {
        Edge::<bool>::new(self.inner.clone(), 0)
    }
}

struct LessEqualOp<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
{
    inner: Rc<LessEqual<T>>,
}

impl<T> GraphOperation for LessEqual<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("LessEqual_{}")?
        };
        let mut new_op = graph.new_operation("LessEqual", &op_name)?;
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct LessEqual<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
{
    x: Edge<T>,
    y: Edge<T>,
    id_: usize,
}

impl<T> LessEqual<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
{
    pub fn finish(self) -> LessEqualOp<T> {
        LessEqualOp::new(Rc::new(self))
    }

    pub fn new(x: Edge<T>, y: Edge<T>) -> Self {
        Self {
            x,
            y,
            id_: new_id(),
        }
    }
}

impl<T> GreaterEqualOp<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
{
    pub fn new(inner: Rc<GreaterEqual<T>>) -> Self {
        Self{inner}
    }

    pub fn z(&self) -> Edge<bool> {
        Edge::<bool>::new(self.inner.clone(), 0)
    }
}

struct GreaterEqualOp<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
{
    inner: Rc<GreaterEqual<T>>,
}

impl<T> GraphOperation for GreaterEqual<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("GreaterEqual_{}")?
        };
        let mut new_op = graph.new_operation("GreaterEqual", &op_name)?;
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct GreaterEqual<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
{
    x: Edge<T>,
    y: Edge<T>,
    id_: usize,
}

impl<T> GreaterEqual<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
{
    pub fn finish(self) -> GreaterEqualOp<T> {
        GreaterEqualOp::new(Rc::new(self))
    }

    pub fn new(x: Edge<T>, y: Edge<T>) -> Self {
        Self {
            x,
            y,
            id_: new_id(),
        }
    }
}

impl<dtype> TensorArrayGatherV2Op<dtype>
where dtype: con,
{
    pub fn new(inner: Rc<TensorArrayGatherV2<dtype>>) -> Self {
        Self{inner}
    }

    pub fn value(&self) -> Edge<dtype> {
        Edge::<dtype>::new(self.inner.clone(), 0)
    }
}

struct TensorArrayGatherV2Op<dtype>
where dtype: con,
{
    inner: Rc<TensorArrayGatherV2<dtype>>,
}

impl<dtype> GraphOperation for TensorArrayGatherV2<dtype>
where dtype: con,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("TensorArrayGatherV2_{}")?
        };
        let mut new_op = graph.new_operation("TensorArrayGatherV2", &op_name)?;
        {
            match self.element_shape {
            }
            None => new_op.set_attr_value_proto("element_shape", &vec![58_u8, 0_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_shape("element_shape", attr)})(&value),
        };
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct TensorArrayGatherV2<dtype>
where dtype: con,
{
    handle: Edge<String>,
    indices: Edge<i32>,
    flow_in: Edge<f32>,
    element_shape: Option<Shape>,
    id_: usize,
}

impl<dtype> TensorArrayGatherV2<dtype>
where dtype: con,
{
    pub fn element_shape(&mut self, element_shape: &Shape) -> &mut Self {
        self.element_shape = Some(element_shape.clone());
        &self
    }

    pub fn finish(self) -> TensorArrayGatherV2Op<dtype> {
        TensorArrayGatherV2Op::new(Rc::new(self))
    }

    pub fn new(handle: Edge<String>, indices: Edge<i32>, flow_in: Edge<f32>) -> Self {
        Self {
            handle,
            indices,
            flow_in,
            element_shape: None,
            id_: new_id(),
        }
    }
}

pub trait con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_STRING_or_DT_COMPLEX64_or_DT_INT64_or_DT_BOOL_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_STRING_or_DT_COMPLEX64_or_DT_INT64_or_DT_BOOL_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF for BFloat16 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_STRING_or_DT_COMPLEX64_or_DT_INT64_or_DT_BOOL_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF for OtherComplex<f32> {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_STRING_or_DT_COMPLEX64_or_DT_INT64_or_DT_BOOL_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF for OtherComplex<f64> {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_STRING_or_DT_COMPLEX64_or_DT_INT64_or_DT_BOOL_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF for String {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_STRING_or_DT_COMPLEX64_or_DT_INT64_or_DT_BOOL_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF for bool {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_STRING_or_DT_COMPLEX64_or_DT_INT64_or_DT_BOOL_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF for f32 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_STRING_or_DT_COMPLEX64_or_DT_INT64_or_DT_BOOL_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF for f64 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_STRING_or_DT_COMPLEX64_or_DT_INT64_or_DT_BOOL_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF for i16 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_STRING_or_DT_COMPLEX64_or_DT_INT64_or_DT_BOOL_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF for i32 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_STRING_or_DT_COMPLEX64_or_DT_INT64_or_DT_BOOL_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF for i64 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_STRING_or_DT_COMPLEX64_or_DT_INT64_or_DT_BOOL_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF for i8 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_STRING_or_DT_COMPLEX64_or_DT_INT64_or_DT_BOOL_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF for u8 {
}

impl<T> EqualOp<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_STRING_or_DT_COMPLEX64_or_DT_INT64_or_DT_BOOL_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF,
{
    pub fn new(inner: Rc<Equal<T>>) -> Self {
        Self{inner}
    }

    pub fn z(&self) -> Edge<bool> {
        Edge::<bool>::new(self.inner.clone(), 0)
    }
}

struct EqualOp<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_STRING_or_DT_COMPLEX64_or_DT_INT64_or_DT_BOOL_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF,
{
    inner: Rc<Equal<T>>,
}

impl<T> GraphOperation for Equal<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_STRING_or_DT_COMPLEX64_or_DT_INT64_or_DT_BOOL_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("Equal_{}")?
        };
        let mut new_op = graph.new_operation("Equal", &op_name)?;
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct Equal<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_STRING_or_DT_COMPLEX64_or_DT_INT64_or_DT_BOOL_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF,
{
    x: Edge<T>,
    y: Edge<T>,
    id_: usize,
}

impl<T> Equal<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_STRING_or_DT_COMPLEX64_or_DT_INT64_or_DT_BOOL_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF,
{
    pub fn finish(self) -> EqualOp<T> {
        EqualOp::new(Rc::new(self))
    }

    pub fn new(x: Edge<T>, y: Edge<T>) -> Self {
        Self {
            x,
            y,
            id_: new_id(),
        }
    }
}

impl<T> NotEqualOp<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_STRING_or_DT_COMPLEX64_or_DT_INT64_or_DT_BOOL_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF,
{
    pub fn new(inner: Rc<NotEqual<T>>) -> Self {
        Self{inner}
    }

    pub fn z(&self) -> Edge<bool> {
        Edge::<bool>::new(self.inner.clone(), 0)
    }
}

struct NotEqualOp<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_STRING_or_DT_COMPLEX64_or_DT_INT64_or_DT_BOOL_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF,
{
    inner: Rc<NotEqual<T>>,
}

impl<T> GraphOperation for NotEqual<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_STRING_or_DT_COMPLEX64_or_DT_INT64_or_DT_BOOL_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("NotEqual_{}")?
        };
        let mut new_op = graph.new_operation("NotEqual", &op_name)?;
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct NotEqual<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_STRING_or_DT_COMPLEX64_or_DT_INT64_or_DT_BOOL_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF,
{
    x: Edge<T>,
    y: Edge<T>,
    id_: usize,
}

impl<T> NotEqual<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_STRING_or_DT_COMPLEX64_or_DT_INT64_or_DT_BOOL_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF,
{
    pub fn finish(self) -> NotEqualOp<T> {
        NotEqualOp::new(Rc::new(self))
    }

    pub fn new(x: Edge<T>, y: Edge<T>) -> Self {
        Self {
            x,
            y,
            id_: new_id(),
        }
    }
}

impl<T> ApproximateEqualOp<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
{
    pub fn new(inner: Rc<ApproximateEqual<T>>) -> Self {
        Self{inner}
    }

    pub fn z(&self) -> Edge<bool> {
        Edge::<bool>::new(self.inner.clone(), 0)
    }
}

struct ApproximateEqualOp<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
{
    inner: Rc<ApproximateEqual<T>>,
}

impl<T> GraphOperation for ApproximateEqual<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("ApproximateEqual_{}")?
        };
        let mut new_op = graph.new_operation("ApproximateEqual", &op_name)?;
        {
            match self.tolerance {
            }
            None => new_op.set_attr_value_proto("tolerance", &vec![37_u8, 172_u8, 197_u8, 39_u8, 55_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_float("tolerance", *attr)})(&value),
        };
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct ApproximateEqual<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
{
    x: Edge<T>,
    y: Edge<T>,
    tolerance: Option<f32>,
    id_: usize,
}

impl<T> ApproximateEqual<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
{
    pub fn tolerance(&mut self, tolerance: f32) -> &mut Self {
        self.tolerance = Some(tolerance);
        &self
    }

    pub fn finish(self) -> ApproximateEqualOp<T> {
        ApproximateEqualOp::new(Rc::new(self))
    }

    pub fn new(x: Edge<T>, y: Edge<T>) -> Self {
        Self {
            x,
            y,
            tolerance: None,
            id_: new_id(),
        }
    }
}

impl<T> MatMulOp<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_COMPLEX64_or_DT_INT64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF,
{
    pub fn new(inner: Rc<MatMul<T>>) -> Self {
        Self{inner}
    }

    pub fn product(&self) -> Edge<T> {
        Edge::<T>::new(self.inner.clone(), 0)
    }
}

struct MatMulOp<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_COMPLEX64_or_DT_INT64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF,
{
    inner: Rc<MatMul<T>>,
}

impl<T> GraphOperation for MatMul<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_COMPLEX64_or_DT_INT64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("MatMul_{}")?
        };
        let mut new_op = graph.new_operation("MatMul", &op_name)?;
        {
            match self.transpose_a {
            }
            None => new_op.set_attr_value_proto("transpose_a", &vec![40_u8, 0_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_bool("transpose_a", *attr)})(&value),
        };
        {
            match self.transpose_b {
            }
            None => new_op.set_attr_value_proto("transpose_b", &vec![40_u8, 0_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_bool("transpose_b", *attr)})(&value),
        };
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct MatMul<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_COMPLEX64_or_DT_INT64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF,
{
    a: Edge<T>,
    b: Edge<T>,
    transpose_a: Option<bool>,
    transpose_b: Option<bool>,
    id_: usize,
}

impl<T> MatMul<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_COMPLEX64_or_DT_INT64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF,
{
    pub fn transpose_a(&mut self, transpose_a: bool) -> &mut Self {
        self.transpose_a = Some(transpose_a);
        &self
    }

    pub fn transpose_b(&mut self, transpose_b: bool) -> &mut Self {
        self.transpose_b = Some(transpose_b);
        &self
    }

    pub fn finish(self) -> MatMulOp<T> {
        MatMulOp::new(Rc::new(self))
    }

    pub fn new(a: Edge<T>, b: Edge<T>) -> Self {
        Self {
            a,
            b,
            transpose_a: None,
            transpose_b: None,
            id_: new_id(),
        }
    }
}

impl<T, Tidx> MeanOp<T, Tidx>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      Tidx: con_or_DT_INT32_or_DT_INT64,
{
    pub fn new(inner: Rc<Mean<T, Tidx>>) -> Self {
        Self{inner}
    }

    pub fn output(&self) -> Edge<T> {
        Edge::<T>::new(self.inner.clone(), 0)
    }
}

struct MeanOp<T, Tidx>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      Tidx: con_or_DT_INT32_or_DT_INT64,
{
    inner: Rc<Mean<T, Tidx>>,
}

impl<T, Tidx> GraphOperation for Mean<T, Tidx>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      Tidx: con_or_DT_INT32_or_DT_INT64,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("Mean_{}")?
        };
        let mut new_op = graph.new_operation("Mean", &op_name)?;
        {
            match self.keep_dims {
            }
            None => new_op.set_attr_value_proto("keep_dims", &vec![40_u8, 0_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_bool("keep_dims", *attr)})(&value),
        };
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct Mean<T, Tidx>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      Tidx: con_or_DT_INT32_or_DT_INT64,
{
    input: Edge<T>,
    reduction_indices: Edge<Tidx>,
    keep_dims: Option<bool>,
    id_: usize,
}

impl<T, Tidx> Mean<T, Tidx>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      Tidx: con_or_DT_INT32_or_DT_INT64,
{
    pub fn keep_dims(&mut self, keep_dims: bool) -> &mut Self {
        self.keep_dims = Some(keep_dims);
        &self
    }

    pub fn finish(self) -> MeanOp<T, Tidx> {
        MeanOp::new(Rc::new(self))
    }

    pub fn new(input: Edge<T>, reduction_indices: Edge<Tidx>) -> Self {
        Self {
            input,
            reduction_indices,
            keep_dims: None,
            id_: new_id(),
        }
    }
}

impl<T, Tidx, output_type> ArgMinOp<T, Tidx, output_type>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      Tidx: con_or_DT_INT32_or_DT_INT64,
      output_type: con_or_DT_INT32_or_DT_INT64,
{
    pub fn new(inner: Rc<ArgMin<T, Tidx, output_type>>) -> Self {
        Self{inner}
    }

    pub fn output(&self) -> Edge<output_type> {
        Edge::<output_type>::new(self.inner.clone(), 0)
    }
}

struct ArgMinOp<T, Tidx, output_type>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      Tidx: con_or_DT_INT32_or_DT_INT64,
      output_type: con_or_DT_INT32_or_DT_INT64,
{
    inner: Rc<ArgMin<T, Tidx, output_type>>,
}

impl<T, Tidx, output_type> GraphOperation for ArgMin<T, Tidx, output_type>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      Tidx: con_or_DT_INT32_or_DT_INT64,
      output_type: con_or_DT_INT32_or_DT_INT64,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("ArgMin_{}")?
        };
        let mut new_op = graph.new_operation("ArgMin", &op_name)?;
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct ArgMin<T, Tidx, output_type>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      Tidx: con_or_DT_INT32_or_DT_INT64,
      output_type: con_or_DT_INT32_or_DT_INT64,
{
    input: Edge<T>,
    dimension: Edge<Tidx>,
    id_: usize,
}

impl<T, Tidx, output_type> ArgMin<T, Tidx, output_type>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      Tidx: con_or_DT_INT32_or_DT_INT64,
      output_type: con_or_DT_INT32_or_DT_INT64,
{
    pub fn finish(self) -> ArgMinOp<T, Tidx, output_type> {
        ArgMinOp::new(Rc::new(self))
    }

    pub fn new(input: Edge<T>, dimension: Edge<Tidx>) -> Self {
        Self {
            input,
            dimension,
            id_: new_id(),
        }
    }
}

impl<Tinput, out_type> RequantizeOp<Tinput, out_type>
where Tinput: con_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_QINT16_or_DT_QUINT16,
      out_type: con_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_QINT16_or_DT_QUINT16,
{
    pub fn new(inner: Rc<Requantize<Tinput, out_type>>) -> Self {
        Self{inner}
    }

    pub fn output(&self) -> Edge<out_type> {
        Edge::<out_type>::new(self.inner.clone(), 0)
    }

    pub fn output_min(&self) -> Edge<f32> {
        Edge::<f32>::new(self.inner.clone(), 1)
    }

    pub fn output_max(&self) -> Edge<f32> {
        Edge::<f32>::new(self.inner.clone(), 2)
    }
}

struct RequantizeOp<Tinput, out_type>
where Tinput: con_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_QINT16_or_DT_QUINT16,
      out_type: con_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_QINT16_or_DT_QUINT16,
{
    inner: Rc<Requantize<Tinput, out_type>>,
}

impl<Tinput, out_type> GraphOperation for Requantize<Tinput, out_type>
where Tinput: con_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_QINT16_or_DT_QUINT16,
      out_type: con_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_QINT16_or_DT_QUINT16,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("Requantize_{}")?
        };
        let mut new_op = graph.new_operation("Requantize", &op_name)?;
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct Requantize<Tinput, out_type>
where Tinput: con_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_QINT16_or_DT_QUINT16,
      out_type: con_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_QINT16_or_DT_QUINT16,
{
    input: Edge<Tinput>,
    input_min: Edge<f32>,
    input_max: Edge<f32>,
    requested_output_min: Edge<f32>,
    requested_output_max: Edge<f32>,
    id_: usize,
}

impl<Tinput, out_type> Requantize<Tinput, out_type>
where Tinput: con_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_QINT16_or_DT_QUINT16,
      out_type: con_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_QINT16_or_DT_QUINT16,
{
    pub fn finish(self) -> RequantizeOp<Tinput, out_type> {
        RequantizeOp::new(Rc::new(self))
    }

    pub fn new(input: Edge<Tinput>, input_min: Edge<f32>, input_max: Edge<f32>, requested_output_min: Edge<f32>, requested_output_max: Edge<f32>) -> Self {
        Self {
            input,
            input_min,
            input_max,
            requested_output_min,
            requested_output_max,
            id_: new_id(),
        }
    }
}

impl<T, Tindices, Tnumsegments> UnsortedSegmentSumOp<T, Tindices, Tnumsegments>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      Tindices: con_or_DT_INT32_or_DT_INT64,
      Tnumsegments: con_or_DT_INT32_or_DT_INT64,
{
    pub fn new(inner: Rc<UnsortedSegmentSum<T, Tindices, Tnumsegments>>) -> Self {
        Self{inner}
    }

    pub fn output(&self) -> Edge<T> {
        Edge::<T>::new(self.inner.clone(), 0)
    }
}

struct UnsortedSegmentSumOp<T, Tindices, Tnumsegments>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      Tindices: con_or_DT_INT32_or_DT_INT64,
      Tnumsegments: con_or_DT_INT32_or_DT_INT64,
{
    inner: Rc<UnsortedSegmentSum<T, Tindices, Tnumsegments>>,
}

impl<T, Tindices, Tnumsegments> GraphOperation for UnsortedSegmentSum<T, Tindices, Tnumsegments>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      Tindices: con_or_DT_INT32_or_DT_INT64,
      Tnumsegments: con_or_DT_INT32_or_DT_INT64,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("UnsortedSegmentSum_{}")?
        };
        let mut new_op = graph.new_operation("UnsortedSegmentSum", &op_name)?;
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct UnsortedSegmentSum<T, Tindices, Tnumsegments>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      Tindices: con_or_DT_INT32_or_DT_INT64,
      Tnumsegments: con_or_DT_INT32_or_DT_INT64,
{
    data: Edge<T>,
    segment_ids: Edge<Tindices>,
    num_segments: Edge<Tnumsegments>,
    id_: usize,
}

impl<T, Tindices, Tnumsegments> UnsortedSegmentSum<T, Tindices, Tnumsegments>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      Tindices: con_or_DT_INT32_or_DT_INT64,
      Tnumsegments: con_or_DT_INT32_or_DT_INT64,
{
    pub fn finish(self) -> UnsortedSegmentSumOp<T, Tindices, Tnumsegments> {
        UnsortedSegmentSumOp::new(Rc::new(self))
    }

    pub fn new(data: Edge<T>, segment_ids: Edge<Tindices>, num_segments: Edge<Tnumsegments>) -> Self {
        Self {
            data,
            segment_ids,
            num_segments,
            id_: new_id(),
        }
    }
}

impl<T, Tindices, Tnumsegments> UnsortedSegmentMinOp<T, Tindices, Tnumsegments>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      Tindices: con_or_DT_INT32_or_DT_INT64,
      Tnumsegments: con_or_DT_INT32_or_DT_INT64,
{
    pub fn new(inner: Rc<UnsortedSegmentMin<T, Tindices, Tnumsegments>>) -> Self {
        Self{inner}
    }

    pub fn output(&self) -> Edge<T> {
        Edge::<T>::new(self.inner.clone(), 0)
    }
}

struct UnsortedSegmentMinOp<T, Tindices, Tnumsegments>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      Tindices: con_or_DT_INT32_or_DT_INT64,
      Tnumsegments: con_or_DT_INT32_or_DT_INT64,
{
    inner: Rc<UnsortedSegmentMin<T, Tindices, Tnumsegments>>,
}

impl<T, Tindices, Tnumsegments> GraphOperation for UnsortedSegmentMin<T, Tindices, Tnumsegments>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      Tindices: con_or_DT_INT32_or_DT_INT64,
      Tnumsegments: con_or_DT_INT32_or_DT_INT64,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("UnsortedSegmentMin_{}")?
        };
        let mut new_op = graph.new_operation("UnsortedSegmentMin", &op_name)?;
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct UnsortedSegmentMin<T, Tindices, Tnumsegments>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      Tindices: con_or_DT_INT32_or_DT_INT64,
      Tnumsegments: con_or_DT_INT32_or_DT_INT64,
{
    data: Edge<T>,
    segment_ids: Edge<Tindices>,
    num_segments: Edge<Tnumsegments>,
    id_: usize,
}

impl<T, Tindices, Tnumsegments> UnsortedSegmentMin<T, Tindices, Tnumsegments>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      Tindices: con_or_DT_INT32_or_DT_INT64,
      Tnumsegments: con_or_DT_INT32_or_DT_INT64,
{
    pub fn finish(self) -> UnsortedSegmentMinOp<T, Tindices, Tnumsegments> {
        UnsortedSegmentMinOp::new(Rc::new(self))
    }

    pub fn new(data: Edge<T>, segment_ids: Edge<Tindices>, num_segments: Edge<Tnumsegments>) -> Self {
        Self {
            data,
            segment_ids,
            num_segments,
            id_: new_id(),
        }
    }
}

impl<T, Tindices, Tnumsegments> UnsortedSegmentProdOp<T, Tindices, Tnumsegments>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      Tindices: con_or_DT_INT32_or_DT_INT64,
      Tnumsegments: con_or_DT_INT32_or_DT_INT64,
{
    pub fn new(inner: Rc<UnsortedSegmentProd<T, Tindices, Tnumsegments>>) -> Self {
        Self{inner}
    }

    pub fn output(&self) -> Edge<T> {
        Edge::<T>::new(self.inner.clone(), 0)
    }
}

struct UnsortedSegmentProdOp<T, Tindices, Tnumsegments>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      Tindices: con_or_DT_INT32_or_DT_INT64,
      Tnumsegments: con_or_DT_INT32_or_DT_INT64,
{
    inner: Rc<UnsortedSegmentProd<T, Tindices, Tnumsegments>>,
}

impl<T, Tindices, Tnumsegments> GraphOperation for UnsortedSegmentProd<T, Tindices, Tnumsegments>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      Tindices: con_or_DT_INT32_or_DT_INT64,
      Tnumsegments: con_or_DT_INT32_or_DT_INT64,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("UnsortedSegmentProd_{}")?
        };
        let mut new_op = graph.new_operation("UnsortedSegmentProd", &op_name)?;
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct UnsortedSegmentProd<T, Tindices, Tnumsegments>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      Tindices: con_or_DT_INT32_or_DT_INT64,
      Tnumsegments: con_or_DT_INT32_or_DT_INT64,
{
    data: Edge<T>,
    segment_ids: Edge<Tindices>,
    num_segments: Edge<Tnumsegments>,
    id_: usize,
}

impl<T, Tindices, Tnumsegments> UnsortedSegmentProd<T, Tindices, Tnumsegments>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      Tindices: con_or_DT_INT32_or_DT_INT64,
      Tnumsegments: con_or_DT_INT32_or_DT_INT64,
{
    pub fn finish(self) -> UnsortedSegmentProdOp<T, Tindices, Tnumsegments> {
        UnsortedSegmentProdOp::new(Rc::new(self))
    }

    pub fn new(data: Edge<T>, segment_ids: Edge<Tindices>, num_segments: Edge<Tnumsegments>) -> Self {
        Self {
            data,
            segment_ids,
            num_segments,
            id_: new_id(),
        }
    }
}

impl<S, T> CudnnRNNParamsSizeOp<S, T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_HALF,
      S: con_or_DT_INT32_or_DT_INT64,
{
    pub fn new(inner: Rc<CudnnRNNParamsSize<S, T>>) -> Self {
        Self{inner}
    }

    pub fn params_size(&self) -> Edge<S> {
        Edge::<S>::new(self.inner.clone(), 0)
    }
}

struct CudnnRNNParamsSizeOp<S, T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_HALF,
      S: con_or_DT_INT32_or_DT_INT64,
{
    inner: Rc<CudnnRNNParamsSize<S, T>>,
}

impl<S, T> GraphOperation for CudnnRNNParamsSize<S, T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_HALF,
      S: con_or_DT_INT32_or_DT_INT64,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("CudnnRNNParamsSize_{}")?
        };
        let mut new_op = graph.new_operation("CudnnRNNParamsSize", &op_name)?;
        {
            match self.rnn_mode {
            }
            None => new_op.set_attr_value_proto("rnn_mode", &vec![18_u8, 4_u8, 108_u8, 115_u8, 116_u8, 109_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_string("rnn_mode", attr)})(&value),
        };
        {
            match self.input_mode {
            }
            None => new_op.set_attr_value_proto("input_mode", &vec![18_u8, 12_u8, 108_u8, 105_u8, 110_u8, 101_u8, 97_u8, 114_u8, 95_u8, 105_u8, 110_u8, 112_u8, 117_u8, 116_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_string("input_mode", attr)})(&value),
        };
        {
            match self.direction {
            }
            None => new_op.set_attr_value_proto("direction", &vec![18_u8, 14_u8, 117_u8, 110_u8, 105_u8, 100_u8, 105_u8, 114_u8, 101_u8, 99_u8, 116_u8, 105_u8, 111_u8, 110_u8, 97_u8, 108_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_string("direction", attr)})(&value),
        };
        {
            match self.dropout {
            }
            None => new_op.set_attr_value_proto("dropout", &vec![37_u8, 0_u8, 0_u8, 0_u8, 0_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_float("dropout", *attr)})(&value),
        };
        {
            match self.seed {
            }
            None => new_op.set_attr_value_proto("seed", &vec![24_u8, 0_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_int("seed", *attr)})(&value),
        };
        {
            match self.seed2 {
            }
            None => new_op.set_attr_value_proto("seed2", &vec![24_u8, 0_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_int("seed2", *attr)})(&value),
        };
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct CudnnRNNParamsSize<S, T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_HALF,
      S: con_or_DT_INT32_or_DT_INT64,
{
    num_layers: Edge<i32>,
    num_units: Edge<i32>,
    input_size: Edge<i32>,
    rnn_mode: Option<String>,
    input_mode: Option<String>,
    direction: Option<String>,
    dropout: Option<f32>,
    seed: Option<i64>,
    seed2: Option<i64>,
    id_: usize,
}

impl<S, T> CudnnRNNParamsSize<S, T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_HALF,
      S: con_or_DT_INT32_or_DT_INT64,
{
    pub fn rnn_mode(&mut self, rnn_mode: &str) -> &mut Self {
        self.rnn_mode = Some(rnn_mode.to_string());
        &self
    }

    pub fn input_mode(&mut self, input_mode: &str) -> &mut Self {
        self.input_mode = Some(input_mode.to_string());
        &self
    }

    pub fn direction(&mut self, direction: &str) -> &mut Self {
        self.direction = Some(direction.to_string());
        &self
    }

    pub fn dropout(&mut self, dropout: f32) -> &mut Self {
        self.dropout = Some(dropout);
        &self
    }

    pub fn seed(&mut self, seed: int) -> &mut Self {
        self.seed = Some(seed);
        &self
    }

    pub fn seed2(&mut self, seed2: int) -> &mut Self {
        self.seed2 = Some(seed2);
        &self
    }

    pub fn finish(self) -> CudnnRNNParamsSizeOp<S, T> {
        CudnnRNNParamsSizeOp::new(Rc::new(self))
    }

    pub fn new(num_layers: Edge<i32>, num_units: Edge<i32>, input_size: Edge<i32>) -> Self {
        Self {
            num_layers,
            num_units,
            input_size,
            rnn_mode: None,
            input_mode: None,
            direction: None,
            dropout: None,
            seed: None,
            seed2: None,
            id_: new_id(),
        }
    }
}

impl<T, Tidx> SparseSegmentMeanGradOp<T, Tidx>
where T: con_or_DT_FLOAT_or_DT_DOUBLE,
      Tidx: con_or_DT_INT32_or_DT_INT64,
{
    pub fn new(inner: Rc<SparseSegmentMeanGrad<T, Tidx>>) -> Self {
        Self{inner}
    }

    pub fn output(&self) -> Edge<T> {
        Edge::<T>::new(self.inner.clone(), 0)
    }
}

struct SparseSegmentMeanGradOp<T, Tidx>
where T: con_or_DT_FLOAT_or_DT_DOUBLE,
      Tidx: con_or_DT_INT32_or_DT_INT64,
{
    inner: Rc<SparseSegmentMeanGrad<T, Tidx>>,
}

impl<T, Tidx> GraphOperation for SparseSegmentMeanGrad<T, Tidx>
where T: con_or_DT_FLOAT_or_DT_DOUBLE,
      Tidx: con_or_DT_INT32_or_DT_INT64,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("SparseSegmentMeanGrad_{}")?
        };
        let mut new_op = graph.new_operation("SparseSegmentMeanGrad", &op_name)?;
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct SparseSegmentMeanGrad<T, Tidx>
where T: con_or_DT_FLOAT_or_DT_DOUBLE,
      Tidx: con_or_DT_INT32_or_DT_INT64,
{
    grad: Edge<T>,
    indices: Edge<Tidx>,
    segment_ids: Edge<i32>,
    output_dim0: Edge<i32>,
    id_: usize,
}

impl<T, Tidx> SparseSegmentMeanGrad<T, Tidx>
where T: con_or_DT_FLOAT_or_DT_DOUBLE,
      Tidx: con_or_DT_INT32_or_DT_INT64,
{
    pub fn finish(self) -> SparseSegmentMeanGradOp<T, Tidx> {
        SparseSegmentMeanGradOp::new(Rc::new(self))
    }

    pub fn new(grad: Edge<T>, indices: Edge<Tidx>, segment_ids: Edge<i32>, output_dim0: Edge<i32>) -> Self {
        Self {
            grad,
            indices,
            segment_ids,
            output_dim0,
            id_: new_id(),
        }
    }
}

impl<T, Tidx> SparseSegmentSqrtNOp<T, Tidx>
where T: con_or_DT_FLOAT_or_DT_DOUBLE,
      Tidx: con_or_DT_INT32_or_DT_INT64,
{
    pub fn new(inner: Rc<SparseSegmentSqrtN<T, Tidx>>) -> Self {
        Self{inner}
    }

    pub fn output(&self) -> Edge<T> {
        Edge::<T>::new(self.inner.clone(), 0)
    }
}

struct SparseSegmentSqrtNOp<T, Tidx>
where T: con_or_DT_FLOAT_or_DT_DOUBLE,
      Tidx: con_or_DT_INT32_or_DT_INT64,
{
    inner: Rc<SparseSegmentSqrtN<T, Tidx>>,
}

impl<T, Tidx> GraphOperation for SparseSegmentSqrtN<T, Tidx>
where T: con_or_DT_FLOAT_or_DT_DOUBLE,
      Tidx: con_or_DT_INT32_or_DT_INT64,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("SparseSegmentSqrtN_{}")?
        };
        let mut new_op = graph.new_operation("SparseSegmentSqrtN", &op_name)?;
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct SparseSegmentSqrtN<T, Tidx>
where T: con_or_DT_FLOAT_or_DT_DOUBLE,
      Tidx: con_or_DT_INT32_or_DT_INT64,
{
    data: Edge<T>,
    indices: Edge<Tidx>,
    segment_ids: Edge<i32>,
    id_: usize,
}

impl<T, Tidx> SparseSegmentSqrtN<T, Tidx>
where T: con_or_DT_FLOAT_or_DT_DOUBLE,
      Tidx: con_or_DT_INT32_or_DT_INT64,
{
    pub fn finish(self) -> SparseSegmentSqrtNOp<T, Tidx> {
        SparseSegmentSqrtNOp::new(Rc::new(self))
    }

    pub fn new(data: Edge<T>, indices: Edge<Tidx>, segment_ids: Edge<i32>) -> Self {
        Self {
            data,
            indices,
            segment_ids,
            id_: new_id(),
        }
    }
}

impl<T> IgammacOp<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE,
{
    pub fn new(inner: Rc<Igammac<T>>) -> Self {
        Self{inner}
    }

    pub fn z(&self) -> Edge<T> {
        Edge::<T>::new(self.inner.clone(), 0)
    }
}

struct IgammacOp<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE,
{
    inner: Rc<Igammac<T>>,
}

impl<T> GraphOperation for Igammac<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("Igammac_{}")?
        };
        let mut new_op = graph.new_operation("Igammac", &op_name)?;
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct Igammac<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE,
{
    a: Edge<T>,
    x: Edge<T>,
    id_: usize,
}

impl<T> Igammac<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE,
{
    pub fn finish(self) -> IgammacOp<T> {
        IgammacOp::new(Rc::new(self))
    }

    pub fn new(a: Edge<T>, x: Edge<T>) -> Self {
        Self {
            a,
            x,
            id_: new_id(),
        }
    }
}

impl<T, Tidx, Tnumsegments> SparseSegmentSqrtNWithNumSegmentsOp<T, Tidx, Tnumsegments>
where T: con_or_DT_FLOAT_or_DT_DOUBLE,
      Tidx: con_or_DT_INT32_or_DT_INT64,
      Tnumsegments: con_or_DT_INT32_or_DT_INT64,
{
    pub fn new(inner: Rc<SparseSegmentSqrtNWithNumSegments<T, Tidx, Tnumsegments>>) -> Self {
        Self{inner}
    }

    pub fn output(&self) -> Edge<T> {
        Edge::<T>::new(self.inner.clone(), 0)
    }
}

struct SparseSegmentSqrtNWithNumSegmentsOp<T, Tidx, Tnumsegments>
where T: con_or_DT_FLOAT_or_DT_DOUBLE,
      Tidx: con_or_DT_INT32_or_DT_INT64,
      Tnumsegments: con_or_DT_INT32_or_DT_INT64,
{
    inner: Rc<SparseSegmentSqrtNWithNumSegments<T, Tidx, Tnumsegments>>,
}

impl<T, Tidx, Tnumsegments> GraphOperation for SparseSegmentSqrtNWithNumSegments<T, Tidx, Tnumsegments>
where T: con_or_DT_FLOAT_or_DT_DOUBLE,
      Tidx: con_or_DT_INT32_or_DT_INT64,
      Tnumsegments: con_or_DT_INT32_or_DT_INT64,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("SparseSegmentSqrtNWithNumSegments_{}")?
        };
        let mut new_op = graph.new_operation("SparseSegmentSqrtNWithNumSegments", &op_name)?;
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct SparseSegmentSqrtNWithNumSegments<T, Tidx, Tnumsegments>
where T: con_or_DT_FLOAT_or_DT_DOUBLE,
      Tidx: con_or_DT_INT32_or_DT_INT64,
      Tnumsegments: con_or_DT_INT32_or_DT_INT64,
{
    data: Edge<T>,
    indices: Edge<Tidx>,
    segment_ids: Edge<i32>,
    num_segments: Edge<Tnumsegments>,
    id_: usize,
}

impl<T, Tidx, Tnumsegments> SparseSegmentSqrtNWithNumSegments<T, Tidx, Tnumsegments>
where T: con_or_DT_FLOAT_or_DT_DOUBLE,
      Tidx: con_or_DT_INT32_or_DT_INT64,
      Tnumsegments: con_or_DT_INT32_or_DT_INT64,
{
    pub fn finish(self) -> SparseSegmentSqrtNWithNumSegmentsOp<T, Tidx, Tnumsegments> {
        SparseSegmentSqrtNWithNumSegmentsOp::new(Rc::new(self))
    }

    pub fn new(data: Edge<T>, indices: Edge<Tidx>, segment_ids: Edge<i32>, num_segments: Edge<Tnumsegments>) -> Self {
        Self {
            data,
            indices,
            segment_ids,
            num_segments,
            id_: new_id(),
        }
    }
}

impl<T> LRNGradOp<T>
where T: con_or_DT_FLOAT_or_DT_BFLOAT16_or_DT_HALF,
{
    pub fn new(inner: Rc<LRNGrad<T>>) -> Self {
        Self{inner}
    }

    pub fn output(&self) -> Edge<T> {
        Edge::<T>::new(self.inner.clone(), 0)
    }
}

struct LRNGradOp<T>
where T: con_or_DT_FLOAT_or_DT_BFLOAT16_or_DT_HALF,
{
    inner: Rc<LRNGrad<T>>,
}

impl<T> GraphOperation for LRNGrad<T>
where T: con_or_DT_FLOAT_or_DT_BFLOAT16_or_DT_HALF,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("LRNGrad_{}")?
        };
        let mut new_op = graph.new_operation("LRNGrad", &op_name)?;
        {
            match self.depth_radius {
            }
            None => new_op.set_attr_value_proto("depth_radius", &vec![24_u8, 5_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_int("depth_radius", *attr)})(&value),
        };
        {
            match self.bias {
            }
            None => new_op.set_attr_value_proto("bias", &vec![37_u8, 0_u8, 0_u8, 128_u8, 63_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_float("bias", *attr)})(&value),
        };
        {
            match self.alpha {
            }
            None => new_op.set_attr_value_proto("alpha", &vec![37_u8, 0_u8, 0_u8, 128_u8, 63_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_float("alpha", *attr)})(&value),
        };
        {
            match self.beta {
            }
            None => new_op.set_attr_value_proto("beta", &vec![37_u8, 0_u8, 0_u8, 0_u8, 63_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_float("beta", *attr)})(&value),
        };
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct LRNGrad<T>
where T: con_or_DT_FLOAT_or_DT_BFLOAT16_or_DT_HALF,
{
    input_grads: Edge<T>,
    input_image: Edge<T>,
    output_image: Edge<T>,
    depth_radius: Option<i64>,
    bias: Option<f32>,
    alpha: Option<f32>,
    beta: Option<f32>,
    id_: usize,
}

impl<T> LRNGrad<T>
where T: con_or_DT_FLOAT_or_DT_BFLOAT16_or_DT_HALF,
{
    pub fn depth_radius(&mut self, depth_radius: int) -> &mut Self {
        self.depth_radius = Some(depth_radius);
        &self
    }

    pub fn bias(&mut self, bias: f32) -> &mut Self {
        self.bias = Some(bias);
        &self
    }

    pub fn alpha(&mut self, alpha: f32) -> &mut Self {
        self.alpha = Some(alpha);
        &self
    }

    pub fn beta(&mut self, beta: f32) -> &mut Self {
        self.beta = Some(beta);
        &self
    }

    pub fn finish(self) -> LRNGradOp<T> {
        LRNGradOp::new(Rc::new(self))
    }

    pub fn new(input_grads: Edge<T>, input_image: Edge<T>, output_image: Edge<T>) -> Self {
        Self {
            input_grads,
            input_image,
            output_image,
            depth_radius: None,
            bias: None,
            alpha: None,
            beta: None,
            id_: new_id(),
        }
    }
}

impl<Tidx> AnyOp<Tidx>
where Tidx: con_or_DT_INT32_or_DT_INT64,
{
    pub fn new(inner: Rc<Any<Tidx>>) -> Self {
        Self{inner}
    }

    pub fn output(&self) -> Edge<bool> {
        Edge::<bool>::new(self.inner.clone(), 0)
    }
}

struct AnyOp<Tidx>
where Tidx: con_or_DT_INT32_or_DT_INT64,
{
    inner: Rc<Any<Tidx>>,
}

impl<Tidx> GraphOperation for Any<Tidx>
where Tidx: con_or_DT_INT32_or_DT_INT64,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("Any_{}")?
        };
        let mut new_op = graph.new_operation("Any", &op_name)?;
        {
            match self.keep_dims {
            }
            None => new_op.set_attr_value_proto("keep_dims", &vec![40_u8, 0_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_bool("keep_dims", *attr)})(&value),
        };
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct Any<Tidx>
where Tidx: con_or_DT_INT32_or_DT_INT64,
{
    input: Edge<bool>,
    reduction_indices: Edge<Tidx>,
    keep_dims: Option<bool>,
    id_: usize,
}

impl<Tidx> Any<Tidx>
where Tidx: con_or_DT_INT32_or_DT_INT64,
{
    pub fn keep_dims(&mut self, keep_dims: bool) -> &mut Self {
        self.keep_dims = Some(keep_dims);
        &self
    }

    pub fn finish(self) -> AnyOp<Tidx> {
        AnyOp::new(Rc::new(self))
    }

    pub fn new(input: Edge<bool>, reduction_indices: Edge<Tidx>) -> Self {
        Self {
            input,
            reduction_indices,
            keep_dims: None,
            id_: new_id(),
        }
    }
}

impl<Tidx> RangeOp<Tidx>
where Tidx: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_INT64_or_DT_BFLOAT16,
{
    pub fn new(inner: Rc<Range<Tidx>>) -> Self {
        Self{inner}
    }

    pub fn output(&self) -> Edge<Tidx> {
        Edge::<Tidx>::new(self.inner.clone(), 0)
    }
}

struct RangeOp<Tidx>
where Tidx: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_INT64_or_DT_BFLOAT16,
{
    inner: Rc<Range<Tidx>>,
}

impl<Tidx> GraphOperation for Range<Tidx>
where Tidx: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_INT64_or_DT_BFLOAT16,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("Range_{}")?
        };
        let mut new_op = graph.new_operation("Range", &op_name)?;
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct Range<Tidx>
where Tidx: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_INT64_or_DT_BFLOAT16,
{
    start: Edge<Tidx>,
    limit: Edge<Tidx>,
    delta: Edge<Tidx>,
    id_: usize,
}

impl<Tidx> Range<Tidx>
where Tidx: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_INT64_or_DT_BFLOAT16,
{
    pub fn finish(self) -> RangeOp<Tidx> {
        RangeOp::new(Rc::new(self))
    }

    pub fn new(start: Edge<Tidx>, limit: Edge<Tidx>, delta: Edge<Tidx>) -> Self {
        Self {
            start,
            limit,
            delta,
            id_: new_id(),
        }
    }
}

pub trait con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16 for BFloat16 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16 for f32 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16 for f64 {
}

impl<T, Tidx> LinSpaceOp<T, Tidx>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16,
      Tidx: con_or_DT_INT32_or_DT_INT64,
{
    pub fn new(inner: Rc<LinSpace<T, Tidx>>) -> Self {
        Self{inner}
    }

    pub fn output(&self) -> Edge<T> {
        Edge::<T>::new(self.inner.clone(), 0)
    }
}

struct LinSpaceOp<T, Tidx>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16,
      Tidx: con_or_DT_INT32_or_DT_INT64,
{
    inner: Rc<LinSpace<T, Tidx>>,
}

impl<T, Tidx> GraphOperation for LinSpace<T, Tidx>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16,
      Tidx: con_or_DT_INT32_or_DT_INT64,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("LinSpace_{}")?
        };
        let mut new_op = graph.new_operation("LinSpace", &op_name)?;
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct LinSpace<T, Tidx>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16,
      Tidx: con_or_DT_INT32_or_DT_INT64,
{
    start: Edge<T>,
    stop: Edge<T>,
    num: Edge<Tidx>,
    id_: usize,
}

impl<T, Tidx> LinSpace<T, Tidx>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16,
      Tidx: con_or_DT_INT32_or_DT_INT64,
{
    pub fn finish(self) -> LinSpaceOp<T, Tidx> {
        LinSpaceOp::new(Rc::new(self))
    }

    pub fn new(start: Edge<T>, stop: Edge<T>, num: Edge<Tidx>) -> Self {
        Self {
            start,
            stop,
            num,
            id_: new_id(),
        }
    }
}

impl<T, Tout> AngleOp<T, Tout>
where T: con_or_DT_COMPLEX64_or_DT_COMPLEX128,
      Tout: con_or_DT_FLOAT_or_DT_DOUBLE,
{
    pub fn new(inner: Rc<Angle<T, Tout>>) -> Self {
        Self{inner}
    }

    pub fn output(&self) -> Edge<Tout> {
        Edge::<Tout>::new(self.inner.clone(), 0)
    }
}

struct AngleOp<T, Tout>
where T: con_or_DT_COMPLEX64_or_DT_COMPLEX128,
      Tout: con_or_DT_FLOAT_or_DT_DOUBLE,
{
    inner: Rc<Angle<T, Tout>>,
}

impl<T, Tout> GraphOperation for Angle<T, Tout>
where T: con_or_DT_COMPLEX64_or_DT_COMPLEX128,
      Tout: con_or_DT_FLOAT_or_DT_DOUBLE,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("Angle_{}")?
        };
        let mut new_op = graph.new_operation("Angle", &op_name)?;
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct Angle<T, Tout>
where T: con_or_DT_COMPLEX64_or_DT_COMPLEX128,
      Tout: con_or_DT_FLOAT_or_DT_DOUBLE,
{
    input: Edge<T>,
    id_: usize,
}

impl<T, Tout> Angle<T, Tout>
where T: con_or_DT_COMPLEX64_or_DT_COMPLEX128,
      Tout: con_or_DT_FLOAT_or_DT_DOUBLE,
{
    pub fn finish(self) -> AngleOp<T, Tout> {
        AngleOp::new(Rc::new(self))
    }

    pub fn new(input: Edge<T>) -> Self {
        Self {
            input,
            id_: new_id(),
        }
    }
}

impl<T> ClipByValueOp<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
{
    pub fn new(inner: Rc<ClipByValue<T>>) -> Self {
        Self{inner}
    }

    pub fn output(&self) -> Edge<T> {
        Edge::<T>::new(self.inner.clone(), 0)
    }
}

struct ClipByValueOp<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
{
    inner: Rc<ClipByValue<T>>,
}

impl<T> GraphOperation for ClipByValue<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("ClipByValue_{}")?
        };
        let mut new_op = graph.new_operation("ClipByValue", &op_name)?;
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct ClipByValue<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
{
    t: Edge<T>,
    clip_value_min: Edge<T>,
    clip_value_max: Edge<T>,
    id_: usize,
}

impl<T> ClipByValue<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
{
    pub fn finish(self) -> ClipByValueOp<T> {
        ClipByValueOp::new(Rc::new(self))
    }

    pub fn new(t: Edge<T>, clip_value_min: Edge<T>, clip_value_max: Edge<T>) -> Self {
        Self {
            t,
            clip_value_min,
            clip_value_max,
            id_: new_id(),
        }
    }
}

impl<T, dtype> HistogramFixedWidthOp<T, dtype>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_INT64,
      dtype: con_or_DT_INT32_or_DT_INT64,
{
    pub fn new(inner: Rc<HistogramFixedWidth<T, dtype>>) -> Self {
        Self{inner}
    }

    pub fn out(&self) -> Edge<dtype> {
        Edge::<dtype>::new(self.inner.clone(), 0)
    }
}

struct HistogramFixedWidthOp<T, dtype>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_INT64,
      dtype: con_or_DT_INT32_or_DT_INT64,
{
    inner: Rc<HistogramFixedWidth<T, dtype>>,
}

impl<T, dtype> GraphOperation for HistogramFixedWidth<T, dtype>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_INT64,
      dtype: con_or_DT_INT32_or_DT_INT64,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("HistogramFixedWidth_{}")?
        };
        let mut new_op = graph.new_operation("HistogramFixedWidth", &op_name)?;
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct HistogramFixedWidth<T, dtype>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_INT64,
      dtype: con_or_DT_INT32_or_DT_INT64,
{
    values: Edge<T>,
    value_range: Edge<T>,
    nbins: Edge<i32>,
    id_: usize,
}

impl<T, dtype> HistogramFixedWidth<T, dtype>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_INT64,
      dtype: con_or_DT_INT32_or_DT_INT64,
{
    pub fn finish(self) -> HistogramFixedWidthOp<T, dtype> {
        HistogramFixedWidthOp::new(Rc::new(self))
    }

    pub fn new(values: Edge<T>, value_range: Edge<T>, nbins: Edge<i32>) -> Self {
        Self {
            values,
            value_range,
            nbins,
            id_: new_id(),
        }
    }
}

impl<T> BincountOp<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_INT64,
{
    pub fn new(inner: Rc<Bincount<T>>) -> Self {
        Self{inner}
    }

    pub fn bins(&self) -> Edge<T> {
        Edge::<T>::new(self.inner.clone(), 0)
    }
}

struct BincountOp<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_INT64,
{
    inner: Rc<Bincount<T>>,
}

impl<T> GraphOperation for Bincount<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_INT64,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("Bincount_{}")?
        };
        let mut new_op = graph.new_operation("Bincount", &op_name)?;
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct Bincount<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_INT64,
{
    arr: Edge<i32>,
    size: Edge<i32>,
    weights: Edge<T>,
    id_: usize,
}

impl<T> Bincount<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_INT64,
{
    pub fn finish(self) -> BincountOp<T> {
        BincountOp::new(Rc::new(self))
    }

    pub fn new(arr: Edge<i32>, size: Edge<i32>, weights: Edge<T>) -> Self {
        Self {
            arr,
            size,
            weights,
            id_: new_id(),
        }
    }
}

impl<T1, T2, Toutput> QuantizedMulOp<T1, T2, Toutput>
where T1: con_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_QINT16_or_DT_QUINT16,
      T2: con_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_QINT16_or_DT_QUINT16,
      Toutput: con_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_QINT16_or_DT_QUINT16,
{
    pub fn new(inner: Rc<QuantizedMul<T1, T2, Toutput>>) -> Self {
        Self{inner}
    }

    pub fn z(&self) -> Edge<Toutput> {
        Edge::<Toutput>::new(self.inner.clone(), 0)
    }

    pub fn min_z(&self) -> Edge<f32> {
        Edge::<f32>::new(self.inner.clone(), 1)
    }

    pub fn max_z(&self) -> Edge<f32> {
        Edge::<f32>::new(self.inner.clone(), 2)
    }
}

struct QuantizedMulOp<T1, T2, Toutput>
where T1: con_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_QINT16_or_DT_QUINT16,
      T2: con_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_QINT16_or_DT_QUINT16,
      Toutput: con_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_QINT16_or_DT_QUINT16,
{
    inner: Rc<QuantizedMul<T1, T2, Toutput>>,
}

impl<T1, T2, Toutput> GraphOperation for QuantizedMul<T1, T2, Toutput>
where T1: con_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_QINT16_or_DT_QUINT16,
      T2: con_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_QINT16_or_DT_QUINT16,
      Toutput: con_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_QINT16_or_DT_QUINT16,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("QuantizedMul_{}")?
        };
        let mut new_op = graph.new_operation("QuantizedMul", &op_name)?;
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct QuantizedMul<T1, T2, Toutput>
where T1: con_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_QINT16_or_DT_QUINT16,
      T2: con_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_QINT16_or_DT_QUINT16,
      Toutput: con_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_QINT16_or_DT_QUINT16,
{
    x: Edge<T1>,
    y: Edge<T2>,
    min_x: Edge<f32>,
    max_x: Edge<f32>,
    min_y: Edge<f32>,
    max_y: Edge<f32>,
    id_: usize,
}

impl<T1, T2, Toutput> QuantizedMul<T1, T2, Toutput>
where T1: con_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_QINT16_or_DT_QUINT16,
      T2: con_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_QINT16_or_DT_QUINT16,
      Toutput: con_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_QINT16_or_DT_QUINT16,
{
    pub fn finish(self) -> QuantizedMulOp<T1, T2, Toutput> {
        QuantizedMulOp::new(Rc::new(self))
    }

    pub fn new(x: Edge<T1>, y: Edge<T2>, min_x: Edge<f32>, max_x: Edge<f32>, min_y: Edge<f32>, max_y: Edge<f32>) -> Self {
        Self {
            x,
            y,
            min_x,
            max_x,
            min_y,
            max_y,
            id_: new_id(),
        }
    }
}

impl<Tinput> RequantizationRangeOp<Tinput>
where Tinput: con_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_QINT16_or_DT_QUINT16,
{
    pub fn new(inner: Rc<RequantizationRange<Tinput>>) -> Self {
        Self{inner}
    }

    pub fn output_min(&self) -> Edge<f32> {
        Edge::<f32>::new(self.inner.clone(), 0)
    }

    pub fn output_max(&self) -> Edge<f32> {
        Edge::<f32>::new(self.inner.clone(), 1)
    }
}

struct RequantizationRangeOp<Tinput>
where Tinput: con_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_QINT16_or_DT_QUINT16,
{
    inner: Rc<RequantizationRange<Tinput>>,
}

impl<Tinput> GraphOperation for RequantizationRange<Tinput>
where Tinput: con_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_QINT16_or_DT_QUINT16,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("RequantizationRange_{}")?
        };
        let mut new_op = graph.new_operation("RequantizationRange", &op_name)?;
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct RequantizationRange<Tinput>
where Tinput: con_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_QINT16_or_DT_QUINT16,
{
    input: Edge<Tinput>,
    input_min: Edge<f32>,
    input_max: Edge<f32>,
    id_: usize,
}

impl<Tinput> RequantizationRange<Tinput>
where Tinput: con_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_QINT16_or_DT_QUINT16,
{
    pub fn finish(self) -> RequantizationRangeOp<Tinput> {
        RequantizationRangeOp::new(Rc::new(self))
    }

    pub fn new(input: Edge<Tinput>, input_min: Edge<f32>, input_max: Edge<f32>) -> Self {
        Self {
            input,
            input_min,
            input_max,
            id_: new_id(),
        }
    }
}

impl RegexReplaceOp {
    pub fn new(inner: Rc<RegexReplace>) -> Self {
        Self{inner}
    }

    pub fn output(&self) -> Edge<String> {
        Edge::<String>::new(self.inner.clone(), 0)
    }
}

struct RegexReplaceOp {
    inner: Rc<RegexReplace>,
}

impl GraphOperation for RegexReplace {
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("RegexReplace_{}")?
        };
        let mut new_op = graph.new_operation("RegexReplace", &op_name)?;
        {
            match self.replace_global {
            }
            None => new_op.set_attr_value_proto("replace_global", &vec![40_u8, 1_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_bool("replace_global", *attr)})(&value),
        };
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct RegexReplace {
    input: Edge<String>,
    pattern: Edge<String>,
    rewrite: Edge<String>,
    replace_global: Option<bool>,
    id_: usize,
}

impl RegexReplace {
    pub fn replace_global(&mut self, replace_global: bool) -> &mut Self {
        self.replace_global = Some(replace_global);
        &self
    }

    pub fn finish(self) -> RegexReplaceOp {
        RegexReplaceOp::new(Rc::new(self))
    }

    pub fn new(input: Edge<String>, pattern: Edge<String>, rewrite: Edge<String>) -> Self {
        Self {
            input,
            pattern,
            rewrite,
            replace_global: None,
            id_: new_id(),
        }
    }
}

impl<T> NcclAllReduceOp<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_INT64_or_DT_HALF,
{
    pub fn new(inner: Rc<NcclAllReduce<T>>) -> Self {
        Self{inner}
    }

    pub fn data(&self) -> Edge<T> {
        Edge::<T>::new(self.inner.clone(), 0)
    }
}

struct NcclAllReduceOp<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_INT64_or_DT_HALF,
{
    inner: Rc<NcclAllReduce<T>>,
}

impl<T> GraphOperation for NcclAllReduce<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_INT64_or_DT_HALF,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("NcclAllReduce_{}")?
        };
        let mut new_op = graph.new_operation("NcclAllReduce", &op_name)?;
        {
            (|attr| {new_op.set_attr_string("reduction", attr)})(&self.reduction)
        }
        {
            (|attr| {new_op.set_attr_int("num_devices", *attr)})(&self.num_devices)
        }
        {
            (|attr| {new_op.set_attr_string("shared_name", attr)})(&self.shared_name)
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct NcclAllReduce<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_INT64_or_DT_HALF,
{
    input: Edge<T>,
    reduction: String,
    num_devices: i64,
    shared_name: String,
    id_: usize,
}

impl<T> NcclAllReduce<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_INT64_or_DT_HALF,
{
    pub fn finish(self) -> NcclAllReduceOp<T> {
        NcclAllReduceOp::new(Rc::new(self))
    }

    pub fn new(input: Edge<T>, reduction: &str, num_devices: int, shared_name: &str) -> Self {
        Self {
            input,
            reduction: reduction.to_string()
            num_devices: num_devices
            shared_name: shared_name.to_string()
            id_: new_id(),
        }
    }
}

impl QueueSizeOp {
    pub fn new(inner: Rc<QueueSize>) -> Self {
        Self{inner}
    }

    pub fn size(&self) -> Edge<i32> {
        Edge::<i32>::new(self.inner.clone(), 0)
    }
}

struct QueueSizeOp {
    inner: Rc<QueueSize>,
}

impl GraphOperation for QueueSize {
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("QueueSize_{}")?
        };
        let mut new_op = graph.new_operation("QueueSize", &op_name)?;
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct QueueSize {
    handle: Edge<String>,
    id_: usize,
}

impl QueueSize {
    pub fn finish(self) -> QueueSizeOp {
        QueueSizeOp::new(Rc::new(self))
    }

    pub fn new(handle: Edge<String>) -> Self {
        Self {
            handle,
            id_: new_id(),
        }
    }
}

impl<T> BiasAddGradOp<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
{
    pub fn new(inner: Rc<BiasAddGrad<T>>) -> Self {
        Self{inner}
    }

    pub fn output(&self) -> Edge<T> {
        Edge::<T>::new(self.inner.clone(), 0)
    }
}

struct BiasAddGradOp<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
{
    inner: Rc<BiasAddGrad<T>>,
}

impl<T> GraphOperation for BiasAddGrad<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("BiasAddGrad_{}")?
        };
        let mut new_op = graph.new_operation("BiasAddGrad", &op_name)?;
        {
            match self.data_format {
            }
            None => new_op.set_attr_value_proto("data_format", &vec![18_u8, 4_u8, 78_u8, 72_u8, 87_u8, 67_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_string("data_format", attr)})(&value),
        };
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct BiasAddGrad<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
{
    out_backprop: Edge<T>,
    data_format: Option<String>,
    id_: usize,
}

impl<T> BiasAddGrad<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
{
    pub fn data_format(&mut self, data_format: &str) -> &mut Self {
        self.data_format = Some(data_format.to_string());
        &self
    }

    pub fn finish(self) -> BiasAddGradOp<T> {
        BiasAddGradOp::new(Rc::new(self))
    }

    pub fn new(out_backprop: Edge<T>) -> Self {
        Self {
            out_backprop,
            data_format: None,
            id_: new_id(),
        }
    }
}

impl<T> NcclReduceOp<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_INT64_or_DT_HALF,
{
    pub fn new(inner: Rc<NcclReduce<T>>) -> Self {
        Self{inner}
    }

    pub fn data(&self) -> Edge<T> {
        Edge::<T>::new(self.inner.clone(), 0)
    }
}

struct NcclReduceOp<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_INT64_or_DT_HALF,
{
    inner: Rc<NcclReduce<T>>,
}

impl<T> GraphOperation for NcclReduce<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_INT64_or_DT_HALF,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("NcclReduce_{}")?
        };
        let mut new_op = graph.new_operation("NcclReduce", &op_name)?;
        {
            (|attr| {new_op.set_attr_string("reduction", attr)})(&self.reduction)
        }
        {
            (|attr| {new_op.set_attr_int("num_devices", *attr)})(&self.num_devices)
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct NcclReduce<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_INT64_or_DT_HALF,
{
    input: Edge<T>,
    reduction: String,
    num_devices: i64,
    id_: usize,
}

impl<T> NcclReduce<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_INT64_or_DT_HALF,
{
    pub fn finish(self) -> NcclReduceOp<T> {
        NcclReduceOp::new(Rc::new(self))
    }

    pub fn new(input: Edge<T>, reduction: &str, num_devices: int) -> Self {
        Self {
            input,
            reduction: reduction.to_string()
            num_devices: num_devices
            id_: new_id(),
        }
    }
}

impl<T> _NcclReduceSendOp<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_INT64_or_DT_HALF,
{
    pub fn new(inner: Rc<_NcclReduceSend<T>>) -> Self {
        Self{inner}
    }
}

struct _NcclReduceSendOp<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_INT64_or_DT_HALF,
{
    inner: Rc<_NcclReduceSend<T>>,
}

impl<T> GraphOperation for _NcclReduceSend<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_INT64_or_DT_HALF,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("_NcclReduceSend_{}")?
        };
        let mut new_op = graph.new_operation("_NcclReduceSend", &op_name)?;
        {
            (|attr| {new_op.set_attr_string("reduction", attr)})(&self.reduction)
        }
        {
            (|attr| {new_op.set_attr_int("num_devices", *attr)})(&self.num_devices)
        }
        {
            (|attr| {new_op.set_attr_string("shared_name", attr)})(&self.shared_name)
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct _NcclReduceSend<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_INT64_or_DT_HALF,
{
    input: Edge<T>,
    reduction: String,
    num_devices: i64,
    shared_name: String,
    id_: usize,
}

impl<T> _NcclReduceSend<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_INT64_or_DT_HALF,
{
    pub fn finish(self) -> _NcclReduceSendOp<T> {
        _NcclReduceSendOp::new(Rc::new(self))
    }

    pub fn new(input: Edge<T>, reduction: &str, num_devices: int, shared_name: &str) -> Self {
        Self {
            input,
            reduction: reduction.to_string()
            num_devices: num_devices
            shared_name: shared_name.to_string()
            id_: new_id(),
        }
    }
}

impl SdcaShrinkL1Op {
    pub fn new(inner: Rc<SdcaShrinkL1>) -> Self {
        Self{inner}
    }
}

struct SdcaShrinkL1Op {
    inner: Rc<SdcaShrinkL1>,
}

impl GraphOperation for SdcaShrinkL1 {
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("SdcaShrinkL1_{}")?
        };
        let mut new_op = graph.new_operation("SdcaShrinkL1", &op_name)?;
        {
            (|attr| {new_op.set_attr_int("num_features", *attr)})(&self.num_features)
        }
        {
            (|attr| {new_op.set_attr_float("l1", *attr)})(&self.l1)
        }
        {
            (|attr| {new_op.set_attr_float("l2", *attr)})(&self.l2)
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct SdcaShrinkL1 {
    weights: Edge<f32>,
    num_features: i64,
    l1: f32,
    l2: f32,
    id_: usize,
}

impl SdcaShrinkL1 {
    pub fn finish(self) -> SdcaShrinkL1Op {
        SdcaShrinkL1Op::new(Rc::new(self))
    }

    pub fn new(weights: Edge<f32>, num_features: int, l1: f32, l2: f32) -> Self {
        Self {
            weights,
            num_features: num_features
            l1: l1
            l2: l2
            id_: new_id(),
        }
    }
}

impl<T> BitwiseAndOp<T>
where T: con_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_UINT16_or_DT_UINT32_or_DT_UINT64,
{
    pub fn new(inner: Rc<BitwiseAnd<T>>) -> Self {
        Self{inner}
    }

    pub fn z(&self) -> Edge<T> {
        Edge::<T>::new(self.inner.clone(), 0)
    }
}

struct BitwiseAndOp<T>
where T: con_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_UINT16_or_DT_UINT32_or_DT_UINT64,
{
    inner: Rc<BitwiseAnd<T>>,
}

impl<T> GraphOperation for BitwiseAnd<T>
where T: con_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_UINT16_or_DT_UINT32_or_DT_UINT64,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("BitwiseAnd_{}")?
        };
        let mut new_op = graph.new_operation("BitwiseAnd", &op_name)?;
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct BitwiseAnd<T>
where T: con_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_UINT16_or_DT_UINT32_or_DT_UINT64,
{
    x: Edge<T>,
    y: Edge<T>,
    id_: usize,
}

impl<T> BitwiseAnd<T>
where T: con_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_UINT16_or_DT_UINT32_or_DT_UINT64,
{
    pub fn finish(self) -> BitwiseAndOp<T> {
        BitwiseAndOp::new(Rc::new(self))
    }

    pub fn new(x: Edge<T>, y: Edge<T>) -> Self {
        Self {
            x,
            y,
            id_: new_id(),
        }
    }
}

impl<T> _NcclReduceRecvOp<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_INT64_or_DT_HALF,
{
    pub fn new(inner: Rc<_NcclReduceRecv<T>>) -> Self {
        Self{inner}
    }

    pub fn data(&self) -> Edge<T> {
        Edge::<T>::new(self.inner.clone(), 0)
    }
}

struct _NcclReduceRecvOp<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_INT64_or_DT_HALF,
{
    inner: Rc<_NcclReduceRecv<T>>,
}

impl<T> GraphOperation for _NcclReduceRecv<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_INT64_or_DT_HALF,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("_NcclReduceRecv_{}")?
        };
        let mut new_op = graph.new_operation("_NcclReduceRecv", &op_name)?;
        {
            (|attr| {new_op.set_attr_string("reduction", attr)})(&self.reduction)
        }
        {
            (|attr| {new_op.set_attr_int("num_devices", *attr)})(&self.num_devices)
        }
        {
            (|attr| {new_op.set_attr_string("shared_name", attr)})(&self.shared_name)
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct _NcclReduceRecv<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_INT64_or_DT_HALF,
{
    input: Edge<T>,
    reduction: String,
    num_devices: i64,
    shared_name: String,
    id_: usize,
}

impl<T> _NcclReduceRecv<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_INT64_or_DT_HALF,
{
    pub fn finish(self) -> _NcclReduceRecvOp<T> {
        _NcclReduceRecvOp::new(Rc::new(self))
    }

    pub fn new(input: Edge<T>, reduction: &str, num_devices: int, shared_name: &str) -> Self {
        Self {
            input,
            reduction: reduction.to_string()
            num_devices: num_devices
            shared_name: shared_name.to_string()
            id_: new_id(),
        }
    }
}

impl<T> _NcclBroadcastSendOp<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_INT64_or_DT_HALF,
{
    pub fn new(inner: Rc<_NcclBroadcastSend<T>>) -> Self {
        Self{inner}
    }
}

struct _NcclBroadcastSendOp<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_INT64_or_DT_HALF,
{
    inner: Rc<_NcclBroadcastSend<T>>,
}

impl<T> GraphOperation for _NcclBroadcastSend<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_INT64_or_DT_HALF,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("_NcclBroadcastSend_{}")?
        };
        let mut new_op = graph.new_operation("_NcclBroadcastSend", &op_name)?;
        {
            (|attr| {new_op.set_attr_int("num_devices", *attr)})(&self.num_devices)
        }
        {
            (|attr| {new_op.set_attr_string("shared_name", attr)})(&self.shared_name)
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct _NcclBroadcastSend<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_INT64_or_DT_HALF,
{
    input: Edge<T>,
    num_devices: i64,
    shared_name: String,
    id_: usize,
}

impl<T> _NcclBroadcastSend<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_INT64_or_DT_HALF,
{
    pub fn finish(self) -> _NcclBroadcastSendOp<T> {
        _NcclBroadcastSendOp::new(Rc::new(self))
    }

    pub fn new(input: Edge<T>, num_devices: int, shared_name: &str) -> Self {
        Self {
            input,
            num_devices: num_devices
            shared_name: shared_name.to_string()
            id_: new_id(),
        }
    }
}

impl<T> _NcclBroadcastRecvOp<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_INT64_or_DT_HALF,
{
    pub fn new(inner: Rc<_NcclBroadcastRecv<T>>) -> Self {
        Self{inner}
    }

    pub fn output(&self) -> Edge<T> {
        Edge::<T>::new(self.inner.clone(), 0)
    }
}

struct _NcclBroadcastRecvOp<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_INT64_or_DT_HALF,
{
    inner: Rc<_NcclBroadcastRecv<T>>,
}

impl<T> GraphOperation for _NcclBroadcastRecv<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_INT64_or_DT_HALF,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("_NcclBroadcastRecv_{}")?
        };
        let mut new_op = graph.new_operation("_NcclBroadcastRecv", &op_name)?;
        {
            (|attr| {new_op.set_attr_int("num_devices", *attr)})(&self.num_devices)
        }
        {
            (|attr| {new_op.set_attr_string("shared_name", attr)})(&self.shared_name)
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct _NcclBroadcastRecv<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_INT64_or_DT_HALF,
{
    shape: Edge<i32>,
    num_devices: i64,
    shared_name: String,
    id_: usize,
}

impl<T> _NcclBroadcastRecv<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_INT64_or_DT_HALF,
{
    pub fn finish(self) -> _NcclBroadcastRecvOp<T> {
        _NcclBroadcastRecvOp::new(Rc::new(self))
    }

    pub fn new(shape: Edge<i32>, num_devices: int, shared_name: &str) -> Self {
        Self {
            shape,
            num_devices: num_devices
            shared_name: shared_name.to_string()
            id_: new_id(),
        }
    }
}

impl ControlTriggerOp {
    pub fn new(inner: Rc<ControlTrigger>) -> Self {
        Self{inner}
    }
}

struct ControlTriggerOp {
    inner: Rc<ControlTrigger>,
}

impl GraphOperation for ControlTrigger {
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("ControlTrigger_{}")?
        };
        let mut new_op = graph.new_operation("ControlTrigger", &op_name)?;
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct ControlTrigger {
    id_: usize,
}

impl ControlTrigger {
    pub fn finish(self) -> ControlTriggerOp {
        ControlTriggerOp::new(Rc::new(self))
    }

    pub fn new() -> Self {
        Self {
            id_: new_id(),
        }
    }
}

impl<dtype> TensorArrayReadV2Op<dtype>
where dtype: con,
{
    pub fn new(inner: Rc<TensorArrayReadV2<dtype>>) -> Self {
        Self{inner}
    }

    pub fn value(&self) -> Edge<dtype> {
        Edge::<dtype>::new(self.inner.clone(), 0)
    }
}

struct TensorArrayReadV2Op<dtype>
where dtype: con,
{
    inner: Rc<TensorArrayReadV2<dtype>>,
}

impl<dtype> GraphOperation for TensorArrayReadV2<dtype>
where dtype: con,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("TensorArrayReadV2_{}")?
        };
        let mut new_op = graph.new_operation("TensorArrayReadV2", &op_name)?;
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct TensorArrayReadV2<dtype>
where dtype: con,
{
    handle: Edge<String>,
    index: Edge<i32>,
    flow_in: Edge<f32>,
    id_: usize,
}

impl<dtype> TensorArrayReadV2<dtype>
where dtype: con,
{
    pub fn finish(self) -> TensorArrayReadV2Op<dtype> {
        TensorArrayReadV2Op::new(Rc::new(self))
    }

    pub fn new(handle: Edge<String>, index: Edge<i32>, flow_in: Edge<f32>) -> Self {
        Self {
            handle,
            index,
            flow_in,
            id_: new_id(),
        }
    }
}

impl<T> BatchNormWithGlobalNormalizationOp<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
{
    pub fn new(inner: Rc<BatchNormWithGlobalNormalization<T>>) -> Self {
        Self{inner}
    }

    pub fn result(&self) -> Edge<T> {
        Edge::<T>::new(self.inner.clone(), 0)
    }
}

struct BatchNormWithGlobalNormalizationOp<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
{
    inner: Rc<BatchNormWithGlobalNormalization<T>>,
}

impl<T> GraphOperation for BatchNormWithGlobalNormalization<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("BatchNormWithGlobalNormalization_{}")?
        };
        let mut new_op = graph.new_operation("BatchNormWithGlobalNormalization", &op_name)?;
        {
            (|attr| {new_op.set_attr_float("variance_epsilon", *attr)})(&self.variance_epsilon)
        }
        {
            (|attr| {new_op.set_attr_bool("scale_after_normalization", *attr)})(&self.scale_after_normalization)
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct BatchNormWithGlobalNormalization<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
{
    t: Edge<T>,
    m: Edge<T>,
    v: Edge<T>,
    beta: Edge<T>,
    gamma: Edge<T>,
    variance_epsilon: f32,
    scale_after_normalization: bool,
    id_: usize,
}

impl<T> BatchNormWithGlobalNormalization<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
{
    pub fn finish(self) -> BatchNormWithGlobalNormalizationOp<T> {
        BatchNormWithGlobalNormalizationOp::new(Rc::new(self))
    }

    pub fn new(t: Edge<T>, m: Edge<T>, v: Edge<T>, beta: Edge<T>, gamma: Edge<T>, variance_epsilon: f32, scale_after_normalization: bool) -> Self {
        Self {
            t,
            m,
            v,
            beta,
            gamma,
            variance_epsilon: variance_epsilon
            scale_after_normalization: scale_after_normalization
            id_: new_id(),
        }
    }
}

impl<T> FusedBatchNormOp<T>
where T: con_or_DT_FLOAT,
{
    pub fn new(inner: Rc<FusedBatchNorm<T>>) -> Self {
        Self{inner}
    }

    pub fn y(&self) -> Edge<T> {
        Edge::<T>::new(self.inner.clone(), 0)
    }

    pub fn batch_mean(&self) -> Edge<T> {
        Edge::<T>::new(self.inner.clone(), 1)
    }

    pub fn batch_variance(&self) -> Edge<T> {
        Edge::<T>::new(self.inner.clone(), 2)
    }

    pub fn reserve_space_1(&self) -> Edge<T> {
        Edge::<T>::new(self.inner.clone(), 3)
    }

    pub fn reserve_space_2(&self) -> Edge<T> {
        Edge::<T>::new(self.inner.clone(), 4)
    }
}

struct FusedBatchNormOp<T>
where T: con_or_DT_FLOAT,
{
    inner: Rc<FusedBatchNorm<T>>,
}

impl<T> GraphOperation for FusedBatchNorm<T>
where T: con_or_DT_FLOAT,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("FusedBatchNorm_{}")?
        };
        let mut new_op = graph.new_operation("FusedBatchNorm", &op_name)?;
        {
            match self.epsilon {
            }
            None => new_op.set_attr_value_proto("epsilon", &vec![37_u8, 23_u8, 183_u8, 209_u8, 56_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_float("epsilon", *attr)})(&value),
        };
        {
            match self.data_format {
            }
            None => new_op.set_attr_value_proto("data_format", &vec![18_u8, 4_u8, 78_u8, 72_u8, 87_u8, 67_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_string("data_format", attr)})(&value),
        };
        {
            match self.is_training {
            }
            None => new_op.set_attr_value_proto("is_training", &vec![40_u8, 1_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_bool("is_training", *attr)})(&value),
        };
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct FusedBatchNorm<T>
where T: con_or_DT_FLOAT,
{
    x: Edge<T>,
    scale: Edge<T>,
    offset: Edge<T>,
    mean: Edge<T>,
    variance: Edge<T>,
    epsilon: Option<f32>,
    data_format: Option<String>,
    is_training: Option<bool>,
    id_: usize,
}

impl<T> FusedBatchNorm<T>
where T: con_or_DT_FLOAT,
{
    pub fn epsilon(&mut self, epsilon: f32) -> &mut Self {
        self.epsilon = Some(epsilon);
        &self
    }

    pub fn data_format(&mut self, data_format: &str) -> &mut Self {
        self.data_format = Some(data_format.to_string());
        &self
    }

    pub fn is_training(&mut self, is_training: bool) -> &mut Self {
        self.is_training = Some(is_training);
        &self
    }

    pub fn finish(self) -> FusedBatchNormOp<T> {
        FusedBatchNormOp::new(Rc::new(self))
    }

    pub fn new(x: Edge<T>, scale: Edge<T>, offset: Edge<T>, mean: Edge<T>, variance: Edge<T>) -> Self {
        Self {
            x,
            scale,
            offset,
            mean,
            variance,
            epsilon: None,
            data_format: None,
            is_training: None,
            id_: new_id(),
        }
    }
}

impl<T> DebugIdentityOp<T>
where T: con,
{
    pub fn new(inner: Rc<DebugIdentity<T>>) -> Self {
        Self{inner}
    }

    pub fn output(&self) -> Edge<T> {
        Edge::<T>::new(self.inner.clone(), 0)
    }
}

struct DebugIdentityOp<T>
where T: con,
{
    inner: Rc<DebugIdentity<T>>,
}

impl<T> GraphOperation for DebugIdentity<T>
where T: con,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("DebugIdentity_{}")?
        };
        let mut new_op = graph.new_operation("DebugIdentity", &op_name)?;
        {
            match self.device_name {
            }
            None => new_op.set_attr_value_proto("device_name", &vec![18_u8, 0_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_string("device_name", attr)})(&value),
        };
        {
            match self.tensor_name {
            }
            None => new_op.set_attr_value_proto("tensor_name", &vec![18_u8, 0_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_string("tensor_name", attr)})(&value),
        };
        {
            match self.debug_urls {
            }
            None => new_op.set_attr_value_proto("debug_urls", &vec![10_u8, 0_u8,]);,
            Some(value) => (|attrs| {new_op.set_attr_string_list("debug_urls", attrs)})(&value),
        };
        {
            match self.gated_grpc {
            }
            None => new_op.set_attr_value_proto("gated_grpc", &vec![40_u8, 0_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_bool("gated_grpc", *attr)})(&value),
        };
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct DebugIdentity<T>
where T: con,
{
    input: Edge<T>,
    device_name: Option<String>,
    tensor_name: Option<String>,
    debug_urls: Option<Vec<String>>,
    gated_grpc: Option<bool>,
    id_: usize,
}

impl<T> DebugIdentity<T>
where T: con,
{
    pub fn device_name(&mut self, device_name: &str) -> &mut Self {
        self.device_name = Some(device_name.to_string());
        &self
    }

    pub fn tensor_name(&mut self, tensor_name: &str) -> &mut Self {
        self.tensor_name = Some(tensor_name.to_string());
        &self
    }

    pub fn debug_urls(&mut self, debug_urls: &[String]) -> &mut Self {
        self.debug_urls = Some(debug_urls.to_vec());
        &self
    }

    pub fn gated_grpc(&mut self, gated_grpc: bool) -> &mut Self {
        self.gated_grpc = Some(gated_grpc);
        &self
    }

    pub fn finish(self) -> DebugIdentityOp<T> {
        DebugIdentityOp::new(Rc::new(self))
    }

    pub fn new(input: Edge<T>) -> Self {
        Self {
            input,
            device_name: None,
            tensor_name: None,
            debug_urls: None,
            gated_grpc: None,
            id_: new_id(),
        }
    }
}

impl<T, U> FusedBatchNormV2Op<T, U>
where T: con_or_DT_FLOAT_or_DT_BFLOAT16_or_DT_HALF,
      U: con_or_DT_FLOAT,
{
    pub fn new(inner: Rc<FusedBatchNormV2<T, U>>) -> Self {
        Self{inner}
    }

    pub fn y(&self) -> Edge<T> {
        Edge::<T>::new(self.inner.clone(), 0)
    }

    pub fn batch_mean(&self) -> Edge<U> {
        Edge::<U>::new(self.inner.clone(), 1)
    }

    pub fn batch_variance(&self) -> Edge<U> {
        Edge::<U>::new(self.inner.clone(), 2)
    }

    pub fn reserve_space_1(&self) -> Edge<U> {
        Edge::<U>::new(self.inner.clone(), 3)
    }

    pub fn reserve_space_2(&self) -> Edge<U> {
        Edge::<U>::new(self.inner.clone(), 4)
    }
}

struct FusedBatchNormV2Op<T, U>
where T: con_or_DT_FLOAT_or_DT_BFLOAT16_or_DT_HALF,
      U: con_or_DT_FLOAT,
{
    inner: Rc<FusedBatchNormV2<T, U>>,
}

impl<T, U> GraphOperation for FusedBatchNormV2<T, U>
where T: con_or_DT_FLOAT_or_DT_BFLOAT16_or_DT_HALF,
      U: con_or_DT_FLOAT,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("FusedBatchNormV2_{}")?
        };
        let mut new_op = graph.new_operation("FusedBatchNormV2", &op_name)?;
        {
            match self.epsilon {
            }
            None => new_op.set_attr_value_proto("epsilon", &vec![37_u8, 23_u8, 183_u8, 209_u8, 56_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_float("epsilon", *attr)})(&value),
        };
        {
            match self.data_format {
            }
            None => new_op.set_attr_value_proto("data_format", &vec![18_u8, 4_u8, 78_u8, 72_u8, 87_u8, 67_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_string("data_format", attr)})(&value),
        };
        {
            match self.is_training {
            }
            None => new_op.set_attr_value_proto("is_training", &vec![40_u8, 1_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_bool("is_training", *attr)})(&value),
        };
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct FusedBatchNormV2<T, U>
where T: con_or_DT_FLOAT_or_DT_BFLOAT16_or_DT_HALF,
      U: con_or_DT_FLOAT,
{
    x: Edge<T>,
    scale: Edge<U>,
    offset: Edge<U>,
    mean: Edge<U>,
    variance: Edge<U>,
    epsilon: Option<f32>,
    data_format: Option<String>,
    is_training: Option<bool>,
    id_: usize,
}

impl<T, U> FusedBatchNormV2<T, U>
where T: con_or_DT_FLOAT_or_DT_BFLOAT16_or_DT_HALF,
      U: con_or_DT_FLOAT,
{
    pub fn epsilon(&mut self, epsilon: f32) -> &mut Self {
        self.epsilon = Some(epsilon);
        &self
    }

    pub fn data_format(&mut self, data_format: &str) -> &mut Self {
        self.data_format = Some(data_format.to_string());
        &self
    }

    pub fn is_training(&mut self, is_training: bool) -> &mut Self {
        self.is_training = Some(is_training);
        &self
    }

    pub fn finish(self) -> FusedBatchNormV2Op<T, U> {
        FusedBatchNormV2Op::new(Rc::new(self))
    }

    pub fn new(x: Edge<T>, scale: Edge<U>, offset: Edge<U>, mean: Edge<U>, variance: Edge<U>) -> Self {
        Self {
            x,
            scale,
            offset,
            mean,
            variance,
            epsilon: None,
            data_format: None,
            is_training: None,
            id_: new_id(),
        }
    }
}

impl<T> CosOp<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_COMPLEX64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF,
{
    pub fn new(inner: Rc<Cos<T>>) -> Self {
        Self{inner}
    }

    pub fn y(&self) -> Edge<T> {
        Edge::<T>::new(self.inner.clone(), 0)
    }
}

struct CosOp<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_COMPLEX64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF,
{
    inner: Rc<Cos<T>>,
}

impl<T> GraphOperation for Cos<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_COMPLEX64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("Cos_{}")?
        };
        let mut new_op = graph.new_operation("Cos", &op_name)?;
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct Cos<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_COMPLEX64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF,
{
    x: Edge<T>,
    id_: usize,
}

impl<T> Cos<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_COMPLEX64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF,
{
    pub fn finish(self) -> CosOp<T> {
        CosOp::new(Rc::new(self))
    }

    pub fn new(x: Edge<T>) -> Self {
        Self {
            x,
            id_: new_id(),
        }
    }
}

impl<T> FusedBatchNormGradOp<T>
where T: con_or_DT_FLOAT,
{
    pub fn new(inner: Rc<FusedBatchNormGrad<T>>) -> Self {
        Self{inner}
    }

    pub fn x_backprop(&self) -> Edge<T> {
        Edge::<T>::new(self.inner.clone(), 0)
    }

    pub fn scale_backprop(&self) -> Edge<T> {
        Edge::<T>::new(self.inner.clone(), 1)
    }

    pub fn offset_backprop(&self) -> Edge<T> {
        Edge::<T>::new(self.inner.clone(), 2)
    }

    pub fn reserve_space_3(&self) -> Edge<T> {
        Edge::<T>::new(self.inner.clone(), 3)
    }

    pub fn reserve_space_4(&self) -> Edge<T> {
        Edge::<T>::new(self.inner.clone(), 4)
    }
}

struct FusedBatchNormGradOp<T>
where T: con_or_DT_FLOAT,
{
    inner: Rc<FusedBatchNormGrad<T>>,
}

impl<T> GraphOperation for FusedBatchNormGrad<T>
where T: con_or_DT_FLOAT,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("FusedBatchNormGrad_{}")?
        };
        let mut new_op = graph.new_operation("FusedBatchNormGrad", &op_name)?;
        {
            match self.epsilon {
            }
            None => new_op.set_attr_value_proto("epsilon", &vec![37_u8, 23_u8, 183_u8, 209_u8, 56_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_float("epsilon", *attr)})(&value),
        };
        {
            match self.data_format {
            }
            None => new_op.set_attr_value_proto("data_format", &vec![18_u8, 4_u8, 78_u8, 72_u8, 87_u8, 67_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_string("data_format", attr)})(&value),
        };
        {
            match self.is_training {
            }
            None => new_op.set_attr_value_proto("is_training", &vec![40_u8, 1_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_bool("is_training", *attr)})(&value),
        };
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct FusedBatchNormGrad<T>
where T: con_or_DT_FLOAT,
{
    y_backprop: Edge<T>,
    x: Edge<T>,
    scale: Edge<T>,
    reserve_space_1: Edge<T>,
    reserve_space_2: Edge<T>,
    epsilon: Option<f32>,
    data_format: Option<String>,
    is_training: Option<bool>,
    id_: usize,
}

impl<T> FusedBatchNormGrad<T>
where T: con_or_DT_FLOAT,
{
    pub fn epsilon(&mut self, epsilon: f32) -> &mut Self {
        self.epsilon = Some(epsilon);
        &self
    }

    pub fn data_format(&mut self, data_format: &str) -> &mut Self {
        self.data_format = Some(data_format.to_string());
        &self
    }

    pub fn is_training(&mut self, is_training: bool) -> &mut Self {
        self.is_training = Some(is_training);
        &self
    }

    pub fn finish(self) -> FusedBatchNormGradOp<T> {
        FusedBatchNormGradOp::new(Rc::new(self))
    }

    pub fn new(y_backprop: Edge<T>, x: Edge<T>, scale: Edge<T>, reserve_space_1: Edge<T>, reserve_space_2: Edge<T>) -> Self {
        Self {
            y_backprop,
            x,
            scale,
            reserve_space_1,
            reserve_space_2,
            epsilon: None,
            data_format: None,
            is_training: None,
            id_: new_id(),
        }
    }
}

pub trait con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_STRING_or_DT_COMPLEX64_or_DT_INT64_or_DT_BOOL_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_STRING_or_DT_COMPLEX64_or_DT_INT64_or_DT_BOOL_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF for BFloat16 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_STRING_or_DT_COMPLEX64_or_DT_INT64_or_DT_BOOL_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF for OtherComplex<f32> {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_STRING_or_DT_COMPLEX64_or_DT_INT64_or_DT_BOOL_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF for OtherComplex<f64> {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_STRING_or_DT_COMPLEX64_or_DT_INT64_or_DT_BOOL_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF for String {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_STRING_or_DT_COMPLEX64_or_DT_INT64_or_DT_BOOL_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF for bool {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_STRING_or_DT_COMPLEX64_or_DT_INT64_or_DT_BOOL_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF for f32 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_STRING_or_DT_COMPLEX64_or_DT_INT64_or_DT_BOOL_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF for f64 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_STRING_or_DT_COMPLEX64_or_DT_INT64_or_DT_BOOL_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF for i16 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_STRING_or_DT_COMPLEX64_or_DT_INT64_or_DT_BOOL_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF for i32 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_STRING_or_DT_COMPLEX64_or_DT_INT64_or_DT_BOOL_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF for i64 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_STRING_or_DT_COMPLEX64_or_DT_INT64_or_DT_BOOL_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF for i8 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_STRING_or_DT_COMPLEX64_or_DT_INT64_or_DT_BOOL_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF for u16 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_STRING_or_DT_COMPLEX64_or_DT_INT64_or_DT_BOOL_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF for u8 {
}

impl<T, Tidx> ReverseV2Op<T, Tidx>
where Tidx: con_or_DT_INT32_or_DT_INT64,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_STRING_or_DT_COMPLEX64_or_DT_INT64_or_DT_BOOL_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF,
{
    pub fn new(inner: Rc<ReverseV2<T, Tidx>>) -> Self {
        Self{inner}
    }

    pub fn output(&self) -> Edge<T> {
        Edge::<T>::new(self.inner.clone(), 0)
    }
}

struct ReverseV2Op<T, Tidx>
where Tidx: con_or_DT_INT32_or_DT_INT64,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_STRING_or_DT_COMPLEX64_or_DT_INT64_or_DT_BOOL_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF,
{
    inner: Rc<ReverseV2<T, Tidx>>,
}

impl<T, Tidx> GraphOperation for ReverseV2<T, Tidx>
where Tidx: con_or_DT_INT32_or_DT_INT64,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_STRING_or_DT_COMPLEX64_or_DT_INT64_or_DT_BOOL_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("ReverseV2_{}")?
        };
        let mut new_op = graph.new_operation("ReverseV2", &op_name)?;
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct ReverseV2<T, Tidx>
where Tidx: con_or_DT_INT32_or_DT_INT64,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_STRING_or_DT_COMPLEX64_or_DT_INT64_or_DT_BOOL_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF,
{
    tensor: Edge<T>,
    axis: Edge<Tidx>,
    id_: usize,
}

impl<T, Tidx> ReverseV2<T, Tidx>
where Tidx: con_or_DT_INT32_or_DT_INT64,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_STRING_or_DT_COMPLEX64_or_DT_INT64_or_DT_BOOL_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF,
{
    pub fn finish(self) -> ReverseV2Op<T, Tidx> {
        ReverseV2Op::new(Rc::new(self))
    }

    pub fn new(tensor: Edge<T>, axis: Edge<Tidx>) -> Self {
        Self {
            tensor,
            axis,
            id_: new_id(),
        }
    }
}

impl<T> BiasAddV1Op<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
{
    pub fn new(inner: Rc<BiasAddV1<T>>) -> Self {
        Self{inner}
    }

    pub fn output(&self) -> Edge<T> {
        Edge::<T>::new(self.inner.clone(), 0)
    }
}

struct BiasAddV1Op<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
{
    inner: Rc<BiasAddV1<T>>,
}

impl<T> GraphOperation for BiasAddV1<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("BiasAddV1_{}")?
        };
        let mut new_op = graph.new_operation("BiasAddV1", &op_name)?;
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct BiasAddV1<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
{
    value: Edge<T>,
    bias: Edge<T>,
    id_: usize,
}

impl<T> BiasAddV1<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
{
    pub fn finish(self) -> BiasAddV1Op<T> {
        BiasAddV1Op::new(Rc::new(self))
    }

    pub fn new(value: Edge<T>, bias: Edge<T>) -> Self {
        Self {
            value,
            bias,
            id_: new_id(),
        }
    }
}

impl<T> FusedPadConv2DOp<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_HALF,
{
    pub fn new(inner: Rc<FusedPadConv2D<T>>) -> Self {
        Self{inner}
    }

    pub fn output(&self) -> Edge<T> {
        Edge::<T>::new(self.inner.clone(), 0)
    }
}

struct FusedPadConv2DOp<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_HALF,
{
    inner: Rc<FusedPadConv2D<T>>,
}

impl<T> GraphOperation for FusedPadConv2D<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_HALF,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("FusedPadConv2D_{}")?
        };
        let mut new_op = graph.new_operation("FusedPadConv2D", &op_name)?;
        {
            (|attr| {new_op.set_attr_string("mode", attr)})(&self.mode)
        }
        {
            (|attrs| {new_op.set_attr_int_list("strides", attrs)})(&self.strides)
        }
        {
            (|attr| {new_op.set_attr_string("padding", attr)})(&self.padding)
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct FusedPadConv2D<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_HALF,
{
    input: Edge<T>,
    paddings: Edge<i32>,
    filter: Edge<T>,
    mode: String,
    strides: Vec<i64>,
    padding: String,
    id_: usize,
}

impl<T> FusedPadConv2D<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_HALF,
{
    pub fn finish(self) -> FusedPadConv2DOp<T> {
        FusedPadConv2DOp::new(Rc::new(self))
    }

    pub fn new(input: Edge<T>, paddings: Edge<i32>, filter: Edge<T>, mode: &str, strides: &[int], padding: &str) -> Self {
        Self {
            input,
            paddings,
            filter,
            mode: mode.to_string()
            strides: strides.to_vec()
            padding: padding.to_string()
            id_: new_id(),
        }
    }
}

impl<T> DynamicStitchOp<T>
where T: con,
{
    pub fn new(inner: Rc<DynamicStitch<T>>) -> Self {
        Self{inner}
    }

    pub fn merged(&self) -> Edge<T> {
        Edge::<T>::new(self.inner.clone(), 0)
    }
}

struct DynamicStitchOp<T>
where T: con,
{
    inner: Rc<DynamicStitch<T>>,
}

impl<T> GraphOperation for DynamicStitch<T>
where T: con,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("DynamicStitch_{}")?
        };
        let mut new_op = graph.new_operation("DynamicStitch", &op_name)?;
        {
            (|attr| {new_op.set_attr_int("N", *attr)})(&self.N)
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct DynamicStitch<T>
where T: con,
{
    indices: Edge<i32>,
    data: Edge<T>,
    N: i64,
    id_: usize,
}

impl<T> DynamicStitch<T>
where T: con,
{
    pub fn finish(self) -> DynamicStitchOp<T> {
        DynamicStitchOp::new(Rc::new(self))
    }

    pub fn new(indices: Edge<i32>, data: Edge<T>, N: int) -> Self {
        Self {
            indices,
            data,
            N: N
            id_: new_id(),
        }
    }
}

impl<T> Conv2DBackpropInputOp<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
{
    pub fn new(inner: Rc<Conv2DBackpropInput<T>>) -> Self {
        Self{inner}
    }

    pub fn output(&self) -> Edge<T> {
        Edge::<T>::new(self.inner.clone(), 0)
    }
}

struct Conv2DBackpropInputOp<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
{
    inner: Rc<Conv2DBackpropInput<T>>,
}

impl<T> GraphOperation for Conv2DBackpropInput<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("Conv2DBackpropInput_{}")?
        };
        let mut new_op = graph.new_operation("Conv2DBackpropInput", &op_name)?;
        {
            (|attrs| {new_op.set_attr_int_list("strides", attrs)})(&self.strides)
        }
        {
            match self.use_cudnn_on_gpu {
            }
            None => new_op.set_attr_value_proto("use_cudnn_on_gpu", &vec![40_u8, 1_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_bool("use_cudnn_on_gpu", *attr)})(&value),
        };
        {
            (|attr| {new_op.set_attr_string("padding", attr)})(&self.padding)
        }
        {
            match self.data_format {
            }
            None => new_op.set_attr_value_proto("data_format", &vec![18_u8, 4_u8, 78_u8, 72_u8, 87_u8, 67_u8,]);,
            Some(value) => (|attr| {new_op.set_attr_string("data_format", attr)})(&value),
        };
        {
            match self.dilations {
            }
            None => new_op.set_attr_value_proto("dilations", &vec![10_u8, 0_u8, 26_u8, 4_u8,]);,
            Some(value) => (|attrs| {new_op.set_attr_int_list("dilations", attrs)})(&value),
        };
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

struct Conv2DBackpropInput<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
{
    input_sizes: Edge<i32>,
    filter: Edge<T>,
    out_backprop: Edge<T>,
    strides: Vec<i64>,
    use_cudnn_on_gpu: Option<bool>,
    padding: String,
    data_format: Option<String>,
    dilations: Option<Vec<i64>>,
    id_: usize,
}

impl<T> Conv2DBackpropInput<T>
where T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
{
    pub fn use_cudnn_on_gpu(&mut self, use_cudnn_on_gpu: bool) -> &mut Self {
        self.use_cudnn_on_gpu = Some(use_cudnn_on_gpu);
        &self
    }

    pub fn data_format(&mut self, data_format: &str) -> &mut Self {
        self.data_format = Some(data_format.to_string());
        &self
    }

    pub fn dilations(&mut self, dilations: &[int]) -> &mut Self {
        self.dilations = Some(dilations.to_vec());
        &self
    }

    pub fn finish(self) -> Conv2DBackpropInputOp<T> {
        Conv2DBackpropInputOp::new(Rc::new(self))
    }

    pub fn new(input_sizes: Edge<i32>, filter: Edge<T>, out_backprop: Edge<T>, strides: &[int], padding: &str) -> Self {
        Self {
            input_sizes,
            filter,
            out_backprop,
            strides: strides.to_vec()
            use_cudnn_on_gpu: None,
            padding: padding.to_string()
            data_format: None,
            dilations: None,
            id_: new_id(),
        }
    }
}