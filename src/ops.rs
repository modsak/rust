#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(dead_code)]
#![allow(non_camel_case_types)]
use super::graph::{Graph, GraphOperation, Operation, Edge};
use super::{Shape as OtherShape, new_id, TensorType, BFloat16, Tensor, AnyTensor, Result};
use num_complex::Complex as OtherComplex;
use std::rc::Rc;
use std::{f32, f64};
use std::marker::PhantomData;

impl GraphOperation for GenerateBigQueryReaderPartitions {
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("GenerateBigQueryReaderPartitions_{}")?
        };
        let mut new_op = graph.new_operation("GenerateBigQueryReaderPartitions", &op_name)?;
        {
            (|attr| {new_op.set_attr_string("project_id", attr)})(&self.project_id)?
        }
        {
            (|attr| {new_op.set_attr_string("dataset_id", attr)})(&self.dataset_id)?
        }
        {
            (|attr| {new_op.set_attr_string("table_id", attr)})(&self.table_id)?
        }
        {
            (|attrs| {new_op.set_attr_string_list("columns", attrs)})(&self.columns)?
        }
        {
            (|attr: &i64| {new_op.set_attr_int("timestamp_millis", *attr)})(&self.timestamp_millis)?
        }
        {
            (|attr: &i64| {new_op.set_attr_int("num_partitions", *attr)})(&self.num_partitions)?
        }
        {
            match self.test_end_point {
                None => new_op.set_attr_value_proto("test_end_point", &vec![18_u8, 0_u8,])?,
                Some(ref value) => (|attr| {new_op.set_attr_string("test_end_point", attr)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct GenerateBigQueryReaderPartitions {
    project_id: String,
    dataset_id: String,
    table_id: String,
    columns: Vec<String>,
    timestamp_millis: i64,
    num_partitions: i64,
    test_end_point: Option<String>,
    op_name: Option<String>,
    id_: usize,
}

impl GenerateBigQueryReaderPartitions {
    pub fn partitions(self) -> Edge<String> {
        let rc = Rc::new(self);
        {
            Edge::<String>::new(rc.clone(), 0)
        }
    }

    pub fn test_end_point(&mut self, test_end_point: &str) -> Self {
        self.test_end_point = Some(test_end_point.to_string());
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<String> {
        let rc = Rc::new(self);
        {
            Edge::<String>::new(rc.clone(), 0)
        }
    }

    pub fn build(project_id: &str, dataset_id: &str, table_id: &str, columns: &[String], timestamp_millis: i64, num_partitions: i64) -> Self {
        Self {
            project_id: project_id.to_string(),
            dataset_id: dataset_id.to_string(),
            table_id: table_id.to_string(),
            columns: columns.to_vec(),
            timestamp_millis: timestamp_millis,
            num_partitions: num_partitions,
            test_end_point: None,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(project_id: &str, dataset_id: &str, table_id: &str, columns: &[String], timestamp_millis: i64, num_partitions: i64) -> Edge<String> {
        Self {
            project_id: project_id.to_string(),
            dataset_id: dataset_id.to_string(),
            table_id: table_id.to_string(),
            columns: columns.to_vec(),
            timestamp_millis: timestamp_millis,
            num_partitions: num_partitions,
            test_end_point: None,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl GraphOperation for Skipgram {
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("Skipgram_{}")?
        };
        let mut new_op = graph.new_operation("Skipgram", &op_name)?;
        {
            (|attr| {new_op.set_attr_string("filename", attr)})(&self.filename)?
        }
        {
            (|attr: &i64| {new_op.set_attr_int("batch_size", *attr)})(&self.batch_size)?
        }
        {
            match self.window_size {
                None => new_op.set_attr_value_proto("window_size", &vec![24_u8, 5_u8,])?,
                Some(ref value) => (|attr: &i64| {new_op.set_attr_int("window_size", *attr)})(&value)?,
            };
        }
        {
            match self.min_count {
                None => new_op.set_attr_value_proto("min_count", &vec![24_u8, 5_u8,])?,
                Some(ref value) => (|attr: &i64| {new_op.set_attr_int("min_count", *attr)})(&value)?,
            };
        }
        {
            match self.subsample {
                None => new_op.set_attr_value_proto("subsample", &vec![37_u8, 111_u8, 18_u8, 131_u8, 58_u8,])?,
                Some(ref value) => (|attr: &f32| {new_op.set_attr_float("subsample", *attr)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct Skipgram {
    filename: String,
    batch_size: i64,
    window_size: Option<i64>,
    min_count: Option<i64>,
    subsample: Option<f32>,
    op_name: Option<String>,
    id_: usize,
}

impl Skipgram {
    pub fn vocab_word(self) -> Edge<String> {
        let rc = Rc::new(self);
        {
            Edge::<String>::new(rc.clone(), 0)
        }
    }

    pub fn vocab_freq(self) -> Edge<i32> {
        let rc = Rc::new(self);
        {
            Edge::<i32>::new(rc.clone(), 1)
        }
    }

    pub fn words_per_epoch(self) -> Edge<i64> {
        let rc = Rc::new(self);
        {
            Edge::<i64>::new(rc.clone(), 2)
        }
    }

    pub fn current_epoch(self) -> Edge<i32> {
        let rc = Rc::new(self);
        {
            Edge::<i32>::new(rc.clone(), 3)
        }
    }

    pub fn total_words_processed(self) -> Edge<i64> {
        let rc = Rc::new(self);
        {
            Edge::<i64>::new(rc.clone(), 4)
        }
    }

    pub fn examples(self) -> Edge<i32> {
        let rc = Rc::new(self);
        {
            Edge::<i32>::new(rc.clone(), 5)
        }
    }

    pub fn labels(self) -> Edge<i32> {
        let rc = Rc::new(self);
        {
            Edge::<i32>::new(rc.clone(), 6)
        }
    }

    pub fn window_size(&mut self, window_size: i64) -> Self {
        self.window_size = Some(window_size);
        self.clone()
    }

    pub fn min_count(&mut self, min_count: i64) -> Self {
        self.min_count = Some(min_count);
        self.clone()
    }

    pub fn subsample(&mut self, subsample: f32) -> Self {
        self.subsample = Some(subsample);
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> (Edge<String>, Edge<i32>, Edge<i64>, Edge<i32>, Edge<i64>, Edge<i32>, Edge<i32>) {
        let rc = Rc::new(self);
        (
        {
            Edge::<String>::new(rc.clone(), 0)
        },
        {
            Edge::<i32>::new(rc.clone(), 1)
        },
        {
            Edge::<i64>::new(rc.clone(), 2)
        },
        {
            Edge::<i32>::new(rc.clone(), 3)
        },
        {
            Edge::<i64>::new(rc.clone(), 4)
        },
        {
            Edge::<i32>::new(rc.clone(), 5)
        },
        {
            Edge::<i32>::new(rc.clone(), 6)
        },
        )
    }

    pub fn build(filename: &str, batch_size: i64) -> Self {
        Self {
            filename: filename.to_string(),
            batch_size: batch_size,
            window_size: None,
            min_count: None,
            subsample: None,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(filename: &str, batch_size: i64) -> (Edge<String>, Edge<i32>, Edge<i64>, Edge<i32>, Edge<i64>, Edge<i32>, Edge<i32>) {
        Self {
            filename: filename.to_string(),
            batch_size: batch_size,
            window_size: None,
            min_count: None,
            subsample: None,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

pub trait con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64 for BFloat16 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64 for OtherComplex<f32> {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64 for OtherComplex<f64> {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64 for f32 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64 for f64 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64 for i16 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64 for i32 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64 for i64 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64 for i8 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64 for u16 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64 for u32 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64 for u64 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64 for u8 {
}

impl<T> GraphOperation for ApplyPowerSign<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("ApplyPowerSign_{}")?
        };
        let mut new_op = graph.new_operation("ApplyPowerSign", &op_name)?;
        {
            new_op.add_edge(&self.var)?
        }
        {
            new_op.add_edge(&self.m)?
        }
        {
            new_op.add_edge(&self.lr)?
        }
        {
            new_op.add_edge(&self.logbase)?
        }
        {
            new_op.add_edge(&self.sign_decay)?
        }
        {
            new_op.add_edge(&self.beta)?
        }
        {
            new_op.add_edge(&self.grad)?
        }
        {
            match self.use_locking {
                None => new_op.set_attr_value_proto("use_locking", &vec![40_u8, 0_u8,])?,
                Some(ref value) => (|attr: &bool| {new_op.set_attr_bool("use_locking", *attr)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct ApplyPowerSign<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    var: Edge<T>,
    m: Edge<T>,
    lr: Edge<T>,
    logbase: Edge<T>,
    sign_decay: Edge<T>,
    beta: Edge<T>,
    grad: Edge<T>,
    use_locking: Option<bool>,
    op_name: Option<String>,
    id_: usize,
}

impl<T> ApplyPowerSign<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
{
    pub fn out(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn use_locking(&mut self, use_locking: bool) -> Self {
        self.use_locking = Some(use_locking);
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(var: Edge<T>, m: Edge<T>, lr: Edge<T>, logbase: Edge<T>, sign_decay: Edge<T>, beta: Edge<T>, grad: Edge<T>) -> Self {
        Self {
            phantom_T: PhantomData,
            var,
            m,
            lr,
            logbase,
            sign_decay,
            beta,
            grad,
            use_locking: None,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(var: Edge<T>, m: Edge<T>, lr: Edge<T>, logbase: Edge<T>, sign_decay: Edge<T>, beta: Edge<T>, grad: Edge<T>) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            var,
            m,
            lr,
            logbase,
            sign_decay,
            beta,
            grad,
            use_locking: None,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<T> GraphOperation for ApplyAddSign<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("ApplyAddSign_{}")?
        };
        let mut new_op = graph.new_operation("ApplyAddSign", &op_name)?;
        {
            new_op.add_edge(&self.var)?
        }
        {
            new_op.add_edge(&self.m)?
        }
        {
            new_op.add_edge(&self.lr)?
        }
        {
            new_op.add_edge(&self.alpha)?
        }
        {
            new_op.add_edge(&self.sign_decay)?
        }
        {
            new_op.add_edge(&self.beta)?
        }
        {
            new_op.add_edge(&self.grad)?
        }
        {
            match self.use_locking {
                None => new_op.set_attr_value_proto("use_locking", &vec![40_u8, 0_u8,])?,
                Some(ref value) => (|attr: &bool| {new_op.set_attr_bool("use_locking", *attr)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct ApplyAddSign<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    var: Edge<T>,
    m: Edge<T>,
    lr: Edge<T>,
    alpha: Edge<T>,
    sign_decay: Edge<T>,
    beta: Edge<T>,
    grad: Edge<T>,
    use_locking: Option<bool>,
    op_name: Option<String>,
    id_: usize,
}

impl<T> ApplyAddSign<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
{
    pub fn out(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn use_locking(&mut self, use_locking: bool) -> Self {
        self.use_locking = Some(use_locking);
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(var: Edge<T>, m: Edge<T>, lr: Edge<T>, alpha: Edge<T>, sign_decay: Edge<T>, beta: Edge<T>, grad: Edge<T>) -> Self {
        Self {
            phantom_T: PhantomData,
            var,
            m,
            lr,
            alpha,
            sign_decay,
            beta,
            grad,
            use_locking: None,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(var: Edge<T>, m: Edge<T>, lr: Edge<T>, alpha: Edge<T>, sign_decay: Edge<T>, beta: Edge<T>, grad: Edge<T>) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            var,
            m,
            lr,
            alpha,
            sign_decay,
            beta,
            grad,
            use_locking: None,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

pub trait con_or_DT_INT32_or_DT_INT64 {
}

impl con_or_DT_INT32_or_DT_INT64 for i32 {
}

impl con_or_DT_INT32_or_DT_INT64 for i64 {
}

impl<T, Tindices> GraphOperation for SparseApplyRMSProp<T, Tindices>
where T: TensorType,
      T: Clone,
      Tindices: TensorType,
      Tindices: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
      Tindices: con_or_DT_INT32_or_DT_INT64,
      Tindices: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("SparseApplyRMSProp_{}")?
        };
        let mut new_op = graph.new_operation("SparseApplyRMSProp", &op_name)?;
        {
            new_op.add_edge(&self.var)?
        }
        {
            new_op.add_edge(&self.ms)?
        }
        {
            new_op.add_edge(&self.mom)?
        }
        {
            new_op.add_edge(&self.lr)?
        }
        {
            new_op.add_edge(&self.rho)?
        }
        {
            new_op.add_edge(&self.momentum)?
        }
        {
            new_op.add_edge(&self.epsilon)?
        }
        {
            new_op.add_edge(&self.grad)?
        }
        {
            new_op.add_edge(&self.indices)?
        }
        {
            match self.use_locking {
                None => new_op.set_attr_value_proto("use_locking", &vec![40_u8, 0_u8,])?,
                Some(ref value) => (|attr: &bool| {new_op.set_attr_bool("use_locking", *attr)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct SparseApplyRMSProp<T, Tindices>
where T: TensorType,
      T: Clone,
      Tindices: TensorType,
      Tindices: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
      Tindices: con_or_DT_INT32_or_DT_INT64,
      Tindices: 'static,
{
    phantom_T: PhantomData<T>,
    var: Edge<T>,
    ms: Edge<T>,
    mom: Edge<T>,
    lr: Edge<T>,
    rho: Edge<T>,
    momentum: Edge<T>,
    epsilon: Edge<T>,
    grad: Edge<T>,
    phantom_Tindices: PhantomData<Tindices>,
    indices: Edge<Tindices>,
    use_locking: Option<bool>,
    op_name: Option<String>,
    id_: usize,
}

impl<T, Tindices> SparseApplyRMSProp<T, Tindices>
where T: TensorType,
      T: Clone,
      Tindices: TensorType,
      Tindices: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
      Tindices: con_or_DT_INT32_or_DT_INT64,
      Tindices: 'static,
{
    pub fn out(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn use_locking(&mut self, use_locking: bool) -> Self {
        self.use_locking = Some(use_locking);
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(var: Edge<T>, ms: Edge<T>, mom: Edge<T>, lr: Edge<T>, rho: Edge<T>, momentum: Edge<T>, epsilon: Edge<T>, grad: Edge<T>, indices: Edge<Tindices>) -> Self {
        Self {
            phantom_T: PhantomData,
            var,
            ms,
            mom,
            lr,
            rho,
            momentum,
            epsilon,
            grad,
            phantom_Tindices: PhantomData,
            indices,
            use_locking: None,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(var: Edge<T>, ms: Edge<T>, mom: Edge<T>, lr: Edge<T>, rho: Edge<T>, momentum: Edge<T>, epsilon: Edge<T>, grad: Edge<T>, indices: Edge<Tindices>) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            var,
            ms,
            mom,
            lr,
            rho,
            momentum,
            epsilon,
            grad,
            phantom_Tindices: PhantomData,
            indices,
            use_locking: None,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<T> GraphOperation for ApplyCenteredRMSProp<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("ApplyCenteredRMSProp_{}")?
        };
        let mut new_op = graph.new_operation("ApplyCenteredRMSProp", &op_name)?;
        {
            new_op.add_edge(&self.var)?
        }
        {
            new_op.add_edge(&self.mg)?
        }
        {
            new_op.add_edge(&self.ms)?
        }
        {
            new_op.add_edge(&self.mom)?
        }
        {
            new_op.add_edge(&self.lr)?
        }
        {
            new_op.add_edge(&self.rho)?
        }
        {
            new_op.add_edge(&self.momentum)?
        }
        {
            new_op.add_edge(&self.epsilon)?
        }
        {
            new_op.add_edge(&self.grad)?
        }
        {
            match self.use_locking {
                None => new_op.set_attr_value_proto("use_locking", &vec![40_u8, 0_u8,])?,
                Some(ref value) => (|attr: &bool| {new_op.set_attr_bool("use_locking", *attr)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct ApplyCenteredRMSProp<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    var: Edge<T>,
    mg: Edge<T>,
    ms: Edge<T>,
    mom: Edge<T>,
    lr: Edge<T>,
    rho: Edge<T>,
    momentum: Edge<T>,
    epsilon: Edge<T>,
    grad: Edge<T>,
    use_locking: Option<bool>,
    op_name: Option<String>,
    id_: usize,
}

impl<T> ApplyCenteredRMSProp<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
{
    pub fn out(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn use_locking(&mut self, use_locking: bool) -> Self {
        self.use_locking = Some(use_locking);
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(var: Edge<T>, mg: Edge<T>, ms: Edge<T>, mom: Edge<T>, lr: Edge<T>, rho: Edge<T>, momentum: Edge<T>, epsilon: Edge<T>, grad: Edge<T>) -> Self {
        Self {
            phantom_T: PhantomData,
            var,
            mg,
            ms,
            mom,
            lr,
            rho,
            momentum,
            epsilon,
            grad,
            use_locking: None,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(var: Edge<T>, mg: Edge<T>, ms: Edge<T>, mom: Edge<T>, lr: Edge<T>, rho: Edge<T>, momentum: Edge<T>, epsilon: Edge<T>, grad: Edge<T>) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            var,
            mg,
            ms,
            mom,
            lr,
            rho,
            momentum,
            epsilon,
            grad,
            use_locking: None,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<T, Tindices> GraphOperation for SparseApplyMomentum<T, Tindices>
where T: TensorType,
      T: Clone,
      Tindices: TensorType,
      Tindices: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
      Tindices: con_or_DT_INT32_or_DT_INT64,
      Tindices: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("SparseApplyMomentum_{}")?
        };
        let mut new_op = graph.new_operation("SparseApplyMomentum", &op_name)?;
        {
            new_op.add_edge(&self.var)?
        }
        {
            new_op.add_edge(&self.accum)?
        }
        {
            new_op.add_edge(&self.lr)?
        }
        {
            new_op.add_edge(&self.grad)?
        }
        {
            new_op.add_edge(&self.indices)?
        }
        {
            new_op.add_edge(&self.momentum)?
        }
        {
            match self.use_locking {
                None => new_op.set_attr_value_proto("use_locking", &vec![40_u8, 0_u8,])?,
                Some(ref value) => (|attr: &bool| {new_op.set_attr_bool("use_locking", *attr)})(&value)?,
            };
        }
        {
            match self.use_nesterov {
                None => new_op.set_attr_value_proto("use_nesterov", &vec![40_u8, 0_u8,])?,
                Some(ref value) => (|attr: &bool| {new_op.set_attr_bool("use_nesterov", *attr)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct SparseApplyMomentum<T, Tindices>
where T: TensorType,
      T: Clone,
      Tindices: TensorType,
      Tindices: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
      Tindices: con_or_DT_INT32_or_DT_INT64,
      Tindices: 'static,
{
    phantom_T: PhantomData<T>,
    var: Edge<T>,
    accum: Edge<T>,
    lr: Edge<T>,
    grad: Edge<T>,
    phantom_Tindices: PhantomData<Tindices>,
    indices: Edge<Tindices>,
    momentum: Edge<T>,
    use_locking: Option<bool>,
    use_nesterov: Option<bool>,
    op_name: Option<String>,
    id_: usize,
}

impl<T, Tindices> SparseApplyMomentum<T, Tindices>
where T: TensorType,
      T: Clone,
      Tindices: TensorType,
      Tindices: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
      Tindices: con_or_DT_INT32_or_DT_INT64,
      Tindices: 'static,
{
    pub fn out(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn use_locking(&mut self, use_locking: bool) -> Self {
        self.use_locking = Some(use_locking);
        self.clone()
    }

    pub fn use_nesterov(&mut self, use_nesterov: bool) -> Self {
        self.use_nesterov = Some(use_nesterov);
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(var: Edge<T>, accum: Edge<T>, lr: Edge<T>, grad: Edge<T>, indices: Edge<Tindices>, momentum: Edge<T>) -> Self {
        Self {
            phantom_T: PhantomData,
            var,
            accum,
            lr,
            grad,
            phantom_Tindices: PhantomData,
            indices,
            momentum,
            use_locking: None,
            use_nesterov: None,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(var: Edge<T>, accum: Edge<T>, lr: Edge<T>, grad: Edge<T>, indices: Edge<Tindices>, momentum: Edge<T>) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            var,
            accum,
            lr,
            grad,
            phantom_Tindices: PhantomData,
            indices,
            momentum,
            use_locking: None,
            use_nesterov: None,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<T, Tindices> GraphOperation for SparseApplyFtrlV2<T, Tindices>
where T: TensorType,
      T: Clone,
      Tindices: TensorType,
      Tindices: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
      Tindices: con_or_DT_INT32_or_DT_INT64,
      Tindices: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("SparseApplyFtrlV2_{}")?
        };
        let mut new_op = graph.new_operation("SparseApplyFtrlV2", &op_name)?;
        {
            new_op.add_edge(&self.var)?
        }
        {
            new_op.add_edge(&self.accum)?
        }
        {
            new_op.add_edge(&self.linear)?
        }
        {
            new_op.add_edge(&self.grad)?
        }
        {
            new_op.add_edge(&self.indices)?
        }
        {
            new_op.add_edge(&self.lr)?
        }
        {
            new_op.add_edge(&self.l1)?
        }
        {
            new_op.add_edge(&self.l2)?
        }
        {
            new_op.add_edge(&self.l2_shrinkage)?
        }
        {
            new_op.add_edge(&self.lr_power)?
        }
        {
            match self.use_locking {
                None => new_op.set_attr_value_proto("use_locking", &vec![40_u8, 0_u8,])?,
                Some(ref value) => (|attr: &bool| {new_op.set_attr_bool("use_locking", *attr)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct SparseApplyFtrlV2<T, Tindices>
where T: TensorType,
      T: Clone,
      Tindices: TensorType,
      Tindices: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
      Tindices: con_or_DT_INT32_or_DT_INT64,
      Tindices: 'static,
{
    phantom_T: PhantomData<T>,
    var: Edge<T>,
    accum: Edge<T>,
    linear: Edge<T>,
    grad: Edge<T>,
    phantom_Tindices: PhantomData<Tindices>,
    indices: Edge<Tindices>,
    lr: Edge<T>,
    l1: Edge<T>,
    l2: Edge<T>,
    l2_shrinkage: Edge<T>,
    lr_power: Edge<T>,
    use_locking: Option<bool>,
    op_name: Option<String>,
    id_: usize,
}

impl<T, Tindices> SparseApplyFtrlV2<T, Tindices>
where T: TensorType,
      T: Clone,
      Tindices: TensorType,
      Tindices: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
      Tindices: con_or_DT_INT32_or_DT_INT64,
      Tindices: 'static,
{
    pub fn out(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn use_locking(&mut self, use_locking: bool) -> Self {
        self.use_locking = Some(use_locking);
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(var: Edge<T>, accum: Edge<T>, linear: Edge<T>, grad: Edge<T>, indices: Edge<Tindices>, lr: Edge<T>, l1: Edge<T>, l2: Edge<T>, l2_shrinkage: Edge<T>, lr_power: Edge<T>) -> Self {
        Self {
            phantom_T: PhantomData,
            var,
            accum,
            linear,
            grad,
            phantom_Tindices: PhantomData,
            indices,
            lr,
            l1,
            l2,
            l2_shrinkage,
            lr_power,
            use_locking: None,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(var: Edge<T>, accum: Edge<T>, linear: Edge<T>, grad: Edge<T>, indices: Edge<Tindices>, lr: Edge<T>, l1: Edge<T>, l2: Edge<T>, l2_shrinkage: Edge<T>, lr_power: Edge<T>) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            var,
            accum,
            linear,
            grad,
            phantom_Tindices: PhantomData,
            indices,
            lr,
            l1,
            l2,
            l2_shrinkage,
            lr_power,
            use_locking: None,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<T> GraphOperation for ApplyFtrlV2<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("ApplyFtrlV2_{}")?
        };
        let mut new_op = graph.new_operation("ApplyFtrlV2", &op_name)?;
        {
            new_op.add_edge(&self.var)?
        }
        {
            new_op.add_edge(&self.accum)?
        }
        {
            new_op.add_edge(&self.linear)?
        }
        {
            new_op.add_edge(&self.grad)?
        }
        {
            new_op.add_edge(&self.lr)?
        }
        {
            new_op.add_edge(&self.l1)?
        }
        {
            new_op.add_edge(&self.l2)?
        }
        {
            new_op.add_edge(&self.l2_shrinkage)?
        }
        {
            new_op.add_edge(&self.lr_power)?
        }
        {
            match self.use_locking {
                None => new_op.set_attr_value_proto("use_locking", &vec![40_u8, 0_u8,])?,
                Some(ref value) => (|attr: &bool| {new_op.set_attr_bool("use_locking", *attr)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct ApplyFtrlV2<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    var: Edge<T>,
    accum: Edge<T>,
    linear: Edge<T>,
    grad: Edge<T>,
    lr: Edge<T>,
    l1: Edge<T>,
    l2: Edge<T>,
    l2_shrinkage: Edge<T>,
    lr_power: Edge<T>,
    use_locking: Option<bool>,
    op_name: Option<String>,
    id_: usize,
}

impl<T> ApplyFtrlV2<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
{
    pub fn out(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn use_locking(&mut self, use_locking: bool) -> Self {
        self.use_locking = Some(use_locking);
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(var: Edge<T>, accum: Edge<T>, linear: Edge<T>, grad: Edge<T>, lr: Edge<T>, l1: Edge<T>, l2: Edge<T>, l2_shrinkage: Edge<T>, lr_power: Edge<T>) -> Self {
        Self {
            phantom_T: PhantomData,
            var,
            accum,
            linear,
            grad,
            lr,
            l1,
            l2,
            l2_shrinkage,
            lr_power,
            use_locking: None,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(var: Edge<T>, accum: Edge<T>, linear: Edge<T>, grad: Edge<T>, lr: Edge<T>, l1: Edge<T>, l2: Edge<T>, l2_shrinkage: Edge<T>, lr_power: Edge<T>) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            var,
            accum,
            linear,
            grad,
            lr,
            l1,
            l2,
            l2_shrinkage,
            lr_power,
            use_locking: None,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<T, Tindices> GraphOperation for SparseApplyAdagrad<T, Tindices>
where T: TensorType,
      T: Clone,
      Tindices: TensorType,
      Tindices: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
      Tindices: con_or_DT_INT32_or_DT_INT64,
      Tindices: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("SparseApplyAdagrad_{}")?
        };
        let mut new_op = graph.new_operation("SparseApplyAdagrad", &op_name)?;
        {
            new_op.add_edge(&self.var)?
        }
        {
            new_op.add_edge(&self.accum)?
        }
        {
            new_op.add_edge(&self.lr)?
        }
        {
            new_op.add_edge(&self.grad)?
        }
        {
            new_op.add_edge(&self.indices)?
        }
        {
            match self.use_locking {
                None => new_op.set_attr_value_proto("use_locking", &vec![40_u8, 0_u8,])?,
                Some(ref value) => (|attr: &bool| {new_op.set_attr_bool("use_locking", *attr)})(&value)?,
            };
        }
        {
            match self.update_slots {
                None => new_op.set_attr_value_proto("update_slots", &vec![40_u8, 1_u8,])?,
                Some(ref value) => (|attr: &bool| {new_op.set_attr_bool("update_slots", *attr)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct SparseApplyAdagrad<T, Tindices>
where T: TensorType,
      T: Clone,
      Tindices: TensorType,
      Tindices: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
      Tindices: con_or_DT_INT32_or_DT_INT64,
      Tindices: 'static,
{
    phantom_T: PhantomData<T>,
    var: Edge<T>,
    accum: Edge<T>,
    lr: Edge<T>,
    grad: Edge<T>,
    phantom_Tindices: PhantomData<Tindices>,
    indices: Edge<Tindices>,
    use_locking: Option<bool>,
    update_slots: Option<bool>,
    op_name: Option<String>,
    id_: usize,
}

impl<T, Tindices> SparseApplyAdagrad<T, Tindices>
where T: TensorType,
      T: Clone,
      Tindices: TensorType,
      Tindices: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
      Tindices: con_or_DT_INT32_or_DT_INT64,
      Tindices: 'static,
{
    pub fn out(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn use_locking(&mut self, use_locking: bool) -> Self {
        self.use_locking = Some(use_locking);
        self.clone()
    }

    pub fn update_slots(&mut self, update_slots: bool) -> Self {
        self.update_slots = Some(update_slots);
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(var: Edge<T>, accum: Edge<T>, lr: Edge<T>, grad: Edge<T>, indices: Edge<Tindices>) -> Self {
        Self {
            phantom_T: PhantomData,
            var,
            accum,
            lr,
            grad,
            phantom_Tindices: PhantomData,
            indices,
            use_locking: None,
            update_slots: None,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(var: Edge<T>, accum: Edge<T>, lr: Edge<T>, grad: Edge<T>, indices: Edge<Tindices>) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            var,
            accum,
            lr,
            grad,
            phantom_Tindices: PhantomData,
            indices,
            use_locking: None,
            update_slots: None,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<T, Tindices> GraphOperation for SparseApplyAdadelta<T, Tindices>
where T: TensorType,
      T: Clone,
      Tindices: TensorType,
      Tindices: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
      Tindices: con_or_DT_INT32_or_DT_INT64,
      Tindices: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("SparseApplyAdadelta_{}")?
        };
        let mut new_op = graph.new_operation("SparseApplyAdadelta", &op_name)?;
        {
            new_op.add_edge(&self.var)?
        }
        {
            new_op.add_edge(&self.accum)?
        }
        {
            new_op.add_edge(&self.accum_update)?
        }
        {
            new_op.add_edge(&self.lr)?
        }
        {
            new_op.add_edge(&self.rho)?
        }
        {
            new_op.add_edge(&self.epsilon)?
        }
        {
            new_op.add_edge(&self.grad)?
        }
        {
            new_op.add_edge(&self.indices)?
        }
        {
            match self.use_locking {
                None => new_op.set_attr_value_proto("use_locking", &vec![40_u8, 0_u8,])?,
                Some(ref value) => (|attr: &bool| {new_op.set_attr_bool("use_locking", *attr)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct SparseApplyAdadelta<T, Tindices>
where T: TensorType,
      T: Clone,
      Tindices: TensorType,
      Tindices: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
      Tindices: con_or_DT_INT32_or_DT_INT64,
      Tindices: 'static,
{
    phantom_T: PhantomData<T>,
    var: Edge<T>,
    accum: Edge<T>,
    accum_update: Edge<T>,
    lr: Edge<T>,
    rho: Edge<T>,
    epsilon: Edge<T>,
    grad: Edge<T>,
    phantom_Tindices: PhantomData<Tindices>,
    indices: Edge<Tindices>,
    use_locking: Option<bool>,
    op_name: Option<String>,
    id_: usize,
}

impl<T, Tindices> SparseApplyAdadelta<T, Tindices>
where T: TensorType,
      T: Clone,
      Tindices: TensorType,
      Tindices: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
      Tindices: con_or_DT_INT32_or_DT_INT64,
      Tindices: 'static,
{
    pub fn out(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn use_locking(&mut self, use_locking: bool) -> Self {
        self.use_locking = Some(use_locking);
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(var: Edge<T>, accum: Edge<T>, accum_update: Edge<T>, lr: Edge<T>, rho: Edge<T>, epsilon: Edge<T>, grad: Edge<T>, indices: Edge<Tindices>) -> Self {
        Self {
            phantom_T: PhantomData,
            var,
            accum,
            accum_update,
            lr,
            rho,
            epsilon,
            grad,
            phantom_Tindices: PhantomData,
            indices,
            use_locking: None,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(var: Edge<T>, accum: Edge<T>, accum_update: Edge<T>, lr: Edge<T>, rho: Edge<T>, epsilon: Edge<T>, grad: Edge<T>, indices: Edge<Tindices>) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            var,
            accum,
            accum_update,
            lr,
            rho,
            epsilon,
            grad,
            phantom_Tindices: PhantomData,
            indices,
            use_locking: None,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<T> GraphOperation for ApplyAdadelta<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("ApplyAdadelta_{}")?
        };
        let mut new_op = graph.new_operation("ApplyAdadelta", &op_name)?;
        {
            new_op.add_edge(&self.var)?
        }
        {
            new_op.add_edge(&self.accum)?
        }
        {
            new_op.add_edge(&self.accum_update)?
        }
        {
            new_op.add_edge(&self.lr)?
        }
        {
            new_op.add_edge(&self.rho)?
        }
        {
            new_op.add_edge(&self.epsilon)?
        }
        {
            new_op.add_edge(&self.grad)?
        }
        {
            match self.use_locking {
                None => new_op.set_attr_value_proto("use_locking", &vec![40_u8, 0_u8,])?,
                Some(ref value) => (|attr: &bool| {new_op.set_attr_bool("use_locking", *attr)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct ApplyAdadelta<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    var: Edge<T>,
    accum: Edge<T>,
    accum_update: Edge<T>,
    lr: Edge<T>,
    rho: Edge<T>,
    epsilon: Edge<T>,
    grad: Edge<T>,
    use_locking: Option<bool>,
    op_name: Option<String>,
    id_: usize,
}

impl<T> ApplyAdadelta<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
{
    pub fn out(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn use_locking(&mut self, use_locking: bool) -> Self {
        self.use_locking = Some(use_locking);
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(var: Edge<T>, accum: Edge<T>, accum_update: Edge<T>, lr: Edge<T>, rho: Edge<T>, epsilon: Edge<T>, grad: Edge<T>) -> Self {
        Self {
            phantom_T: PhantomData,
            var,
            accum,
            accum_update,
            lr,
            rho,
            epsilon,
            grad,
            use_locking: None,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(var: Edge<T>, accum: Edge<T>, accum_update: Edge<T>, lr: Edge<T>, rho: Edge<T>, epsilon: Edge<T>, grad: Edge<T>) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            var,
            accum,
            accum_update,
            lr,
            rho,
            epsilon,
            grad,
            use_locking: None,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<T, Tindices> GraphOperation for SparseApplyFtrl<T, Tindices>
where T: TensorType,
      T: Clone,
      Tindices: TensorType,
      Tindices: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
      Tindices: con_or_DT_INT32_or_DT_INT64,
      Tindices: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("SparseApplyFtrl_{}")?
        };
        let mut new_op = graph.new_operation("SparseApplyFtrl", &op_name)?;
        {
            new_op.add_edge(&self.var)?
        }
        {
            new_op.add_edge(&self.accum)?
        }
        {
            new_op.add_edge(&self.linear)?
        }
        {
            new_op.add_edge(&self.grad)?
        }
        {
            new_op.add_edge(&self.indices)?
        }
        {
            new_op.add_edge(&self.lr)?
        }
        {
            new_op.add_edge(&self.l1)?
        }
        {
            new_op.add_edge(&self.l2)?
        }
        {
            new_op.add_edge(&self.lr_power)?
        }
        {
            match self.use_locking {
                None => new_op.set_attr_value_proto("use_locking", &vec![40_u8, 0_u8,])?,
                Some(ref value) => (|attr: &bool| {new_op.set_attr_bool("use_locking", *attr)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct SparseApplyFtrl<T, Tindices>
where T: TensorType,
      T: Clone,
      Tindices: TensorType,
      Tindices: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
      Tindices: con_or_DT_INT32_or_DT_INT64,
      Tindices: 'static,
{
    phantom_T: PhantomData<T>,
    var: Edge<T>,
    accum: Edge<T>,
    linear: Edge<T>,
    grad: Edge<T>,
    phantom_Tindices: PhantomData<Tindices>,
    indices: Edge<Tindices>,
    lr: Edge<T>,
    l1: Edge<T>,
    l2: Edge<T>,
    lr_power: Edge<T>,
    use_locking: Option<bool>,
    op_name: Option<String>,
    id_: usize,
}

impl<T, Tindices> SparseApplyFtrl<T, Tindices>
where T: TensorType,
      T: Clone,
      Tindices: TensorType,
      Tindices: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
      Tindices: con_or_DT_INT32_or_DT_INT64,
      Tindices: 'static,
{
    pub fn out(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn use_locking(&mut self, use_locking: bool) -> Self {
        self.use_locking = Some(use_locking);
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(var: Edge<T>, accum: Edge<T>, linear: Edge<T>, grad: Edge<T>, indices: Edge<Tindices>, lr: Edge<T>, l1: Edge<T>, l2: Edge<T>, lr_power: Edge<T>) -> Self {
        Self {
            phantom_T: PhantomData,
            var,
            accum,
            linear,
            grad,
            phantom_Tindices: PhantomData,
            indices,
            lr,
            l1,
            l2,
            lr_power,
            use_locking: None,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(var: Edge<T>, accum: Edge<T>, linear: Edge<T>, grad: Edge<T>, indices: Edge<Tindices>, lr: Edge<T>, l1: Edge<T>, l2: Edge<T>, lr_power: Edge<T>) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            var,
            accum,
            linear,
            grad,
            phantom_Tindices: PhantomData,
            indices,
            lr,
            l1,
            l2,
            lr_power,
            use_locking: None,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl GraphOperation for UnicodeDecodeWithOffsets {
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("UnicodeDecodeWithOffsets_{}")?
        };
        let mut new_op = graph.new_operation("UnicodeDecodeWithOffsets", &op_name)?;
        {
            new_op.add_edge(&self.input)?
        }
        {
            (|attr| {new_op.set_attr_string("input_encoding", attr)})(&self.input_encoding)?
        }
        {
            match self.errors {
                None => new_op.set_attr_value_proto("errors", &vec![18_u8, 7_u8, 114_u8, 101_u8, 112_u8, 108_u8, 97_u8, 99_u8, 101_u8,])?,
                Some(ref value) => (|attr| {new_op.set_attr_string("errors", attr)})(&value)?,
            };
        }
        {
            match self.replacement_char {
                None => new_op.set_attr_value_proto("replacement_char", &vec![24_u8, 253_u8, 255_u8, 3_u8,])?,
                Some(ref value) => (|attr: &i64| {new_op.set_attr_int("replacement_char", *attr)})(&value)?,
            };
        }
        {
            match self.replace_control_characters {
                None => new_op.set_attr_value_proto("replace_control_characters", &vec![40_u8, 0_u8,])?,
                Some(ref value) => (|attr: &bool| {new_op.set_attr_bool("replace_control_characters", *attr)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct UnicodeDecodeWithOffsets {
    input: Edge<String>,
    input_encoding: String,
    errors: Option<String>,
    replacement_char: Option<i64>,
    replace_control_characters: Option<bool>,
    op_name: Option<String>,
    id_: usize,
}

impl UnicodeDecodeWithOffsets {
    pub fn row_splits(self) -> Edge<i64> {
        let rc = Rc::new(self);
        {
            Edge::<i64>::new(rc.clone(), 0)
        }
    }

    pub fn char_values(self) -> Edge<i32> {
        let rc = Rc::new(self);
        {
            Edge::<i32>::new(rc.clone(), 1)
        }
    }

    pub fn char_to_byte_starts(self) -> Edge<i64> {
        let rc = Rc::new(self);
        {
            Edge::<i64>::new(rc.clone(), 2)
        }
    }

    pub fn errors(&mut self, errors: &str) -> Self {
        self.errors = Some(errors.to_string());
        self.clone()
    }

    pub fn replacement_char(&mut self, replacement_char: i64) -> Self {
        self.replacement_char = Some(replacement_char);
        self.clone()
    }

    pub fn replace_control_characters(&mut self, replace_control_characters: bool) -> Self {
        self.replace_control_characters = Some(replace_control_characters);
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> (Edge<i64>, Edge<i32>, Edge<i64>) {
        let rc = Rc::new(self);
        (
        {
            Edge::<i64>::new(rc.clone(), 0)
        },
        {
            Edge::<i32>::new(rc.clone(), 1)
        },
        {
            Edge::<i64>::new(rc.clone(), 2)
        },
        )
    }

    pub fn build(input: Edge<String>, input_encoding: &str) -> Self {
        Self {
            input,
            input_encoding: input_encoding.to_string(),
            errors: None,
            replacement_char: None,
            replace_control_characters: None,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(input: Edge<String>, input_encoding: &str) -> (Edge<i64>, Edge<i32>, Edge<i64>) {
        Self {
            input,
            input_encoding: input_encoding.to_string(),
            errors: None,
            replacement_char: None,
            replace_control_characters: None,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl GraphOperation for UnicodeDecode {
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("UnicodeDecode_{}")?
        };
        let mut new_op = graph.new_operation("UnicodeDecode", &op_name)?;
        {
            new_op.add_edge(&self.input)?
        }
        {
            (|attr| {new_op.set_attr_string("input_encoding", attr)})(&self.input_encoding)?
        }
        {
            match self.errors {
                None => new_op.set_attr_value_proto("errors", &vec![18_u8, 7_u8, 114_u8, 101_u8, 112_u8, 108_u8, 97_u8, 99_u8, 101_u8,])?,
                Some(ref value) => (|attr| {new_op.set_attr_string("errors", attr)})(&value)?,
            };
        }
        {
            match self.replacement_char {
                None => new_op.set_attr_value_proto("replacement_char", &vec![24_u8, 253_u8, 255_u8, 3_u8,])?,
                Some(ref value) => (|attr: &i64| {new_op.set_attr_int("replacement_char", *attr)})(&value)?,
            };
        }
        {
            match self.replace_control_characters {
                None => new_op.set_attr_value_proto("replace_control_characters", &vec![40_u8, 0_u8,])?,
                Some(ref value) => (|attr: &bool| {new_op.set_attr_bool("replace_control_characters", *attr)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct UnicodeDecode {
    input: Edge<String>,
    input_encoding: String,
    errors: Option<String>,
    replacement_char: Option<i64>,
    replace_control_characters: Option<bool>,
    op_name: Option<String>,
    id_: usize,
}

impl UnicodeDecode {
    pub fn row_splits(self) -> Edge<i64> {
        let rc = Rc::new(self);
        {
            Edge::<i64>::new(rc.clone(), 0)
        }
    }

    pub fn char_values(self) -> Edge<i32> {
        let rc = Rc::new(self);
        {
            Edge::<i32>::new(rc.clone(), 1)
        }
    }

    pub fn errors(&mut self, errors: &str) -> Self {
        self.errors = Some(errors.to_string());
        self.clone()
    }

    pub fn replacement_char(&mut self, replacement_char: i64) -> Self {
        self.replacement_char = Some(replacement_char);
        self.clone()
    }

    pub fn replace_control_characters(&mut self, replace_control_characters: bool) -> Self {
        self.replace_control_characters = Some(replace_control_characters);
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> (Edge<i64>, Edge<i32>) {
        let rc = Rc::new(self);
        (
        {
            Edge::<i64>::new(rc.clone(), 0)
        },
        {
            Edge::<i32>::new(rc.clone(), 1)
        },
        )
    }

    pub fn build(input: Edge<String>, input_encoding: &str) -> Self {
        Self {
            input,
            input_encoding: input_encoding.to_string(),
            errors: None,
            replacement_char: None,
            replace_control_characters: None,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(input: Edge<String>, input_encoding: &str) -> (Edge<i64>, Edge<i32>) {
        Self {
            input,
            input_encoding: input_encoding.to_string(),
            errors: None,
            replacement_char: None,
            replace_control_characters: None,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl GraphOperation for UnicodeScript {
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("UnicodeScript_{}")?
        };
        let mut new_op = graph.new_operation("UnicodeScript", &op_name)?;
        {
            new_op.add_edge(&self.input)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct UnicodeScript {
    input: Edge<i32>,
    op_name: Option<String>,
    id_: usize,
}

impl UnicodeScript {
    pub fn output(self) -> Edge<i32> {
        let rc = Rc::new(self);
        {
            Edge::<i32>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<i32> {
        let rc = Rc::new(self);
        {
            Edge::<i32>::new(rc.clone(), 0)
        }
    }

    pub fn build(input: Edge<i32>) -> Self {
        Self {
            input,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(input: Edge<i32>) -> Edge<i32> {
        Self {
            input,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<T> GraphOperation for Substr<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_INT32_or_DT_INT64,
      T: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("Substr_{}")?
        };
        let mut new_op = graph.new_operation("Substr", &op_name)?;
        {
            new_op.add_edge(&self.input)?
        }
        {
            new_op.add_edge(&self.pos)?
        }
        {
            new_op.add_edge(&self.len)?
        }
        {
            match self.unit {
                None => new_op.set_attr_value_proto("unit", &vec![18_u8, 4_u8, 66_u8, 89_u8, 84_u8, 69_u8,])?,
                Some(ref value) => (|attr| {new_op.set_attr_string("unit", attr)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct Substr<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_INT32_or_DT_INT64,
      T: 'static,
{
    input: Edge<String>,
    phantom_T: PhantomData<T>,
    pos: Edge<T>,
    len: Edge<T>,
    unit: Option<String>,
    op_name: Option<String>,
    id_: usize,
}

impl<T> Substr<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_INT32_or_DT_INT64,
      T: 'static,
{
    pub fn output(self) -> Edge<String> {
        let rc = Rc::new(self);
        {
            Edge::<String>::new(rc.clone(), 0)
        }
    }

    pub fn unit(&mut self, unit: &str) -> Self {
        self.unit = Some(unit.to_string());
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<String> {
        let rc = Rc::new(self);
        {
            Edge::<String>::new(rc.clone(), 0)
        }
    }

    pub fn build(input: Edge<String>, pos: Edge<T>, len: Edge<T>) -> Self {
        Self {
            input,
            phantom_T: PhantomData,
            pos,
            len,
            unit: None,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(input: Edge<String>, pos: Edge<T>, len: Edge<T>) -> Edge<String> {
        Self {
            input,
            phantom_T: PhantomData,
            pos,
            len,
            unit: None,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl GraphOperation for StringStrip {
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("StringStrip_{}")?
        };
        let mut new_op = graph.new_operation("StringStrip", &op_name)?;
        {
            new_op.add_edge(&self.input)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct StringStrip {
    input: Edge<String>,
    op_name: Option<String>,
    id_: usize,
}

impl StringStrip {
    pub fn output(self) -> Edge<String> {
        let rc = Rc::new(self);
        {
            Edge::<String>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<String> {
        let rc = Rc::new(self);
        {
            Edge::<String>::new(rc.clone(), 0)
        }
    }

    pub fn build(input: Edge<String>) -> Self {
        Self {
            input,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(input: Edge<String>) -> Edge<String> {
        Self {
            input,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl GraphOperation for StringSplit {
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("StringSplit_{}")?
        };
        let mut new_op = graph.new_operation("StringSplit", &op_name)?;
        {
            new_op.add_edge(&self.input)?
        }
        {
            new_op.add_edge(&self.delimiter)?
        }
        {
            match self.skip_empty {
                None => new_op.set_attr_value_proto("skip_empty", &vec![40_u8, 1_u8,])?,
                Some(ref value) => (|attr: &bool| {new_op.set_attr_bool("skip_empty", *attr)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct StringSplit {
    input: Edge<String>,
    delimiter: Edge<String>,
    skip_empty: Option<bool>,
    op_name: Option<String>,
    id_: usize,
}

impl StringSplit {
    pub fn indices(self) -> Edge<i64> {
        let rc = Rc::new(self);
        {
            Edge::<i64>::new(rc.clone(), 0)
        }
    }

    pub fn values(self) -> Edge<String> {
        let rc = Rc::new(self);
        {
            Edge::<String>::new(rc.clone(), 1)
        }
    }

    pub fn shape(self) -> Edge<i64> {
        let rc = Rc::new(self);
        {
            Edge::<i64>::new(rc.clone(), 2)
        }
    }

    pub fn skip_empty(&mut self, skip_empty: bool) -> Self {
        self.skip_empty = Some(skip_empty);
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> (Edge<i64>, Edge<String>, Edge<i64>) {
        let rc = Rc::new(self);
        (
        {
            Edge::<i64>::new(rc.clone(), 0)
        },
        {
            Edge::<String>::new(rc.clone(), 1)
        },
        {
            Edge::<i64>::new(rc.clone(), 2)
        },
        )
    }

    pub fn build(input: Edge<String>, delimiter: Edge<String>) -> Self {
        Self {
            input,
            delimiter,
            skip_empty: None,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(input: Edge<String>, delimiter: Edge<String>) -> (Edge<i64>, Edge<String>, Edge<i64>) {
        Self {
            input,
            delimiter,
            skip_empty: None,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl GraphOperation for StringToHashBucket {
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("StringToHashBucket_{}")?
        };
        let mut new_op = graph.new_operation("StringToHashBucket", &op_name)?;
        {
            new_op.add_edge(&self.string_tensor)?
        }
        {
            (|attr: &i64| {new_op.set_attr_int("num_buckets", *attr)})(&self.num_buckets)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct StringToHashBucket {
    string_tensor: Edge<String>,
    num_buckets: i64,
    op_name: Option<String>,
    id_: usize,
}

impl StringToHashBucket {
    pub fn output(self) -> Edge<i64> {
        let rc = Rc::new(self);
        {
            Edge::<i64>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<i64> {
        let rc = Rc::new(self);
        {
            Edge::<i64>::new(rc.clone(), 0)
        }
    }

    pub fn build(string_tensor: Edge<String>, num_buckets: i64) -> Self {
        Self {
            string_tensor,
            num_buckets: num_buckets,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(string_tensor: Edge<String>, num_buckets: i64) -> Edge<i64> {
        Self {
            string_tensor,
            num_buckets: num_buckets,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl GraphOperation for StringLength {
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("StringLength_{}")?
        };
        let mut new_op = graph.new_operation("StringLength", &op_name)?;
        {
            new_op.add_edge(&self.input)?
        }
        {
            match self.unit {
                None => new_op.set_attr_value_proto("unit", &vec![18_u8, 4_u8, 66_u8, 89_u8, 84_u8, 69_u8,])?,
                Some(ref value) => (|attr| {new_op.set_attr_string("unit", attr)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct StringLength {
    input: Edge<String>,
    unit: Option<String>,
    op_name: Option<String>,
    id_: usize,
}

impl StringLength {
    pub fn output(self) -> Edge<i32> {
        let rc = Rc::new(self);
        {
            Edge::<i32>::new(rc.clone(), 0)
        }
    }

    pub fn unit(&mut self, unit: &str) -> Self {
        self.unit = Some(unit.to_string());
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<i32> {
        let rc = Rc::new(self);
        {
            Edge::<i32>::new(rc.clone(), 0)
        }
    }

    pub fn build(input: Edge<String>) -> Self {
        Self {
            input,
            unit: None,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(input: Edge<String>) -> Edge<i32> {
        Self {
            input,
            unit: None,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl GraphOperation for StringToHashBucketStrong {
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("StringToHashBucketStrong_{}")?
        };
        let mut new_op = graph.new_operation("StringToHashBucketStrong", &op_name)?;
        {
            new_op.add_edge(&self.input)?
        }
        {
            (|attr: &i64| {new_op.set_attr_int("num_buckets", *attr)})(&self.num_buckets)?
        }
        {
            (|attrs| {new_op.set_attr_int_list("key", attrs)})(&self.key)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct StringToHashBucketStrong {
    input: Edge<String>,
    num_buckets: i64,
    key: Vec<i64>,
    op_name: Option<String>,
    id_: usize,
}

impl StringToHashBucketStrong {
    pub fn output(self) -> Edge<i64> {
        let rc = Rc::new(self);
        {
            Edge::<i64>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<i64> {
        let rc = Rc::new(self);
        {
            Edge::<i64>::new(rc.clone(), 0)
        }
    }

    pub fn build(input: Edge<String>, num_buckets: i64, key: &[i64]) -> Self {
        Self {
            input,
            num_buckets: num_buckets,
            key: key.to_vec(),
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(input: Edge<String>, num_buckets: i64, key: &[i64]) -> Edge<i64> {
        Self {
            input,
            num_buckets: num_buckets,
            key: key.to_vec(),
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl GraphOperation for StringToHashBucketFast {
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("StringToHashBucketFast_{}")?
        };
        let mut new_op = graph.new_operation("StringToHashBucketFast", &op_name)?;
        {
            new_op.add_edge(&self.input)?
        }
        {
            (|attr: &i64| {new_op.set_attr_int("num_buckets", *attr)})(&self.num_buckets)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct StringToHashBucketFast {
    input: Edge<String>,
    num_buckets: i64,
    op_name: Option<String>,
    id_: usize,
}

impl StringToHashBucketFast {
    pub fn output(self) -> Edge<i64> {
        let rc = Rc::new(self);
        {
            Edge::<i64>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<i64> {
        let rc = Rc::new(self);
        {
            Edge::<i64>::new(rc.clone(), 0)
        }
    }

    pub fn build(input: Edge<String>, num_buckets: i64) -> Self {
        Self {
            input,
            num_buckets: num_buckets,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(input: Edge<String>, num_buckets: i64) -> Edge<i64> {
        Self {
            input,
            num_buckets: num_buckets,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl GraphOperation for StaticRegexFullMatch {
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("StaticRegexFullMatch_{}")?
        };
        let mut new_op = graph.new_operation("StaticRegexFullMatch", &op_name)?;
        {
            new_op.add_edge(&self.input)?
        }
        {
            (|attr| {new_op.set_attr_string("pattern", attr)})(&self.pattern)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct StaticRegexFullMatch {
    input: Edge<String>,
    pattern: String,
    op_name: Option<String>,
    id_: usize,
}

impl StaticRegexFullMatch {
    pub fn output(self) -> Edge<bool> {
        let rc = Rc::new(self);
        {
            Edge::<bool>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<bool> {
        let rc = Rc::new(self);
        {
            Edge::<bool>::new(rc.clone(), 0)
        }
    }

    pub fn build(input: Edge<String>, pattern: &str) -> Self {
        Self {
            input,
            pattern: pattern.to_string(),
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(input: Edge<String>, pattern: &str) -> Edge<bool> {
        Self {
            input,
            pattern: pattern.to_string(),
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl GraphOperation for RegexFullMatch {
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("RegexFullMatch_{}")?
        };
        let mut new_op = graph.new_operation("RegexFullMatch", &op_name)?;
        {
            new_op.add_edge(&self.input)?
        }
        {
            new_op.add_edge(&self.pattern)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct RegexFullMatch {
    input: Edge<String>,
    pattern: Edge<String>,
    op_name: Option<String>,
    id_: usize,
}

impl RegexFullMatch {
    pub fn output(self) -> Edge<bool> {
        let rc = Rc::new(self);
        {
            Edge::<bool>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<bool> {
        let rc = Rc::new(self);
        {
            Edge::<bool>::new(rc.clone(), 0)
        }
    }

    pub fn build(input: Edge<String>, pattern: Edge<String>) -> Self {
        Self {
            input,
            pattern,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(input: Edge<String>, pattern: Edge<String>) -> Edge<bool> {
        Self {
            input,
            pattern,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

pub trait con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64 for BFloat16 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64 for f32 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64 for f64 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64 for i16 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64 for i32 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64 for i64 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64 for i8 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64 for u16 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64 for u32 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64 for u64 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64 for u8 {
}

impl<T, Tseed, output_dtype> GraphOperation for StatelessMultinomial<T, Tseed, output_dtype>
where T: TensorType,
      T: Clone,
      Tseed: TensorType,
      Tseed: Clone,
      output_dtype: TensorType,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
      Tseed: con_or_DT_INT32_or_DT_INT64,
      Tseed: 'static,
      output_dtype: con_or_DT_INT32_or_DT_INT64,
      output_dtype: 'static,
      output_dtype: Clone,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("StatelessMultinomial_{}")?
        };
        let mut new_op = graph.new_operation("StatelessMultinomial", &op_name)?;
        {
            new_op.add_edge(&self.logits)?
        }
        {
            new_op.add_edge(&self.num_samples)?
        }
        {
            new_op.add_edge(&self.seed)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct StatelessMultinomial<T, Tseed, output_dtype>
where T: TensorType,
      T: Clone,
      Tseed: TensorType,
      Tseed: Clone,
      output_dtype: TensorType,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
      Tseed: con_or_DT_INT32_or_DT_INT64,
      Tseed: 'static,
      output_dtype: con_or_DT_INT32_or_DT_INT64,
      output_dtype: 'static,
      output_dtype: Clone,
{
    phantom_T: PhantomData<T>,
    logits: Edge<T>,
    num_samples: Edge<i32>,
    phantom_Tseed: PhantomData<Tseed>,
    seed: Edge<Tseed>,
    phantom_output_dtype: PhantomData<output_dtype>,
    op_name: Option<String>,
    id_: usize,
}

impl<T, Tseed, output_dtype> StatelessMultinomial<T, Tseed, output_dtype>
where T: TensorType,
      T: Clone,
      Tseed: TensorType,
      Tseed: Clone,
      output_dtype: TensorType,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
      Tseed: con_or_DT_INT32_or_DT_INT64,
      Tseed: 'static,
      output_dtype: con_or_DT_INT32_or_DT_INT64,
      output_dtype: 'static,
      output_dtype: Clone,
{
    pub fn output(self) -> Edge<output_dtype> {
        let rc = Rc::new(self);
        {
            Edge::<output_dtype>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<output_dtype> {
        let rc = Rc::new(self);
        {
            Edge::<output_dtype>::new(rc.clone(), 0)
        }
    }

    pub fn build(logits: Edge<T>, num_samples: Edge<i32>, seed: Edge<Tseed>) -> Self {
        Self {
            phantom_T: PhantomData,
            logits,
            num_samples,
            phantom_Tseed: PhantomData,
            seed,
            phantom_output_dtype: PhantomData,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(logits: Edge<T>, num_samples: Edge<i32>, seed: Edge<Tseed>) -> Edge<output_dtype> {
        Self {
            phantom_T: PhantomData,
            logits,
            num_samples,
            phantom_Tseed: PhantomData,
            seed,
            phantom_output_dtype: PhantomData,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<T, Tseed, dtype> GraphOperation for StatelessRandomUniformInt<T, Tseed, dtype>
where T: TensorType,
      T: Clone,
      Tseed: TensorType,
      Tseed: Clone,
      dtype: TensorType,
      dtype: Clone,
      dtype: con_or_DT_INT32_or_DT_INT64,
      dtype: 'static,
      T: con_or_DT_INT32_or_DT_INT64,
      T: 'static,
      Tseed: con_or_DT_INT32_or_DT_INT64,
      Tseed: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("StatelessRandomUniformInt_{}")?
        };
        let mut new_op = graph.new_operation("StatelessRandomUniformInt", &op_name)?;
        {
            new_op.add_edge(&self.shape)?
        }
        {
            new_op.add_edge(&self.seed)?
        }
        {
            new_op.add_edge(&self.minval)?
        }
        {
            new_op.add_edge(&self.maxval)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct StatelessRandomUniformInt<T, Tseed, dtype>
where T: TensorType,
      T: Clone,
      Tseed: TensorType,
      Tseed: Clone,
      dtype: TensorType,
      dtype: Clone,
      dtype: con_or_DT_INT32_or_DT_INT64,
      dtype: 'static,
      T: con_or_DT_INT32_or_DT_INT64,
      T: 'static,
      Tseed: con_or_DT_INT32_or_DT_INT64,
      Tseed: 'static,
{
    phantom_T: PhantomData<T>,
    shape: Edge<T>,
    phantom_Tseed: PhantomData<Tseed>,
    seed: Edge<Tseed>,
    phantom_dtype: PhantomData<dtype>,
    minval: Edge<dtype>,
    maxval: Edge<dtype>,
    op_name: Option<String>,
    id_: usize,
}

impl<T, Tseed, dtype> StatelessRandomUniformInt<T, Tseed, dtype>
where T: TensorType,
      T: Clone,
      Tseed: TensorType,
      Tseed: Clone,
      dtype: TensorType,
      dtype: Clone,
      dtype: con_or_DT_INT32_or_DT_INT64,
      dtype: 'static,
      T: con_or_DT_INT32_or_DT_INT64,
      T: 'static,
      Tseed: con_or_DT_INT32_or_DT_INT64,
      Tseed: 'static,
{
    pub fn output(self) -> Edge<dtype> {
        let rc = Rc::new(self);
        {
            Edge::<dtype>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<dtype> {
        let rc = Rc::new(self);
        {
            Edge::<dtype>::new(rc.clone(), 0)
        }
    }

    pub fn build(shape: Edge<T>, seed: Edge<Tseed>, minval: Edge<dtype>, maxval: Edge<dtype>) -> Self {
        Self {
            phantom_T: PhantomData,
            shape,
            phantom_Tseed: PhantomData,
            seed,
            phantom_dtype: PhantomData,
            minval,
            maxval,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(shape: Edge<T>, seed: Edge<Tseed>, minval: Edge<dtype>, maxval: Edge<dtype>) -> Edge<dtype> {
        Self {
            phantom_T: PhantomData,
            shape,
            phantom_Tseed: PhantomData,
            seed,
            phantom_dtype: PhantomData,
            minval,
            maxval,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

pub trait con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF for BFloat16 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF for f32 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF for f64 {
}

impl<T, Tseed, dtype> GraphOperation for StatelessTruncatedNormal<T, Tseed, dtype>
where T: TensorType,
      T: Clone,
      Tseed: TensorType,
      Tseed: Clone,
      dtype: TensorType,
      dtype: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
      dtype: 'static,
      dtype: Clone,
      T: con_or_DT_INT32_or_DT_INT64,
      T: 'static,
      Tseed: con_or_DT_INT32_or_DT_INT64,
      Tseed: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("StatelessTruncatedNormal_{}")?
        };
        let mut new_op = graph.new_operation("StatelessTruncatedNormal", &op_name)?;
        {
            new_op.add_edge(&self.shape)?
        }
        {
            new_op.add_edge(&self.seed)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct StatelessTruncatedNormal<T, Tseed, dtype>
where T: TensorType,
      T: Clone,
      Tseed: TensorType,
      Tseed: Clone,
      dtype: TensorType,
      dtype: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
      dtype: 'static,
      dtype: Clone,
      T: con_or_DT_INT32_or_DT_INT64,
      T: 'static,
      Tseed: con_or_DT_INT32_or_DT_INT64,
      Tseed: 'static,
{
    phantom_T: PhantomData<T>,
    shape: Edge<T>,
    phantom_Tseed: PhantomData<Tseed>,
    seed: Edge<Tseed>,
    phantom_dtype: PhantomData<dtype>,
    op_name: Option<String>,
    id_: usize,
}

impl<T, Tseed, dtype> StatelessTruncatedNormal<T, Tseed, dtype>
where T: TensorType,
      T: Clone,
      Tseed: TensorType,
      Tseed: Clone,
      dtype: TensorType,
      dtype: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
      dtype: 'static,
      dtype: Clone,
      T: con_or_DT_INT32_or_DT_INT64,
      T: 'static,
      Tseed: con_or_DT_INT32_or_DT_INT64,
      Tseed: 'static,
{
    pub fn output(self) -> Edge<dtype> {
        let rc = Rc::new(self);
        {
            Edge::<dtype>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<dtype> {
        let rc = Rc::new(self);
        {
            Edge::<dtype>::new(rc.clone(), 0)
        }
    }

    pub fn build(shape: Edge<T>, seed: Edge<Tseed>) -> Self {
        Self {
            phantom_T: PhantomData,
            shape,
            phantom_Tseed: PhantomData,
            seed,
            phantom_dtype: PhantomData,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(shape: Edge<T>, seed: Edge<Tseed>) -> Edge<dtype> {
        Self {
            phantom_T: PhantomData,
            shape,
            phantom_Tseed: PhantomData,
            seed,
            phantom_dtype: PhantomData,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<T, Tseed, dtype> GraphOperation for StatelessRandomNormal<T, Tseed, dtype>
where T: TensorType,
      T: Clone,
      Tseed: TensorType,
      Tseed: Clone,
      dtype: TensorType,
      dtype: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
      dtype: 'static,
      dtype: Clone,
      T: con_or_DT_INT32_or_DT_INT64,
      T: 'static,
      Tseed: con_or_DT_INT32_or_DT_INT64,
      Tseed: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("StatelessRandomNormal_{}")?
        };
        let mut new_op = graph.new_operation("StatelessRandomNormal", &op_name)?;
        {
            new_op.add_edge(&self.shape)?
        }
        {
            new_op.add_edge(&self.seed)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct StatelessRandomNormal<T, Tseed, dtype>
where T: TensorType,
      T: Clone,
      Tseed: TensorType,
      Tseed: Clone,
      dtype: TensorType,
      dtype: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
      dtype: 'static,
      dtype: Clone,
      T: con_or_DT_INT32_or_DT_INT64,
      T: 'static,
      Tseed: con_or_DT_INT32_or_DT_INT64,
      Tseed: 'static,
{
    phantom_T: PhantomData<T>,
    shape: Edge<T>,
    phantom_Tseed: PhantomData<Tseed>,
    seed: Edge<Tseed>,
    phantom_dtype: PhantomData<dtype>,
    op_name: Option<String>,
    id_: usize,
}

impl<T, Tseed, dtype> StatelessRandomNormal<T, Tseed, dtype>
where T: TensorType,
      T: Clone,
      Tseed: TensorType,
      Tseed: Clone,
      dtype: TensorType,
      dtype: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
      dtype: 'static,
      dtype: Clone,
      T: con_or_DT_INT32_or_DT_INT64,
      T: 'static,
      Tseed: con_or_DT_INT32_or_DT_INT64,
      Tseed: 'static,
{
    pub fn output(self) -> Edge<dtype> {
        let rc = Rc::new(self);
        {
            Edge::<dtype>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<dtype> {
        let rc = Rc::new(self);
        {
            Edge::<dtype>::new(rc.clone(), 0)
        }
    }

    pub fn build(shape: Edge<T>, seed: Edge<Tseed>) -> Self {
        Self {
            phantom_T: PhantomData,
            shape,
            phantom_Tseed: PhantomData,
            seed,
            phantom_dtype: PhantomData,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(shape: Edge<T>, seed: Edge<Tseed>) -> Edge<dtype> {
        Self {
            phantom_T: PhantomData,
            shape,
            phantom_Tseed: PhantomData,
            seed,
            phantom_dtype: PhantomData,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<T, Tindices> GraphOperation for ScatterNdSub<T, Tindices>
where T: TensorType,
      T: Clone,
      Tindices: TensorType,
      Tindices: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
      Tindices: con_or_DT_INT32_or_DT_INT64,
      Tindices: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("ScatterNdSub_{}")?
        };
        let mut new_op = graph.new_operation("ScatterNdSub", &op_name)?;
        {
            new_op.add_edge(&self.ref_)?
        }
        {
            new_op.add_edge(&self.indices)?
        }
        {
            new_op.add_edge(&self.updates)?
        }
        {
            match self.use_locking {
                None => new_op.set_attr_value_proto("use_locking", &vec![40_u8, 0_u8,])?,
                Some(ref value) => (|attr: &bool| {new_op.set_attr_bool("use_locking", *attr)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct ScatterNdSub<T, Tindices>
where T: TensorType,
      T: Clone,
      Tindices: TensorType,
      Tindices: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
      Tindices: con_or_DT_INT32_or_DT_INT64,
      Tindices: 'static,
{
    phantom_T: PhantomData<T>,
    ref_: Edge<T>,
    phantom_Tindices: PhantomData<Tindices>,
    indices: Edge<Tindices>,
    updates: Edge<T>,
    use_locking: Option<bool>,
    op_name: Option<String>,
    id_: usize,
}

impl<T, Tindices> ScatterNdSub<T, Tindices>
where T: TensorType,
      T: Clone,
      Tindices: TensorType,
      Tindices: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
      Tindices: con_or_DT_INT32_or_DT_INT64,
      Tindices: 'static,
{
    pub fn output_ref(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn use_locking(&mut self, use_locking: bool) -> Self {
        self.use_locking = Some(use_locking);
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(ref_: Edge<T>, indices: Edge<Tindices>, updates: Edge<T>) -> Self {
        Self {
            phantom_T: PhantomData,
            ref_,
            phantom_Tindices: PhantomData,
            indices,
            updates,
            use_locking: None,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(ref_: Edge<T>, indices: Edge<Tindices>, updates: Edge<T>) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            ref_,
            phantom_Tindices: PhantomData,
            indices,
            updates,
            use_locking: None,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<T, Tindices> GraphOperation for ScatterNdUpdate<T, Tindices>
where T: TensorType,
      T: Clone,
      Tindices: TensorType,
      Tindices: Clone,
      T: 'static,
      Tindices: con_or_DT_INT32_or_DT_INT64,
      Tindices: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("ScatterNdUpdate_{}")?
        };
        let mut new_op = graph.new_operation("ScatterNdUpdate", &op_name)?;
        {
            new_op.add_edge(&self.ref_)?
        }
        {
            new_op.add_edge(&self.indices)?
        }
        {
            new_op.add_edge(&self.updates)?
        }
        {
            match self.use_locking {
                None => new_op.set_attr_value_proto("use_locking", &vec![40_u8, 1_u8,])?,
                Some(ref value) => (|attr: &bool| {new_op.set_attr_bool("use_locking", *attr)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct ScatterNdUpdate<T, Tindices>
where T: TensorType,
      T: Clone,
      Tindices: TensorType,
      Tindices: Clone,
      T: 'static,
      Tindices: con_or_DT_INT32_or_DT_INT64,
      Tindices: 'static,
{
    phantom_T: PhantomData<T>,
    ref_: Edge<T>,
    phantom_Tindices: PhantomData<Tindices>,
    indices: Edge<Tindices>,
    updates: Edge<T>,
    use_locking: Option<bool>,
    op_name: Option<String>,
    id_: usize,
}

impl<T, Tindices> ScatterNdUpdate<T, Tindices>
where T: TensorType,
      T: Clone,
      Tindices: TensorType,
      Tindices: Clone,
      T: 'static,
      Tindices: con_or_DT_INT32_or_DT_INT64,
      Tindices: 'static,
{
    pub fn output_ref(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn use_locking(&mut self, use_locking: bool) -> Self {
        self.use_locking = Some(use_locking);
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(ref_: Edge<T>, indices: Edge<Tindices>, updates: Edge<T>) -> Self {
        Self {
            phantom_T: PhantomData,
            ref_,
            phantom_Tindices: PhantomData,
            indices,
            updates,
            use_locking: None,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(ref_: Edge<T>, indices: Edge<Tindices>, updates: Edge<T>) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            ref_,
            phantom_Tindices: PhantomData,
            indices,
            updates,
            use_locking: None,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

pub trait con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_INT64_or_DT_BFLOAT16_or_DT_HALF {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_INT64_or_DT_BFLOAT16_or_DT_HALF for BFloat16 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_INT64_or_DT_BFLOAT16_or_DT_HALF for f32 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_INT64_or_DT_BFLOAT16_or_DT_HALF for f64 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_INT64_or_DT_BFLOAT16_or_DT_HALF for i32 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_INT64_or_DT_BFLOAT16_or_DT_HALF for i64 {
}

impl<T, Tindices> GraphOperation for ScatterMax<T, Tindices>
where T: TensorType,
      T: Clone,
      Tindices: TensorType,
      Tindices: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_INT64_or_DT_BFLOAT16_or_DT_HALF,
      T: 'static,
      Tindices: con_or_DT_INT32_or_DT_INT64,
      Tindices: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("ScatterMax_{}")?
        };
        let mut new_op = graph.new_operation("ScatterMax", &op_name)?;
        {
            new_op.add_edge(&self.ref_)?
        }
        {
            new_op.add_edge(&self.indices)?
        }
        {
            new_op.add_edge(&self.updates)?
        }
        {
            match self.use_locking {
                None => new_op.set_attr_value_proto("use_locking", &vec![40_u8, 0_u8,])?,
                Some(ref value) => (|attr: &bool| {new_op.set_attr_bool("use_locking", *attr)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct ScatterMax<T, Tindices>
where T: TensorType,
      T: Clone,
      Tindices: TensorType,
      Tindices: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_INT64_or_DT_BFLOAT16_or_DT_HALF,
      T: 'static,
      Tindices: con_or_DT_INT32_or_DT_INT64,
      Tindices: 'static,
{
    phantom_T: PhantomData<T>,
    ref_: Edge<T>,
    phantom_Tindices: PhantomData<Tindices>,
    indices: Edge<Tindices>,
    updates: Edge<T>,
    use_locking: Option<bool>,
    op_name: Option<String>,
    id_: usize,
}

impl<T, Tindices> ScatterMax<T, Tindices>
where T: TensorType,
      T: Clone,
      Tindices: TensorType,
      Tindices: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_INT64_or_DT_BFLOAT16_or_DT_HALF,
      T: 'static,
      Tindices: con_or_DT_INT32_or_DT_INT64,
      Tindices: 'static,
{
    pub fn output_ref(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn use_locking(&mut self, use_locking: bool) -> Self {
        self.use_locking = Some(use_locking);
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(ref_: Edge<T>, indices: Edge<Tindices>, updates: Edge<T>) -> Self {
        Self {
            phantom_T: PhantomData,
            ref_,
            phantom_Tindices: PhantomData,
            indices,
            updates,
            use_locking: None,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(ref_: Edge<T>, indices: Edge<Tindices>, updates: Edge<T>) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            ref_,
            phantom_Tindices: PhantomData,
            indices,
            updates,
            use_locking: None,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<T, Tindices> GraphOperation for ScatterMin<T, Tindices>
where T: TensorType,
      T: Clone,
      Tindices: TensorType,
      Tindices: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_INT64_or_DT_BFLOAT16_or_DT_HALF,
      T: 'static,
      Tindices: con_or_DT_INT32_or_DT_INT64,
      Tindices: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("ScatterMin_{}")?
        };
        let mut new_op = graph.new_operation("ScatterMin", &op_name)?;
        {
            new_op.add_edge(&self.ref_)?
        }
        {
            new_op.add_edge(&self.indices)?
        }
        {
            new_op.add_edge(&self.updates)?
        }
        {
            match self.use_locking {
                None => new_op.set_attr_value_proto("use_locking", &vec![40_u8, 0_u8,])?,
                Some(ref value) => (|attr: &bool| {new_op.set_attr_bool("use_locking", *attr)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct ScatterMin<T, Tindices>
where T: TensorType,
      T: Clone,
      Tindices: TensorType,
      Tindices: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_INT64_or_DT_BFLOAT16_or_DT_HALF,
      T: 'static,
      Tindices: con_or_DT_INT32_or_DT_INT64,
      Tindices: 'static,
{
    phantom_T: PhantomData<T>,
    ref_: Edge<T>,
    phantom_Tindices: PhantomData<Tindices>,
    indices: Edge<Tindices>,
    updates: Edge<T>,
    use_locking: Option<bool>,
    op_name: Option<String>,
    id_: usize,
}

impl<T, Tindices> ScatterMin<T, Tindices>
where T: TensorType,
      T: Clone,
      Tindices: TensorType,
      Tindices: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_INT64_or_DT_BFLOAT16_or_DT_HALF,
      T: 'static,
      Tindices: con_or_DT_INT32_or_DT_INT64,
      Tindices: 'static,
{
    pub fn output_ref(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn use_locking(&mut self, use_locking: bool) -> Self {
        self.use_locking = Some(use_locking);
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(ref_: Edge<T>, indices: Edge<Tindices>, updates: Edge<T>) -> Self {
        Self {
            phantom_T: PhantomData,
            ref_,
            phantom_Tindices: PhantomData,
            indices,
            updates,
            use_locking: None,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(ref_: Edge<T>, indices: Edge<Tindices>, updates: Edge<T>) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            ref_,
            phantom_Tindices: PhantomData,
            indices,
            updates,
            use_locking: None,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<T, Tindices> GraphOperation for ScatterMul<T, Tindices>
where T: TensorType,
      T: Clone,
      Tindices: TensorType,
      Tindices: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
      Tindices: con_or_DT_INT32_or_DT_INT64,
      Tindices: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("ScatterMul_{}")?
        };
        let mut new_op = graph.new_operation("ScatterMul", &op_name)?;
        {
            new_op.add_edge(&self.ref_)?
        }
        {
            new_op.add_edge(&self.indices)?
        }
        {
            new_op.add_edge(&self.updates)?
        }
        {
            match self.use_locking {
                None => new_op.set_attr_value_proto("use_locking", &vec![40_u8, 0_u8,])?,
                Some(ref value) => (|attr: &bool| {new_op.set_attr_bool("use_locking", *attr)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct ScatterMul<T, Tindices>
where T: TensorType,
      T: Clone,
      Tindices: TensorType,
      Tindices: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
      Tindices: con_or_DT_INT32_or_DT_INT64,
      Tindices: 'static,
{
    phantom_T: PhantomData<T>,
    ref_: Edge<T>,
    phantom_Tindices: PhantomData<Tindices>,
    indices: Edge<Tindices>,
    updates: Edge<T>,
    use_locking: Option<bool>,
    op_name: Option<String>,
    id_: usize,
}

impl<T, Tindices> ScatterMul<T, Tindices>
where T: TensorType,
      T: Clone,
      Tindices: TensorType,
      Tindices: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
      Tindices: con_or_DT_INT32_or_DT_INT64,
      Tindices: 'static,
{
    pub fn output_ref(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn use_locking(&mut self, use_locking: bool) -> Self {
        self.use_locking = Some(use_locking);
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(ref_: Edge<T>, indices: Edge<Tindices>, updates: Edge<T>) -> Self {
        Self {
            phantom_T: PhantomData,
            ref_,
            phantom_Tindices: PhantomData,
            indices,
            updates,
            use_locking: None,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(ref_: Edge<T>, indices: Edge<Tindices>, updates: Edge<T>) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            ref_,
            phantom_Tindices: PhantomData,
            indices,
            updates,
            use_locking: None,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<T> GraphOperation for AssignSub<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("AssignSub_{}")?
        };
        let mut new_op = graph.new_operation("AssignSub", &op_name)?;
        {
            new_op.add_edge(&self.ref_)?
        }
        {
            new_op.add_edge(&self.value)?
        }
        {
            match self.use_locking {
                None => new_op.set_attr_value_proto("use_locking", &vec![40_u8, 0_u8,])?,
                Some(ref value) => (|attr: &bool| {new_op.set_attr_bool("use_locking", *attr)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct AssignSub<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    ref_: Edge<T>,
    value: Edge<T>,
    use_locking: Option<bool>,
    op_name: Option<String>,
    id_: usize,
}

impl<T> AssignSub<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
{
    pub fn output_ref(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn use_locking(&mut self, use_locking: bool) -> Self {
        self.use_locking = Some(use_locking);
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(ref_: Edge<T>, value: Edge<T>) -> Self {
        Self {
            phantom_T: PhantomData,
            ref_,
            value,
            use_locking: None,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(ref_: Edge<T>, value: Edge<T>) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            ref_,
            value,
            use_locking: None,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<T> GraphOperation for DestroyTemporaryVariable<T>
where T: TensorType,
      T: Clone,
      T: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("DestroyTemporaryVariable_{}")?
        };
        let mut new_op = graph.new_operation("DestroyTemporaryVariable", &op_name)?;
        {
            new_op.add_edge(&self.ref_)?
        }
        {
            (|attr| {new_op.set_attr_string("var_name", attr)})(&self.var_name)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct DestroyTemporaryVariable<T>
where T: TensorType,
      T: Clone,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    ref_: Edge<T>,
    var_name: String,
    op_name: Option<String>,
    id_: usize,
}

impl<T> DestroyTemporaryVariable<T>
where T: TensorType,
      T: Clone,
      T: 'static,
{
    pub fn value(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(ref_: Edge<T>, var_name: &str) -> Self {
        Self {
            phantom_T: PhantomData,
            ref_,
            var_name: var_name.to_string(),
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(ref_: Edge<T>, var_name: &str) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            ref_,
            var_name: var_name.to_string(),
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl GraphOperation for BatchIFFT3D {
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("BatchIFFT3D_{}")?
        };
        let mut new_op = graph.new_operation("BatchIFFT3D", &op_name)?;
        {
            new_op.add_edge(&self.input)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct BatchIFFT3D {
    input: Edge<OtherComplex<f32>>,
    op_name: Option<String>,
    id_: usize,
}

impl BatchIFFT3D {
    pub fn output(self) -> Edge<OtherComplex<f32>> {
        let rc = Rc::new(self);
        {
            Edge::<OtherComplex::<f32>>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<OtherComplex<f32>> {
        let rc = Rc::new(self);
        {
            Edge::<OtherComplex::<f32>>::new(rc.clone(), 0)
        }
    }

    pub fn build(input: Edge<OtherComplex<f32>>) -> Self {
        Self {
            input,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(input: Edge<OtherComplex<f32>>) -> Edge<OtherComplex<f32>> {
        Self {
            input,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl GraphOperation for BatchFFT3D {
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("BatchFFT3D_{}")?
        };
        let mut new_op = graph.new_operation("BatchFFT3D", &op_name)?;
        {
            new_op.add_edge(&self.input)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct BatchFFT3D {
    input: Edge<OtherComplex<f32>>,
    op_name: Option<String>,
    id_: usize,
}

impl BatchFFT3D {
    pub fn output(self) -> Edge<OtherComplex<f32>> {
        let rc = Rc::new(self);
        {
            Edge::<OtherComplex::<f32>>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<OtherComplex<f32>> {
        let rc = Rc::new(self);
        {
            Edge::<OtherComplex::<f32>>::new(rc.clone(), 0)
        }
    }

    pub fn build(input: Edge<OtherComplex<f32>>) -> Self {
        Self {
            input,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(input: Edge<OtherComplex<f32>>) -> Edge<OtherComplex<f32>> {
        Self {
            input,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl GraphOperation for BatchIFFT2D {
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("BatchIFFT2D_{}")?
        };
        let mut new_op = graph.new_operation("BatchIFFT2D", &op_name)?;
        {
            new_op.add_edge(&self.input)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct BatchIFFT2D {
    input: Edge<OtherComplex<f32>>,
    op_name: Option<String>,
    id_: usize,
}

impl BatchIFFT2D {
    pub fn output(self) -> Edge<OtherComplex<f32>> {
        let rc = Rc::new(self);
        {
            Edge::<OtherComplex::<f32>>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<OtherComplex<f32>> {
        let rc = Rc::new(self);
        {
            Edge::<OtherComplex::<f32>>::new(rc.clone(), 0)
        }
    }

    pub fn build(input: Edge<OtherComplex<f32>>) -> Self {
        Self {
            input,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(input: Edge<OtherComplex<f32>>) -> Edge<OtherComplex<f32>> {
        Self {
            input,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl GraphOperation for BatchFFT2D {
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("BatchFFT2D_{}")?
        };
        let mut new_op = graph.new_operation("BatchFFT2D", &op_name)?;
        {
            new_op.add_edge(&self.input)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct BatchFFT2D {
    input: Edge<OtherComplex<f32>>,
    op_name: Option<String>,
    id_: usize,
}

impl BatchFFT2D {
    pub fn output(self) -> Edge<OtherComplex<f32>> {
        let rc = Rc::new(self);
        {
            Edge::<OtherComplex::<f32>>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<OtherComplex<f32>> {
        let rc = Rc::new(self);
        {
            Edge::<OtherComplex::<f32>>::new(rc.clone(), 0)
        }
    }

    pub fn build(input: Edge<OtherComplex<f32>>) -> Self {
        Self {
            input,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(input: Edge<OtherComplex<f32>>) -> Edge<OtherComplex<f32>> {
        Self {
            input,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl GraphOperation for BatchIFFT {
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("BatchIFFT_{}")?
        };
        let mut new_op = graph.new_operation("BatchIFFT", &op_name)?;
        {
            new_op.add_edge(&self.input)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct BatchIFFT {
    input: Edge<OtherComplex<f32>>,
    op_name: Option<String>,
    id_: usize,
}

impl BatchIFFT {
    pub fn output(self) -> Edge<OtherComplex<f32>> {
        let rc = Rc::new(self);
        {
            Edge::<OtherComplex::<f32>>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<OtherComplex<f32>> {
        let rc = Rc::new(self);
        {
            Edge::<OtherComplex::<f32>>::new(rc.clone(), 0)
        }
    }

    pub fn build(input: Edge<OtherComplex<f32>>) -> Self {
        Self {
            input,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(input: Edge<OtherComplex<f32>>) -> Edge<OtherComplex<f32>> {
        Self {
            input,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl GraphOperation for IRFFT3D {
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("IRFFT3D_{}")?
        };
        let mut new_op = graph.new_operation("IRFFT3D", &op_name)?;
        {
            new_op.add_edge(&self.input)?
        }
        {
            new_op.add_edge(&self.fft_length)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct IRFFT3D {
    input: Edge<OtherComplex<f32>>,
    fft_length: Edge<i32>,
    op_name: Option<String>,
    id_: usize,
}

impl IRFFT3D {
    pub fn output(self) -> Edge<f32> {
        let rc = Rc::new(self);
        {
            Edge::<f32>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<f32> {
        let rc = Rc::new(self);
        {
            Edge::<f32>::new(rc.clone(), 0)
        }
    }

    pub fn build(input: Edge<OtherComplex<f32>>, fft_length: Edge<i32>) -> Self {
        Self {
            input,
            fft_length,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(input: Edge<OtherComplex<f32>>, fft_length: Edge<i32>) -> Edge<f32> {
        Self {
            input,
            fft_length,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl GraphOperation for IRFFT2D {
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("IRFFT2D_{}")?
        };
        let mut new_op = graph.new_operation("IRFFT2D", &op_name)?;
        {
            new_op.add_edge(&self.input)?
        }
        {
            new_op.add_edge(&self.fft_length)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct IRFFT2D {
    input: Edge<OtherComplex<f32>>,
    fft_length: Edge<i32>,
    op_name: Option<String>,
    id_: usize,
}

impl IRFFT2D {
    pub fn output(self) -> Edge<f32> {
        let rc = Rc::new(self);
        {
            Edge::<f32>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<f32> {
        let rc = Rc::new(self);
        {
            Edge::<f32>::new(rc.clone(), 0)
        }
    }

    pub fn build(input: Edge<OtherComplex<f32>>, fft_length: Edge<i32>) -> Self {
        Self {
            input,
            fft_length,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(input: Edge<OtherComplex<f32>>, fft_length: Edge<i32>) -> Edge<f32> {
        Self {
            input,
            fft_length,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl GraphOperation for RFFT2D {
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("RFFT2D_{}")?
        };
        let mut new_op = graph.new_operation("RFFT2D", &op_name)?;
        {
            new_op.add_edge(&self.input)?
        }
        {
            new_op.add_edge(&self.fft_length)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct RFFT2D {
    input: Edge<f32>,
    fft_length: Edge<i32>,
    op_name: Option<String>,
    id_: usize,
}

impl RFFT2D {
    pub fn output(self) -> Edge<OtherComplex<f32>> {
        let rc = Rc::new(self);
        {
            Edge::<OtherComplex::<f32>>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<OtherComplex<f32>> {
        let rc = Rc::new(self);
        {
            Edge::<OtherComplex::<f32>>::new(rc.clone(), 0)
        }
    }

    pub fn build(input: Edge<f32>, fft_length: Edge<i32>) -> Self {
        Self {
            input,
            fft_length,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(input: Edge<f32>, fft_length: Edge<i32>) -> Edge<OtherComplex<f32>> {
        Self {
            input,
            fft_length,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl GraphOperation for RFFT {
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("RFFT_{}")?
        };
        let mut new_op = graph.new_operation("RFFT", &op_name)?;
        {
            new_op.add_edge(&self.input)?
        }
        {
            new_op.add_edge(&self.fft_length)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct RFFT {
    input: Edge<f32>,
    fft_length: Edge<i32>,
    op_name: Option<String>,
    id_: usize,
}

impl RFFT {
    pub fn output(self) -> Edge<OtherComplex<f32>> {
        let rc = Rc::new(self);
        {
            Edge::<OtherComplex::<f32>>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<OtherComplex<f32>> {
        let rc = Rc::new(self);
        {
            Edge::<OtherComplex::<f32>>::new(rc.clone(), 0)
        }
    }

    pub fn build(input: Edge<f32>, fft_length: Edge<i32>) -> Self {
        Self {
            input,
            fft_length,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(input: Edge<f32>, fft_length: Edge<i32>) -> Edge<OtherComplex<f32>> {
        Self {
            input,
            fft_length,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

pub trait con_or_DT_COMPLEX64_or_DT_COMPLEX128 {
}

impl con_or_DT_COMPLEX64_or_DT_COMPLEX128 for OtherComplex<f32> {
}

impl con_or_DT_COMPLEX64_or_DT_COMPLEX128 for OtherComplex<f64> {
}

impl<Tcomplex> GraphOperation for IFFT2D<Tcomplex>
where Tcomplex: TensorType,
      Tcomplex: Clone,
      Tcomplex: con_or_DT_COMPLEX64_or_DT_COMPLEX128,
      Tcomplex: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("IFFT2D_{}")?
        };
        let mut new_op = graph.new_operation("IFFT2D", &op_name)?;
        {
            new_op.add_edge(&self.input)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct IFFT2D<Tcomplex>
where Tcomplex: TensorType,
      Tcomplex: Clone,
      Tcomplex: con_or_DT_COMPLEX64_or_DT_COMPLEX128,
      Tcomplex: 'static,
{
    phantom_Tcomplex: PhantomData<Tcomplex>,
    input: Edge<Tcomplex>,
    op_name: Option<String>,
    id_: usize,
}

impl<Tcomplex> IFFT2D<Tcomplex>
where Tcomplex: TensorType,
      Tcomplex: Clone,
      Tcomplex: con_or_DT_COMPLEX64_or_DT_COMPLEX128,
      Tcomplex: 'static,
{
    pub fn output(self) -> Edge<Tcomplex> {
        let rc = Rc::new(self);
        {
            Edge::<Tcomplex>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<Tcomplex> {
        let rc = Rc::new(self);
        {
            Edge::<Tcomplex>::new(rc.clone(), 0)
        }
    }

    pub fn build(input: Edge<Tcomplex>) -> Self {
        Self {
            phantom_Tcomplex: PhantomData,
            input,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(input: Edge<Tcomplex>) -> Edge<Tcomplex> {
        Self {
            phantom_Tcomplex: PhantomData,
            input,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<Tcomplex> GraphOperation for FFT2D<Tcomplex>
where Tcomplex: TensorType,
      Tcomplex: Clone,
      Tcomplex: con_or_DT_COMPLEX64_or_DT_COMPLEX128,
      Tcomplex: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("FFT2D_{}")?
        };
        let mut new_op = graph.new_operation("FFT2D", &op_name)?;
        {
            new_op.add_edge(&self.input)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct FFT2D<Tcomplex>
where Tcomplex: TensorType,
      Tcomplex: Clone,
      Tcomplex: con_or_DT_COMPLEX64_or_DT_COMPLEX128,
      Tcomplex: 'static,
{
    phantom_Tcomplex: PhantomData<Tcomplex>,
    input: Edge<Tcomplex>,
    op_name: Option<String>,
    id_: usize,
}

impl<Tcomplex> FFT2D<Tcomplex>
where Tcomplex: TensorType,
      Tcomplex: Clone,
      Tcomplex: con_or_DT_COMPLEX64_or_DT_COMPLEX128,
      Tcomplex: 'static,
{
    pub fn output(self) -> Edge<Tcomplex> {
        let rc = Rc::new(self);
        {
            Edge::<Tcomplex>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<Tcomplex> {
        let rc = Rc::new(self);
        {
            Edge::<Tcomplex>::new(rc.clone(), 0)
        }
    }

    pub fn build(input: Edge<Tcomplex>) -> Self {
        Self {
            phantom_Tcomplex: PhantomData,
            input,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(input: Edge<Tcomplex>) -> Edge<Tcomplex> {
        Self {
            phantom_Tcomplex: PhantomData,
            input,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<Tcomplex> GraphOperation for IFFT<Tcomplex>
where Tcomplex: TensorType,
      Tcomplex: Clone,
      Tcomplex: con_or_DT_COMPLEX64_or_DT_COMPLEX128,
      Tcomplex: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("IFFT_{}")?
        };
        let mut new_op = graph.new_operation("IFFT", &op_name)?;
        {
            new_op.add_edge(&self.input)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct IFFT<Tcomplex>
where Tcomplex: TensorType,
      Tcomplex: Clone,
      Tcomplex: con_or_DT_COMPLEX64_or_DT_COMPLEX128,
      Tcomplex: 'static,
{
    phantom_Tcomplex: PhantomData<Tcomplex>,
    input: Edge<Tcomplex>,
    op_name: Option<String>,
    id_: usize,
}

impl<Tcomplex> IFFT<Tcomplex>
where Tcomplex: TensorType,
      Tcomplex: Clone,
      Tcomplex: con_or_DT_COMPLEX64_or_DT_COMPLEX128,
      Tcomplex: 'static,
{
    pub fn output(self) -> Edge<Tcomplex> {
        let rc = Rc::new(self);
        {
            Edge::<Tcomplex>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<Tcomplex> {
        let rc = Rc::new(self);
        {
            Edge::<Tcomplex>::new(rc.clone(), 0)
        }
    }

    pub fn build(input: Edge<Tcomplex>) -> Self {
        Self {
            phantom_Tcomplex: PhantomData,
            input,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(input: Edge<Tcomplex>) -> Edge<Tcomplex> {
        Self {
            phantom_Tcomplex: PhantomData,
            input,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<T> GraphOperation for SparseFillEmptyRows<T>
where T: TensorType,
      T: Clone,
      T: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("SparseFillEmptyRows_{}")?
        };
        let mut new_op = graph.new_operation("SparseFillEmptyRows", &op_name)?;
        {
            new_op.add_edge(&self.indices)?
        }
        {
            new_op.add_edge(&self.values)?
        }
        {
            new_op.add_edge(&self.dense_shape)?
        }
        {
            new_op.add_edge(&self.default_value)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct SparseFillEmptyRows<T>
where T: TensorType,
      T: Clone,
      T: 'static,
{
    indices: Edge<i64>,
    phantom_T: PhantomData<T>,
    values: Edge<T>,
    dense_shape: Edge<i64>,
    default_value: Edge<T>,
    op_name: Option<String>,
    id_: usize,
}

impl<T> SparseFillEmptyRows<T>
where T: TensorType,
      T: Clone,
      T: 'static,
{
    pub fn output_indices(self) -> Edge<i64> {
        let rc = Rc::new(self);
        {
            Edge::<i64>::new(rc.clone(), 0)
        }
    }

    pub fn output_values(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 1)
        }
    }

    pub fn empty_row_indicator(self) -> Edge<bool> {
        let rc = Rc::new(self);
        {
            Edge::<bool>::new(rc.clone(), 2)
        }
    }

    pub fn reverse_index_map(self) -> Edge<i64> {
        let rc = Rc::new(self);
        {
            Edge::<i64>::new(rc.clone(), 3)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> (Edge<i64>, Edge<T>, Edge<bool>, Edge<i64>) {
        let rc = Rc::new(self);
        (
        {
            Edge::<i64>::new(rc.clone(), 0)
        },
        {
            Edge::<T>::new(rc.clone(), 1)
        },
        {
            Edge::<bool>::new(rc.clone(), 2)
        },
        {
            Edge::<i64>::new(rc.clone(), 3)
        },
        )
    }

    pub fn build(indices: Edge<i64>, values: Edge<T>, dense_shape: Edge<i64>, default_value: Edge<T>) -> Self {
        Self {
            indices,
            phantom_T: PhantomData,
            values,
            dense_shape,
            default_value,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(indices: Edge<i64>, values: Edge<T>, dense_shape: Edge<i64>, default_value: Edge<T>) -> (Edge<i64>, Edge<T>, Edge<bool>, Edge<i64>) {
        Self {
            indices,
            phantom_T: PhantomData,
            values,
            dense_shape,
            default_value,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<T> GraphOperation for SparseSparseMinimum<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("SparseSparseMinimum_{}")?
        };
        let mut new_op = graph.new_operation("SparseSparseMinimum", &op_name)?;
        {
            new_op.add_edge(&self.a_indices)?
        }
        {
            new_op.add_edge(&self.a_values)?
        }
        {
            new_op.add_edge(&self.a_shape)?
        }
        {
            new_op.add_edge(&self.b_indices)?
        }
        {
            new_op.add_edge(&self.b_values)?
        }
        {
            new_op.add_edge(&self.b_shape)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct SparseSparseMinimum<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
{
    a_indices: Edge<i64>,
    phantom_T: PhantomData<T>,
    a_values: Edge<T>,
    a_shape: Edge<i64>,
    b_indices: Edge<i64>,
    b_values: Edge<T>,
    b_shape: Edge<i64>,
    op_name: Option<String>,
    id_: usize,
}

impl<T> SparseSparseMinimum<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
{
    pub fn output_indices(self) -> Edge<i64> {
        let rc = Rc::new(self);
        {
            Edge::<i64>::new(rc.clone(), 0)
        }
    }

    pub fn output_values(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 1)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> (Edge<i64>, Edge<T>) {
        let rc = Rc::new(self);
        (
        {
            Edge::<i64>::new(rc.clone(), 0)
        },
        {
            Edge::<T>::new(rc.clone(), 1)
        },
        )
    }

    pub fn build(a_indices: Edge<i64>, a_values: Edge<T>, a_shape: Edge<i64>, b_indices: Edge<i64>, b_values: Edge<T>, b_shape: Edge<i64>) -> Self {
        Self {
            a_indices,
            phantom_T: PhantomData,
            a_values,
            a_shape,
            b_indices,
            b_values,
            b_shape,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(a_indices: Edge<i64>, a_values: Edge<T>, a_shape: Edge<i64>, b_indices: Edge<i64>, b_values: Edge<T>, b_shape: Edge<i64>) -> (Edge<i64>, Edge<T>) {
        Self {
            a_indices,
            phantom_T: PhantomData,
            a_values,
            a_shape,
            b_indices,
            b_values,
            b_shape,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

pub trait con_or_DT_FLOAT_or_DT_DOUBLE {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE for f32 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE for f64 {
}

impl<T> GraphOperation for SparseSoftmax<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE,
      T: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("SparseSoftmax_{}")?
        };
        let mut new_op = graph.new_operation("SparseSoftmax", &op_name)?;
        {
            new_op.add_edge(&self.sp_indices)?
        }
        {
            new_op.add_edge(&self.sp_values)?
        }
        {
            new_op.add_edge(&self.sp_shape)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct SparseSoftmax<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE,
      T: 'static,
{
    sp_indices: Edge<i64>,
    phantom_T: PhantomData<T>,
    sp_values: Edge<T>,
    sp_shape: Edge<i64>,
    op_name: Option<String>,
    id_: usize,
}

impl<T> SparseSoftmax<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE,
      T: 'static,
{
    pub fn output(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(sp_indices: Edge<i64>, sp_values: Edge<T>, sp_shape: Edge<i64>) -> Self {
        Self {
            sp_indices,
            phantom_T: PhantomData,
            sp_values,
            sp_shape,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(sp_indices: Edge<i64>, sp_values: Edge<T>, sp_shape: Edge<i64>) -> Edge<T> {
        Self {
            sp_indices,
            phantom_T: PhantomData,
            sp_values,
            sp_shape,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<T> GraphOperation for SparseDenseCwiseAdd<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("SparseDenseCwiseAdd_{}")?
        };
        let mut new_op = graph.new_operation("SparseDenseCwiseAdd", &op_name)?;
        {
            new_op.add_edge(&self.sp_indices)?
        }
        {
            new_op.add_edge(&self.sp_values)?
        }
        {
            new_op.add_edge(&self.sp_shape)?
        }
        {
            new_op.add_edge(&self.dense)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct SparseDenseCwiseAdd<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
{
    sp_indices: Edge<i64>,
    phantom_T: PhantomData<T>,
    sp_values: Edge<T>,
    sp_shape: Edge<i64>,
    dense: Edge<T>,
    op_name: Option<String>,
    id_: usize,
}

impl<T> SparseDenseCwiseAdd<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
{
    pub fn output(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(sp_indices: Edge<i64>, sp_values: Edge<T>, sp_shape: Edge<i64>, dense: Edge<T>) -> Self {
        Self {
            sp_indices,
            phantom_T: PhantomData,
            sp_values,
            sp_shape,
            dense,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(sp_indices: Edge<i64>, sp_values: Edge<T>, sp_shape: Edge<i64>, dense: Edge<T>) -> Edge<T> {
        Self {
            sp_indices,
            phantom_T: PhantomData,
            sp_values,
            sp_shape,
            dense,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<T> GraphOperation for ApplyMomentum<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("ApplyMomentum_{}")?
        };
        let mut new_op = graph.new_operation("ApplyMomentum", &op_name)?;
        {
            new_op.add_edge(&self.var)?
        }
        {
            new_op.add_edge(&self.accum)?
        }
        {
            new_op.add_edge(&self.lr)?
        }
        {
            new_op.add_edge(&self.grad)?
        }
        {
            new_op.add_edge(&self.momentum)?
        }
        {
            match self.use_locking {
                None => new_op.set_attr_value_proto("use_locking", &vec![40_u8, 0_u8,])?,
                Some(ref value) => (|attr: &bool| {new_op.set_attr_bool("use_locking", *attr)})(&value)?,
            };
        }
        {
            match self.use_nesterov {
                None => new_op.set_attr_value_proto("use_nesterov", &vec![40_u8, 0_u8,])?,
                Some(ref value) => (|attr: &bool| {new_op.set_attr_bool("use_nesterov", *attr)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct ApplyMomentum<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    var: Edge<T>,
    accum: Edge<T>,
    lr: Edge<T>,
    grad: Edge<T>,
    momentum: Edge<T>,
    use_locking: Option<bool>,
    use_nesterov: Option<bool>,
    op_name: Option<String>,
    id_: usize,
}

impl<T> ApplyMomentum<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
{
    pub fn out(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn use_locking(&mut self, use_locking: bool) -> Self {
        self.use_locking = Some(use_locking);
        self.clone()
    }

    pub fn use_nesterov(&mut self, use_nesterov: bool) -> Self {
        self.use_nesterov = Some(use_nesterov);
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(var: Edge<T>, accum: Edge<T>, lr: Edge<T>, grad: Edge<T>, momentum: Edge<T>) -> Self {
        Self {
            phantom_T: PhantomData,
            var,
            accum,
            lr,
            grad,
            momentum,
            use_locking: None,
            use_nesterov: None,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(var: Edge<T>, accum: Edge<T>, lr: Edge<T>, grad: Edge<T>, momentum: Edge<T>) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            var,
            accum,
            lr,
            grad,
            momentum,
            use_locking: None,
            use_nesterov: None,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<T> GraphOperation for SparseDenseCwiseDiv<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("SparseDenseCwiseDiv_{}")?
        };
        let mut new_op = graph.new_operation("SparseDenseCwiseDiv", &op_name)?;
        {
            new_op.add_edge(&self.sp_indices)?
        }
        {
            new_op.add_edge(&self.sp_values)?
        }
        {
            new_op.add_edge(&self.sp_shape)?
        }
        {
            new_op.add_edge(&self.dense)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct SparseDenseCwiseDiv<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
{
    sp_indices: Edge<i64>,
    phantom_T: PhantomData<T>,
    sp_values: Edge<T>,
    sp_shape: Edge<i64>,
    dense: Edge<T>,
    op_name: Option<String>,
    id_: usize,
}

impl<T> SparseDenseCwiseDiv<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
{
    pub fn output(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(sp_indices: Edge<i64>, sp_values: Edge<T>, sp_shape: Edge<i64>, dense: Edge<T>) -> Self {
        Self {
            sp_indices,
            phantom_T: PhantomData,
            sp_values,
            sp_shape,
            dense,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(sp_indices: Edge<i64>, sp_values: Edge<T>, sp_shape: Edge<i64>, dense: Edge<T>) -> Edge<T> {
        Self {
            sp_indices,
            phantom_T: PhantomData,
            sp_values,
            sp_shape,
            dense,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<T> GraphOperation for SparseDenseCwiseMul<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("SparseDenseCwiseMul_{}")?
        };
        let mut new_op = graph.new_operation("SparseDenseCwiseMul", &op_name)?;
        {
            new_op.add_edge(&self.sp_indices)?
        }
        {
            new_op.add_edge(&self.sp_values)?
        }
        {
            new_op.add_edge(&self.sp_shape)?
        }
        {
            new_op.add_edge(&self.dense)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct SparseDenseCwiseMul<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
{
    sp_indices: Edge<i64>,
    phantom_T: PhantomData<T>,
    sp_values: Edge<T>,
    sp_shape: Edge<i64>,
    dense: Edge<T>,
    op_name: Option<String>,
    id_: usize,
}

impl<T> SparseDenseCwiseMul<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
{
    pub fn output(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(sp_indices: Edge<i64>, sp_values: Edge<T>, sp_shape: Edge<i64>, dense: Edge<T>) -> Self {
        Self {
            sp_indices,
            phantom_T: PhantomData,
            sp_values,
            sp_shape,
            dense,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(sp_indices: Edge<i64>, sp_values: Edge<T>, sp_shape: Edge<i64>, dense: Edge<T>) -> Edge<T> {
        Self {
            sp_indices,
            phantom_T: PhantomData,
            sp_values,
            sp_shape,
            dense,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<T> GraphOperation for SparseReduceSumSparse<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("SparseReduceSumSparse_{}")?
        };
        let mut new_op = graph.new_operation("SparseReduceSumSparse", &op_name)?;
        {
            new_op.add_edge(&self.input_indices)?
        }
        {
            new_op.add_edge(&self.input_values)?
        }
        {
            new_op.add_edge(&self.input_shape)?
        }
        {
            new_op.add_edge(&self.reduction_axes)?
        }
        {
            match self.keep_dims {
                None => new_op.set_attr_value_proto("keep_dims", &vec![40_u8, 0_u8,])?,
                Some(ref value) => (|attr: &bool| {new_op.set_attr_bool("keep_dims", *attr)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct SparseReduceSumSparse<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
{
    input_indices: Edge<i64>,
    phantom_T: PhantomData<T>,
    input_values: Edge<T>,
    input_shape: Edge<i64>,
    reduction_axes: Edge<i32>,
    keep_dims: Option<bool>,
    op_name: Option<String>,
    id_: usize,
}

impl<T> SparseReduceSumSparse<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
{
    pub fn output_indices(self) -> Edge<i64> {
        let rc = Rc::new(self);
        {
            Edge::<i64>::new(rc.clone(), 0)
        }
    }

    pub fn output_values(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 1)
        }
    }

    pub fn output_shape(self) -> Edge<i64> {
        let rc = Rc::new(self);
        {
            Edge::<i64>::new(rc.clone(), 2)
        }
    }

    pub fn keep_dims(&mut self, keep_dims: bool) -> Self {
        self.keep_dims = Some(keep_dims);
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> (Edge<i64>, Edge<T>, Edge<i64>) {
        let rc = Rc::new(self);
        (
        {
            Edge::<i64>::new(rc.clone(), 0)
        },
        {
            Edge::<T>::new(rc.clone(), 1)
        },
        {
            Edge::<i64>::new(rc.clone(), 2)
        },
        )
    }

    pub fn build(input_indices: Edge<i64>, input_values: Edge<T>, input_shape: Edge<i64>, reduction_axes: Edge<i32>) -> Self {
        Self {
            input_indices,
            phantom_T: PhantomData,
            input_values,
            input_shape,
            reduction_axes,
            keep_dims: None,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(input_indices: Edge<i64>, input_values: Edge<T>, input_shape: Edge<i64>, reduction_axes: Edge<i32>) -> (Edge<i64>, Edge<T>, Edge<i64>) {
        Self {
            input_indices,
            phantom_T: PhantomData,
            input_values,
            input_shape,
            reduction_axes,
            keep_dims: None,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<T> GraphOperation for SparseReduceSum<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("SparseReduceSum_{}")?
        };
        let mut new_op = graph.new_operation("SparseReduceSum", &op_name)?;
        {
            new_op.add_edge(&self.input_indices)?
        }
        {
            new_op.add_edge(&self.input_values)?
        }
        {
            new_op.add_edge(&self.input_shape)?
        }
        {
            new_op.add_edge(&self.reduction_axes)?
        }
        {
            match self.keep_dims {
                None => new_op.set_attr_value_proto("keep_dims", &vec![40_u8, 0_u8,])?,
                Some(ref value) => (|attr: &bool| {new_op.set_attr_bool("keep_dims", *attr)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct SparseReduceSum<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
{
    input_indices: Edge<i64>,
    phantom_T: PhantomData<T>,
    input_values: Edge<T>,
    input_shape: Edge<i64>,
    reduction_axes: Edge<i32>,
    keep_dims: Option<bool>,
    op_name: Option<String>,
    id_: usize,
}

impl<T> SparseReduceSum<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
{
    pub fn output(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn keep_dims(&mut self, keep_dims: bool) -> Self {
        self.keep_dims = Some(keep_dims);
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(input_indices: Edge<i64>, input_values: Edge<T>, input_shape: Edge<i64>, reduction_axes: Edge<i32>) -> Self {
        Self {
            input_indices,
            phantom_T: PhantomData,
            input_values,
            input_shape,
            reduction_axes,
            keep_dims: None,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(input_indices: Edge<i64>, input_values: Edge<T>, input_shape: Edge<i64>, reduction_axes: Edge<i32>) -> Edge<T> {
        Self {
            input_indices,
            phantom_T: PhantomData,
            input_values,
            input_shape,
            reduction_axes,
            keep_dims: None,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<T> GraphOperation for SparseReduceMaxSparse<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("SparseReduceMaxSparse_{}")?
        };
        let mut new_op = graph.new_operation("SparseReduceMaxSparse", &op_name)?;
        {
            new_op.add_edge(&self.input_indices)?
        }
        {
            new_op.add_edge(&self.input_values)?
        }
        {
            new_op.add_edge(&self.input_shape)?
        }
        {
            new_op.add_edge(&self.reduction_axes)?
        }
        {
            match self.keep_dims {
                None => new_op.set_attr_value_proto("keep_dims", &vec![40_u8, 0_u8,])?,
                Some(ref value) => (|attr: &bool| {new_op.set_attr_bool("keep_dims", *attr)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct SparseReduceMaxSparse<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
{
    input_indices: Edge<i64>,
    phantom_T: PhantomData<T>,
    input_values: Edge<T>,
    input_shape: Edge<i64>,
    reduction_axes: Edge<i32>,
    keep_dims: Option<bool>,
    op_name: Option<String>,
    id_: usize,
}

impl<T> SparseReduceMaxSparse<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
{
    pub fn output_indices(self) -> Edge<i64> {
        let rc = Rc::new(self);
        {
            Edge::<i64>::new(rc.clone(), 0)
        }
    }

    pub fn output_values(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 1)
        }
    }

    pub fn output_shape(self) -> Edge<i64> {
        let rc = Rc::new(self);
        {
            Edge::<i64>::new(rc.clone(), 2)
        }
    }

    pub fn keep_dims(&mut self, keep_dims: bool) -> Self {
        self.keep_dims = Some(keep_dims);
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> (Edge<i64>, Edge<T>, Edge<i64>) {
        let rc = Rc::new(self);
        (
        {
            Edge::<i64>::new(rc.clone(), 0)
        },
        {
            Edge::<T>::new(rc.clone(), 1)
        },
        {
            Edge::<i64>::new(rc.clone(), 2)
        },
        )
    }

    pub fn build(input_indices: Edge<i64>, input_values: Edge<T>, input_shape: Edge<i64>, reduction_axes: Edge<i32>) -> Self {
        Self {
            input_indices,
            phantom_T: PhantomData,
            input_values,
            input_shape,
            reduction_axes,
            keep_dims: None,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(input_indices: Edge<i64>, input_values: Edge<T>, input_shape: Edge<i64>, reduction_axes: Edge<i32>) -> (Edge<i64>, Edge<T>, Edge<i64>) {
        Self {
            input_indices,
            phantom_T: PhantomData,
            input_values,
            input_shape,
            reduction_axes,
            keep_dims: None,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<Tindices, T> GraphOperation for SparseTensorDenseAdd<Tindices, T>
where Tindices: TensorType,
      Tindices: Clone,
      T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
      Tindices: con_or_DT_INT32_or_DT_INT64,
      Tindices: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("SparseTensorDenseAdd_{}")?
        };
        let mut new_op = graph.new_operation("SparseTensorDenseAdd", &op_name)?;
        {
            new_op.add_edge(&self.a_indices)?
        }
        {
            new_op.add_edge(&self.a_values)?
        }
        {
            new_op.add_edge(&self.a_shape)?
        }
        {
            new_op.add_edge(&self.b)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct SparseTensorDenseAdd<Tindices, T>
where Tindices: TensorType,
      Tindices: Clone,
      T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
      Tindices: con_or_DT_INT32_or_DT_INT64,
      Tindices: 'static,
{
    phantom_Tindices: PhantomData<Tindices>,
    a_indices: Edge<Tindices>,
    phantom_T: PhantomData<T>,
    a_values: Edge<T>,
    a_shape: Edge<Tindices>,
    b: Edge<T>,
    op_name: Option<String>,
    id_: usize,
}

impl<Tindices, T> SparseTensorDenseAdd<Tindices, T>
where Tindices: TensorType,
      Tindices: Clone,
      T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
      Tindices: con_or_DT_INT32_or_DT_INT64,
      Tindices: 'static,
{
    pub fn output(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(a_indices: Edge<Tindices>, a_values: Edge<T>, a_shape: Edge<Tindices>, b: Edge<T>) -> Self {
        Self {
            phantom_Tindices: PhantomData,
            a_indices,
            phantom_T: PhantomData,
            a_values,
            a_shape,
            b,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(a_indices: Edge<Tindices>, a_values: Edge<T>, a_shape: Edge<Tindices>, b: Edge<T>) -> Edge<T> {
        Self {
            phantom_Tindices: PhantomData,
            a_indices,
            phantom_T: PhantomData,
            a_values,
            a_shape,
            b,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<T> GraphOperation for SparseReorder<T>
where T: TensorType,
      T: Clone,
      T: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("SparseReorder_{}")?
        };
        let mut new_op = graph.new_operation("SparseReorder", &op_name)?;
        {
            new_op.add_edge(&self.input_indices)?
        }
        {
            new_op.add_edge(&self.input_values)?
        }
        {
            new_op.add_edge(&self.input_shape)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct SparseReorder<T>
where T: TensorType,
      T: Clone,
      T: 'static,
{
    input_indices: Edge<i64>,
    phantom_T: PhantomData<T>,
    input_values: Edge<T>,
    input_shape: Edge<i64>,
    op_name: Option<String>,
    id_: usize,
}

impl<T> SparseReorder<T>
where T: TensorType,
      T: Clone,
      T: 'static,
{
    pub fn output_indices(self) -> Edge<i64> {
        let rc = Rc::new(self);
        {
            Edge::<i64>::new(rc.clone(), 0)
        }
    }

    pub fn output_values(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 1)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> (Edge<i64>, Edge<T>) {
        let rc = Rc::new(self);
        (
        {
            Edge::<i64>::new(rc.clone(), 0)
        },
        {
            Edge::<T>::new(rc.clone(), 1)
        },
        )
    }

    pub fn build(input_indices: Edge<i64>, input_values: Edge<T>, input_shape: Edge<i64>) -> Self {
        Self {
            input_indices,
            phantom_T: PhantomData,
            input_values,
            input_shape,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(input_indices: Edge<i64>, input_values: Edge<T>, input_shape: Edge<i64>) -> (Edge<i64>, Edge<T>) {
        Self {
            input_indices,
            phantom_T: PhantomData,
            input_values,
            input_shape,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<T> GraphOperation for SparseSliceGrad<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("SparseSliceGrad_{}")?
        };
        let mut new_op = graph.new_operation("SparseSliceGrad", &op_name)?;
        {
            new_op.add_edge(&self.backprop_val_grad)?
        }
        {
            new_op.add_edge(&self.input_indices)?
        }
        {
            new_op.add_edge(&self.input_start)?
        }
        {
            new_op.add_edge(&self.output_indices)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct SparseSliceGrad<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    backprop_val_grad: Edge<T>,
    input_indices: Edge<i64>,
    input_start: Edge<i64>,
    output_indices: Edge<i64>,
    op_name: Option<String>,
    id_: usize,
}

impl<T> SparseSliceGrad<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
{
    pub fn val_grad(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(backprop_val_grad: Edge<T>, input_indices: Edge<i64>, input_start: Edge<i64>, output_indices: Edge<i64>) -> Self {
        Self {
            phantom_T: PhantomData,
            backprop_val_grad,
            input_indices,
            input_start,
            output_indices,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(backprop_val_grad: Edge<T>, input_indices: Edge<i64>, input_start: Edge<i64>, output_indices: Edge<i64>) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            backprop_val_grad,
            input_indices,
            input_start,
            output_indices,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<T> GraphOperation for SparseSplit<T>
where T: TensorType,
      T: Clone,
      T: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("SparseSplit_{}")?
        };
        let mut new_op = graph.new_operation("SparseSplit", &op_name)?;
        {
            new_op.add_edge(&self.split_dim)?
        }
        {
            new_op.add_edge(&self.indices)?
        }
        {
            new_op.add_edge(&self.values)?
        }
        {
            new_op.add_edge(&self.shape)?
        }
        {
            (|attr: &i64| {new_op.set_attr_int("num_split", *attr)})(&self.num_split)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct SparseSplit<T>
where T: TensorType,
      T: Clone,
      T: 'static,
{
    split_dim: Edge<i64>,
    indices: Edge<i64>,
    phantom_T: PhantomData<T>,
    values: Edge<T>,
    shape: Edge<i64>,
    num_split: i64,
    op_name: Option<String>,
    id_: usize,
}

impl<T> SparseSplit<T>
where T: TensorType,
      T: Clone,
      T: 'static,
{
    pub fn output_indices(self) -> Edge<i64> {
        let rc = Rc::new(self);
        {
            Edge::<i64>::new(rc.clone(), 0)
        }
    }

    pub fn output_values(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 1)
        }
    }

    pub fn output_shape(self) -> Edge<i64> {
        let rc = Rc::new(self);
        {
            Edge::<i64>::new(rc.clone(), 2)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> (Edge<i64>, Edge<T>, Edge<i64>) {
        let rc = Rc::new(self);
        (
        {
            Edge::<i64>::new(rc.clone(), 0)
        },
        {
            Edge::<T>::new(rc.clone(), 1)
        },
        {
            Edge::<i64>::new(rc.clone(), 2)
        },
        )
    }

    pub fn build(split_dim: Edge<i64>, indices: Edge<i64>, values: Edge<T>, shape: Edge<i64>, num_split: i64) -> Self {
        Self {
            split_dim,
            indices,
            phantom_T: PhantomData,
            values,
            shape,
            num_split: num_split,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(split_dim: Edge<i64>, indices: Edge<i64>, values: Edge<T>, shape: Edge<i64>, num_split: i64) -> (Edge<i64>, Edge<T>, Edge<i64>) {
        Self {
            split_dim,
            indices,
            phantom_T: PhantomData,
            values,
            shape,
            num_split: num_split,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl GraphOperation for IRFFT {
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("IRFFT_{}")?
        };
        let mut new_op = graph.new_operation("IRFFT", &op_name)?;
        {
            new_op.add_edge(&self.input)?
        }
        {
            new_op.add_edge(&self.fft_length)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct IRFFT {
    input: Edge<OtherComplex<f32>>,
    fft_length: Edge<i32>,
    op_name: Option<String>,
    id_: usize,
}

impl IRFFT {
    pub fn output(self) -> Edge<f32> {
        let rc = Rc::new(self);
        {
            Edge::<f32>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<f32> {
        let rc = Rc::new(self);
        {
            Edge::<f32>::new(rc.clone(), 0)
        }
    }

    pub fn build(input: Edge<OtherComplex<f32>>, fft_length: Edge<i32>) -> Self {
        Self {
            input,
            fft_length,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(input: Edge<OtherComplex<f32>>, fft_length: Edge<i32>) -> Edge<f32> {
        Self {
            input,
            fft_length,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<T> GraphOperation for SparseConcat<T>
where T: TensorType,
      T: Clone,
      T: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("SparseConcat_{}")?
        };
        let mut new_op = graph.new_operation("SparseConcat", &op_name)?;
        {
            new_op.add_edge(&self.indices)?
        }
        {
            new_op.add_edge(&self.values)?
        }
        {
            new_op.add_edge(&self.shapes)?
        }
        {
            (|attr: &i64| {new_op.set_attr_int("concat_dim", *attr)})(&self.concat_dim)?
        }
        {
            (|attr: &i64| {new_op.set_attr_int("N", *attr)})(&self.N)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct SparseConcat<T>
where T: TensorType,
      T: Clone,
      T: 'static,
{
    indices: Edge<i64>,
    phantom_T: PhantomData<T>,
    values: Edge<T>,
    shapes: Edge<i64>,
    concat_dim: i64,
    N: i64,
    op_name: Option<String>,
    id_: usize,
}

impl<T> SparseConcat<T>
where T: TensorType,
      T: Clone,
      T: 'static,
{
    pub fn output_indices(self) -> Edge<i64> {
        let rc = Rc::new(self);
        {
            Edge::<i64>::new(rc.clone(), 0)
        }
    }

    pub fn output_values(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 1)
        }
    }

    pub fn output_shape(self) -> Edge<i64> {
        let rc = Rc::new(self);
        {
            Edge::<i64>::new(rc.clone(), 2)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> (Edge<i64>, Edge<T>, Edge<i64>) {
        let rc = Rc::new(self);
        (
        {
            Edge::<i64>::new(rc.clone(), 0)
        },
        {
            Edge::<T>::new(rc.clone(), 1)
        },
        {
            Edge::<i64>::new(rc.clone(), 2)
        },
        )
    }

    pub fn build(indices: Edge<i64>, values: Edge<T>, shapes: Edge<i64>, concat_dim: i64, N: i64) -> Self {
        Self {
            indices,
            phantom_T: PhantomData,
            values,
            shapes,
            concat_dim: concat_dim,
            N: N,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(indices: Edge<i64>, values: Edge<T>, shapes: Edge<i64>, concat_dim: i64, N: i64) -> (Edge<i64>, Edge<T>, Edge<i64>) {
        Self {
            indices,
            phantom_T: PhantomData,
            values,
            shapes,
            concat_dim: concat_dim,
            N: N,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<Tindices, T> GraphOperation for SparseToDense<Tindices, T>
where Tindices: TensorType,
      Tindices: Clone,
      T: TensorType,
      T: Clone,
      T: 'static,
      Tindices: con_or_DT_INT32_or_DT_INT64,
      Tindices: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("SparseToDense_{}")?
        };
        let mut new_op = graph.new_operation("SparseToDense", &op_name)?;
        {
            new_op.add_edge(&self.sparse_indices)?
        }
        {
            new_op.add_edge(&self.output_shape)?
        }
        {
            new_op.add_edge(&self.sparse_values)?
        }
        {
            new_op.add_edge(&self.default_value)?
        }
        {
            match self.validate_indices {
                None => new_op.set_attr_value_proto("validate_indices", &vec![40_u8, 1_u8,])?,
                Some(ref value) => (|attr: &bool| {new_op.set_attr_bool("validate_indices", *attr)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct SparseToDense<Tindices, T>
where Tindices: TensorType,
      Tindices: Clone,
      T: TensorType,
      T: Clone,
      T: 'static,
      Tindices: con_or_DT_INT32_or_DT_INT64,
      Tindices: 'static,
{
    phantom_Tindices: PhantomData<Tindices>,
    sparse_indices: Edge<Tindices>,
    output_shape: Edge<Tindices>,
    phantom_T: PhantomData<T>,
    sparse_values: Edge<T>,
    default_value: Edge<T>,
    validate_indices: Option<bool>,
    op_name: Option<String>,
    id_: usize,
}

impl<Tindices, T> SparseToDense<Tindices, T>
where Tindices: TensorType,
      Tindices: Clone,
      T: TensorType,
      T: Clone,
      T: 'static,
      Tindices: con_or_DT_INT32_or_DT_INT64,
      Tindices: 'static,
{
    pub fn dense(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn validate_indices(&mut self, validate_indices: bool) -> Self {
        self.validate_indices = Some(validate_indices);
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(sparse_indices: Edge<Tindices>, output_shape: Edge<Tindices>, sparse_values: Edge<T>, default_value: Edge<T>) -> Self {
        Self {
            phantom_Tindices: PhantomData,
            sparse_indices,
            output_shape,
            phantom_T: PhantomData,
            sparse_values,
            default_value,
            validate_indices: None,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(sparse_indices: Edge<Tindices>, output_shape: Edge<Tindices>, sparse_values: Edge<T>, default_value: Edge<T>) -> Edge<T> {
        Self {
            phantom_Tindices: PhantomData,
            sparse_indices,
            output_shape,
            phantom_T: PhantomData,
            sparse_values,
            default_value,
            validate_indices: None,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<dtype> GraphOperation for DeserializeManySparse<dtype>
where dtype: TensorType,
      dtype: 'static,
      dtype: Clone,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("DeserializeManySparse_{}")?
        };
        let mut new_op = graph.new_operation("DeserializeManySparse", &op_name)?;
        {
            new_op.add_edge(&self.serialized_sparse)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct DeserializeManySparse<dtype>
where dtype: TensorType,
      dtype: 'static,
      dtype: Clone,
{
    serialized_sparse: Edge<String>,
    phantom_dtype: PhantomData<dtype>,
    op_name: Option<String>,
    id_: usize,
}

impl<dtype> DeserializeManySparse<dtype>
where dtype: TensorType,
      dtype: 'static,
      dtype: Clone,
{
    pub fn sparse_indices(self) -> Edge<i64> {
        let rc = Rc::new(self);
        {
            Edge::<i64>::new(rc.clone(), 0)
        }
    }

    pub fn sparse_values(self) -> Edge<dtype> {
        let rc = Rc::new(self);
        {
            Edge::<dtype>::new(rc.clone(), 1)
        }
    }

    pub fn sparse_shape(self) -> Edge<i64> {
        let rc = Rc::new(self);
        {
            Edge::<i64>::new(rc.clone(), 2)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> (Edge<i64>, Edge<dtype>, Edge<i64>) {
        let rc = Rc::new(self);
        (
        {
            Edge::<i64>::new(rc.clone(), 0)
        },
        {
            Edge::<dtype>::new(rc.clone(), 1)
        },
        {
            Edge::<i64>::new(rc.clone(), 2)
        },
        )
    }

    pub fn build(serialized_sparse: Edge<String>) -> Self {
        Self {
            serialized_sparse,
            phantom_dtype: PhantomData,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(serialized_sparse: Edge<String>) -> (Edge<i64>, Edge<dtype>, Edge<i64>) {
        Self {
            serialized_sparse,
            phantom_dtype: PhantomData,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

pub trait con_or_DT_STRING_or_DT_VARIANT {
}

impl con_or_DT_STRING_or_DT_VARIANT for String {
}

impl<Tserialized, dtype> GraphOperation for DeserializeSparse<Tserialized, dtype>
where Tserialized: TensorType,
      Tserialized: Clone,
      dtype: TensorType,
      dtype: 'static,
      dtype: Clone,
      Tserialized: con_or_DT_STRING_or_DT_VARIANT,
      Tserialized: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("DeserializeSparse_{}")?
        };
        let mut new_op = graph.new_operation("DeserializeSparse", &op_name)?;
        {
            new_op.add_edge(&self.serialized_sparse)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct DeserializeSparse<Tserialized, dtype>
where Tserialized: TensorType,
      Tserialized: Clone,
      dtype: TensorType,
      dtype: 'static,
      dtype: Clone,
      Tserialized: con_or_DT_STRING_or_DT_VARIANT,
      Tserialized: 'static,
{
    phantom_Tserialized: PhantomData<Tserialized>,
    serialized_sparse: Edge<Tserialized>,
    phantom_dtype: PhantomData<dtype>,
    op_name: Option<String>,
    id_: usize,
}

impl<Tserialized, dtype> DeserializeSparse<Tserialized, dtype>
where Tserialized: TensorType,
      Tserialized: Clone,
      dtype: TensorType,
      dtype: 'static,
      dtype: Clone,
      Tserialized: con_or_DT_STRING_or_DT_VARIANT,
      Tserialized: 'static,
{
    pub fn sparse_indices(self) -> Edge<i64> {
        let rc = Rc::new(self);
        {
            Edge::<i64>::new(rc.clone(), 0)
        }
    }

    pub fn sparse_values(self) -> Edge<dtype> {
        let rc = Rc::new(self);
        {
            Edge::<dtype>::new(rc.clone(), 1)
        }
    }

    pub fn sparse_shape(self) -> Edge<i64> {
        let rc = Rc::new(self);
        {
            Edge::<i64>::new(rc.clone(), 2)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> (Edge<i64>, Edge<dtype>, Edge<i64>) {
        let rc = Rc::new(self);
        (
        {
            Edge::<i64>::new(rc.clone(), 0)
        },
        {
            Edge::<dtype>::new(rc.clone(), 1)
        },
        {
            Edge::<i64>::new(rc.clone(), 2)
        },
        )
    }

    pub fn build(serialized_sparse: Edge<Tserialized>) -> Self {
        Self {
            phantom_Tserialized: PhantomData,
            serialized_sparse,
            phantom_dtype: PhantomData,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(serialized_sparse: Edge<Tserialized>) -> (Edge<i64>, Edge<dtype>, Edge<i64>) {
        Self {
            phantom_Tserialized: PhantomData,
            serialized_sparse,
            phantom_dtype: PhantomData,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<T, out_type> GraphOperation for SerializeManySparse<T, out_type>
where T: TensorType,
      T: Clone,
      out_type: TensorType,
      T: 'static,
      out_type: con_or_DT_STRING_or_DT_VARIANT,
      out_type: 'static,
      out_type: Clone,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("SerializeManySparse_{}")?
        };
        let mut new_op = graph.new_operation("SerializeManySparse", &op_name)?;
        {
            new_op.add_edge(&self.sparse_indices)?
        }
        {
            new_op.add_edge(&self.sparse_values)?
        }
        {
            new_op.add_edge(&self.sparse_shape)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct SerializeManySparse<T, out_type>
where T: TensorType,
      T: Clone,
      out_type: TensorType,
      T: 'static,
      out_type: con_or_DT_STRING_or_DT_VARIANT,
      out_type: 'static,
      out_type: Clone,
{
    sparse_indices: Edge<i64>,
    phantom_T: PhantomData<T>,
    sparse_values: Edge<T>,
    sparse_shape: Edge<i64>,
    phantom_out_type: PhantomData<out_type>,
    op_name: Option<String>,
    id_: usize,
}

impl<T, out_type> SerializeManySparse<T, out_type>
where T: TensorType,
      T: Clone,
      out_type: TensorType,
      T: 'static,
      out_type: con_or_DT_STRING_or_DT_VARIANT,
      out_type: 'static,
      out_type: Clone,
{
    pub fn serialized_sparse(self) -> Edge<out_type> {
        let rc = Rc::new(self);
        {
            Edge::<out_type>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<out_type> {
        let rc = Rc::new(self);
        {
            Edge::<out_type>::new(rc.clone(), 0)
        }
    }

    pub fn build(sparse_indices: Edge<i64>, sparse_values: Edge<T>, sparse_shape: Edge<i64>) -> Self {
        Self {
            sparse_indices,
            phantom_T: PhantomData,
            sparse_values,
            sparse_shape,
            phantom_out_type: PhantomData,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(sparse_indices: Edge<i64>, sparse_values: Edge<T>, sparse_shape: Edge<i64>) -> Edge<out_type> {
        Self {
            sparse_indices,
            phantom_T: PhantomData,
            sparse_values,
            sparse_shape,
            phantom_out_type: PhantomData,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<Tindices, T> GraphOperation for SparseTensorDenseMatMul<Tindices, T>
where Tindices: TensorType,
      Tindices: Clone,
      T: TensorType,
      T: Clone,
      T: 'static,
      Tindices: con_or_DT_INT32_or_DT_INT64,
      Tindices: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("SparseTensorDenseMatMul_{}")?
        };
        let mut new_op = graph.new_operation("SparseTensorDenseMatMul", &op_name)?;
        {
            new_op.add_edge(&self.a_indices)?
        }
        {
            new_op.add_edge(&self.a_values)?
        }
        {
            new_op.add_edge(&self.a_shape)?
        }
        {
            new_op.add_edge(&self.b)?
        }
        {
            match self.adjoint_a {
                None => new_op.set_attr_value_proto("adjoint_a", &vec![40_u8, 0_u8,])?,
                Some(ref value) => (|attr: &bool| {new_op.set_attr_bool("adjoint_a", *attr)})(&value)?,
            };
        }
        {
            match self.adjoint_b {
                None => new_op.set_attr_value_proto("adjoint_b", &vec![40_u8, 0_u8,])?,
                Some(ref value) => (|attr: &bool| {new_op.set_attr_bool("adjoint_b", *attr)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct SparseTensorDenseMatMul<Tindices, T>
where Tindices: TensorType,
      Tindices: Clone,
      T: TensorType,
      T: Clone,
      T: 'static,
      Tindices: con_or_DT_INT32_or_DT_INT64,
      Tindices: 'static,
{
    phantom_Tindices: PhantomData<Tindices>,
    a_indices: Edge<Tindices>,
    phantom_T: PhantomData<T>,
    a_values: Edge<T>,
    a_shape: Edge<i64>,
    b: Edge<T>,
    adjoint_a: Option<bool>,
    adjoint_b: Option<bool>,
    op_name: Option<String>,
    id_: usize,
}

impl<Tindices, T> SparseTensorDenseMatMul<Tindices, T>
where Tindices: TensorType,
      Tindices: Clone,
      T: TensorType,
      T: Clone,
      T: 'static,
      Tindices: con_or_DT_INT32_or_DT_INT64,
      Tindices: 'static,
{
    pub fn product(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn adjoint_a(&mut self, adjoint_a: bool) -> Self {
        self.adjoint_a = Some(adjoint_a);
        self.clone()
    }

    pub fn adjoint_b(&mut self, adjoint_b: bool) -> Self {
        self.adjoint_b = Some(adjoint_b);
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(a_indices: Edge<Tindices>, a_values: Edge<T>, a_shape: Edge<i64>, b: Edge<T>) -> Self {
        Self {
            phantom_Tindices: PhantomData,
            a_indices,
            phantom_T: PhantomData,
            a_values,
            a_shape,
            b,
            adjoint_a: None,
            adjoint_b: None,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(a_indices: Edge<Tindices>, a_values: Edge<T>, a_shape: Edge<i64>, b: Edge<T>) -> Edge<T> {
        Self {
            phantom_Tindices: PhantomData,
            a_indices,
            phantom_T: PhantomData,
            a_values,
            a_shape,
            b,
            adjoint_a: None,
            adjoint_b: None,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<T, Treal> GraphOperation for SparseAdd<T, Treal>
where T: TensorType,
      T: Clone,
      Treal: TensorType,
      Treal: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
      Treal: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      Treal: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("SparseAdd_{}")?
        };
        let mut new_op = graph.new_operation("SparseAdd", &op_name)?;
        {
            new_op.add_edge(&self.a_indices)?
        }
        {
            new_op.add_edge(&self.a_values)?
        }
        {
            new_op.add_edge(&self.a_shape)?
        }
        {
            new_op.add_edge(&self.b_indices)?
        }
        {
            new_op.add_edge(&self.b_values)?
        }
        {
            new_op.add_edge(&self.b_shape)?
        }
        {
            new_op.add_edge(&self.thresh)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct SparseAdd<T, Treal>
where T: TensorType,
      T: Clone,
      Treal: TensorType,
      Treal: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
      Treal: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      Treal: 'static,
{
    a_indices: Edge<i64>,
    phantom_T: PhantomData<T>,
    a_values: Edge<T>,
    a_shape: Edge<i64>,
    b_indices: Edge<i64>,
    b_values: Edge<T>,
    b_shape: Edge<i64>,
    phantom_Treal: PhantomData<Treal>,
    thresh: Edge<Treal>,
    op_name: Option<String>,
    id_: usize,
}

impl<T, Treal> SparseAdd<T, Treal>
where T: TensorType,
      T: Clone,
      Treal: TensorType,
      Treal: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
      Treal: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      Treal: 'static,
{
    pub fn sum_indices(self) -> Edge<i64> {
        let rc = Rc::new(self);
        {
            Edge::<i64>::new(rc.clone(), 0)
        }
    }

    pub fn sum_values(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 1)
        }
    }

    pub fn sum_shape(self) -> Edge<i64> {
        let rc = Rc::new(self);
        {
            Edge::<i64>::new(rc.clone(), 2)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> (Edge<i64>, Edge<T>, Edge<i64>) {
        let rc = Rc::new(self);
        (
        {
            Edge::<i64>::new(rc.clone(), 0)
        },
        {
            Edge::<T>::new(rc.clone(), 1)
        },
        {
            Edge::<i64>::new(rc.clone(), 2)
        },
        )
    }

    pub fn build(a_indices: Edge<i64>, a_values: Edge<T>, a_shape: Edge<i64>, b_indices: Edge<i64>, b_values: Edge<T>, b_shape: Edge<i64>, thresh: Edge<Treal>) -> Self {
        Self {
            a_indices,
            phantom_T: PhantomData,
            a_values,
            a_shape,
            b_indices,
            b_values,
            b_shape,
            phantom_Treal: PhantomData,
            thresh,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(a_indices: Edge<i64>, a_values: Edge<T>, a_shape: Edge<i64>, b_indices: Edge<i64>, b_values: Edge<T>, b_shape: Edge<i64>, thresh: Edge<Treal>) -> (Edge<i64>, Edge<T>, Edge<i64>) {
        Self {
            a_indices,
            phantom_T: PhantomData,
            a_values,
            a_shape,
            b_indices,
            b_values,
            b_shape,
            phantom_Treal: PhantomData,
            thresh,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<T> GraphOperation for SparseAddGrad<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("SparseAddGrad_{}")?
        };
        let mut new_op = graph.new_operation("SparseAddGrad", &op_name)?;
        {
            new_op.add_edge(&self.backprop_val_grad)?
        }
        {
            new_op.add_edge(&self.a_indices)?
        }
        {
            new_op.add_edge(&self.b_indices)?
        }
        {
            new_op.add_edge(&self.sum_indices)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct SparseAddGrad<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    backprop_val_grad: Edge<T>,
    a_indices: Edge<i64>,
    b_indices: Edge<i64>,
    sum_indices: Edge<i64>,
    op_name: Option<String>,
    id_: usize,
}

impl<T> SparseAddGrad<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
{
    pub fn a_val_grad(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn b_val_grad(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 1)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> (Edge<T>, Edge<T>) {
        let rc = Rc::new(self);
        (
        {
            Edge::<T>::new(rc.clone(), 0)
        },
        {
            Edge::<T>::new(rc.clone(), 1)
        },
        )
    }

    pub fn build(backprop_val_grad: Edge<T>, a_indices: Edge<i64>, b_indices: Edge<i64>, sum_indices: Edge<i64>) -> Self {
        Self {
            phantom_T: PhantomData,
            backprop_val_grad,
            a_indices,
            b_indices,
            sum_indices,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(backprop_val_grad: Edge<T>, a_indices: Edge<i64>, b_indices: Edge<i64>, sum_indices: Edge<i64>) -> (Edge<T>, Edge<T>) {
        Self {
            phantom_T: PhantomData,
            backprop_val_grad,
            a_indices,
            b_indices,
            sum_indices,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

pub trait con_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_STRING_or_DT_INT64_or_DT_UINT16 {
}

impl con_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_STRING_or_DT_INT64_or_DT_UINT16 for String {
}

impl con_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_STRING_or_DT_INT64_or_DT_UINT16 for i16 {
}

impl con_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_STRING_or_DT_INT64_or_DT_UINT16 for i32 {
}

impl con_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_STRING_or_DT_INT64_or_DT_UINT16 for i64 {
}

impl con_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_STRING_or_DT_INT64_or_DT_UINT16 for i8 {
}

impl con_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_STRING_or_DT_INT64_or_DT_UINT16 for u16 {
}

impl con_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_STRING_or_DT_INT64_or_DT_UINT16 for u8 {
}

impl<T> GraphOperation for SparseToSparseSetOperation<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_STRING_or_DT_INT64_or_DT_UINT16,
      T: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("SparseToSparseSetOperation_{}")?
        };
        let mut new_op = graph.new_operation("SparseToSparseSetOperation", &op_name)?;
        {
            new_op.add_edge(&self.set1_indices)?
        }
        {
            new_op.add_edge(&self.set1_values)?
        }
        {
            new_op.add_edge(&self.set1_shape)?
        }
        {
            new_op.add_edge(&self.set2_indices)?
        }
        {
            new_op.add_edge(&self.set2_values)?
        }
        {
            new_op.add_edge(&self.set2_shape)?
        }
        {
            (|attr| {new_op.set_attr_string("set_operation", attr)})(&self.set_operation)?
        }
        {
            match self.validate_indices {
                None => new_op.set_attr_value_proto("validate_indices", &vec![40_u8, 1_u8,])?,
                Some(ref value) => (|attr: &bool| {new_op.set_attr_bool("validate_indices", *attr)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct SparseToSparseSetOperation<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_STRING_or_DT_INT64_or_DT_UINT16,
      T: 'static,
{
    set1_indices: Edge<i64>,
    phantom_T: PhantomData<T>,
    set1_values: Edge<T>,
    set1_shape: Edge<i64>,
    set2_indices: Edge<i64>,
    set2_values: Edge<T>,
    set2_shape: Edge<i64>,
    set_operation: String,
    validate_indices: Option<bool>,
    op_name: Option<String>,
    id_: usize,
}

impl<T> SparseToSparseSetOperation<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_STRING_or_DT_INT64_or_DT_UINT16,
      T: 'static,
{
    pub fn result_indices(self) -> Edge<i64> {
        let rc = Rc::new(self);
        {
            Edge::<i64>::new(rc.clone(), 0)
        }
    }

    pub fn result_values(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 1)
        }
    }

    pub fn result_shape(self) -> Edge<i64> {
        let rc = Rc::new(self);
        {
            Edge::<i64>::new(rc.clone(), 2)
        }
    }

    pub fn validate_indices(&mut self, validate_indices: bool) -> Self {
        self.validate_indices = Some(validate_indices);
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> (Edge<i64>, Edge<T>, Edge<i64>) {
        let rc = Rc::new(self);
        (
        {
            Edge::<i64>::new(rc.clone(), 0)
        },
        {
            Edge::<T>::new(rc.clone(), 1)
        },
        {
            Edge::<i64>::new(rc.clone(), 2)
        },
        )
    }

    pub fn build(set1_indices: Edge<i64>, set1_values: Edge<T>, set1_shape: Edge<i64>, set2_indices: Edge<i64>, set2_values: Edge<T>, set2_shape: Edge<i64>, set_operation: &str) -> Self {
        Self {
            set1_indices,
            phantom_T: PhantomData,
            set1_values,
            set1_shape,
            set2_indices,
            set2_values,
            set2_shape,
            set_operation: set_operation.to_string(),
            validate_indices: None,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(set1_indices: Edge<i64>, set1_values: Edge<T>, set1_shape: Edge<i64>, set2_indices: Edge<i64>, set2_values: Edge<T>, set2_shape: Edge<i64>, set_operation: &str) -> (Edge<i64>, Edge<T>, Edge<i64>) {
        Self {
            set1_indices,
            phantom_T: PhantomData,
            set1_values,
            set1_shape,
            set2_indices,
            set2_values,
            set2_shape,
            set_operation: set_operation.to_string(),
            validate_indices: None,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<tensor_type> GraphOperation for _HostRecv<tensor_type>
where tensor_type: TensorType,
      tensor_type: 'static,
      tensor_type: Clone,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("_HostRecv_{}")?
        };
        let mut new_op = graph.new_operation("_HostRecv", &op_name)?;
        {
            (|attr| {new_op.set_attr_string("tensor_name", attr)})(&self.tensor_name)?
        }
        {
            (|attr| {new_op.set_attr_string("send_device", attr)})(&self.send_device)?
        }
        {
            (|attr: &i64| {new_op.set_attr_int("send_device_incarnation", *attr)})(&self.send_device_incarnation)?
        }
        {
            (|attr| {new_op.set_attr_string("recv_device", attr)})(&self.recv_device)?
        }
        {
            match self.client_terminated {
                None => new_op.set_attr_value_proto("client_terminated", &vec![40_u8, 0_u8,])?,
                Some(ref value) => (|attr: &bool| {new_op.set_attr_bool("client_terminated", *attr)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct _HostRecv<tensor_type>
where tensor_type: TensorType,
      tensor_type: 'static,
      tensor_type: Clone,
{
    phantom_tensor_type: PhantomData<tensor_type>,
    tensor_name: String,
    send_device: String,
    send_device_incarnation: i64,
    recv_device: String,
    client_terminated: Option<bool>,
    op_name: Option<String>,
    id_: usize,
}

impl<tensor_type> _HostRecv<tensor_type>
where tensor_type: TensorType,
      tensor_type: 'static,
      tensor_type: Clone,
{
    pub fn tensor(self) -> Edge<tensor_type> {
        let rc = Rc::new(self);
        {
            Edge::<tensor_type>::new(rc.clone(), 0)
        }
    }

    pub fn client_terminated(&mut self, client_terminated: bool) -> Self {
        self.client_terminated = Some(client_terminated);
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<tensor_type> {
        let rc = Rc::new(self);
        {
            Edge::<tensor_type>::new(rc.clone(), 0)
        }
    }

    pub fn build(tensor_name: &str, send_device: &str, send_device_incarnation: i64, recv_device: &str) -> Self {
        Self {
            phantom_tensor_type: PhantomData,
            tensor_name: tensor_name.to_string(),
            send_device: send_device.to_string(),
            send_device_incarnation: send_device_incarnation,
            recv_device: recv_device.to_string(),
            client_terminated: None,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(tensor_name: &str, send_device: &str, send_device_incarnation: i64, recv_device: &str) -> Edge<tensor_type> {
        Self {
            phantom_tensor_type: PhantomData,
            tensor_name: tensor_name.to_string(),
            send_device: send_device.to_string(),
            send_device_incarnation: send_device_incarnation,
            recv_device: recv_device.to_string(),
            client_terminated: None,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<T> GraphOperation for _HostSend<T>
where T: TensorType,
      T: Clone,
      T: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("_HostSend_{}")?
        };
        let mut new_op = graph.new_operation("_HostSend", &op_name)?;
        {
            new_op.add_edge(&self.tensor)?
        }
        {
            (|attr| {new_op.set_attr_string("tensor_name", attr)})(&self.tensor_name)?
        }
        {
            (|attr| {new_op.set_attr_string("send_device", attr)})(&self.send_device)?
        }
        {
            (|attr: &i64| {new_op.set_attr_int("send_device_incarnation", *attr)})(&self.send_device_incarnation)?
        }
        {
            (|attr| {new_op.set_attr_string("recv_device", attr)})(&self.recv_device)?
        }
        {
            match self.client_terminated {
                None => new_op.set_attr_value_proto("client_terminated", &vec![40_u8, 0_u8,])?,
                Some(ref value) => (|attr: &bool| {new_op.set_attr_bool("client_terminated", *attr)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct _HostSend<T>
where T: TensorType,
      T: Clone,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    tensor: Edge<T>,
    tensor_name: String,
    send_device: String,
    send_device_incarnation: i64,
    recv_device: String,
    client_terminated: Option<bool>,
    op_name: Option<String>,
    id_: usize,
}

impl<T> _HostSend<T>
where T: TensorType,
      T: Clone,
      T: 'static,
{
    pub fn client_terminated(&mut self, client_terminated: bool) -> Self {
        self.client_terminated = Some(client_terminated);
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> () {
        let rc = Rc::new(self);
        (
        )
    }

    pub fn build(tensor: Edge<T>, tensor_name: &str, send_device: &str, send_device_incarnation: i64, recv_device: &str) -> Self {
        Self {
            phantom_T: PhantomData,
            tensor,
            tensor_name: tensor_name.to_string(),
            send_device: send_device.to_string(),
            send_device_incarnation: send_device_incarnation,
            recv_device: recv_device.to_string(),
            client_terminated: None,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(tensor: Edge<T>, tensor_name: &str, send_device: &str, send_device_incarnation: i64, recv_device: &str) -> () {
        Self {
            phantom_T: PhantomData,
            tensor,
            tensor_name: tensor_name.to_string(),
            send_device: send_device.to_string(),
            send_device_incarnation: send_device_incarnation,
            recv_device: recv_device.to_string(),
            client_terminated: None,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<T> GraphOperation for _ScopedAllocatorSplit<T>
where T: TensorType,
      T: Clone,
      T: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("_ScopedAllocatorSplit_{}")?
        };
        let mut new_op = graph.new_operation("_ScopedAllocatorSplit", &op_name)?;
        {
            new_op.add_edge(&self.concat)?
        }
        {
            new_op.add_edge(&self.split)?
        }
        {
            (|attr| {new_op.set_attr_string("sa_name", attr)})(&self.sa_name)?
        }
        {
            (|attr: &i64| {new_op.set_attr_int("id", *attr)})(&self.id)?
        }
        {
            (|attr: &i64| {new_op.set_attr_int("N", *attr)})(&self.N)?
        }
        {
            (|attrs| {new_op.set_attr_shape_list("shapes", attrs)})(&self.shapes)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct _ScopedAllocatorSplit<T>
where T: TensorType,
      T: Clone,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    concat: Edge<T>,
    split: Edge<T>,
    sa_name: String,
    id: i64,
    N: i64,
    shapes: Vec<OtherShape>,
    op_name: Option<String>,
    id_: usize,
}

impl<T> _ScopedAllocatorSplit<T>
where T: TensorType,
      T: Clone,
      T: 'static,
{
    pub fn output(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(concat: Edge<T>, split: Edge<T>, sa_name: &str, id: i64, N: i64, shapes: &[OtherShape]) -> Self {
        Self {
            phantom_T: PhantomData,
            concat,
            split,
            sa_name: sa_name.to_string(),
            id: id,
            N: N,
            shapes: shapes.to_vec(),
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(concat: Edge<T>, split: Edge<T>, sa_name: &str, id: i64, N: i64, shapes: &[OtherShape]) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            concat,
            split,
            sa_name: sa_name.to_string(),
            id: id,
            N: N,
            shapes: shapes.to_vec(),
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<T> GraphOperation for _ScopedAllocatorConcat<T>
where T: TensorType,
      T: Clone,
      T: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("_ScopedAllocatorConcat_{}")?
        };
        let mut new_op = graph.new_operation("_ScopedAllocatorConcat", &op_name)?;
        {
            new_op.add_edge(&self.backing)?
        }
        {
            new_op.add_edge(&self.inputs)?
        }
        {
            (|attr| {new_op.set_attr_shape("shape", attr)})(&self.shape)?
        }
        {
            match self.reshape {
                None => new_op.set_attr_value_proto("reshape", &vec![40_u8, 0_u8,])?,
                Some(ref value) => (|attr: &bool| {new_op.set_attr_bool("reshape", *attr)})(&value)?,
            };
        }
        {
            (|attr| {new_op.set_attr_string("sa_name", attr)})(&self.sa_name)?
        }
        {
            (|attr: &i64| {new_op.set_attr_int("id", *attr)})(&self.id)?
        }
        {
            (|attr: &i64| {new_op.set_attr_int("N", *attr)})(&self.N)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct _ScopedAllocatorConcat<T>
where T: TensorType,
      T: Clone,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    backing: Edge<T>,
    inputs: Edge<T>,
    shape: OtherShape,
    reshape: Option<bool>,
    sa_name: String,
    id: i64,
    N: i64,
    op_name: Option<String>,
    id_: usize,
}

impl<T> _ScopedAllocatorConcat<T>
where T: TensorType,
      T: Clone,
      T: 'static,
{
    pub fn output(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn reshape(&mut self, reshape: bool) -> Self {
        self.reshape = Some(reshape);
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(backing: Edge<T>, inputs: Edge<T>, shape: &OtherShape, sa_name: &str, id: i64, N: i64) -> Self {
        Self {
            phantom_T: PhantomData,
            backing,
            inputs,
            shape: shape.clone(),
            reshape: None,
            sa_name: sa_name.to_string(),
            id: id,
            N: N,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(backing: Edge<T>, inputs: Edge<T>, shape: &OtherShape, sa_name: &str, id: i64, N: i64) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            backing,
            inputs,
            shape: shape.clone(),
            reshape: None,
            sa_name: sa_name.to_string(),
            id: id,
            N: N,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<T> GraphOperation for Assign<T>
where T: TensorType,
      T: Clone,
      T: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("Assign_{}")?
        };
        let mut new_op = graph.new_operation("Assign", &op_name)?;
        {
            new_op.add_edge(&self.ref_)?
        }
        {
            new_op.add_edge(&self.value)?
        }
        {
            match self.validate_shape {
                None => new_op.set_attr_value_proto("validate_shape", &vec![40_u8, 1_u8,])?,
                Some(ref value) => (|attr: &bool| {new_op.set_attr_bool("validate_shape", *attr)})(&value)?,
            };
        }
        {
            match self.use_locking {
                None => new_op.set_attr_value_proto("use_locking", &vec![40_u8, 1_u8,])?,
                Some(ref value) => (|attr: &bool| {new_op.set_attr_bool("use_locking", *attr)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct Assign<T>
where T: TensorType,
      T: Clone,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    ref_: Edge<T>,
    value: Edge<T>,
    validate_shape: Option<bool>,
    use_locking: Option<bool>,
    op_name: Option<String>,
    id_: usize,
}

impl<T> Assign<T>
where T: TensorType,
      T: Clone,
      T: 'static,
{
    pub fn output_ref(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn validate_shape(&mut self, validate_shape: bool) -> Self {
        self.validate_shape = Some(validate_shape);
        self.clone()
    }

    pub fn use_locking(&mut self, use_locking: bool) -> Self {
        self.use_locking = Some(use_locking);
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(ref_: Edge<T>, value: Edge<T>) -> Self {
        Self {
            phantom_T: PhantomData,
            ref_,
            value,
            validate_shape: None,
            use_locking: None,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(ref_: Edge<T>, value: Edge<T>) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            ref_,
            value,
            validate_shape: None,
            use_locking: None,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<T> GraphOperation for RandomShuffle<T>
where T: TensorType,
      T: Clone,
      T: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("RandomShuffle_{}")?
        };
        let mut new_op = graph.new_operation("RandomShuffle", &op_name)?;
        {
            new_op.add_edge(&self.value)?
        }
        {
            match self.seed {
                None => new_op.set_attr_value_proto("seed", &vec![24_u8, 0_u8,])?,
                Some(ref value) => (|attr: &i64| {new_op.set_attr_int("seed", *attr)})(&value)?,
            };
        }
        {
            match self.seed2 {
                None => new_op.set_attr_value_proto("seed2", &vec![24_u8, 0_u8,])?,
                Some(ref value) => (|attr: &i64| {new_op.set_attr_int("seed2", *attr)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct RandomShuffle<T>
where T: TensorType,
      T: Clone,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    value: Edge<T>,
    seed: Option<i64>,
    seed2: Option<i64>,
    op_name: Option<String>,
    id_: usize,
}

impl<T> RandomShuffle<T>
where T: TensorType,
      T: Clone,
      T: 'static,
{
    pub fn output(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn seed(&mut self, seed: i64) -> Self {
        self.seed = Some(seed);
        self.clone()
    }

    pub fn seed2(&mut self, seed2: i64) -> Self {
        self.seed2 = Some(seed2);
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(value: Edge<T>) -> Self {
        Self {
            phantom_T: PhantomData,
            value,
            seed: None,
            seed2: None,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(value: Edge<T>) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            value,
            seed: None,
            seed2: None,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<T, dtype> GraphOperation for TruncatedNormal<T, dtype>
where T: TensorType,
      T: Clone,
      dtype: TensorType,
      dtype: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
      dtype: 'static,
      dtype: Clone,
      T: con_or_DT_INT32_or_DT_INT64,
      T: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("TruncatedNormal_{}")?
        };
        let mut new_op = graph.new_operation("TruncatedNormal", &op_name)?;
        {
            new_op.add_edge(&self.shape)?
        }
        {
            match self.seed {
                None => new_op.set_attr_value_proto("seed", &vec![24_u8, 0_u8,])?,
                Some(ref value) => (|attr: &i64| {new_op.set_attr_int("seed", *attr)})(&value)?,
            };
        }
        {
            match self.seed2 {
                None => new_op.set_attr_value_proto("seed2", &vec![24_u8, 0_u8,])?,
                Some(ref value) => (|attr: &i64| {new_op.set_attr_int("seed2", *attr)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct TruncatedNormal<T, dtype>
where T: TensorType,
      T: Clone,
      dtype: TensorType,
      dtype: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
      dtype: 'static,
      dtype: Clone,
      T: con_or_DT_INT32_or_DT_INT64,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    shape: Edge<T>,
    seed: Option<i64>,
    seed2: Option<i64>,
    phantom_dtype: PhantomData<dtype>,
    op_name: Option<String>,
    id_: usize,
}

impl<T, dtype> TruncatedNormal<T, dtype>
where T: TensorType,
      T: Clone,
      dtype: TensorType,
      dtype: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
      dtype: 'static,
      dtype: Clone,
      T: con_or_DT_INT32_or_DT_INT64,
      T: 'static,
{
    pub fn output(self) -> Edge<dtype> {
        let rc = Rc::new(self);
        {
            Edge::<dtype>::new(rc.clone(), 0)
        }
    }

    pub fn seed(&mut self, seed: i64) -> Self {
        self.seed = Some(seed);
        self.clone()
    }

    pub fn seed2(&mut self, seed2: i64) -> Self {
        self.seed2 = Some(seed2);
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<dtype> {
        let rc = Rc::new(self);
        {
            Edge::<dtype>::new(rc.clone(), 0)
        }
    }

    pub fn build(shape: Edge<T>) -> Self {
        Self {
            phantom_T: PhantomData,
            shape,
            seed: None,
            seed2: None,
            phantom_dtype: PhantomData,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(shape: Edge<T>) -> Edge<dtype> {
        Self {
            phantom_T: PhantomData,
            shape,
            seed: None,
            seed2: None,
            phantom_dtype: PhantomData,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<T, dtype> GraphOperation for RandomStandardNormal<T, dtype>
where T: TensorType,
      T: Clone,
      dtype: TensorType,
      dtype: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
      dtype: 'static,
      dtype: Clone,
      T: con_or_DT_INT32_or_DT_INT64,
      T: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("RandomStandardNormal_{}")?
        };
        let mut new_op = graph.new_operation("RandomStandardNormal", &op_name)?;
        {
            new_op.add_edge(&self.shape)?
        }
        {
            match self.seed {
                None => new_op.set_attr_value_proto("seed", &vec![24_u8, 0_u8,])?,
                Some(ref value) => (|attr: &i64| {new_op.set_attr_int("seed", *attr)})(&value)?,
            };
        }
        {
            match self.seed2 {
                None => new_op.set_attr_value_proto("seed2", &vec![24_u8, 0_u8,])?,
                Some(ref value) => (|attr: &i64| {new_op.set_attr_int("seed2", *attr)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct RandomStandardNormal<T, dtype>
where T: TensorType,
      T: Clone,
      dtype: TensorType,
      dtype: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
      dtype: 'static,
      dtype: Clone,
      T: con_or_DT_INT32_or_DT_INT64,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    shape: Edge<T>,
    seed: Option<i64>,
    seed2: Option<i64>,
    phantom_dtype: PhantomData<dtype>,
    op_name: Option<String>,
    id_: usize,
}

impl<T, dtype> RandomStandardNormal<T, dtype>
where T: TensorType,
      T: Clone,
      dtype: TensorType,
      dtype: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
      dtype: 'static,
      dtype: Clone,
      T: con_or_DT_INT32_or_DT_INT64,
      T: 'static,
{
    pub fn output(self) -> Edge<dtype> {
        let rc = Rc::new(self);
        {
            Edge::<dtype>::new(rc.clone(), 0)
        }
    }

    pub fn seed(&mut self, seed: i64) -> Self {
        self.seed = Some(seed);
        self.clone()
    }

    pub fn seed2(&mut self, seed2: i64) -> Self {
        self.seed2 = Some(seed2);
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<dtype> {
        let rc = Rc::new(self);
        {
            Edge::<dtype>::new(rc.clone(), 0)
        }
    }

    pub fn build(shape: Edge<T>) -> Self {
        Self {
            phantom_T: PhantomData,
            shape,
            seed: None,
            seed2: None,
            phantom_dtype: PhantomData,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(shape: Edge<T>) -> Edge<dtype> {
        Self {
            phantom_T: PhantomData,
            shape,
            seed: None,
            seed2: None,
            phantom_dtype: PhantomData,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<T, dtype> GraphOperation for RandomUniform<T, dtype>
where T: TensorType,
      T: Clone,
      dtype: TensorType,
      dtype: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
      dtype: 'static,
      dtype: Clone,
      T: con_or_DT_INT32_or_DT_INT64,
      T: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("RandomUniform_{}")?
        };
        let mut new_op = graph.new_operation("RandomUniform", &op_name)?;
        {
            new_op.add_edge(&self.shape)?
        }
        {
            match self.seed {
                None => new_op.set_attr_value_proto("seed", &vec![24_u8, 0_u8,])?,
                Some(ref value) => (|attr: &i64| {new_op.set_attr_int("seed", *attr)})(&value)?,
            };
        }
        {
            match self.seed2 {
                None => new_op.set_attr_value_proto("seed2", &vec![24_u8, 0_u8,])?,
                Some(ref value) => (|attr: &i64| {new_op.set_attr_int("seed2", *attr)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct RandomUniform<T, dtype>
where T: TensorType,
      T: Clone,
      dtype: TensorType,
      dtype: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
      dtype: 'static,
      dtype: Clone,
      T: con_or_DT_INT32_or_DT_INT64,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    shape: Edge<T>,
    seed: Option<i64>,
    seed2: Option<i64>,
    phantom_dtype: PhantomData<dtype>,
    op_name: Option<String>,
    id_: usize,
}

impl<T, dtype> RandomUniform<T, dtype>
where T: TensorType,
      T: Clone,
      dtype: TensorType,
      dtype: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
      dtype: 'static,
      dtype: Clone,
      T: con_or_DT_INT32_or_DT_INT64,
      T: 'static,
{
    pub fn output(self) -> Edge<dtype> {
        let rc = Rc::new(self);
        {
            Edge::<dtype>::new(rc.clone(), 0)
        }
    }

    pub fn seed(&mut self, seed: i64) -> Self {
        self.seed = Some(seed);
        self.clone()
    }

    pub fn seed2(&mut self, seed2: i64) -> Self {
        self.seed2 = Some(seed2);
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<dtype> {
        let rc = Rc::new(self);
        {
            Edge::<dtype>::new(rc.clone(), 0)
        }
    }

    pub fn build(shape: Edge<T>) -> Self {
        Self {
            phantom_T: PhantomData,
            shape,
            seed: None,
            seed2: None,
            phantom_dtype: PhantomData,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(shape: Edge<T>) -> Edge<dtype> {
        Self {
            phantom_T: PhantomData,
            shape,
            seed: None,
            seed2: None,
            phantom_dtype: PhantomData,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<T> GraphOperation for RaggedTensorToSparse<T>
where T: TensorType,
      T: Clone,
      T: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("RaggedTensorToSparse_{}")?
        };
        let mut new_op = graph.new_operation("RaggedTensorToSparse", &op_name)?;
        {
            new_op.add_edge(&self.rt_nested_splits)?
        }
        {
            new_op.add_edge(&self.rt_dense_values)?
        }
        {
            (|attr: &i64| {new_op.set_attr_int("RAGGED_RANK", *attr)})(&self.RAGGED_RANK)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct RaggedTensorToSparse<T>
where T: TensorType,
      T: Clone,
      T: 'static,
{
    rt_nested_splits: Edge<i64>,
    phantom_T: PhantomData<T>,
    rt_dense_values: Edge<T>,
    RAGGED_RANK: i64,
    op_name: Option<String>,
    id_: usize,
}

impl<T> RaggedTensorToSparse<T>
where T: TensorType,
      T: Clone,
      T: 'static,
{
    pub fn sparse_indices(self) -> Edge<i64> {
        let rc = Rc::new(self);
        {
            Edge::<i64>::new(rc.clone(), 0)
        }
    }

    pub fn sparse_values(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 1)
        }
    }

    pub fn sparse_dense_shape(self) -> Edge<i64> {
        let rc = Rc::new(self);
        {
            Edge::<i64>::new(rc.clone(), 2)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> (Edge<i64>, Edge<T>, Edge<i64>) {
        let rc = Rc::new(self);
        (
        {
            Edge::<i64>::new(rc.clone(), 0)
        },
        {
            Edge::<T>::new(rc.clone(), 1)
        },
        {
            Edge::<i64>::new(rc.clone(), 2)
        },
        )
    }

    pub fn build(rt_nested_splits: Edge<i64>, rt_dense_values: Edge<T>, RAGGED_RANK: i64) -> Self {
        Self {
            rt_nested_splits,
            phantom_T: PhantomData,
            rt_dense_values,
            RAGGED_RANK: RAGGED_RANK,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(rt_nested_splits: Edge<i64>, rt_dense_values: Edge<T>, RAGGED_RANK: i64) -> (Edge<i64>, Edge<T>, Edge<i64>) {
        Self {
            rt_nested_splits,
            phantom_T: PhantomData,
            rt_dense_values,
            RAGGED_RANK: RAGGED_RANK,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<Tvalues, Tindices> GraphOperation for RaggedGather<Tvalues, Tindices>
where Tvalues: TensorType,
      Tvalues: Clone,
      Tindices: TensorType,
      Tindices: Clone,
      Tvalues: 'static,
      Tindices: con_or_DT_INT32_or_DT_INT64,
      Tindices: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("RaggedGather_{}")?
        };
        let mut new_op = graph.new_operation("RaggedGather", &op_name)?;
        {
            new_op.add_edge(&self.params_nested_splits)?
        }
        {
            new_op.add_edge(&self.params_dense_values)?
        }
        {
            new_op.add_edge(&self.indices)?
        }
        {
            (|attr: &i64| {new_op.set_attr_int("PARAMS_RAGGED_RANK", *attr)})(&self.PARAMS_RAGGED_RANK)?
        }
        {
            (|attr: &i64| {new_op.set_attr_int("OUTPUT_RAGGED_RANK", *attr)})(&self.OUTPUT_RAGGED_RANK)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct RaggedGather<Tvalues, Tindices>
where Tvalues: TensorType,
      Tvalues: Clone,
      Tindices: TensorType,
      Tindices: Clone,
      Tvalues: 'static,
      Tindices: con_or_DT_INT32_or_DT_INT64,
      Tindices: 'static,
{
    params_nested_splits: Edge<i64>,
    phantom_Tvalues: PhantomData<Tvalues>,
    params_dense_values: Edge<Tvalues>,
    phantom_Tindices: PhantomData<Tindices>,
    indices: Edge<Tindices>,
    PARAMS_RAGGED_RANK: i64,
    OUTPUT_RAGGED_RANK: i64,
    op_name: Option<String>,
    id_: usize,
}

impl<Tvalues, Tindices> RaggedGather<Tvalues, Tindices>
where Tvalues: TensorType,
      Tvalues: Clone,
      Tindices: TensorType,
      Tindices: Clone,
      Tvalues: 'static,
      Tindices: con_or_DT_INT32_or_DT_INT64,
      Tindices: 'static,
{
    pub fn output_nested_splits(self) -> Edge<i64> {
        let rc = Rc::new(self);
        {
            Edge::<i64>::new(rc.clone(), 0)
        }
    }

    pub fn output_dense_values(self) -> Edge<Tvalues> {
        let rc = Rc::new(self);
        {
            Edge::<Tvalues>::new(rc.clone(), 1)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> (Edge<i64>, Edge<Tvalues>) {
        let rc = Rc::new(self);
        (
        {
            Edge::<i64>::new(rc.clone(), 0)
        },
        {
            Edge::<Tvalues>::new(rc.clone(), 1)
        },
        )
    }

    pub fn build(params_nested_splits: Edge<i64>, params_dense_values: Edge<Tvalues>, indices: Edge<Tindices>, PARAMS_RAGGED_RANK: i64, OUTPUT_RAGGED_RANK: i64) -> Self {
        Self {
            params_nested_splits,
            phantom_Tvalues: PhantomData,
            params_dense_values,
            phantom_Tindices: PhantomData,
            indices,
            PARAMS_RAGGED_RANK: PARAMS_RAGGED_RANK,
            OUTPUT_RAGGED_RANK: OUTPUT_RAGGED_RANK,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(params_nested_splits: Edge<i64>, params_dense_values: Edge<Tvalues>, indices: Edge<Tindices>, PARAMS_RAGGED_RANK: i64, OUTPUT_RAGGED_RANK: i64) -> (Edge<i64>, Edge<Tvalues>) {
        Self {
            params_nested_splits,
            phantom_Tvalues: PhantomData,
            params_dense_values,
            phantom_Tindices: PhantomData,
            indices,
            PARAMS_RAGGED_RANK: PARAMS_RAGGED_RANK,
            OUTPUT_RAGGED_RANK: OUTPUT_RAGGED_RANK,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

pub trait con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_INT64 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_INT64 for f32 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_INT64 for f64 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_INT64 for i32 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_INT64 for i64 {
}

impl<out_type> GraphOperation for StringToNumber<out_type>
where out_type: TensorType,
      out_type: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_INT64,
      out_type: 'static,
      out_type: Clone,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("StringToNumber_{}")?
        };
        let mut new_op = graph.new_operation("StringToNumber", &op_name)?;
        {
            new_op.add_edge(&self.string_tensor)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct StringToNumber<out_type>
where out_type: TensorType,
      out_type: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_INT64,
      out_type: 'static,
      out_type: Clone,
{
    string_tensor: Edge<String>,
    phantom_out_type: PhantomData<out_type>,
    op_name: Option<String>,
    id_: usize,
}

impl<out_type> StringToNumber<out_type>
where out_type: TensorType,
      out_type: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_INT64,
      out_type: 'static,
      out_type: Clone,
{
    pub fn output(self) -> Edge<out_type> {
        let rc = Rc::new(self);
        {
            Edge::<out_type>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<out_type> {
        let rc = Rc::new(self);
        {
            Edge::<out_type>::new(rc.clone(), 0)
        }
    }

    pub fn build(string_tensor: Edge<String>) -> Self {
        Self {
            string_tensor,
            phantom_out_type: PhantomData,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(string_tensor: Edge<String>) -> Edge<out_type> {
        Self {
            string_tensor,
            phantom_out_type: PhantomData,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl GraphOperation for DecodeJSONExample {
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("DecodeJSONExample_{}")?
        };
        let mut new_op = graph.new_operation("DecodeJSONExample", &op_name)?;
        {
            new_op.add_edge(&self.json_examples)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct DecodeJSONExample {
    json_examples: Edge<String>,
    op_name: Option<String>,
    id_: usize,
}

impl DecodeJSONExample {
    pub fn binary_examples(self) -> Edge<String> {
        let rc = Rc::new(self);
        {
            Edge::<String>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<String> {
        let rc = Rc::new(self);
        {
            Edge::<String>::new(rc.clone(), 0)
        }
    }

    pub fn build(json_examples: Edge<String>) -> Self {
        Self {
            json_examples,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(json_examples: Edge<String>) -> Edge<String> {
        Self {
            json_examples,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

pub trait con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_UINT16_or_DT_HALF {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_UINT16_or_DT_HALF for f32 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_UINT16_or_DT_HALF for f64 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_UINT16_or_DT_HALF for i16 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_UINT16_or_DT_HALF for i32 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_UINT16_or_DT_HALF for i64 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_UINT16_or_DT_HALF for i8 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_UINT16_or_DT_HALF for u16 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_UINT16_or_DT_HALF for u8 {
}

impl<out_type> GraphOperation for DecodeRaw<out_type>
where out_type: TensorType,
      out_type: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_UINT16_or_DT_HALF,
      out_type: 'static,
      out_type: Clone,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("DecodeRaw_{}")?
        };
        let mut new_op = graph.new_operation("DecodeRaw", &op_name)?;
        {
            new_op.add_edge(&self.bytes)?
        }
        {
            match self.little_endian {
                None => new_op.set_attr_value_proto("little_endian", &vec![40_u8, 1_u8,])?,
                Some(ref value) => (|attr: &bool| {new_op.set_attr_bool("little_endian", *attr)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct DecodeRaw<out_type>
where out_type: TensorType,
      out_type: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_UINT16_or_DT_HALF,
      out_type: 'static,
      out_type: Clone,
{
    bytes: Edge<String>,
    phantom_out_type: PhantomData<out_type>,
    little_endian: Option<bool>,
    op_name: Option<String>,
    id_: usize,
}

impl<out_type> DecodeRaw<out_type>
where out_type: TensorType,
      out_type: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_UINT16_or_DT_HALF,
      out_type: 'static,
      out_type: Clone,
{
    pub fn output(self) -> Edge<out_type> {
        let rc = Rc::new(self);
        {
            Edge::<out_type>::new(rc.clone(), 0)
        }
    }

    pub fn little_endian(&mut self, little_endian: bool) -> Self {
        self.little_endian = Some(little_endian);
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<out_type> {
        let rc = Rc::new(self);
        {
            Edge::<out_type>::new(rc.clone(), 0)
        }
    }

    pub fn build(bytes: Edge<String>) -> Self {
        Self {
            bytes,
            phantom_out_type: PhantomData,
            little_endian: None,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(bytes: Edge<String>) -> Edge<out_type> {
        Self {
            bytes,
            phantom_out_type: PhantomData,
            little_endian: None,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

pub trait con_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_QINT16_or_DT_QUINT16 {
}

impl con_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_QINT16_or_DT_QUINT16 for i16 {
}

impl con_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_QINT16_or_DT_QUINT16 for i32 {
}

impl con_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_QINT16_or_DT_QUINT16 for i8 {
}

impl con_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_QINT16_or_DT_QUINT16 for u16 {
}

impl con_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_QINT16_or_DT_QUINT16 for u8 {
}

impl<Tinput, out_type> GraphOperation for QuantizedBatchNormWithGlobalNormalization<Tinput, out_type>
where Tinput: TensorType,
      Tinput: Clone,
      out_type: TensorType,
      Tinput: con_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_QINT16_or_DT_QUINT16,
      Tinput: 'static,
      out_type: con_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_QINT16_or_DT_QUINT16,
      out_type: 'static,
      out_type: Clone,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("QuantizedBatchNormWithGlobalNormalization_{}")?
        };
        let mut new_op = graph.new_operation("QuantizedBatchNormWithGlobalNormalization", &op_name)?;
        {
            new_op.add_edge(&self.t)?
        }
        {
            new_op.add_edge(&self.t_min)?
        }
        {
            new_op.add_edge(&self.t_max)?
        }
        {
            new_op.add_edge(&self.m)?
        }
        {
            new_op.add_edge(&self.m_min)?
        }
        {
            new_op.add_edge(&self.m_max)?
        }
        {
            new_op.add_edge(&self.v)?
        }
        {
            new_op.add_edge(&self.v_min)?
        }
        {
            new_op.add_edge(&self.v_max)?
        }
        {
            new_op.add_edge(&self.beta)?
        }
        {
            new_op.add_edge(&self.beta_min)?
        }
        {
            new_op.add_edge(&self.beta_max)?
        }
        {
            new_op.add_edge(&self.gamma)?
        }
        {
            new_op.add_edge(&self.gamma_min)?
        }
        {
            new_op.add_edge(&self.gamma_max)?
        }
        {
            (|attr: &f32| {new_op.set_attr_float("variance_epsilon", *attr)})(&self.variance_epsilon)?
        }
        {
            (|attr: &bool| {new_op.set_attr_bool("scale_after_normalization", *attr)})(&self.scale_after_normalization)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct QuantizedBatchNormWithGlobalNormalization<Tinput, out_type>
where Tinput: TensorType,
      Tinput: Clone,
      out_type: TensorType,
      Tinput: con_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_QINT16_or_DT_QUINT16,
      Tinput: 'static,
      out_type: con_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_QINT16_or_DT_QUINT16,
      out_type: 'static,
      out_type: Clone,
{
    phantom_Tinput: PhantomData<Tinput>,
    t: Edge<Tinput>,
    t_min: Edge<f32>,
    t_max: Edge<f32>,
    m: Edge<Tinput>,
    m_min: Edge<f32>,
    m_max: Edge<f32>,
    v: Edge<Tinput>,
    v_min: Edge<f32>,
    v_max: Edge<f32>,
    beta: Edge<Tinput>,
    beta_min: Edge<f32>,
    beta_max: Edge<f32>,
    gamma: Edge<Tinput>,
    gamma_min: Edge<f32>,
    gamma_max: Edge<f32>,
    phantom_out_type: PhantomData<out_type>,
    variance_epsilon: f32,
    scale_after_normalization: bool,
    op_name: Option<String>,
    id_: usize,
}

impl<Tinput, out_type> QuantizedBatchNormWithGlobalNormalization<Tinput, out_type>
where Tinput: TensorType,
      Tinput: Clone,
      out_type: TensorType,
      Tinput: con_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_QINT16_or_DT_QUINT16,
      Tinput: 'static,
      out_type: con_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_QINT16_or_DT_QUINT16,
      out_type: 'static,
      out_type: Clone,
{
    pub fn result(self) -> Edge<out_type> {
        let rc = Rc::new(self);
        {
            Edge::<out_type>::new(rc.clone(), 0)
        }
    }

    pub fn result_min(self) -> Edge<f32> {
        let rc = Rc::new(self);
        {
            Edge::<f32>::new(rc.clone(), 1)
        }
    }

    pub fn result_max(self) -> Edge<f32> {
        let rc = Rc::new(self);
        {
            Edge::<f32>::new(rc.clone(), 2)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> (Edge<out_type>, Edge<f32>, Edge<f32>) {
        let rc = Rc::new(self);
        (
        {
            Edge::<out_type>::new(rc.clone(), 0)
        },
        {
            Edge::<f32>::new(rc.clone(), 1)
        },
        {
            Edge::<f32>::new(rc.clone(), 2)
        },
        )
    }

    pub fn build(t: Edge<Tinput>, t_min: Edge<f32>, t_max: Edge<f32>, m: Edge<Tinput>, m_min: Edge<f32>, m_max: Edge<f32>, v: Edge<Tinput>, v_min: Edge<f32>, v_max: Edge<f32>, beta: Edge<Tinput>, beta_min: Edge<f32>, beta_max: Edge<f32>, gamma: Edge<Tinput>, gamma_min: Edge<f32>, gamma_max: Edge<f32>, variance_epsilon: f32, scale_after_normalization: bool) -> Self {
        Self {
            phantom_Tinput: PhantomData,
            t,
            t_min,
            t_max,
            m,
            m_min,
            m_max,
            v,
            v_min,
            v_max,
            beta,
            beta_min,
            beta_max,
            gamma,
            gamma_min,
            gamma_max,
            phantom_out_type: PhantomData,
            variance_epsilon: variance_epsilon,
            scale_after_normalization: scale_after_normalization,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(t: Edge<Tinput>, t_min: Edge<f32>, t_max: Edge<f32>, m: Edge<Tinput>, m_min: Edge<f32>, m_max: Edge<f32>, v: Edge<Tinput>, v_min: Edge<f32>, v_max: Edge<f32>, beta: Edge<Tinput>, beta_min: Edge<f32>, beta_max: Edge<f32>, gamma: Edge<Tinput>, gamma_min: Edge<f32>, gamma_max: Edge<f32>, variance_epsilon: f32, scale_after_normalization: bool) -> (Edge<out_type>, Edge<f32>, Edge<f32>) {
        Self {
            phantom_Tinput: PhantomData,
            t,
            t_min,
            t_max,
            m,
            m_min,
            m_max,
            v,
            v_min,
            v_max,
            beta,
            beta_min,
            beta_max,
            gamma,
            gamma_min,
            gamma_max,
            phantom_out_type: PhantomData,
            variance_epsilon: variance_epsilon,
            scale_after_normalization: scale_after_normalization,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<Tinput, out_type> GraphOperation for QuantizedRelu6<Tinput, out_type>
where Tinput: TensorType,
      Tinput: Clone,
      out_type: TensorType,
      Tinput: con_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_QINT16_or_DT_QUINT16,
      Tinput: 'static,
      out_type: con_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_QINT16_or_DT_QUINT16,
      out_type: 'static,
      out_type: Clone,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("QuantizedRelu6_{}")?
        };
        let mut new_op = graph.new_operation("QuantizedRelu6", &op_name)?;
        {
            new_op.add_edge(&self.features)?
        }
        {
            new_op.add_edge(&self.min_features)?
        }
        {
            new_op.add_edge(&self.max_features)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct QuantizedRelu6<Tinput, out_type>
where Tinput: TensorType,
      Tinput: Clone,
      out_type: TensorType,
      Tinput: con_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_QINT16_or_DT_QUINT16,
      Tinput: 'static,
      out_type: con_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_QINT16_or_DT_QUINT16,
      out_type: 'static,
      out_type: Clone,
{
    phantom_Tinput: PhantomData<Tinput>,
    features: Edge<Tinput>,
    min_features: Edge<f32>,
    max_features: Edge<f32>,
    phantom_out_type: PhantomData<out_type>,
    op_name: Option<String>,
    id_: usize,
}

impl<Tinput, out_type> QuantizedRelu6<Tinput, out_type>
where Tinput: TensorType,
      Tinput: Clone,
      out_type: TensorType,
      Tinput: con_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_QINT16_or_DT_QUINT16,
      Tinput: 'static,
      out_type: con_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_QINT16_or_DT_QUINT16,
      out_type: 'static,
      out_type: Clone,
{
    pub fn activations(self) -> Edge<out_type> {
        let rc = Rc::new(self);
        {
            Edge::<out_type>::new(rc.clone(), 0)
        }
    }

    pub fn min_activations(self) -> Edge<f32> {
        let rc = Rc::new(self);
        {
            Edge::<f32>::new(rc.clone(), 1)
        }
    }

    pub fn max_activations(self) -> Edge<f32> {
        let rc = Rc::new(self);
        {
            Edge::<f32>::new(rc.clone(), 2)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> (Edge<out_type>, Edge<f32>, Edge<f32>) {
        let rc = Rc::new(self);
        (
        {
            Edge::<out_type>::new(rc.clone(), 0)
        },
        {
            Edge::<f32>::new(rc.clone(), 1)
        },
        {
            Edge::<f32>::new(rc.clone(), 2)
        },
        )
    }

    pub fn build(features: Edge<Tinput>, min_features: Edge<f32>, max_features: Edge<f32>) -> Self {
        Self {
            phantom_Tinput: PhantomData,
            features,
            min_features,
            max_features,
            phantom_out_type: PhantomData,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(features: Edge<Tinput>, min_features: Edge<f32>, max_features: Edge<f32>) -> (Edge<out_type>, Edge<f32>, Edge<f32>) {
        Self {
            phantom_Tinput: PhantomData,
            features,
            min_features,
            max_features,
            phantom_out_type: PhantomData,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<Tinput, out_type> GraphOperation for QuantizedRelu<Tinput, out_type>
where Tinput: TensorType,
      Tinput: Clone,
      out_type: TensorType,
      Tinput: con_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_QINT16_or_DT_QUINT16,
      Tinput: 'static,
      out_type: con_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_QINT16_or_DT_QUINT16,
      out_type: 'static,
      out_type: Clone,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("QuantizedRelu_{}")?
        };
        let mut new_op = graph.new_operation("QuantizedRelu", &op_name)?;
        {
            new_op.add_edge(&self.features)?
        }
        {
            new_op.add_edge(&self.min_features)?
        }
        {
            new_op.add_edge(&self.max_features)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct QuantizedRelu<Tinput, out_type>
where Tinput: TensorType,
      Tinput: Clone,
      out_type: TensorType,
      Tinput: con_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_QINT16_or_DT_QUINT16,
      Tinput: 'static,
      out_type: con_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_QINT16_or_DT_QUINT16,
      out_type: 'static,
      out_type: Clone,
{
    phantom_Tinput: PhantomData<Tinput>,
    features: Edge<Tinput>,
    min_features: Edge<f32>,
    max_features: Edge<f32>,
    phantom_out_type: PhantomData<out_type>,
    op_name: Option<String>,
    id_: usize,
}

impl<Tinput, out_type> QuantizedRelu<Tinput, out_type>
where Tinput: TensorType,
      Tinput: Clone,
      out_type: TensorType,
      Tinput: con_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_QINT16_or_DT_QUINT16,
      Tinput: 'static,
      out_type: con_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_QINT16_or_DT_QUINT16,
      out_type: 'static,
      out_type: Clone,
{
    pub fn activations(self) -> Edge<out_type> {
        let rc = Rc::new(self);
        {
            Edge::<out_type>::new(rc.clone(), 0)
        }
    }

    pub fn min_activations(self) -> Edge<f32> {
        let rc = Rc::new(self);
        {
            Edge::<f32>::new(rc.clone(), 1)
        }
    }

    pub fn max_activations(self) -> Edge<f32> {
        let rc = Rc::new(self);
        {
            Edge::<f32>::new(rc.clone(), 2)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> (Edge<out_type>, Edge<f32>, Edge<f32>) {
        let rc = Rc::new(self);
        (
        {
            Edge::<out_type>::new(rc.clone(), 0)
        },
        {
            Edge::<f32>::new(rc.clone(), 1)
        },
        {
            Edge::<f32>::new(rc.clone(), 2)
        },
        )
    }

    pub fn build(features: Edge<Tinput>, min_features: Edge<f32>, max_features: Edge<f32>) -> Self {
        Self {
            phantom_Tinput: PhantomData,
            features,
            min_features,
            max_features,
            phantom_out_type: PhantomData,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(features: Edge<Tinput>, min_features: Edge<f32>, max_features: Edge<f32>) -> (Edge<out_type>, Edge<f32>, Edge<f32>) {
        Self {
            phantom_Tinput: PhantomData,
            features,
            min_features,
            max_features,
            phantom_out_type: PhantomData,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<T, Tindices> GraphOperation for ScatterUpdate<T, Tindices>
where T: TensorType,
      T: Clone,
      Tindices: TensorType,
      Tindices: Clone,
      T: 'static,
      Tindices: con_or_DT_INT32_or_DT_INT64,
      Tindices: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("ScatterUpdate_{}")?
        };
        let mut new_op = graph.new_operation("ScatterUpdate", &op_name)?;
        {
            new_op.add_edge(&self.ref_)?
        }
        {
            new_op.add_edge(&self.indices)?
        }
        {
            new_op.add_edge(&self.updates)?
        }
        {
            match self.use_locking {
                None => new_op.set_attr_value_proto("use_locking", &vec![40_u8, 1_u8,])?,
                Some(ref value) => (|attr: &bool| {new_op.set_attr_bool("use_locking", *attr)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct ScatterUpdate<T, Tindices>
where T: TensorType,
      T: Clone,
      Tindices: TensorType,
      Tindices: Clone,
      T: 'static,
      Tindices: con_or_DT_INT32_or_DT_INT64,
      Tindices: 'static,
{
    phantom_T: PhantomData<T>,
    ref_: Edge<T>,
    phantom_Tindices: PhantomData<Tindices>,
    indices: Edge<Tindices>,
    updates: Edge<T>,
    use_locking: Option<bool>,
    op_name: Option<String>,
    id_: usize,
}

impl<T, Tindices> ScatterUpdate<T, Tindices>
where T: TensorType,
      T: Clone,
      Tindices: TensorType,
      Tindices: Clone,
      T: 'static,
      Tindices: con_or_DT_INT32_or_DT_INT64,
      Tindices: 'static,
{
    pub fn output_ref(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn use_locking(&mut self, use_locking: bool) -> Self {
        self.use_locking = Some(use_locking);
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(ref_: Edge<T>, indices: Edge<Tindices>, updates: Edge<T>) -> Self {
        Self {
            phantom_T: PhantomData,
            ref_,
            phantom_Tindices: PhantomData,
            indices,
            updates,
            use_locking: None,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(ref_: Edge<T>, indices: Edge<Tindices>, updates: Edge<T>) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            ref_,
            phantom_Tindices: PhantomData,
            indices,
            updates,
            use_locking: None,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<T> GraphOperation for QuantizedMaxPool<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_QINT16_or_DT_QUINT16,
      T: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("QuantizedMaxPool_{}")?
        };
        let mut new_op = graph.new_operation("QuantizedMaxPool", &op_name)?;
        {
            new_op.add_edge(&self.input)?
        }
        {
            new_op.add_edge(&self.min_input)?
        }
        {
            new_op.add_edge(&self.max_input)?
        }
        {
            (|attrs| {new_op.set_attr_int_list("ksize", attrs)})(&self.ksize)?
        }
        {
            (|attrs| {new_op.set_attr_int_list("strides", attrs)})(&self.strides)?
        }
        {
            (|attr| {new_op.set_attr_string("padding", attr)})(&self.padding)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct QuantizedMaxPool<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_QINT16_or_DT_QUINT16,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    input: Edge<T>,
    min_input: Edge<f32>,
    max_input: Edge<f32>,
    ksize: Vec<i64>,
    strides: Vec<i64>,
    padding: String,
    op_name: Option<String>,
    id_: usize,
}

impl<T> QuantizedMaxPool<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_QINT16_or_DT_QUINT16,
      T: 'static,
{
    pub fn output(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn min_output(self) -> Edge<f32> {
        let rc = Rc::new(self);
        {
            Edge::<f32>::new(rc.clone(), 1)
        }
    }

    pub fn max_output(self) -> Edge<f32> {
        let rc = Rc::new(self);
        {
            Edge::<f32>::new(rc.clone(), 2)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> (Edge<T>, Edge<f32>, Edge<f32>) {
        let rc = Rc::new(self);
        (
        {
            Edge::<T>::new(rc.clone(), 0)
        },
        {
            Edge::<f32>::new(rc.clone(), 1)
        },
        {
            Edge::<f32>::new(rc.clone(), 2)
        },
        )
    }

    pub fn build(input: Edge<T>, min_input: Edge<f32>, max_input: Edge<f32>, ksize: &[i64], strides: &[i64], padding: &str) -> Self {
        Self {
            phantom_T: PhantomData,
            input,
            min_input,
            max_input,
            ksize: ksize.to_vec(),
            strides: strides.to_vec(),
            padding: padding.to_string(),
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(input: Edge<T>, min_input: Edge<f32>, max_input: Edge<f32>, ksize: &[i64], strides: &[i64], padding: &str) -> (Edge<T>, Edge<f32>, Edge<f32>) {
        Self {
            phantom_T: PhantomData,
            input,
            min_input,
            max_input,
            ksize: ksize.to_vec(),
            strides: strides.to_vec(),
            padding: padding.to_string(),
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<Tinput, Tfilter, out_type> GraphOperation for QuantizedConv2D<Tinput, Tfilter, out_type>
where Tinput: TensorType,
      Tinput: Clone,
      Tfilter: TensorType,
      Tfilter: Clone,
      out_type: TensorType,
      Tinput: con_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_QINT16_or_DT_QUINT16,
      Tinput: 'static,
      Tfilter: con_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_QINT16_or_DT_QUINT16,
      Tfilter: 'static,
      out_type: con_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_QINT16_or_DT_QUINT16,
      out_type: 'static,
      out_type: Clone,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("QuantizedConv2D_{}")?
        };
        let mut new_op = graph.new_operation("QuantizedConv2D", &op_name)?;
        {
            new_op.add_edge(&self.input)?
        }
        {
            new_op.add_edge(&self.filter)?
        }
        {
            new_op.add_edge(&self.min_input)?
        }
        {
            new_op.add_edge(&self.max_input)?
        }
        {
            new_op.add_edge(&self.min_filter)?
        }
        {
            new_op.add_edge(&self.max_filter)?
        }
        {
            (|attrs| {new_op.set_attr_int_list("strides", attrs)})(&self.strides)?
        }
        {
            (|attr| {new_op.set_attr_string("padding", attr)})(&self.padding)?
        }
        {
            match self.dilations {
                None => new_op.set_attr_value_proto("dilations", &vec![10_u8, 0_u8, 26_u8, 4_u8,])?,
                Some(ref value) => (|attrs| {new_op.set_attr_int_list("dilations", attrs)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct QuantizedConv2D<Tinput, Tfilter, out_type>
where Tinput: TensorType,
      Tinput: Clone,
      Tfilter: TensorType,
      Tfilter: Clone,
      out_type: TensorType,
      Tinput: con_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_QINT16_or_DT_QUINT16,
      Tinput: 'static,
      Tfilter: con_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_QINT16_or_DT_QUINT16,
      Tfilter: 'static,
      out_type: con_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_QINT16_or_DT_QUINT16,
      out_type: 'static,
      out_type: Clone,
{
    phantom_Tinput: PhantomData<Tinput>,
    input: Edge<Tinput>,
    phantom_Tfilter: PhantomData<Tfilter>,
    filter: Edge<Tfilter>,
    min_input: Edge<f32>,
    max_input: Edge<f32>,
    min_filter: Edge<f32>,
    max_filter: Edge<f32>,
    phantom_out_type: PhantomData<out_type>,
    strides: Vec<i64>,
    padding: String,
    dilations: Option<Vec<i64>>,
    op_name: Option<String>,
    id_: usize,
}

impl<Tinput, Tfilter, out_type> QuantizedConv2D<Tinput, Tfilter, out_type>
where Tinput: TensorType,
      Tinput: Clone,
      Tfilter: TensorType,
      Tfilter: Clone,
      out_type: TensorType,
      Tinput: con_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_QINT16_or_DT_QUINT16,
      Tinput: 'static,
      Tfilter: con_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_QINT16_or_DT_QUINT16,
      Tfilter: 'static,
      out_type: con_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_QINT16_or_DT_QUINT16,
      out_type: 'static,
      out_type: Clone,
{
    pub fn output(self) -> Edge<out_type> {
        let rc = Rc::new(self);
        {
            Edge::<out_type>::new(rc.clone(), 0)
        }
    }

    pub fn min_output(self) -> Edge<f32> {
        let rc = Rc::new(self);
        {
            Edge::<f32>::new(rc.clone(), 1)
        }
    }

    pub fn max_output(self) -> Edge<f32> {
        let rc = Rc::new(self);
        {
            Edge::<f32>::new(rc.clone(), 2)
        }
    }

    pub fn dilations(&mut self, dilations: &[i64]) -> Self {
        self.dilations = Some(dilations.to_vec());
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> (Edge<out_type>, Edge<f32>, Edge<f32>) {
        let rc = Rc::new(self);
        (
        {
            Edge::<out_type>::new(rc.clone(), 0)
        },
        {
            Edge::<f32>::new(rc.clone(), 1)
        },
        {
            Edge::<f32>::new(rc.clone(), 2)
        },
        )
    }

    pub fn build(input: Edge<Tinput>, filter: Edge<Tfilter>, min_input: Edge<f32>, max_input: Edge<f32>, min_filter: Edge<f32>, max_filter: Edge<f32>, strides: &[i64], padding: &str) -> Self {
        Self {
            phantom_Tinput: PhantomData,
            input,
            phantom_Tfilter: PhantomData,
            filter,
            min_input,
            max_input,
            min_filter,
            max_filter,
            phantom_out_type: PhantomData,
            strides: strides.to_vec(),
            padding: padding.to_string(),
            dilations: None,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(input: Edge<Tinput>, filter: Edge<Tfilter>, min_input: Edge<f32>, max_input: Edge<f32>, min_filter: Edge<f32>, max_filter: Edge<f32>, strides: &[i64], padding: &str) -> (Edge<out_type>, Edge<f32>, Edge<f32>) {
        Self {
            phantom_Tinput: PhantomData,
            input,
            phantom_Tfilter: PhantomData,
            filter,
            min_input,
            max_input,
            min_filter,
            max_filter,
            phantom_out_type: PhantomData,
            strides: strides.to_vec(),
            padding: padding.to_string(),
            dilations: None,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<T1, T2, out_type> GraphOperation for QuantizedBiasAdd<T1, T2, out_type>
where T1: TensorType,
      T1: Clone,
      T2: TensorType,
      T2: Clone,
      out_type: TensorType,
      T1: con_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_QINT16_or_DT_QUINT16,
      T1: 'static,
      T2: con_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_QINT16_or_DT_QUINT16,
      T2: 'static,
      out_type: con_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_QINT16_or_DT_QUINT16,
      out_type: 'static,
      out_type: Clone,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("QuantizedBiasAdd_{}")?
        };
        let mut new_op = graph.new_operation("QuantizedBiasAdd", &op_name)?;
        {
            new_op.add_edge(&self.input)?
        }
        {
            new_op.add_edge(&self.bias)?
        }
        {
            new_op.add_edge(&self.min_input)?
        }
        {
            new_op.add_edge(&self.max_input)?
        }
        {
            new_op.add_edge(&self.min_bias)?
        }
        {
            new_op.add_edge(&self.max_bias)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct QuantizedBiasAdd<T1, T2, out_type>
where T1: TensorType,
      T1: Clone,
      T2: TensorType,
      T2: Clone,
      out_type: TensorType,
      T1: con_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_QINT16_or_DT_QUINT16,
      T1: 'static,
      T2: con_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_QINT16_or_DT_QUINT16,
      T2: 'static,
      out_type: con_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_QINT16_or_DT_QUINT16,
      out_type: 'static,
      out_type: Clone,
{
    phantom_T1: PhantomData<T1>,
    input: Edge<T1>,
    phantom_T2: PhantomData<T2>,
    bias: Edge<T2>,
    min_input: Edge<f32>,
    max_input: Edge<f32>,
    min_bias: Edge<f32>,
    max_bias: Edge<f32>,
    phantom_out_type: PhantomData<out_type>,
    op_name: Option<String>,
    id_: usize,
}

impl<T1, T2, out_type> QuantizedBiasAdd<T1, T2, out_type>
where T1: TensorType,
      T1: Clone,
      T2: TensorType,
      T2: Clone,
      out_type: TensorType,
      T1: con_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_QINT16_or_DT_QUINT16,
      T1: 'static,
      T2: con_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_QINT16_or_DT_QUINT16,
      T2: 'static,
      out_type: con_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_QINT16_or_DT_QUINT16,
      out_type: 'static,
      out_type: Clone,
{
    pub fn output(self) -> Edge<out_type> {
        let rc = Rc::new(self);
        {
            Edge::<out_type>::new(rc.clone(), 0)
        }
    }

    pub fn min_out(self) -> Edge<f32> {
        let rc = Rc::new(self);
        {
            Edge::<f32>::new(rc.clone(), 1)
        }
    }

    pub fn max_out(self) -> Edge<f32> {
        let rc = Rc::new(self);
        {
            Edge::<f32>::new(rc.clone(), 2)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> (Edge<out_type>, Edge<f32>, Edge<f32>) {
        let rc = Rc::new(self);
        (
        {
            Edge::<out_type>::new(rc.clone(), 0)
        },
        {
            Edge::<f32>::new(rc.clone(), 1)
        },
        {
            Edge::<f32>::new(rc.clone(), 2)
        },
        )
    }

    pub fn build(input: Edge<T1>, bias: Edge<T2>, min_input: Edge<f32>, max_input: Edge<f32>, min_bias: Edge<f32>, max_bias: Edge<f32>) -> Self {
        Self {
            phantom_T1: PhantomData,
            input,
            phantom_T2: PhantomData,
            bias,
            min_input,
            max_input,
            min_bias,
            max_bias,
            phantom_out_type: PhantomData,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(input: Edge<T1>, bias: Edge<T2>, min_input: Edge<f32>, max_input: Edge<f32>, min_bias: Edge<f32>, max_bias: Edge<f32>) -> (Edge<out_type>, Edge<f32>, Edge<f32>) {
        Self {
            phantom_T1: PhantomData,
            input,
            phantom_T2: PhantomData,
            bias,
            min_input,
            max_input,
            min_bias,
            max_bias,
            phantom_out_type: PhantomData,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<T> GraphOperation for QuantizedAvgPool<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_QINT16_or_DT_QUINT16,
      T: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("QuantizedAvgPool_{}")?
        };
        let mut new_op = graph.new_operation("QuantizedAvgPool", &op_name)?;
        {
            new_op.add_edge(&self.input)?
        }
        {
            new_op.add_edge(&self.min_input)?
        }
        {
            new_op.add_edge(&self.max_input)?
        }
        {
            (|attrs| {new_op.set_attr_int_list("ksize", attrs)})(&self.ksize)?
        }
        {
            (|attrs| {new_op.set_attr_int_list("strides", attrs)})(&self.strides)?
        }
        {
            (|attr| {new_op.set_attr_string("padding", attr)})(&self.padding)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct QuantizedAvgPool<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_QINT16_or_DT_QUINT16,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    input: Edge<T>,
    min_input: Edge<f32>,
    max_input: Edge<f32>,
    ksize: Vec<i64>,
    strides: Vec<i64>,
    padding: String,
    op_name: Option<String>,
    id_: usize,
}

impl<T> QuantizedAvgPool<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_QINT16_or_DT_QUINT16,
      T: 'static,
{
    pub fn output(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn min_output(self) -> Edge<f32> {
        let rc = Rc::new(self);
        {
            Edge::<f32>::new(rc.clone(), 1)
        }
    }

    pub fn max_output(self) -> Edge<f32> {
        let rc = Rc::new(self);
        {
            Edge::<f32>::new(rc.clone(), 2)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> (Edge<T>, Edge<f32>, Edge<f32>) {
        let rc = Rc::new(self);
        (
        {
            Edge::<T>::new(rc.clone(), 0)
        },
        {
            Edge::<f32>::new(rc.clone(), 1)
        },
        {
            Edge::<f32>::new(rc.clone(), 2)
        },
        )
    }

    pub fn build(input: Edge<T>, min_input: Edge<f32>, max_input: Edge<f32>, ksize: &[i64], strides: &[i64], padding: &str) -> Self {
        Self {
            phantom_T: PhantomData,
            input,
            min_input,
            max_input,
            ksize: ksize.to_vec(),
            strides: strides.to_vec(),
            padding: padding.to_string(),
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(input: Edge<T>, min_input: Edge<f32>, max_input: Edge<f32>, ksize: &[i64], strides: &[i64], padding: &str) -> (Edge<T>, Edge<f32>, Edge<f32>) {
        Self {
            phantom_T: PhantomData,
            input,
            min_input,
            max_input,
            ksize: ksize.to_vec(),
            strides: strides.to_vec(),
            padding: padding.to_string(),
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<T> GraphOperation for FractionalAvgPoolGrad<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_INT64,
      T: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("FractionalAvgPoolGrad_{}")?
        };
        let mut new_op = graph.new_operation("FractionalAvgPoolGrad", &op_name)?;
        {
            new_op.add_edge(&self.orig_input_tensor_shape)?
        }
        {
            new_op.add_edge(&self.out_backprop)?
        }
        {
            new_op.add_edge(&self.row_pooling_sequence)?
        }
        {
            new_op.add_edge(&self.col_pooling_sequence)?
        }
        {
            match self.overlapping {
                None => new_op.set_attr_value_proto("overlapping", &vec![40_u8, 0_u8,])?,
                Some(ref value) => (|attr: &bool| {new_op.set_attr_bool("overlapping", *attr)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct FractionalAvgPoolGrad<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_INT64,
      T: 'static,
{
    orig_input_tensor_shape: Edge<i64>,
    phantom_T: PhantomData<T>,
    out_backprop: Edge<T>,
    row_pooling_sequence: Edge<i64>,
    col_pooling_sequence: Edge<i64>,
    overlapping: Option<bool>,
    op_name: Option<String>,
    id_: usize,
}

impl<T> FractionalAvgPoolGrad<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_INT64,
      T: 'static,
{
    pub fn output(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn overlapping(&mut self, overlapping: bool) -> Self {
        self.overlapping = Some(overlapping);
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(orig_input_tensor_shape: Edge<i64>, out_backprop: Edge<T>, row_pooling_sequence: Edge<i64>, col_pooling_sequence: Edge<i64>) -> Self {
        Self {
            orig_input_tensor_shape,
            phantom_T: PhantomData,
            out_backprop,
            row_pooling_sequence,
            col_pooling_sequence,
            overlapping: None,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(orig_input_tensor_shape: Edge<i64>, out_backprop: Edge<T>, row_pooling_sequence: Edge<i64>, col_pooling_sequence: Edge<i64>) -> Edge<T> {
        Self {
            orig_input_tensor_shape,
            phantom_T: PhantomData,
            out_backprop,
            row_pooling_sequence,
            col_pooling_sequence,
            overlapping: None,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<T> GraphOperation for TopKV2<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("TopKV2_{}")?
        };
        let mut new_op = graph.new_operation("TopKV2", &op_name)?;
        {
            new_op.add_edge(&self.input)?
        }
        {
            new_op.add_edge(&self.k)?
        }
        {
            match self.sorted {
                None => new_op.set_attr_value_proto("sorted", &vec![40_u8, 1_u8,])?,
                Some(ref value) => (|attr: &bool| {new_op.set_attr_bool("sorted", *attr)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct TopKV2<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    input: Edge<T>,
    k: Edge<i32>,
    sorted: Option<bool>,
    op_name: Option<String>,
    id_: usize,
}

impl<T> TopKV2<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
{
    pub fn values(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn indices(self) -> Edge<i32> {
        let rc = Rc::new(self);
        {
            Edge::<i32>::new(rc.clone(), 1)
        }
    }

    pub fn sorted(&mut self, sorted: bool) -> Self {
        self.sorted = Some(sorted);
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> (Edge<T>, Edge<i32>) {
        let rc = Rc::new(self);
        (
        {
            Edge::<T>::new(rc.clone(), 0)
        },
        {
            Edge::<i32>::new(rc.clone(), 1)
        },
        )
    }

    pub fn build(input: Edge<T>, k: Edge<i32>) -> Self {
        Self {
            phantom_T: PhantomData,
            input,
            k,
            sorted: None,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(input: Edge<T>, k: Edge<i32>) -> (Edge<T>, Edge<i32>) {
        Self {
            phantom_T: PhantomData,
            input,
            k,
            sorted: None,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<T> GraphOperation for ApplyProximalGradientDescent<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("ApplyProximalGradientDescent_{}")?
        };
        let mut new_op = graph.new_operation("ApplyProximalGradientDescent", &op_name)?;
        {
            new_op.add_edge(&self.var)?
        }
        {
            new_op.add_edge(&self.alpha)?
        }
        {
            new_op.add_edge(&self.l1)?
        }
        {
            new_op.add_edge(&self.l2)?
        }
        {
            new_op.add_edge(&self.delta)?
        }
        {
            match self.use_locking {
                None => new_op.set_attr_value_proto("use_locking", &vec![40_u8, 0_u8,])?,
                Some(ref value) => (|attr: &bool| {new_op.set_attr_bool("use_locking", *attr)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct ApplyProximalGradientDescent<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    var: Edge<T>,
    alpha: Edge<T>,
    l1: Edge<T>,
    l2: Edge<T>,
    delta: Edge<T>,
    use_locking: Option<bool>,
    op_name: Option<String>,
    id_: usize,
}

impl<T> ApplyProximalGradientDescent<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
{
    pub fn out(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn use_locking(&mut self, use_locking: bool) -> Self {
        self.use_locking = Some(use_locking);
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(var: Edge<T>, alpha: Edge<T>, l1: Edge<T>, l2: Edge<T>, delta: Edge<T>) -> Self {
        Self {
            phantom_T: PhantomData,
            var,
            alpha,
            l1,
            l2,
            delta,
            use_locking: None,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(var: Edge<T>, alpha: Edge<T>, l1: Edge<T>, l2: Edge<T>, delta: Edge<T>) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            var,
            alpha,
            l1,
            l2,
            delta,
            use_locking: None,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<T> GraphOperation for TopK<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("TopK_{}")?
        };
        let mut new_op = graph.new_operation("TopK", &op_name)?;
        {
            new_op.add_edge(&self.input)?
        }
        {
            (|attr: &i64| {new_op.set_attr_int("k", *attr)})(&self.k)?
        }
        {
            match self.sorted {
                None => new_op.set_attr_value_proto("sorted", &vec![40_u8, 1_u8,])?,
                Some(ref value) => (|attr: &bool| {new_op.set_attr_bool("sorted", *attr)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct TopK<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    input: Edge<T>,
    k: i64,
    sorted: Option<bool>,
    op_name: Option<String>,
    id_: usize,
}

impl<T> TopK<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
{
    pub fn values(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn indices(self) -> Edge<i32> {
        let rc = Rc::new(self);
        {
            Edge::<i32>::new(rc.clone(), 1)
        }
    }

    pub fn sorted(&mut self, sorted: bool) -> Self {
        self.sorted = Some(sorted);
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> (Edge<T>, Edge<i32>) {
        let rc = Rc::new(self);
        (
        {
            Edge::<T>::new(rc.clone(), 0)
        },
        {
            Edge::<i32>::new(rc.clone(), 1)
        },
        )
    }

    pub fn build(input: Edge<T>, k: i64) -> Self {
        Self {
            phantom_T: PhantomData,
            input,
            k: k,
            sorted: None,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(input: Edge<T>, k: i64) -> (Edge<T>, Edge<i32>) {
        Self {
            phantom_T: PhantomData,
            input,
            k: k,
            sorted: None,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<T> GraphOperation for InTopKV2<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_INT32_or_DT_INT64,
      T: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("InTopKV2_{}")?
        };
        let mut new_op = graph.new_operation("InTopKV2", &op_name)?;
        {
            new_op.add_edge(&self.predictions)?
        }
        {
            new_op.add_edge(&self.targets)?
        }
        {
            new_op.add_edge(&self.k)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct InTopKV2<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_INT32_or_DT_INT64,
      T: 'static,
{
    predictions: Edge<f32>,
    phantom_T: PhantomData<T>,
    targets: Edge<T>,
    k: Edge<T>,
    op_name: Option<String>,
    id_: usize,
}

impl<T> InTopKV2<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_INT32_or_DT_INT64,
      T: 'static,
{
    pub fn precision(self) -> Edge<bool> {
        let rc = Rc::new(self);
        {
            Edge::<bool>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<bool> {
        let rc = Rc::new(self);
        {
            Edge::<bool>::new(rc.clone(), 0)
        }
    }

    pub fn build(predictions: Edge<f32>, targets: Edge<T>, k: Edge<T>) -> Self {
        Self {
            predictions,
            phantom_T: PhantomData,
            targets,
            k,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(predictions: Edge<f32>, targets: Edge<T>, k: Edge<T>) -> Edge<bool> {
        Self {
            predictions,
            phantom_T: PhantomData,
            targets,
            k,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<T> GraphOperation for InTopK<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_INT32_or_DT_INT64,
      T: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("InTopK_{}")?
        };
        let mut new_op = graph.new_operation("InTopK", &op_name)?;
        {
            new_op.add_edge(&self.predictions)?
        }
        {
            new_op.add_edge(&self.targets)?
        }
        {
            (|attr: &i64| {new_op.set_attr_int("k", *attr)})(&self.k)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct InTopK<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_INT32_or_DT_INT64,
      T: 'static,
{
    predictions: Edge<f32>,
    phantom_T: PhantomData<T>,
    targets: Edge<T>,
    k: i64,
    op_name: Option<String>,
    id_: usize,
}

impl<T> InTopK<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_INT32_or_DT_INT64,
      T: 'static,
{
    pub fn precision(self) -> Edge<bool> {
        let rc = Rc::new(self);
        {
            Edge::<bool>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<bool> {
        let rc = Rc::new(self);
        {
            Edge::<bool>::new(rc.clone(), 0)
        }
    }

    pub fn build(predictions: Edge<f32>, targets: Edge<T>, k: i64) -> Self {
        Self {
            predictions,
            phantom_T: PhantomData,
            targets,
            k: k,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(predictions: Edge<f32>, targets: Edge<T>, k: i64) -> Edge<bool> {
        Self {
            predictions,
            phantom_T: PhantomData,
            targets,
            k: k,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<T, Tlabels> GraphOperation for SparseSoftmaxCrossEntropyWithLogits<T, Tlabels>
where T: TensorType,
      T: Clone,
      Tlabels: TensorType,
      Tlabels: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
      T: 'static,
      Tlabels: con_or_DT_INT32_or_DT_INT64,
      Tlabels: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("SparseSoftmaxCrossEntropyWithLogits_{}")?
        };
        let mut new_op = graph.new_operation("SparseSoftmaxCrossEntropyWithLogits", &op_name)?;
        {
            new_op.add_edge(&self.features)?
        }
        {
            new_op.add_edge(&self.labels)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct SparseSoftmaxCrossEntropyWithLogits<T, Tlabels>
where T: TensorType,
      T: Clone,
      Tlabels: TensorType,
      Tlabels: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
      T: 'static,
      Tlabels: con_or_DT_INT32_or_DT_INT64,
      Tlabels: 'static,
{
    phantom_T: PhantomData<T>,
    features: Edge<T>,
    phantom_Tlabels: PhantomData<Tlabels>,
    labels: Edge<Tlabels>,
    op_name: Option<String>,
    id_: usize,
}

impl<T, Tlabels> SparseSoftmaxCrossEntropyWithLogits<T, Tlabels>
where T: TensorType,
      T: Clone,
      Tlabels: TensorType,
      Tlabels: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
      T: 'static,
      Tlabels: con_or_DT_INT32_or_DT_INT64,
      Tlabels: 'static,
{
    pub fn loss(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn backprop(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 1)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> (Edge<T>, Edge<T>) {
        let rc = Rc::new(self);
        (
        {
            Edge::<T>::new(rc.clone(), 0)
        },
        {
            Edge::<T>::new(rc.clone(), 1)
        },
        )
    }

    pub fn build(features: Edge<T>, labels: Edge<Tlabels>) -> Self {
        Self {
            phantom_T: PhantomData,
            features,
            phantom_Tlabels: PhantomData,
            labels,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(features: Edge<T>, labels: Edge<Tlabels>) -> (Edge<T>, Edge<T>) {
        Self {
            phantom_T: PhantomData,
            features,
            phantom_Tlabels: PhantomData,
            labels,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<T> GraphOperation for SoftmaxCrossEntropyWithLogits<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
      T: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("SoftmaxCrossEntropyWithLogits_{}")?
        };
        let mut new_op = graph.new_operation("SoftmaxCrossEntropyWithLogits", &op_name)?;
        {
            new_op.add_edge(&self.features)?
        }
        {
            new_op.add_edge(&self.labels)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct SoftmaxCrossEntropyWithLogits<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    features: Edge<T>,
    labels: Edge<T>,
    op_name: Option<String>,
    id_: usize,
}

impl<T> SoftmaxCrossEntropyWithLogits<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
      T: 'static,
{
    pub fn loss(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn backprop(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 1)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> (Edge<T>, Edge<T>) {
        let rc = Rc::new(self);
        (
        {
            Edge::<T>::new(rc.clone(), 0)
        },
        {
            Edge::<T>::new(rc.clone(), 1)
        },
        )
    }

    pub fn build(features: Edge<T>, labels: Edge<T>) -> Self {
        Self {
            phantom_T: PhantomData,
            features,
            labels,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(features: Edge<T>, labels: Edge<T>) -> (Edge<T>, Edge<T>) {
        Self {
            phantom_T: PhantomData,
            features,
            labels,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<T> GraphOperation for Softmax<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
      T: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("Softmax_{}")?
        };
        let mut new_op = graph.new_operation("Softmax", &op_name)?;
        {
            new_op.add_edge(&self.logits)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct Softmax<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    logits: Edge<T>,
    op_name: Option<String>,
    id_: usize,
}

impl<T> Softmax<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
      T: 'static,
{
    pub fn softmax(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(logits: Edge<T>) -> Self {
        Self {
            phantom_T: PhantomData,
            logits,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(logits: Edge<T>) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            logits,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<T> GraphOperation for SoftsignGrad<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
      T: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("SoftsignGrad_{}")?
        };
        let mut new_op = graph.new_operation("SoftsignGrad", &op_name)?;
        {
            new_op.add_edge(&self.gradients)?
        }
        {
            new_op.add_edge(&self.features)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct SoftsignGrad<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    gradients: Edge<T>,
    features: Edge<T>,
    op_name: Option<String>,
    id_: usize,
}

impl<T> SoftsignGrad<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
      T: 'static,
{
    pub fn backprops(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(gradients: Edge<T>, features: Edge<T>) -> Self {
        Self {
            phantom_T: PhantomData,
            gradients,
            features,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(gradients: Edge<T>, features: Edge<T>) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            gradients,
            features,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<T> GraphOperation for SetSize<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_STRING_or_DT_INT64_or_DT_UINT16,
      T: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("SetSize_{}")?
        };
        let mut new_op = graph.new_operation("SetSize", &op_name)?;
        {
            new_op.add_edge(&self.set_indices)?
        }
        {
            new_op.add_edge(&self.set_values)?
        }
        {
            new_op.add_edge(&self.set_shape)?
        }
        {
            match self.validate_indices {
                None => new_op.set_attr_value_proto("validate_indices", &vec![40_u8, 1_u8,])?,
                Some(ref value) => (|attr: &bool| {new_op.set_attr_bool("validate_indices", *attr)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct SetSize<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_STRING_or_DT_INT64_or_DT_UINT16,
      T: 'static,
{
    set_indices: Edge<i64>,
    phantom_T: PhantomData<T>,
    set_values: Edge<T>,
    set_shape: Edge<i64>,
    validate_indices: Option<bool>,
    op_name: Option<String>,
    id_: usize,
}

impl<T> SetSize<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_STRING_or_DT_INT64_or_DT_UINT16,
      T: 'static,
{
    pub fn size(self) -> Edge<i32> {
        let rc = Rc::new(self);
        {
            Edge::<i32>::new(rc.clone(), 0)
        }
    }

    pub fn validate_indices(&mut self, validate_indices: bool) -> Self {
        self.validate_indices = Some(validate_indices);
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<i32> {
        let rc = Rc::new(self);
        {
            Edge::<i32>::new(rc.clone(), 0)
        }
    }

    pub fn build(set_indices: Edge<i64>, set_values: Edge<T>, set_shape: Edge<i64>) -> Self {
        Self {
            set_indices,
            phantom_T: PhantomData,
            set_values,
            set_shape,
            validate_indices: None,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(set_indices: Edge<i64>, set_values: Edge<T>, set_shape: Edge<i64>) -> Edge<i32> {
        Self {
            set_indices,
            phantom_T: PhantomData,
            set_values,
            set_shape,
            validate_indices: None,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<T> GraphOperation for Selu<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
      T: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("Selu_{}")?
        };
        let mut new_op = graph.new_operation("Selu", &op_name)?;
        {
            new_op.add_edge(&self.features)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct Selu<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    features: Edge<T>,
    op_name: Option<String>,
    id_: usize,
}

impl<T> Selu<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
      T: 'static,
{
    pub fn activations(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(features: Edge<T>) -> Self {
        Self {
            phantom_T: PhantomData,
            features,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(features: Edge<T>) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            features,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl GraphOperation for StaticRegexReplace {
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("StaticRegexReplace_{}")?
        };
        let mut new_op = graph.new_operation("StaticRegexReplace", &op_name)?;
        {
            new_op.add_edge(&self.input)?
        }
        {
            (|attr| {new_op.set_attr_string("pattern", attr)})(&self.pattern)?
        }
        {
            (|attr| {new_op.set_attr_string("rewrite", attr)})(&self.rewrite)?
        }
        {
            match self.replace_global {
                None => new_op.set_attr_value_proto("replace_global", &vec![40_u8, 1_u8,])?,
                Some(ref value) => (|attr: &bool| {new_op.set_attr_bool("replace_global", *attr)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct StaticRegexReplace {
    input: Edge<String>,
    pattern: String,
    rewrite: String,
    replace_global: Option<bool>,
    op_name: Option<String>,
    id_: usize,
}

impl StaticRegexReplace {
    pub fn output(self) -> Edge<String> {
        let rc = Rc::new(self);
        {
            Edge::<String>::new(rc.clone(), 0)
        }
    }

    pub fn replace_global(&mut self, replace_global: bool) -> Self {
        self.replace_global = Some(replace_global);
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<String> {
        let rc = Rc::new(self);
        {
            Edge::<String>::new(rc.clone(), 0)
        }
    }

    pub fn build(input: Edge<String>, pattern: &str, rewrite: &str) -> Self {
        Self {
            input,
            pattern: pattern.to_string(),
            rewrite: rewrite.to_string(),
            replace_global: None,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(input: Edge<String>, pattern: &str, rewrite: &str) -> Edge<String> {
        Self {
            input,
            pattern: pattern.to_string(),
            rewrite: rewrite.to_string(),
            replace_global: None,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<T> GraphOperation for EluGrad<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
      T: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("EluGrad_{}")?
        };
        let mut new_op = graph.new_operation("EluGrad", &op_name)?;
        {
            new_op.add_edge(&self.gradients)?
        }
        {
            new_op.add_edge(&self.outputs)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct EluGrad<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    gradients: Edge<T>,
    outputs: Edge<T>,
    op_name: Option<String>,
    id_: usize,
}

impl<T> EluGrad<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
      T: 'static,
{
    pub fn backprops(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(gradients: Edge<T>, outputs: Edge<T>) -> Self {
        Self {
            phantom_T: PhantomData,
            gradients,
            outputs,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(gradients: Edge<T>, outputs: Edge<T>) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            gradients,
            outputs,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<T> GraphOperation for Elu<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
      T: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("Elu_{}")?
        };
        let mut new_op = graph.new_operation("Elu", &op_name)?;
        {
            new_op.add_edge(&self.features)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct Elu<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    features: Edge<T>,
    op_name: Option<String>,
    id_: usize,
}

impl<T> Elu<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
      T: 'static,
{
    pub fn activations(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(features: Edge<T>) -> Self {
        Self {
            phantom_T: PhantomData,
            features,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(features: Edge<T>) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            features,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<T> GraphOperation for LeakyReluGrad<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
      T: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("LeakyReluGrad_{}")?
        };
        let mut new_op = graph.new_operation("LeakyReluGrad", &op_name)?;
        {
            new_op.add_edge(&self.gradients)?
        }
        {
            new_op.add_edge(&self.features)?
        }
        {
            match self.alpha {
                None => new_op.set_attr_value_proto("alpha", &vec![37_u8, 205_u8, 204_u8, 76_u8, 62_u8,])?,
                Some(ref value) => (|attr: &f32| {new_op.set_attr_float("alpha", *attr)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct LeakyReluGrad<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    gradients: Edge<T>,
    features: Edge<T>,
    alpha: Option<f32>,
    op_name: Option<String>,
    id_: usize,
}

impl<T> LeakyReluGrad<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
      T: 'static,
{
    pub fn backprops(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn alpha(&mut self, alpha: f32) -> Self {
        self.alpha = Some(alpha);
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(gradients: Edge<T>, features: Edge<T>) -> Self {
        Self {
            phantom_T: PhantomData,
            gradients,
            features,
            alpha: None,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(gradients: Edge<T>, features: Edge<T>) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            gradients,
            features,
            alpha: None,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<T> GraphOperation for LeakyRelu<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
      T: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("LeakyRelu_{}")?
        };
        let mut new_op = graph.new_operation("LeakyRelu", &op_name)?;
        {
            new_op.add_edge(&self.features)?
        }
        {
            match self.alpha {
                None => new_op.set_attr_value_proto("alpha", &vec![37_u8, 205_u8, 204_u8, 76_u8, 62_u8,])?,
                Some(ref value) => (|attr: &f32| {new_op.set_attr_float("alpha", *attr)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct LeakyRelu<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    features: Edge<T>,
    alpha: Option<f32>,
    op_name: Option<String>,
    id_: usize,
}

impl<T> LeakyRelu<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
      T: 'static,
{
    pub fn activations(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn alpha(&mut self, alpha: f32) -> Self {
        self.alpha = Some(alpha);
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(features: Edge<T>) -> Self {
        Self {
            phantom_T: PhantomData,
            features,
            alpha: None,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(features: Edge<T>) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            features,
            alpha: None,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<T> GraphOperation for Relu6Grad<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("Relu6Grad_{}")?
        };
        let mut new_op = graph.new_operation("Relu6Grad", &op_name)?;
        {
            new_op.add_edge(&self.gradients)?
        }
        {
            new_op.add_edge(&self.features)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct Relu6Grad<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    gradients: Edge<T>,
    features: Edge<T>,
    op_name: Option<String>,
    id_: usize,
}

impl<T> Relu6Grad<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
{
    pub fn backprops(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(gradients: Edge<T>, features: Edge<T>) -> Self {
        Self {
            phantom_T: PhantomData,
            gradients,
            features,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(gradients: Edge<T>, features: Edge<T>) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            gradients,
            features,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<T> GraphOperation for Relu6<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("Relu6_{}")?
        };
        let mut new_op = graph.new_operation("Relu6", &op_name)?;
        {
            new_op.add_edge(&self.features)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct Relu6<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    features: Edge<T>,
    op_name: Option<String>,
    id_: usize,
}

impl<T> Relu6<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
{
    pub fn activations(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(features: Edge<T>) -> Self {
        Self {
            phantom_T: PhantomData,
            features,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(features: Edge<T>) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            features,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<T> GraphOperation for ReluGrad<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("ReluGrad_{}")?
        };
        let mut new_op = graph.new_operation("ReluGrad", &op_name)?;
        {
            new_op.add_edge(&self.gradients)?
        }
        {
            new_op.add_edge(&self.features)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct ReluGrad<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    gradients: Edge<T>,
    features: Edge<T>,
    op_name: Option<String>,
    id_: usize,
}

impl<T> ReluGrad<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
{
    pub fn backprops(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(gradients: Edge<T>, features: Edge<T>) -> Self {
        Self {
            phantom_T: PhantomData,
            gradients,
            features,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(gradients: Edge<T>, features: Edge<T>) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            gradients,
            features,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

pub trait con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_QINT8_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_QINT8_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64 for BFloat16 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_QINT8_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64 for f32 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_QINT8_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64 for f64 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_QINT8_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64 for i16 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_QINT8_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64 for i32 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_QINT8_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64 for i64 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_QINT8_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64 for i8 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_QINT8_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64 for u16 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_QINT8_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64 for u32 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_QINT8_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64 for u64 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_QINT8_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64 for u8 {
}

impl<T> GraphOperation for Relu<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_QINT8_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("Relu_{}")?
        };
        let mut new_op = graph.new_operation("Relu", &op_name)?;
        {
            new_op.add_edge(&self.features)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct Relu<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_QINT8_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    features: Edge<T>,
    op_name: Option<String>,
    id_: usize,
}

impl<T> Relu<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_QINT8_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
{
    pub fn activations(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(features: Edge<T>) -> Self {
        Self {
            phantom_T: PhantomData,
            features,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(features: Edge<T>) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            features,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<T> GraphOperation for Dilation2DBackpropInput<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("Dilation2DBackpropInput_{}")?
        };
        let mut new_op = graph.new_operation("Dilation2DBackpropInput", &op_name)?;
        {
            new_op.add_edge(&self.input)?
        }
        {
            new_op.add_edge(&self.filter)?
        }
        {
            new_op.add_edge(&self.out_backprop)?
        }
        {
            (|attrs| {new_op.set_attr_int_list("strides", attrs)})(&self.strides)?
        }
        {
            (|attrs| {new_op.set_attr_int_list("rates", attrs)})(&self.rates)?
        }
        {
            (|attr| {new_op.set_attr_string("padding", attr)})(&self.padding)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct Dilation2DBackpropInput<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    input: Edge<T>,
    filter: Edge<T>,
    out_backprop: Edge<T>,
    strides: Vec<i64>,
    rates: Vec<i64>,
    padding: String,
    op_name: Option<String>,
    id_: usize,
}

impl<T> Dilation2DBackpropInput<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
{
    pub fn in_backprop(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(input: Edge<T>, filter: Edge<T>, out_backprop: Edge<T>, strides: &[i64], rates: &[i64], padding: &str) -> Self {
        Self {
            phantom_T: PhantomData,
            input,
            filter,
            out_backprop,
            strides: strides.to_vec(),
            rates: rates.to_vec(),
            padding: padding.to_string(),
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(input: Edge<T>, filter: Edge<T>, out_backprop: Edge<T>, strides: &[i64], rates: &[i64], padding: &str) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            input,
            filter,
            out_backprop,
            strides: strides.to_vec(),
            rates: rates.to_vec(),
            padding: padding.to_string(),
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<T, Targmax> GraphOperation for MaxPoolGradGradWithArgmax<T, Targmax>
where T: TensorType,
      T: Clone,
      Targmax: TensorType,
      Targmax: Clone,
      Targmax: con_or_DT_INT32_or_DT_INT64,
      Targmax: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("MaxPoolGradGradWithArgmax_{}")?
        };
        let mut new_op = graph.new_operation("MaxPoolGradGradWithArgmax", &op_name)?;
        {
            new_op.add_edge(&self.input)?
        }
        {
            new_op.add_edge(&self.grad)?
        }
        {
            new_op.add_edge(&self.argmax)?
        }
        {
            (|attrs| {new_op.set_attr_int_list("ksize", attrs)})(&self.ksize)?
        }
        {
            (|attrs| {new_op.set_attr_int_list("strides", attrs)})(&self.strides)?
        }
        {
            (|attr| {new_op.set_attr_string("padding", attr)})(&self.padding)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct MaxPoolGradGradWithArgmax<T, Targmax>
where T: TensorType,
      T: Clone,
      Targmax: TensorType,
      Targmax: Clone,
      Targmax: con_or_DT_INT32_or_DT_INT64,
      Targmax: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    input: Edge<T>,
    grad: Edge<T>,
    phantom_Targmax: PhantomData<Targmax>,
    argmax: Edge<Targmax>,
    ksize: Vec<i64>,
    strides: Vec<i64>,
    padding: String,
    op_name: Option<String>,
    id_: usize,
}

impl<T, Targmax> MaxPoolGradGradWithArgmax<T, Targmax>
where T: TensorType,
      T: Clone,
      Targmax: TensorType,
      Targmax: Clone,
      Targmax: con_or_DT_INT32_or_DT_INT64,
      Targmax: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
{
    pub fn output(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(input: Edge<T>, grad: Edge<T>, argmax: Edge<Targmax>, ksize: &[i64], strides: &[i64], padding: &str) -> Self {
        Self {
            phantom_T: PhantomData,
            input,
            grad,
            phantom_Targmax: PhantomData,
            argmax,
            ksize: ksize.to_vec(),
            strides: strides.to_vec(),
            padding: padding.to_string(),
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(input: Edge<T>, grad: Edge<T>, argmax: Edge<Targmax>, ksize: &[i64], strides: &[i64], padding: &str) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            input,
            grad,
            phantom_Targmax: PhantomData,
            argmax,
            ksize: ksize.to_vec(),
            strides: strides.to_vec(),
            padding: padding.to_string(),
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<T, Targmax> GraphOperation for MaxPoolGradWithArgmax<T, Targmax>
where T: TensorType,
      T: Clone,
      Targmax: TensorType,
      Targmax: Clone,
      Targmax: con_or_DT_INT32_or_DT_INT64,
      Targmax: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("MaxPoolGradWithArgmax_{}")?
        };
        let mut new_op = graph.new_operation("MaxPoolGradWithArgmax", &op_name)?;
        {
            new_op.add_edge(&self.input)?
        }
        {
            new_op.add_edge(&self.grad)?
        }
        {
            new_op.add_edge(&self.argmax)?
        }
        {
            (|attrs| {new_op.set_attr_int_list("ksize", attrs)})(&self.ksize)?
        }
        {
            (|attrs| {new_op.set_attr_int_list("strides", attrs)})(&self.strides)?
        }
        {
            (|attr| {new_op.set_attr_string("padding", attr)})(&self.padding)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct MaxPoolGradWithArgmax<T, Targmax>
where T: TensorType,
      T: Clone,
      Targmax: TensorType,
      Targmax: Clone,
      Targmax: con_or_DT_INT32_or_DT_INT64,
      Targmax: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    input: Edge<T>,
    grad: Edge<T>,
    phantom_Targmax: PhantomData<Targmax>,
    argmax: Edge<Targmax>,
    ksize: Vec<i64>,
    strides: Vec<i64>,
    padding: String,
    op_name: Option<String>,
    id_: usize,
}

impl<T, Targmax> MaxPoolGradWithArgmax<T, Targmax>
where T: TensorType,
      T: Clone,
      Targmax: TensorType,
      Targmax: Clone,
      Targmax: con_or_DT_INT32_or_DT_INT64,
      Targmax: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
{
    pub fn output(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(input: Edge<T>, grad: Edge<T>, argmax: Edge<Targmax>, ksize: &[i64], strides: &[i64], padding: &str) -> Self {
        Self {
            phantom_T: PhantomData,
            input,
            grad,
            phantom_Targmax: PhantomData,
            argmax,
            ksize: ksize.to_vec(),
            strides: strides.to_vec(),
            padding: padding.to_string(),
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(input: Edge<T>, grad: Edge<T>, argmax: Edge<Targmax>, ksize: &[i64], strides: &[i64], padding: &str) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            input,
            grad,
            phantom_Targmax: PhantomData,
            argmax,
            ksize: ksize.to_vec(),
            strides: strides.to_vec(),
            padding: padding.to_string(),
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<out_type> GraphOperation for ParseTensor<out_type>
where out_type: TensorType,
      out_type: 'static,
      out_type: Clone,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("ParseTensor_{}")?
        };
        let mut new_op = graph.new_operation("ParseTensor", &op_name)?;
        {
            new_op.add_edge(&self.serialized)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct ParseTensor<out_type>
where out_type: TensorType,
      out_type: 'static,
      out_type: Clone,
{
    serialized: Edge<String>,
    phantom_out_type: PhantomData<out_type>,
    op_name: Option<String>,
    id_: usize,
}

impl<out_type> ParseTensor<out_type>
where out_type: TensorType,
      out_type: 'static,
      out_type: Clone,
{
    pub fn output(self) -> Edge<out_type> {
        let rc = Rc::new(self);
        {
            Edge::<out_type>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<out_type> {
        let rc = Rc::new(self);
        {
            Edge::<out_type>::new(rc.clone(), 0)
        }
    }

    pub fn build(serialized: Edge<String>) -> Self {
        Self {
            serialized,
            phantom_out_type: PhantomData,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(serialized: Edge<String>) -> Edge<out_type> {
        Self {
            serialized,
            phantom_out_type: PhantomData,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<T, Targmax> GraphOperation for MaxPoolWithArgmax<T, Targmax>
where T: TensorType,
      T: Clone,
      Targmax: TensorType,
      Targmax: con_or_DT_INT32_or_DT_INT64,
      Targmax: 'static,
      Targmax: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("MaxPoolWithArgmax_{}")?
        };
        let mut new_op = graph.new_operation("MaxPoolWithArgmax", &op_name)?;
        {
            new_op.add_edge(&self.input)?
        }
        {
            (|attrs| {new_op.set_attr_int_list("ksize", attrs)})(&self.ksize)?
        }
        {
            (|attrs| {new_op.set_attr_int_list("strides", attrs)})(&self.strides)?
        }
        {
            (|attr| {new_op.set_attr_string("padding", attr)})(&self.padding)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct MaxPoolWithArgmax<T, Targmax>
where T: TensorType,
      T: Clone,
      Targmax: TensorType,
      Targmax: con_or_DT_INT32_or_DT_INT64,
      Targmax: 'static,
      Targmax: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    input: Edge<T>,
    ksize: Vec<i64>,
    strides: Vec<i64>,
    phantom_Targmax: PhantomData<Targmax>,
    padding: String,
    op_name: Option<String>,
    id_: usize,
}

impl<T, Targmax> MaxPoolWithArgmax<T, Targmax>
where T: TensorType,
      T: Clone,
      Targmax: TensorType,
      Targmax: con_or_DT_INT32_or_DT_INT64,
      Targmax: 'static,
      Targmax: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
{
    pub fn output(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn argmax(self) -> Edge<Targmax> {
        let rc = Rc::new(self);
        {
            Edge::<Targmax>::new(rc.clone(), 1)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> (Edge<T>, Edge<Targmax>) {
        let rc = Rc::new(self);
        (
        {
            Edge::<T>::new(rc.clone(), 0)
        },
        {
            Edge::<Targmax>::new(rc.clone(), 1)
        },
        )
    }

    pub fn build(input: Edge<T>, ksize: &[i64], strides: &[i64], padding: &str) -> Self {
        Self {
            phantom_T: PhantomData,
            input,
            ksize: ksize.to_vec(),
            strides: strides.to_vec(),
            phantom_Targmax: PhantomData,
            padding: padding.to_string(),
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(input: Edge<T>, ksize: &[i64], strides: &[i64], padding: &str) -> (Edge<T>, Edge<Targmax>) {
        Self {
            phantom_T: PhantomData,
            input,
            ksize: ksize.to_vec(),
            strides: strides.to_vec(),
            phantom_Targmax: PhantomData,
            padding: padding.to_string(),
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<T> GraphOperation for MaxPoolGradGradV2<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("MaxPoolGradGradV2_{}")?
        };
        let mut new_op = graph.new_operation("MaxPoolGradGradV2", &op_name)?;
        {
            new_op.add_edge(&self.orig_input)?
        }
        {
            new_op.add_edge(&self.orig_output)?
        }
        {
            new_op.add_edge(&self.grad)?
        }
        {
            new_op.add_edge(&self.ksize)?
        }
        {
            new_op.add_edge(&self.strides)?
        }
        {
            (|attr| {new_op.set_attr_string("padding", attr)})(&self.padding)?
        }
        {
            match self.data_format {
                None => new_op.set_attr_value_proto("data_format", &vec![18_u8, 4_u8, 78_u8, 72_u8, 87_u8, 67_u8,])?,
                Some(ref value) => (|attr| {new_op.set_attr_string("data_format", attr)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct MaxPoolGradGradV2<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    orig_input: Edge<T>,
    orig_output: Edge<T>,
    grad: Edge<T>,
    ksize: Edge<i32>,
    strides: Edge<i32>,
    padding: String,
    data_format: Option<String>,
    op_name: Option<String>,
    id_: usize,
}

impl<T> MaxPoolGradGradV2<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
{
    pub fn output(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn data_format(&mut self, data_format: &str) -> Self {
        self.data_format = Some(data_format.to_string());
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(orig_input: Edge<T>, orig_output: Edge<T>, grad: Edge<T>, ksize: Edge<i32>, strides: Edge<i32>, padding: &str) -> Self {
        Self {
            phantom_T: PhantomData,
            orig_input,
            orig_output,
            grad,
            ksize,
            strides,
            padding: padding.to_string(),
            data_format: None,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(orig_input: Edge<T>, orig_output: Edge<T>, grad: Edge<T>, ksize: Edge<i32>, strides: Edge<i32>, padding: &str) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            orig_input,
            orig_output,
            grad,
            ksize,
            strides,
            padding: padding.to_string(),
            data_format: None,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<T> GraphOperation for MaxPoolGrad<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("MaxPoolGrad_{}")?
        };
        let mut new_op = graph.new_operation("MaxPoolGrad", &op_name)?;
        {
            new_op.add_edge(&self.orig_input)?
        }
        {
            new_op.add_edge(&self.orig_output)?
        }
        {
            new_op.add_edge(&self.grad)?
        }
        {
            (|attrs| {new_op.set_attr_int_list("ksize", attrs)})(&self.ksize)?
        }
        {
            (|attrs| {new_op.set_attr_int_list("strides", attrs)})(&self.strides)?
        }
        {
            (|attr| {new_op.set_attr_string("padding", attr)})(&self.padding)?
        }
        {
            match self.data_format {
                None => new_op.set_attr_value_proto("data_format", &vec![18_u8, 4_u8, 78_u8, 72_u8, 87_u8, 67_u8,])?,
                Some(ref value) => (|attr| {new_op.set_attr_string("data_format", attr)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct MaxPoolGrad<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    orig_input: Edge<T>,
    orig_output: Edge<T>,
    grad: Edge<T>,
    ksize: Vec<i64>,
    strides: Vec<i64>,
    padding: String,
    data_format: Option<String>,
    op_name: Option<String>,
    id_: usize,
}

impl<T> MaxPoolGrad<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
{
    pub fn output(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn data_format(&mut self, data_format: &str) -> Self {
        self.data_format = Some(data_format.to_string());
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(orig_input: Edge<T>, orig_output: Edge<T>, grad: Edge<T>, ksize: &[i64], strides: &[i64], padding: &str) -> Self {
        Self {
            phantom_T: PhantomData,
            orig_input,
            orig_output,
            grad,
            ksize: ksize.to_vec(),
            strides: strides.to_vec(),
            padding: padding.to_string(),
            data_format: None,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(orig_input: Edge<T>, orig_output: Edge<T>, grad: Edge<T>, ksize: &[i64], strides: &[i64], padding: &str) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            orig_input,
            orig_output,
            grad,
            ksize: ksize.to_vec(),
            strides: strides.to_vec(),
            padding: padding.to_string(),
            data_format: None,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

pub trait con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_QINT8_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_QINT8_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF for BFloat16 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_QINT8_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF for f32 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_QINT8_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF for f64 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_QINT8_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF for i16 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_QINT8_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF for i32 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_QINT8_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF for i64 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_QINT8_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF for i8 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_QINT8_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF for u16 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_QINT8_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF for u8 {
}

impl<T> GraphOperation for MaxPool<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_QINT8_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF,
      T: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("MaxPool_{}")?
        };
        let mut new_op = graph.new_operation("MaxPool", &op_name)?;
        {
            new_op.add_edge(&self.input)?
        }
        {
            (|attrs| {new_op.set_attr_int_list("ksize", attrs)})(&self.ksize)?
        }
        {
            (|attrs| {new_op.set_attr_int_list("strides", attrs)})(&self.strides)?
        }
        {
            (|attr| {new_op.set_attr_string("padding", attr)})(&self.padding)?
        }
        {
            match self.data_format {
                None => new_op.set_attr_value_proto("data_format", &vec![18_u8, 4_u8, 78_u8, 72_u8, 87_u8, 67_u8,])?,
                Some(ref value) => (|attr| {new_op.set_attr_string("data_format", attr)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct MaxPool<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_QINT8_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    input: Edge<T>,
    ksize: Vec<i64>,
    strides: Vec<i64>,
    padding: String,
    data_format: Option<String>,
    op_name: Option<String>,
    id_: usize,
}

impl<T> MaxPool<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_QINT8_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF,
      T: 'static,
{
    pub fn output(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn data_format(&mut self, data_format: &str) -> Self {
        self.data_format = Some(data_format.to_string());
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(input: Edge<T>, ksize: &[i64], strides: &[i64], padding: &str) -> Self {
        Self {
            phantom_T: PhantomData,
            input,
            ksize: ksize.to_vec(),
            strides: strides.to_vec(),
            padding: padding.to_string(),
            data_format: None,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(input: Edge<T>, ksize: &[i64], strides: &[i64], padding: &str) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            input,
            ksize: ksize.to_vec(),
            strides: strides.to_vec(),
            padding: padding.to_string(),
            data_format: None,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

pub trait con_or_DT_FLOAT_or_DT_BFLOAT16_or_DT_HALF {
}

impl con_or_DT_FLOAT_or_DT_BFLOAT16_or_DT_HALF for BFloat16 {
}

impl con_or_DT_FLOAT_or_DT_BFLOAT16_or_DT_HALF for f32 {
}

impl<T> GraphOperation for LRN<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_BFLOAT16_or_DT_HALF,
      T: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("LRN_{}")?
        };
        let mut new_op = graph.new_operation("LRN", &op_name)?;
        {
            new_op.add_edge(&self.input)?
        }
        {
            match self.depth_radius {
                None => new_op.set_attr_value_proto("depth_radius", &vec![24_u8, 5_u8,])?,
                Some(ref value) => (|attr: &i64| {new_op.set_attr_int("depth_radius", *attr)})(&value)?,
            };
        }
        {
            match self.bias {
                None => new_op.set_attr_value_proto("bias", &vec![37_u8, 0_u8, 0_u8, 128_u8, 63_u8,])?,
                Some(ref value) => (|attr: &f32| {new_op.set_attr_float("bias", *attr)})(&value)?,
            };
        }
        {
            match self.alpha {
                None => new_op.set_attr_value_proto("alpha", &vec![37_u8, 0_u8, 0_u8, 128_u8, 63_u8,])?,
                Some(ref value) => (|attr: &f32| {new_op.set_attr_float("alpha", *attr)})(&value)?,
            };
        }
        {
            match self.beta {
                None => new_op.set_attr_value_proto("beta", &vec![37_u8, 0_u8, 0_u8, 0_u8, 63_u8,])?,
                Some(ref value) => (|attr: &f32| {new_op.set_attr_float("beta", *attr)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct LRN<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_BFLOAT16_or_DT_HALF,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    input: Edge<T>,
    depth_radius: Option<i64>,
    bias: Option<f32>,
    alpha: Option<f32>,
    beta: Option<f32>,
    op_name: Option<String>,
    id_: usize,
}

impl<T> LRN<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_BFLOAT16_or_DT_HALF,
      T: 'static,
{
    pub fn output(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn depth_radius(&mut self, depth_radius: i64) -> Self {
        self.depth_radius = Some(depth_radius);
        self.clone()
    }

    pub fn bias(&mut self, bias: f32) -> Self {
        self.bias = Some(bias);
        self.clone()
    }

    pub fn alpha(&mut self, alpha: f32) -> Self {
        self.alpha = Some(alpha);
        self.clone()
    }

    pub fn beta(&mut self, beta: f32) -> Self {
        self.beta = Some(beta);
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(input: Edge<T>) -> Self {
        Self {
            phantom_T: PhantomData,
            input,
            depth_radius: None,
            bias: None,
            alpha: None,
            beta: None,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(input: Edge<T>) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            input,
            depth_radius: None,
            bias: None,
            alpha: None,
            beta: None,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<T> GraphOperation for DenseToSparseSetOperation<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_STRING_or_DT_INT64_or_DT_UINT16,
      T: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("DenseToSparseSetOperation_{}")?
        };
        let mut new_op = graph.new_operation("DenseToSparseSetOperation", &op_name)?;
        {
            new_op.add_edge(&self.set1)?
        }
        {
            new_op.add_edge(&self.set2_indices)?
        }
        {
            new_op.add_edge(&self.set2_values)?
        }
        {
            new_op.add_edge(&self.set2_shape)?
        }
        {
            (|attr| {new_op.set_attr_string("set_operation", attr)})(&self.set_operation)?
        }
        {
            match self.validate_indices {
                None => new_op.set_attr_value_proto("validate_indices", &vec![40_u8, 1_u8,])?,
                Some(ref value) => (|attr: &bool| {new_op.set_attr_bool("validate_indices", *attr)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct DenseToSparseSetOperation<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_STRING_or_DT_INT64_or_DT_UINT16,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    set1: Edge<T>,
    set2_indices: Edge<i64>,
    set2_values: Edge<T>,
    set2_shape: Edge<i64>,
    set_operation: String,
    validate_indices: Option<bool>,
    op_name: Option<String>,
    id_: usize,
}

impl<T> DenseToSparseSetOperation<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_STRING_or_DT_INT64_or_DT_UINT16,
      T: 'static,
{
    pub fn result_indices(self) -> Edge<i64> {
        let rc = Rc::new(self);
        {
            Edge::<i64>::new(rc.clone(), 0)
        }
    }

    pub fn result_values(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 1)
        }
    }

    pub fn result_shape(self) -> Edge<i64> {
        let rc = Rc::new(self);
        {
            Edge::<i64>::new(rc.clone(), 2)
        }
    }

    pub fn validate_indices(&mut self, validate_indices: bool) -> Self {
        self.validate_indices = Some(validate_indices);
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> (Edge<i64>, Edge<T>, Edge<i64>) {
        let rc = Rc::new(self);
        (
        {
            Edge::<i64>::new(rc.clone(), 0)
        },
        {
            Edge::<T>::new(rc.clone(), 1)
        },
        {
            Edge::<i64>::new(rc.clone(), 2)
        },
        )
    }

    pub fn build(set1: Edge<T>, set2_indices: Edge<i64>, set2_values: Edge<T>, set2_shape: Edge<i64>, set_operation: &str) -> Self {
        Self {
            phantom_T: PhantomData,
            set1,
            set2_indices,
            set2_values,
            set2_shape,
            set_operation: set_operation.to_string(),
            validate_indices: None,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(set1: Edge<T>, set2_indices: Edge<i64>, set2_values: Edge<T>, set2_shape: Edge<i64>, set_operation: &str) -> (Edge<i64>, Edge<T>, Edge<i64>) {
        Self {
            phantom_T: PhantomData,
            set1,
            set2_indices,
            set2_values,
            set2_shape,
            set_operation: set_operation.to_string(),
            validate_indices: None,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<T> GraphOperation for L2Loss<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
      T: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("L2Loss_{}")?
        };
        let mut new_op = graph.new_operation("L2Loss", &op_name)?;
        {
            new_op.add_edge(&self.t)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct L2Loss<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    t: Edge<T>,
    op_name: Option<String>,
    id_: usize,
}

impl<T> L2Loss<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
      T: 'static,
{
    pub fn output(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(t: Edge<T>) -> Self {
        Self {
            phantom_T: PhantomData,
            t,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(t: Edge<T>) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            t,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<TInput, T> GraphOperation for MaxPool3DGrad<TInput, T>
where TInput: TensorType,
      TInput: Clone,
      T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_BFLOAT16_or_DT_HALF,
      T: 'static,
      TInput: con_or_DT_FLOAT_or_DT_BFLOAT16_or_DT_HALF,
      TInput: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("MaxPool3DGrad_{}")?
        };
        let mut new_op = graph.new_operation("MaxPool3DGrad", &op_name)?;
        {
            new_op.add_edge(&self.orig_input)?
        }
        {
            new_op.add_edge(&self.orig_output)?
        }
        {
            new_op.add_edge(&self.grad)?
        }
        {
            (|attrs| {new_op.set_attr_int_list("ksize", attrs)})(&self.ksize)?
        }
        {
            (|attrs| {new_op.set_attr_int_list("strides", attrs)})(&self.strides)?
        }
        {
            (|attr| {new_op.set_attr_string("padding", attr)})(&self.padding)?
        }
        {
            match self.data_format {
                None => new_op.set_attr_value_proto("data_format", &vec![18_u8, 5_u8, 78_u8, 68_u8, 72_u8, 87_u8, 67_u8,])?,
                Some(ref value) => (|attr| {new_op.set_attr_string("data_format", attr)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct MaxPool3DGrad<TInput, T>
where TInput: TensorType,
      TInput: Clone,
      T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_BFLOAT16_or_DT_HALF,
      T: 'static,
      TInput: con_or_DT_FLOAT_or_DT_BFLOAT16_or_DT_HALF,
      TInput: 'static,
{
    phantom_TInput: PhantomData<TInput>,
    orig_input: Edge<TInput>,
    orig_output: Edge<TInput>,
    phantom_T: PhantomData<T>,
    grad: Edge<T>,
    ksize: Vec<i64>,
    strides: Vec<i64>,
    padding: String,
    data_format: Option<String>,
    op_name: Option<String>,
    id_: usize,
}

impl<TInput, T> MaxPool3DGrad<TInput, T>
where TInput: TensorType,
      TInput: Clone,
      T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_BFLOAT16_or_DT_HALF,
      T: 'static,
      TInput: con_or_DT_FLOAT_or_DT_BFLOAT16_or_DT_HALF,
      TInput: 'static,
{
    pub fn output(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn data_format(&mut self, data_format: &str) -> Self {
        self.data_format = Some(data_format.to_string());
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(orig_input: Edge<TInput>, orig_output: Edge<TInput>, grad: Edge<T>, ksize: &[i64], strides: &[i64], padding: &str) -> Self {
        Self {
            phantom_TInput: PhantomData,
            orig_input,
            orig_output,
            phantom_T: PhantomData,
            grad,
            ksize: ksize.to_vec(),
            strides: strides.to_vec(),
            padding: padding.to_string(),
            data_format: None,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(orig_input: Edge<TInput>, orig_output: Edge<TInput>, grad: Edge<T>, ksize: &[i64], strides: &[i64], padding: &str) -> Edge<T> {
        Self {
            phantom_TInput: PhantomData,
            orig_input,
            orig_output,
            phantom_T: PhantomData,
            grad,
            ksize: ksize.to_vec(),
            strides: strides.to_vec(),
            padding: padding.to_string(),
            data_format: None,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<T> GraphOperation for ApplyGradientDescent<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("ApplyGradientDescent_{}")?
        };
        let mut new_op = graph.new_operation("ApplyGradientDescent", &op_name)?;
        {
            new_op.add_edge(&self.var)?
        }
        {
            new_op.add_edge(&self.alpha)?
        }
        {
            new_op.add_edge(&self.delta)?
        }
        {
            match self.use_locking {
                None => new_op.set_attr_value_proto("use_locking", &vec![40_u8, 0_u8,])?,
                Some(ref value) => (|attr: &bool| {new_op.set_attr_bool("use_locking", *attr)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct ApplyGradientDescent<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    var: Edge<T>,
    alpha: Edge<T>,
    delta: Edge<T>,
    use_locking: Option<bool>,
    op_name: Option<String>,
    id_: usize,
}

impl<T> ApplyGradientDescent<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
{
    pub fn out(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn use_locking(&mut self, use_locking: bool) -> Self {
        self.use_locking = Some(use_locking);
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(var: Edge<T>, alpha: Edge<T>, delta: Edge<T>) -> Self {
        Self {
            phantom_T: PhantomData,
            var,
            alpha,
            delta,
            use_locking: None,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(var: Edge<T>, alpha: Edge<T>, delta: Edge<T>) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            var,
            alpha,
            delta,
            use_locking: None,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<T> GraphOperation for MaxPool3D<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_BFLOAT16_or_DT_HALF,
      T: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("MaxPool3D_{}")?
        };
        let mut new_op = graph.new_operation("MaxPool3D", &op_name)?;
        {
            new_op.add_edge(&self.input)?
        }
        {
            (|attrs| {new_op.set_attr_int_list("ksize", attrs)})(&self.ksize)?
        }
        {
            (|attrs| {new_op.set_attr_int_list("strides", attrs)})(&self.strides)?
        }
        {
            (|attr| {new_op.set_attr_string("padding", attr)})(&self.padding)?
        }
        {
            match self.data_format {
                None => new_op.set_attr_value_proto("data_format", &vec![18_u8, 5_u8, 78_u8, 68_u8, 72_u8, 87_u8, 67_u8,])?,
                Some(ref value) => (|attr| {new_op.set_attr_string("data_format", attr)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct MaxPool3D<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_BFLOAT16_or_DT_HALF,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    input: Edge<T>,
    ksize: Vec<i64>,
    strides: Vec<i64>,
    padding: String,
    data_format: Option<String>,
    op_name: Option<String>,
    id_: usize,
}

impl<T> MaxPool3D<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_BFLOAT16_or_DT_HALF,
      T: 'static,
{
    pub fn output(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn data_format(&mut self, data_format: &str) -> Self {
        self.data_format = Some(data_format.to_string());
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(input: Edge<T>, ksize: &[i64], strides: &[i64], padding: &str) -> Self {
        Self {
            phantom_T: PhantomData,
            input,
            ksize: ksize.to_vec(),
            strides: strides.to_vec(),
            padding: padding.to_string(),
            data_format: None,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(input: Edge<T>, ksize: &[i64], strides: &[i64], padding: &str) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            input,
            ksize: ksize.to_vec(),
            strides: strides.to_vec(),
            padding: padding.to_string(),
            data_format: None,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<T> GraphOperation for AvgPool3D<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
      T: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("AvgPool3D_{}")?
        };
        let mut new_op = graph.new_operation("AvgPool3D", &op_name)?;
        {
            new_op.add_edge(&self.input)?
        }
        {
            (|attrs| {new_op.set_attr_int_list("ksize", attrs)})(&self.ksize)?
        }
        {
            (|attrs| {new_op.set_attr_int_list("strides", attrs)})(&self.strides)?
        }
        {
            (|attr| {new_op.set_attr_string("padding", attr)})(&self.padding)?
        }
        {
            match self.data_format {
                None => new_op.set_attr_value_proto("data_format", &vec![18_u8, 5_u8, 78_u8, 68_u8, 72_u8, 87_u8, 67_u8,])?,
                Some(ref value) => (|attr| {new_op.set_attr_string("data_format", attr)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct AvgPool3D<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    input: Edge<T>,
    ksize: Vec<i64>,
    strides: Vec<i64>,
    padding: String,
    data_format: Option<String>,
    op_name: Option<String>,
    id_: usize,
}

impl<T> AvgPool3D<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
      T: 'static,
{
    pub fn output(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn data_format(&mut self, data_format: &str) -> Self {
        self.data_format = Some(data_format.to_string());
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(input: Edge<T>, ksize: &[i64], strides: &[i64], padding: &str) -> Self {
        Self {
            phantom_T: PhantomData,
            input,
            ksize: ksize.to_vec(),
            strides: strides.to_vec(),
            padding: padding.to_string(),
            data_format: None,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(input: Edge<T>, ksize: &[i64], strides: &[i64], padding: &str) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            input,
            ksize: ksize.to_vec(),
            strides: strides.to_vec(),
            padding: padding.to_string(),
            data_format: None,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<T> GraphOperation for MaxPool3DGradGrad<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("MaxPool3DGradGrad_{}")?
        };
        let mut new_op = graph.new_operation("MaxPool3DGradGrad", &op_name)?;
        {
            new_op.add_edge(&self.orig_input)?
        }
        {
            new_op.add_edge(&self.orig_output)?
        }
        {
            new_op.add_edge(&self.grad)?
        }
        {
            (|attrs| {new_op.set_attr_int_list("ksize", attrs)})(&self.ksize)?
        }
        {
            (|attrs| {new_op.set_attr_int_list("strides", attrs)})(&self.strides)?
        }
        {
            (|attr| {new_op.set_attr_string("padding", attr)})(&self.padding)?
        }
        {
            match self.data_format {
                None => new_op.set_attr_value_proto("data_format", &vec![18_u8, 5_u8, 78_u8, 68_u8, 72_u8, 87_u8, 67_u8,])?,
                Some(ref value) => (|attr| {new_op.set_attr_string("data_format", attr)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct MaxPool3DGradGrad<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    orig_input: Edge<T>,
    orig_output: Edge<T>,
    grad: Edge<T>,
    ksize: Vec<i64>,
    strides: Vec<i64>,
    padding: String,
    data_format: Option<String>,
    op_name: Option<String>,
    id_: usize,
}

impl<T> MaxPool3DGradGrad<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
{
    pub fn output(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn data_format(&mut self, data_format: &str) -> Self {
        self.data_format = Some(data_format.to_string());
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(orig_input: Edge<T>, orig_output: Edge<T>, grad: Edge<T>, ksize: &[i64], strides: &[i64], padding: &str) -> Self {
        Self {
            phantom_T: PhantomData,
            orig_input,
            orig_output,
            grad,
            ksize: ksize.to_vec(),
            strides: strides.to_vec(),
            padding: padding.to_string(),
            data_format: None,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(orig_input: Edge<T>, orig_output: Edge<T>, grad: Edge<T>, ksize: &[i64], strides: &[i64], padding: &str) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            orig_input,
            orig_output,
            grad,
            ksize: ksize.to_vec(),
            strides: strides.to_vec(),
            padding: padding.to_string(),
            data_format: None,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<T> GraphOperation for Conv3DBackpropFilterV2<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
      T: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("Conv3DBackpropFilterV2_{}")?
        };
        let mut new_op = graph.new_operation("Conv3DBackpropFilterV2", &op_name)?;
        {
            new_op.add_edge(&self.input)?
        }
        {
            new_op.add_edge(&self.filter_sizes)?
        }
        {
            new_op.add_edge(&self.out_backprop)?
        }
        {
            (|attrs| {new_op.set_attr_int_list("strides", attrs)})(&self.strides)?
        }
        {
            (|attr| {new_op.set_attr_string("padding", attr)})(&self.padding)?
        }
        {
            match self.data_format {
                None => new_op.set_attr_value_proto("data_format", &vec![18_u8, 5_u8, 78_u8, 68_u8, 72_u8, 87_u8, 67_u8,])?,
                Some(ref value) => (|attr| {new_op.set_attr_string("data_format", attr)})(&value)?,
            };
        }
        {
            match self.dilations {
                None => new_op.set_attr_value_proto("dilations", &vec![10_u8, 0_u8, 26_u8, 5_u8, 1_u8, 1_u8, 1_u8, 1_u8,])?,
                Some(ref value) => (|attrs| {new_op.set_attr_int_list("dilations", attrs)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct Conv3DBackpropFilterV2<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    input: Edge<T>,
    filter_sizes: Edge<i32>,
    out_backprop: Edge<T>,
    strides: Vec<i64>,
    padding: String,
    data_format: Option<String>,
    dilations: Option<Vec<i64>>,
    op_name: Option<String>,
    id_: usize,
}

impl<T> Conv3DBackpropFilterV2<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
      T: 'static,
{
    pub fn output(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn data_format(&mut self, data_format: &str) -> Self {
        self.data_format = Some(data_format.to_string());
        self.clone()
    }

    pub fn dilations(&mut self, dilations: &[i64]) -> Self {
        self.dilations = Some(dilations.to_vec());
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(input: Edge<T>, filter_sizes: Edge<i32>, out_backprop: Edge<T>, strides: &[i64], padding: &str) -> Self {
        Self {
            phantom_T: PhantomData,
            input,
            filter_sizes,
            out_backprop,
            strides: strides.to_vec(),
            padding: padding.to_string(),
            data_format: None,
            dilations: None,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(input: Edge<T>, filter_sizes: Edge<i32>, out_backprop: Edge<T>, strides: &[i64], padding: &str) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            input,
            filter_sizes,
            out_backprop,
            strides: strides.to_vec(),
            padding: padding.to_string(),
            data_format: None,
            dilations: None,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<T> GraphOperation for Conv3D<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
      T: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("Conv3D_{}")?
        };
        let mut new_op = graph.new_operation("Conv3D", &op_name)?;
        {
            new_op.add_edge(&self.input)?
        }
        {
            new_op.add_edge(&self.filter)?
        }
        {
            (|attrs| {new_op.set_attr_int_list("strides", attrs)})(&self.strides)?
        }
        {
            (|attr| {new_op.set_attr_string("padding", attr)})(&self.padding)?
        }
        {
            match self.data_format {
                None => new_op.set_attr_value_proto("data_format", &vec![18_u8, 5_u8, 78_u8, 68_u8, 72_u8, 87_u8, 67_u8,])?,
                Some(ref value) => (|attr| {new_op.set_attr_string("data_format", attr)})(&value)?,
            };
        }
        {
            match self.dilations {
                None => new_op.set_attr_value_proto("dilations", &vec![10_u8, 0_u8, 26_u8, 5_u8, 1_u8, 1_u8, 1_u8, 1_u8,])?,
                Some(ref value) => (|attrs| {new_op.set_attr_int_list("dilations", attrs)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct Conv3D<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    input: Edge<T>,
    filter: Edge<T>,
    strides: Vec<i64>,
    padding: String,
    data_format: Option<String>,
    dilations: Option<Vec<i64>>,
    op_name: Option<String>,
    id_: usize,
}

impl<T> Conv3D<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
      T: 'static,
{
    pub fn output(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn data_format(&mut self, data_format: &str) -> Self {
        self.data_format = Some(data_format.to_string());
        self.clone()
    }

    pub fn dilations(&mut self, dilations: &[i64]) -> Self {
        self.dilations = Some(dilations.to_vec());
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(input: Edge<T>, filter: Edge<T>, strides: &[i64], padding: &str) -> Self {
        Self {
            phantom_T: PhantomData,
            input,
            filter,
            strides: strides.to_vec(),
            padding: padding.to_string(),
            data_format: None,
            dilations: None,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(input: Edge<T>, filter: Edge<T>, strides: &[i64], padding: &str) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            input,
            filter,
            strides: strides.to_vec(),
            padding: padding.to_string(),
            data_format: None,
            dilations: None,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<T> GraphOperation for DepthwiseConv2dNativeBackpropFilter<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
      T: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("DepthwiseConv2dNativeBackpropFilter_{}")?
        };
        let mut new_op = graph.new_operation("DepthwiseConv2dNativeBackpropFilter", &op_name)?;
        {
            new_op.add_edge(&self.input)?
        }
        {
            new_op.add_edge(&self.filter_sizes)?
        }
        {
            new_op.add_edge(&self.out_backprop)?
        }
        {
            (|attrs| {new_op.set_attr_int_list("strides", attrs)})(&self.strides)?
        }
        {
            (|attr| {new_op.set_attr_string("padding", attr)})(&self.padding)?
        }
        {
            match self.data_format {
                None => new_op.set_attr_value_proto("data_format", &vec![18_u8, 4_u8, 78_u8, 72_u8, 87_u8, 67_u8,])?,
                Some(ref value) => (|attr| {new_op.set_attr_string("data_format", attr)})(&value)?,
            };
        }
        {
            match self.dilations {
                None => new_op.set_attr_value_proto("dilations", &vec![10_u8, 0_u8, 26_u8, 4_u8,])?,
                Some(ref value) => (|attrs| {new_op.set_attr_int_list("dilations", attrs)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct DepthwiseConv2dNativeBackpropFilter<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    input: Edge<T>,
    filter_sizes: Edge<i32>,
    out_backprop: Edge<T>,
    strides: Vec<i64>,
    padding: String,
    data_format: Option<String>,
    dilations: Option<Vec<i64>>,
    op_name: Option<String>,
    id_: usize,
}

impl<T> DepthwiseConv2dNativeBackpropFilter<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
      T: 'static,
{
    pub fn output(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn data_format(&mut self, data_format: &str) -> Self {
        self.data_format = Some(data_format.to_string());
        self.clone()
    }

    pub fn dilations(&mut self, dilations: &[i64]) -> Self {
        self.dilations = Some(dilations.to_vec());
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(input: Edge<T>, filter_sizes: Edge<i32>, out_backprop: Edge<T>, strides: &[i64], padding: &str) -> Self {
        Self {
            phantom_T: PhantomData,
            input,
            filter_sizes,
            out_backprop,
            strides: strides.to_vec(),
            padding: padding.to_string(),
            data_format: None,
            dilations: None,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(input: Edge<T>, filter_sizes: Edge<i32>, out_backprop: Edge<T>, strides: &[i64], padding: &str) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            input,
            filter_sizes,
            out_backprop,
            strides: strides.to_vec(),
            padding: padding.to_string(),
            data_format: None,
            dilations: None,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<T> GraphOperation for DepthwiseConv2dNativeBackpropInput<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
      T: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("DepthwiseConv2dNativeBackpropInput_{}")?
        };
        let mut new_op = graph.new_operation("DepthwiseConv2dNativeBackpropInput", &op_name)?;
        {
            new_op.add_edge(&self.input_sizes)?
        }
        {
            new_op.add_edge(&self.filter)?
        }
        {
            new_op.add_edge(&self.out_backprop)?
        }
        {
            (|attrs| {new_op.set_attr_int_list("strides", attrs)})(&self.strides)?
        }
        {
            (|attr| {new_op.set_attr_string("padding", attr)})(&self.padding)?
        }
        {
            match self.data_format {
                None => new_op.set_attr_value_proto("data_format", &vec![18_u8, 4_u8, 78_u8, 72_u8, 87_u8, 67_u8,])?,
                Some(ref value) => (|attr| {new_op.set_attr_string("data_format", attr)})(&value)?,
            };
        }
        {
            match self.dilations {
                None => new_op.set_attr_value_proto("dilations", &vec![10_u8, 0_u8, 26_u8, 4_u8,])?,
                Some(ref value) => (|attrs| {new_op.set_attr_int_list("dilations", attrs)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct DepthwiseConv2dNativeBackpropInput<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
      T: 'static,
{
    input_sizes: Edge<i32>,
    phantom_T: PhantomData<T>,
    filter: Edge<T>,
    out_backprop: Edge<T>,
    strides: Vec<i64>,
    padding: String,
    data_format: Option<String>,
    dilations: Option<Vec<i64>>,
    op_name: Option<String>,
    id_: usize,
}

impl<T> DepthwiseConv2dNativeBackpropInput<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
      T: 'static,
{
    pub fn output(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn data_format(&mut self, data_format: &str) -> Self {
        self.data_format = Some(data_format.to_string());
        self.clone()
    }

    pub fn dilations(&mut self, dilations: &[i64]) -> Self {
        self.dilations = Some(dilations.to_vec());
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(input_sizes: Edge<i32>, filter: Edge<T>, out_backprop: Edge<T>, strides: &[i64], padding: &str) -> Self {
        Self {
            input_sizes,
            phantom_T: PhantomData,
            filter,
            out_backprop,
            strides: strides.to_vec(),
            padding: padding.to_string(),
            data_format: None,
            dilations: None,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(input_sizes: Edge<i32>, filter: Edge<T>, out_backprop: Edge<T>, strides: &[i64], padding: &str) -> Edge<T> {
        Self {
            input_sizes,
            phantom_T: PhantomData,
            filter,
            out_backprop,
            strides: strides.to_vec(),
            padding: padding.to_string(),
            data_format: None,
            dilations: None,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<T> GraphOperation for DepthwiseConv2dNative<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
      T: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("DepthwiseConv2dNative_{}")?
        };
        let mut new_op = graph.new_operation("DepthwiseConv2dNative", &op_name)?;
        {
            new_op.add_edge(&self.input)?
        }
        {
            new_op.add_edge(&self.filter)?
        }
        {
            (|attrs| {new_op.set_attr_int_list("strides", attrs)})(&self.strides)?
        }
        {
            (|attr| {new_op.set_attr_string("padding", attr)})(&self.padding)?
        }
        {
            match self.data_format {
                None => new_op.set_attr_value_proto("data_format", &vec![18_u8, 4_u8, 78_u8, 72_u8, 87_u8, 67_u8,])?,
                Some(ref value) => (|attr| {new_op.set_attr_string("data_format", attr)})(&value)?,
            };
        }
        {
            match self.dilations {
                None => new_op.set_attr_value_proto("dilations", &vec![10_u8, 0_u8, 26_u8, 4_u8,])?,
                Some(ref value) => (|attrs| {new_op.set_attr_int_list("dilations", attrs)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct DepthwiseConv2dNative<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    input: Edge<T>,
    filter: Edge<T>,
    strides: Vec<i64>,
    padding: String,
    data_format: Option<String>,
    dilations: Option<Vec<i64>>,
    op_name: Option<String>,
    id_: usize,
}

impl<T> DepthwiseConv2dNative<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
      T: 'static,
{
    pub fn output(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn data_format(&mut self, data_format: &str) -> Self {
        self.data_format = Some(data_format.to_string());
        self.clone()
    }

    pub fn dilations(&mut self, dilations: &[i64]) -> Self {
        self.dilations = Some(dilations.to_vec());
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(input: Edge<T>, filter: Edge<T>, strides: &[i64], padding: &str) -> Self {
        Self {
            phantom_T: PhantomData,
            input,
            filter,
            strides: strides.to_vec(),
            padding: padding.to_string(),
            data_format: None,
            dilations: None,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(input: Edge<T>, filter: Edge<T>, strides: &[i64], padding: &str) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            input,
            filter,
            strides: strides.to_vec(),
            padding: padding.to_string(),
            data_format: None,
            dilations: None,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

pub trait con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_HALF {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_HALF for f32 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_HALF for f64 {
}

impl<T> GraphOperation for FusedResizeAndPadConv2D<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_HALF,
      T: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("FusedResizeAndPadConv2D_{}")?
        };
        let mut new_op = graph.new_operation("FusedResizeAndPadConv2D", &op_name)?;
        {
            new_op.add_edge(&self.input)?
        }
        {
            new_op.add_edge(&self.size)?
        }
        {
            new_op.add_edge(&self.paddings)?
        }
        {
            new_op.add_edge(&self.filter)?
        }
        {
            match self.resize_align_corners {
                None => new_op.set_attr_value_proto("resize_align_corners", &vec![40_u8, 0_u8,])?,
                Some(ref value) => (|attr: &bool| {new_op.set_attr_bool("resize_align_corners", *attr)})(&value)?,
            };
        }
        {
            (|attr| {new_op.set_attr_string("mode", attr)})(&self.mode)?
        }
        {
            (|attrs| {new_op.set_attr_int_list("strides", attrs)})(&self.strides)?
        }
        {
            (|attr| {new_op.set_attr_string("padding", attr)})(&self.padding)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct FusedResizeAndPadConv2D<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_HALF,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    input: Edge<T>,
    size: Edge<i32>,
    paddings: Edge<i32>,
    filter: Edge<T>,
    resize_align_corners: Option<bool>,
    mode: String,
    strides: Vec<i64>,
    padding: String,
    op_name: Option<String>,
    id_: usize,
}

impl<T> FusedResizeAndPadConv2D<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_HALF,
      T: 'static,
{
    pub fn output(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn resize_align_corners(&mut self, resize_align_corners: bool) -> Self {
        self.resize_align_corners = Some(resize_align_corners);
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(input: Edge<T>, size: Edge<i32>, paddings: Edge<i32>, filter: Edge<T>, mode: &str, strides: &[i64], padding: &str) -> Self {
        Self {
            phantom_T: PhantomData,
            input,
            size,
            paddings,
            filter,
            resize_align_corners: None,
            mode: mode.to_string(),
            strides: strides.to_vec(),
            padding: padding.to_string(),
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(input: Edge<T>, size: Edge<i32>, paddings: Edge<i32>, filter: Edge<T>, mode: &str, strides: &[i64], padding: &str) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            input,
            size,
            paddings,
            filter,
            resize_align_corners: None,
            mode: mode.to_string(),
            strides: strides.to_vec(),
            padding: padding.to_string(),
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<T> GraphOperation for DataFormatVecPermute<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_INT32_or_DT_INT64,
      T: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("DataFormatVecPermute_{}")?
        };
        let mut new_op = graph.new_operation("DataFormatVecPermute", &op_name)?;
        {
            new_op.add_edge(&self.x)?
        }
        {
            match self.src_format {
                None => new_op.set_attr_value_proto("src_format", &vec![18_u8, 4_u8, 78_u8, 72_u8, 87_u8, 67_u8,])?,
                Some(ref value) => (|attr| {new_op.set_attr_string("src_format", attr)})(&value)?,
            };
        }
        {
            match self.dst_format {
                None => new_op.set_attr_value_proto("dst_format", &vec![18_u8, 4_u8, 78_u8, 67_u8, 72_u8, 87_u8,])?,
                Some(ref value) => (|attr| {new_op.set_attr_string("dst_format", attr)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct DataFormatVecPermute<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_INT32_or_DT_INT64,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    x: Edge<T>,
    src_format: Option<String>,
    dst_format: Option<String>,
    op_name: Option<String>,
    id_: usize,
}

impl<T> DataFormatVecPermute<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_INT32_or_DT_INT64,
      T: 'static,
{
    pub fn y(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn src_format(&mut self, src_format: &str) -> Self {
        self.src_format = Some(src_format.to_string());
        self.clone()
    }

    pub fn dst_format(&mut self, dst_format: &str) -> Self {
        self.dst_format = Some(dst_format.to_string());
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(x: Edge<T>) -> Self {
        Self {
            phantom_T: PhantomData,
            x,
            src_format: None,
            dst_format: None,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(x: Edge<T>) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            x,
            src_format: None,
            dst_format: None,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<T> GraphOperation for _FusedConv2D<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE,
      T: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("_FusedConv2D_{}")?
        };
        let mut new_op = graph.new_operation("_FusedConv2D", &op_name)?;
        {
            new_op.add_edge(&self.input)?
        }
        {
            new_op.add_edge(&self.filter)?
        }
        {
            new_op.add_edge(&self.args)?
        }
        {
            (|attr: &i64| {new_op.set_attr_int("num_args", *attr)})(&self.num_args)?
        }
        {
            (|attrs| {new_op.set_attr_int_list("strides", attrs)})(&self.strides)?
        }
        {
            (|attr| {new_op.set_attr_string("padding", attr)})(&self.padding)?
        }
        {
            match self.data_format {
                None => new_op.set_attr_value_proto("data_format", &vec![18_u8, 4_u8, 78_u8, 72_u8, 87_u8, 67_u8,])?,
                Some(ref value) => (|attr| {new_op.set_attr_string("data_format", attr)})(&value)?,
            };
        }
        {
            match self.dilations {
                None => new_op.set_attr_value_proto("dilations", &vec![10_u8, 0_u8, 26_u8, 4_u8,])?,
                Some(ref value) => (|attrs| {new_op.set_attr_int_list("dilations", attrs)})(&value)?,
            };
        }
        {
            match self.fused_ops {
                None => new_op.set_attr_value_proto("fused_ops", &vec![10_u8, 0_u8,])?,
                Some(ref value) => (|attrs| {new_op.set_attr_string_list("fused_ops", attrs)})(&value)?,
            };
        }
        {
            match self.epsilon {
                None => new_op.set_attr_value_proto("epsilon", &vec![37_u8, 23_u8, 183_u8, 209_u8, 56_u8,])?,
                Some(ref value) => (|attr: &f32| {new_op.set_attr_float("epsilon", *attr)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct _FusedConv2D<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    input: Edge<T>,
    filter: Edge<T>,
    args: Edge<T>,
    num_args: i64,
    strides: Vec<i64>,
    padding: String,
    data_format: Option<String>,
    dilations: Option<Vec<i64>>,
    fused_ops: Option<Vec<String>>,
    epsilon: Option<f32>,
    op_name: Option<String>,
    id_: usize,
}

impl<T> _FusedConv2D<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE,
      T: 'static,
{
    pub fn output(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn data_format(&mut self, data_format: &str) -> Self {
        self.data_format = Some(data_format.to_string());
        self.clone()
    }

    pub fn dilations(&mut self, dilations: &[i64]) -> Self {
        self.dilations = Some(dilations.to_vec());
        self.clone()
    }

    pub fn fused_ops(&mut self, fused_ops: &[String]) -> Self {
        self.fused_ops = Some(fused_ops.to_vec());
        self.clone()
    }

    pub fn epsilon(&mut self, epsilon: f32) -> Self {
        self.epsilon = Some(epsilon);
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(input: Edge<T>, filter: Edge<T>, args: Edge<T>, num_args: i64, strides: &[i64], padding: &str) -> Self {
        Self {
            phantom_T: PhantomData,
            input,
            filter,
            args,
            num_args: num_args,
            strides: strides.to_vec(),
            padding: padding.to_string(),
            data_format: None,
            dilations: None,
            fused_ops: None,
            epsilon: None,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(input: Edge<T>, filter: Edge<T>, args: Edge<T>, num_args: i64, strides: &[i64], padding: &str) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            input,
            filter,
            args,
            num_args: num_args,
            strides: strides.to_vec(),
            padding: padding.to_string(),
            data_format: None,
            dilations: None,
            fused_ops: None,
            epsilon: None,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<T> GraphOperation for Dilation2D<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("Dilation2D_{}")?
        };
        let mut new_op = graph.new_operation("Dilation2D", &op_name)?;
        {
            new_op.add_edge(&self.input)?
        }
        {
            new_op.add_edge(&self.filter)?
        }
        {
            (|attrs| {new_op.set_attr_int_list("strides", attrs)})(&self.strides)?
        }
        {
            (|attrs| {new_op.set_attr_int_list("rates", attrs)})(&self.rates)?
        }
        {
            (|attr| {new_op.set_attr_string("padding", attr)})(&self.padding)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct Dilation2D<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    input: Edge<T>,
    filter: Edge<T>,
    strides: Vec<i64>,
    rates: Vec<i64>,
    padding: String,
    op_name: Option<String>,
    id_: usize,
}

impl<T> Dilation2D<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
{
    pub fn output(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(input: Edge<T>, filter: Edge<T>, strides: &[i64], rates: &[i64], padding: &str) -> Self {
        Self {
            phantom_T: PhantomData,
            input,
            filter,
            strides: strides.to_vec(),
            rates: rates.to_vec(),
            padding: padding.to_string(),
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(input: Edge<T>, filter: Edge<T>, strides: &[i64], rates: &[i64], padding: &str) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            input,
            filter,
            strides: strides.to_vec(),
            rates: rates.to_vec(),
            padding: padding.to_string(),
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<dtype> GraphOperation for ConditionalAccumulator<dtype>
where dtype: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      dtype: 'static,
      dtype: Clone,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("ConditionalAccumulator_{}")?
        };
        let mut new_op = graph.new_operation("ConditionalAccumulator", &op_name)?;
        {
            (|attr| {new_op.set_attr_shape("shape", attr)})(&self.shape)?
        }
        {
            match self.container {
                None => new_op.set_attr_value_proto("container", &vec![18_u8, 0_u8,])?,
                Some(ref value) => (|attr| {new_op.set_attr_string("container", attr)})(&value)?,
            };
        }
        {
            match self.shared_name {
                None => new_op.set_attr_value_proto("shared_name", &vec![18_u8, 0_u8,])?,
                Some(ref value) => (|attr| {new_op.set_attr_string("shared_name", attr)})(&value)?,
            };
        }
        {
            match self.reduction_type {
                None => new_op.set_attr_value_proto("reduction_type", &vec![18_u8, 4_u8, 77_u8, 69_u8, 65_u8, 78_u8,])?,
                Some(ref value) => (|attr| {new_op.set_attr_string("reduction_type", attr)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct ConditionalAccumulator<dtype>
where dtype: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      dtype: 'static,
      dtype: Clone,
{
    phantom_dtype: PhantomData<dtype>,
    shape: OtherShape,
    container: Option<String>,
    shared_name: Option<String>,
    reduction_type: Option<String>,
    op_name: Option<String>,
    id_: usize,
}

impl<dtype> ConditionalAccumulator<dtype>
where dtype: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      dtype: 'static,
      dtype: Clone,
{
    pub fn handle(self) -> Edge<String> {
        let rc = Rc::new(self);
        {
            Edge::<String>::new(rc.clone(), 0)
        }
    }

    pub fn container(&mut self, container: &str) -> Self {
        self.container = Some(container.to_string());
        self.clone()
    }

    pub fn shared_name(&mut self, shared_name: &str) -> Self {
        self.shared_name = Some(shared_name.to_string());
        self.clone()
    }

    pub fn reduction_type(&mut self, reduction_type: &str) -> Self {
        self.reduction_type = Some(reduction_type.to_string());
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<String> {
        let rc = Rc::new(self);
        {
            Edge::<String>::new(rc.clone(), 0)
        }
    }

    pub fn build(shape: &OtherShape) -> Self {
        Self {
            phantom_dtype: PhantomData,
            shape: shape.clone(),
            container: None,
            shared_name: None,
            reduction_type: None,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(shape: &OtherShape) -> Edge<String> {
        Self {
            phantom_dtype: PhantomData,
            shape: shape.clone(),
            container: None,
            shared_name: None,
            reduction_type: None,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<dtype> GraphOperation for TensorArrayConcatV2<dtype>
where dtype: TensorType,
      dtype: 'static,
      dtype: Clone,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("TensorArrayConcatV2_{}")?
        };
        let mut new_op = graph.new_operation("TensorArrayConcatV2", &op_name)?;
        {
            new_op.add_edge(&self.handle)?
        }
        {
            new_op.add_edge(&self.flow_in)?
        }
        {
            match self.element_shape_except0 {
                None => new_op.set_attr_value_proto("element_shape_except0", &vec![58_u8, 0_u8,])?,
                Some(ref value) => (|attr| {new_op.set_attr_shape("element_shape_except0", attr)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct TensorArrayConcatV2<dtype>
where dtype: TensorType,
      dtype: 'static,
      dtype: Clone,
{
    handle: Edge<String>,
    flow_in: Edge<f32>,
    phantom_dtype: PhantomData<dtype>,
    element_shape_except0: Option<OtherShape>,
    op_name: Option<String>,
    id_: usize,
}

impl<dtype> TensorArrayConcatV2<dtype>
where dtype: TensorType,
      dtype: 'static,
      dtype: Clone,
{
    pub fn value(self) -> Edge<dtype> {
        let rc = Rc::new(self);
        {
            Edge::<dtype>::new(rc.clone(), 0)
        }
    }

    pub fn lengths(self) -> Edge<i64> {
        let rc = Rc::new(self);
        {
            Edge::<i64>::new(rc.clone(), 1)
        }
    }

    pub fn element_shape_except0(&mut self, element_shape_except0: &OtherShape) -> Self {
        self.element_shape_except0 = Some(element_shape_except0.clone());
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> (Edge<dtype>, Edge<i64>) {
        let rc = Rc::new(self);
        (
        {
            Edge::<dtype>::new(rc.clone(), 0)
        },
        {
            Edge::<i64>::new(rc.clone(), 1)
        },
        )
    }

    pub fn build(handle: Edge<String>, flow_in: Edge<f32>) -> Self {
        Self {
            handle,
            flow_in,
            phantom_dtype: PhantomData,
            element_shape_except0: None,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(handle: Edge<String>, flow_in: Edge<f32>) -> (Edge<dtype>, Edge<i64>) {
        Self {
            handle,
            flow_in,
            phantom_dtype: PhantomData,
            element_shape_except0: None,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<T> GraphOperation for TensorSummaryV2<T>
where T: TensorType,
      T: Clone,
      T: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("TensorSummaryV2_{}")?
        };
        let mut new_op = graph.new_operation("TensorSummaryV2", &op_name)?;
        {
            new_op.add_edge(&self.tag)?
        }
        {
            new_op.add_edge(&self.tensor)?
        }
        {
            new_op.add_edge(&self.serialized_summary_metadata)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct TensorSummaryV2<T>
where T: TensorType,
      T: Clone,
      T: 'static,
{
    tag: Edge<String>,
    phantom_T: PhantomData<T>,
    tensor: Edge<T>,
    serialized_summary_metadata: Edge<String>,
    op_name: Option<String>,
    id_: usize,
}

impl<T> TensorSummaryV2<T>
where T: TensorType,
      T: Clone,
      T: 'static,
{
    pub fn summary(self) -> Edge<String> {
        let rc = Rc::new(self);
        {
            Edge::<String>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<String> {
        let rc = Rc::new(self);
        {
            Edge::<String>::new(rc.clone(), 0)
        }
    }

    pub fn build(tag: Edge<String>, tensor: Edge<T>, serialized_summary_metadata: Edge<String>) -> Self {
        Self {
            tag,
            phantom_T: PhantomData,
            tensor,
            serialized_summary_metadata,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(tag: Edge<String>, tensor: Edge<T>, serialized_summary_metadata: Edge<String>) -> Edge<String> {
        Self {
            tag,
            phantom_T: PhantomData,
            tensor,
            serialized_summary_metadata,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl GraphOperation for RetrieveTPUEmbeddingProximalAdagradParametersGradAccumDebug {
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("RetrieveTPUEmbeddingProximalAdagradParametersGradAccumDebug_{}")?
        };
        let mut new_op = graph.new_operation("RetrieveTPUEmbeddingProximalAdagradParametersGradAccumDebug", &op_name)?;
        {
            match self.table_id {
                None => new_op.set_attr_value_proto("table_id", &vec![24_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 1_u8,])?,
                Some(ref value) => (|attr: &i64| {new_op.set_attr_int("table_id", *attr)})(&value)?,
            };
        }
        {
            match self.table_name {
                None => new_op.set_attr_value_proto("table_name", &vec![18_u8, 0_u8,])?,
                Some(ref value) => (|attr| {new_op.set_attr_string("table_name", attr)})(&value)?,
            };
        }
        {
            (|attr: &i64| {new_op.set_attr_int("num_shards", *attr)})(&self.num_shards)?
        }
        {
            (|attr: &i64| {new_op.set_attr_int("shard_id", *attr)})(&self.shard_id)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct RetrieveTPUEmbeddingProximalAdagradParametersGradAccumDebug {
    table_id: Option<i64>,
    table_name: Option<String>,
    num_shards: i64,
    shard_id: i64,
    op_name: Option<String>,
    id_: usize,
}

impl RetrieveTPUEmbeddingProximalAdagradParametersGradAccumDebug {
    pub fn parameters(self) -> Edge<f32> {
        let rc = Rc::new(self);
        {
            Edge::<f32>::new(rc.clone(), 0)
        }
    }

    pub fn accumulators(self) -> Edge<f32> {
        let rc = Rc::new(self);
        {
            Edge::<f32>::new(rc.clone(), 1)
        }
    }

    pub fn gradient_accumulators(self) -> Edge<f32> {
        let rc = Rc::new(self);
        {
            Edge::<f32>::new(rc.clone(), 2)
        }
    }

    pub fn table_id(&mut self, table_id: i64) -> Self {
        self.table_id = Some(table_id);
        self.clone()
    }

    pub fn table_name(&mut self, table_name: &str) -> Self {
        self.table_name = Some(table_name.to_string());
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> (Edge<f32>, Edge<f32>, Edge<f32>) {
        let rc = Rc::new(self);
        (
        {
            Edge::<f32>::new(rc.clone(), 0)
        },
        {
            Edge::<f32>::new(rc.clone(), 1)
        },
        {
            Edge::<f32>::new(rc.clone(), 2)
        },
        )
    }

    pub fn build(num_shards: i64, shard_id: i64) -> Self {
        Self {
            table_id: None,
            table_name: None,
            num_shards: num_shards,
            shard_id: shard_id,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(num_shards: i64, shard_id: i64) -> (Edge<f32>, Edge<f32>, Edge<f32>) {
        Self {
            table_id: None,
            table_name: None,
            num_shards: num_shards,
            shard_id: shard_id,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<T, Tindices> GraphOperation for SparseApplyCenteredRMSProp<T, Tindices>
where T: TensorType,
      T: Clone,
      Tindices: TensorType,
      Tindices: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
      Tindices: con_or_DT_INT32_or_DT_INT64,
      Tindices: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("SparseApplyCenteredRMSProp_{}")?
        };
        let mut new_op = graph.new_operation("SparseApplyCenteredRMSProp", &op_name)?;
        {
            new_op.add_edge(&self.var)?
        }
        {
            new_op.add_edge(&self.mg)?
        }
        {
            new_op.add_edge(&self.ms)?
        }
        {
            new_op.add_edge(&self.mom)?
        }
        {
            new_op.add_edge(&self.lr)?
        }
        {
            new_op.add_edge(&self.rho)?
        }
        {
            new_op.add_edge(&self.momentum)?
        }
        {
            new_op.add_edge(&self.epsilon)?
        }
        {
            new_op.add_edge(&self.grad)?
        }
        {
            new_op.add_edge(&self.indices)?
        }
        {
            match self.use_locking {
                None => new_op.set_attr_value_proto("use_locking", &vec![40_u8, 0_u8,])?,
                Some(ref value) => (|attr: &bool| {new_op.set_attr_bool("use_locking", *attr)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct SparseApplyCenteredRMSProp<T, Tindices>
where T: TensorType,
      T: Clone,
      Tindices: TensorType,
      Tindices: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
      Tindices: con_or_DT_INT32_or_DT_INT64,
      Tindices: 'static,
{
    phantom_T: PhantomData<T>,
    var: Edge<T>,
    mg: Edge<T>,
    ms: Edge<T>,
    mom: Edge<T>,
    lr: Edge<T>,
    rho: Edge<T>,
    momentum: Edge<T>,
    epsilon: Edge<T>,
    grad: Edge<T>,
    phantom_Tindices: PhantomData<Tindices>,
    indices: Edge<Tindices>,
    use_locking: Option<bool>,
    op_name: Option<String>,
    id_: usize,
}

impl<T, Tindices> SparseApplyCenteredRMSProp<T, Tindices>
where T: TensorType,
      T: Clone,
      Tindices: TensorType,
      Tindices: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
      Tindices: con_or_DT_INT32_or_DT_INT64,
      Tindices: 'static,
{
    pub fn out(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn use_locking(&mut self, use_locking: bool) -> Self {
        self.use_locking = Some(use_locking);
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(var: Edge<T>, mg: Edge<T>, ms: Edge<T>, mom: Edge<T>, lr: Edge<T>, rho: Edge<T>, momentum: Edge<T>, epsilon: Edge<T>, grad: Edge<T>, indices: Edge<Tindices>) -> Self {
        Self {
            phantom_T: PhantomData,
            var,
            mg,
            ms,
            mom,
            lr,
            rho,
            momentum,
            epsilon,
            grad,
            phantom_Tindices: PhantomData,
            indices,
            use_locking: None,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(var: Edge<T>, mg: Edge<T>, ms: Edge<T>, mom: Edge<T>, lr: Edge<T>, rho: Edge<T>, momentum: Edge<T>, epsilon: Edge<T>, grad: Edge<T>, indices: Edge<Tindices>) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            var,
            mg,
            ms,
            mom,
            lr,
            rho,
            momentum,
            epsilon,
            grad,
            phantom_Tindices: PhantomData,
            indices,
            use_locking: None,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl GraphOperation for RecordInput {
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("RecordInput_{}")?
        };
        let mut new_op = graph.new_operation("RecordInput", &op_name)?;
        {
            (|attr| {new_op.set_attr_string("file_pattern", attr)})(&self.file_pattern)?
        }
        {
            match self.file_random_seed {
                None => new_op.set_attr_value_proto("file_random_seed", &vec![24_u8, 173_u8, 2_u8,])?,
                Some(ref value) => (|attr: &i64| {new_op.set_attr_int("file_random_seed", *attr)})(&value)?,
            };
        }
        {
            match self.file_shuffle_shift_ratio {
                None => new_op.set_attr_value_proto("file_shuffle_shift_ratio", &vec![37_u8, 0_u8, 0_u8, 0_u8, 0_u8,])?,
                Some(ref value) => (|attr: &f32| {new_op.set_attr_float("file_shuffle_shift_ratio", *attr)})(&value)?,
            };
        }
        {
            match self.file_buffer_size {
                None => new_op.set_attr_value_proto("file_buffer_size", &vec![24_u8, 144_u8, 78_u8,])?,
                Some(ref value) => (|attr: &i64| {new_op.set_attr_int("file_buffer_size", *attr)})(&value)?,
            };
        }
        {
            match self.file_parallelism {
                None => new_op.set_attr_value_proto("file_parallelism", &vec![24_u8, 16_u8,])?,
                Some(ref value) => (|attr: &i64| {new_op.set_attr_int("file_parallelism", *attr)})(&value)?,
            };
        }
        {
            match self.batch_size {
                None => new_op.set_attr_value_proto("batch_size", &vec![24_u8, 32_u8,])?,
                Some(ref value) => (|attr: &i64| {new_op.set_attr_int("batch_size", *attr)})(&value)?,
            };
        }
        {
            match self.compression_type {
                None => new_op.set_attr_value_proto("compression_type", &vec![18_u8, 0_u8,])?,
                Some(ref value) => (|attr| {new_op.set_attr_string("compression_type", attr)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct RecordInput {
    file_pattern: String,
    file_random_seed: Option<i64>,
    file_shuffle_shift_ratio: Option<f32>,
    file_buffer_size: Option<i64>,
    file_parallelism: Option<i64>,
    batch_size: Option<i64>,
    compression_type: Option<String>,
    op_name: Option<String>,
    id_: usize,
}

impl RecordInput {
    pub fn records(self) -> Edge<String> {
        let rc = Rc::new(self);
        {
            Edge::<String>::new(rc.clone(), 0)
        }
    }

    pub fn file_random_seed(&mut self, file_random_seed: i64) -> Self {
        self.file_random_seed = Some(file_random_seed);
        self.clone()
    }

    pub fn file_shuffle_shift_ratio(&mut self, file_shuffle_shift_ratio: f32) -> Self {
        self.file_shuffle_shift_ratio = Some(file_shuffle_shift_ratio);
        self.clone()
    }

    pub fn file_buffer_size(&mut self, file_buffer_size: i64) -> Self {
        self.file_buffer_size = Some(file_buffer_size);
        self.clone()
    }

    pub fn file_parallelism(&mut self, file_parallelism: i64) -> Self {
        self.file_parallelism = Some(file_parallelism);
        self.clone()
    }

    pub fn batch_size(&mut self, batch_size: i64) -> Self {
        self.batch_size = Some(batch_size);
        self.clone()
    }

    pub fn compression_type(&mut self, compression_type: &str) -> Self {
        self.compression_type = Some(compression_type.to_string());
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<String> {
        let rc = Rc::new(self);
        {
            Edge::<String>::new(rc.clone(), 0)
        }
    }

    pub fn build(file_pattern: &str) -> Self {
        Self {
            file_pattern: file_pattern.to_string(),
            file_random_seed: None,
            file_shuffle_shift_ratio: None,
            file_buffer_size: None,
            file_parallelism: None,
            batch_size: None,
            compression_type: None,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(file_pattern: &str) -> Edge<String> {
        Self {
            file_pattern: file_pattern.to_string(),
            file_random_seed: None,
            file_shuffle_shift_ratio: None,
            file_buffer_size: None,
            file_parallelism: None,
            batch_size: None,
            compression_type: None,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

pub trait con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_COMPLEX64_or_DT_INT64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_COMPLEX64_or_DT_INT64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF for BFloat16 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_COMPLEX64_or_DT_INT64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF for OtherComplex<f32> {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_COMPLEX64_or_DT_INT64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF for OtherComplex<f64> {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_COMPLEX64_or_DT_INT64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF for f32 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_COMPLEX64_or_DT_INT64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF for f64 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_COMPLEX64_or_DT_INT64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF for i32 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_COMPLEX64_or_DT_INT64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF for i64 {
}

impl<T> GraphOperation for Round<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_COMPLEX64_or_DT_INT64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF,
      T: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("Round_{}")?
        };
        let mut new_op = graph.new_operation("Round", &op_name)?;
        {
            new_op.add_edge(&self.x)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct Round<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_COMPLEX64_or_DT_INT64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    x: Edge<T>,
    op_name: Option<String>,
    id_: usize,
}

impl<T> Round<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_COMPLEX64_or_DT_INT64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF,
      T: 'static,
{
    pub fn y(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(x: Edge<T>) -> Self {
        Self {
            phantom_T: PhantomData,
            x,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(x: Edge<T>) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            x,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<dtypes> GraphOperation for OrderedMapClear<dtypes>
where dtypes: 'static,
      dtypes: Clone,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("OrderedMapClear_{}")?
        };
        let mut new_op = graph.new_operation("OrderedMapClear", &op_name)?;
        {
            match self.capacity {
                None => new_op.set_attr_value_proto("capacity", &vec![24_u8, 0_u8,])?,
                Some(ref value) => (|attr: &i64| {new_op.set_attr_int("capacity", *attr)})(&value)?,
            };
        }
        {
            match self.memory_limit {
                None => new_op.set_attr_value_proto("memory_limit", &vec![24_u8, 0_u8,])?,
                Some(ref value) => (|attr: &i64| {new_op.set_attr_int("memory_limit", *attr)})(&value)?,
            };
        }
        {
            match self.container {
                None => new_op.set_attr_value_proto("container", &vec![18_u8, 0_u8,])?,
                Some(ref value) => (|attr| {new_op.set_attr_string("container", attr)})(&value)?,
            };
        }
        {
            match self.shared_name {
                None => new_op.set_attr_value_proto("shared_name", &vec![18_u8, 0_u8,])?,
                Some(ref value) => (|attr| {new_op.set_attr_string("shared_name", attr)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct OrderedMapClear<dtypes>
where dtypes: 'static,
      dtypes: Clone,
{
    capacity: Option<i64>,
    memory_limit: Option<i64>,
    phantom_dtypes: PhantomData<dtypes>,
    container: Option<String>,
    shared_name: Option<String>,
    op_name: Option<String>,
    id_: usize,
}

impl<dtypes> OrderedMapClear<dtypes>
where dtypes: 'static,
      dtypes: Clone,
{
    pub fn capacity(&mut self, capacity: i64) -> Self {
        self.capacity = Some(capacity);
        self.clone()
    }

    pub fn memory_limit(&mut self, memory_limit: i64) -> Self {
        self.memory_limit = Some(memory_limit);
        self.clone()
    }

    pub fn container(&mut self, container: &str) -> Self {
        self.container = Some(container.to_string());
        self.clone()
    }

    pub fn shared_name(&mut self, shared_name: &str) -> Self {
        self.shared_name = Some(shared_name.to_string());
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> () {
        let rc = Rc::new(self);
        (
        )
    }

    pub fn build() -> Self {
        Self {
            capacity: None,
            memory_limit: None,
            phantom_dtypes: PhantomData,
            container: None,
            shared_name: None,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new() -> () {
        Self {
            capacity: None,
            memory_limit: None,
            phantom_dtypes: PhantomData,
            container: None,
            shared_name: None,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<dtypes> GraphOperation for MapClear<dtypes>
where dtypes: 'static,
      dtypes: Clone,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("MapClear_{}")?
        };
        let mut new_op = graph.new_operation("MapClear", &op_name)?;
        {
            match self.capacity {
                None => new_op.set_attr_value_proto("capacity", &vec![24_u8, 0_u8,])?,
                Some(ref value) => (|attr: &i64| {new_op.set_attr_int("capacity", *attr)})(&value)?,
            };
        }
        {
            match self.memory_limit {
                None => new_op.set_attr_value_proto("memory_limit", &vec![24_u8, 0_u8,])?,
                Some(ref value) => (|attr: &i64| {new_op.set_attr_int("memory_limit", *attr)})(&value)?,
            };
        }
        {
            match self.container {
                None => new_op.set_attr_value_proto("container", &vec![18_u8, 0_u8,])?,
                Some(ref value) => (|attr| {new_op.set_attr_string("container", attr)})(&value)?,
            };
        }
        {
            match self.shared_name {
                None => new_op.set_attr_value_proto("shared_name", &vec![18_u8, 0_u8,])?,
                Some(ref value) => (|attr| {new_op.set_attr_string("shared_name", attr)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct MapClear<dtypes>
where dtypes: 'static,
      dtypes: Clone,
{
    capacity: Option<i64>,
    memory_limit: Option<i64>,
    phantom_dtypes: PhantomData<dtypes>,
    container: Option<String>,
    shared_name: Option<String>,
    op_name: Option<String>,
    id_: usize,
}

impl<dtypes> MapClear<dtypes>
where dtypes: 'static,
      dtypes: Clone,
{
    pub fn capacity(&mut self, capacity: i64) -> Self {
        self.capacity = Some(capacity);
        self.clone()
    }

    pub fn memory_limit(&mut self, memory_limit: i64) -> Self {
        self.memory_limit = Some(memory_limit);
        self.clone()
    }

    pub fn container(&mut self, container: &str) -> Self {
        self.container = Some(container.to_string());
        self.clone()
    }

    pub fn shared_name(&mut self, shared_name: &str) -> Self {
        self.shared_name = Some(shared_name.to_string());
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> () {
        let rc = Rc::new(self);
        (
        )
    }

    pub fn build() -> Self {
        Self {
            capacity: None,
            memory_limit: None,
            phantom_dtypes: PhantomData,
            container: None,
            shared_name: None,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new() -> () {
        Self {
            capacity: None,
            memory_limit: None,
            phantom_dtypes: PhantomData,
            container: None,
            shared_name: None,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<dtype> GraphOperation for TensorArrayV2<dtype>
where dtype: 'static,
      dtype: Clone,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("TensorArrayV2_{}")?
        };
        let mut new_op = graph.new_operation("TensorArrayV2", &op_name)?;
        {
            new_op.add_edge(&self.size)?
        }
        {
            match self.element_shape {
                None => new_op.set_attr_value_proto("element_shape", &vec![58_u8, 0_u8,])?,
                Some(ref value) => (|attr| {new_op.set_attr_shape("element_shape", attr)})(&value)?,
            };
        }
        {
            match self.dynamic_size {
                None => new_op.set_attr_value_proto("dynamic_size", &vec![40_u8, 0_u8,])?,
                Some(ref value) => (|attr: &bool| {new_op.set_attr_bool("dynamic_size", *attr)})(&value)?,
            };
        }
        {
            match self.clear_after_read {
                None => new_op.set_attr_value_proto("clear_after_read", &vec![40_u8, 1_u8,])?,
                Some(ref value) => (|attr: &bool| {new_op.set_attr_bool("clear_after_read", *attr)})(&value)?,
            };
        }
        {
            match self.tensor_array_name {
                None => new_op.set_attr_value_proto("tensor_array_name", &vec![18_u8, 0_u8,])?,
                Some(ref value) => (|attr| {new_op.set_attr_string("tensor_array_name", attr)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct TensorArrayV2<dtype>
where dtype: 'static,
      dtype: Clone,
{
    size: Edge<i32>,
    phantom_dtype: PhantomData<dtype>,
    element_shape: Option<OtherShape>,
    dynamic_size: Option<bool>,
    clear_after_read: Option<bool>,
    tensor_array_name: Option<String>,
    op_name: Option<String>,
    id_: usize,
}

impl<dtype> TensorArrayV2<dtype>
where dtype: 'static,
      dtype: Clone,
{
    pub fn handle(self) -> Edge<String> {
        let rc = Rc::new(self);
        {
            Edge::<String>::new(rc.clone(), 0)
        }
    }

    pub fn element_shape(&mut self, element_shape: &OtherShape) -> Self {
        self.element_shape = Some(element_shape.clone());
        self.clone()
    }

    pub fn dynamic_size(&mut self, dynamic_size: bool) -> Self {
        self.dynamic_size = Some(dynamic_size);
        self.clone()
    }

    pub fn clear_after_read(&mut self, clear_after_read: bool) -> Self {
        self.clear_after_read = Some(clear_after_read);
        self.clone()
    }

    pub fn tensor_array_name(&mut self, tensor_array_name: &str) -> Self {
        self.tensor_array_name = Some(tensor_array_name.to_string());
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<String> {
        let rc = Rc::new(self);
        {
            Edge::<String>::new(rc.clone(), 0)
        }
    }

    pub fn build(size: Edge<i32>) -> Self {
        Self {
            size,
            phantom_dtype: PhantomData,
            element_shape: None,
            dynamic_size: None,
            clear_after_read: None,
            tensor_array_name: None,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(size: Edge<i32>) -> Edge<String> {
        Self {
            size,
            phantom_dtype: PhantomData,
            element_shape: None,
            dynamic_size: None,
            clear_after_read: None,
            tensor_array_name: None,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

pub trait con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_COMPLEX64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_COMPLEX64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF for BFloat16 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_COMPLEX64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF for OtherComplex<f32> {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_COMPLEX64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF for OtherComplex<f64> {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_COMPLEX64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF for f32 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_COMPLEX64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF for f64 {
}

impl<T> GraphOperation for Acosh<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_COMPLEX64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF,
      T: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("Acosh_{}")?
        };
        let mut new_op = graph.new_operation("Acosh", &op_name)?;
        {
            new_op.add_edge(&self.x)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct Acosh<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_COMPLEX64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    x: Edge<T>,
    op_name: Option<String>,
    id_: usize,
}

impl<T> Acosh<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_COMPLEX64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF,
      T: 'static,
{
    pub fn y(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(x: Edge<T>) -> Self {
        Self {
            phantom_T: PhantomData,
            x,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(x: Edge<T>) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            x,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<dtypes> GraphOperation for MapSize<dtypes>
where dtypes: 'static,
      dtypes: Clone,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("MapSize_{}")?
        };
        let mut new_op = graph.new_operation("MapSize", &op_name)?;
        {
            match self.capacity {
                None => new_op.set_attr_value_proto("capacity", &vec![24_u8, 0_u8,])?,
                Some(ref value) => (|attr: &i64| {new_op.set_attr_int("capacity", *attr)})(&value)?,
            };
        }
        {
            match self.memory_limit {
                None => new_op.set_attr_value_proto("memory_limit", &vec![24_u8, 0_u8,])?,
                Some(ref value) => (|attr: &i64| {new_op.set_attr_int("memory_limit", *attr)})(&value)?,
            };
        }
        {
            match self.container {
                None => new_op.set_attr_value_proto("container", &vec![18_u8, 0_u8,])?,
                Some(ref value) => (|attr| {new_op.set_attr_string("container", attr)})(&value)?,
            };
        }
        {
            match self.shared_name {
                None => new_op.set_attr_value_proto("shared_name", &vec![18_u8, 0_u8,])?,
                Some(ref value) => (|attr| {new_op.set_attr_string("shared_name", attr)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct MapSize<dtypes>
where dtypes: 'static,
      dtypes: Clone,
{
    capacity: Option<i64>,
    memory_limit: Option<i64>,
    phantom_dtypes: PhantomData<dtypes>,
    container: Option<String>,
    shared_name: Option<String>,
    op_name: Option<String>,
    id_: usize,
}

impl<dtypes> MapSize<dtypes>
where dtypes: 'static,
      dtypes: Clone,
{
    pub fn size(self) -> Edge<i32> {
        let rc = Rc::new(self);
        {
            Edge::<i32>::new(rc.clone(), 0)
        }
    }

    pub fn capacity(&mut self, capacity: i64) -> Self {
        self.capacity = Some(capacity);
        self.clone()
    }

    pub fn memory_limit(&mut self, memory_limit: i64) -> Self {
        self.memory_limit = Some(memory_limit);
        self.clone()
    }

    pub fn container(&mut self, container: &str) -> Self {
        self.container = Some(container.to_string());
        self.clone()
    }

    pub fn shared_name(&mut self, shared_name: &str) -> Self {
        self.shared_name = Some(shared_name.to_string());
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<i32> {
        let rc = Rc::new(self);
        {
            Edge::<i32>::new(rc.clone(), 0)
        }
    }

    pub fn build() -> Self {
        Self {
            capacity: None,
            memory_limit: None,
            phantom_dtypes: PhantomData,
            container: None,
            shared_name: None,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new() -> Edge<i32> {
        Self {
            capacity: None,
            memory_limit: None,
            phantom_dtypes: PhantomData,
            container: None,
            shared_name: None,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<T, Tshift, Taxis> GraphOperation for Roll<T, Tshift, Taxis>
where T: TensorType,
      T: Clone,
      Tshift: TensorType,
      Tshift: Clone,
      Taxis: TensorType,
      Taxis: Clone,
      T: 'static,
      Tshift: con_or_DT_INT32_or_DT_INT64,
      Tshift: 'static,
      Taxis: con_or_DT_INT32_or_DT_INT64,
      Taxis: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("Roll_{}")?
        };
        let mut new_op = graph.new_operation("Roll", &op_name)?;
        {
            new_op.add_edge(&self.input)?
        }
        {
            new_op.add_edge(&self.shift)?
        }
        {
            new_op.add_edge(&self.axis)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct Roll<T, Tshift, Taxis>
where T: TensorType,
      T: Clone,
      Tshift: TensorType,
      Tshift: Clone,
      Taxis: TensorType,
      Taxis: Clone,
      T: 'static,
      Tshift: con_or_DT_INT32_or_DT_INT64,
      Tshift: 'static,
      Taxis: con_or_DT_INT32_or_DT_INT64,
      Taxis: 'static,
{
    phantom_T: PhantomData<T>,
    input: Edge<T>,
    phantom_Tshift: PhantomData<Tshift>,
    shift: Edge<Tshift>,
    phantom_Taxis: PhantomData<Taxis>,
    axis: Edge<Taxis>,
    op_name: Option<String>,
    id_: usize,
}

impl<T, Tshift, Taxis> Roll<T, Tshift, Taxis>
where T: TensorType,
      T: Clone,
      Tshift: TensorType,
      Tshift: Clone,
      Taxis: TensorType,
      Taxis: Clone,
      T: 'static,
      Tshift: con_or_DT_INT32_or_DT_INT64,
      Tshift: 'static,
      Taxis: con_or_DT_INT32_or_DT_INT64,
      Taxis: 'static,
{
    pub fn output(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(input: Edge<T>, shift: Edge<Tshift>, axis: Edge<Taxis>) -> Self {
        Self {
            phantom_T: PhantomData,
            input,
            phantom_Tshift: PhantomData,
            shift,
            phantom_Taxis: PhantomData,
            axis,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(input: Edge<T>, shift: Edge<Tshift>, axis: Edge<Taxis>) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            input,
            phantom_Tshift: PhantomData,
            shift,
            phantom_Taxis: PhantomData,
            axis,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<dtypes> GraphOperation for StageClear<dtypes>
where dtypes: 'static,
      dtypes: Clone,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("StageClear_{}")?
        };
        let mut new_op = graph.new_operation("StageClear", &op_name)?;
        {
            match self.capacity {
                None => new_op.set_attr_value_proto("capacity", &vec![24_u8, 0_u8,])?,
                Some(ref value) => (|attr: &i64| {new_op.set_attr_int("capacity", *attr)})(&value)?,
            };
        }
        {
            match self.memory_limit {
                None => new_op.set_attr_value_proto("memory_limit", &vec![24_u8, 0_u8,])?,
                Some(ref value) => (|attr: &i64| {new_op.set_attr_int("memory_limit", *attr)})(&value)?,
            };
        }
        {
            match self.container {
                None => new_op.set_attr_value_proto("container", &vec![18_u8, 0_u8,])?,
                Some(ref value) => (|attr| {new_op.set_attr_string("container", attr)})(&value)?,
            };
        }
        {
            match self.shared_name {
                None => new_op.set_attr_value_proto("shared_name", &vec![18_u8, 0_u8,])?,
                Some(ref value) => (|attr| {new_op.set_attr_string("shared_name", attr)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct StageClear<dtypes>
where dtypes: 'static,
      dtypes: Clone,
{
    capacity: Option<i64>,
    memory_limit: Option<i64>,
    phantom_dtypes: PhantomData<dtypes>,
    container: Option<String>,
    shared_name: Option<String>,
    op_name: Option<String>,
    id_: usize,
}

impl<dtypes> StageClear<dtypes>
where dtypes: 'static,
      dtypes: Clone,
{
    pub fn capacity(&mut self, capacity: i64) -> Self {
        self.capacity = Some(capacity);
        self.clone()
    }

    pub fn memory_limit(&mut self, memory_limit: i64) -> Self {
        self.memory_limit = Some(memory_limit);
        self.clone()
    }

    pub fn container(&mut self, container: &str) -> Self {
        self.container = Some(container.to_string());
        self.clone()
    }

    pub fn shared_name(&mut self, shared_name: &str) -> Self {
        self.shared_name = Some(shared_name.to_string());
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> () {
        let rc = Rc::new(self);
        (
        )
    }

    pub fn build() -> Self {
        Self {
            capacity: None,
            memory_limit: None,
            phantom_dtypes: PhantomData,
            container: None,
            shared_name: None,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new() -> () {
        Self {
            capacity: None,
            memory_limit: None,
            phantom_dtypes: PhantomData,
            container: None,
            shared_name: None,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl GraphOperation for NonMaxSuppressionWithOverlaps {
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("NonMaxSuppressionWithOverlaps_{}")?
        };
        let mut new_op = graph.new_operation("NonMaxSuppressionWithOverlaps", &op_name)?;
        {
            new_op.add_edge(&self.overlaps)?
        }
        {
            new_op.add_edge(&self.scores)?
        }
        {
            new_op.add_edge(&self.max_output_size)?
        }
        {
            new_op.add_edge(&self.overlap_threshold)?
        }
        {
            new_op.add_edge(&self.score_threshold)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct NonMaxSuppressionWithOverlaps {
    overlaps: Edge<f32>,
    scores: Edge<f32>,
    max_output_size: Edge<i32>,
    overlap_threshold: Edge<f32>,
    score_threshold: Edge<f32>,
    op_name: Option<String>,
    id_: usize,
}

impl NonMaxSuppressionWithOverlaps {
    pub fn selected_indices(self) -> Edge<i32> {
        let rc = Rc::new(self);
        {
            Edge::<i32>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<i32> {
        let rc = Rc::new(self);
        {
            Edge::<i32>::new(rc.clone(), 0)
        }
    }

    pub fn build(overlaps: Edge<f32>, scores: Edge<f32>, max_output_size: Edge<i32>, overlap_threshold: Edge<f32>, score_threshold: Edge<f32>) -> Self {
        Self {
            overlaps,
            scores,
            max_output_size,
            overlap_threshold,
            score_threshold,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(overlaps: Edge<f32>, scores: Edge<f32>, max_output_size: Edge<i32>, overlap_threshold: Edge<f32>, score_threshold: Edge<f32>) -> Edge<i32> {
        Self {
            overlaps,
            scores,
            max_output_size,
            overlap_threshold,
            score_threshold,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<T> GraphOperation for AvgPoolGrad<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
      T: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("AvgPoolGrad_{}")?
        };
        let mut new_op = graph.new_operation("AvgPoolGrad", &op_name)?;
        {
            new_op.add_edge(&self.orig_input_shape)?
        }
        {
            new_op.add_edge(&self.grad)?
        }
        {
            (|attrs| {new_op.set_attr_int_list("ksize", attrs)})(&self.ksize)?
        }
        {
            (|attrs| {new_op.set_attr_int_list("strides", attrs)})(&self.strides)?
        }
        {
            (|attr| {new_op.set_attr_string("padding", attr)})(&self.padding)?
        }
        {
            match self.data_format {
                None => new_op.set_attr_value_proto("data_format", &vec![18_u8, 4_u8, 78_u8, 72_u8, 87_u8, 67_u8,])?,
                Some(ref value) => (|attr| {new_op.set_attr_string("data_format", attr)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct AvgPoolGrad<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
      T: 'static,
{
    orig_input_shape: Edge<i32>,
    phantom_T: PhantomData<T>,
    grad: Edge<T>,
    ksize: Vec<i64>,
    strides: Vec<i64>,
    padding: String,
    data_format: Option<String>,
    op_name: Option<String>,
    id_: usize,
}

impl<T> AvgPoolGrad<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
      T: 'static,
{
    pub fn output(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn data_format(&mut self, data_format: &str) -> Self {
        self.data_format = Some(data_format.to_string());
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(orig_input_shape: Edge<i32>, grad: Edge<T>, ksize: &[i64], strides: &[i64], padding: &str) -> Self {
        Self {
            orig_input_shape,
            phantom_T: PhantomData,
            grad,
            ksize: ksize.to_vec(),
            strides: strides.to_vec(),
            padding: padding.to_string(),
            data_format: None,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(orig_input_shape: Edge<i32>, grad: Edge<T>, ksize: &[i64], strides: &[i64], padding: &str) -> Edge<T> {
        Self {
            orig_input_shape,
            phantom_T: PhantomData,
            grad,
            ksize: ksize.to_vec(),
            strides: strides.to_vec(),
            padding: padding.to_string(),
            data_format: None,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<dtypes> GraphOperation for StageSize<dtypes>
where dtypes: 'static,
      dtypes: Clone,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("StageSize_{}")?
        };
        let mut new_op = graph.new_operation("StageSize", &op_name)?;
        {
            match self.capacity {
                None => new_op.set_attr_value_proto("capacity", &vec![24_u8, 0_u8,])?,
                Some(ref value) => (|attr: &i64| {new_op.set_attr_int("capacity", *attr)})(&value)?,
            };
        }
        {
            match self.memory_limit {
                None => new_op.set_attr_value_proto("memory_limit", &vec![24_u8, 0_u8,])?,
                Some(ref value) => (|attr: &i64| {new_op.set_attr_int("memory_limit", *attr)})(&value)?,
            };
        }
        {
            match self.container {
                None => new_op.set_attr_value_proto("container", &vec![18_u8, 0_u8,])?,
                Some(ref value) => (|attr| {new_op.set_attr_string("container", attr)})(&value)?,
            };
        }
        {
            match self.shared_name {
                None => new_op.set_attr_value_proto("shared_name", &vec![18_u8, 0_u8,])?,
                Some(ref value) => (|attr| {new_op.set_attr_string("shared_name", attr)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct StageSize<dtypes>
where dtypes: 'static,
      dtypes: Clone,
{
    capacity: Option<i64>,
    memory_limit: Option<i64>,
    phantom_dtypes: PhantomData<dtypes>,
    container: Option<String>,
    shared_name: Option<String>,
    op_name: Option<String>,
    id_: usize,
}

impl<dtypes> StageSize<dtypes>
where dtypes: 'static,
      dtypes: Clone,
{
    pub fn size(self) -> Edge<i32> {
        let rc = Rc::new(self);
        {
            Edge::<i32>::new(rc.clone(), 0)
        }
    }

    pub fn capacity(&mut self, capacity: i64) -> Self {
        self.capacity = Some(capacity);
        self.clone()
    }

    pub fn memory_limit(&mut self, memory_limit: i64) -> Self {
        self.memory_limit = Some(memory_limit);
        self.clone()
    }

    pub fn container(&mut self, container: &str) -> Self {
        self.container = Some(container.to_string());
        self.clone()
    }

    pub fn shared_name(&mut self, shared_name: &str) -> Self {
        self.shared_name = Some(shared_name.to_string());
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<i32> {
        let rc = Rc::new(self);
        {
            Edge::<i32>::new(rc.clone(), 0)
        }
    }

    pub fn build() -> Self {
        Self {
            capacity: None,
            memory_limit: None,
            phantom_dtypes: PhantomData,
            container: None,
            shared_name: None,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new() -> Edge<i32> {
        Self {
            capacity: None,
            memory_limit: None,
            phantom_dtypes: PhantomData,
            container: None,
            shared_name: None,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<Tshape, T> GraphOperation for Conv3DBackpropInputV2<Tshape, T>
where Tshape: TensorType,
      Tshape: Clone,
      T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
      T: 'static,
      Tshape: con_or_DT_INT32_or_DT_INT64,
      Tshape: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("Conv3DBackpropInputV2_{}")?
        };
        let mut new_op = graph.new_operation("Conv3DBackpropInputV2", &op_name)?;
        {
            new_op.add_edge(&self.input_sizes)?
        }
        {
            new_op.add_edge(&self.filter)?
        }
        {
            new_op.add_edge(&self.out_backprop)?
        }
        {
            (|attrs| {new_op.set_attr_int_list("strides", attrs)})(&self.strides)?
        }
        {
            (|attr| {new_op.set_attr_string("padding", attr)})(&self.padding)?
        }
        {
            match self.data_format {
                None => new_op.set_attr_value_proto("data_format", &vec![18_u8, 5_u8, 78_u8, 68_u8, 72_u8, 87_u8, 67_u8,])?,
                Some(ref value) => (|attr| {new_op.set_attr_string("data_format", attr)})(&value)?,
            };
        }
        {
            match self.dilations {
                None => new_op.set_attr_value_proto("dilations", &vec![10_u8, 0_u8, 26_u8, 5_u8, 1_u8, 1_u8, 1_u8, 1_u8,])?,
                Some(ref value) => (|attrs| {new_op.set_attr_int_list("dilations", attrs)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct Conv3DBackpropInputV2<Tshape, T>
where Tshape: TensorType,
      Tshape: Clone,
      T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
      T: 'static,
      Tshape: con_or_DT_INT32_or_DT_INT64,
      Tshape: 'static,
{
    phantom_Tshape: PhantomData<Tshape>,
    input_sizes: Edge<Tshape>,
    phantom_T: PhantomData<T>,
    filter: Edge<T>,
    out_backprop: Edge<T>,
    strides: Vec<i64>,
    padding: String,
    data_format: Option<String>,
    dilations: Option<Vec<i64>>,
    op_name: Option<String>,
    id_: usize,
}

impl<Tshape, T> Conv3DBackpropInputV2<Tshape, T>
where Tshape: TensorType,
      Tshape: Clone,
      T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
      T: 'static,
      Tshape: con_or_DT_INT32_or_DT_INT64,
      Tshape: 'static,
{
    pub fn output(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn data_format(&mut self, data_format: &str) -> Self {
        self.data_format = Some(data_format.to_string());
        self.clone()
    }

    pub fn dilations(&mut self, dilations: &[i64]) -> Self {
        self.dilations = Some(dilations.to_vec());
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(input_sizes: Edge<Tshape>, filter: Edge<T>, out_backprop: Edge<T>, strides: &[i64], padding: &str) -> Self {
        Self {
            phantom_Tshape: PhantomData,
            input_sizes,
            phantom_T: PhantomData,
            filter,
            out_backprop,
            strides: strides.to_vec(),
            padding: padding.to_string(),
            data_format: None,
            dilations: None,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(input_sizes: Edge<Tshape>, filter: Edge<T>, out_backprop: Edge<T>, strides: &[i64], padding: &str) -> Edge<T> {
        Self {
            phantom_Tshape: PhantomData,
            input_sizes,
            phantom_T: PhantomData,
            filter,
            out_backprop,
            strides: strides.to_vec(),
            padding: padding.to_string(),
            data_format: None,
            dilations: None,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<T> GraphOperation for DepthToSpace<T>
where T: TensorType,
      T: Clone,
      T: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("DepthToSpace_{}")?
        };
        let mut new_op = graph.new_operation("DepthToSpace", &op_name)?;
        {
            new_op.add_edge(&self.input)?
        }
        {
            (|attr: &i64| {new_op.set_attr_int("block_size", *attr)})(&self.block_size)?
        }
        {
            match self.data_format {
                None => new_op.set_attr_value_proto("data_format", &vec![18_u8, 4_u8, 78_u8, 72_u8, 87_u8, 67_u8,])?,
                Some(ref value) => (|attr| {new_op.set_attr_string("data_format", attr)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct DepthToSpace<T>
where T: TensorType,
      T: Clone,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    input: Edge<T>,
    block_size: i64,
    data_format: Option<String>,
    op_name: Option<String>,
    id_: usize,
}

impl<T> DepthToSpace<T>
where T: TensorType,
      T: Clone,
      T: 'static,
{
    pub fn output(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn data_format(&mut self, data_format: &str) -> Self {
        self.data_format = Some(data_format.to_string());
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(input: Edge<T>, block_size: i64) -> Self {
        Self {
            phantom_T: PhantomData,
            input,
            block_size: block_size,
            data_format: None,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(input: Edge<T>, block_size: i64) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            input,
            block_size: block_size,
            data_format: None,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl GraphOperation for BarrierReadySize {
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("BarrierReadySize_{}")?
        };
        let mut new_op = graph.new_operation("BarrierReadySize", &op_name)?;
        {
            new_op.add_edge(&self.handle)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct BarrierReadySize {
    handle: Edge<String>,
    op_name: Option<String>,
    id_: usize,
}

impl BarrierReadySize {
    pub fn size(self) -> Edge<i32> {
        let rc = Rc::new(self);
        {
            Edge::<i32>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<i32> {
        let rc = Rc::new(self);
        {
            Edge::<i32>::new(rc.clone(), 0)
        }
    }

    pub fn build(handle: Edge<String>) -> Self {
        Self {
            handle,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(handle: Edge<String>) -> Edge<i32> {
        Self {
            handle,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl GraphOperation for FakeQuantWithMinMaxArgs {
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("FakeQuantWithMinMaxArgs_{}")?
        };
        let mut new_op = graph.new_operation("FakeQuantWithMinMaxArgs", &op_name)?;
        {
            new_op.add_edge(&self.inputs)?
        }
        {
            match self.min {
                None => new_op.set_attr_value_proto("min", &vec![37_u8, 0_u8, 0_u8, 192_u8, 192_u8,])?,
                Some(ref value) => (|attr: &f32| {new_op.set_attr_float("min", *attr)})(&value)?,
            };
        }
        {
            match self.max {
                None => new_op.set_attr_value_proto("max", &vec![37_u8, 0_u8, 0_u8, 192_u8, 64_u8,])?,
                Some(ref value) => (|attr: &f32| {new_op.set_attr_float("max", *attr)})(&value)?,
            };
        }
        {
            match self.num_bits {
                None => new_op.set_attr_value_proto("num_bits", &vec![24_u8, 8_u8,])?,
                Some(ref value) => (|attr: &i64| {new_op.set_attr_int("num_bits", *attr)})(&value)?,
            };
        }
        {
            match self.narrow_range {
                None => new_op.set_attr_value_proto("narrow_range", &vec![40_u8, 0_u8,])?,
                Some(ref value) => (|attr: &bool| {new_op.set_attr_bool("narrow_range", *attr)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct FakeQuantWithMinMaxArgs {
    inputs: Edge<f32>,
    min: Option<f32>,
    max: Option<f32>,
    num_bits: Option<i64>,
    narrow_range: Option<bool>,
    op_name: Option<String>,
    id_: usize,
}

impl FakeQuantWithMinMaxArgs {
    pub fn outputs(self) -> Edge<f32> {
        let rc = Rc::new(self);
        {
            Edge::<f32>::new(rc.clone(), 0)
        }
    }

    pub fn min(&mut self, min: f32) -> Self {
        self.min = Some(min);
        self.clone()
    }

    pub fn max(&mut self, max: f32) -> Self {
        self.max = Some(max);
        self.clone()
    }

    pub fn num_bits(&mut self, num_bits: i64) -> Self {
        self.num_bits = Some(num_bits);
        self.clone()
    }

    pub fn narrow_range(&mut self, narrow_range: bool) -> Self {
        self.narrow_range = Some(narrow_range);
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<f32> {
        let rc = Rc::new(self);
        {
            Edge::<f32>::new(rc.clone(), 0)
        }
    }

    pub fn build(inputs: Edge<f32>) -> Self {
        Self {
            inputs,
            min: None,
            max: None,
            num_bits: None,
            narrow_range: None,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(inputs: Edge<f32>) -> Edge<f32> {
        Self {
            inputs,
            min: None,
            max: None,
            num_bits: None,
            narrow_range: None,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl GraphOperation for BarrierClose {
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("BarrierClose_{}")?
        };
        let mut new_op = graph.new_operation("BarrierClose", &op_name)?;
        {
            new_op.add_edge(&self.handle)?
        }
        {
            match self.cancel_pending_enqueues {
                None => new_op.set_attr_value_proto("cancel_pending_enqueues", &vec![40_u8, 0_u8,])?,
                Some(ref value) => (|attr: &bool| {new_op.set_attr_bool("cancel_pending_enqueues", *attr)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct BarrierClose {
    handle: Edge<String>,
    cancel_pending_enqueues: Option<bool>,
    op_name: Option<String>,
    id_: usize,
}

impl BarrierClose {
    pub fn cancel_pending_enqueues(&mut self, cancel_pending_enqueues: bool) -> Self {
        self.cancel_pending_enqueues = Some(cancel_pending_enqueues);
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> () {
        let rc = Rc::new(self);
        (
        )
    }

    pub fn build(handle: Edge<String>) -> Self {
        Self {
            handle,
            cancel_pending_enqueues: None,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(handle: Edge<String>) -> () {
        Self {
            handle,
            cancel_pending_enqueues: None,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<T> GraphOperation for BarrierInsertMany<T>
where T: TensorType,
      T: Clone,
      T: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("BarrierInsertMany_{}")?
        };
        let mut new_op = graph.new_operation("BarrierInsertMany", &op_name)?;
        {
            new_op.add_edge(&self.handle)?
        }
        {
            new_op.add_edge(&self.keys)?
        }
        {
            new_op.add_edge(&self.values)?
        }
        {
            (|attr: &i64| {new_op.set_attr_int("component_index", *attr)})(&self.component_index)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct BarrierInsertMany<T>
where T: TensorType,
      T: Clone,
      T: 'static,
{
    handle: Edge<String>,
    keys: Edge<String>,
    phantom_T: PhantomData<T>,
    values: Edge<T>,
    component_index: i64,
    op_name: Option<String>,
    id_: usize,
}

impl<T> BarrierInsertMany<T>
where T: TensorType,
      T: Clone,
      T: 'static,
{
    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> () {
        let rc = Rc::new(self);
        (
        )
    }

    pub fn build(handle: Edge<String>, keys: Edge<String>, values: Edge<T>, component_index: i64) -> Self {
        Self {
            handle,
            keys,
            phantom_T: PhantomData,
            values,
            component_index: component_index,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(handle: Edge<String>, keys: Edge<String>, values: Edge<T>, component_index: i64) -> () {
        Self {
            handle,
            keys,
            phantom_T: PhantomData,
            values,
            component_index: component_index,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<T> GraphOperation for Erf<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
      T: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("Erf_{}")?
        };
        let mut new_op = graph.new_operation("Erf", &op_name)?;
        {
            new_op.add_edge(&self.x)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct Erf<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    x: Edge<T>,
    op_name: Option<String>,
    id_: usize,
}

impl<T> Erf<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
      T: 'static,
{
    pub fn y(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(x: Edge<T>) -> Self {
        Self {
            phantom_T: PhantomData,
            x,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(x: Edge<T>) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            x,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<T> GraphOperation for Floor<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
      T: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("Floor_{}")?
        };
        let mut new_op = graph.new_operation("Floor", &op_name)?;
        {
            new_op.add_edge(&self.x)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct Floor<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    x: Edge<T>,
    op_name: Option<String>,
    id_: usize,
}

impl<T> Floor<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
      T: 'static,
{
    pub fn y(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(x: Edge<T>) -> Self {
        Self {
            phantom_T: PhantomData,
            x,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(x: Edge<T>) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            x,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl GraphOperation for TensorArraySizeV2 {
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("TensorArraySizeV2_{}")?
        };
        let mut new_op = graph.new_operation("TensorArraySizeV2", &op_name)?;
        {
            new_op.add_edge(&self.handle)?
        }
        {
            new_op.add_edge(&self.flow_in)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct TensorArraySizeV2 {
    handle: Edge<String>,
    flow_in: Edge<f32>,
    op_name: Option<String>,
    id_: usize,
}

impl TensorArraySizeV2 {
    pub fn size(self) -> Edge<i32> {
        let rc = Rc::new(self);
        {
            Edge::<i32>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<i32> {
        let rc = Rc::new(self);
        {
            Edge::<i32>::new(rc.clone(), 0)
        }
    }

    pub fn build(handle: Edge<String>, flow_in: Edge<f32>) -> Self {
        Self {
            handle,
            flow_in,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(handle: Edge<String>, flow_in: Edge<f32>) -> Edge<i32> {
        Self {
            handle,
            flow_in,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<dtype> GraphOperation for TensorArrayConcat<dtype>
where dtype: TensorType,
      dtype: 'static,
      dtype: Clone,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("TensorArrayConcat_{}")?
        };
        let mut new_op = graph.new_operation("TensorArrayConcat", &op_name)?;
        {
            new_op.add_edge(&self.handle)?
        }
        {
            new_op.add_edge(&self.flow_in)?
        }
        {
            match self.element_shape_except0 {
                None => new_op.set_attr_value_proto("element_shape_except0", &vec![58_u8, 0_u8,])?,
                Some(ref value) => (|attr| {new_op.set_attr_shape("element_shape_except0", attr)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct TensorArrayConcat<dtype>
where dtype: TensorType,
      dtype: 'static,
      dtype: Clone,
{
    handle: Edge<String>,
    flow_in: Edge<f32>,
    phantom_dtype: PhantomData<dtype>,
    element_shape_except0: Option<OtherShape>,
    op_name: Option<String>,
    id_: usize,
}

impl<dtype> TensorArrayConcat<dtype>
where dtype: TensorType,
      dtype: 'static,
      dtype: Clone,
{
    pub fn value(self) -> Edge<dtype> {
        let rc = Rc::new(self);
        {
            Edge::<dtype>::new(rc.clone(), 0)
        }
    }

    pub fn lengths(self) -> Edge<i64> {
        let rc = Rc::new(self);
        {
            Edge::<i64>::new(rc.clone(), 1)
        }
    }

    pub fn element_shape_except0(&mut self, element_shape_except0: &OtherShape) -> Self {
        self.element_shape_except0 = Some(element_shape_except0.clone());
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> (Edge<dtype>, Edge<i64>) {
        let rc = Rc::new(self);
        (
        {
            Edge::<dtype>::new(rc.clone(), 0)
        },
        {
            Edge::<i64>::new(rc.clone(), 1)
        },
        )
    }

    pub fn build(handle: Edge<String>, flow_in: Edge<f32>) -> Self {
        Self {
            handle,
            flow_in,
            phantom_dtype: PhantomData,
            element_shape_except0: None,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(handle: Edge<String>, flow_in: Edge<f32>) -> (Edge<dtype>, Edge<i64>) {
        Self {
            handle,
            flow_in,
            phantom_dtype: PhantomData,
            element_shape_except0: None,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

pub trait con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_COMPLEX64_or_DT_COMPLEX128 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_COMPLEX64_or_DT_COMPLEX128 for OtherComplex<f32> {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_COMPLEX64_or_DT_COMPLEX128 for OtherComplex<f64> {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_COMPLEX64_or_DT_COMPLEX128 for f32 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_COMPLEX64_or_DT_COMPLEX128 for f64 {
}

impl<T> GraphOperation for MatrixSquareRoot<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_COMPLEX64_or_DT_COMPLEX128,
      T: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("MatrixSquareRoot_{}")?
        };
        let mut new_op = graph.new_operation("MatrixSquareRoot", &op_name)?;
        {
            new_op.add_edge(&self.input)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct MatrixSquareRoot<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_COMPLEX64_or_DT_COMPLEX128,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    input: Edge<T>,
    op_name: Option<String>,
    id_: usize,
}

impl<T> MatrixSquareRoot<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_COMPLEX64_or_DT_COMPLEX128,
      T: 'static,
{
    pub fn output(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(input: Edge<T>) -> Self {
        Self {
            phantom_T: PhantomData,
            input,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(input: Edge<T>) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            input,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<T, Tindices> GraphOperation for SparseApplyAdagradDA<T, Tindices>
where T: TensorType,
      T: Clone,
      Tindices: TensorType,
      Tindices: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
      Tindices: con_or_DT_INT32_or_DT_INT64,
      Tindices: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("SparseApplyAdagradDA_{}")?
        };
        let mut new_op = graph.new_operation("SparseApplyAdagradDA", &op_name)?;
        {
            new_op.add_edge(&self.var)?
        }
        {
            new_op.add_edge(&self.gradient_accumulator)?
        }
        {
            new_op.add_edge(&self.gradient_squared_accumulator)?
        }
        {
            new_op.add_edge(&self.grad)?
        }
        {
            new_op.add_edge(&self.indices)?
        }
        {
            new_op.add_edge(&self.lr)?
        }
        {
            new_op.add_edge(&self.l1)?
        }
        {
            new_op.add_edge(&self.l2)?
        }
        {
            new_op.add_edge(&self.global_step)?
        }
        {
            match self.use_locking {
                None => new_op.set_attr_value_proto("use_locking", &vec![40_u8, 0_u8,])?,
                Some(ref value) => (|attr: &bool| {new_op.set_attr_bool("use_locking", *attr)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct SparseApplyAdagradDA<T, Tindices>
where T: TensorType,
      T: Clone,
      Tindices: TensorType,
      Tindices: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
      Tindices: con_or_DT_INT32_or_DT_INT64,
      Tindices: 'static,
{
    phantom_T: PhantomData<T>,
    var: Edge<T>,
    gradient_accumulator: Edge<T>,
    gradient_squared_accumulator: Edge<T>,
    grad: Edge<T>,
    phantom_Tindices: PhantomData<Tindices>,
    indices: Edge<Tindices>,
    lr: Edge<T>,
    l1: Edge<T>,
    l2: Edge<T>,
    global_step: Edge<i64>,
    use_locking: Option<bool>,
    op_name: Option<String>,
    id_: usize,
}

impl<T, Tindices> SparseApplyAdagradDA<T, Tindices>
where T: TensorType,
      T: Clone,
      Tindices: TensorType,
      Tindices: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
      Tindices: con_or_DT_INT32_or_DT_INT64,
      Tindices: 'static,
{
    pub fn out(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn use_locking(&mut self, use_locking: bool) -> Self {
        self.use_locking = Some(use_locking);
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(var: Edge<T>, gradient_accumulator: Edge<T>, gradient_squared_accumulator: Edge<T>, grad: Edge<T>, indices: Edge<Tindices>, lr: Edge<T>, l1: Edge<T>, l2: Edge<T>, global_step: Edge<i64>) -> Self {
        Self {
            phantom_T: PhantomData,
            var,
            gradient_accumulator,
            gradient_squared_accumulator,
            grad,
            phantom_Tindices: PhantomData,
            indices,
            lr,
            l1,
            l2,
            global_step,
            use_locking: None,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(var: Edge<T>, gradient_accumulator: Edge<T>, gradient_squared_accumulator: Edge<T>, grad: Edge<T>, indices: Edge<Tindices>, lr: Edge<T>, l1: Edge<T>, l2: Edge<T>, global_step: Edge<i64>) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            var,
            gradient_accumulator,
            gradient_squared_accumulator,
            grad,
            phantom_Tindices: PhantomData,
            indices,
            lr,
            l1,
            l2,
            global_step,
            use_locking: None,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<T> GraphOperation for DivNoNan<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE,
      T: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("DivNoNan_{}")?
        };
        let mut new_op = graph.new_operation("DivNoNan", &op_name)?;
        {
            new_op.add_edge(&self.x)?
        }
        {
            new_op.add_edge(&self.y)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct DivNoNan<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    x: Edge<T>,
    y: Edge<T>,
    op_name: Option<String>,
    id_: usize,
}

impl<T> DivNoNan<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE,
      T: 'static,
{
    pub fn z(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(x: Edge<T>, y: Edge<T>) -> Self {
        Self {
            phantom_T: PhantomData,
            x,
            y,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(x: Edge<T>, y: Edge<T>) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            x,
            y,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<T> GraphOperation for TensorArrayScatter<T>
where T: TensorType,
      T: Clone,
      T: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("TensorArrayScatter_{}")?
        };
        let mut new_op = graph.new_operation("TensorArrayScatter", &op_name)?;
        {
            new_op.add_edge(&self.handle)?
        }
        {
            new_op.add_edge(&self.indices)?
        }
        {
            new_op.add_edge(&self.value)?
        }
        {
            new_op.add_edge(&self.flow_in)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct TensorArrayScatter<T>
where T: TensorType,
      T: Clone,
      T: 'static,
{
    handle: Edge<String>,
    indices: Edge<i32>,
    phantom_T: PhantomData<T>,
    value: Edge<T>,
    flow_in: Edge<f32>,
    op_name: Option<String>,
    id_: usize,
}

impl<T> TensorArrayScatter<T>
where T: TensorType,
      T: Clone,
      T: 'static,
{
    pub fn flow_out(self) -> Edge<f32> {
        let rc = Rc::new(self);
        {
            Edge::<f32>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<f32> {
        let rc = Rc::new(self);
        {
            Edge::<f32>::new(rc.clone(), 0)
        }
    }

    pub fn build(handle: Edge<String>, indices: Edge<i32>, value: Edge<T>, flow_in: Edge<f32>) -> Self {
        Self {
            handle,
            indices,
            phantom_T: PhantomData,
            value,
            flow_in,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(handle: Edge<String>, indices: Edge<i32>, value: Edge<T>, flow_in: Edge<f32>) -> Edge<f32> {
        Self {
            handle,
            indices,
            phantom_T: PhantomData,
            value,
            flow_in,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<T> GraphOperation for SparseReduceMax<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("SparseReduceMax_{}")?
        };
        let mut new_op = graph.new_operation("SparseReduceMax", &op_name)?;
        {
            new_op.add_edge(&self.input_indices)?
        }
        {
            new_op.add_edge(&self.input_values)?
        }
        {
            new_op.add_edge(&self.input_shape)?
        }
        {
            new_op.add_edge(&self.reduction_axes)?
        }
        {
            match self.keep_dims {
                None => new_op.set_attr_value_proto("keep_dims", &vec![40_u8, 0_u8,])?,
                Some(ref value) => (|attr: &bool| {new_op.set_attr_bool("keep_dims", *attr)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct SparseReduceMax<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
{
    input_indices: Edge<i64>,
    phantom_T: PhantomData<T>,
    input_values: Edge<T>,
    input_shape: Edge<i64>,
    reduction_axes: Edge<i32>,
    keep_dims: Option<bool>,
    op_name: Option<String>,
    id_: usize,
}

impl<T> SparseReduceMax<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
{
    pub fn output(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn keep_dims(&mut self, keep_dims: bool) -> Self {
        self.keep_dims = Some(keep_dims);
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(input_indices: Edge<i64>, input_values: Edge<T>, input_shape: Edge<i64>, reduction_axes: Edge<i32>) -> Self {
        Self {
            input_indices,
            phantom_T: PhantomData,
            input_values,
            input_shape,
            reduction_axes,
            keep_dims: None,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(input_indices: Edge<i64>, input_values: Edge<T>, input_shape: Edge<i64>, reduction_axes: Edge<i32>) -> Edge<T> {
        Self {
            input_indices,
            phantom_T: PhantomData,
            input_values,
            input_shape,
            reduction_axes,
            keep_dims: None,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<T> GraphOperation for TensorArrayUnpack<T>
where T: TensorType,
      T: Clone,
      T: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("TensorArrayUnpack_{}")?
        };
        let mut new_op = graph.new_operation("TensorArrayUnpack", &op_name)?;
        {
            new_op.add_edge(&self.handle)?
        }
        {
            new_op.add_edge(&self.value)?
        }
        {
            new_op.add_edge(&self.flow_in)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct TensorArrayUnpack<T>
where T: TensorType,
      T: Clone,
      T: 'static,
{
    handle: Edge<String>,
    phantom_T: PhantomData<T>,
    value: Edge<T>,
    flow_in: Edge<f32>,
    op_name: Option<String>,
    id_: usize,
}

impl<T> TensorArrayUnpack<T>
where T: TensorType,
      T: Clone,
      T: 'static,
{
    pub fn flow_out(self) -> Edge<f32> {
        let rc = Rc::new(self);
        {
            Edge::<f32>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<f32> {
        let rc = Rc::new(self);
        {
            Edge::<f32>::new(rc.clone(), 0)
        }
    }

    pub fn build(handle: Edge<String>, value: Edge<T>, flow_in: Edge<f32>) -> Self {
        Self {
            handle,
            phantom_T: PhantomData,
            value,
            flow_in,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(handle: Edge<String>, value: Edge<T>, flow_in: Edge<f32>) -> Edge<f32> {
        Self {
            handle,
            phantom_T: PhantomData,
            value,
            flow_in,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl GraphOperation for _ConfigureDistributedTPU {
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("_ConfigureDistributedTPU_{}")?
        };
        let mut new_op = graph.new_operation("_ConfigureDistributedTPU", &op_name)?;
        {
            new_op.add_edge(&self.inputs)?
        }
        {
            (|attr: &i64| {new_op.set_attr_int("N", *attr)})(&self.N)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct _ConfigureDistributedTPU {
    inputs: Edge<i32>,
    N: i64,
    op_name: Option<String>,
    id_: usize,
}

impl _ConfigureDistributedTPU {
    pub fn output(self) -> Edge<String> {
        let rc = Rc::new(self);
        {
            Edge::<String>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<String> {
        let rc = Rc::new(self);
        {
            Edge::<String>::new(rc.clone(), 0)
        }
    }

    pub fn build(inputs: Edge<i32>, N: i64) -> Self {
        Self {
            inputs,
            N: N,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(inputs: Edge<i32>, N: i64) -> Edge<String> {
        Self {
            inputs,
            N: N,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl GraphOperation for TensorArrayGradV2 {
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("TensorArrayGradV2_{}")?
        };
        let mut new_op = graph.new_operation("TensorArrayGradV2", &op_name)?;
        {
            new_op.add_edge(&self.handle)?
        }
        {
            new_op.add_edge(&self.flow_in)?
        }
        {
            (|attr| {new_op.set_attr_string("source", attr)})(&self.source)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct TensorArrayGradV2 {
    handle: Edge<String>,
    flow_in: Edge<f32>,
    source: String,
    op_name: Option<String>,
    id_: usize,
}

impl TensorArrayGradV2 {
    pub fn grad_handle(self) -> Edge<String> {
        let rc = Rc::new(self);
        {
            Edge::<String>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<String> {
        let rc = Rc::new(self);
        {
            Edge::<String>::new(rc.clone(), 0)
        }
    }

    pub fn build(handle: Edge<String>, flow_in: Edge<f32>, source: &str) -> Self {
        Self {
            handle,
            flow_in,
            source: source.to_string(),
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(handle: Edge<String>, flow_in: Edge<f32>, source: &str) -> Edge<String> {
        Self {
            handle,
            flow_in,
            source: source.to_string(),
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<T> GraphOperation for DebugGradientIdentity<T>
where T: TensorType,
      T: Clone,
      T: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("DebugGradientIdentity_{}")?
        };
        let mut new_op = graph.new_operation("DebugGradientIdentity", &op_name)?;
        {
            new_op.add_edge(&self.input)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct DebugGradientIdentity<T>
where T: TensorType,
      T: Clone,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    input: Edge<T>,
    op_name: Option<String>,
    id_: usize,
}

impl<T> DebugGradientIdentity<T>
where T: TensorType,
      T: Clone,
      T: 'static,
{
    pub fn output(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(input: Edge<T>) -> Self {
        Self {
            phantom_T: PhantomData,
            input,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(input: Edge<T>) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            input,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<dtype> GraphOperation for TensorArray<dtype>
where dtype: 'static,
      dtype: Clone,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("TensorArray_{}")?
        };
        let mut new_op = graph.new_operation("TensorArray", &op_name)?;
        {
            new_op.add_edge(&self.size)?
        }
        {
            match self.dynamic_size {
                None => new_op.set_attr_value_proto("dynamic_size", &vec![40_u8, 0_u8,])?,
                Some(ref value) => (|attr: &bool| {new_op.set_attr_bool("dynamic_size", *attr)})(&value)?,
            };
        }
        {
            match self.clear_after_read {
                None => new_op.set_attr_value_proto("clear_after_read", &vec![40_u8, 1_u8,])?,
                Some(ref value) => (|attr: &bool| {new_op.set_attr_bool("clear_after_read", *attr)})(&value)?,
            };
        }
        {
            match self.tensor_array_name {
                None => new_op.set_attr_value_proto("tensor_array_name", &vec![18_u8, 0_u8,])?,
                Some(ref value) => (|attr| {new_op.set_attr_string("tensor_array_name", attr)})(&value)?,
            };
        }
        {
            match self.element_shape {
                None => new_op.set_attr_value_proto("element_shape", &vec![58_u8, 0_u8,])?,
                Some(ref value) => (|attr| {new_op.set_attr_shape("element_shape", attr)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct TensorArray<dtype>
where dtype: 'static,
      dtype: Clone,
{
    size: Edge<i32>,
    phantom_dtype: PhantomData<dtype>,
    dynamic_size: Option<bool>,
    clear_after_read: Option<bool>,
    tensor_array_name: Option<String>,
    element_shape: Option<OtherShape>,
    op_name: Option<String>,
    id_: usize,
}

impl<dtype> TensorArray<dtype>
where dtype: 'static,
      dtype: Clone,
{
    pub fn handle(self) -> Edge<String> {
        let rc = Rc::new(self);
        {
            Edge::<String>::new(rc.clone(), 0)
        }
    }

    pub fn dynamic_size(&mut self, dynamic_size: bool) -> Self {
        self.dynamic_size = Some(dynamic_size);
        self.clone()
    }

    pub fn clear_after_read(&mut self, clear_after_read: bool) -> Self {
        self.clear_after_read = Some(clear_after_read);
        self.clone()
    }

    pub fn tensor_array_name(&mut self, tensor_array_name: &str) -> Self {
        self.tensor_array_name = Some(tensor_array_name.to_string());
        self.clone()
    }

    pub fn element_shape(&mut self, element_shape: &OtherShape) -> Self {
        self.element_shape = Some(element_shape.clone());
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<String> {
        let rc = Rc::new(self);
        {
            Edge::<String>::new(rc.clone(), 0)
        }
    }

    pub fn build(size: Edge<i32>) -> Self {
        Self {
            size,
            phantom_dtype: PhantomData,
            dynamic_size: None,
            clear_after_read: None,
            tensor_array_name: None,
            element_shape: None,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(size: Edge<i32>) -> Edge<String> {
        Self {
            size,
            phantom_dtype: PhantomData,
            dynamic_size: None,
            clear_after_read: None,
            tensor_array_name: None,
            element_shape: None,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<T> GraphOperation for SeluGrad<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
      T: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("SeluGrad_{}")?
        };
        let mut new_op = graph.new_operation("SeluGrad", &op_name)?;
        {
            new_op.add_edge(&self.gradients)?
        }
        {
            new_op.add_edge(&self.outputs)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct SeluGrad<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    gradients: Edge<T>,
    outputs: Edge<T>,
    op_name: Option<String>,
    id_: usize,
}

impl<T> SeluGrad<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
      T: 'static,
{
    pub fn backprops(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(gradients: Edge<T>, outputs: Edge<T>) -> Self {
        Self {
            phantom_T: PhantomData,
            gradients,
            outputs,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(gradients: Edge<T>, outputs: Edge<T>) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            gradients,
            outputs,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl GraphOperation for StackClose {
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("StackClose_{}")?
        };
        let mut new_op = graph.new_operation("StackClose", &op_name)?;
        {
            new_op.add_edge(&self.handle)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct StackClose {
    handle: Edge<String>,
    op_name: Option<String>,
    id_: usize,
}

impl StackClose {
    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> () {
        let rc = Rc::new(self);
        (
        )
    }

    pub fn build(handle: Edge<String>) -> Self {
        Self {
            handle,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(handle: Edge<String>) -> () {
        Self {
            handle,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl GraphOperation for DecodeCompressed {
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("DecodeCompressed_{}")?
        };
        let mut new_op = graph.new_operation("DecodeCompressed", &op_name)?;
        {
            new_op.add_edge(&self.bytes)?
        }
        {
            match self.compression_type {
                None => new_op.set_attr_value_proto("compression_type", &vec![18_u8, 0_u8,])?,
                Some(ref value) => (|attr| {new_op.set_attr_string("compression_type", attr)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct DecodeCompressed {
    bytes: Edge<String>,
    compression_type: Option<String>,
    op_name: Option<String>,
    id_: usize,
}

impl DecodeCompressed {
    pub fn output(self) -> Edge<String> {
        let rc = Rc::new(self);
        {
            Edge::<String>::new(rc.clone(), 0)
        }
    }

    pub fn compression_type(&mut self, compression_type: &str) -> Self {
        self.compression_type = Some(compression_type.to_string());
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<String> {
        let rc = Rc::new(self);
        {
            Edge::<String>::new(rc.clone(), 0)
        }
    }

    pub fn build(bytes: Edge<String>) -> Self {
        Self {
            bytes,
            compression_type: None,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(bytes: Edge<String>) -> Edge<String> {
        Self {
            bytes,
            compression_type: None,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<T> GraphOperation for CudnnRNN<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_HALF,
      T: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("CudnnRNN_{}")?
        };
        let mut new_op = graph.new_operation("CudnnRNN", &op_name)?;
        {
            new_op.add_edge(&self.input)?
        }
        {
            new_op.add_edge(&self.input_h)?
        }
        {
            new_op.add_edge(&self.input_c)?
        }
        {
            new_op.add_edge(&self.params)?
        }
        {
            match self.rnn_mode {
                None => new_op.set_attr_value_proto("rnn_mode", &vec![18_u8, 4_u8, 108_u8, 115_u8, 116_u8, 109_u8,])?,
                Some(ref value) => (|attr| {new_op.set_attr_string("rnn_mode", attr)})(&value)?,
            };
        }
        {
            match self.input_mode {
                None => new_op.set_attr_value_proto("input_mode", &vec![18_u8, 12_u8, 108_u8, 105_u8, 110_u8, 101_u8, 97_u8, 114_u8, 95_u8, 105_u8, 110_u8, 112_u8, 117_u8, 116_u8,])?,
                Some(ref value) => (|attr| {new_op.set_attr_string("input_mode", attr)})(&value)?,
            };
        }
        {
            match self.direction {
                None => new_op.set_attr_value_proto("direction", &vec![18_u8, 14_u8, 117_u8, 110_u8, 105_u8, 100_u8, 105_u8, 114_u8, 101_u8, 99_u8, 116_u8, 105_u8, 111_u8, 110_u8, 97_u8, 108_u8,])?,
                Some(ref value) => (|attr| {new_op.set_attr_string("direction", attr)})(&value)?,
            };
        }
        {
            match self.dropout {
                None => new_op.set_attr_value_proto("dropout", &vec![37_u8, 0_u8, 0_u8, 0_u8, 0_u8,])?,
                Some(ref value) => (|attr: &f32| {new_op.set_attr_float("dropout", *attr)})(&value)?,
            };
        }
        {
            match self.seed {
                None => new_op.set_attr_value_proto("seed", &vec![24_u8, 0_u8,])?,
                Some(ref value) => (|attr: &i64| {new_op.set_attr_int("seed", *attr)})(&value)?,
            };
        }
        {
            match self.seed2 {
                None => new_op.set_attr_value_proto("seed2", &vec![24_u8, 0_u8,])?,
                Some(ref value) => (|attr: &i64| {new_op.set_attr_int("seed2", *attr)})(&value)?,
            };
        }
        {
            match self.is_training {
                None => new_op.set_attr_value_proto("is_training", &vec![40_u8, 1_u8,])?,
                Some(ref value) => (|attr: &bool| {new_op.set_attr_bool("is_training", *attr)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct CudnnRNN<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_HALF,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    input: Edge<T>,
    input_h: Edge<T>,
    input_c: Edge<T>,
    params: Edge<T>,
    rnn_mode: Option<String>,
    input_mode: Option<String>,
    direction: Option<String>,
    dropout: Option<f32>,
    seed: Option<i64>,
    seed2: Option<i64>,
    is_training: Option<bool>,
    op_name: Option<String>,
    id_: usize,
}

impl<T> CudnnRNN<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_HALF,
      T: 'static,
{
    pub fn output(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn output_h(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 1)
        }
    }

    pub fn output_c(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 2)
        }
    }

    pub fn reserve_space(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 3)
        }
    }

    pub fn rnn_mode(&mut self, rnn_mode: &str) -> Self {
        self.rnn_mode = Some(rnn_mode.to_string());
        self.clone()
    }

    pub fn input_mode(&mut self, input_mode: &str) -> Self {
        self.input_mode = Some(input_mode.to_string());
        self.clone()
    }

    pub fn direction(&mut self, direction: &str) -> Self {
        self.direction = Some(direction.to_string());
        self.clone()
    }

    pub fn dropout(&mut self, dropout: f32) -> Self {
        self.dropout = Some(dropout);
        self.clone()
    }

    pub fn seed(&mut self, seed: i64) -> Self {
        self.seed = Some(seed);
        self.clone()
    }

    pub fn seed2(&mut self, seed2: i64) -> Self {
        self.seed2 = Some(seed2);
        self.clone()
    }

    pub fn is_training(&mut self, is_training: bool) -> Self {
        self.is_training = Some(is_training);
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> (Edge<T>, Edge<T>, Edge<T>, Edge<T>) {
        let rc = Rc::new(self);
        (
        {
            Edge::<T>::new(rc.clone(), 0)
        },
        {
            Edge::<T>::new(rc.clone(), 1)
        },
        {
            Edge::<T>::new(rc.clone(), 2)
        },
        {
            Edge::<T>::new(rc.clone(), 3)
        },
        )
    }

    pub fn build(input: Edge<T>, input_h: Edge<T>, input_c: Edge<T>, params: Edge<T>) -> Self {
        Self {
            phantom_T: PhantomData,
            input,
            input_h,
            input_c,
            params,
            rnn_mode: None,
            input_mode: None,
            direction: None,
            dropout: None,
            seed: None,
            seed2: None,
            is_training: None,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(input: Edge<T>, input_h: Edge<T>, input_c: Edge<T>, params: Edge<T>) -> (Edge<T>, Edge<T>, Edge<T>, Edge<T>) {
        Self {
            phantom_T: PhantomData,
            input,
            input_h,
            input_c,
            params,
            rnn_mode: None,
            input_mode: None,
            direction: None,
            dropout: None,
            seed: None,
            seed2: None,
            is_training: None,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<dtypes> GraphOperation for MapIncompleteSize<dtypes>
where dtypes: 'static,
      dtypes: Clone,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("MapIncompleteSize_{}")?
        };
        let mut new_op = graph.new_operation("MapIncompleteSize", &op_name)?;
        {
            match self.capacity {
                None => new_op.set_attr_value_proto("capacity", &vec![24_u8, 0_u8,])?,
                Some(ref value) => (|attr: &i64| {new_op.set_attr_int("capacity", *attr)})(&value)?,
            };
        }
        {
            match self.memory_limit {
                None => new_op.set_attr_value_proto("memory_limit", &vec![24_u8, 0_u8,])?,
                Some(ref value) => (|attr: &i64| {new_op.set_attr_int("memory_limit", *attr)})(&value)?,
            };
        }
        {
            match self.container {
                None => new_op.set_attr_value_proto("container", &vec![18_u8, 0_u8,])?,
                Some(ref value) => (|attr| {new_op.set_attr_string("container", attr)})(&value)?,
            };
        }
        {
            match self.shared_name {
                None => new_op.set_attr_value_proto("shared_name", &vec![18_u8, 0_u8,])?,
                Some(ref value) => (|attr| {new_op.set_attr_string("shared_name", attr)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct MapIncompleteSize<dtypes>
where dtypes: 'static,
      dtypes: Clone,
{
    capacity: Option<i64>,
    memory_limit: Option<i64>,
    phantom_dtypes: PhantomData<dtypes>,
    container: Option<String>,
    shared_name: Option<String>,
    op_name: Option<String>,
    id_: usize,
}

impl<dtypes> MapIncompleteSize<dtypes>
where dtypes: 'static,
      dtypes: Clone,
{
    pub fn size(self) -> Edge<i32> {
        let rc = Rc::new(self);
        {
            Edge::<i32>::new(rc.clone(), 0)
        }
    }

    pub fn capacity(&mut self, capacity: i64) -> Self {
        self.capacity = Some(capacity);
        self.clone()
    }

    pub fn memory_limit(&mut self, memory_limit: i64) -> Self {
        self.memory_limit = Some(memory_limit);
        self.clone()
    }

    pub fn container(&mut self, container: &str) -> Self {
        self.container = Some(container.to_string());
        self.clone()
    }

    pub fn shared_name(&mut self, shared_name: &str) -> Self {
        self.shared_name = Some(shared_name.to_string());
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<i32> {
        let rc = Rc::new(self);
        {
            Edge::<i32>::new(rc.clone(), 0)
        }
    }

    pub fn build() -> Self {
        Self {
            capacity: None,
            memory_limit: None,
            phantom_dtypes: PhantomData,
            container: None,
            shared_name: None,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new() -> Edge<i32> {
        Self {
            capacity: None,
            memory_limit: None,
            phantom_dtypes: PhantomData,
            container: None,
            shared_name: None,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<T> GraphOperation for Conv3DBackpropInput<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_HALF,
      T: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("Conv3DBackpropInput_{}")?
        };
        let mut new_op = graph.new_operation("Conv3DBackpropInput", &op_name)?;
        {
            new_op.add_edge(&self.input)?
        }
        {
            new_op.add_edge(&self.filter)?
        }
        {
            new_op.add_edge(&self.out_backprop)?
        }
        {
            (|attrs| {new_op.set_attr_int_list("strides", attrs)})(&self.strides)?
        }
        {
            (|attr| {new_op.set_attr_string("padding", attr)})(&self.padding)?
        }
        {
            match self.dilations {
                None => new_op.set_attr_value_proto("dilations", &vec![10_u8, 0_u8, 26_u8, 5_u8, 1_u8, 1_u8, 1_u8, 1_u8,])?,
                Some(ref value) => (|attrs| {new_op.set_attr_int_list("dilations", attrs)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct Conv3DBackpropInput<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_HALF,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    input: Edge<T>,
    filter: Edge<T>,
    out_backprop: Edge<T>,
    strides: Vec<i64>,
    padding: String,
    dilations: Option<Vec<i64>>,
    op_name: Option<String>,
    id_: usize,
}

impl<T> Conv3DBackpropInput<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_HALF,
      T: 'static,
{
    pub fn output(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn dilations(&mut self, dilations: &[i64]) -> Self {
        self.dilations = Some(dilations.to_vec());
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(input: Edge<T>, filter: Edge<T>, out_backprop: Edge<T>, strides: &[i64], padding: &str) -> Self {
        Self {
            phantom_T: PhantomData,
            input,
            filter,
            out_backprop,
            strides: strides.to_vec(),
            padding: padding.to_string(),
            dilations: None,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(input: Edge<T>, filter: Edge<T>, out_backprop: Edge<T>, strides: &[i64], padding: &str) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            input,
            filter,
            out_backprop,
            strides: strides.to_vec(),
            padding: padding.to_string(),
            dilations: None,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<T> GraphOperation for StackPush<T>
where T: TensorType,
      T: Clone,
      T: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("StackPush_{}")?
        };
        let mut new_op = graph.new_operation("StackPush", &op_name)?;
        {
            new_op.add_edge(&self.handle)?
        }
        {
            new_op.add_edge(&self.elem)?
        }
        {
            match self.swap_memory {
                None => new_op.set_attr_value_proto("swap_memory", &vec![40_u8, 0_u8,])?,
                Some(ref value) => (|attr: &bool| {new_op.set_attr_bool("swap_memory", *attr)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct StackPush<T>
where T: TensorType,
      T: Clone,
      T: 'static,
{
    handle: Edge<String>,
    phantom_T: PhantomData<T>,
    elem: Edge<T>,
    swap_memory: Option<bool>,
    op_name: Option<String>,
    id_: usize,
}

impl<T> StackPush<T>
where T: TensorType,
      T: Clone,
      T: 'static,
{
    pub fn output(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn swap_memory(&mut self, swap_memory: bool) -> Self {
        self.swap_memory = Some(swap_memory);
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(handle: Edge<String>, elem: Edge<T>) -> Self {
        Self {
            handle,
            phantom_T: PhantomData,
            elem,
            swap_memory: None,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(handle: Edge<String>, elem: Edge<T>) -> Edge<T> {
        Self {
            handle,
            phantom_T: PhantomData,
            elem,
            swap_memory: None,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<T> GraphOperation for DenseToDenseSetOperation<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_STRING_or_DT_INT64_or_DT_UINT16,
      T: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("DenseToDenseSetOperation_{}")?
        };
        let mut new_op = graph.new_operation("DenseToDenseSetOperation", &op_name)?;
        {
            new_op.add_edge(&self.set1)?
        }
        {
            new_op.add_edge(&self.set2)?
        }
        {
            (|attr| {new_op.set_attr_string("set_operation", attr)})(&self.set_operation)?
        }
        {
            match self.validate_indices {
                None => new_op.set_attr_value_proto("validate_indices", &vec![40_u8, 1_u8,])?,
                Some(ref value) => (|attr: &bool| {new_op.set_attr_bool("validate_indices", *attr)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct DenseToDenseSetOperation<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_STRING_or_DT_INT64_or_DT_UINT16,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    set1: Edge<T>,
    set2: Edge<T>,
    set_operation: String,
    validate_indices: Option<bool>,
    op_name: Option<String>,
    id_: usize,
}

impl<T> DenseToDenseSetOperation<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_STRING_or_DT_INT64_or_DT_UINT16,
      T: 'static,
{
    pub fn result_indices(self) -> Edge<i64> {
        let rc = Rc::new(self);
        {
            Edge::<i64>::new(rc.clone(), 0)
        }
    }

    pub fn result_values(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 1)
        }
    }

    pub fn result_shape(self) -> Edge<i64> {
        let rc = Rc::new(self);
        {
            Edge::<i64>::new(rc.clone(), 2)
        }
    }

    pub fn validate_indices(&mut self, validate_indices: bool) -> Self {
        self.validate_indices = Some(validate_indices);
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> (Edge<i64>, Edge<T>, Edge<i64>) {
        let rc = Rc::new(self);
        (
        {
            Edge::<i64>::new(rc.clone(), 0)
        },
        {
            Edge::<T>::new(rc.clone(), 1)
        },
        {
            Edge::<i64>::new(rc.clone(), 2)
        },
        )
    }

    pub fn build(set1: Edge<T>, set2: Edge<T>, set_operation: &str) -> Self {
        Self {
            phantom_T: PhantomData,
            set1,
            set2,
            set_operation: set_operation.to_string(),
            validate_indices: None,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(set1: Edge<T>, set2: Edge<T>, set_operation: &str) -> (Edge<i64>, Edge<T>, Edge<i64>) {
        Self {
            phantom_T: PhantomData,
            set1,
            set2,
            set_operation: set_operation.to_string(),
            validate_indices: None,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl GraphOperation for ShardedFilename {
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("ShardedFilename_{}")?
        };
        let mut new_op = graph.new_operation("ShardedFilename", &op_name)?;
        {
            new_op.add_edge(&self.basename)?
        }
        {
            new_op.add_edge(&self.shard)?
        }
        {
            new_op.add_edge(&self.num_shards)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct ShardedFilename {
    basename: Edge<String>,
    shard: Edge<i32>,
    num_shards: Edge<i32>,
    op_name: Option<String>,
    id_: usize,
}

impl ShardedFilename {
    pub fn filename(self) -> Edge<String> {
        let rc = Rc::new(self);
        {
            Edge::<String>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<String> {
        let rc = Rc::new(self);
        {
            Edge::<String>::new(rc.clone(), 0)
        }
    }

    pub fn build(basename: Edge<String>, shard: Edge<i32>, num_shards: Edge<i32>) -> Self {
        Self {
            basename,
            shard,
            num_shards,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(basename: Edge<String>, shard: Edge<i32>, num_shards: Edge<i32>) -> Edge<String> {
        Self {
            basename,
            shard,
            num_shards,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<dtype> GraphOperation for SparseAccumulatorApplyGradient<dtype>
where dtype: TensorType,
      dtype: Clone,
      dtype: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      dtype: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("SparseAccumulatorApplyGradient_{}")?
        };
        let mut new_op = graph.new_operation("SparseAccumulatorApplyGradient", &op_name)?;
        {
            new_op.add_edge(&self.handle)?
        }
        {
            new_op.add_edge(&self.local_step)?
        }
        {
            new_op.add_edge(&self.gradient_indices)?
        }
        {
            new_op.add_edge(&self.gradient_values)?
        }
        {
            new_op.add_edge(&self.gradient_shape)?
        }
        {
            (|attr: &bool| {new_op.set_attr_bool("has_known_shape", *attr)})(&self.has_known_shape)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct SparseAccumulatorApplyGradient<dtype>
where dtype: TensorType,
      dtype: Clone,
      dtype: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      dtype: 'static,
{
    handle: Edge<String>,
    local_step: Edge<i64>,
    gradient_indices: Edge<i64>,
    phantom_dtype: PhantomData<dtype>,
    gradient_values: Edge<dtype>,
    gradient_shape: Edge<i64>,
    has_known_shape: bool,
    op_name: Option<String>,
    id_: usize,
}

impl<dtype> SparseAccumulatorApplyGradient<dtype>
where dtype: TensorType,
      dtype: Clone,
      dtype: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      dtype: 'static,
{
    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> () {
        let rc = Rc::new(self);
        (
        )
    }

    pub fn build(handle: Edge<String>, local_step: Edge<i64>, gradient_indices: Edge<i64>, gradient_values: Edge<dtype>, gradient_shape: Edge<i64>, has_known_shape: bool) -> Self {
        Self {
            handle,
            local_step,
            gradient_indices,
            phantom_dtype: PhantomData,
            gradient_values,
            gradient_shape,
            has_known_shape: has_known_shape,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(handle: Edge<String>, local_step: Edge<i64>, gradient_indices: Edge<i64>, gradient_values: Edge<dtype>, gradient_shape: Edge<i64>, has_known_shape: bool) -> () {
        Self {
            handle,
            local_step,
            gradient_indices,
            phantom_dtype: PhantomData,
            gradient_values,
            gradient_shape,
            has_known_shape: has_known_shape,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl GraphOperation for AccumulatorSetGlobalStep {
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("AccumulatorSetGlobalStep_{}")?
        };
        let mut new_op = graph.new_operation("AccumulatorSetGlobalStep", &op_name)?;
        {
            new_op.add_edge(&self.handle)?
        }
        {
            new_op.add_edge(&self.new_global_step)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct AccumulatorSetGlobalStep {
    handle: Edge<String>,
    new_global_step: Edge<i64>,
    op_name: Option<String>,
    id_: usize,
}

impl AccumulatorSetGlobalStep {
    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> () {
        let rc = Rc::new(self);
        (
        )
    }

    pub fn build(handle: Edge<String>, new_global_step: Edge<i64>) -> Self {
        Self {
            handle,
            new_global_step,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(handle: Edge<String>, new_global_step: Edge<i64>) -> () {
        Self {
            handle,
            new_global_step,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<T> GraphOperation for MatrixDiagPart<T>
where T: TensorType,
      T: Clone,
      T: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("MatrixDiagPart_{}")?
        };
        let mut new_op = graph.new_operation("MatrixDiagPart", &op_name)?;
        {
            new_op.add_edge(&self.input)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct MatrixDiagPart<T>
where T: TensorType,
      T: Clone,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    input: Edge<T>,
    op_name: Option<String>,
    id_: usize,
}

impl<T> MatrixDiagPart<T>
where T: TensorType,
      T: Clone,
      T: 'static,
{
    pub fn diagonal(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(input: Edge<T>) -> Self {
        Self {
            phantom_T: PhantomData,
            input,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(input: Edge<T>) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            input,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<output_type> GraphOperation for ExtractJpegShape<output_type>
where output_type: TensorType,
      output_type: con_or_DT_INT32_or_DT_INT64,
      output_type: 'static,
      output_type: Clone,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("ExtractJpegShape_{}")?
        };
        let mut new_op = graph.new_operation("ExtractJpegShape", &op_name)?;
        {
            new_op.add_edge(&self.contents)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct ExtractJpegShape<output_type>
where output_type: TensorType,
      output_type: con_or_DT_INT32_or_DT_INT64,
      output_type: 'static,
      output_type: Clone,
{
    contents: Edge<String>,
    phantom_output_type: PhantomData<output_type>,
    op_name: Option<String>,
    id_: usize,
}

impl<output_type> ExtractJpegShape<output_type>
where output_type: TensorType,
      output_type: con_or_DT_INT32_or_DT_INT64,
      output_type: 'static,
      output_type: Clone,
{
    pub fn image_shape(self) -> Edge<output_type> {
        let rc = Rc::new(self);
        {
            Edge::<output_type>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<output_type> {
        let rc = Rc::new(self);
        {
            Edge::<output_type>::new(rc.clone(), 0)
        }
    }

    pub fn build(contents: Edge<String>) -> Self {
        Self {
            contents,
            phantom_output_type: PhantomData,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(contents: Edge<String>) -> Edge<output_type> {
        Self {
            contents,
            phantom_output_type: PhantomData,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<elem_type> GraphOperation for StackPop<elem_type>
where elem_type: TensorType,
      elem_type: 'static,
      elem_type: Clone,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("StackPop_{}")?
        };
        let mut new_op = graph.new_operation("StackPop", &op_name)?;
        {
            new_op.add_edge(&self.handle)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct StackPop<elem_type>
where elem_type: TensorType,
      elem_type: 'static,
      elem_type: Clone,
{
    handle: Edge<String>,
    phantom_elem_type: PhantomData<elem_type>,
    op_name: Option<String>,
    id_: usize,
}

impl<elem_type> StackPop<elem_type>
where elem_type: TensorType,
      elem_type: 'static,
      elem_type: Clone,
{
    pub fn elem(self) -> Edge<elem_type> {
        let rc = Rc::new(self);
        {
            Edge::<elem_type>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<elem_type> {
        let rc = Rc::new(self);
        {
            Edge::<elem_type>::new(rc.clone(), 0)
        }
    }

    pub fn build(handle: Edge<String>) -> Self {
        Self {
            handle,
            phantom_elem_type: PhantomData,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(handle: Edge<String>) -> Edge<elem_type> {
        Self {
            handle,
            phantom_elem_type: PhantomData,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<T> GraphOperation for Inv<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_COMPLEX64_or_DT_INT64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF,
      T: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("Inv_{}")?
        };
        let mut new_op = graph.new_operation("Inv", &op_name)?;
        {
            new_op.add_edge(&self.x)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct Inv<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_COMPLEX64_or_DT_INT64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    x: Edge<T>,
    op_name: Option<String>,
    id_: usize,
}

impl<T> Inv<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_COMPLEX64_or_DT_INT64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF,
      T: 'static,
{
    pub fn y(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(x: Edge<T>) -> Self {
        Self {
            phantom_T: PhantomData,
            x,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(x: Edge<T>) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            x,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<T> GraphOperation for ParallelDynamicStitch<T>
where T: TensorType,
      T: Clone,
      T: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("ParallelDynamicStitch_{}")?
        };
        let mut new_op = graph.new_operation("ParallelDynamicStitch", &op_name)?;
        {
            new_op.add_edge(&self.indices)?
        }
        {
            new_op.add_edge(&self.data)?
        }
        {
            (|attr: &i64| {new_op.set_attr_int("N", *attr)})(&self.N)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct ParallelDynamicStitch<T>
where T: TensorType,
      T: Clone,
      T: 'static,
{
    indices: Edge<i32>,
    phantom_T: PhantomData<T>,
    data: Edge<T>,
    N: i64,
    op_name: Option<String>,
    id_: usize,
}

impl<T> ParallelDynamicStitch<T>
where T: TensorType,
      T: Clone,
      T: 'static,
{
    pub fn merged(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(indices: Edge<i32>, data: Edge<T>, N: i64) -> Self {
        Self {
            indices,
            phantom_T: PhantomData,
            data,
            N: N,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(indices: Edge<i32>, data: Edge<T>, N: i64) -> Edge<T> {
        Self {
            indices,
            phantom_T: PhantomData,
            data,
            N: N,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<T> GraphOperation for DynamicPartition<T>
where T: TensorType,
      T: Clone,
      T: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("DynamicPartition_{}")?
        };
        let mut new_op = graph.new_operation("DynamicPartition", &op_name)?;
        {
            new_op.add_edge(&self.data)?
        }
        {
            new_op.add_edge(&self.partitions)?
        }
        {
            (|attr: &i64| {new_op.set_attr_int("num_partitions", *attr)})(&self.num_partitions)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct DynamicPartition<T>
where T: TensorType,
      T: Clone,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    data: Edge<T>,
    partitions: Edge<i32>,
    num_partitions: i64,
    op_name: Option<String>,
    id_: usize,
}

impl<T> DynamicPartition<T>
where T: TensorType,
      T: Clone,
      T: 'static,
{
    pub fn outputs(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(data: Edge<T>, partitions: Edge<i32>, num_partitions: i64) -> Self {
        Self {
            phantom_T: PhantomData,
            data,
            partitions,
            num_partitions: num_partitions,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(data: Edge<T>, partitions: Edge<i32>, num_partitions: i64) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            data,
            partitions,
            num_partitions: num_partitions,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<T> GraphOperation for BatchCholesky<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE,
      T: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("BatchCholesky_{}")?
        };
        let mut new_op = graph.new_operation("BatchCholesky", &op_name)?;
        {
            new_op.add_edge(&self.input)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct BatchCholesky<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    input: Edge<T>,
    op_name: Option<String>,
    id_: usize,
}

impl<T> BatchCholesky<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE,
      T: 'static,
{
    pub fn output(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(input: Edge<T>) -> Self {
        Self {
            phantom_T: PhantomData,
            input,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(input: Edge<T>) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            input,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<key_dtype, value_dtype> GraphOperation for MutableDenseHashTable<key_dtype, value_dtype>
where key_dtype: TensorType,
      key_dtype: Clone,
      key_dtype: 'static,
      value_dtype: 'static,
      value_dtype: Clone,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("MutableDenseHashTable_{}")?
        };
        let mut new_op = graph.new_operation("MutableDenseHashTable", &op_name)?;
        {
            new_op.add_edge(&self.empty_key)?
        }
        {
            match self.container {
                None => new_op.set_attr_value_proto("container", &vec![18_u8, 0_u8,])?,
                Some(ref value) => (|attr| {new_op.set_attr_string("container", attr)})(&value)?,
            };
        }
        {
            match self.shared_name {
                None => new_op.set_attr_value_proto("shared_name", &vec![18_u8, 0_u8,])?,
                Some(ref value) => (|attr| {new_op.set_attr_string("shared_name", attr)})(&value)?,
            };
        }
        {
            match self.use_node_name_sharing {
                None => new_op.set_attr_value_proto("use_node_name_sharing", &vec![40_u8, 0_u8,])?,
                Some(ref value) => (|attr: &bool| {new_op.set_attr_bool("use_node_name_sharing", *attr)})(&value)?,
            };
        }
        {
            match self.value_shape {
                None => new_op.set_attr_value_proto("value_shape", &vec![58_u8, 0_u8,])?,
                Some(ref value) => (|attr| {new_op.set_attr_shape("value_shape", attr)})(&value)?,
            };
        }
        {
            match self.initial_num_buckets {
                None => new_op.set_attr_value_proto("initial_num_buckets", &vec![24_u8, 128_u8, 128_u8, 8_u8,])?,
                Some(ref value) => (|attr: &i64| {new_op.set_attr_int("initial_num_buckets", *attr)})(&value)?,
            };
        }
        {
            match self.max_load_factor {
                None => new_op.set_attr_value_proto("max_load_factor", &vec![37_u8, 205_u8, 204_u8, 76_u8, 63_u8,])?,
                Some(ref value) => (|attr: &f32| {new_op.set_attr_float("max_load_factor", *attr)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct MutableDenseHashTable<key_dtype, value_dtype>
where key_dtype: TensorType,
      key_dtype: Clone,
      key_dtype: 'static,
      value_dtype: 'static,
      value_dtype: Clone,
{
    phantom_key_dtype: PhantomData<key_dtype>,
    empty_key: Edge<key_dtype>,
    container: Option<String>,
    shared_name: Option<String>,
    use_node_name_sharing: Option<bool>,
    phantom_value_dtype: PhantomData<value_dtype>,
    value_shape: Option<OtherShape>,
    initial_num_buckets: Option<i64>,
    max_load_factor: Option<f32>,
    op_name: Option<String>,
    id_: usize,
}

impl<key_dtype, value_dtype> MutableDenseHashTable<key_dtype, value_dtype>
where key_dtype: TensorType,
      key_dtype: Clone,
      key_dtype: 'static,
      value_dtype: 'static,
      value_dtype: Clone,
{
    pub fn table_handle(self) -> Edge<String> {
        let rc = Rc::new(self);
        {
            Edge::<String>::new(rc.clone(), 0)
        }
    }

    pub fn container(&mut self, container: &str) -> Self {
        self.container = Some(container.to_string());
        self.clone()
    }

    pub fn shared_name(&mut self, shared_name: &str) -> Self {
        self.shared_name = Some(shared_name.to_string());
        self.clone()
    }

    pub fn use_node_name_sharing(&mut self, use_node_name_sharing: bool) -> Self {
        self.use_node_name_sharing = Some(use_node_name_sharing);
        self.clone()
    }

    pub fn value_shape(&mut self, value_shape: &OtherShape) -> Self {
        self.value_shape = Some(value_shape.clone());
        self.clone()
    }

    pub fn initial_num_buckets(&mut self, initial_num_buckets: i64) -> Self {
        self.initial_num_buckets = Some(initial_num_buckets);
        self.clone()
    }

    pub fn max_load_factor(&mut self, max_load_factor: f32) -> Self {
        self.max_load_factor = Some(max_load_factor);
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<String> {
        let rc = Rc::new(self);
        {
            Edge::<String>::new(rc.clone(), 0)
        }
    }

    pub fn build(empty_key: Edge<key_dtype>) -> Self {
        Self {
            phantom_key_dtype: PhantomData,
            empty_key,
            container: None,
            shared_name: None,
            use_node_name_sharing: None,
            phantom_value_dtype: PhantomData,
            value_shape: None,
            initial_num_buckets: None,
            max_load_factor: None,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(empty_key: Edge<key_dtype>) -> Edge<String> {
        Self {
            phantom_key_dtype: PhantomData,
            empty_key,
            container: None,
            shared_name: None,
            use_node_name_sharing: None,
            phantom_value_dtype: PhantomData,
            value_shape: None,
            initial_num_buckets: None,
            max_load_factor: None,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl GraphOperation for UniformCandidateSampler {
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("UniformCandidateSampler_{}")?
        };
        let mut new_op = graph.new_operation("UniformCandidateSampler", &op_name)?;
        {
            new_op.add_edge(&self.true_classes)?
        }
        {
            (|attr: &i64| {new_op.set_attr_int("num_true", *attr)})(&self.num_true)?
        }
        {
            (|attr: &i64| {new_op.set_attr_int("num_sampled", *attr)})(&self.num_sampled)?
        }
        {
            (|attr: &bool| {new_op.set_attr_bool("unique", *attr)})(&self.unique)?
        }
        {
            (|attr: &i64| {new_op.set_attr_int("range_max", *attr)})(&self.range_max)?
        }
        {
            match self.seed {
                None => new_op.set_attr_value_proto("seed", &vec![24_u8, 0_u8,])?,
                Some(ref value) => (|attr: &i64| {new_op.set_attr_int("seed", *attr)})(&value)?,
            };
        }
        {
            match self.seed2 {
                None => new_op.set_attr_value_proto("seed2", &vec![24_u8, 0_u8,])?,
                Some(ref value) => (|attr: &i64| {new_op.set_attr_int("seed2", *attr)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct UniformCandidateSampler {
    true_classes: Edge<i64>,
    num_true: i64,
    num_sampled: i64,
    unique: bool,
    range_max: i64,
    seed: Option<i64>,
    seed2: Option<i64>,
    op_name: Option<String>,
    id_: usize,
}

impl UniformCandidateSampler {
    pub fn sampled_candidates(self) -> Edge<i64> {
        let rc = Rc::new(self);
        {
            Edge::<i64>::new(rc.clone(), 0)
        }
    }

    pub fn true_expected_count(self) -> Edge<f32> {
        let rc = Rc::new(self);
        {
            Edge::<f32>::new(rc.clone(), 1)
        }
    }

    pub fn sampled_expected_count(self) -> Edge<f32> {
        let rc = Rc::new(self);
        {
            Edge::<f32>::new(rc.clone(), 2)
        }
    }

    pub fn seed(&mut self, seed: i64) -> Self {
        self.seed = Some(seed);
        self.clone()
    }

    pub fn seed2(&mut self, seed2: i64) -> Self {
        self.seed2 = Some(seed2);
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> (Edge<i64>, Edge<f32>, Edge<f32>) {
        let rc = Rc::new(self);
        (
        {
            Edge::<i64>::new(rc.clone(), 0)
        },
        {
            Edge::<f32>::new(rc.clone(), 1)
        },
        {
            Edge::<f32>::new(rc.clone(), 2)
        },
        )
    }

    pub fn build(true_classes: Edge<i64>, num_true: i64, num_sampled: i64, unique: bool, range_max: i64) -> Self {
        Self {
            true_classes,
            num_true: num_true,
            num_sampled: num_sampled,
            unique: unique,
            range_max: range_max,
            seed: None,
            seed2: None,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(true_classes: Edge<i64>, num_true: i64, num_sampled: i64, unique: bool, range_max: i64) -> (Edge<i64>, Edge<f32>, Edge<f32>) {
        Self {
            true_classes,
            num_true: num_true,
            num_sampled: num_sampled,
            unique: unique,
            range_max: range_max,
            seed: None,
            seed2: None,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<T, Tidx> GraphOperation for SparseSegmentMean<T, Tidx>
where T: TensorType,
      T: Clone,
      Tidx: TensorType,
      Tidx: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE,
      T: 'static,
      Tidx: con_or_DT_INT32_or_DT_INT64,
      Tidx: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("SparseSegmentMean_{}")?
        };
        let mut new_op = graph.new_operation("SparseSegmentMean", &op_name)?;
        {
            new_op.add_edge(&self.data)?
        }
        {
            new_op.add_edge(&self.indices)?
        }
        {
            new_op.add_edge(&self.segment_ids)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct SparseSegmentMean<T, Tidx>
where T: TensorType,
      T: Clone,
      Tidx: TensorType,
      Tidx: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE,
      T: 'static,
      Tidx: con_or_DT_INT32_or_DT_INT64,
      Tidx: 'static,
{
    phantom_T: PhantomData<T>,
    data: Edge<T>,
    phantom_Tidx: PhantomData<Tidx>,
    indices: Edge<Tidx>,
    segment_ids: Edge<i32>,
    op_name: Option<String>,
    id_: usize,
}

impl<T, Tidx> SparseSegmentMean<T, Tidx>
where T: TensorType,
      T: Clone,
      Tidx: TensorType,
      Tidx: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE,
      T: 'static,
      Tidx: con_or_DT_INT32_or_DT_INT64,
      Tidx: 'static,
{
    pub fn output(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(data: Edge<T>, indices: Edge<Tidx>, segment_ids: Edge<i32>) -> Self {
        Self {
            phantom_T: PhantomData,
            data,
            phantom_Tidx: PhantomData,
            indices,
            segment_ids,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(data: Edge<T>, indices: Edge<Tidx>, segment_ids: Edge<i32>) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            data,
            phantom_Tidx: PhantomData,
            indices,
            segment_ids,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<T> GraphOperation for BatchCholeskyGrad<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE,
      T: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("BatchCholeskyGrad_{}")?
        };
        let mut new_op = graph.new_operation("BatchCholeskyGrad", &op_name)?;
        {
            new_op.add_edge(&self.l)?
        }
        {
            new_op.add_edge(&self.grad)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct BatchCholeskyGrad<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    l: Edge<T>,
    grad: Edge<T>,
    op_name: Option<String>,
    id_: usize,
}

impl<T> BatchCholeskyGrad<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE,
      T: 'static,
{
    pub fn output(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(l: Edge<T>, grad: Edge<T>) -> Self {
        Self {
            phantom_T: PhantomData,
            l,
            grad,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(l: Edge<T>, grad: Edge<T>) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            l,
            grad,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl GraphOperation for CTCLoss {
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("CTCLoss_{}")?
        };
        let mut new_op = graph.new_operation("CTCLoss", &op_name)?;
        {
            new_op.add_edge(&self.inputs)?
        }
        {
            new_op.add_edge(&self.labels_indices)?
        }
        {
            new_op.add_edge(&self.labels_values)?
        }
        {
            new_op.add_edge(&self.sequence_length)?
        }
        {
            match self.preprocess_collapse_repeated {
                None => new_op.set_attr_value_proto("preprocess_collapse_repeated", &vec![40_u8, 0_u8,])?,
                Some(ref value) => (|attr: &bool| {new_op.set_attr_bool("preprocess_collapse_repeated", *attr)})(&value)?,
            };
        }
        {
            match self.ctc_merge_repeated {
                None => new_op.set_attr_value_proto("ctc_merge_repeated", &vec![40_u8, 1_u8,])?,
                Some(ref value) => (|attr: &bool| {new_op.set_attr_bool("ctc_merge_repeated", *attr)})(&value)?,
            };
        }
        {
            match self.ignore_longer_outputs_than_inputs {
                None => new_op.set_attr_value_proto("ignore_longer_outputs_than_inputs", &vec![40_u8, 0_u8,])?,
                Some(ref value) => (|attr: &bool| {new_op.set_attr_bool("ignore_longer_outputs_than_inputs", *attr)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct CTCLoss {
    inputs: Edge<f32>,
    labels_indices: Edge<i64>,
    labels_values: Edge<i32>,
    sequence_length: Edge<i32>,
    preprocess_collapse_repeated: Option<bool>,
    ctc_merge_repeated: Option<bool>,
    ignore_longer_outputs_than_inputs: Option<bool>,
    op_name: Option<String>,
    id_: usize,
}

impl CTCLoss {
    pub fn loss(self) -> Edge<f32> {
        let rc = Rc::new(self);
        {
            Edge::<f32>::new(rc.clone(), 0)
        }
    }

    pub fn gradient(self) -> Edge<f32> {
        let rc = Rc::new(self);
        {
            Edge::<f32>::new(rc.clone(), 1)
        }
    }

    pub fn preprocess_collapse_repeated(&mut self, preprocess_collapse_repeated: bool) -> Self {
        self.preprocess_collapse_repeated = Some(preprocess_collapse_repeated);
        self.clone()
    }

    pub fn ctc_merge_repeated(&mut self, ctc_merge_repeated: bool) -> Self {
        self.ctc_merge_repeated = Some(ctc_merge_repeated);
        self.clone()
    }

    pub fn ignore_longer_outputs_than_inputs(&mut self, ignore_longer_outputs_than_inputs: bool) -> Self {
        self.ignore_longer_outputs_than_inputs = Some(ignore_longer_outputs_than_inputs);
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> (Edge<f32>, Edge<f32>) {
        let rc = Rc::new(self);
        (
        {
            Edge::<f32>::new(rc.clone(), 0)
        },
        {
            Edge::<f32>::new(rc.clone(), 1)
        },
        )
    }

    pub fn build(inputs: Edge<f32>, labels_indices: Edge<i64>, labels_values: Edge<i32>, sequence_length: Edge<i32>) -> Self {
        Self {
            inputs,
            labels_indices,
            labels_values,
            sequence_length,
            preprocess_collapse_repeated: None,
            ctc_merge_repeated: None,
            ignore_longer_outputs_than_inputs: None,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(inputs: Edge<f32>, labels_indices: Edge<i64>, labels_values: Edge<i32>, sequence_length: Edge<i32>) -> (Edge<f32>, Edge<f32>) {
        Self {
            inputs,
            labels_indices,
            labels_values,
            sequence_length,
            preprocess_collapse_repeated: None,
            ctc_merge_repeated: None,
            ignore_longer_outputs_than_inputs: None,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<T> GraphOperation for SparseFillEmptyRowsGrad<T>
where T: TensorType,
      T: Clone,
      T: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("SparseFillEmptyRowsGrad_{}")?
        };
        let mut new_op = graph.new_operation("SparseFillEmptyRowsGrad", &op_name)?;
        {
            new_op.add_edge(&self.reverse_index_map)?
        }
        {
            new_op.add_edge(&self.grad_values)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct SparseFillEmptyRowsGrad<T>
where T: TensorType,
      T: Clone,
      T: 'static,
{
    reverse_index_map: Edge<i64>,
    phantom_T: PhantomData<T>,
    grad_values: Edge<T>,
    op_name: Option<String>,
    id_: usize,
}

impl<T> SparseFillEmptyRowsGrad<T>
where T: TensorType,
      T: Clone,
      T: 'static,
{
    pub fn d_values(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn d_default_value(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 1)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> (Edge<T>, Edge<T>) {
        let rc = Rc::new(self);
        (
        {
            Edge::<T>::new(rc.clone(), 0)
        },
        {
            Edge::<T>::new(rc.clone(), 1)
        },
        )
    }

    pub fn build(reverse_index_map: Edge<i64>, grad_values: Edge<T>) -> Self {
        Self {
            reverse_index_map,
            phantom_T: PhantomData,
            grad_values,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(reverse_index_map: Edge<i64>, grad_values: Edge<T>) -> (Edge<T>, Edge<T>) {
        Self {
            reverse_index_map,
            phantom_T: PhantomData,
            grad_values,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

pub trait con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_BOOL_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_BOOL_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF for BFloat16 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_BOOL_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF for OtherComplex<f32> {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_BOOL_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF for OtherComplex<f64> {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_BOOL_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF for bool {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_BOOL_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF for f32 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_BOOL_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF for f64 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_BOOL_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF for i16 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_BOOL_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF for i32 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_BOOL_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF for i64 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_BOOL_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF for i8 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_BOOL_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF for u16 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_BOOL_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF for u8 {
}

impl<T> GraphOperation for OnesLike<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_BOOL_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF,
      T: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("OnesLike_{}")?
        };
        let mut new_op = graph.new_operation("OnesLike", &op_name)?;
        {
            new_op.add_edge(&self.x)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct OnesLike<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_BOOL_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    x: Edge<T>,
    op_name: Option<String>,
    id_: usize,
}

impl<T> OnesLike<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_BOOL_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF,
      T: 'static,
{
    pub fn y(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(x: Edge<T>) -> Self {
        Self {
            phantom_T: PhantomData,
            x,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(x: Edge<T>) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            x,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

pub trait con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_INT64_or_DT_BFLOAT16_or_DT_HALF_or_DT_HALF {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_INT64_or_DT_BFLOAT16_or_DT_HALF_or_DT_HALF for BFloat16 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_INT64_or_DT_BFLOAT16_or_DT_HALF_or_DT_HALF for f32 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_INT64_or_DT_BFLOAT16_or_DT_HALF_or_DT_HALF for f64 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_INT64_or_DT_BFLOAT16_or_DT_HALF_or_DT_HALF for i32 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_INT64_or_DT_BFLOAT16_or_DT_HALF_or_DT_HALF for i64 {
}

impl<T> GraphOperation for Mod<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_INT64_or_DT_BFLOAT16_or_DT_HALF_or_DT_HALF,
      T: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("Mod_{}")?
        };
        let mut new_op = graph.new_operation("Mod", &op_name)?;
        {
            new_op.add_edge(&self.x)?
        }
        {
            new_op.add_edge(&self.y)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct Mod<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_INT64_or_DT_BFLOAT16_or_DT_HALF_or_DT_HALF,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    x: Edge<T>,
    y: Edge<T>,
    op_name: Option<String>,
    id_: usize,
}

impl<T> Mod<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_INT64_or_DT_BFLOAT16_or_DT_HALF_or_DT_HALF,
      T: 'static,
{
    pub fn z(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(x: Edge<T>, y: Edge<T>) -> Self {
        Self {
            phantom_T: PhantomData,
            x,
            y,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(x: Edge<T>, y: Edge<T>) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            x,
            y,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl GraphOperation for Abort {
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("Abort_{}")?
        };
        let mut new_op = graph.new_operation("Abort", &op_name)?;
        {
            match self.error_msg {
                None => new_op.set_attr_value_proto("error_msg", &vec![18_u8, 0_u8,])?,
                Some(ref value) => (|attr| {new_op.set_attr_string("error_msg", attr)})(&value)?,
            };
        }
        {
            match self.exit_without_error {
                None => new_op.set_attr_value_proto("exit_without_error", &vec![40_u8, 0_u8,])?,
                Some(ref value) => (|attr: &bool| {new_op.set_attr_bool("exit_without_error", *attr)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct Abort {
    error_msg: Option<String>,
    exit_without_error: Option<bool>,
    op_name: Option<String>,
    id_: usize,
}

impl Abort {
    pub fn error_msg(&mut self, error_msg: &str) -> Self {
        self.error_msg = Some(error_msg.to_string());
        self.clone()
    }

    pub fn exit_without_error(&mut self, exit_without_error: bool) -> Self {
        self.exit_without_error = Some(exit_without_error);
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> () {
        let rc = Rc::new(self);
        (
        )
    }

    pub fn build() -> Self {
        Self {
            error_msg: None,
            exit_without_error: None,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new() -> () {
        Self {
            error_msg: None,
            exit_without_error: None,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl GraphOperation for LoadTPUEmbeddingProximalAdagradParametersGradAccumDebug {
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("LoadTPUEmbeddingProximalAdagradParametersGradAccumDebug_{}")?
        };
        let mut new_op = graph.new_operation("LoadTPUEmbeddingProximalAdagradParametersGradAccumDebug", &op_name)?;
        {
            new_op.add_edge(&self.parameters)?
        }
        {
            new_op.add_edge(&self.accumulators)?
        }
        {
            new_op.add_edge(&self.gradient_accumulators)?
        }
        {
            match self.table_id {
                None => new_op.set_attr_value_proto("table_id", &vec![24_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 1_u8,])?,
                Some(ref value) => (|attr: &i64| {new_op.set_attr_int("table_id", *attr)})(&value)?,
            };
        }
        {
            match self.table_name {
                None => new_op.set_attr_value_proto("table_name", &vec![18_u8, 0_u8,])?,
                Some(ref value) => (|attr| {new_op.set_attr_string("table_name", attr)})(&value)?,
            };
        }
        {
            (|attr: &i64| {new_op.set_attr_int("num_shards", *attr)})(&self.num_shards)?
        }
        {
            (|attr: &i64| {new_op.set_attr_int("shard_id", *attr)})(&self.shard_id)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct LoadTPUEmbeddingProximalAdagradParametersGradAccumDebug {
    parameters: Edge<f32>,
    accumulators: Edge<f32>,
    gradient_accumulators: Edge<f32>,
    table_id: Option<i64>,
    table_name: Option<String>,
    num_shards: i64,
    shard_id: i64,
    op_name: Option<String>,
    id_: usize,
}

impl LoadTPUEmbeddingProximalAdagradParametersGradAccumDebug {
    pub fn table_id(&mut self, table_id: i64) -> Self {
        self.table_id = Some(table_id);
        self.clone()
    }

    pub fn table_name(&mut self, table_name: &str) -> Self {
        self.table_name = Some(table_name.to_string());
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> () {
        let rc = Rc::new(self);
        (
        )
    }

    pub fn build(parameters: Edge<f32>, accumulators: Edge<f32>, gradient_accumulators: Edge<f32>, num_shards: i64, shard_id: i64) -> Self {
        Self {
            parameters,
            accumulators,
            gradient_accumulators,
            table_id: None,
            table_name: None,
            num_shards: num_shards,
            shard_id: shard_id,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(parameters: Edge<f32>, accumulators: Edge<f32>, gradient_accumulators: Edge<f32>, num_shards: i64, shard_id: i64) -> () {
        Self {
            parameters,
            accumulators,
            gradient_accumulators,
            table_id: None,
            table_name: None,
            num_shards: num_shards,
            shard_id: shard_id,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl GraphOperation for LoopCond {
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("LoopCond_{}")?
        };
        let mut new_op = graph.new_operation("LoopCond", &op_name)?;
        {
            new_op.add_edge(&self.input)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct LoopCond {
    input: Edge<bool>,
    op_name: Option<String>,
    id_: usize,
}

impl LoopCond {
    pub fn output(self) -> Edge<bool> {
        let rc = Rc::new(self);
        {
            Edge::<bool>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<bool> {
        let rc = Rc::new(self);
        {
            Edge::<bool>::new(rc.clone(), 0)
        }
    }

    pub fn build(input: Edge<bool>) -> Self {
        Self {
            input,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(input: Edge<bool>) -> Edge<bool> {
        Self {
            input,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<T> GraphOperation for SquaredDifference<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_COMPLEX64_or_DT_INT64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF,
      T: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("SquaredDifference_{}")?
        };
        let mut new_op = graph.new_operation("SquaredDifference", &op_name)?;
        {
            new_op.add_edge(&self.x)?
        }
        {
            new_op.add_edge(&self.y)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct SquaredDifference<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_COMPLEX64_or_DT_INT64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    x: Edge<T>,
    y: Edge<T>,
    op_name: Option<String>,
    id_: usize,
}

impl<T> SquaredDifference<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_COMPLEX64_or_DT_INT64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF,
      T: 'static,
{
    pub fn z(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(x: Edge<T>, y: Edge<T>) -> Self {
        Self {
            phantom_T: PhantomData,
            x,
            y,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(x: Edge<T>, y: Edge<T>) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            x,
            y,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<S, T> GraphOperation for RandomGamma<S, T>
where S: TensorType,
      S: Clone,
      T: TensorType,
      T: Clone,
      S: con_or_DT_INT32_or_DT_INT64,
      S: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_HALF,
      T: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("RandomGamma_{}")?
        };
        let mut new_op = graph.new_operation("RandomGamma", &op_name)?;
        {
            new_op.add_edge(&self.shape)?
        }
        {
            new_op.add_edge(&self.alpha)?
        }
        {
            match self.seed {
                None => new_op.set_attr_value_proto("seed", &vec![24_u8, 0_u8,])?,
                Some(ref value) => (|attr: &i64| {new_op.set_attr_int("seed", *attr)})(&value)?,
            };
        }
        {
            match self.seed2 {
                None => new_op.set_attr_value_proto("seed2", &vec![24_u8, 0_u8,])?,
                Some(ref value) => (|attr: &i64| {new_op.set_attr_int("seed2", *attr)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct RandomGamma<S, T>
where S: TensorType,
      S: Clone,
      T: TensorType,
      T: Clone,
      S: con_or_DT_INT32_or_DT_INT64,
      S: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_HALF,
      T: 'static,
{
    phantom_S: PhantomData<S>,
    shape: Edge<S>,
    phantom_T: PhantomData<T>,
    alpha: Edge<T>,
    seed: Option<i64>,
    seed2: Option<i64>,
    op_name: Option<String>,
    id_: usize,
}

impl<S, T> RandomGamma<S, T>
where S: TensorType,
      S: Clone,
      T: TensorType,
      T: Clone,
      S: con_or_DT_INT32_or_DT_INT64,
      S: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_HALF,
      T: 'static,
{
    pub fn output(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn seed(&mut self, seed: i64) -> Self {
        self.seed = Some(seed);
        self.clone()
    }

    pub fn seed2(&mut self, seed2: i64) -> Self {
        self.seed2 = Some(seed2);
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(shape: Edge<S>, alpha: Edge<T>) -> Self {
        Self {
            phantom_S: PhantomData,
            shape,
            phantom_T: PhantomData,
            alpha,
            seed: None,
            seed2: None,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(shape: Edge<S>, alpha: Edge<T>) -> Edge<T> {
        Self {
            phantom_S: PhantomData,
            shape,
            phantom_T: PhantomData,
            alpha,
            seed: None,
            seed2: None,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<Tinput, out_type> GraphOperation for QuantizeDownAndShrinkRange<Tinput, out_type>
where Tinput: TensorType,
      Tinput: Clone,
      out_type: TensorType,
      Tinput: con_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_QINT16_or_DT_QUINT16,
      Tinput: 'static,
      out_type: con_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_QINT16_or_DT_QUINT16,
      out_type: 'static,
      out_type: Clone,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("QuantizeDownAndShrinkRange_{}")?
        };
        let mut new_op = graph.new_operation("QuantizeDownAndShrinkRange", &op_name)?;
        {
            new_op.add_edge(&self.input)?
        }
        {
            new_op.add_edge(&self.input_min)?
        }
        {
            new_op.add_edge(&self.input_max)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct QuantizeDownAndShrinkRange<Tinput, out_type>
where Tinput: TensorType,
      Tinput: Clone,
      out_type: TensorType,
      Tinput: con_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_QINT16_or_DT_QUINT16,
      Tinput: 'static,
      out_type: con_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_QINT16_or_DT_QUINT16,
      out_type: 'static,
      out_type: Clone,
{
    phantom_Tinput: PhantomData<Tinput>,
    input: Edge<Tinput>,
    input_min: Edge<f32>,
    input_max: Edge<f32>,
    phantom_out_type: PhantomData<out_type>,
    op_name: Option<String>,
    id_: usize,
}

impl<Tinput, out_type> QuantizeDownAndShrinkRange<Tinput, out_type>
where Tinput: TensorType,
      Tinput: Clone,
      out_type: TensorType,
      Tinput: con_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_QINT16_or_DT_QUINT16,
      Tinput: 'static,
      out_type: con_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_QINT16_or_DT_QUINT16,
      out_type: 'static,
      out_type: Clone,
{
    pub fn output(self) -> Edge<out_type> {
        let rc = Rc::new(self);
        {
            Edge::<out_type>::new(rc.clone(), 0)
        }
    }

    pub fn output_min(self) -> Edge<f32> {
        let rc = Rc::new(self);
        {
            Edge::<f32>::new(rc.clone(), 1)
        }
    }

    pub fn output_max(self) -> Edge<f32> {
        let rc = Rc::new(self);
        {
            Edge::<f32>::new(rc.clone(), 2)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> (Edge<out_type>, Edge<f32>, Edge<f32>) {
        let rc = Rc::new(self);
        (
        {
            Edge::<out_type>::new(rc.clone(), 0)
        },
        {
            Edge::<f32>::new(rc.clone(), 1)
        },
        {
            Edge::<f32>::new(rc.clone(), 2)
        },
        )
    }

    pub fn build(input: Edge<Tinput>, input_min: Edge<f32>, input_max: Edge<f32>) -> Self {
        Self {
            phantom_Tinput: PhantomData,
            input,
            input_min,
            input_max,
            phantom_out_type: PhantomData,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(input: Edge<Tinput>, input_min: Edge<f32>, input_max: Edge<f32>) -> (Edge<out_type>, Edge<f32>, Edge<f32>) {
        Self {
            phantom_Tinput: PhantomData,
            input,
            input_min,
            input_max,
            phantom_out_type: PhantomData,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl GraphOperation for Fact {
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("Fact_{}")?
        };
        let mut new_op = graph.new_operation("Fact", &op_name)?;
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct Fact {
    op_name: Option<String>,
    id_: usize,
}

impl Fact {
    pub fn fact(self) -> Edge<String> {
        let rc = Rc::new(self);
        {
            Edge::<String>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<String> {
        let rc = Rc::new(self);
        {
            Edge::<String>::new(rc.clone(), 0)
        }
    }

    pub fn build() -> Self {
        Self {
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new() -> Edge<String> {
        Self {
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<T> GraphOperation for NextIteration<T>
where T: TensorType,
      T: Clone,
      T: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("NextIteration_{}")?
        };
        let mut new_op = graph.new_operation("NextIteration", &op_name)?;
        {
            new_op.add_edge(&self.data)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct NextIteration<T>
where T: TensorType,
      T: Clone,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    data: Edge<T>,
    op_name: Option<String>,
    id_: usize,
}

impl<T> NextIteration<T>
where T: TensorType,
      T: Clone,
      T: 'static,
{
    pub fn output(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(data: Edge<T>) -> Self {
        Self {
            phantom_T: PhantomData,
            data,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(data: Edge<T>) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            data,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<T> GraphOperation for Lgamma<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
      T: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("Lgamma_{}")?
        };
        let mut new_op = graph.new_operation("Lgamma", &op_name)?;
        {
            new_op.add_edge(&self.x)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct Lgamma<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    x: Edge<T>,
    op_name: Option<String>,
    id_: usize,
}

impl<T> Lgamma<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
      T: 'static,
{
    pub fn y(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(x: Edge<T>) -> Self {
        Self {
            phantom_T: PhantomData,
            x,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(x: Edge<T>) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            x,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<T> GraphOperation for Snapshot<T>
where T: TensorType,
      T: Clone,
      T: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("Snapshot_{}")?
        };
        let mut new_op = graph.new_operation("Snapshot", &op_name)?;
        {
            new_op.add_edge(&self.input)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct Snapshot<T>
where T: TensorType,
      T: Clone,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    input: Edge<T>,
    op_name: Option<String>,
    id_: usize,
}

impl<T> Snapshot<T>
where T: TensorType,
      T: Clone,
      T: 'static,
{
    pub fn output(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(input: Edge<T>) -> Self {
        Self {
            phantom_T: PhantomData,
            input,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(input: Edge<T>) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            input,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<T> GraphOperation for RefExit<T>
where T: TensorType,
      T: Clone,
      T: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("RefExit_{}")?
        };
        let mut new_op = graph.new_operation("RefExit", &op_name)?;
        {
            new_op.add_edge(&self.data)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct RefExit<T>
where T: TensorType,
      T: Clone,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    data: Edge<T>,
    op_name: Option<String>,
    id_: usize,
}

impl<T> RefExit<T>
where T: TensorType,
      T: Clone,
      T: 'static,
{
    pub fn output(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(data: Edge<T>) -> Self {
        Self {
            phantom_T: PhantomData,
            data,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(data: Edge<T>) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            data,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<Tindices, T> GraphOperation for ScatterNd<Tindices, T>
where Tindices: TensorType,
      Tindices: Clone,
      T: TensorType,
      T: Clone,
      T: 'static,
      Tindices: con_or_DT_INT32_or_DT_INT64,
      Tindices: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("ScatterNd_{}")?
        };
        let mut new_op = graph.new_operation("ScatterNd", &op_name)?;
        {
            new_op.add_edge(&self.indices)?
        }
        {
            new_op.add_edge(&self.updates)?
        }
        {
            new_op.add_edge(&self.shape)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct ScatterNd<Tindices, T>
where Tindices: TensorType,
      Tindices: Clone,
      T: TensorType,
      T: Clone,
      T: 'static,
      Tindices: con_or_DT_INT32_or_DT_INT64,
      Tindices: 'static,
{
    phantom_Tindices: PhantomData<Tindices>,
    indices: Edge<Tindices>,
    phantom_T: PhantomData<T>,
    updates: Edge<T>,
    shape: Edge<Tindices>,
    op_name: Option<String>,
    id_: usize,
}

impl<Tindices, T> ScatterNd<Tindices, T>
where Tindices: TensorType,
      Tindices: Clone,
      T: TensorType,
      T: Clone,
      T: 'static,
      Tindices: con_or_DT_INT32_or_DT_INT64,
      Tindices: 'static,
{
    pub fn output(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(indices: Edge<Tindices>, updates: Edge<T>, shape: Edge<Tindices>) -> Self {
        Self {
            phantom_Tindices: PhantomData,
            indices,
            phantom_T: PhantomData,
            updates,
            shape,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(indices: Edge<Tindices>, updates: Edge<T>, shape: Edge<Tindices>) -> Edge<T> {
        Self {
            phantom_Tindices: PhantomData,
            indices,
            phantom_T: PhantomData,
            updates,
            shape,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<T> GraphOperation for RefMerge<T>
where T: TensorType,
      T: Clone,
      T: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("RefMerge_{}")?
        };
        let mut new_op = graph.new_operation("RefMerge", &op_name)?;
        {
            new_op.add_edge(&self.inputs)?
        }
        {
            (|attr: &i64| {new_op.set_attr_int("N", *attr)})(&self.N)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct RefMerge<T>
where T: TensorType,
      T: Clone,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    inputs: Edge<T>,
    N: i64,
    op_name: Option<String>,
    id_: usize,
}

impl<T> RefMerge<T>
where T: TensorType,
      T: Clone,
      T: 'static,
{
    pub fn output(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn value_index(self) -> Edge<i32> {
        let rc = Rc::new(self);
        {
            Edge::<i32>::new(rc.clone(), 1)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> (Edge<T>, Edge<i32>) {
        let rc = Rc::new(self);
        (
        {
            Edge::<T>::new(rc.clone(), 0)
        },
        {
            Edge::<i32>::new(rc.clone(), 1)
        },
        )
    }

    pub fn build(inputs: Edge<T>, N: i64) -> Self {
        Self {
            phantom_T: PhantomData,
            inputs,
            N: N,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(inputs: Edge<T>, N: i64) -> (Edge<T>, Edge<i32>) {
        Self {
            phantom_T: PhantomData,
            inputs,
            N: N,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<T> GraphOperation for Switch<T>
where T: TensorType,
      T: Clone,
      T: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("Switch_{}")?
        };
        let mut new_op = graph.new_operation("Switch", &op_name)?;
        {
            new_op.add_edge(&self.data)?
        }
        {
            new_op.add_edge(&self.pred)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct Switch<T>
where T: TensorType,
      T: Clone,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    data: Edge<T>,
    pred: Edge<bool>,
    op_name: Option<String>,
    id_: usize,
}

impl<T> Switch<T>
where T: TensorType,
      T: Clone,
      T: 'static,
{
    pub fn output_false(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn output_true(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 1)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> (Edge<T>, Edge<T>) {
        let rc = Rc::new(self);
        (
        {
            Edge::<T>::new(rc.clone(), 0)
        },
        {
            Edge::<T>::new(rc.clone(), 1)
        },
        )
    }

    pub fn build(data: Edge<T>, pred: Edge<bool>) -> Self {
        Self {
            phantom_T: PhantomData,
            data,
            pred,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(data: Edge<T>, pred: Edge<bool>) -> (Edge<T>, Edge<T>) {
        Self {
            phantom_T: PhantomData,
            data,
            pred,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl GraphOperation for DecodeBase64 {
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("DecodeBase64_{}")?
        };
        let mut new_op = graph.new_operation("DecodeBase64", &op_name)?;
        {
            new_op.add_edge(&self.input)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct DecodeBase64 {
    input: Edge<String>,
    op_name: Option<String>,
    id_: usize,
}

impl DecodeBase64 {
    pub fn output(self) -> Edge<String> {
        let rc = Rc::new(self);
        {
            Edge::<String>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<String> {
        let rc = Rc::new(self);
        {
            Edge::<String>::new(rc.clone(), 0)
        }
    }

    pub fn build(input: Edge<String>) -> Self {
        Self {
            input,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(input: Edge<String>) -> Edge<String> {
        Self {
            input,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

pub trait con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_INT64_or_DT_HALF {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_INT64_or_DT_HALF for f32 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_INT64_or_DT_HALF for f64 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_INT64_or_DT_HALF for i32 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_INT64_or_DT_HALF for i64 {
}

impl<T> GraphOperation for CollectiveBcastRecv<T>
where T: TensorType,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_INT64_or_DT_HALF,
      T: 'static,
      T: Clone,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("CollectiveBcastRecv_{}")?
        };
        let mut new_op = graph.new_operation("CollectiveBcastRecv", &op_name)?;
        {
            (|attr: &i64| {new_op.set_attr_int("group_size", *attr)})(&self.group_size)?
        }
        {
            (|attr: &i64| {new_op.set_attr_int("group_key", *attr)})(&self.group_key)?
        }
        {
            (|attr: &i64| {new_op.set_attr_int("instance_key", *attr)})(&self.instance_key)?
        }
        {
            (|attr| {new_op.set_attr_shape("shape", attr)})(&self.shape)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct CollectiveBcastRecv<T>
where T: TensorType,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_INT64_or_DT_HALF,
      T: 'static,
      T: Clone,
{
    phantom_T: PhantomData<T>,
    group_size: i64,
    group_key: i64,
    instance_key: i64,
    shape: OtherShape,
    op_name: Option<String>,
    id_: usize,
}

impl<T> CollectiveBcastRecv<T>
where T: TensorType,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_INT64_or_DT_HALF,
      T: 'static,
      T: Clone,
{
    pub fn data(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(group_size: i64, group_key: i64, instance_key: i64, shape: &OtherShape) -> Self {
        Self {
            phantom_T: PhantomData,
            group_size: group_size,
            group_key: group_key,
            instance_key: instance_key,
            shape: shape.clone(),
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(group_size: i64, group_key: i64, instance_key: i64, shape: &OtherShape) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            group_size: group_size,
            group_key: group_key,
            instance_key: instance_key,
            shape: shape.clone(),
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<T> GraphOperation for Rsqrt<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_COMPLEX64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF,
      T: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("Rsqrt_{}")?
        };
        let mut new_op = graph.new_operation("Rsqrt", &op_name)?;
        {
            new_op.add_edge(&self.x)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct Rsqrt<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_COMPLEX64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    x: Edge<T>,
    op_name: Option<String>,
    id_: usize,
}

impl<T> Rsqrt<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_COMPLEX64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF,
      T: 'static,
{
    pub fn y(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(x: Edge<T>) -> Self {
        Self {
            phantom_T: PhantomData,
            x,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(x: Edge<T>) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            x,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<T> GraphOperation for RefSwitch<T>
where T: TensorType,
      T: Clone,
      T: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("RefSwitch_{}")?
        };
        let mut new_op = graph.new_operation("RefSwitch", &op_name)?;
        {
            new_op.add_edge(&self.data)?
        }
        {
            new_op.add_edge(&self.pred)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct RefSwitch<T>
where T: TensorType,
      T: Clone,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    data: Edge<T>,
    pred: Edge<bool>,
    op_name: Option<String>,
    id_: usize,
}

impl<T> RefSwitch<T>
where T: TensorType,
      T: Clone,
      T: 'static,
{
    pub fn output_false(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn output_true(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 1)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> (Edge<T>, Edge<T>) {
        let rc = Rc::new(self);
        (
        {
            Edge::<T>::new(rc.clone(), 0)
        },
        {
            Edge::<T>::new(rc.clone(), 1)
        },
        )
    }

    pub fn build(data: Edge<T>, pred: Edge<bool>) -> Self {
        Self {
            phantom_T: PhantomData,
            data,
            pred,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(data: Edge<T>, pred: Edge<bool>) -> (Edge<T>, Edge<T>) {
        Self {
            phantom_T: PhantomData,
            data,
            pred,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<T> GraphOperation for CollectiveBcastSend<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_INT64_or_DT_HALF,
      T: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("CollectiveBcastSend_{}")?
        };
        let mut new_op = graph.new_operation("CollectiveBcastSend", &op_name)?;
        {
            new_op.add_edge(&self.input)?
        }
        {
            (|attr: &i64| {new_op.set_attr_int("group_size", *attr)})(&self.group_size)?
        }
        {
            (|attr: &i64| {new_op.set_attr_int("group_key", *attr)})(&self.group_key)?
        }
        {
            (|attr: &i64| {new_op.set_attr_int("instance_key", *attr)})(&self.instance_key)?
        }
        {
            (|attr| {new_op.set_attr_shape("shape", attr)})(&self.shape)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct CollectiveBcastSend<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_INT64_or_DT_HALF,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    input: Edge<T>,
    group_size: i64,
    group_key: i64,
    instance_key: i64,
    shape: OtherShape,
    op_name: Option<String>,
    id_: usize,
}

impl<T> CollectiveBcastSend<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_INT64_or_DT_HALF,
      T: 'static,
{
    pub fn data(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(input: Edge<T>, group_size: i64, group_key: i64, instance_key: i64, shape: &OtherShape) -> Self {
        Self {
            phantom_T: PhantomData,
            input,
            group_size: group_size,
            group_key: group_key,
            instance_key: instance_key,
            shape: shape.clone(),
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(input: Edge<T>, group_size: i64, group_key: i64, instance_key: i64, shape: &OtherShape) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            input,
            group_size: group_size,
            group_key: group_key,
            instance_key: instance_key,
            shape: shape.clone(),
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<T> GraphOperation for DeepCopy<T>
where T: TensorType,
      T: Clone,
      T: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("DeepCopy_{}")?
        };
        let mut new_op = graph.new_operation("DeepCopy", &op_name)?;
        {
            new_op.add_edge(&self.x)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct DeepCopy<T>
where T: TensorType,
      T: Clone,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    x: Edge<T>,
    op_name: Option<String>,
    id_: usize,
}

impl<T> DeepCopy<T>
where T: TensorType,
      T: Clone,
      T: 'static,
{
    pub fn y(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(x: Edge<T>) -> Self {
        Self {
            phantom_T: PhantomData,
            x,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(x: Edge<T>) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            x,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<T> GraphOperation for CollectiveReduce<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_INT64_or_DT_HALF,
      T: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("CollectiveReduce_{}")?
        };
        let mut new_op = graph.new_operation("CollectiveReduce", &op_name)?;
        {
            new_op.add_edge(&self.input)?
        }
        {
            (|attr: &i64| {new_op.set_attr_int("group_size", *attr)})(&self.group_size)?
        }
        {
            (|attr: &i64| {new_op.set_attr_int("group_key", *attr)})(&self.group_key)?
        }
        {
            (|attr: &i64| {new_op.set_attr_int("instance_key", *attr)})(&self.instance_key)?
        }
        {
            (|attr| {new_op.set_attr_string("merge_op", attr)})(&self.merge_op)?
        }
        {
            (|attr| {new_op.set_attr_string("final_op", attr)})(&self.final_op)?
        }
        {
            (|attrs| {new_op.set_attr_int_list("subdiv_offsets", attrs)})(&self.subdiv_offsets)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct CollectiveReduce<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_INT64_or_DT_HALF,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    input: Edge<T>,
    group_size: i64,
    group_key: i64,
    instance_key: i64,
    merge_op: String,
    final_op: String,
    subdiv_offsets: Vec<i64>,
    op_name: Option<String>,
    id_: usize,
}

impl<T> CollectiveReduce<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_INT64_or_DT_HALF,
      T: 'static,
{
    pub fn data(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(input: Edge<T>, group_size: i64, group_key: i64, instance_key: i64, merge_op: &str, final_op: &str, subdiv_offsets: &[i64]) -> Self {
        Self {
            phantom_T: PhantomData,
            input,
            group_size: group_size,
            group_key: group_key,
            instance_key: instance_key,
            merge_op: merge_op.to_string(),
            final_op: final_op.to_string(),
            subdiv_offsets: subdiv_offsets.to_vec(),
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(input: Edge<T>, group_size: i64, group_key: i64, instance_key: i64, merge_op: &str, final_op: &str, subdiv_offsets: &[i64]) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            input,
            group_size: group_size,
            group_key: group_key,
            instance_key: instance_key,
            merge_op: merge_op.to_string(),
            final_op: final_op.to_string(),
            subdiv_offsets: subdiv_offsets.to_vec(),
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<T> GraphOperation for RefEnter<T>
where T: TensorType,
      T: Clone,
      T: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("RefEnter_{}")?
        };
        let mut new_op = graph.new_operation("RefEnter", &op_name)?;
        {
            new_op.add_edge(&self.data)?
        }
        {
            (|attr| {new_op.set_attr_string("frame_name", attr)})(&self.frame_name)?
        }
        {
            match self.is_constant {
                None => new_op.set_attr_value_proto("is_constant", &vec![40_u8, 0_u8,])?,
                Some(ref value) => (|attr: &bool| {new_op.set_attr_bool("is_constant", *attr)})(&value)?,
            };
        }
        {
            match self.parallel_iterations {
                None => new_op.set_attr_value_proto("parallel_iterations", &vec![24_u8, 10_u8,])?,
                Some(ref value) => (|attr: &i64| {new_op.set_attr_int("parallel_iterations", *attr)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct RefEnter<T>
where T: TensorType,
      T: Clone,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    data: Edge<T>,
    frame_name: String,
    is_constant: Option<bool>,
    parallel_iterations: Option<i64>,
    op_name: Option<String>,
    id_: usize,
}

impl<T> RefEnter<T>
where T: TensorType,
      T: Clone,
      T: 'static,
{
    pub fn output(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn is_constant(&mut self, is_constant: bool) -> Self {
        self.is_constant = Some(is_constant);
        self.clone()
    }

    pub fn parallel_iterations(&mut self, parallel_iterations: i64) -> Self {
        self.parallel_iterations = Some(parallel_iterations);
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(data: Edge<T>, frame_name: &str) -> Self {
        Self {
            phantom_T: PhantomData,
            data,
            frame_name: frame_name.to_string(),
            is_constant: None,
            parallel_iterations: None,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(data: Edge<T>, frame_name: &str) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            data,
            frame_name: frame_name.to_string(),
            is_constant: None,
            parallel_iterations: None,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl GraphOperation for FixedUnigramCandidateSampler {
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("FixedUnigramCandidateSampler_{}")?
        };
        let mut new_op = graph.new_operation("FixedUnigramCandidateSampler", &op_name)?;
        {
            new_op.add_edge(&self.true_classes)?
        }
        {
            (|attr: &i64| {new_op.set_attr_int("num_true", *attr)})(&self.num_true)?
        }
        {
            (|attr: &i64| {new_op.set_attr_int("num_sampled", *attr)})(&self.num_sampled)?
        }
        {
            (|attr: &bool| {new_op.set_attr_bool("unique", *attr)})(&self.unique)?
        }
        {
            (|attr: &i64| {new_op.set_attr_int("range_max", *attr)})(&self.range_max)?
        }
        {
            match self.vocab_file {
                None => new_op.set_attr_value_proto("vocab_file", &vec![18_u8, 0_u8,])?,
                Some(ref value) => (|attr| {new_op.set_attr_string("vocab_file", attr)})(&value)?,
            };
        }
        {
            match self.distortion {
                None => new_op.set_attr_value_proto("distortion", &vec![37_u8, 0_u8, 0_u8, 128_u8, 63_u8,])?,
                Some(ref value) => (|attr: &f32| {new_op.set_attr_float("distortion", *attr)})(&value)?,
            };
        }
        {
            match self.num_reserved_ids {
                None => new_op.set_attr_value_proto("num_reserved_ids", &vec![24_u8, 0_u8,])?,
                Some(ref value) => (|attr: &i64| {new_op.set_attr_int("num_reserved_ids", *attr)})(&value)?,
            };
        }
        {
            match self.num_shards {
                None => new_op.set_attr_value_proto("num_shards", &vec![24_u8, 1_u8,])?,
                Some(ref value) => (|attr: &i64| {new_op.set_attr_int("num_shards", *attr)})(&value)?,
            };
        }
        {
            match self.shard {
                None => new_op.set_attr_value_proto("shard", &vec![24_u8, 0_u8,])?,
                Some(ref value) => (|attr: &i64| {new_op.set_attr_int("shard", *attr)})(&value)?,
            };
        }
        {
            match self.unigrams {
                None => new_op.set_attr_value_proto("unigrams", &vec![10_u8, 0_u8,])?,
                Some(ref value) => (|attrs| {new_op.set_attr_float_list("unigrams", attrs)})(&value)?,
            };
        }
        {
            match self.seed {
                None => new_op.set_attr_value_proto("seed", &vec![24_u8, 0_u8,])?,
                Some(ref value) => (|attr: &i64| {new_op.set_attr_int("seed", *attr)})(&value)?,
            };
        }
        {
            match self.seed2 {
                None => new_op.set_attr_value_proto("seed2", &vec![24_u8, 0_u8,])?,
                Some(ref value) => (|attr: &i64| {new_op.set_attr_int("seed2", *attr)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct FixedUnigramCandidateSampler {
    true_classes: Edge<i64>,
    num_true: i64,
    num_sampled: i64,
    unique: bool,
    range_max: i64,
    vocab_file: Option<String>,
    distortion: Option<f32>,
    num_reserved_ids: Option<i64>,
    num_shards: Option<i64>,
    shard: Option<i64>,
    unigrams: Option<Vec<f32>>,
    seed: Option<i64>,
    seed2: Option<i64>,
    op_name: Option<String>,
    id_: usize,
}

impl FixedUnigramCandidateSampler {
    pub fn sampled_candidates(self) -> Edge<i64> {
        let rc = Rc::new(self);
        {
            Edge::<i64>::new(rc.clone(), 0)
        }
    }

    pub fn true_expected_count(self) -> Edge<f32> {
        let rc = Rc::new(self);
        {
            Edge::<f32>::new(rc.clone(), 1)
        }
    }

    pub fn sampled_expected_count(self) -> Edge<f32> {
        let rc = Rc::new(self);
        {
            Edge::<f32>::new(rc.clone(), 2)
        }
    }

    pub fn vocab_file(&mut self, vocab_file: &str) -> Self {
        self.vocab_file = Some(vocab_file.to_string());
        self.clone()
    }

    pub fn distortion(&mut self, distortion: f32) -> Self {
        self.distortion = Some(distortion);
        self.clone()
    }

    pub fn num_reserved_ids(&mut self, num_reserved_ids: i64) -> Self {
        self.num_reserved_ids = Some(num_reserved_ids);
        self.clone()
    }

    pub fn num_shards(&mut self, num_shards: i64) -> Self {
        self.num_shards = Some(num_shards);
        self.clone()
    }

    pub fn shard(&mut self, shard: i64) -> Self {
        self.shard = Some(shard);
        self.clone()
    }

    pub fn unigrams(&mut self, unigrams: &[f32]) -> Self {
        self.unigrams = Some(unigrams.to_vec());
        self.clone()
    }

    pub fn seed(&mut self, seed: i64) -> Self {
        self.seed = Some(seed);
        self.clone()
    }

    pub fn seed2(&mut self, seed2: i64) -> Self {
        self.seed2 = Some(seed2);
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> (Edge<i64>, Edge<f32>, Edge<f32>) {
        let rc = Rc::new(self);
        (
        {
            Edge::<i64>::new(rc.clone(), 0)
        },
        {
            Edge::<f32>::new(rc.clone(), 1)
        },
        {
            Edge::<f32>::new(rc.clone(), 2)
        },
        )
    }

    pub fn build(true_classes: Edge<i64>, num_true: i64, num_sampled: i64, unique: bool, range_max: i64) -> Self {
        Self {
            true_classes,
            num_true: num_true,
            num_sampled: num_sampled,
            unique: unique,
            range_max: range_max,
            vocab_file: None,
            distortion: None,
            num_reserved_ids: None,
            num_shards: None,
            shard: None,
            unigrams: None,
            seed: None,
            seed2: None,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(true_classes: Edge<i64>, num_true: i64, num_sampled: i64, unique: bool, range_max: i64) -> (Edge<i64>, Edge<f32>, Edge<f32>) {
        Self {
            true_classes,
            num_true: num_true,
            num_sampled: num_sampled,
            unique: unique,
            range_max: range_max,
            vocab_file: None,
            distortion: None,
            num_reserved_ids: None,
            num_shards: None,
            shard: None,
            unigrams: None,
            seed: None,
            seed2: None,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl GraphOperation for BarrierIncompleteSize {
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("BarrierIncompleteSize_{}")?
        };
        let mut new_op = graph.new_operation("BarrierIncompleteSize", &op_name)?;
        {
            new_op.add_edge(&self.handle)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct BarrierIncompleteSize {
    handle: Edge<String>,
    op_name: Option<String>,
    id_: usize,
}

impl BarrierIncompleteSize {
    pub fn size(self) -> Edge<i32> {
        let rc = Rc::new(self);
        {
            Edge::<i32>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<i32> {
        let rc = Rc::new(self);
        {
            Edge::<i32>::new(rc.clone(), 0)
        }
    }

    pub fn build(handle: Edge<String>) -> Self {
        Self {
            handle,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(handle: Edge<String>) -> Edge<i32> {
        Self {
            handle,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<T> GraphOperation for MaxPoolV2<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_QINT8_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF,
      T: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("MaxPoolV2_{}")?
        };
        let mut new_op = graph.new_operation("MaxPoolV2", &op_name)?;
        {
            new_op.add_edge(&self.input)?
        }
        {
            new_op.add_edge(&self.ksize)?
        }
        {
            new_op.add_edge(&self.strides)?
        }
        {
            (|attr| {new_op.set_attr_string("padding", attr)})(&self.padding)?
        }
        {
            match self.data_format {
                None => new_op.set_attr_value_proto("data_format", &vec![18_u8, 4_u8, 78_u8, 72_u8, 87_u8, 67_u8,])?,
                Some(ref value) => (|attr| {new_op.set_attr_string("data_format", attr)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct MaxPoolV2<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_QINT8_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    input: Edge<T>,
    ksize: Edge<i32>,
    strides: Edge<i32>,
    padding: String,
    data_format: Option<String>,
    op_name: Option<String>,
    id_: usize,
}

impl<T> MaxPoolV2<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_QINT8_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF,
      T: 'static,
{
    pub fn output(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn data_format(&mut self, data_format: &str) -> Self {
        self.data_format = Some(data_format.to_string());
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(input: Edge<T>, ksize: Edge<i32>, strides: Edge<i32>, padding: &str) -> Self {
        Self {
            phantom_T: PhantomData,
            input,
            ksize,
            strides,
            padding: padding.to_string(),
            data_format: None,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(input: Edge<T>, ksize: Edge<i32>, strides: Edge<i32>, padding: &str) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            input,
            ksize,
            strides,
            padding: padding.to_string(),
            data_format: None,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl GraphOperation for ThreadUnsafeUnigramCandidateSampler {
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("ThreadUnsafeUnigramCandidateSampler_{}")?
        };
        let mut new_op = graph.new_operation("ThreadUnsafeUnigramCandidateSampler", &op_name)?;
        {
            new_op.add_edge(&self.true_classes)?
        }
        {
            (|attr: &i64| {new_op.set_attr_int("num_true", *attr)})(&self.num_true)?
        }
        {
            (|attr: &i64| {new_op.set_attr_int("num_sampled", *attr)})(&self.num_sampled)?
        }
        {
            (|attr: &bool| {new_op.set_attr_bool("unique", *attr)})(&self.unique)?
        }
        {
            (|attr: &i64| {new_op.set_attr_int("range_max", *attr)})(&self.range_max)?
        }
        {
            match self.seed {
                None => new_op.set_attr_value_proto("seed", &vec![24_u8, 0_u8,])?,
                Some(ref value) => (|attr: &i64| {new_op.set_attr_int("seed", *attr)})(&value)?,
            };
        }
        {
            match self.seed2 {
                None => new_op.set_attr_value_proto("seed2", &vec![24_u8, 0_u8,])?,
                Some(ref value) => (|attr: &i64| {new_op.set_attr_int("seed2", *attr)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct ThreadUnsafeUnigramCandidateSampler {
    true_classes: Edge<i64>,
    num_true: i64,
    num_sampled: i64,
    unique: bool,
    range_max: i64,
    seed: Option<i64>,
    seed2: Option<i64>,
    op_name: Option<String>,
    id_: usize,
}

impl ThreadUnsafeUnigramCandidateSampler {
    pub fn sampled_candidates(self) -> Edge<i64> {
        let rc = Rc::new(self);
        {
            Edge::<i64>::new(rc.clone(), 0)
        }
    }

    pub fn true_expected_count(self) -> Edge<f32> {
        let rc = Rc::new(self);
        {
            Edge::<f32>::new(rc.clone(), 1)
        }
    }

    pub fn sampled_expected_count(self) -> Edge<f32> {
        let rc = Rc::new(self);
        {
            Edge::<f32>::new(rc.clone(), 2)
        }
    }

    pub fn seed(&mut self, seed: i64) -> Self {
        self.seed = Some(seed);
        self.clone()
    }

    pub fn seed2(&mut self, seed2: i64) -> Self {
        self.seed2 = Some(seed2);
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> (Edge<i64>, Edge<f32>, Edge<f32>) {
        let rc = Rc::new(self);
        (
        {
            Edge::<i64>::new(rc.clone(), 0)
        },
        {
            Edge::<f32>::new(rc.clone(), 1)
        },
        {
            Edge::<f32>::new(rc.clone(), 2)
        },
        )
    }

    pub fn build(true_classes: Edge<i64>, num_true: i64, num_sampled: i64, unique: bool, range_max: i64) -> Self {
        Self {
            true_classes,
            num_true: num_true,
            num_sampled: num_sampled,
            unique: unique,
            range_max: range_max,
            seed: None,
            seed2: None,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(true_classes: Edge<i64>, num_true: i64, num_sampled: i64, unique: bool, range_max: i64) -> (Edge<i64>, Edge<f32>, Edge<f32>) {
        Self {
            true_classes,
            num_true: num_true,
            num_sampled: num_sampled,
            unique: unique,
            range_max: range_max,
            seed: None,
            seed2: None,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl GraphOperation for QueueIsClosed {
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("QueueIsClosed_{}")?
        };
        let mut new_op = graph.new_operation("QueueIsClosed", &op_name)?;
        {
            new_op.add_edge(&self.handle)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct QueueIsClosed {
    handle: Edge<String>,
    op_name: Option<String>,
    id_: usize,
}

impl QueueIsClosed {
    pub fn is_closed(self) -> Edge<bool> {
        let rc = Rc::new(self);
        {
            Edge::<bool>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<bool> {
        let rc = Rc::new(self);
        {
            Edge::<bool>::new(rc.clone(), 0)
        }
    }

    pub fn build(handle: Edge<String>) -> Self {
        Self {
            handle,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(handle: Edge<String>) -> Edge<bool> {
        Self {
            handle,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<component_types> GraphOperation for FIFOQueue<component_types>
where component_types: 'static,
      component_types: Clone,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("FIFOQueue_{}")?
        };
        let mut new_op = graph.new_operation("FIFOQueue", &op_name)?;
        {
            match self.shapes {
                None => new_op.set_attr_value_proto("shapes", &vec![10_u8, 0_u8,])?,
                Some(ref value) => (|attrs| {new_op.set_attr_shape_list("shapes", attrs)})(&value)?,
            };
        }
        {
            match self.capacity {
                None => new_op.set_attr_value_proto("capacity", &vec![24_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 1_u8,])?,
                Some(ref value) => (|attr: &i64| {new_op.set_attr_int("capacity", *attr)})(&value)?,
            };
        }
        {
            match self.container {
                None => new_op.set_attr_value_proto("container", &vec![18_u8, 0_u8,])?,
                Some(ref value) => (|attr| {new_op.set_attr_string("container", attr)})(&value)?,
            };
        }
        {
            match self.shared_name {
                None => new_op.set_attr_value_proto("shared_name", &vec![18_u8, 0_u8,])?,
                Some(ref value) => (|attr| {new_op.set_attr_string("shared_name", attr)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct FIFOQueue<component_types>
where component_types: 'static,
      component_types: Clone,
{
    phantom_component_types: PhantomData<component_types>,
    shapes: Option<Vec<OtherShape>>,
    capacity: Option<i64>,
    container: Option<String>,
    shared_name: Option<String>,
    op_name: Option<String>,
    id_: usize,
}

impl<component_types> FIFOQueue<component_types>
where component_types: 'static,
      component_types: Clone,
{
    pub fn handle(self) -> Edge<String> {
        let rc = Rc::new(self);
        {
            Edge::<String>::new(rc.clone(), 0)
        }
    }

    pub fn shapes(&mut self, shapes: &[OtherShape]) -> Self {
        self.shapes = Some(shapes.to_vec());
        self.clone()
    }

    pub fn capacity(&mut self, capacity: i64) -> Self {
        self.capacity = Some(capacity);
        self.clone()
    }

    pub fn container(&mut self, container: &str) -> Self {
        self.container = Some(container.to_string());
        self.clone()
    }

    pub fn shared_name(&mut self, shared_name: &str) -> Self {
        self.shared_name = Some(shared_name.to_string());
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<String> {
        let rc = Rc::new(self);
        {
            Edge::<String>::new(rc.clone(), 0)
        }
    }

    pub fn build() -> Self {
        Self {
            phantom_component_types: PhantomData,
            shapes: None,
            capacity: None,
            container: None,
            shared_name: None,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new() -> Edge<String> {
        Self {
            phantom_component_types: PhantomData,
            shapes: None,
            capacity: None,
            container: None,
            shared_name: None,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<T> GraphOperation for TPUReplicatedInput<T>
where T: TensorType,
      T: Clone,
      T: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("TPUReplicatedInput_{}")?
        };
        let mut new_op = graph.new_operation("TPUReplicatedInput", &op_name)?;
        {
            new_op.add_edge(&self.inputs)?
        }
        {
            (|attr: &i64| {new_op.set_attr_int("N", *attr)})(&self.N)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct TPUReplicatedInput<T>
where T: TensorType,
      T: Clone,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    inputs: Edge<T>,
    N: i64,
    op_name: Option<String>,
    id_: usize,
}

impl<T> TPUReplicatedInput<T>
where T: TensorType,
      T: Clone,
      T: 'static,
{
    pub fn output(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(inputs: Edge<T>, N: i64) -> Self {
        Self {
            phantom_T: PhantomData,
            inputs,
            N: N,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(inputs: Edge<T>, N: i64) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            inputs,
            N: N,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<T> GraphOperation for SpaceToDepth<T>
where T: TensorType,
      T: Clone,
      T: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("SpaceToDepth_{}")?
        };
        let mut new_op = graph.new_operation("SpaceToDepth", &op_name)?;
        {
            new_op.add_edge(&self.input)?
        }
        {
            (|attr: &i64| {new_op.set_attr_int("block_size", *attr)})(&self.block_size)?
        }
        {
            match self.data_format {
                None => new_op.set_attr_value_proto("data_format", &vec![18_u8, 4_u8, 78_u8, 72_u8, 87_u8, 67_u8,])?,
                Some(ref value) => (|attr| {new_op.set_attr_string("data_format", attr)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct SpaceToDepth<T>
where T: TensorType,
      T: Clone,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    input: Edge<T>,
    block_size: i64,
    data_format: Option<String>,
    op_name: Option<String>,
    id_: usize,
}

impl<T> SpaceToDepth<T>
where T: TensorType,
      T: Clone,
      T: 'static,
{
    pub fn output(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn data_format(&mut self, data_format: &str) -> Self {
        self.data_format = Some(data_format.to_string());
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(input: Edge<T>, block_size: i64) -> Self {
        Self {
            phantom_T: PhantomData,
            input,
            block_size: block_size,
            data_format: None,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(input: Edge<T>, block_size: i64) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            input,
            block_size: block_size,
            data_format: None,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl GraphOperation for LogUniformCandidateSampler {
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("LogUniformCandidateSampler_{}")?
        };
        let mut new_op = graph.new_operation("LogUniformCandidateSampler", &op_name)?;
        {
            new_op.add_edge(&self.true_classes)?
        }
        {
            (|attr: &i64| {new_op.set_attr_int("num_true", *attr)})(&self.num_true)?
        }
        {
            (|attr: &i64| {new_op.set_attr_int("num_sampled", *attr)})(&self.num_sampled)?
        }
        {
            (|attr: &bool| {new_op.set_attr_bool("unique", *attr)})(&self.unique)?
        }
        {
            (|attr: &i64| {new_op.set_attr_int("range_max", *attr)})(&self.range_max)?
        }
        {
            match self.seed {
                None => new_op.set_attr_value_proto("seed", &vec![24_u8, 0_u8,])?,
                Some(ref value) => (|attr: &i64| {new_op.set_attr_int("seed", *attr)})(&value)?,
            };
        }
        {
            match self.seed2 {
                None => new_op.set_attr_value_proto("seed2", &vec![24_u8, 0_u8,])?,
                Some(ref value) => (|attr: &i64| {new_op.set_attr_int("seed2", *attr)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct LogUniformCandidateSampler {
    true_classes: Edge<i64>,
    num_true: i64,
    num_sampled: i64,
    unique: bool,
    range_max: i64,
    seed: Option<i64>,
    seed2: Option<i64>,
    op_name: Option<String>,
    id_: usize,
}

impl LogUniformCandidateSampler {
    pub fn sampled_candidates(self) -> Edge<i64> {
        let rc = Rc::new(self);
        {
            Edge::<i64>::new(rc.clone(), 0)
        }
    }

    pub fn true_expected_count(self) -> Edge<f32> {
        let rc = Rc::new(self);
        {
            Edge::<f32>::new(rc.clone(), 1)
        }
    }

    pub fn sampled_expected_count(self) -> Edge<f32> {
        let rc = Rc::new(self);
        {
            Edge::<f32>::new(rc.clone(), 2)
        }
    }

    pub fn seed(&mut self, seed: i64) -> Self {
        self.seed = Some(seed);
        self.clone()
    }

    pub fn seed2(&mut self, seed2: i64) -> Self {
        self.seed2 = Some(seed2);
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> (Edge<i64>, Edge<f32>, Edge<f32>) {
        let rc = Rc::new(self);
        (
        {
            Edge::<i64>::new(rc.clone(), 0)
        },
        {
            Edge::<f32>::new(rc.clone(), 1)
        },
        {
            Edge::<f32>::new(rc.clone(), 2)
        },
        )
    }

    pub fn build(true_classes: Edge<i64>, num_true: i64, num_sampled: i64, unique: bool, range_max: i64) -> Self {
        Self {
            true_classes,
            num_true: num_true,
            num_sampled: num_sampled,
            unique: unique,
            range_max: range_max,
            seed: None,
            seed2: None,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(true_classes: Edge<i64>, num_true: i64, num_sampled: i64, unique: bool, range_max: i64) -> (Edge<i64>, Edge<f32>, Edge<f32>) {
        Self {
            true_classes,
            num_true: num_true,
            num_sampled: num_sampled,
            unique: unique,
            range_max: range_max,
            seed: None,
            seed2: None,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<S, dtype> GraphOperation for RandomPoisson<S, dtype>
where S: TensorType,
      S: Clone,
      dtype: TensorType,
      dtype: Clone,
      S: con_or_DT_INT32_or_DT_INT64,
      S: 'static,
      dtype: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_HALF,
      dtype: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("RandomPoisson_{}")?
        };
        let mut new_op = graph.new_operation("RandomPoisson", &op_name)?;
        {
            new_op.add_edge(&self.shape)?
        }
        {
            new_op.add_edge(&self.rate)?
        }
        {
            match self.seed {
                None => new_op.set_attr_value_proto("seed", &vec![24_u8, 0_u8,])?,
                Some(ref value) => (|attr: &i64| {new_op.set_attr_int("seed", *attr)})(&value)?,
            };
        }
        {
            match self.seed2 {
                None => new_op.set_attr_value_proto("seed2", &vec![24_u8, 0_u8,])?,
                Some(ref value) => (|attr: &i64| {new_op.set_attr_int("seed2", *attr)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct RandomPoisson<S, dtype>
where S: TensorType,
      S: Clone,
      dtype: TensorType,
      dtype: Clone,
      S: con_or_DT_INT32_or_DT_INT64,
      S: 'static,
      dtype: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_HALF,
      dtype: 'static,
{
    phantom_S: PhantomData<S>,
    shape: Edge<S>,
    phantom_dtype: PhantomData<dtype>,
    rate: Edge<dtype>,
    seed: Option<i64>,
    seed2: Option<i64>,
    op_name: Option<String>,
    id_: usize,
}

impl<S, dtype> RandomPoisson<S, dtype>
where S: TensorType,
      S: Clone,
      dtype: TensorType,
      dtype: Clone,
      S: con_or_DT_INT32_or_DT_INT64,
      S: 'static,
      dtype: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_HALF,
      dtype: 'static,
{
    pub fn output(self) -> Edge<dtype> {
        let rc = Rc::new(self);
        {
            Edge::<dtype>::new(rc.clone(), 0)
        }
    }

    pub fn seed(&mut self, seed: i64) -> Self {
        self.seed = Some(seed);
        self.clone()
    }

    pub fn seed2(&mut self, seed2: i64) -> Self {
        self.seed2 = Some(seed2);
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<dtype> {
        let rc = Rc::new(self);
        {
            Edge::<dtype>::new(rc.clone(), 0)
        }
    }

    pub fn build(shape: Edge<S>, rate: Edge<dtype>) -> Self {
        Self {
            phantom_S: PhantomData,
            shape,
            phantom_dtype: PhantomData,
            rate,
            seed: None,
            seed2: None,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(shape: Edge<S>, rate: Edge<dtype>) -> Edge<dtype> {
        Self {
            phantom_S: PhantomData,
            shape,
            phantom_dtype: PhantomData,
            rate,
            seed: None,
            seed2: None,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<Tinput, out_type> GraphOperation for QuantizedReluX<Tinput, out_type>
where Tinput: TensorType,
      Tinput: Clone,
      out_type: TensorType,
      Tinput: con_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_QINT16_or_DT_QUINT16,
      Tinput: 'static,
      out_type: con_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_QINT16_or_DT_QUINT16,
      out_type: 'static,
      out_type: Clone,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("QuantizedReluX_{}")?
        };
        let mut new_op = graph.new_operation("QuantizedReluX", &op_name)?;
        {
            new_op.add_edge(&self.features)?
        }
        {
            new_op.add_edge(&self.max_value)?
        }
        {
            new_op.add_edge(&self.min_features)?
        }
        {
            new_op.add_edge(&self.max_features)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct QuantizedReluX<Tinput, out_type>
where Tinput: TensorType,
      Tinput: Clone,
      out_type: TensorType,
      Tinput: con_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_QINT16_or_DT_QUINT16,
      Tinput: 'static,
      out_type: con_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_QINT16_or_DT_QUINT16,
      out_type: 'static,
      out_type: Clone,
{
    phantom_Tinput: PhantomData<Tinput>,
    features: Edge<Tinput>,
    max_value: Edge<f32>,
    min_features: Edge<f32>,
    max_features: Edge<f32>,
    phantom_out_type: PhantomData<out_type>,
    op_name: Option<String>,
    id_: usize,
}

impl<Tinput, out_type> QuantizedReluX<Tinput, out_type>
where Tinput: TensorType,
      Tinput: Clone,
      out_type: TensorType,
      Tinput: con_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_QINT16_or_DT_QUINT16,
      Tinput: 'static,
      out_type: con_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_QINT16_or_DT_QUINT16,
      out_type: 'static,
      out_type: Clone,
{
    pub fn activations(self) -> Edge<out_type> {
        let rc = Rc::new(self);
        {
            Edge::<out_type>::new(rc.clone(), 0)
        }
    }

    pub fn min_activations(self) -> Edge<f32> {
        let rc = Rc::new(self);
        {
            Edge::<f32>::new(rc.clone(), 1)
        }
    }

    pub fn max_activations(self) -> Edge<f32> {
        let rc = Rc::new(self);
        {
            Edge::<f32>::new(rc.clone(), 2)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> (Edge<out_type>, Edge<f32>, Edge<f32>) {
        let rc = Rc::new(self);
        (
        {
            Edge::<out_type>::new(rc.clone(), 0)
        },
        {
            Edge::<f32>::new(rc.clone(), 1)
        },
        {
            Edge::<f32>::new(rc.clone(), 2)
        },
        )
    }

    pub fn build(features: Edge<Tinput>, max_value: Edge<f32>, min_features: Edge<f32>, max_features: Edge<f32>) -> Self {
        Self {
            phantom_Tinput: PhantomData,
            features,
            max_value,
            min_features,
            max_features,
            phantom_out_type: PhantomData,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(features: Edge<Tinput>, max_value: Edge<f32>, min_features: Edge<f32>, max_features: Edge<f32>) -> (Edge<out_type>, Edge<f32>, Edge<f32>) {
        Self {
            phantom_Tinput: PhantomData,
            features,
            max_value,
            min_features,
            max_features,
            phantom_out_type: PhantomData,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<T> GraphOperation for Less<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("Less_{}")?
        };
        let mut new_op = graph.new_operation("Less", &op_name)?;
        {
            new_op.add_edge(&self.x)?
        }
        {
            new_op.add_edge(&self.y)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct Less<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    x: Edge<T>,
    y: Edge<T>,
    op_name: Option<String>,
    id_: usize,
}

impl<T> Less<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
{
    pub fn z(self) -> Edge<bool> {
        let rc = Rc::new(self);
        {
            Edge::<bool>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<bool> {
        let rc = Rc::new(self);
        {
            Edge::<bool>::new(rc.clone(), 0)
        }
    }

    pub fn build(x: Edge<T>, y: Edge<T>) -> Self {
        Self {
            phantom_T: PhantomData,
            x,
            y,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(x: Edge<T>, y: Edge<T>) -> Edge<bool> {
        Self {
            phantom_T: PhantomData,
            x,
            y,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<dtype> GraphOperation for OutfeedEnqueue<dtype>
where dtype: TensorType,
      dtype: Clone,
      dtype: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("OutfeedEnqueue_{}")?
        };
        let mut new_op = graph.new_operation("OutfeedEnqueue", &op_name)?;
        {
            new_op.add_edge(&self.input)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct OutfeedEnqueue<dtype>
where dtype: TensorType,
      dtype: Clone,
      dtype: 'static,
{
    phantom_dtype: PhantomData<dtype>,
    input: Edge<dtype>,
    op_name: Option<String>,
    id_: usize,
}

impl<dtype> OutfeedEnqueue<dtype>
where dtype: TensorType,
      dtype: Clone,
      dtype: 'static,
{
    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> () {
        let rc = Rc::new(self);
        (
        )
    }

    pub fn build(input: Edge<dtype>) -> Self {
        Self {
            phantom_dtype: PhantomData,
            input,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(input: Edge<dtype>) -> () {
        Self {
            phantom_dtype: PhantomData,
            input,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<T> GraphOperation for HistogramSummary<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("HistogramSummary_{}")?
        };
        let mut new_op = graph.new_operation("HistogramSummary", &op_name)?;
        {
            new_op.add_edge(&self.tag)?
        }
        {
            new_op.add_edge(&self.values)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct HistogramSummary<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
{
    tag: Edge<String>,
    phantom_T: PhantomData<T>,
    values: Edge<T>,
    op_name: Option<String>,
    id_: usize,
}

impl<T> HistogramSummary<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
{
    pub fn summary(self) -> Edge<String> {
        let rc = Rc::new(self);
        {
            Edge::<String>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<String> {
        let rc = Rc::new(self);
        {
            Edge::<String>::new(rc.clone(), 0)
        }
    }

    pub fn build(tag: Edge<String>, values: Edge<T>) -> Self {
        Self {
            tag,
            phantom_T: PhantomData,
            values,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(tag: Edge<String>, values: Edge<T>) -> Edge<String> {
        Self {
            tag,
            phantom_T: PhantomData,
            values,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl GraphOperation for _ShutdownDistributedTPU {
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("_ShutdownDistributedTPU_{}")?
        };
        let mut new_op = graph.new_operation("_ShutdownDistributedTPU", &op_name)?;
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct _ShutdownDistributedTPU {
    op_name: Option<String>,
    id_: usize,
}

impl _ShutdownDistributedTPU {
    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> () {
        let rc = Rc::new(self);
        (
        )
    }

    pub fn build() -> Self {
        Self {
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new() -> () {
        Self {
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<T> GraphOperation for TensorArrayWriteV2<T>
where T: TensorType,
      T: Clone,
      T: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("TensorArrayWriteV2_{}")?
        };
        let mut new_op = graph.new_operation("TensorArrayWriteV2", &op_name)?;
        {
            new_op.add_edge(&self.handle)?
        }
        {
            new_op.add_edge(&self.index)?
        }
        {
            new_op.add_edge(&self.value)?
        }
        {
            new_op.add_edge(&self.flow_in)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct TensorArrayWriteV2<T>
where T: TensorType,
      T: Clone,
      T: 'static,
{
    handle: Edge<String>,
    index: Edge<i32>,
    phantom_T: PhantomData<T>,
    value: Edge<T>,
    flow_in: Edge<f32>,
    op_name: Option<String>,
    id_: usize,
}

impl<T> TensorArrayWriteV2<T>
where T: TensorType,
      T: Clone,
      T: 'static,
{
    pub fn flow_out(self) -> Edge<f32> {
        let rc = Rc::new(self);
        {
            Edge::<f32>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<f32> {
        let rc = Rc::new(self);
        {
            Edge::<f32>::new(rc.clone(), 0)
        }
    }

    pub fn build(handle: Edge<String>, index: Edge<i32>, value: Edge<T>, flow_in: Edge<f32>) -> Self {
        Self {
            handle,
            index,
            phantom_T: PhantomData,
            value,
            flow_in,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(handle: Edge<String>, index: Edge<i32>, value: Edge<T>, flow_in: Edge<f32>) -> Edge<f32> {
        Self {
            handle,
            index,
            phantom_T: PhantomData,
            value,
            flow_in,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<T, Tindices> GraphOperation for XlaDynamicSlice<T, Tindices>
where T: TensorType,
      T: Clone,
      Tindices: TensorType,
      Tindices: Clone,
      T: 'static,
      Tindices: con_or_DT_INT32_or_DT_INT64,
      Tindices: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("XlaDynamicSlice_{}")?
        };
        let mut new_op = graph.new_operation("XlaDynamicSlice", &op_name)?;
        {
            new_op.add_edge(&self.input)?
        }
        {
            new_op.add_edge(&self.start_indices)?
        }
        {
            new_op.add_edge(&self.size_indices)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct XlaDynamicSlice<T, Tindices>
where T: TensorType,
      T: Clone,
      Tindices: TensorType,
      Tindices: Clone,
      T: 'static,
      Tindices: con_or_DT_INT32_or_DT_INT64,
      Tindices: 'static,
{
    phantom_T: PhantomData<T>,
    input: Edge<T>,
    phantom_Tindices: PhantomData<Tindices>,
    start_indices: Edge<Tindices>,
    size_indices: Edge<Tindices>,
    op_name: Option<String>,
    id_: usize,
}

impl<T, Tindices> XlaDynamicSlice<T, Tindices>
where T: TensorType,
      T: Clone,
      Tindices: TensorType,
      Tindices: Clone,
      T: 'static,
      Tindices: con_or_DT_INT32_or_DT_INT64,
      Tindices: 'static,
{
    pub fn output(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(input: Edge<T>, start_indices: Edge<Tindices>, size_indices: Edge<Tindices>) -> Self {
        Self {
            phantom_T: PhantomData,
            input,
            phantom_Tindices: PhantomData,
            start_indices,
            size_indices,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(input: Edge<T>, start_indices: Edge<Tindices>, size_indices: Edge<Tindices>) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            input,
            phantom_Tindices: PhantomData,
            start_indices,
            size_indices,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl GraphOperation for AdjustHue {
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("AdjustHue_{}")?
        };
        let mut new_op = graph.new_operation("AdjustHue", &op_name)?;
        {
            new_op.add_edge(&self.images)?
        }
        {
            new_op.add_edge(&self.delta)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct AdjustHue {
    images: Edge<f32>,
    delta: Edge<f32>,
    op_name: Option<String>,
    id_: usize,
}

impl AdjustHue {
    pub fn output(self) -> Edge<f32> {
        let rc = Rc::new(self);
        {
            Edge::<f32>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<f32> {
        let rc = Rc::new(self);
        {
            Edge::<f32>::new(rc.clone(), 0)
        }
    }

    pub fn build(images: Edge<f32>, delta: Edge<f32>) -> Self {
        Self {
            images,
            delta,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(images: Edge<f32>, delta: Edge<f32>) -> Edge<f32> {
        Self {
            images,
            delta,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<T> GraphOperation for _MklSquaredDifference<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_COMPLEX64_or_DT_INT64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF,
      T: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("_MklSquaredDifference_{}")?
        };
        let mut new_op = graph.new_operation("_MklSquaredDifference", &op_name)?;
        {
            new_op.add_edge(&self.x)?
        }
        {
            new_op.add_edge(&self.y)?
        }
        {
            new_op.add_edge(&self.mkl_x)?
        }
        {
            new_op.add_edge(&self.mkl_y)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct _MklSquaredDifference<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_COMPLEX64_or_DT_INT64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    x: Edge<T>,
    y: Edge<T>,
    mkl_x: Edge<u8>,
    mkl_y: Edge<u8>,
    op_name: Option<String>,
    id_: usize,
}

impl<T> _MklSquaredDifference<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_COMPLEX64_or_DT_INT64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF,
      T: 'static,
{
    pub fn z(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn mkl_z(self) -> Edge<u8> {
        let rc = Rc::new(self);
        {
            Edge::<u8>::new(rc.clone(), 1)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> (Edge<T>, Edge<u8>) {
        let rc = Rc::new(self);
        (
        {
            Edge::<T>::new(rc.clone(), 0)
        },
        {
            Edge::<u8>::new(rc.clone(), 1)
        },
        )
    }

    pub fn build(x: Edge<T>, y: Edge<T>, mkl_x: Edge<u8>, mkl_y: Edge<u8>) -> Self {
        Self {
            phantom_T: PhantomData,
            x,
            y,
            mkl_x,
            mkl_y,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(x: Edge<T>, y: Edge<T>, mkl_x: Edge<u8>, mkl_y: Edge<u8>) -> (Edge<T>, Edge<u8>) {
        Self {
            phantom_T: PhantomData,
            x,
            y,
            mkl_x,
            mkl_y,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<component_types> GraphOperation for Barrier<component_types>
where component_types: 'static,
      component_types: Clone,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("Barrier_{}")?
        };
        let mut new_op = graph.new_operation("Barrier", &op_name)?;
        {
            match self.shapes {
                None => new_op.set_attr_value_proto("shapes", &vec![10_u8, 0_u8,])?,
                Some(ref value) => (|attrs| {new_op.set_attr_shape_list("shapes", attrs)})(&value)?,
            };
        }
        {
            match self.capacity {
                None => new_op.set_attr_value_proto("capacity", &vec![24_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 1_u8,])?,
                Some(ref value) => (|attr: &i64| {new_op.set_attr_int("capacity", *attr)})(&value)?,
            };
        }
        {
            match self.container {
                None => new_op.set_attr_value_proto("container", &vec![18_u8, 0_u8,])?,
                Some(ref value) => (|attr| {new_op.set_attr_string("container", attr)})(&value)?,
            };
        }
        {
            match self.shared_name {
                None => new_op.set_attr_value_proto("shared_name", &vec![18_u8, 0_u8,])?,
                Some(ref value) => (|attr| {new_op.set_attr_string("shared_name", attr)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct Barrier<component_types>
where component_types: 'static,
      component_types: Clone,
{
    phantom_component_types: PhantomData<component_types>,
    shapes: Option<Vec<OtherShape>>,
    capacity: Option<i64>,
    container: Option<String>,
    shared_name: Option<String>,
    op_name: Option<String>,
    id_: usize,
}

impl<component_types> Barrier<component_types>
where component_types: 'static,
      component_types: Clone,
{
    pub fn handle(self) -> Edge<String> {
        let rc = Rc::new(self);
        {
            Edge::<String>::new(rc.clone(), 0)
        }
    }

    pub fn shapes(&mut self, shapes: &[OtherShape]) -> Self {
        self.shapes = Some(shapes.to_vec());
        self.clone()
    }

    pub fn capacity(&mut self, capacity: i64) -> Self {
        self.capacity = Some(capacity);
        self.clone()
    }

    pub fn container(&mut self, container: &str) -> Self {
        self.container = Some(container.to_string());
        self.clone()
    }

    pub fn shared_name(&mut self, shared_name: &str) -> Self {
        self.shared_name = Some(shared_name.to_string());
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<String> {
        let rc = Rc::new(self);
        {
            Edge::<String>::new(rc.clone(), 0)
        }
    }

    pub fn build() -> Self {
        Self {
            phantom_component_types: PhantomData,
            shapes: None,
            capacity: None,
            container: None,
            shared_name: None,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new() -> Edge<String> {
        Self {
            phantom_component_types: PhantomData,
            shapes: None,
            capacity: None,
            container: None,
            shared_name: None,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<dtypes> GraphOperation for OrderedMapIncompleteSize<dtypes>
where dtypes: 'static,
      dtypes: Clone,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("OrderedMapIncompleteSize_{}")?
        };
        let mut new_op = graph.new_operation("OrderedMapIncompleteSize", &op_name)?;
        {
            match self.capacity {
                None => new_op.set_attr_value_proto("capacity", &vec![24_u8, 0_u8,])?,
                Some(ref value) => (|attr: &i64| {new_op.set_attr_int("capacity", *attr)})(&value)?,
            };
        }
        {
            match self.memory_limit {
                None => new_op.set_attr_value_proto("memory_limit", &vec![24_u8, 0_u8,])?,
                Some(ref value) => (|attr: &i64| {new_op.set_attr_int("memory_limit", *attr)})(&value)?,
            };
        }
        {
            match self.container {
                None => new_op.set_attr_value_proto("container", &vec![18_u8, 0_u8,])?,
                Some(ref value) => (|attr| {new_op.set_attr_string("container", attr)})(&value)?,
            };
        }
        {
            match self.shared_name {
                None => new_op.set_attr_value_proto("shared_name", &vec![18_u8, 0_u8,])?,
                Some(ref value) => (|attr| {new_op.set_attr_string("shared_name", attr)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct OrderedMapIncompleteSize<dtypes>
where dtypes: 'static,
      dtypes: Clone,
{
    capacity: Option<i64>,
    memory_limit: Option<i64>,
    phantom_dtypes: PhantomData<dtypes>,
    container: Option<String>,
    shared_name: Option<String>,
    op_name: Option<String>,
    id_: usize,
}

impl<dtypes> OrderedMapIncompleteSize<dtypes>
where dtypes: 'static,
      dtypes: Clone,
{
    pub fn size(self) -> Edge<i32> {
        let rc = Rc::new(self);
        {
            Edge::<i32>::new(rc.clone(), 0)
        }
    }

    pub fn capacity(&mut self, capacity: i64) -> Self {
        self.capacity = Some(capacity);
        self.clone()
    }

    pub fn memory_limit(&mut self, memory_limit: i64) -> Self {
        self.memory_limit = Some(memory_limit);
        self.clone()
    }

    pub fn container(&mut self, container: &str) -> Self {
        self.container = Some(container.to_string());
        self.clone()
    }

    pub fn shared_name(&mut self, shared_name: &str) -> Self {
        self.shared_name = Some(shared_name.to_string());
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<i32> {
        let rc = Rc::new(self);
        {
            Edge::<i32>::new(rc.clone(), 0)
        }
    }

    pub fn build() -> Self {
        Self {
            capacity: None,
            memory_limit: None,
            phantom_dtypes: PhantomData,
            container: None,
            shared_name: None,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new() -> Edge<i32> {
        Self {
            capacity: None,
            memory_limit: None,
            phantom_dtypes: PhantomData,
            container: None,
            shared_name: None,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl GraphOperation for GcsConfigureBlockCache {
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("GcsConfigureBlockCache_{}")?
        };
        let mut new_op = graph.new_operation("GcsConfigureBlockCache", &op_name)?;
        {
            new_op.add_edge(&self.max_cache_size)?
        }
        {
            new_op.add_edge(&self.block_size)?
        }
        {
            new_op.add_edge(&self.max_staleness)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct GcsConfigureBlockCache {
    max_cache_size: Edge<u64>,
    block_size: Edge<u64>,
    max_staleness: Edge<u64>,
    op_name: Option<String>,
    id_: usize,
}

impl GcsConfigureBlockCache {
    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> () {
        let rc = Rc::new(self);
        (
        )
    }

    pub fn build(max_cache_size: Edge<u64>, block_size: Edge<u64>, max_staleness: Edge<u64>) -> Self {
        Self {
            max_cache_size,
            block_size,
            max_staleness,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(max_cache_size: Edge<u64>, block_size: Edge<u64>, max_staleness: Edge<u64>) -> () {
        Self {
            max_cache_size,
            block_size,
            max_staleness,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<dtypes> GraphOperation for OrderedMapSize<dtypes>
where dtypes: 'static,
      dtypes: Clone,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("OrderedMapSize_{}")?
        };
        let mut new_op = graph.new_operation("OrderedMapSize", &op_name)?;
        {
            match self.capacity {
                None => new_op.set_attr_value_proto("capacity", &vec![24_u8, 0_u8,])?,
                Some(ref value) => (|attr: &i64| {new_op.set_attr_int("capacity", *attr)})(&value)?,
            };
        }
        {
            match self.memory_limit {
                None => new_op.set_attr_value_proto("memory_limit", &vec![24_u8, 0_u8,])?,
                Some(ref value) => (|attr: &i64| {new_op.set_attr_int("memory_limit", *attr)})(&value)?,
            };
        }
        {
            match self.container {
                None => new_op.set_attr_value_proto("container", &vec![18_u8, 0_u8,])?,
                Some(ref value) => (|attr| {new_op.set_attr_string("container", attr)})(&value)?,
            };
        }
        {
            match self.shared_name {
                None => new_op.set_attr_value_proto("shared_name", &vec![18_u8, 0_u8,])?,
                Some(ref value) => (|attr| {new_op.set_attr_string("shared_name", attr)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct OrderedMapSize<dtypes>
where dtypes: 'static,
      dtypes: Clone,
{
    capacity: Option<i64>,
    memory_limit: Option<i64>,
    phantom_dtypes: PhantomData<dtypes>,
    container: Option<String>,
    shared_name: Option<String>,
    op_name: Option<String>,
    id_: usize,
}

impl<dtypes> OrderedMapSize<dtypes>
where dtypes: 'static,
      dtypes: Clone,
{
    pub fn size(self) -> Edge<i32> {
        let rc = Rc::new(self);
        {
            Edge::<i32>::new(rc.clone(), 0)
        }
    }

    pub fn capacity(&mut self, capacity: i64) -> Self {
        self.capacity = Some(capacity);
        self.clone()
    }

    pub fn memory_limit(&mut self, memory_limit: i64) -> Self {
        self.memory_limit = Some(memory_limit);
        self.clone()
    }

    pub fn container(&mut self, container: &str) -> Self {
        self.container = Some(container.to_string());
        self.clone()
    }

    pub fn shared_name(&mut self, shared_name: &str) -> Self {
        self.shared_name = Some(shared_name.to_string());
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<i32> {
        let rc = Rc::new(self);
        {
            Edge::<i32>::new(rc.clone(), 0)
        }
    }

    pub fn build() -> Self {
        Self {
            capacity: None,
            memory_limit: None,
            phantom_dtypes: PhantomData,
            container: None,
            shared_name: None,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new() -> Edge<i32> {
        Self {
            capacity: None,
            memory_limit: None,
            phantom_dtypes: PhantomData,
            container: None,
            shared_name: None,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl GraphOperation for DecodeBmp {
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("DecodeBmp_{}")?
        };
        let mut new_op = graph.new_operation("DecodeBmp", &op_name)?;
        {
            new_op.add_edge(&self.contents)?
        }
        {
            match self.channels {
                None => new_op.set_attr_value_proto("channels", &vec![24_u8, 0_u8,])?,
                Some(ref value) => (|attr: &i64| {new_op.set_attr_int("channels", *attr)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct DecodeBmp {
    contents: Edge<String>,
    channels: Option<i64>,
    op_name: Option<String>,
    id_: usize,
}

impl DecodeBmp {
    pub fn image(self) -> Edge<u8> {
        let rc = Rc::new(self);
        {
            Edge::<u8>::new(rc.clone(), 0)
        }
    }

    pub fn channels(&mut self, channels: i64) -> Self {
        self.channels = Some(channels);
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<u8> {
        let rc = Rc::new(self);
        {
            Edge::<u8>::new(rc.clone(), 0)
        }
    }

    pub fn build(contents: Edge<String>) -> Self {
        Self {
            contents,
            channels: None,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(contents: Edge<String>) -> Edge<u8> {
        Self {
            contents,
            channels: None,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl GraphOperation for DecodeJpeg {
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("DecodeJpeg_{}")?
        };
        let mut new_op = graph.new_operation("DecodeJpeg", &op_name)?;
        {
            new_op.add_edge(&self.contents)?
        }
        {
            match self.channels {
                None => new_op.set_attr_value_proto("channels", &vec![24_u8, 0_u8,])?,
                Some(ref value) => (|attr: &i64| {new_op.set_attr_int("channels", *attr)})(&value)?,
            };
        }
        {
            match self.ratio {
                None => new_op.set_attr_value_proto("ratio", &vec![24_u8, 1_u8,])?,
                Some(ref value) => (|attr: &i64| {new_op.set_attr_int("ratio", *attr)})(&value)?,
            };
        }
        {
            match self.fancy_upscaling {
                None => new_op.set_attr_value_proto("fancy_upscaling", &vec![40_u8, 1_u8,])?,
                Some(ref value) => (|attr: &bool| {new_op.set_attr_bool("fancy_upscaling", *attr)})(&value)?,
            };
        }
        {
            match self.try_recover_truncated {
                None => new_op.set_attr_value_proto("try_recover_truncated", &vec![40_u8, 0_u8,])?,
                Some(ref value) => (|attr: &bool| {new_op.set_attr_bool("try_recover_truncated", *attr)})(&value)?,
            };
        }
        {
            match self.acceptable_fraction {
                None => new_op.set_attr_value_proto("acceptable_fraction", &vec![37_u8, 0_u8, 0_u8, 128_u8, 63_u8,])?,
                Some(ref value) => (|attr: &f32| {new_op.set_attr_float("acceptable_fraction", *attr)})(&value)?,
            };
        }
        {
            match self.dct_method {
                None => new_op.set_attr_value_proto("dct_method", &vec![18_u8, 0_u8,])?,
                Some(ref value) => (|attr| {new_op.set_attr_string("dct_method", attr)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct DecodeJpeg {
    contents: Edge<String>,
    channels: Option<i64>,
    ratio: Option<i64>,
    fancy_upscaling: Option<bool>,
    try_recover_truncated: Option<bool>,
    acceptable_fraction: Option<f32>,
    dct_method: Option<String>,
    op_name: Option<String>,
    id_: usize,
}

impl DecodeJpeg {
    pub fn image(self) -> Edge<u8> {
        let rc = Rc::new(self);
        {
            Edge::<u8>::new(rc.clone(), 0)
        }
    }

    pub fn channels(&mut self, channels: i64) -> Self {
        self.channels = Some(channels);
        self.clone()
    }

    pub fn ratio(&mut self, ratio: i64) -> Self {
        self.ratio = Some(ratio);
        self.clone()
    }

    pub fn fancy_upscaling(&mut self, fancy_upscaling: bool) -> Self {
        self.fancy_upscaling = Some(fancy_upscaling);
        self.clone()
    }

    pub fn try_recover_truncated(&mut self, try_recover_truncated: bool) -> Self {
        self.try_recover_truncated = Some(try_recover_truncated);
        self.clone()
    }

    pub fn acceptable_fraction(&mut self, acceptable_fraction: f32) -> Self {
        self.acceptable_fraction = Some(acceptable_fraction);
        self.clone()
    }

    pub fn dct_method(&mut self, dct_method: &str) -> Self {
        self.dct_method = Some(dct_method.to_string());
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<u8> {
        let rc = Rc::new(self);
        {
            Edge::<u8>::new(rc.clone(), 0)
        }
    }

    pub fn build(contents: Edge<String>) -> Self {
        Self {
            contents,
            channels: None,
            ratio: None,
            fancy_upscaling: None,
            try_recover_truncated: None,
            acceptable_fraction: None,
            dct_method: None,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(contents: Edge<String>) -> Edge<u8> {
        Self {
            contents,
            channels: None,
            ratio: None,
            fancy_upscaling: None,
            try_recover_truncated: None,
            acceptable_fraction: None,
            dct_method: None,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl GraphOperation for BoostedTreesMakeStatsSummary {
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("BoostedTreesMakeStatsSummary_{}")?
        };
        let mut new_op = graph.new_operation("BoostedTreesMakeStatsSummary", &op_name)?;
        {
            new_op.add_edge(&self.node_ids)?
        }
        {
            new_op.add_edge(&self.gradients)?
        }
        {
            new_op.add_edge(&self.hessians)?
        }
        {
            new_op.add_edge(&self.bucketized_features_list)?
        }
        {
            (|attr: &i64| {new_op.set_attr_int("max_splits", *attr)})(&self.max_splits)?
        }
        {
            (|attr: &i64| {new_op.set_attr_int("num_buckets", *attr)})(&self.num_buckets)?
        }
        {
            (|attr: &i64| {new_op.set_attr_int("num_features", *attr)})(&self.num_features)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct BoostedTreesMakeStatsSummary {
    node_ids: Edge<i32>,
    gradients: Edge<f32>,
    hessians: Edge<f32>,
    bucketized_features_list: Edge<i32>,
    max_splits: i64,
    num_buckets: i64,
    num_features: i64,
    op_name: Option<String>,
    id_: usize,
}

impl BoostedTreesMakeStatsSummary {
    pub fn stats_summary(self) -> Edge<f32> {
        let rc = Rc::new(self);
        {
            Edge::<f32>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<f32> {
        let rc = Rc::new(self);
        {
            Edge::<f32>::new(rc.clone(), 0)
        }
    }

    pub fn build(node_ids: Edge<i32>, gradients: Edge<f32>, hessians: Edge<f32>, bucketized_features_list: Edge<i32>, max_splits: i64, num_buckets: i64, num_features: i64) -> Self {
        Self {
            node_ids,
            gradients,
            hessians,
            bucketized_features_list,
            max_splits: max_splits,
            num_buckets: num_buckets,
            num_features: num_features,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(node_ids: Edge<i32>, gradients: Edge<f32>, hessians: Edge<f32>, bucketized_features_list: Edge<i32>, max_splits: i64, num_buckets: i64, num_features: i64) -> Edge<f32> {
        Self {
            node_ids,
            gradients,
            hessians,
            bucketized_features_list,
            max_splits: max_splits,
            num_buckets: num_buckets,
            num_features: num_features,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl GraphOperation for RetrieveTPUEmbeddingCenteredRMSPropParameters {
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("RetrieveTPUEmbeddingCenteredRMSPropParameters_{}")?
        };
        let mut new_op = graph.new_operation("RetrieveTPUEmbeddingCenteredRMSPropParameters", &op_name)?;
        {
            match self.table_id {
                None => new_op.set_attr_value_proto("table_id", &vec![24_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 1_u8,])?,
                Some(ref value) => (|attr: &i64| {new_op.set_attr_int("table_id", *attr)})(&value)?,
            };
        }
        {
            match self.table_name {
                None => new_op.set_attr_value_proto("table_name", &vec![18_u8, 0_u8,])?,
                Some(ref value) => (|attr| {new_op.set_attr_string("table_name", attr)})(&value)?,
            };
        }
        {
            (|attr: &i64| {new_op.set_attr_int("num_shards", *attr)})(&self.num_shards)?
        }
        {
            (|attr: &i64| {new_op.set_attr_int("shard_id", *attr)})(&self.shard_id)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct RetrieveTPUEmbeddingCenteredRMSPropParameters {
    table_id: Option<i64>,
    table_name: Option<String>,
    num_shards: i64,
    shard_id: i64,
    op_name: Option<String>,
    id_: usize,
}

impl RetrieveTPUEmbeddingCenteredRMSPropParameters {
    pub fn parameters(self) -> Edge<f32> {
        let rc = Rc::new(self);
        {
            Edge::<f32>::new(rc.clone(), 0)
        }
    }

    pub fn ms(self) -> Edge<f32> {
        let rc = Rc::new(self);
        {
            Edge::<f32>::new(rc.clone(), 1)
        }
    }

    pub fn mom(self) -> Edge<f32> {
        let rc = Rc::new(self);
        {
            Edge::<f32>::new(rc.clone(), 2)
        }
    }

    pub fn mg(self) -> Edge<f32> {
        let rc = Rc::new(self);
        {
            Edge::<f32>::new(rc.clone(), 3)
        }
    }

    pub fn table_id(&mut self, table_id: i64) -> Self {
        self.table_id = Some(table_id);
        self.clone()
    }

    pub fn table_name(&mut self, table_name: &str) -> Self {
        self.table_name = Some(table_name.to_string());
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> (Edge<f32>, Edge<f32>, Edge<f32>, Edge<f32>) {
        let rc = Rc::new(self);
        (
        {
            Edge::<f32>::new(rc.clone(), 0)
        },
        {
            Edge::<f32>::new(rc.clone(), 1)
        },
        {
            Edge::<f32>::new(rc.clone(), 2)
        },
        {
            Edge::<f32>::new(rc.clone(), 3)
        },
        )
    }

    pub fn build(num_shards: i64, shard_id: i64) -> Self {
        Self {
            table_id: None,
            table_name: None,
            num_shards: num_shards,
            shard_id: shard_id,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(num_shards: i64, shard_id: i64) -> (Edge<f32>, Edge<f32>, Edge<f32>, Edge<f32>) {
        Self {
            table_id: None,
            table_name: None,
            num_shards: num_shards,
            shard_id: shard_id,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<T, Tout> GraphOperation for ComplexAbs<T, Tout>
where T: TensorType,
      T: Clone,
      Tout: TensorType,
      T: con_or_DT_COMPLEX64_or_DT_COMPLEX128,
      T: 'static,
      Tout: con_or_DT_FLOAT_or_DT_DOUBLE,
      Tout: 'static,
      Tout: Clone,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("ComplexAbs_{}")?
        };
        let mut new_op = graph.new_operation("ComplexAbs", &op_name)?;
        {
            new_op.add_edge(&self.x)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct ComplexAbs<T, Tout>
where T: TensorType,
      T: Clone,
      Tout: TensorType,
      T: con_or_DT_COMPLEX64_or_DT_COMPLEX128,
      T: 'static,
      Tout: con_or_DT_FLOAT_or_DT_DOUBLE,
      Tout: 'static,
      Tout: Clone,
{
    phantom_T: PhantomData<T>,
    x: Edge<T>,
    phantom_Tout: PhantomData<Tout>,
    op_name: Option<String>,
    id_: usize,
}

impl<T, Tout> ComplexAbs<T, Tout>
where T: TensorType,
      T: Clone,
      Tout: TensorType,
      T: con_or_DT_COMPLEX64_or_DT_COMPLEX128,
      T: 'static,
      Tout: con_or_DT_FLOAT_or_DT_DOUBLE,
      Tout: 'static,
      Tout: Clone,
{
    pub fn y(self) -> Edge<Tout> {
        let rc = Rc::new(self);
        {
            Edge::<Tout>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<Tout> {
        let rc = Rc::new(self);
        {
            Edge::<Tout>::new(rc.clone(), 0)
        }
    }

    pub fn build(x: Edge<T>) -> Self {
        Self {
            phantom_T: PhantomData,
            x,
            phantom_Tout: PhantomData,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(x: Edge<T>) -> Edge<Tout> {
        Self {
            phantom_T: PhantomData,
            x,
            phantom_Tout: PhantomData,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl GraphOperation for LogicalAnd {
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("LogicalAnd_{}")?
        };
        let mut new_op = graph.new_operation("LogicalAnd", &op_name)?;
        {
            new_op.add_edge(&self.x)?
        }
        {
            new_op.add_edge(&self.y)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct LogicalAnd {
    x: Edge<bool>,
    y: Edge<bool>,
    op_name: Option<String>,
    id_: usize,
}

impl LogicalAnd {
    pub fn z(self) -> Edge<bool> {
        let rc = Rc::new(self);
        {
            Edge::<bool>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<bool> {
        let rc = Rc::new(self);
        {
            Edge::<bool>::new(rc.clone(), 0)
        }
    }

    pub fn build(x: Edge<bool>, y: Edge<bool>) -> Self {
        Self {
            x,
            y,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(x: Edge<bool>, y: Edge<bool>) -> Edge<bool> {
        Self {
            x,
            y,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl GraphOperation for DeleteSessionTensor {
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("DeleteSessionTensor_{}")?
        };
        let mut new_op = graph.new_operation("DeleteSessionTensor", &op_name)?;
        {
            new_op.add_edge(&self.handle)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct DeleteSessionTensor {
    handle: Edge<String>,
    op_name: Option<String>,
    id_: usize,
}

impl DeleteSessionTensor {
    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> () {
        let rc = Rc::new(self);
        (
        )
    }

    pub fn build(handle: Edge<String>) -> Self {
        Self {
            handle,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(handle: Edge<String>) -> () {
        Self {
            handle,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

pub trait con_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_UINT16_or_DT_UINT32_or_DT_UINT64 {
}

impl con_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_UINT16_or_DT_UINT32_or_DT_UINT64 for i16 {
}

impl con_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_UINT16_or_DT_UINT32_or_DT_UINT64 for i32 {
}

impl con_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_UINT16_or_DT_UINT32_or_DT_UINT64 for i64 {
}

impl con_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_UINT16_or_DT_UINT32_or_DT_UINT64 for i8 {
}

impl con_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_UINT16_or_DT_UINT32_or_DT_UINT64 for u16 {
}

impl con_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_UINT16_or_DT_UINT32_or_DT_UINT64 for u32 {
}

impl con_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_UINT16_or_DT_UINT32_or_DT_UINT64 for u64 {
}

impl con_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_UINT16_or_DT_UINT32_or_DT_UINT64 for u8 {
}

impl<T> GraphOperation for LeftShift<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_UINT16_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("LeftShift_{}")?
        };
        let mut new_op = graph.new_operation("LeftShift", &op_name)?;
        {
            new_op.add_edge(&self.x)?
        }
        {
            new_op.add_edge(&self.y)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct LeftShift<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_UINT16_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    x: Edge<T>,
    y: Edge<T>,
    op_name: Option<String>,
    id_: usize,
}

impl<T> LeftShift<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_UINT16_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
{
    pub fn z(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(x: Edge<T>, y: Edge<T>) -> Self {
        Self {
            phantom_T: PhantomData,
            x,
            y,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(x: Edge<T>, y: Edge<T>) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            x,
            y,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<T> GraphOperation for BitwiseXor<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_UINT16_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("BitwiseXor_{}")?
        };
        let mut new_op = graph.new_operation("BitwiseXor", &op_name)?;
        {
            new_op.add_edge(&self.x)?
        }
        {
            new_op.add_edge(&self.y)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct BitwiseXor<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_UINT16_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    x: Edge<T>,
    y: Edge<T>,
    op_name: Option<String>,
    id_: usize,
}

impl<T> BitwiseXor<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_UINT16_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
{
    pub fn z(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(x: Edge<T>, y: Edge<T>) -> Self {
        Self {
            phantom_T: PhantomData,
            x,
            y,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(x: Edge<T>, y: Edge<T>) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            x,
            y,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<T> GraphOperation for PopulationCount<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_UINT16_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("PopulationCount_{}")?
        };
        let mut new_op = graph.new_operation("PopulationCount", &op_name)?;
        {
            new_op.add_edge(&self.x)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct PopulationCount<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_UINT16_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    x: Edge<T>,
    op_name: Option<String>,
    id_: usize,
}

impl<T> PopulationCount<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_UINT16_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
{
    pub fn y(self) -> Edge<u8> {
        let rc = Rc::new(self);
        {
            Edge::<u8>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<u8> {
        let rc = Rc::new(self);
        {
            Edge::<u8>::new(rc.clone(), 0)
        }
    }

    pub fn build(x: Edge<T>) -> Self {
        Self {
            phantom_T: PhantomData,
            x,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(x: Edge<T>) -> Edge<u8> {
        Self {
            phantom_T: PhantomData,
            x,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<T, Tindices> GraphOperation for SegmentMean<T, Tindices>
where T: TensorType,
      T: Clone,
      Tindices: TensorType,
      Tindices: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
      Tindices: con_or_DT_INT32_or_DT_INT64,
      Tindices: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("SegmentMean_{}")?
        };
        let mut new_op = graph.new_operation("SegmentMean", &op_name)?;
        {
            new_op.add_edge(&self.data)?
        }
        {
            new_op.add_edge(&self.segment_ids)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct SegmentMean<T, Tindices>
where T: TensorType,
      T: Clone,
      Tindices: TensorType,
      Tindices: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
      Tindices: con_or_DT_INT32_or_DT_INT64,
      Tindices: 'static,
{
    phantom_T: PhantomData<T>,
    data: Edge<T>,
    phantom_Tindices: PhantomData<Tindices>,
    segment_ids: Edge<Tindices>,
    op_name: Option<String>,
    id_: usize,
}

impl<T, Tindices> SegmentMean<T, Tindices>
where T: TensorType,
      T: Clone,
      Tindices: TensorType,
      Tindices: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
      Tindices: con_or_DT_INT32_or_DT_INT64,
      Tindices: 'static,
{
    pub fn output(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(data: Edge<T>, segment_ids: Edge<Tindices>) -> Self {
        Self {
            phantom_T: PhantomData,
            data,
            phantom_Tindices: PhantomData,
            segment_ids,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(data: Edge<T>, segment_ids: Edge<Tindices>) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            data,
            phantom_Tindices: PhantomData,
            segment_ids,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<T> GraphOperation for AvgPool3DGrad<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
      T: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("AvgPool3DGrad_{}")?
        };
        let mut new_op = graph.new_operation("AvgPool3DGrad", &op_name)?;
        {
            new_op.add_edge(&self.orig_input_shape)?
        }
        {
            new_op.add_edge(&self.grad)?
        }
        {
            (|attrs| {new_op.set_attr_int_list("ksize", attrs)})(&self.ksize)?
        }
        {
            (|attrs| {new_op.set_attr_int_list("strides", attrs)})(&self.strides)?
        }
        {
            (|attr| {new_op.set_attr_string("padding", attr)})(&self.padding)?
        }
        {
            match self.data_format {
                None => new_op.set_attr_value_proto("data_format", &vec![18_u8, 5_u8, 78_u8, 68_u8, 72_u8, 87_u8, 67_u8,])?,
                Some(ref value) => (|attr| {new_op.set_attr_string("data_format", attr)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct AvgPool3DGrad<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
      T: 'static,
{
    orig_input_shape: Edge<i32>,
    phantom_T: PhantomData<T>,
    grad: Edge<T>,
    ksize: Vec<i64>,
    strides: Vec<i64>,
    padding: String,
    data_format: Option<String>,
    op_name: Option<String>,
    id_: usize,
}

impl<T> AvgPool3DGrad<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
      T: 'static,
{
    pub fn output(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn data_format(&mut self, data_format: &str) -> Self {
        self.data_format = Some(data_format.to_string());
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(orig_input_shape: Edge<i32>, grad: Edge<T>, ksize: &[i64], strides: &[i64], padding: &str) -> Self {
        Self {
            orig_input_shape,
            phantom_T: PhantomData,
            grad,
            ksize: ksize.to_vec(),
            strides: strides.to_vec(),
            padding: padding.to_string(),
            data_format: None,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(orig_input_shape: Edge<i32>, grad: Edge<T>, ksize: &[i64], strides: &[i64], padding: &str) -> Edge<T> {
        Self {
            orig_input_shape,
            phantom_T: PhantomData,
            grad,
            ksize: ksize.to_vec(),
            strides: strides.to_vec(),
            padding: padding.to_string(),
            data_format: None,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<T> GraphOperation for UnbatchGrad<T>
where T: TensorType,
      T: Clone,
      T: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("UnbatchGrad_{}")?
        };
        let mut new_op = graph.new_operation("UnbatchGrad", &op_name)?;
        {
            new_op.add_edge(&self.original_input)?
        }
        {
            new_op.add_edge(&self.batch_index)?
        }
        {
            new_op.add_edge(&self.grad)?
        }
        {
            new_op.add_edge(&self.id)?
        }
        {
            match self.container {
                None => new_op.set_attr_value_proto("container", &vec![18_u8, 0_u8,])?,
                Some(ref value) => (|attr| {new_op.set_attr_string("container", attr)})(&value)?,
            };
        }
        {
            match self.shared_name {
                None => new_op.set_attr_value_proto("shared_name", &vec![18_u8, 0_u8,])?,
                Some(ref value) => (|attr| {new_op.set_attr_string("shared_name", attr)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct UnbatchGrad<T>
where T: TensorType,
      T: Clone,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    original_input: Edge<T>,
    batch_index: Edge<i64>,
    grad: Edge<T>,
    id: Edge<i64>,
    container: Option<String>,
    shared_name: Option<String>,
    op_name: Option<String>,
    id_: usize,
}

impl<T> UnbatchGrad<T>
where T: TensorType,
      T: Clone,
      T: 'static,
{
    pub fn batched_grad(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn container(&mut self, container: &str) -> Self {
        self.container = Some(container.to_string());
        self.clone()
    }

    pub fn shared_name(&mut self, shared_name: &str) -> Self {
        self.shared_name = Some(shared_name.to_string());
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(original_input: Edge<T>, batch_index: Edge<i64>, grad: Edge<T>, id: Edge<i64>) -> Self {
        Self {
            phantom_T: PhantomData,
            original_input,
            batch_index,
            grad,
            id,
            container: None,
            shared_name: None,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(original_input: Edge<T>, batch_index: Edge<i64>, grad: Edge<T>, id: Edge<i64>) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            original_input,
            batch_index,
            grad,
            id,
            container: None,
            shared_name: None,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<T> GraphOperation for DebugGradientRefIdentity<T>
where T: TensorType,
      T: Clone,
      T: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("DebugGradientRefIdentity_{}")?
        };
        let mut new_op = graph.new_operation("DebugGradientRefIdentity", &op_name)?;
        {
            new_op.add_edge(&self.input)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct DebugGradientRefIdentity<T>
where T: TensorType,
      T: Clone,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    input: Edge<T>,
    op_name: Option<String>,
    id_: usize,
}

impl<T> DebugGradientRefIdentity<T>
where T: TensorType,
      T: Clone,
      T: 'static,
{
    pub fn output(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(input: Edge<T>) -> Self {
        Self {
            phantom_T: PhantomData,
            input,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(input: Edge<T>) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            input,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<T> GraphOperation for AccumulateNV2<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("AccumulateNV2_{}")?
        };
        let mut new_op = graph.new_operation("AccumulateNV2", &op_name)?;
        {
            new_op.add_edge(&self.inputs)?
        }
        {
            (|attr: &i64| {new_op.set_attr_int("N", *attr)})(&self.N)?
        }
        {
            (|attr| {new_op.set_attr_shape("shape", attr)})(&self.shape)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct AccumulateNV2<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    inputs: Edge<T>,
    N: i64,
    shape: OtherShape,
    op_name: Option<String>,
    id_: usize,
}

impl<T> AccumulateNV2<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
{
    pub fn sum(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(inputs: Edge<T>, N: i64, shape: &OtherShape) -> Self {
        Self {
            phantom_T: PhantomData,
            inputs,
            N: N,
            shape: shape.clone(),
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(inputs: Edge<T>, N: i64, shape: &OtherShape) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            inputs,
            N: N,
            shape: shape.clone(),
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<T> GraphOperation for XlaSort<T>
where T: TensorType,
      T: Clone,
      T: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("XlaSort_{}")?
        };
        let mut new_op = graph.new_operation("XlaSort", &op_name)?;
        {
            new_op.add_edge(&self.input)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct XlaSort<T>
where T: TensorType,
      T: Clone,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    input: Edge<T>,
    op_name: Option<String>,
    id_: usize,
}

impl<T> XlaSort<T>
where T: TensorType,
      T: Clone,
      T: 'static,
{
    pub fn output(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(input: Edge<T>) -> Self {
        Self {
            phantom_T: PhantomData,
            input,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(input: Edge<T>) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            input,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl GraphOperation for ReaderReset {
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("ReaderReset_{}")?
        };
        let mut new_op = graph.new_operation("ReaderReset", &op_name)?;
        {
            new_op.add_edge(&self.reader_handle)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct ReaderReset {
    reader_handle: Edge<String>,
    op_name: Option<String>,
    id_: usize,
}

impl ReaderReset {
    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> () {
        let rc = Rc::new(self);
        (
        )
    }

    pub fn build(reader_handle: Edge<String>) -> Self {
        Self {
            reader_handle,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(reader_handle: Edge<String>) -> () {
        Self {
            reader_handle,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl GraphOperation for CTCBeamSearchDecoder {
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("CTCBeamSearchDecoder_{}")?
        };
        let mut new_op = graph.new_operation("CTCBeamSearchDecoder", &op_name)?;
        {
            new_op.add_edge(&self.inputs)?
        }
        {
            new_op.add_edge(&self.sequence_length)?
        }
        {
            (|attr: &i64| {new_op.set_attr_int("beam_width", *attr)})(&self.beam_width)?
        }
        {
            (|attr: &i64| {new_op.set_attr_int("top_paths", *attr)})(&self.top_paths)?
        }
        {
            match self.merge_repeated {
                None => new_op.set_attr_value_proto("merge_repeated", &vec![40_u8, 1_u8,])?,
                Some(ref value) => (|attr: &bool| {new_op.set_attr_bool("merge_repeated", *attr)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct CTCBeamSearchDecoder {
    inputs: Edge<f32>,
    sequence_length: Edge<i32>,
    beam_width: i64,
    top_paths: i64,
    merge_repeated: Option<bool>,
    op_name: Option<String>,
    id_: usize,
}

impl CTCBeamSearchDecoder {
    pub fn decoded_indices(self) -> Edge<i64> {
        let rc = Rc::new(self);
        {
            Edge::<i64>::new(rc.clone(), 0)
        }
    }

    pub fn decoded_values(self) -> Edge<i64> {
        let rc = Rc::new(self);
        {
            Edge::<i64>::new(rc.clone(), 1)
        }
    }

    pub fn decoded_shape(self) -> Edge<i64> {
        let rc = Rc::new(self);
        {
            Edge::<i64>::new(rc.clone(), 2)
        }
    }

    pub fn log_probability(self) -> Edge<f32> {
        let rc = Rc::new(self);
        {
            Edge::<f32>::new(rc.clone(), 3)
        }
    }

    pub fn merge_repeated(&mut self, merge_repeated: bool) -> Self {
        self.merge_repeated = Some(merge_repeated);
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> (Edge<i64>, Edge<i64>, Edge<i64>, Edge<f32>) {
        let rc = Rc::new(self);
        (
        {
            Edge::<i64>::new(rc.clone(), 0)
        },
        {
            Edge::<i64>::new(rc.clone(), 1)
        },
        {
            Edge::<i64>::new(rc.clone(), 2)
        },
        {
            Edge::<f32>::new(rc.clone(), 3)
        },
        )
    }

    pub fn build(inputs: Edge<f32>, sequence_length: Edge<i32>, beam_width: i64, top_paths: i64) -> Self {
        Self {
            inputs,
            sequence_length,
            beam_width: beam_width,
            top_paths: top_paths,
            merge_repeated: None,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(inputs: Edge<f32>, sequence_length: Edge<i32>, beam_width: i64, top_paths: i64) -> (Edge<i64>, Edge<i64>, Edge<i64>, Edge<f32>) {
        Self {
            inputs,
            sequence_length,
            beam_width: beam_width,
            top_paths: top_paths,
            merge_repeated: None,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl GraphOperation for AudioSpectrogram {
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("AudioSpectrogram_{}")?
        };
        let mut new_op = graph.new_operation("AudioSpectrogram", &op_name)?;
        {
            new_op.add_edge(&self.input)?
        }
        {
            (|attr: &i64| {new_op.set_attr_int("window_size", *attr)})(&self.window_size)?
        }
        {
            (|attr: &i64| {new_op.set_attr_int("stride", *attr)})(&self.stride)?
        }
        {
            match self.magnitude_squared {
                None => new_op.set_attr_value_proto("magnitude_squared", &vec![40_u8, 0_u8,])?,
                Some(ref value) => (|attr: &bool| {new_op.set_attr_bool("magnitude_squared", *attr)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct AudioSpectrogram {
    input: Edge<f32>,
    window_size: i64,
    stride: i64,
    magnitude_squared: Option<bool>,
    op_name: Option<String>,
    id_: usize,
}

impl AudioSpectrogram {
    pub fn spectrogram(self) -> Edge<f32> {
        let rc = Rc::new(self);
        {
            Edge::<f32>::new(rc.clone(), 0)
        }
    }

    pub fn magnitude_squared(&mut self, magnitude_squared: bool) -> Self {
        self.magnitude_squared = Some(magnitude_squared);
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<f32> {
        let rc = Rc::new(self);
        {
            Edge::<f32>::new(rc.clone(), 0)
        }
    }

    pub fn build(input: Edge<f32>, window_size: i64, stride: i64) -> Self {
        Self {
            input,
            window_size: window_size,
            stride: stride,
            magnitude_squared: None,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(input: Edge<f32>, window_size: i64, stride: i64) -> Edge<f32> {
        Self {
            input,
            window_size: window_size,
            stride: stride,
            magnitude_squared: None,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<T> GraphOperation for ApplyAdaMax<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("ApplyAdaMax_{}")?
        };
        let mut new_op = graph.new_operation("ApplyAdaMax", &op_name)?;
        {
            new_op.add_edge(&self.var)?
        }
        {
            new_op.add_edge(&self.m)?
        }
        {
            new_op.add_edge(&self.v)?
        }
        {
            new_op.add_edge(&self.beta1_power)?
        }
        {
            new_op.add_edge(&self.lr)?
        }
        {
            new_op.add_edge(&self.beta1)?
        }
        {
            new_op.add_edge(&self.beta2)?
        }
        {
            new_op.add_edge(&self.epsilon)?
        }
        {
            new_op.add_edge(&self.grad)?
        }
        {
            match self.use_locking {
                None => new_op.set_attr_value_proto("use_locking", &vec![40_u8, 0_u8,])?,
                Some(ref value) => (|attr: &bool| {new_op.set_attr_bool("use_locking", *attr)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct ApplyAdaMax<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    var: Edge<T>,
    m: Edge<T>,
    v: Edge<T>,
    beta1_power: Edge<T>,
    lr: Edge<T>,
    beta1: Edge<T>,
    beta2: Edge<T>,
    epsilon: Edge<T>,
    grad: Edge<T>,
    use_locking: Option<bool>,
    op_name: Option<String>,
    id_: usize,
}

impl<T> ApplyAdaMax<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
{
    pub fn out(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn use_locking(&mut self, use_locking: bool) -> Self {
        self.use_locking = Some(use_locking);
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(var: Edge<T>, m: Edge<T>, v: Edge<T>, beta1_power: Edge<T>, lr: Edge<T>, beta1: Edge<T>, beta2: Edge<T>, epsilon: Edge<T>, grad: Edge<T>) -> Self {
        Self {
            phantom_T: PhantomData,
            var,
            m,
            v,
            beta1_power,
            lr,
            beta1,
            beta2,
            epsilon,
            grad,
            use_locking: None,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(var: Edge<T>, m: Edge<T>, v: Edge<T>, beta1_power: Edge<T>, lr: Edge<T>, beta1: Edge<T>, beta2: Edge<T>, epsilon: Edge<T>, grad: Edge<T>) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            var,
            m,
            v,
            beta1_power,
            lr,
            beta1,
            beta2,
            epsilon,
            grad,
            use_locking: None,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<T> GraphOperation for RandomGammaGrad<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE,
      T: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("RandomGammaGrad_{}")?
        };
        let mut new_op = graph.new_operation("RandomGammaGrad", &op_name)?;
        {
            new_op.add_edge(&self.alpha)?
        }
        {
            new_op.add_edge(&self.sample)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct RandomGammaGrad<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    alpha: Edge<T>,
    sample: Edge<T>,
    op_name: Option<String>,
    id_: usize,
}

impl<T> RandomGammaGrad<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE,
      T: 'static,
{
    pub fn output(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(alpha: Edge<T>, sample: Edge<T>) -> Self {
        Self {
            phantom_T: PhantomData,
            alpha,
            sample,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(alpha: Edge<T>, sample: Edge<T>) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            alpha,
            sample,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

pub trait con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_STRING_or_DT_COMPLEX64_or_DT_INT64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_STRING_or_DT_COMPLEX64_or_DT_INT64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF for BFloat16 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_STRING_or_DT_COMPLEX64_or_DT_INT64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF for OtherComplex<f32> {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_STRING_or_DT_COMPLEX64_or_DT_INT64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF for OtherComplex<f64> {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_STRING_or_DT_COMPLEX64_or_DT_INT64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF for String {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_STRING_or_DT_COMPLEX64_or_DT_INT64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF for f32 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_STRING_or_DT_COMPLEX64_or_DT_INT64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF for f64 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_STRING_or_DT_COMPLEX64_or_DT_INT64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF for i16 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_STRING_or_DT_COMPLEX64_or_DT_INT64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF for i32 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_STRING_or_DT_COMPLEX64_or_DT_INT64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF for i64 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_STRING_or_DT_COMPLEX64_or_DT_INT64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF for i8 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_STRING_or_DT_COMPLEX64_or_DT_INT64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF for u8 {
}

impl<T> GraphOperation for Add<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_STRING_or_DT_COMPLEX64_or_DT_INT64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF,
      T: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("Add_{}")?
        };
        let mut new_op = graph.new_operation("Add", &op_name)?;
        {
            new_op.add_edge(&self.x)?
        }
        {
            new_op.add_edge(&self.y)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct Add<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_STRING_or_DT_COMPLEX64_or_DT_INT64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    x: Edge<T>,
    y: Edge<T>,
    op_name: Option<String>,
    id_: usize,
}

impl<T> Add<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_STRING_or_DT_COMPLEX64_or_DT_INT64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF,
      T: 'static,
{
    pub fn z(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(x: Edge<T>, y: Edge<T>) -> Self {
        Self {
            phantom_T: PhantomData,
            x,
            y,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(x: Edge<T>, y: Edge<T>) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            x,
            y,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<T1, T2, Toutput> GraphOperation for QuantizedAdd<T1, T2, Toutput>
where T1: TensorType,
      T1: Clone,
      T2: TensorType,
      T2: Clone,
      Toutput: TensorType,
      T1: con_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_QINT16_or_DT_QUINT16,
      T1: 'static,
      T2: con_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_QINT16_or_DT_QUINT16,
      T2: 'static,
      Toutput: con_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_QINT16_or_DT_QUINT16,
      Toutput: 'static,
      Toutput: Clone,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("QuantizedAdd_{}")?
        };
        let mut new_op = graph.new_operation("QuantizedAdd", &op_name)?;
        {
            new_op.add_edge(&self.x)?
        }
        {
            new_op.add_edge(&self.y)?
        }
        {
            new_op.add_edge(&self.min_x)?
        }
        {
            new_op.add_edge(&self.max_x)?
        }
        {
            new_op.add_edge(&self.min_y)?
        }
        {
            new_op.add_edge(&self.max_y)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct QuantizedAdd<T1, T2, Toutput>
where T1: TensorType,
      T1: Clone,
      T2: TensorType,
      T2: Clone,
      Toutput: TensorType,
      T1: con_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_QINT16_or_DT_QUINT16,
      T1: 'static,
      T2: con_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_QINT16_or_DT_QUINT16,
      T2: 'static,
      Toutput: con_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_QINT16_or_DT_QUINT16,
      Toutput: 'static,
      Toutput: Clone,
{
    phantom_T1: PhantomData<T1>,
    x: Edge<T1>,
    phantom_T2: PhantomData<T2>,
    y: Edge<T2>,
    min_x: Edge<f32>,
    max_x: Edge<f32>,
    min_y: Edge<f32>,
    max_y: Edge<f32>,
    phantom_Toutput: PhantomData<Toutput>,
    op_name: Option<String>,
    id_: usize,
}

impl<T1, T2, Toutput> QuantizedAdd<T1, T2, Toutput>
where T1: TensorType,
      T1: Clone,
      T2: TensorType,
      T2: Clone,
      Toutput: TensorType,
      T1: con_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_QINT16_or_DT_QUINT16,
      T1: 'static,
      T2: con_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_QINT16_or_DT_QUINT16,
      T2: 'static,
      Toutput: con_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_QINT16_or_DT_QUINT16,
      Toutput: 'static,
      Toutput: Clone,
{
    pub fn z(self) -> Edge<Toutput> {
        let rc = Rc::new(self);
        {
            Edge::<Toutput>::new(rc.clone(), 0)
        }
    }

    pub fn min_z(self) -> Edge<f32> {
        let rc = Rc::new(self);
        {
            Edge::<f32>::new(rc.clone(), 1)
        }
    }

    pub fn max_z(self) -> Edge<f32> {
        let rc = Rc::new(self);
        {
            Edge::<f32>::new(rc.clone(), 2)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> (Edge<Toutput>, Edge<f32>, Edge<f32>) {
        let rc = Rc::new(self);
        (
        {
            Edge::<Toutput>::new(rc.clone(), 0)
        },
        {
            Edge::<f32>::new(rc.clone(), 1)
        },
        {
            Edge::<f32>::new(rc.clone(), 2)
        },
        )
    }

    pub fn build(x: Edge<T1>, y: Edge<T2>, min_x: Edge<f32>, max_x: Edge<f32>, min_y: Edge<f32>, max_y: Edge<f32>) -> Self {
        Self {
            phantom_T1: PhantomData,
            x,
            phantom_T2: PhantomData,
            y,
            min_x,
            max_x,
            min_y,
            max_y,
            phantom_Toutput: PhantomData,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(x: Edge<T1>, y: Edge<T2>, min_x: Edge<f32>, max_x: Edge<f32>, min_y: Edge<f32>, max_y: Edge<f32>) -> (Edge<Toutput>, Edge<f32>, Edge<f32>) {
        Self {
            phantom_T1: PhantomData,
            x,
            phantom_T2: PhantomData,
            y,
            min_x,
            max_x,
            min_y,
            max_y,
            phantom_Toutput: PhantomData,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl GraphOperation for DecodeWav {
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("DecodeWav_{}")?
        };
        let mut new_op = graph.new_operation("DecodeWav", &op_name)?;
        {
            new_op.add_edge(&self.contents)?
        }
        {
            match self.desired_channels {
                None => new_op.set_attr_value_proto("desired_channels", &vec![24_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 1_u8,])?,
                Some(ref value) => (|attr: &i64| {new_op.set_attr_int("desired_channels", *attr)})(&value)?,
            };
        }
        {
            match self.desired_samples {
                None => new_op.set_attr_value_proto("desired_samples", &vec![24_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 1_u8,])?,
                Some(ref value) => (|attr: &i64| {new_op.set_attr_int("desired_samples", *attr)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct DecodeWav {
    contents: Edge<String>,
    desired_channels: Option<i64>,
    desired_samples: Option<i64>,
    op_name: Option<String>,
    id_: usize,
}

impl DecodeWav {
    pub fn audio(self) -> Edge<f32> {
        let rc = Rc::new(self);
        {
            Edge::<f32>::new(rc.clone(), 0)
        }
    }

    pub fn sample_rate(self) -> Edge<i32> {
        let rc = Rc::new(self);
        {
            Edge::<i32>::new(rc.clone(), 1)
        }
    }

    pub fn desired_channels(&mut self, desired_channels: i64) -> Self {
        self.desired_channels = Some(desired_channels);
        self.clone()
    }

    pub fn desired_samples(&mut self, desired_samples: i64) -> Self {
        self.desired_samples = Some(desired_samples);
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> (Edge<f32>, Edge<i32>) {
        let rc = Rc::new(self);
        (
        {
            Edge::<f32>::new(rc.clone(), 0)
        },
        {
            Edge::<i32>::new(rc.clone(), 1)
        },
        )
    }

    pub fn build(contents: Edge<String>) -> Self {
        Self {
            contents,
            desired_channels: None,
            desired_samples: None,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(contents: Edge<String>) -> (Edge<f32>, Edge<i32>) {
        Self {
            contents,
            desired_channels: None,
            desired_samples: None,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<T, out_idx> GraphOperation for Unique<T, out_idx>
where T: TensorType,
      T: Clone,
      out_idx: TensorType,
      T: 'static,
      out_idx: con_or_DT_INT32_or_DT_INT64,
      out_idx: 'static,
      out_idx: Clone,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("Unique_{}")?
        };
        let mut new_op = graph.new_operation("Unique", &op_name)?;
        {
            new_op.add_edge(&self.x)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct Unique<T, out_idx>
where T: TensorType,
      T: Clone,
      out_idx: TensorType,
      T: 'static,
      out_idx: con_or_DT_INT32_or_DT_INT64,
      out_idx: 'static,
      out_idx: Clone,
{
    phantom_T: PhantomData<T>,
    x: Edge<T>,
    phantom_out_idx: PhantomData<out_idx>,
    op_name: Option<String>,
    id_: usize,
}

impl<T, out_idx> Unique<T, out_idx>
where T: TensorType,
      T: Clone,
      out_idx: TensorType,
      T: 'static,
      out_idx: con_or_DT_INT32_or_DT_INT64,
      out_idx: 'static,
      out_idx: Clone,
{
    pub fn y(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn idx(self) -> Edge<out_idx> {
        let rc = Rc::new(self);
        {
            Edge::<out_idx>::new(rc.clone(), 1)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> (Edge<T>, Edge<out_idx>) {
        let rc = Rc::new(self);
        (
        {
            Edge::<T>::new(rc.clone(), 0)
        },
        {
            Edge::<out_idx>::new(rc.clone(), 1)
        },
        )
    }

    pub fn build(x: Edge<T>) -> Self {
        Self {
            phantom_T: PhantomData,
            x,
            phantom_out_idx: PhantomData,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(x: Edge<T>) -> (Edge<T>, Edge<out_idx>) {
        Self {
            phantom_T: PhantomData,
            x,
            phantom_out_idx: PhantomData,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<T> GraphOperation for RefSelect<T>
where T: TensorType,
      T: Clone,
      T: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("RefSelect_{}")?
        };
        let mut new_op = graph.new_operation("RefSelect", &op_name)?;
        {
            new_op.add_edge(&self.index)?
        }
        {
            new_op.add_edge(&self.inputs)?
        }
        {
            (|attr: &i64| {new_op.set_attr_int("N", *attr)})(&self.N)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct RefSelect<T>
where T: TensorType,
      T: Clone,
      T: 'static,
{
    index: Edge<i32>,
    phantom_T: PhantomData<T>,
    inputs: Edge<T>,
    N: i64,
    op_name: Option<String>,
    id_: usize,
}

impl<T> RefSelect<T>
where T: TensorType,
      T: Clone,
      T: 'static,
{
    pub fn output(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(index: Edge<i32>, inputs: Edge<T>, N: i64) -> Self {
        Self {
            index,
            phantom_T: PhantomData,
            inputs,
            N: N,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(index: Edge<i32>, inputs: Edge<T>, N: i64) -> Edge<T> {
        Self {
            index,
            phantom_T: PhantomData,
            inputs,
            N: N,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<T, Tpaddings> GraphOperation for MirrorPad<T, Tpaddings>
where T: TensorType,
      T: Clone,
      Tpaddings: TensorType,
      Tpaddings: Clone,
      T: 'static,
      Tpaddings: con_or_DT_INT32_or_DT_INT64,
      Tpaddings: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("MirrorPad_{}")?
        };
        let mut new_op = graph.new_operation("MirrorPad", &op_name)?;
        {
            new_op.add_edge(&self.input)?
        }
        {
            new_op.add_edge(&self.paddings)?
        }
        {
            (|attr| {new_op.set_attr_string("mode", attr)})(&self.mode)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct MirrorPad<T, Tpaddings>
where T: TensorType,
      T: Clone,
      Tpaddings: TensorType,
      Tpaddings: Clone,
      T: 'static,
      Tpaddings: con_or_DT_INT32_or_DT_INT64,
      Tpaddings: 'static,
{
    phantom_T: PhantomData<T>,
    input: Edge<T>,
    phantom_Tpaddings: PhantomData<Tpaddings>,
    paddings: Edge<Tpaddings>,
    mode: String,
    op_name: Option<String>,
    id_: usize,
}

impl<T, Tpaddings> MirrorPad<T, Tpaddings>
where T: TensorType,
      T: Clone,
      Tpaddings: TensorType,
      Tpaddings: Clone,
      T: 'static,
      Tpaddings: con_or_DT_INT32_or_DT_INT64,
      Tpaddings: 'static,
{
    pub fn output(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(input: Edge<T>, paddings: Edge<Tpaddings>, mode: &str) -> Self {
        Self {
            phantom_T: PhantomData,
            input,
            phantom_Tpaddings: PhantomData,
            paddings,
            mode: mode.to_string(),
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(input: Edge<T>, paddings: Edge<Tpaddings>, mode: &str) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            input,
            phantom_Tpaddings: PhantomData,
            paddings,
            mode: mode.to_string(),
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl GraphOperation for FakeQuantWithMinMaxVarsPerChannelGradient {
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("FakeQuantWithMinMaxVarsPerChannelGradient_{}")?
        };
        let mut new_op = graph.new_operation("FakeQuantWithMinMaxVarsPerChannelGradient", &op_name)?;
        {
            new_op.add_edge(&self.gradients)?
        }
        {
            new_op.add_edge(&self.inputs)?
        }
        {
            new_op.add_edge(&self.min)?
        }
        {
            new_op.add_edge(&self.max)?
        }
        {
            match self.num_bits {
                None => new_op.set_attr_value_proto("num_bits", &vec![24_u8, 8_u8,])?,
                Some(ref value) => (|attr: &i64| {new_op.set_attr_int("num_bits", *attr)})(&value)?,
            };
        }
        {
            match self.narrow_range {
                None => new_op.set_attr_value_proto("narrow_range", &vec![40_u8, 0_u8,])?,
                Some(ref value) => (|attr: &bool| {new_op.set_attr_bool("narrow_range", *attr)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct FakeQuantWithMinMaxVarsPerChannelGradient {
    gradients: Edge<f32>,
    inputs: Edge<f32>,
    min: Edge<f32>,
    max: Edge<f32>,
    num_bits: Option<i64>,
    narrow_range: Option<bool>,
    op_name: Option<String>,
    id_: usize,
}

impl FakeQuantWithMinMaxVarsPerChannelGradient {
    pub fn backprops_wrt_input(self) -> Edge<f32> {
        let rc = Rc::new(self);
        {
            Edge::<f32>::new(rc.clone(), 0)
        }
    }

    pub fn backprop_wrt_min(self) -> Edge<f32> {
        let rc = Rc::new(self);
        {
            Edge::<f32>::new(rc.clone(), 1)
        }
    }

    pub fn backprop_wrt_max(self) -> Edge<f32> {
        let rc = Rc::new(self);
        {
            Edge::<f32>::new(rc.clone(), 2)
        }
    }

    pub fn num_bits(&mut self, num_bits: i64) -> Self {
        self.num_bits = Some(num_bits);
        self.clone()
    }

    pub fn narrow_range(&mut self, narrow_range: bool) -> Self {
        self.narrow_range = Some(narrow_range);
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> (Edge<f32>, Edge<f32>, Edge<f32>) {
        let rc = Rc::new(self);
        (
        {
            Edge::<f32>::new(rc.clone(), 0)
        },
        {
            Edge::<f32>::new(rc.clone(), 1)
        },
        {
            Edge::<f32>::new(rc.clone(), 2)
        },
        )
    }

    pub fn build(gradients: Edge<f32>, inputs: Edge<f32>, min: Edge<f32>, max: Edge<f32>) -> Self {
        Self {
            gradients,
            inputs,
            min,
            max,
            num_bits: None,
            narrow_range: None,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(gradients: Edge<f32>, inputs: Edge<f32>, min: Edge<f32>, max: Edge<f32>) -> (Edge<f32>, Edge<f32>, Edge<f32>) {
        Self {
            gradients,
            inputs,
            min,
            max,
            num_bits: None,
            narrow_range: None,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<dtype> GraphOperation for TensorArrayRead<dtype>
where dtype: TensorType,
      dtype: 'static,
      dtype: Clone,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("TensorArrayRead_{}")?
        };
        let mut new_op = graph.new_operation("TensorArrayRead", &op_name)?;
        {
            new_op.add_edge(&self.handle)?
        }
        {
            new_op.add_edge(&self.index)?
        }
        {
            new_op.add_edge(&self.flow_in)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct TensorArrayRead<dtype>
where dtype: TensorType,
      dtype: 'static,
      dtype: Clone,
{
    handle: Edge<String>,
    index: Edge<i32>,
    flow_in: Edge<f32>,
    phantom_dtype: PhantomData<dtype>,
    op_name: Option<String>,
    id_: usize,
}

impl<dtype> TensorArrayRead<dtype>
where dtype: TensorType,
      dtype: 'static,
      dtype: Clone,
{
    pub fn value(self) -> Edge<dtype> {
        let rc = Rc::new(self);
        {
            Edge::<dtype>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<dtype> {
        let rc = Rc::new(self);
        {
            Edge::<dtype>::new(rc.clone(), 0)
        }
    }

    pub fn build(handle: Edge<String>, index: Edge<i32>, flow_in: Edge<f32>) -> Self {
        Self {
            handle,
            index,
            flow_in,
            phantom_dtype: PhantomData,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(handle: Edge<String>, index: Edge<i32>, flow_in: Edge<f32>) -> Edge<dtype> {
        Self {
            handle,
            index,
            flow_in,
            phantom_dtype: PhantomData,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<T> GraphOperation for Betainc<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE,
      T: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("Betainc_{}")?
        };
        let mut new_op = graph.new_operation("Betainc", &op_name)?;
        {
            new_op.add_edge(&self.a)?
        }
        {
            new_op.add_edge(&self.b)?
        }
        {
            new_op.add_edge(&self.x)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct Betainc<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    a: Edge<T>,
    b: Edge<T>,
    x: Edge<T>,
    op_name: Option<String>,
    id_: usize,
}

impl<T> Betainc<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE,
      T: 'static,
{
    pub fn z(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(a: Edge<T>, b: Edge<T>, x: Edge<T>) -> Self {
        Self {
            phantom_T: PhantomData,
            a,
            b,
            x,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(a: Edge<T>, b: Edge<T>, x: Edge<T>) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            a,
            b,
            x,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl GraphOperation for FakeQuantWithMinMaxVarsPerChannel {
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("FakeQuantWithMinMaxVarsPerChannel_{}")?
        };
        let mut new_op = graph.new_operation("FakeQuantWithMinMaxVarsPerChannel", &op_name)?;
        {
            new_op.add_edge(&self.inputs)?
        }
        {
            new_op.add_edge(&self.min)?
        }
        {
            new_op.add_edge(&self.max)?
        }
        {
            match self.num_bits {
                None => new_op.set_attr_value_proto("num_bits", &vec![24_u8, 8_u8,])?,
                Some(ref value) => (|attr: &i64| {new_op.set_attr_int("num_bits", *attr)})(&value)?,
            };
        }
        {
            match self.narrow_range {
                None => new_op.set_attr_value_proto("narrow_range", &vec![40_u8, 0_u8,])?,
                Some(ref value) => (|attr: &bool| {new_op.set_attr_bool("narrow_range", *attr)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct FakeQuantWithMinMaxVarsPerChannel {
    inputs: Edge<f32>,
    min: Edge<f32>,
    max: Edge<f32>,
    num_bits: Option<i64>,
    narrow_range: Option<bool>,
    op_name: Option<String>,
    id_: usize,
}

impl FakeQuantWithMinMaxVarsPerChannel {
    pub fn outputs(self) -> Edge<f32> {
        let rc = Rc::new(self);
        {
            Edge::<f32>::new(rc.clone(), 0)
        }
    }

    pub fn num_bits(&mut self, num_bits: i64) -> Self {
        self.num_bits = Some(num_bits);
        self.clone()
    }

    pub fn narrow_range(&mut self, narrow_range: bool) -> Self {
        self.narrow_range = Some(narrow_range);
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<f32> {
        let rc = Rc::new(self);
        {
            Edge::<f32>::new(rc.clone(), 0)
        }
    }

    pub fn build(inputs: Edge<f32>, min: Edge<f32>, max: Edge<f32>) -> Self {
        Self {
            inputs,
            min,
            max,
            num_bits: None,
            narrow_range: None,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(inputs: Edge<f32>, min: Edge<f32>, max: Edge<f32>) -> Edge<f32> {
        Self {
            inputs,
            min,
            max,
            num_bits: None,
            narrow_range: None,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<K, V> GraphOperation for XlaKeyValueSort<K, V>
where K: TensorType,
      K: Clone,
      V: TensorType,
      V: Clone,
      K: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      K: 'static,
      V: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("XlaKeyValueSort_{}")?
        };
        let mut new_op = graph.new_operation("XlaKeyValueSort", &op_name)?;
        {
            new_op.add_edge(&self.keys)?
        }
        {
            new_op.add_edge(&self.values)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct XlaKeyValueSort<K, V>
where K: TensorType,
      K: Clone,
      V: TensorType,
      V: Clone,
      K: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      K: 'static,
      V: 'static,
{
    phantom_K: PhantomData<K>,
    keys: Edge<K>,
    phantom_V: PhantomData<V>,
    values: Edge<V>,
    op_name: Option<String>,
    id_: usize,
}

impl<K, V> XlaKeyValueSort<K, V>
where K: TensorType,
      K: Clone,
      V: TensorType,
      V: Clone,
      K: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      K: 'static,
      V: 'static,
{
    pub fn sorted_keys(self) -> Edge<K> {
        let rc = Rc::new(self);
        {
            Edge::<K>::new(rc.clone(), 0)
        }
    }

    pub fn sorted_values(self) -> Edge<V> {
        let rc = Rc::new(self);
        {
            Edge::<V>::new(rc.clone(), 1)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> (Edge<K>, Edge<V>) {
        let rc = Rc::new(self);
        (
        {
            Edge::<K>::new(rc.clone(), 0)
        },
        {
            Edge::<V>::new(rc.clone(), 1)
        },
        )
    }

    pub fn build(keys: Edge<K>, values: Edge<V>) -> Self {
        Self {
            phantom_K: PhantomData,
            keys,
            phantom_V: PhantomData,
            values,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(keys: Edge<K>, values: Edge<V>) -> (Edge<K>, Edge<V>) {
        Self {
            phantom_K: PhantomData,
            keys,
            phantom_V: PhantomData,
            values,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl GraphOperation for LoadTPUEmbeddingFTRLParameters {
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("LoadTPUEmbeddingFTRLParameters_{}")?
        };
        let mut new_op = graph.new_operation("LoadTPUEmbeddingFTRLParameters", &op_name)?;
        {
            new_op.add_edge(&self.parameters)?
        }
        {
            new_op.add_edge(&self.accumulators)?
        }
        {
            new_op.add_edge(&self.linears)?
        }
        {
            match self.table_id {
                None => new_op.set_attr_value_proto("table_id", &vec![24_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 1_u8,])?,
                Some(ref value) => (|attr: &i64| {new_op.set_attr_int("table_id", *attr)})(&value)?,
            };
        }
        {
            match self.table_name {
                None => new_op.set_attr_value_proto("table_name", &vec![18_u8, 0_u8,])?,
                Some(ref value) => (|attr| {new_op.set_attr_string("table_name", attr)})(&value)?,
            };
        }
        {
            (|attr: &i64| {new_op.set_attr_int("num_shards", *attr)})(&self.num_shards)?
        }
        {
            (|attr: &i64| {new_op.set_attr_int("shard_id", *attr)})(&self.shard_id)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct LoadTPUEmbeddingFTRLParameters {
    parameters: Edge<f32>,
    accumulators: Edge<f32>,
    linears: Edge<f32>,
    table_id: Option<i64>,
    table_name: Option<String>,
    num_shards: i64,
    shard_id: i64,
    op_name: Option<String>,
    id_: usize,
}

impl LoadTPUEmbeddingFTRLParameters {
    pub fn table_id(&mut self, table_id: i64) -> Self {
        self.table_id = Some(table_id);
        self.clone()
    }

    pub fn table_name(&mut self, table_name: &str) -> Self {
        self.table_name = Some(table_name.to_string());
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> () {
        let rc = Rc::new(self);
        (
        )
    }

    pub fn build(parameters: Edge<f32>, accumulators: Edge<f32>, linears: Edge<f32>, num_shards: i64, shard_id: i64) -> Self {
        Self {
            parameters,
            accumulators,
            linears,
            table_id: None,
            table_name: None,
            num_shards: num_shards,
            shard_id: shard_id,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(parameters: Edge<f32>, accumulators: Edge<f32>, linears: Edge<f32>, num_shards: i64, shard_id: i64) -> () {
        Self {
            parameters,
            accumulators,
            linears,
            table_id: None,
            table_name: None,
            num_shards: num_shards,
            shard_id: shard_id,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<T, Tindices> GraphOperation for XlaDynamicUpdateSlice<T, Tindices>
where T: TensorType,
      T: Clone,
      Tindices: TensorType,
      Tindices: Clone,
      T: 'static,
      Tindices: con_or_DT_INT32_or_DT_INT64,
      Tindices: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("XlaDynamicUpdateSlice_{}")?
        };
        let mut new_op = graph.new_operation("XlaDynamicUpdateSlice", &op_name)?;
        {
            new_op.add_edge(&self.input)?
        }
        {
            new_op.add_edge(&self.update)?
        }
        {
            new_op.add_edge(&self.indices)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct XlaDynamicUpdateSlice<T, Tindices>
where T: TensorType,
      T: Clone,
      Tindices: TensorType,
      Tindices: Clone,
      T: 'static,
      Tindices: con_or_DT_INT32_or_DT_INT64,
      Tindices: 'static,
{
    phantom_T: PhantomData<T>,
    input: Edge<T>,
    update: Edge<T>,
    phantom_Tindices: PhantomData<Tindices>,
    indices: Edge<Tindices>,
    op_name: Option<String>,
    id_: usize,
}

impl<T, Tindices> XlaDynamicUpdateSlice<T, Tindices>
where T: TensorType,
      T: Clone,
      Tindices: TensorType,
      Tindices: Clone,
      T: 'static,
      Tindices: con_or_DT_INT32_or_DT_INT64,
      Tindices: 'static,
{
    pub fn output(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(input: Edge<T>, update: Edge<T>, indices: Edge<Tindices>) -> Self {
        Self {
            phantom_T: PhantomData,
            input,
            update,
            phantom_Tindices: PhantomData,
            indices,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(input: Edge<T>, update: Edge<T>, indices: Edge<Tindices>) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            input,
            update,
            phantom_Tindices: PhantomData,
            indices,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<dtype> GraphOperation for Empty<dtype>
where dtype: TensorType,
      dtype: 'static,
      dtype: Clone,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("Empty_{}")?
        };
        let mut new_op = graph.new_operation("Empty", &op_name)?;
        {
            new_op.add_edge(&self.shape)?
        }
        {
            match self.init {
                None => new_op.set_attr_value_proto("init", &vec![40_u8, 0_u8,])?,
                Some(ref value) => (|attr: &bool| {new_op.set_attr_bool("init", *attr)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct Empty<dtype>
where dtype: TensorType,
      dtype: 'static,
      dtype: Clone,
{
    shape: Edge<i32>,
    phantom_dtype: PhantomData<dtype>,
    init: Option<bool>,
    op_name: Option<String>,
    id_: usize,
}

impl<dtype> Empty<dtype>
where dtype: TensorType,
      dtype: 'static,
      dtype: Clone,
{
    pub fn output(self) -> Edge<dtype> {
        let rc = Rc::new(self);
        {
            Edge::<dtype>::new(rc.clone(), 0)
        }
    }

    pub fn init(&mut self, init: bool) -> Self {
        self.init = Some(init);
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<dtype> {
        let rc = Rc::new(self);
        {
            Edge::<dtype>::new(rc.clone(), 0)
        }
    }

    pub fn build(shape: Edge<i32>) -> Self {
        Self {
            shape,
            phantom_dtype: PhantomData,
            init: None,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(shape: Edge<i32>) -> Edge<dtype> {
        Self {
            shape,
            phantom_dtype: PhantomData,
            init: None,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl GraphOperation for RetrieveTPUEmbeddingMDLAdagradLightParameters {
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("RetrieveTPUEmbeddingMDLAdagradLightParameters_{}")?
        };
        let mut new_op = graph.new_operation("RetrieveTPUEmbeddingMDLAdagradLightParameters", &op_name)?;
        {
            match self.table_id {
                None => new_op.set_attr_value_proto("table_id", &vec![24_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 1_u8,])?,
                Some(ref value) => (|attr: &i64| {new_op.set_attr_int("table_id", *attr)})(&value)?,
            };
        }
        {
            match self.table_name {
                None => new_op.set_attr_value_proto("table_name", &vec![18_u8, 0_u8,])?,
                Some(ref value) => (|attr| {new_op.set_attr_string("table_name", attr)})(&value)?,
            };
        }
        {
            (|attr: &i64| {new_op.set_attr_int("num_shards", *attr)})(&self.num_shards)?
        }
        {
            (|attr: &i64| {new_op.set_attr_int("shard_id", *attr)})(&self.shard_id)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct RetrieveTPUEmbeddingMDLAdagradLightParameters {
    table_id: Option<i64>,
    table_name: Option<String>,
    num_shards: i64,
    shard_id: i64,
    op_name: Option<String>,
    id_: usize,
}

impl RetrieveTPUEmbeddingMDLAdagradLightParameters {
    pub fn parameters(self) -> Edge<f32> {
        let rc = Rc::new(self);
        {
            Edge::<f32>::new(rc.clone(), 0)
        }
    }

    pub fn accumulators(self) -> Edge<f32> {
        let rc = Rc::new(self);
        {
            Edge::<f32>::new(rc.clone(), 1)
        }
    }

    pub fn weights(self) -> Edge<f32> {
        let rc = Rc::new(self);
        {
            Edge::<f32>::new(rc.clone(), 2)
        }
    }

    pub fn benefits(self) -> Edge<f32> {
        let rc = Rc::new(self);
        {
            Edge::<f32>::new(rc.clone(), 3)
        }
    }

    pub fn table_id(&mut self, table_id: i64) -> Self {
        self.table_id = Some(table_id);
        self.clone()
    }

    pub fn table_name(&mut self, table_name: &str) -> Self {
        self.table_name = Some(table_name.to_string());
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> (Edge<f32>, Edge<f32>, Edge<f32>, Edge<f32>) {
        let rc = Rc::new(self);
        (
        {
            Edge::<f32>::new(rc.clone(), 0)
        },
        {
            Edge::<f32>::new(rc.clone(), 1)
        },
        {
            Edge::<f32>::new(rc.clone(), 2)
        },
        {
            Edge::<f32>::new(rc.clone(), 3)
        },
        )
    }

    pub fn build(num_shards: i64, shard_id: i64) -> Self {
        Self {
            table_id: None,
            table_name: None,
            num_shards: num_shards,
            shard_id: shard_id,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(num_shards: i64, shard_id: i64) -> (Edge<f32>, Edge<f32>, Edge<f32>, Edge<f32>) {
        Self {
            table_id: None,
            table_name: None,
            num_shards: num_shards,
            shard_id: shard_id,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<T> GraphOperation for FractionalAvgPool<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_INT64,
      T: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("FractionalAvgPool_{}")?
        };
        let mut new_op = graph.new_operation("FractionalAvgPool", &op_name)?;
        {
            new_op.add_edge(&self.value)?
        }
        {
            (|attrs| {new_op.set_attr_float_list("pooling_ratio", attrs)})(&self.pooling_ratio)?
        }
        {
            match self.pseudo_random {
                None => new_op.set_attr_value_proto("pseudo_random", &vec![40_u8, 0_u8,])?,
                Some(ref value) => (|attr: &bool| {new_op.set_attr_bool("pseudo_random", *attr)})(&value)?,
            };
        }
        {
            match self.overlapping {
                None => new_op.set_attr_value_proto("overlapping", &vec![40_u8, 0_u8,])?,
                Some(ref value) => (|attr: &bool| {new_op.set_attr_bool("overlapping", *attr)})(&value)?,
            };
        }
        {
            match self.deterministic {
                None => new_op.set_attr_value_proto("deterministic", &vec![40_u8, 0_u8,])?,
                Some(ref value) => (|attr: &bool| {new_op.set_attr_bool("deterministic", *attr)})(&value)?,
            };
        }
        {
            match self.seed {
                None => new_op.set_attr_value_proto("seed", &vec![24_u8, 0_u8,])?,
                Some(ref value) => (|attr: &i64| {new_op.set_attr_int("seed", *attr)})(&value)?,
            };
        }
        {
            match self.seed2 {
                None => new_op.set_attr_value_proto("seed2", &vec![24_u8, 0_u8,])?,
                Some(ref value) => (|attr: &i64| {new_op.set_attr_int("seed2", *attr)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct FractionalAvgPool<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_INT64,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    value: Edge<T>,
    pooling_ratio: Vec<f32>,
    pseudo_random: Option<bool>,
    overlapping: Option<bool>,
    deterministic: Option<bool>,
    seed: Option<i64>,
    seed2: Option<i64>,
    op_name: Option<String>,
    id_: usize,
}

impl<T> FractionalAvgPool<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_INT64,
      T: 'static,
{
    pub fn output(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn row_pooling_sequence(self) -> Edge<i64> {
        let rc = Rc::new(self);
        {
            Edge::<i64>::new(rc.clone(), 1)
        }
    }

    pub fn col_pooling_sequence(self) -> Edge<i64> {
        let rc = Rc::new(self);
        {
            Edge::<i64>::new(rc.clone(), 2)
        }
    }

    pub fn pseudo_random(&mut self, pseudo_random: bool) -> Self {
        self.pseudo_random = Some(pseudo_random);
        self.clone()
    }

    pub fn overlapping(&mut self, overlapping: bool) -> Self {
        self.overlapping = Some(overlapping);
        self.clone()
    }

    pub fn deterministic(&mut self, deterministic: bool) -> Self {
        self.deterministic = Some(deterministic);
        self.clone()
    }

    pub fn seed(&mut self, seed: i64) -> Self {
        self.seed = Some(seed);
        self.clone()
    }

    pub fn seed2(&mut self, seed2: i64) -> Self {
        self.seed2 = Some(seed2);
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> (Edge<T>, Edge<i64>, Edge<i64>) {
        let rc = Rc::new(self);
        (
        {
            Edge::<T>::new(rc.clone(), 0)
        },
        {
            Edge::<i64>::new(rc.clone(), 1)
        },
        {
            Edge::<i64>::new(rc.clone(), 2)
        },
        )
    }

    pub fn build(value: Edge<T>, pooling_ratio: &[f32]) -> Self {
        Self {
            phantom_T: PhantomData,
            value,
            pooling_ratio: pooling_ratio.to_vec(),
            pseudo_random: None,
            overlapping: None,
            deterministic: None,
            seed: None,
            seed2: None,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(value: Edge<T>, pooling_ratio: &[f32]) -> (Edge<T>, Edge<i64>, Edge<i64>) {
        Self {
            phantom_T: PhantomData,
            value,
            pooling_ratio: pooling_ratio.to_vec(),
            pseudo_random: None,
            overlapping: None,
            deterministic: None,
            seed: None,
            seed2: None,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<T> GraphOperation for ExtractVolumePatches<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("ExtractVolumePatches_{}")?
        };
        let mut new_op = graph.new_operation("ExtractVolumePatches", &op_name)?;
        {
            new_op.add_edge(&self.input)?
        }
        {
            (|attrs| {new_op.set_attr_int_list("ksizes", attrs)})(&self.ksizes)?
        }
        {
            (|attrs| {new_op.set_attr_int_list("strides", attrs)})(&self.strides)?
        }
        {
            (|attr| {new_op.set_attr_string("padding", attr)})(&self.padding)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct ExtractVolumePatches<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    input: Edge<T>,
    ksizes: Vec<i64>,
    strides: Vec<i64>,
    padding: String,
    op_name: Option<String>,
    id_: usize,
}

impl<T> ExtractVolumePatches<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
{
    pub fn patches(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(input: Edge<T>, ksizes: &[i64], strides: &[i64], padding: &str) -> Self {
        Self {
            phantom_T: PhantomData,
            input,
            ksizes: ksizes.to_vec(),
            strides: strides.to_vec(),
            padding: padding.to_string(),
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(input: Edge<T>, ksizes: &[i64], strides: &[i64], padding: &str) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            input,
            ksizes: ksizes.to_vec(),
            strides: strides.to_vec(),
            padding: padding.to_string(),
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<T> GraphOperation for GetSessionHandle<T>
where T: TensorType,
      T: Clone,
      T: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("GetSessionHandle_{}")?
        };
        let mut new_op = graph.new_operation("GetSessionHandle", &op_name)?;
        {
            new_op.add_edge(&self.value)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct GetSessionHandle<T>
where T: TensorType,
      T: Clone,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    value: Edge<T>,
    op_name: Option<String>,
    id_: usize,
}

impl<T> GetSessionHandle<T>
where T: TensorType,
      T: Clone,
      T: 'static,
{
    pub fn handle(self) -> Edge<String> {
        let rc = Rc::new(self);
        {
            Edge::<String>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<String> {
        let rc = Rc::new(self);
        {
            Edge::<String>::new(rc.clone(), 0)
        }
    }

    pub fn build(value: Edge<T>) -> Self {
        Self {
            phantom_T: PhantomData,
            value,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(value: Edge<T>) -> Edge<String> {
        Self {
            phantom_T: PhantomData,
            value,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<Tkeys, Tvalues> GraphOperation for LookupTableExport<Tkeys, Tvalues>
where Tkeys: TensorType,
      Tvalues: TensorType,
      Tkeys: 'static,
      Tkeys: Clone,
      Tvalues: 'static,
      Tvalues: Clone,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("LookupTableExport_{}")?
        };
        let mut new_op = graph.new_operation("LookupTableExport", &op_name)?;
        {
            new_op.add_edge(&self.table_handle)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct LookupTableExport<Tkeys, Tvalues>
where Tkeys: TensorType,
      Tvalues: TensorType,
      Tkeys: 'static,
      Tkeys: Clone,
      Tvalues: 'static,
      Tvalues: Clone,
{
    table_handle: Edge<String>,
    phantom_Tkeys: PhantomData<Tkeys>,
    phantom_Tvalues: PhantomData<Tvalues>,
    op_name: Option<String>,
    id_: usize,
}

impl<Tkeys, Tvalues> LookupTableExport<Tkeys, Tvalues>
where Tkeys: TensorType,
      Tvalues: TensorType,
      Tkeys: 'static,
      Tkeys: Clone,
      Tvalues: 'static,
      Tvalues: Clone,
{
    pub fn keys(self) -> Edge<Tkeys> {
        let rc = Rc::new(self);
        {
            Edge::<Tkeys>::new(rc.clone(), 0)
        }
    }

    pub fn values(self) -> Edge<Tvalues> {
        let rc = Rc::new(self);
        {
            Edge::<Tvalues>::new(rc.clone(), 1)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> (Edge<Tkeys>, Edge<Tvalues>) {
        let rc = Rc::new(self);
        (
        {
            Edge::<Tkeys>::new(rc.clone(), 0)
        },
        {
            Edge::<Tvalues>::new(rc.clone(), 1)
        },
        )
    }

    pub fn build(table_handle: Edge<String>) -> Self {
        Self {
            table_handle,
            phantom_Tkeys: PhantomData,
            phantom_Tvalues: PhantomData,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(table_handle: Edge<String>) -> (Edge<Tkeys>, Edge<Tvalues>) {
        Self {
            table_handle,
            phantom_Tkeys: PhantomData,
            phantom_Tvalues: PhantomData,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<T> GraphOperation for BatchMatrixInverse<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE,
      T: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("BatchMatrixInverse_{}")?
        };
        let mut new_op = graph.new_operation("BatchMatrixInverse", &op_name)?;
        {
            new_op.add_edge(&self.input)?
        }
        {
            match self.adjoint {
                None => new_op.set_attr_value_proto("adjoint", &vec![40_u8, 0_u8,])?,
                Some(ref value) => (|attr: &bool| {new_op.set_attr_bool("adjoint", *attr)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct BatchMatrixInverse<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    input: Edge<T>,
    adjoint: Option<bool>,
    op_name: Option<String>,
    id_: usize,
}

impl<T> BatchMatrixInverse<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE,
      T: 'static,
{
    pub fn output(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn adjoint(&mut self, adjoint: bool) -> Self {
        self.adjoint = Some(adjoint);
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(input: Edge<T>) -> Self {
        Self {
            phantom_T: PhantomData,
            input,
            adjoint: None,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(input: Edge<T>) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            input,
            adjoint: None,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<T> GraphOperation for TensorArraySplit<T>
where T: TensorType,
      T: Clone,
      T: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("TensorArraySplit_{}")?
        };
        let mut new_op = graph.new_operation("TensorArraySplit", &op_name)?;
        {
            new_op.add_edge(&self.handle)?
        }
        {
            new_op.add_edge(&self.value)?
        }
        {
            new_op.add_edge(&self.lengths)?
        }
        {
            new_op.add_edge(&self.flow_in)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct TensorArraySplit<T>
where T: TensorType,
      T: Clone,
      T: 'static,
{
    handle: Edge<String>,
    phantom_T: PhantomData<T>,
    value: Edge<T>,
    lengths: Edge<i64>,
    flow_in: Edge<f32>,
    op_name: Option<String>,
    id_: usize,
}

impl<T> TensorArraySplit<T>
where T: TensorType,
      T: Clone,
      T: 'static,
{
    pub fn flow_out(self) -> Edge<f32> {
        let rc = Rc::new(self);
        {
            Edge::<f32>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<f32> {
        let rc = Rc::new(self);
        {
            Edge::<f32>::new(rc.clone(), 0)
        }
    }

    pub fn build(handle: Edge<String>, value: Edge<T>, lengths: Edge<i64>, flow_in: Edge<f32>) -> Self {
        Self {
            handle,
            phantom_T: PhantomData,
            value,
            lengths,
            flow_in,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(handle: Edge<String>, value: Edge<T>, lengths: Edge<i64>, flow_in: Edge<f32>) -> Edge<f32> {
        Self {
            handle,
            phantom_T: PhantomData,
            value,
            lengths,
            flow_in,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl GraphOperation for GenerateVocabRemapping {
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("GenerateVocabRemapping_{}")?
        };
        let mut new_op = graph.new_operation("GenerateVocabRemapping", &op_name)?;
        {
            new_op.add_edge(&self.new_vocab_file)?
        }
        {
            new_op.add_edge(&self.old_vocab_file)?
        }
        {
            (|attr: &i64| {new_op.set_attr_int("new_vocab_offset", *attr)})(&self.new_vocab_offset)?
        }
        {
            (|attr: &i64| {new_op.set_attr_int("num_new_vocab", *attr)})(&self.num_new_vocab)?
        }
        {
            match self.old_vocab_size {
                None => new_op.set_attr_value_proto("old_vocab_size", &vec![24_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 1_u8,])?,
                Some(ref value) => (|attr: &i64| {new_op.set_attr_int("old_vocab_size", *attr)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct GenerateVocabRemapping {
    new_vocab_file: Edge<String>,
    old_vocab_file: Edge<String>,
    new_vocab_offset: i64,
    num_new_vocab: i64,
    old_vocab_size: Option<i64>,
    op_name: Option<String>,
    id_: usize,
}

impl GenerateVocabRemapping {
    pub fn remapping(self) -> Edge<i64> {
        let rc = Rc::new(self);
        {
            Edge::<i64>::new(rc.clone(), 0)
        }
    }

    pub fn num_present(self) -> Edge<i32> {
        let rc = Rc::new(self);
        {
            Edge::<i32>::new(rc.clone(), 1)
        }
    }

    pub fn old_vocab_size(&mut self, old_vocab_size: i64) -> Self {
        self.old_vocab_size = Some(old_vocab_size);
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> (Edge<i64>, Edge<i32>) {
        let rc = Rc::new(self);
        (
        {
            Edge::<i64>::new(rc.clone(), 0)
        },
        {
            Edge::<i32>::new(rc.clone(), 1)
        },
        )
    }

    pub fn build(new_vocab_file: Edge<String>, old_vocab_file: Edge<String>, new_vocab_offset: i64, num_new_vocab: i64) -> Self {
        Self {
            new_vocab_file,
            old_vocab_file,
            new_vocab_offset: new_vocab_offset,
            num_new_vocab: num_new_vocab,
            old_vocab_size: None,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(new_vocab_file: Edge<String>, old_vocab_file: Edge<String>, new_vocab_offset: i64, num_new_vocab: i64) -> (Edge<i64>, Edge<i32>) {
        Self {
            new_vocab_file,
            old_vocab_file,
            new_vocab_offset: new_vocab_offset,
            num_new_vocab: num_new_vocab,
            old_vocab_size: None,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl GraphOperation for _SetGlobalTPUArray {
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("_SetGlobalTPUArray_{}")?
        };
        let mut new_op = graph.new_operation("_SetGlobalTPUArray", &op_name)?;
        {
            new_op.add_edge(&self.topology)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct _SetGlobalTPUArray {
    topology: Edge<String>,
    op_name: Option<String>,
    id_: usize,
}

impl _SetGlobalTPUArray {
    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> () {
        let rc = Rc::new(self);
        (
        )
    }

    pub fn build(topology: Edge<String>) -> Self {
        Self {
            topology,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(topology: Edge<String>) -> () {
        Self {
            topology,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<dtype> GraphOperation for AccumulatorTakeGradient<dtype>
where dtype: TensorType,
      dtype: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      dtype: 'static,
      dtype: Clone,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("AccumulatorTakeGradient_{}")?
        };
        let mut new_op = graph.new_operation("AccumulatorTakeGradient", &op_name)?;
        {
            new_op.add_edge(&self.handle)?
        }
        {
            new_op.add_edge(&self.num_required)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct AccumulatorTakeGradient<dtype>
where dtype: TensorType,
      dtype: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      dtype: 'static,
      dtype: Clone,
{
    handle: Edge<String>,
    num_required: Edge<i32>,
    phantom_dtype: PhantomData<dtype>,
    op_name: Option<String>,
    id_: usize,
}

impl<dtype> AccumulatorTakeGradient<dtype>
where dtype: TensorType,
      dtype: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      dtype: 'static,
      dtype: Clone,
{
    pub fn average(self) -> Edge<dtype> {
        let rc = Rc::new(self);
        {
            Edge::<dtype>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<dtype> {
        let rc = Rc::new(self);
        {
            Edge::<dtype>::new(rc.clone(), 0)
        }
    }

    pub fn build(handle: Edge<String>, num_required: Edge<i32>) -> Self {
        Self {
            handle,
            num_required,
            phantom_dtype: PhantomData,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(handle: Edge<String>, num_required: Edge<i32>) -> Edge<dtype> {
        Self {
            handle,
            num_required,
            phantom_dtype: PhantomData,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<T, out_type> GraphOperation for SerializeSparse<T, out_type>
where T: TensorType,
      T: Clone,
      out_type: TensorType,
      T: 'static,
      out_type: con_or_DT_STRING_or_DT_VARIANT,
      out_type: 'static,
      out_type: Clone,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("SerializeSparse_{}")?
        };
        let mut new_op = graph.new_operation("SerializeSparse", &op_name)?;
        {
            new_op.add_edge(&self.sparse_indices)?
        }
        {
            new_op.add_edge(&self.sparse_values)?
        }
        {
            new_op.add_edge(&self.sparse_shape)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct SerializeSparse<T, out_type>
where T: TensorType,
      T: Clone,
      out_type: TensorType,
      T: 'static,
      out_type: con_or_DT_STRING_or_DT_VARIANT,
      out_type: 'static,
      out_type: Clone,
{
    sparse_indices: Edge<i64>,
    phantom_T: PhantomData<T>,
    sparse_values: Edge<T>,
    sparse_shape: Edge<i64>,
    phantom_out_type: PhantomData<out_type>,
    op_name: Option<String>,
    id_: usize,
}

impl<T, out_type> SerializeSparse<T, out_type>
where T: TensorType,
      T: Clone,
      out_type: TensorType,
      T: 'static,
      out_type: con_or_DT_STRING_or_DT_VARIANT,
      out_type: 'static,
      out_type: Clone,
{
    pub fn serialized_sparse(self) -> Edge<out_type> {
        let rc = Rc::new(self);
        {
            Edge::<out_type>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<out_type> {
        let rc = Rc::new(self);
        {
            Edge::<out_type>::new(rc.clone(), 0)
        }
    }

    pub fn build(sparse_indices: Edge<i64>, sparse_values: Edge<T>, sparse_shape: Edge<i64>) -> Self {
        Self {
            sparse_indices,
            phantom_T: PhantomData,
            sparse_values,
            sparse_shape,
            phantom_out_type: PhantomData,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(sparse_indices: Edge<i64>, sparse_values: Edge<T>, sparse_shape: Edge<i64>) -> Edge<out_type> {
        Self {
            sparse_indices,
            phantom_T: PhantomData,
            sparse_values,
            sparse_shape,
            phantom_out_type: PhantomData,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl GraphOperation for LearnedUnigramCandidateSampler {
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("LearnedUnigramCandidateSampler_{}")?
        };
        let mut new_op = graph.new_operation("LearnedUnigramCandidateSampler", &op_name)?;
        {
            new_op.add_edge(&self.true_classes)?
        }
        {
            (|attr: &i64| {new_op.set_attr_int("num_true", *attr)})(&self.num_true)?
        }
        {
            (|attr: &i64| {new_op.set_attr_int("num_sampled", *attr)})(&self.num_sampled)?
        }
        {
            (|attr: &bool| {new_op.set_attr_bool("unique", *attr)})(&self.unique)?
        }
        {
            (|attr: &i64| {new_op.set_attr_int("range_max", *attr)})(&self.range_max)?
        }
        {
            match self.seed {
                None => new_op.set_attr_value_proto("seed", &vec![24_u8, 0_u8,])?,
                Some(ref value) => (|attr: &i64| {new_op.set_attr_int("seed", *attr)})(&value)?,
            };
        }
        {
            match self.seed2 {
                None => new_op.set_attr_value_proto("seed2", &vec![24_u8, 0_u8,])?,
                Some(ref value) => (|attr: &i64| {new_op.set_attr_int("seed2", *attr)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct LearnedUnigramCandidateSampler {
    true_classes: Edge<i64>,
    num_true: i64,
    num_sampled: i64,
    unique: bool,
    range_max: i64,
    seed: Option<i64>,
    seed2: Option<i64>,
    op_name: Option<String>,
    id_: usize,
}

impl LearnedUnigramCandidateSampler {
    pub fn sampled_candidates(self) -> Edge<i64> {
        let rc = Rc::new(self);
        {
            Edge::<i64>::new(rc.clone(), 0)
        }
    }

    pub fn true_expected_count(self) -> Edge<f32> {
        let rc = Rc::new(self);
        {
            Edge::<f32>::new(rc.clone(), 1)
        }
    }

    pub fn sampled_expected_count(self) -> Edge<f32> {
        let rc = Rc::new(self);
        {
            Edge::<f32>::new(rc.clone(), 2)
        }
    }

    pub fn seed(&mut self, seed: i64) -> Self {
        self.seed = Some(seed);
        self.clone()
    }

    pub fn seed2(&mut self, seed2: i64) -> Self {
        self.seed2 = Some(seed2);
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> (Edge<i64>, Edge<f32>, Edge<f32>) {
        let rc = Rc::new(self);
        (
        {
            Edge::<i64>::new(rc.clone(), 0)
        },
        {
            Edge::<f32>::new(rc.clone(), 1)
        },
        {
            Edge::<f32>::new(rc.clone(), 2)
        },
        )
    }

    pub fn build(true_classes: Edge<i64>, num_true: i64, num_sampled: i64, unique: bool, range_max: i64) -> Self {
        Self {
            true_classes,
            num_true: num_true,
            num_sampled: num_sampled,
            unique: unique,
            range_max: range_max,
            seed: None,
            seed2: None,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(true_classes: Edge<i64>, num_true: i64, num_sampled: i64, unique: bool, range_max: i64) -> (Edge<i64>, Edge<f32>, Edge<f32>) {
        Self {
            true_classes,
            num_true: num_true,
            num_sampled: num_sampled,
            unique: unique,
            range_max: range_max,
            seed: None,
            seed2: None,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

pub trait con_or_DT_FLOAT_or_DT_HALF {
}

impl con_or_DT_FLOAT_or_DT_HALF for f32 {
}

impl<T> GraphOperation for DrawBoundingBoxes<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_HALF,
      T: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("DrawBoundingBoxes_{}")?
        };
        let mut new_op = graph.new_operation("DrawBoundingBoxes", &op_name)?;
        {
            new_op.add_edge(&self.images)?
        }
        {
            new_op.add_edge(&self.boxes)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct DrawBoundingBoxes<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_HALF,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    images: Edge<T>,
    boxes: Edge<f32>,
    op_name: Option<String>,
    id_: usize,
}

impl<T> DrawBoundingBoxes<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_HALF,
      T: 'static,
{
    pub fn output(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(images: Edge<T>, boxes: Edge<f32>) -> Self {
        Self {
            phantom_T: PhantomData,
            images,
            boxes,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(images: Edge<T>, boxes: Edge<f32>) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            images,
            boxes,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<T, Tindices> GraphOperation for XlaReduceWindow<T, Tindices>
where T: TensorType,
      T: Clone,
      Tindices: TensorType,
      Tindices: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
      Tindices: con_or_DT_INT32_or_DT_INT64,
      Tindices: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("XlaReduceWindow_{}")?
        };
        let mut new_op = graph.new_operation("XlaReduceWindow", &op_name)?;
        {
            new_op.add_edge(&self.input)?
        }
        {
            new_op.add_edge(&self.init_value)?
        }
        {
            new_op.add_edge(&self.window_dimensions)?
        }
        {
            new_op.add_edge(&self.window_strides)?
        }
        {
            new_op.add_edge(&self.base_dilations)?
        }
        {
            new_op.add_edge(&self.window_dilations)?
        }
        {
            new_op.add_edge(&self.padding)?
        }
        {
            (|attr| {new_op.set_attr_func_name("computation", attr)})(&self.computation)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct XlaReduceWindow<T, Tindices>
where T: TensorType,
      T: Clone,
      Tindices: TensorType,
      Tindices: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
      Tindices: con_or_DT_INT32_or_DT_INT64,
      Tindices: 'static,
{
    phantom_T: PhantomData<T>,
    input: Edge<T>,
    init_value: Edge<T>,
    phantom_Tindices: PhantomData<Tindices>,
    window_dimensions: Edge<Tindices>,
    window_strides: Edge<Tindices>,
    base_dilations: Edge<Tindices>,
    window_dilations: Edge<Tindices>,
    padding: Edge<Tindices>,
    computation: String,
    op_name: Option<String>,
    id_: usize,
}

impl<T, Tindices> XlaReduceWindow<T, Tindices>
where T: TensorType,
      T: Clone,
      Tindices: TensorType,
      Tindices: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
      Tindices: con_or_DT_INT32_or_DT_INT64,
      Tindices: 'static,
{
    pub fn output(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(input: Edge<T>, init_value: Edge<T>, window_dimensions: Edge<Tindices>, window_strides: Edge<Tindices>, base_dilations: Edge<Tindices>, window_dilations: Edge<Tindices>, padding: Edge<Tindices>, computation: &str) -> Self {
        Self {
            phantom_T: PhantomData,
            input,
            init_value,
            phantom_Tindices: PhantomData,
            window_dimensions,
            window_strides,
            base_dilations,
            window_dilations,
            padding,
            computation: computation.to_string(),
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(input: Edge<T>, init_value: Edge<T>, window_dimensions: Edge<Tindices>, window_strides: Edge<Tindices>, base_dilations: Edge<Tindices>, window_dilations: Edge<Tindices>, padding: Edge<Tindices>, computation: &str) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            input,
            init_value,
            phantom_Tindices: PhantomData,
            window_dimensions,
            window_strides,
            base_dilations,
            window_dilations,
            padding,
            computation: computation.to_string(),
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<T, Tindices> GraphOperation for XlaSelectAndScatter<T, Tindices>
where T: TensorType,
      T: Clone,
      Tindices: TensorType,
      Tindices: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
      Tindices: con_or_DT_INT32_or_DT_INT64,
      Tindices: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("XlaSelectAndScatter_{}")?
        };
        let mut new_op = graph.new_operation("XlaSelectAndScatter", &op_name)?;
        {
            new_op.add_edge(&self.operand)?
        }
        {
            new_op.add_edge(&self.window_dimensions)?
        }
        {
            new_op.add_edge(&self.window_strides)?
        }
        {
            new_op.add_edge(&self.padding)?
        }
        {
            new_op.add_edge(&self.source)?
        }
        {
            new_op.add_edge(&self.init_value)?
        }
        {
            (|attr| {new_op.set_attr_func_name("select", attr)})(&self.select)?
        }
        {
            (|attr| {new_op.set_attr_func_name("scatter", attr)})(&self.scatter)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct XlaSelectAndScatter<T, Tindices>
where T: TensorType,
      T: Clone,
      Tindices: TensorType,
      Tindices: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
      Tindices: con_or_DT_INT32_or_DT_INT64,
      Tindices: 'static,
{
    phantom_T: PhantomData<T>,
    operand: Edge<T>,
    phantom_Tindices: PhantomData<Tindices>,
    window_dimensions: Edge<Tindices>,
    window_strides: Edge<Tindices>,
    padding: Edge<Tindices>,
    source: Edge<T>,
    init_value: Edge<T>,
    select: String,
    scatter: String,
    op_name: Option<String>,
    id_: usize,
}

impl<T, Tindices> XlaSelectAndScatter<T, Tindices>
where T: TensorType,
      T: Clone,
      Tindices: TensorType,
      Tindices: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
      Tindices: con_or_DT_INT32_or_DT_INT64,
      Tindices: 'static,
{
    pub fn output(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(operand: Edge<T>, window_dimensions: Edge<Tindices>, window_strides: Edge<Tindices>, padding: Edge<Tindices>, source: Edge<T>, init_value: Edge<T>, select: &str, scatter: &str) -> Self {
        Self {
            phantom_T: PhantomData,
            operand,
            phantom_Tindices: PhantomData,
            window_dimensions,
            window_strides,
            padding,
            source,
            init_value,
            select: select.to_string(),
            scatter: scatter.to_string(),
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(operand: Edge<T>, window_dimensions: Edge<Tindices>, window_strides: Edge<Tindices>, padding: Edge<Tindices>, source: Edge<T>, init_value: Edge<T>, select: &str, scatter: &str) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            operand,
            phantom_Tindices: PhantomData,
            window_dimensions,
            window_strides,
            padding,
            source,
            init_value,
            select: select.to_string(),
            scatter: scatter.to_string(),
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl GraphOperation for RetrieveTPUEmbeddingAdadeltaParametersGradAccumDebug {
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("RetrieveTPUEmbeddingAdadeltaParametersGradAccumDebug_{}")?
        };
        let mut new_op = graph.new_operation("RetrieveTPUEmbeddingAdadeltaParametersGradAccumDebug", &op_name)?;
        {
            match self.table_id {
                None => new_op.set_attr_value_proto("table_id", &vec![24_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 1_u8,])?,
                Some(ref value) => (|attr: &i64| {new_op.set_attr_int("table_id", *attr)})(&value)?,
            };
        }
        {
            match self.table_name {
                None => new_op.set_attr_value_proto("table_name", &vec![18_u8, 0_u8,])?,
                Some(ref value) => (|attr| {new_op.set_attr_string("table_name", attr)})(&value)?,
            };
        }
        {
            (|attr: &i64| {new_op.set_attr_int("num_shards", *attr)})(&self.num_shards)?
        }
        {
            (|attr: &i64| {new_op.set_attr_int("shard_id", *attr)})(&self.shard_id)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct RetrieveTPUEmbeddingAdadeltaParametersGradAccumDebug {
    table_id: Option<i64>,
    table_name: Option<String>,
    num_shards: i64,
    shard_id: i64,
    op_name: Option<String>,
    id_: usize,
}

impl RetrieveTPUEmbeddingAdadeltaParametersGradAccumDebug {
    pub fn parameters(self) -> Edge<f32> {
        let rc = Rc::new(self);
        {
            Edge::<f32>::new(rc.clone(), 0)
        }
    }

    pub fn accumulators(self) -> Edge<f32> {
        let rc = Rc::new(self);
        {
            Edge::<f32>::new(rc.clone(), 1)
        }
    }

    pub fn updates(self) -> Edge<f32> {
        let rc = Rc::new(self);
        {
            Edge::<f32>::new(rc.clone(), 2)
        }
    }

    pub fn gradient_accumulators(self) -> Edge<f32> {
        let rc = Rc::new(self);
        {
            Edge::<f32>::new(rc.clone(), 3)
        }
    }

    pub fn table_id(&mut self, table_id: i64) -> Self {
        self.table_id = Some(table_id);
        self.clone()
    }

    pub fn table_name(&mut self, table_name: &str) -> Self {
        self.table_name = Some(table_name.to_string());
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> (Edge<f32>, Edge<f32>, Edge<f32>, Edge<f32>) {
        let rc = Rc::new(self);
        (
        {
            Edge::<f32>::new(rc.clone(), 0)
        },
        {
            Edge::<f32>::new(rc.clone(), 1)
        },
        {
            Edge::<f32>::new(rc.clone(), 2)
        },
        {
            Edge::<f32>::new(rc.clone(), 3)
        },
        )
    }

    pub fn build(num_shards: i64, shard_id: i64) -> Self {
        Self {
            table_id: None,
            table_name: None,
            num_shards: num_shards,
            shard_id: shard_id,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(num_shards: i64, shard_id: i64) -> (Edge<f32>, Edge<f32>, Edge<f32>, Edge<f32>) {
        Self {
            table_id: None,
            table_name: None,
            num_shards: num_shards,
            shard_id: shard_id,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<T> GraphOperation for RefNextIteration<T>
where T: TensorType,
      T: Clone,
      T: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("RefNextIteration_{}")?
        };
        let mut new_op = graph.new_operation("RefNextIteration", &op_name)?;
        {
            new_op.add_edge(&self.data)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct RefNextIteration<T>
where T: TensorType,
      T: Clone,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    data: Edge<T>,
    op_name: Option<String>,
    id_: usize,
}

impl<T> RefNextIteration<T>
where T: TensorType,
      T: Clone,
      T: 'static,
{
    pub fn output(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(data: Edge<T>) -> Self {
        Self {
            phantom_T: PhantomData,
            data,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(data: Edge<T>) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            data,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<T> GraphOperation for ZerosLike<T>
where T: TensorType,
      T: Clone,
      T: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("ZerosLike_{}")?
        };
        let mut new_op = graph.new_operation("ZerosLike", &op_name)?;
        {
            new_op.add_edge(&self.x)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct ZerosLike<T>
where T: TensorType,
      T: Clone,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    x: Edge<T>,
    op_name: Option<String>,
    id_: usize,
}

impl<T> ZerosLike<T>
where T: TensorType,
      T: Clone,
      T: 'static,
{
    pub fn y(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(x: Edge<T>) -> Self {
        Self {
            phantom_T: PhantomData,
            x,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(x: Edge<T>) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            x,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl GraphOperation for EnqueueTPUEmbeddingSparseBatch {
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("EnqueueTPUEmbeddingSparseBatch_{}")?
        };
        let mut new_op = graph.new_operation("EnqueueTPUEmbeddingSparseBatch", &op_name)?;
        {
            new_op.add_edge(&self.sample_indices)?
        }
        {
            new_op.add_edge(&self.embedding_indices)?
        }
        {
            new_op.add_edge(&self.aggregation_weights)?
        }
        {
            new_op.add_edge(&self.mode_override)?
        }
        {
            (|attr: &i64| {new_op.set_attr_int("N", *attr)})(&self.N)?
        }
        {
            match self.device_ordinal {
                None => new_op.set_attr_value_proto("device_ordinal", &vec![24_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 1_u8,])?,
                Some(ref value) => (|attr: &i64| {new_op.set_attr_int("device_ordinal", *attr)})(&value)?,
            };
        }
        {
            match self.combiners {
                None => new_op.set_attr_value_proto("combiners", &vec![10_u8, 0_u8,])?,
                Some(ref value) => (|attrs| {new_op.set_attr_string_list("combiners", attrs)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct EnqueueTPUEmbeddingSparseBatch {
    sample_indices: Edge<i32>,
    embedding_indices: Edge<i32>,
    aggregation_weights: Edge<f32>,
    mode_override: Edge<String>,
    N: i64,
    device_ordinal: Option<i64>,
    combiners: Option<Vec<String>>,
    op_name: Option<String>,
    id_: usize,
}

impl EnqueueTPUEmbeddingSparseBatch {
    pub fn device_ordinal(&mut self, device_ordinal: i64) -> Self {
        self.device_ordinal = Some(device_ordinal);
        self.clone()
    }

    pub fn combiners(&mut self, combiners: &[String]) -> Self {
        self.combiners = Some(combiners.to_vec());
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> () {
        let rc = Rc::new(self);
        (
        )
    }

    pub fn build(sample_indices: Edge<i32>, embedding_indices: Edge<i32>, aggregation_weights: Edge<f32>, mode_override: Edge<String>, N: i64) -> Self {
        Self {
            sample_indices,
            embedding_indices,
            aggregation_weights,
            mode_override,
            N: N,
            device_ordinal: None,
            combiners: None,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(sample_indices: Edge<i32>, embedding_indices: Edge<i32>, aggregation_weights: Edge<f32>, mode_override: Edge<String>, N: i64) -> () {
        Self {
            sample_indices,
            embedding_indices,
            aggregation_weights,
            mode_override,
            N: N,
            device_ordinal: None,
            combiners: None,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<T, Taxis, out_idx> GraphOperation for UniqueV2<T, Taxis, out_idx>
where T: TensorType,
      T: Clone,
      Taxis: TensorType,
      Taxis: Clone,
      out_idx: TensorType,
      T: 'static,
      Taxis: con_or_DT_INT32_or_DT_INT64,
      Taxis: 'static,
      out_idx: con_or_DT_INT32_or_DT_INT64,
      out_idx: 'static,
      out_idx: Clone,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("UniqueV2_{}")?
        };
        let mut new_op = graph.new_operation("UniqueV2", &op_name)?;
        {
            new_op.add_edge(&self.x)?
        }
        {
            new_op.add_edge(&self.axis)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct UniqueV2<T, Taxis, out_idx>
where T: TensorType,
      T: Clone,
      Taxis: TensorType,
      Taxis: Clone,
      out_idx: TensorType,
      T: 'static,
      Taxis: con_or_DT_INT32_or_DT_INT64,
      Taxis: 'static,
      out_idx: con_or_DT_INT32_or_DT_INT64,
      out_idx: 'static,
      out_idx: Clone,
{
    phantom_T: PhantomData<T>,
    x: Edge<T>,
    phantom_Taxis: PhantomData<Taxis>,
    axis: Edge<Taxis>,
    phantom_out_idx: PhantomData<out_idx>,
    op_name: Option<String>,
    id_: usize,
}

impl<T, Taxis, out_idx> UniqueV2<T, Taxis, out_idx>
where T: TensorType,
      T: Clone,
      Taxis: TensorType,
      Taxis: Clone,
      out_idx: TensorType,
      T: 'static,
      Taxis: con_or_DT_INT32_or_DT_INT64,
      Taxis: 'static,
      out_idx: con_or_DT_INT32_or_DT_INT64,
      out_idx: 'static,
      out_idx: Clone,
{
    pub fn y(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn idx(self) -> Edge<out_idx> {
        let rc = Rc::new(self);
        {
            Edge::<out_idx>::new(rc.clone(), 1)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> (Edge<T>, Edge<out_idx>) {
        let rc = Rc::new(self);
        (
        {
            Edge::<T>::new(rc.clone(), 0)
        },
        {
            Edge::<out_idx>::new(rc.clone(), 1)
        },
        )
    }

    pub fn build(x: Edge<T>, axis: Edge<Taxis>) -> Self {
        Self {
            phantom_T: PhantomData,
            x,
            phantom_Taxis: PhantomData,
            axis,
            phantom_out_idx: PhantomData,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(x: Edge<T>, axis: Edge<Taxis>) -> (Edge<T>, Edge<out_idx>) {
        Self {
            phantom_T: PhantomData,
            x,
            phantom_Taxis: PhantomData,
            axis,
            phantom_out_idx: PhantomData,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<T> GraphOperation for InplaceAdd<T>
where T: TensorType,
      T: Clone,
      T: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("InplaceAdd_{}")?
        };
        let mut new_op = graph.new_operation("InplaceAdd", &op_name)?;
        {
            new_op.add_edge(&self.x)?
        }
        {
            new_op.add_edge(&self.i)?
        }
        {
            new_op.add_edge(&self.v)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct InplaceAdd<T>
where T: TensorType,
      T: Clone,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    x: Edge<T>,
    i: Edge<i32>,
    v: Edge<T>,
    op_name: Option<String>,
    id_: usize,
}

impl<T> InplaceAdd<T>
where T: TensorType,
      T: Clone,
      T: 'static,
{
    pub fn y(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(x: Edge<T>, i: Edge<i32>, v: Edge<T>) -> Self {
        Self {
            phantom_T: PhantomData,
            x,
            i,
            v,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(x: Edge<T>, i: Edge<i32>, v: Edge<T>) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            x,
            i,
            v,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl GraphOperation for LogicalOr {
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("LogicalOr_{}")?
        };
        let mut new_op = graph.new_operation("LogicalOr", &op_name)?;
        {
            new_op.add_edge(&self.x)?
        }
        {
            new_op.add_edge(&self.y)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct LogicalOr {
    x: Edge<bool>,
    y: Edge<bool>,
    op_name: Option<String>,
    id_: usize,
}

impl LogicalOr {
    pub fn z(self) -> Edge<bool> {
        let rc = Rc::new(self);
        {
            Edge::<bool>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<bool> {
        let rc = Rc::new(self);
        {
            Edge::<bool>::new(rc.clone(), 0)
        }
    }

    pub fn build(x: Edge<bool>, y: Edge<bool>) -> Self {
        Self {
            x,
            y,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(x: Edge<bool>, y: Edge<bool>) -> Edge<bool> {
        Self {
            x,
            y,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<T> GraphOperation for IgammaGradA<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE,
      T: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("IgammaGradA_{}")?
        };
        let mut new_op = graph.new_operation("IgammaGradA", &op_name)?;
        {
            new_op.add_edge(&self.a)?
        }
        {
            new_op.add_edge(&self.x)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct IgammaGradA<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    a: Edge<T>,
    x: Edge<T>,
    op_name: Option<String>,
    id_: usize,
}

impl<T> IgammaGradA<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE,
      T: 'static,
{
    pub fn z(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(a: Edge<T>, x: Edge<T>) -> Self {
        Self {
            phantom_T: PhantomData,
            a,
            x,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(a: Edge<T>, x: Edge<T>) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            a,
            x,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<dtype> GraphOperation for TakeManySparseFromTensorsMap<dtype>
where dtype: TensorType,
      dtype: 'static,
      dtype: Clone,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("TakeManySparseFromTensorsMap_{}")?
        };
        let mut new_op = graph.new_operation("TakeManySparseFromTensorsMap", &op_name)?;
        {
            new_op.add_edge(&self.sparse_handles)?
        }
        {
            match self.container {
                None => new_op.set_attr_value_proto("container", &vec![18_u8, 0_u8,])?,
                Some(ref value) => (|attr| {new_op.set_attr_string("container", attr)})(&value)?,
            };
        }
        {
            match self.shared_name {
                None => new_op.set_attr_value_proto("shared_name", &vec![18_u8, 0_u8,])?,
                Some(ref value) => (|attr| {new_op.set_attr_string("shared_name", attr)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct TakeManySparseFromTensorsMap<dtype>
where dtype: TensorType,
      dtype: 'static,
      dtype: Clone,
{
    sparse_handles: Edge<i64>,
    phantom_dtype: PhantomData<dtype>,
    container: Option<String>,
    shared_name: Option<String>,
    op_name: Option<String>,
    id_: usize,
}

impl<dtype> TakeManySparseFromTensorsMap<dtype>
where dtype: TensorType,
      dtype: 'static,
      dtype: Clone,
{
    pub fn sparse_indices(self) -> Edge<i64> {
        let rc = Rc::new(self);
        {
            Edge::<i64>::new(rc.clone(), 0)
        }
    }

    pub fn sparse_values(self) -> Edge<dtype> {
        let rc = Rc::new(self);
        {
            Edge::<dtype>::new(rc.clone(), 1)
        }
    }

    pub fn sparse_shape(self) -> Edge<i64> {
        let rc = Rc::new(self);
        {
            Edge::<i64>::new(rc.clone(), 2)
        }
    }

    pub fn container(&mut self, container: &str) -> Self {
        self.container = Some(container.to_string());
        self.clone()
    }

    pub fn shared_name(&mut self, shared_name: &str) -> Self {
        self.shared_name = Some(shared_name.to_string());
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> (Edge<i64>, Edge<dtype>, Edge<i64>) {
        let rc = Rc::new(self);
        (
        {
            Edge::<i64>::new(rc.clone(), 0)
        },
        {
            Edge::<dtype>::new(rc.clone(), 1)
        },
        {
            Edge::<i64>::new(rc.clone(), 2)
        },
        )
    }

    pub fn build(sparse_handles: Edge<i64>) -> Self {
        Self {
            sparse_handles,
            phantom_dtype: PhantomData,
            container: None,
            shared_name: None,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(sparse_handles: Edge<i64>) -> (Edge<i64>, Edge<dtype>, Edge<i64>) {
        Self {
            sparse_handles,
            phantom_dtype: PhantomData,
            container: None,
            shared_name: None,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<dtype> GraphOperation for Const<dtype>
where dtype: TensorType,
      dtype: 'static,
      dtype: Clone,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("Const_{}")?
        };
        let mut new_op = graph.new_operation("Const", &op_name)?;
        {
            (|attr: &Rc<AnyTensor>| {new_op.set_attr_tensor_owned("value", attr.clone())})(&self.value)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct Const<dtype>
where dtype: TensorType,
      dtype: 'static,
      dtype: Clone,
{
    value: Rc<AnyTensor>,
    phantom_dtype: PhantomData<dtype>,
    op_name: Option<String>,
    id_: usize,
}

impl<dtype> Const<dtype>
where dtype: TensorType,
      dtype: 'static,
      dtype: Clone,
{
    pub fn output(self) -> Edge<dtype> {
        let rc = Rc::new(self);
        {
            Edge::<dtype>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<dtype> {
        let rc = Rc::new(self);
        {
            Edge::<dtype>::new(rc.clone(), 0)
        }
    }

    pub fn build<value_T>(value: value_T) -> Self
    where value_T: AnyTensor,
          value_T: 'static,
    {
        Self {
            value: Rc::new(value),
            phantom_dtype: PhantomData,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new<value_T>(value: value_T) -> Edge<dtype>
    where value_T: AnyTensor,
          value_T: 'static,
    {
        Self {
            value: Rc::new(value),
            phantom_dtype: PhantomData,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl GraphOperation for EnqueueTPUEmbeddingSparseTensorBatch {
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("EnqueueTPUEmbeddingSparseTensorBatch_{}")?
        };
        let mut new_op = graph.new_operation("EnqueueTPUEmbeddingSparseTensorBatch", &op_name)?;
        {
            new_op.add_edge(&self.sample_indices)?
        }
        {
            new_op.add_edge(&self.embedding_indices)?
        }
        {
            new_op.add_edge(&self.aggregation_weights)?
        }
        {
            new_op.add_edge(&self.mode_override)?
        }
        {
            (|attr: &i64| {new_op.set_attr_int("N", *attr)})(&self.N)?
        }
        {
            match self.device_ordinal {
                None => new_op.set_attr_value_proto("device_ordinal", &vec![24_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 1_u8,])?,
                Some(ref value) => (|attr: &i64| {new_op.set_attr_int("device_ordinal", *attr)})(&value)?,
            };
        }
        {
            match self.combiners {
                None => new_op.set_attr_value_proto("combiners", &vec![10_u8, 0_u8,])?,
                Some(ref value) => (|attrs| {new_op.set_attr_string_list("combiners", attrs)})(&value)?,
            };
        }
        {
            (|attrs| {new_op.set_attr_int_list("table_ids", attrs)})(&self.table_ids)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct EnqueueTPUEmbeddingSparseTensorBatch {
    sample_indices: Edge<i32>,
    embedding_indices: Edge<i32>,
    aggregation_weights: Edge<f32>,
    mode_override: Edge<String>,
    N: i64,
    device_ordinal: Option<i64>,
    combiners: Option<Vec<String>>,
    table_ids: Vec<i64>,
    op_name: Option<String>,
    id_: usize,
}

impl EnqueueTPUEmbeddingSparseTensorBatch {
    pub fn device_ordinal(&mut self, device_ordinal: i64) -> Self {
        self.device_ordinal = Some(device_ordinal);
        self.clone()
    }

    pub fn combiners(&mut self, combiners: &[String]) -> Self {
        self.combiners = Some(combiners.to_vec());
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> () {
        let rc = Rc::new(self);
        (
        )
    }

    pub fn build(sample_indices: Edge<i32>, embedding_indices: Edge<i32>, aggregation_weights: Edge<f32>, mode_override: Edge<String>, N: i64, table_ids: &[i64]) -> Self {
        Self {
            sample_indices,
            embedding_indices,
            aggregation_weights,
            mode_override,
            N: N,
            device_ordinal: None,
            combiners: None,
            table_ids: table_ids.to_vec(),
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(sample_indices: Edge<i32>, embedding_indices: Edge<i32>, aggregation_weights: Edge<f32>, mode_override: Edge<String>, N: i64, table_ids: &[i64]) -> () {
        Self {
            sample_indices,
            embedding_indices,
            aggregation_weights,
            mode_override,
            N: N,
            device_ordinal: None,
            combiners: None,
            table_ids: table_ids.to_vec(),
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl GraphOperation for LoadTPUEmbeddingStochasticGradientDescentParameters {
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("LoadTPUEmbeddingStochasticGradientDescentParameters_{}")?
        };
        let mut new_op = graph.new_operation("LoadTPUEmbeddingStochasticGradientDescentParameters", &op_name)?;
        {
            new_op.add_edge(&self.parameters)?
        }
        {
            match self.table_id {
                None => new_op.set_attr_value_proto("table_id", &vec![24_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 1_u8,])?,
                Some(ref value) => (|attr: &i64| {new_op.set_attr_int("table_id", *attr)})(&value)?,
            };
        }
        {
            match self.table_name {
                None => new_op.set_attr_value_proto("table_name", &vec![18_u8, 0_u8,])?,
                Some(ref value) => (|attr| {new_op.set_attr_string("table_name", attr)})(&value)?,
            };
        }
        {
            (|attr: &i64| {new_op.set_attr_int("num_shards", *attr)})(&self.num_shards)?
        }
        {
            (|attr: &i64| {new_op.set_attr_int("shard_id", *attr)})(&self.shard_id)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct LoadTPUEmbeddingStochasticGradientDescentParameters {
    parameters: Edge<f32>,
    table_id: Option<i64>,
    table_name: Option<String>,
    num_shards: i64,
    shard_id: i64,
    op_name: Option<String>,
    id_: usize,
}

impl LoadTPUEmbeddingStochasticGradientDescentParameters {
    pub fn table_id(&mut self, table_id: i64) -> Self {
        self.table_id = Some(table_id);
        self.clone()
    }

    pub fn table_name(&mut self, table_name: &str) -> Self {
        self.table_name = Some(table_name.to_string());
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> () {
        let rc = Rc::new(self);
        (
        )
    }

    pub fn build(parameters: Edge<f32>, num_shards: i64, shard_id: i64) -> Self {
        Self {
            parameters,
            table_id: None,
            table_name: None,
            num_shards: num_shards,
            shard_id: shard_id,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(parameters: Edge<f32>, num_shards: i64, shard_id: i64) -> () {
        Self {
            parameters,
            table_id: None,
            table_name: None,
            num_shards: num_shards,
            shard_id: shard_id,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

pub trait con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF for BFloat16 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF for OtherComplex<f32> {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF for OtherComplex<f64> {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF for f32 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF for f64 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF for i16 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF for i32 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF for i64 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF for i8 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF for u16 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF for u8 {
}

impl<T> GraphOperation for Mul<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF,
      T: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("Mul_{}")?
        };
        let mut new_op = graph.new_operation("Mul", &op_name)?;
        {
            new_op.add_edge(&self.x)?
        }
        {
            new_op.add_edge(&self.y)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct Mul<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    x: Edge<T>,
    y: Edge<T>,
    op_name: Option<String>,
    id_: usize,
}

impl<T> Mul<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF,
      T: 'static,
{
    pub fn z(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(x: Edge<T>, y: Edge<T>) -> Self {
        Self {
            phantom_T: PhantomData,
            x,
            y,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(x: Edge<T>, y: Edge<T>) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            x,
            y,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<T> GraphOperation for BiasAdd<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("BiasAdd_{}")?
        };
        let mut new_op = graph.new_operation("BiasAdd", &op_name)?;
        {
            new_op.add_edge(&self.value)?
        }
        {
            new_op.add_edge(&self.bias)?
        }
        {
            match self.data_format {
                None => new_op.set_attr_value_proto("data_format", &vec![18_u8, 4_u8, 78_u8, 72_u8, 87_u8, 67_u8,])?,
                Some(ref value) => (|attr| {new_op.set_attr_string("data_format", attr)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct BiasAdd<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    value: Edge<T>,
    bias: Edge<T>,
    data_format: Option<String>,
    op_name: Option<String>,
    id_: usize,
}

impl<T> BiasAdd<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
{
    pub fn output(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn data_format(&mut self, data_format: &str) -> Self {
        self.data_format = Some(data_format.to_string());
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(value: Edge<T>, bias: Edge<T>) -> Self {
        Self {
            phantom_T: PhantomData,
            value,
            bias,
            data_format: None,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(value: Edge<T>, bias: Edge<T>) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            value,
            bias,
            data_format: None,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<T, Tdim> GraphOperation for ExpandDims<T, Tdim>
where T: TensorType,
      T: Clone,
      Tdim: TensorType,
      Tdim: Clone,
      T: 'static,
      Tdim: con_or_DT_INT32_or_DT_INT64,
      Tdim: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("ExpandDims_{}")?
        };
        let mut new_op = graph.new_operation("ExpandDims", &op_name)?;
        {
            new_op.add_edge(&self.input)?
        }
        {
            new_op.add_edge(&self.dim)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct ExpandDims<T, Tdim>
where T: TensorType,
      T: Clone,
      Tdim: TensorType,
      Tdim: Clone,
      T: 'static,
      Tdim: con_or_DT_INT32_or_DT_INT64,
      Tdim: 'static,
{
    phantom_T: PhantomData<T>,
    input: Edge<T>,
    phantom_Tdim: PhantomData<Tdim>,
    dim: Edge<Tdim>,
    op_name: Option<String>,
    id_: usize,
}

impl<T, Tdim> ExpandDims<T, Tdim>
where T: TensorType,
      T: Clone,
      Tdim: TensorType,
      Tdim: Clone,
      T: 'static,
      Tdim: con_or_DT_INT32_or_DT_INT64,
      Tdim: 'static,
{
    pub fn output(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(input: Edge<T>, dim: Edge<Tdim>) -> Self {
        Self {
            phantom_T: PhantomData,
            input,
            phantom_Tdim: PhantomData,
            dim,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(input: Edge<T>, dim: Edge<Tdim>) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            input,
            phantom_Tdim: PhantomData,
            dim,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<T, Tmultiples> GraphOperation for Tile<T, Tmultiples>
where T: TensorType,
      T: Clone,
      Tmultiples: TensorType,
      Tmultiples: Clone,
      T: 'static,
      Tmultiples: con_or_DT_INT32_or_DT_INT64,
      Tmultiples: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("Tile_{}")?
        };
        let mut new_op = graph.new_operation("Tile", &op_name)?;
        {
            new_op.add_edge(&self.input)?
        }
        {
            new_op.add_edge(&self.multiples)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct Tile<T, Tmultiples>
where T: TensorType,
      T: Clone,
      Tmultiples: TensorType,
      Tmultiples: Clone,
      T: 'static,
      Tmultiples: con_or_DT_INT32_or_DT_INT64,
      Tmultiples: 'static,
{
    phantom_T: PhantomData<T>,
    input: Edge<T>,
    phantom_Tmultiples: PhantomData<Tmultiples>,
    multiples: Edge<Tmultiples>,
    op_name: Option<String>,
    id_: usize,
}

impl<T, Tmultiples> Tile<T, Tmultiples>
where T: TensorType,
      T: Clone,
      Tmultiples: TensorType,
      Tmultiples: Clone,
      T: 'static,
      Tmultiples: con_or_DT_INT32_or_DT_INT64,
      Tmultiples: 'static,
{
    pub fn output(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(input: Edge<T>, multiples: Edge<Tmultiples>) -> Self {
        Self {
            phantom_T: PhantomData,
            input,
            phantom_Tmultiples: PhantomData,
            multiples,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(input: Edge<T>, multiples: Edge<Tmultiples>) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            input,
            phantom_Tmultiples: PhantomData,
            multiples,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl GraphOperation for RecvTPUEmbeddingActivations {
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("RecvTPUEmbeddingActivations_{}")?
        };
        let mut new_op = graph.new_operation("RecvTPUEmbeddingActivations", &op_name)?;
        {
            (|attr: &i64| {new_op.set_attr_int("num_outputs", *attr)})(&self.num_outputs)?
        }
        {
            (|attr| {new_op.set_attr_string("config", attr)})(&self.config)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct RecvTPUEmbeddingActivations {
    num_outputs: i64,
    config: String,
    op_name: Option<String>,
    id_: usize,
}

impl RecvTPUEmbeddingActivations {
    pub fn outputs(self) -> Edge<f32> {
        let rc = Rc::new(self);
        {
            Edge::<f32>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<f32> {
        let rc = Rc::new(self);
        {
            Edge::<f32>::new(rc.clone(), 0)
        }
    }

    pub fn build(num_outputs: i64, config: &str) -> Self {
        Self {
            num_outputs: num_outputs,
            config: config.to_string(),
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(num_outputs: i64, config: &str) -> Edge<f32> {
        Self {
            num_outputs: num_outputs,
            config: config.to_string(),
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl GraphOperation for WorkerHeartbeat {
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("WorkerHeartbeat_{}")?
        };
        let mut new_op = graph.new_operation("WorkerHeartbeat", &op_name)?;
        {
            new_op.add_edge(&self.request)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct WorkerHeartbeat {
    request: Edge<String>,
    op_name: Option<String>,
    id_: usize,
}

impl WorkerHeartbeat {
    pub fn response(self) -> Edge<String> {
        let rc = Rc::new(self);
        {
            Edge::<String>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<String> {
        let rc = Rc::new(self);
        {
            Edge::<String>::new(rc.clone(), 0)
        }
    }

    pub fn build(request: Edge<String>) -> Self {
        Self {
            request,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(request: Edge<String>) -> Edge<String> {
        Self {
            request,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<T> GraphOperation for Select<T>
where T: TensorType,
      T: Clone,
      T: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("Select_{}")?
        };
        let mut new_op = graph.new_operation("Select", &op_name)?;
        {
            new_op.add_edge(&self.condition)?
        }
        {
            new_op.add_edge(&self.t)?
        }
        {
            new_op.add_edge(&self.e)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct Select<T>
where T: TensorType,
      T: Clone,
      T: 'static,
{
    condition: Edge<bool>,
    phantom_T: PhantomData<T>,
    t: Edge<T>,
    e: Edge<T>,
    op_name: Option<String>,
    id_: usize,
}

impl<T> Select<T>
where T: TensorType,
      T: Clone,
      T: 'static,
{
    pub fn output(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(condition: Edge<bool>, t: Edge<T>, e: Edge<T>) -> Self {
        Self {
            condition,
            phantom_T: PhantomData,
            t,
            e,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(condition: Edge<bool>, t: Edge<T>, e: Edge<T>) -> Edge<T> {
        Self {
            condition,
            phantom_T: PhantomData,
            t,
            e,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<T> GraphOperation for RsqrtGrad<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_COMPLEX64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF,
      T: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("RsqrtGrad_{}")?
        };
        let mut new_op = graph.new_operation("RsqrtGrad", &op_name)?;
        {
            new_op.add_edge(&self.y)?
        }
        {
            new_op.add_edge(&self.dy)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct RsqrtGrad<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_COMPLEX64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    y: Edge<T>,
    dy: Edge<T>,
    op_name: Option<String>,
    id_: usize,
}

impl<T> RsqrtGrad<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_COMPLEX64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF,
      T: 'static,
{
    pub fn z(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(y: Edge<T>, dy: Edge<T>) -> Self {
        Self {
            phantom_T: PhantomData,
            y,
            dy,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(y: Edge<T>, dy: Edge<T>) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            y,
            dy,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<T, Tpaddings> GraphOperation for PadV2<T, Tpaddings>
where T: TensorType,
      T: Clone,
      Tpaddings: TensorType,
      Tpaddings: Clone,
      T: 'static,
      Tpaddings: con_or_DT_INT32_or_DT_INT64,
      Tpaddings: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("PadV2_{}")?
        };
        let mut new_op = graph.new_operation("PadV2", &op_name)?;
        {
            new_op.add_edge(&self.input)?
        }
        {
            new_op.add_edge(&self.paddings)?
        }
        {
            new_op.add_edge(&self.constant_values)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct PadV2<T, Tpaddings>
where T: TensorType,
      T: Clone,
      Tpaddings: TensorType,
      Tpaddings: Clone,
      T: 'static,
      Tpaddings: con_or_DT_INT32_or_DT_INT64,
      Tpaddings: 'static,
{
    phantom_T: PhantomData<T>,
    input: Edge<T>,
    phantom_Tpaddings: PhantomData<Tpaddings>,
    paddings: Edge<Tpaddings>,
    constant_values: Edge<T>,
    op_name: Option<String>,
    id_: usize,
}

impl<T, Tpaddings> PadV2<T, Tpaddings>
where T: TensorType,
      T: Clone,
      Tpaddings: TensorType,
      Tpaddings: Clone,
      T: 'static,
      Tpaddings: con_or_DT_INT32_or_DT_INT64,
      Tpaddings: 'static,
{
    pub fn output(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(input: Edge<T>, paddings: Edge<Tpaddings>, constant_values: Edge<T>) -> Self {
        Self {
            phantom_T: PhantomData,
            input,
            phantom_Tpaddings: PhantomData,
            paddings,
            constant_values,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(input: Edge<T>, paddings: Edge<Tpaddings>, constant_values: Edge<T>) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            input,
            phantom_Tpaddings: PhantomData,
            paddings,
            constant_values,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl GraphOperation for LoadTPUEmbeddingProximalAdagradParameters {
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("LoadTPUEmbeddingProximalAdagradParameters_{}")?
        };
        let mut new_op = graph.new_operation("LoadTPUEmbeddingProximalAdagradParameters", &op_name)?;
        {
            new_op.add_edge(&self.parameters)?
        }
        {
            new_op.add_edge(&self.accumulators)?
        }
        {
            match self.table_id {
                None => new_op.set_attr_value_proto("table_id", &vec![24_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 1_u8,])?,
                Some(ref value) => (|attr: &i64| {new_op.set_attr_int("table_id", *attr)})(&value)?,
            };
        }
        {
            match self.table_name {
                None => new_op.set_attr_value_proto("table_name", &vec![18_u8, 0_u8,])?,
                Some(ref value) => (|attr| {new_op.set_attr_string("table_name", attr)})(&value)?,
            };
        }
        {
            (|attr: &i64| {new_op.set_attr_int("num_shards", *attr)})(&self.num_shards)?
        }
        {
            (|attr: &i64| {new_op.set_attr_int("shard_id", *attr)})(&self.shard_id)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct LoadTPUEmbeddingProximalAdagradParameters {
    parameters: Edge<f32>,
    accumulators: Edge<f32>,
    table_id: Option<i64>,
    table_name: Option<String>,
    num_shards: i64,
    shard_id: i64,
    op_name: Option<String>,
    id_: usize,
}

impl LoadTPUEmbeddingProximalAdagradParameters {
    pub fn table_id(&mut self, table_id: i64) -> Self {
        self.table_id = Some(table_id);
        self.clone()
    }

    pub fn table_name(&mut self, table_name: &str) -> Self {
        self.table_name = Some(table_name.to_string());
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> () {
        let rc = Rc::new(self);
        (
        )
    }

    pub fn build(parameters: Edge<f32>, accumulators: Edge<f32>, num_shards: i64, shard_id: i64) -> Self {
        Self {
            parameters,
            accumulators,
            table_id: None,
            table_name: None,
            num_shards: num_shards,
            shard_id: shard_id,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(parameters: Edge<f32>, accumulators: Edge<f32>, num_shards: i64, shard_id: i64) -> () {
        Self {
            parameters,
            accumulators,
            table_id: None,
            table_name: None,
            num_shards: num_shards,
            shard_id: shard_id,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<T, Tpaddings> GraphOperation for MirrorPadGrad<T, Tpaddings>
where T: TensorType,
      T: Clone,
      Tpaddings: TensorType,
      Tpaddings: Clone,
      T: 'static,
      Tpaddings: con_or_DT_INT32_or_DT_INT64,
      Tpaddings: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("MirrorPadGrad_{}")?
        };
        let mut new_op = graph.new_operation("MirrorPadGrad", &op_name)?;
        {
            new_op.add_edge(&self.input)?
        }
        {
            new_op.add_edge(&self.paddings)?
        }
        {
            (|attr| {new_op.set_attr_string("mode", attr)})(&self.mode)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct MirrorPadGrad<T, Tpaddings>
where T: TensorType,
      T: Clone,
      Tpaddings: TensorType,
      Tpaddings: Clone,
      T: 'static,
      Tpaddings: con_or_DT_INT32_or_DT_INT64,
      Tpaddings: 'static,
{
    phantom_T: PhantomData<T>,
    input: Edge<T>,
    phantom_Tpaddings: PhantomData<Tpaddings>,
    paddings: Edge<Tpaddings>,
    mode: String,
    op_name: Option<String>,
    id_: usize,
}

impl<T, Tpaddings> MirrorPadGrad<T, Tpaddings>
where T: TensorType,
      T: Clone,
      Tpaddings: TensorType,
      Tpaddings: Clone,
      T: 'static,
      Tpaddings: con_or_DT_INT32_or_DT_INT64,
      Tpaddings: 'static,
{
    pub fn output(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(input: Edge<T>, paddings: Edge<Tpaddings>, mode: &str) -> Self {
        Self {
            phantom_T: PhantomData,
            input,
            phantom_Tpaddings: PhantomData,
            paddings,
            mode: mode.to_string(),
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(input: Edge<T>, paddings: Edge<Tpaddings>, mode: &str) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            input,
            phantom_Tpaddings: PhantomData,
            paddings,
            mode: mode.to_string(),
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

pub trait con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_STRING_or_DT_COMPLEX64_or_DT_INT64_or_DT_BOOL_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_STRING_or_DT_COMPLEX64_or_DT_INT64_or_DT_BOOL_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF for OtherComplex<f32> {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_STRING_or_DT_COMPLEX64_or_DT_INT64_or_DT_BOOL_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF for OtherComplex<f64> {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_STRING_or_DT_COMPLEX64_or_DT_INT64_or_DT_BOOL_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF for String {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_STRING_or_DT_COMPLEX64_or_DT_INT64_or_DT_BOOL_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF for bool {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_STRING_or_DT_COMPLEX64_or_DT_INT64_or_DT_BOOL_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF for f32 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_STRING_or_DT_COMPLEX64_or_DT_INT64_or_DT_BOOL_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF for f64 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_STRING_or_DT_COMPLEX64_or_DT_INT64_or_DT_BOOL_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF for i16 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_STRING_or_DT_COMPLEX64_or_DT_INT64_or_DT_BOOL_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF for i32 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_STRING_or_DT_COMPLEX64_or_DT_INT64_or_DT_BOOL_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF for i64 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_STRING_or_DT_COMPLEX64_or_DT_INT64_or_DT_BOOL_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF for i8 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_STRING_or_DT_COMPLEX64_or_DT_INT64_or_DT_BOOL_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF for u16 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_STRING_or_DT_COMPLEX64_or_DT_INT64_or_DT_BOOL_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF for u8 {
}

impl<T> GraphOperation for Reverse<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_STRING_or_DT_COMPLEX64_or_DT_INT64_or_DT_BOOL_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF,
      T: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("Reverse_{}")?
        };
        let mut new_op = graph.new_operation("Reverse", &op_name)?;
        {
            new_op.add_edge(&self.tensor)?
        }
        {
            new_op.add_edge(&self.dims)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct Reverse<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_STRING_or_DT_COMPLEX64_or_DT_INT64_or_DT_BOOL_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    tensor: Edge<T>,
    dims: Edge<bool>,
    op_name: Option<String>,
    id_: usize,
}

impl<T> Reverse<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_STRING_or_DT_COMPLEX64_or_DT_INT64_or_DT_BOOL_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF,
      T: 'static,
{
    pub fn output(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(tensor: Edge<T>, dims: Edge<bool>) -> Self {
        Self {
            phantom_T: PhantomData,
            tensor,
            dims,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(tensor: Edge<T>, dims: Edge<bool>) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            tensor,
            dims,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<T> GraphOperation for LogSoftmax<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
      T: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("LogSoftmax_{}")?
        };
        let mut new_op = graph.new_operation("LogSoftmax", &op_name)?;
        {
            new_op.add_edge(&self.logits)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct LogSoftmax<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    logits: Edge<T>,
    op_name: Option<String>,
    id_: usize,
}

impl<T> LogSoftmax<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
      T: 'static,
{
    pub fn logsoftmax(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(logits: Edge<T>) -> Self {
        Self {
            phantom_T: PhantomData,
            logits,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(logits: Edge<T>) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            logits,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<T> GraphOperation for InvertPermutation<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_INT32_or_DT_INT64,
      T: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("InvertPermutation_{}")?
        };
        let mut new_op = graph.new_operation("InvertPermutation", &op_name)?;
        {
            new_op.add_edge(&self.x)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct InvertPermutation<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_INT32_or_DT_INT64,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    x: Edge<T>,
    op_name: Option<String>,
    id_: usize,
}

impl<T> InvertPermutation<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_INT32_or_DT_INT64,
      T: 'static,
{
    pub fn y(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(x: Edge<T>) -> Self {
        Self {
            phantom_T: PhantomData,
            x,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(x: Edge<T>) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            x,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl GraphOperation for TensorArrayClose {
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("TensorArrayClose_{}")?
        };
        let mut new_op = graph.new_operation("TensorArrayClose", &op_name)?;
        {
            new_op.add_edge(&self.handle)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct TensorArrayClose {
    handle: Edge<String>,
    op_name: Option<String>,
    id_: usize,
}

impl TensorArrayClose {
    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> () {
        let rc = Rc::new(self);
        (
        )
    }

    pub fn build(handle: Edge<String>) -> Self {
        Self {
            handle,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(handle: Edge<String>) -> () {
        Self {
            handle,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<T> GraphOperation for Conv2D<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
      T: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("Conv2D_{}")?
        };
        let mut new_op = graph.new_operation("Conv2D", &op_name)?;
        {
            new_op.add_edge(&self.input)?
        }
        {
            new_op.add_edge(&self.filter)?
        }
        {
            (|attrs| {new_op.set_attr_int_list("strides", attrs)})(&self.strides)?
        }
        {
            match self.use_cudnn_on_gpu {
                None => new_op.set_attr_value_proto("use_cudnn_on_gpu", &vec![40_u8, 1_u8,])?,
                Some(ref value) => (|attr: &bool| {new_op.set_attr_bool("use_cudnn_on_gpu", *attr)})(&value)?,
            };
        }
        {
            (|attr| {new_op.set_attr_string("padding", attr)})(&self.padding)?
        }
        {
            match self.data_format {
                None => new_op.set_attr_value_proto("data_format", &vec![18_u8, 4_u8, 78_u8, 72_u8, 87_u8, 67_u8,])?,
                Some(ref value) => (|attr| {new_op.set_attr_string("data_format", attr)})(&value)?,
            };
        }
        {
            match self.dilations {
                None => new_op.set_attr_value_proto("dilations", &vec![10_u8, 0_u8, 26_u8, 4_u8,])?,
                Some(ref value) => (|attrs| {new_op.set_attr_int_list("dilations", attrs)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct Conv2D<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    input: Edge<T>,
    filter: Edge<T>,
    strides: Vec<i64>,
    use_cudnn_on_gpu: Option<bool>,
    padding: String,
    data_format: Option<String>,
    dilations: Option<Vec<i64>>,
    op_name: Option<String>,
    id_: usize,
}

impl<T> Conv2D<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
      T: 'static,
{
    pub fn output(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn use_cudnn_on_gpu(&mut self, use_cudnn_on_gpu: bool) -> Self {
        self.use_cudnn_on_gpu = Some(use_cudnn_on_gpu);
        self.clone()
    }

    pub fn data_format(&mut self, data_format: &str) -> Self {
        self.data_format = Some(data_format.to_string());
        self.clone()
    }

    pub fn dilations(&mut self, dilations: &[i64]) -> Self {
        self.dilations = Some(dilations.to_vec());
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(input: Edge<T>, filter: Edge<T>, strides: &[i64], padding: &str) -> Self {
        Self {
            phantom_T: PhantomData,
            input,
            filter,
            strides: strides.to_vec(),
            use_cudnn_on_gpu: None,
            padding: padding.to_string(),
            data_format: None,
            dilations: None,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(input: Edge<T>, filter: Edge<T>, strides: &[i64], padding: &str) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            input,
            filter,
            strides: strides.to_vec(),
            use_cudnn_on_gpu: None,
            padding: padding.to_string(),
            data_format: None,
            dilations: None,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<T, Tshape> GraphOperation for Reshape<T, Tshape>
where T: TensorType,
      T: Clone,
      Tshape: TensorType,
      Tshape: Clone,
      T: 'static,
      Tshape: con_or_DT_INT32_or_DT_INT64,
      Tshape: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("Reshape_{}")?
        };
        let mut new_op = graph.new_operation("Reshape", &op_name)?;
        {
            new_op.add_edge(&self.tensor)?
        }
        {
            new_op.add_edge(&self.shape)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct Reshape<T, Tshape>
where T: TensorType,
      T: Clone,
      Tshape: TensorType,
      Tshape: Clone,
      T: 'static,
      Tshape: con_or_DT_INT32_or_DT_INT64,
      Tshape: 'static,
{
    phantom_T: PhantomData<T>,
    tensor: Edge<T>,
    phantom_Tshape: PhantomData<Tshape>,
    shape: Edge<Tshape>,
    op_name: Option<String>,
    id_: usize,
}

impl<T, Tshape> Reshape<T, Tshape>
where T: TensorType,
      T: Clone,
      Tshape: TensorType,
      Tshape: Clone,
      T: 'static,
      Tshape: con_or_DT_INT32_or_DT_INT64,
      Tshape: 'static,
{
    pub fn output(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(tensor: Edge<T>, shape: Edge<Tshape>) -> Self {
        Self {
            phantom_T: PhantomData,
            tensor,
            phantom_Tshape: PhantomData,
            shape,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(tensor: Edge<T>, shape: Edge<Tshape>) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            tensor,
            phantom_Tshape: PhantomData,
            shape,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<T> GraphOperation for NonMaxSuppressionV2<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_HALF,
      T: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("NonMaxSuppressionV2_{}")?
        };
        let mut new_op = graph.new_operation("NonMaxSuppressionV2", &op_name)?;
        {
            new_op.add_edge(&self.boxes)?
        }
        {
            new_op.add_edge(&self.scores)?
        }
        {
            new_op.add_edge(&self.max_output_size)?
        }
        {
            new_op.add_edge(&self.iou_threshold)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct NonMaxSuppressionV2<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_HALF,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    boxes: Edge<T>,
    scores: Edge<T>,
    max_output_size: Edge<i32>,
    iou_threshold: Edge<f32>,
    op_name: Option<String>,
    id_: usize,
}

impl<T> NonMaxSuppressionV2<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_HALF,
      T: 'static,
{
    pub fn selected_indices(self) -> Edge<i32> {
        let rc = Rc::new(self);
        {
            Edge::<i32>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<i32> {
        let rc = Rc::new(self);
        {
            Edge::<i32>::new(rc.clone(), 0)
        }
    }

    pub fn build(boxes: Edge<T>, scores: Edge<T>, max_output_size: Edge<i32>, iou_threshold: Edge<f32>) -> Self {
        Self {
            phantom_T: PhantomData,
            boxes,
            scores,
            max_output_size,
            iou_threshold,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(boxes: Edge<T>, scores: Edge<T>, max_output_size: Edge<i32>, iou_threshold: Edge<f32>) -> Edge<i32> {
        Self {
            phantom_T: PhantomData,
            boxes,
            scores,
            max_output_size,
            iou_threshold,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl GraphOperation for ReduceJoin {
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("ReduceJoin_{}")?
        };
        let mut new_op = graph.new_operation("ReduceJoin", &op_name)?;
        {
            new_op.add_edge(&self.inputs)?
        }
        {
            new_op.add_edge(&self.reduction_indices)?
        }
        {
            match self.keep_dims {
                None => new_op.set_attr_value_proto("keep_dims", &vec![40_u8, 0_u8,])?,
                Some(ref value) => (|attr: &bool| {new_op.set_attr_bool("keep_dims", *attr)})(&value)?,
            };
        }
        {
            match self.separator {
                None => new_op.set_attr_value_proto("separator", &vec![18_u8, 0_u8,])?,
                Some(ref value) => (|attr| {new_op.set_attr_string("separator", attr)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct ReduceJoin {
    inputs: Edge<String>,
    reduction_indices: Edge<i32>,
    keep_dims: Option<bool>,
    separator: Option<String>,
    op_name: Option<String>,
    id_: usize,
}

impl ReduceJoin {
    pub fn output(self) -> Edge<String> {
        let rc = Rc::new(self);
        {
            Edge::<String>::new(rc.clone(), 0)
        }
    }

    pub fn keep_dims(&mut self, keep_dims: bool) -> Self {
        self.keep_dims = Some(keep_dims);
        self.clone()
    }

    pub fn separator(&mut self, separator: &str) -> Self {
        self.separator = Some(separator.to_string());
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<String> {
        let rc = Rc::new(self);
        {
            Edge::<String>::new(rc.clone(), 0)
        }
    }

    pub fn build(inputs: Edge<String>, reduction_indices: Edge<i32>) -> Self {
        Self {
            inputs,
            reduction_indices,
            keep_dims: None,
            separator: None,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(inputs: Edge<String>, reduction_indices: Edge<i32>) -> Edge<String> {
        Self {
            inputs,
            reduction_indices,
            keep_dims: None,
            separator: None,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl GraphOperation for ReaderRestoreState {
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("ReaderRestoreState_{}")?
        };
        let mut new_op = graph.new_operation("ReaderRestoreState", &op_name)?;
        {
            new_op.add_edge(&self.reader_handle)?
        }
        {
            new_op.add_edge(&self.state)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct ReaderRestoreState {
    reader_handle: Edge<String>,
    state: Edge<String>,
    op_name: Option<String>,
    id_: usize,
}

impl ReaderRestoreState {
    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> () {
        let rc = Rc::new(self);
        (
        )
    }

    pub fn build(reader_handle: Edge<String>, state: Edge<String>) -> Self {
        Self {
            reader_handle,
            state,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(reader_handle: Edge<String>, state: Edge<String>) -> () {
        Self {
            reader_handle,
            state,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<T, Tlen> GraphOperation for ReverseSequence<T, Tlen>
where T: TensorType,
      T: Clone,
      Tlen: TensorType,
      Tlen: Clone,
      T: 'static,
      Tlen: con_or_DT_INT32_or_DT_INT64,
      Tlen: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("ReverseSequence_{}")?
        };
        let mut new_op = graph.new_operation("ReverseSequence", &op_name)?;
        {
            new_op.add_edge(&self.input)?
        }
        {
            new_op.add_edge(&self.seq_lengths)?
        }
        {
            (|attr: &i64| {new_op.set_attr_int("seq_dim", *attr)})(&self.seq_dim)?
        }
        {
            match self.batch_dim {
                None => new_op.set_attr_value_proto("batch_dim", &vec![24_u8, 0_u8,])?,
                Some(ref value) => (|attr: &i64| {new_op.set_attr_int("batch_dim", *attr)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct ReverseSequence<T, Tlen>
where T: TensorType,
      T: Clone,
      Tlen: TensorType,
      Tlen: Clone,
      T: 'static,
      Tlen: con_or_DT_INT32_or_DT_INT64,
      Tlen: 'static,
{
    phantom_T: PhantomData<T>,
    input: Edge<T>,
    phantom_Tlen: PhantomData<Tlen>,
    seq_lengths: Edge<Tlen>,
    seq_dim: i64,
    batch_dim: Option<i64>,
    op_name: Option<String>,
    id_: usize,
}

impl<T, Tlen> ReverseSequence<T, Tlen>
where T: TensorType,
      T: Clone,
      Tlen: TensorType,
      Tlen: Clone,
      T: 'static,
      Tlen: con_or_DT_INT32_or_DT_INT64,
      Tlen: 'static,
{
    pub fn output(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn batch_dim(&mut self, batch_dim: i64) -> Self {
        self.batch_dim = Some(batch_dim);
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(input: Edge<T>, seq_lengths: Edge<Tlen>, seq_dim: i64) -> Self {
        Self {
            phantom_T: PhantomData,
            input,
            phantom_Tlen: PhantomData,
            seq_lengths,
            seq_dim: seq_dim,
            batch_dim: None,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(input: Edge<T>, seq_lengths: Edge<Tlen>, seq_dim: i64) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            input,
            phantom_Tlen: PhantomData,
            seq_lengths,
            seq_dim: seq_dim,
            batch_dim: None,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<T> GraphOperation for XlaSend<T>
where T: TensorType,
      T: Clone,
      T: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("XlaSend_{}")?
        };
        let mut new_op = graph.new_operation("XlaSend", &op_name)?;
        {
            new_op.add_edge(&self.tensor)?
        }
        {
            (|attr| {new_op.set_attr_string("tensor_name", attr)})(&self.tensor_name)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct XlaSend<T>
where T: TensorType,
      T: Clone,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    tensor: Edge<T>,
    tensor_name: String,
    op_name: Option<String>,
    id_: usize,
}

impl<T> XlaSend<T>
where T: TensorType,
      T: Clone,
      T: 'static,
{
    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> () {
        let rc = Rc::new(self);
        (
        )
    }

    pub fn build(tensor: Edge<T>, tensor_name: &str) -> Self {
        Self {
            phantom_T: PhantomData,
            tensor,
            tensor_name: tensor_name.to_string(),
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(tensor: Edge<T>, tensor_name: &str) -> () {
        Self {
            phantom_T: PhantomData,
            tensor,
            tensor_name: tensor_name.to_string(),
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<T> GraphOperation for ApplyAdagradDA<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("ApplyAdagradDA_{}")?
        };
        let mut new_op = graph.new_operation("ApplyAdagradDA", &op_name)?;
        {
            new_op.add_edge(&self.var)?
        }
        {
            new_op.add_edge(&self.gradient_accumulator)?
        }
        {
            new_op.add_edge(&self.gradient_squared_accumulator)?
        }
        {
            new_op.add_edge(&self.grad)?
        }
        {
            new_op.add_edge(&self.lr)?
        }
        {
            new_op.add_edge(&self.l1)?
        }
        {
            new_op.add_edge(&self.l2)?
        }
        {
            new_op.add_edge(&self.global_step)?
        }
        {
            match self.use_locking {
                None => new_op.set_attr_value_proto("use_locking", &vec![40_u8, 0_u8,])?,
                Some(ref value) => (|attr: &bool| {new_op.set_attr_bool("use_locking", *attr)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct ApplyAdagradDA<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    var: Edge<T>,
    gradient_accumulator: Edge<T>,
    gradient_squared_accumulator: Edge<T>,
    grad: Edge<T>,
    lr: Edge<T>,
    l1: Edge<T>,
    l2: Edge<T>,
    global_step: Edge<i64>,
    use_locking: Option<bool>,
    op_name: Option<String>,
    id_: usize,
}

impl<T> ApplyAdagradDA<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
{
    pub fn out(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn use_locking(&mut self, use_locking: bool) -> Self {
        self.use_locking = Some(use_locking);
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(var: Edge<T>, gradient_accumulator: Edge<T>, gradient_squared_accumulator: Edge<T>, grad: Edge<T>, lr: Edge<T>, l1: Edge<T>, l2: Edge<T>, global_step: Edge<i64>) -> Self {
        Self {
            phantom_T: PhantomData,
            var,
            gradient_accumulator,
            gradient_squared_accumulator,
            grad,
            lr,
            l1,
            l2,
            global_step,
            use_locking: None,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(var: Edge<T>, gradient_accumulator: Edge<T>, gradient_squared_accumulator: Edge<T>, grad: Edge<T>, lr: Edge<T>, l1: Edge<T>, l2: Edge<T>, global_step: Edge<i64>) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            var,
            gradient_accumulator,
            gradient_squared_accumulator,
            grad,
            lr,
            l1,
            l2,
            global_step,
            use_locking: None,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<T> GraphOperation for Pack<T>
where T: TensorType,
      T: Clone,
      T: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("Pack_{}")?
        };
        let mut new_op = graph.new_operation("Pack", &op_name)?;
        {
            new_op.add_edge(&self.values)?
        }
        {
            (|attr: &i64| {new_op.set_attr_int("N", *attr)})(&self.N)?
        }
        {
            match self.axis {
                None => new_op.set_attr_value_proto("axis", &vec![24_u8, 0_u8,])?,
                Some(ref value) => (|attr: &i64| {new_op.set_attr_int("axis", *attr)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct Pack<T>
where T: TensorType,
      T: Clone,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    values: Edge<T>,
    N: i64,
    axis: Option<i64>,
    op_name: Option<String>,
    id_: usize,
}

impl<T> Pack<T>
where T: TensorType,
      T: Clone,
      T: 'static,
{
    pub fn output(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn axis(&mut self, axis: i64) -> Self {
        self.axis = Some(axis);
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(values: Edge<T>, N: i64) -> Self {
        Self {
            phantom_T: PhantomData,
            values,
            N: N,
            axis: None,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(values: Edge<T>, N: i64) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            values,
            N: N,
            axis: None,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl GraphOperation for SparseReshape {
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("SparseReshape_{}")?
        };
        let mut new_op = graph.new_operation("SparseReshape", &op_name)?;
        {
            new_op.add_edge(&self.input_indices)?
        }
        {
            new_op.add_edge(&self.input_shape)?
        }
        {
            new_op.add_edge(&self.new_shape)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct SparseReshape {
    input_indices: Edge<i64>,
    input_shape: Edge<i64>,
    new_shape: Edge<i64>,
    op_name: Option<String>,
    id_: usize,
}

impl SparseReshape {
    pub fn output_indices(self) -> Edge<i64> {
        let rc = Rc::new(self);
        {
            Edge::<i64>::new(rc.clone(), 0)
        }
    }

    pub fn output_shape(self) -> Edge<i64> {
        let rc = Rc::new(self);
        {
            Edge::<i64>::new(rc.clone(), 1)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> (Edge<i64>, Edge<i64>) {
        let rc = Rc::new(self);
        (
        {
            Edge::<i64>::new(rc.clone(), 0)
        },
        {
            Edge::<i64>::new(rc.clone(), 1)
        },
        )
    }

    pub fn build(input_indices: Edge<i64>, input_shape: Edge<i64>, new_shape: Edge<i64>) -> Self {
        Self {
            input_indices,
            input_shape,
            new_shape,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(input_indices: Edge<i64>, input_shape: Edge<i64>, new_shape: Edge<i64>) -> (Edge<i64>, Edge<i64>) {
        Self {
            input_indices,
            input_shape,
            new_shape,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<T> GraphOperation for TensorArraySplitV2<T>
where T: TensorType,
      T: Clone,
      T: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("TensorArraySplitV2_{}")?
        };
        let mut new_op = graph.new_operation("TensorArraySplitV2", &op_name)?;
        {
            new_op.add_edge(&self.handle)?
        }
        {
            new_op.add_edge(&self.value)?
        }
        {
            new_op.add_edge(&self.lengths)?
        }
        {
            new_op.add_edge(&self.flow_in)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct TensorArraySplitV2<T>
where T: TensorType,
      T: Clone,
      T: 'static,
{
    handle: Edge<String>,
    phantom_T: PhantomData<T>,
    value: Edge<T>,
    lengths: Edge<i64>,
    flow_in: Edge<f32>,
    op_name: Option<String>,
    id_: usize,
}

impl<T> TensorArraySplitV2<T>
where T: TensorType,
      T: Clone,
      T: 'static,
{
    pub fn flow_out(self) -> Edge<f32> {
        let rc = Rc::new(self);
        {
            Edge::<f32>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<f32> {
        let rc = Rc::new(self);
        {
            Edge::<f32>::new(rc.clone(), 0)
        }
    }

    pub fn build(handle: Edge<String>, value: Edge<T>, lengths: Edge<i64>, flow_in: Edge<f32>) -> Self {
        Self {
            handle,
            phantom_T: PhantomData,
            value,
            lengths,
            flow_in,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(handle: Edge<String>, value: Edge<T>, lengths: Edge<i64>, flow_in: Edge<f32>) -> Edge<f32> {
        Self {
            handle,
            phantom_T: PhantomData,
            value,
            lengths,
            flow_in,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<T> GraphOperation for AssignAdd<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("AssignAdd_{}")?
        };
        let mut new_op = graph.new_operation("AssignAdd", &op_name)?;
        {
            new_op.add_edge(&self.ref_)?
        }
        {
            new_op.add_edge(&self.value)?
        }
        {
            match self.use_locking {
                None => new_op.set_attr_value_proto("use_locking", &vec![40_u8, 0_u8,])?,
                Some(ref value) => (|attr: &bool| {new_op.set_attr_bool("use_locking", *attr)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct AssignAdd<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    ref_: Edge<T>,
    value: Edge<T>,
    use_locking: Option<bool>,
    op_name: Option<String>,
    id_: usize,
}

impl<T> AssignAdd<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
{
    pub fn output_ref(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn use_locking(&mut self, use_locking: bool) -> Self {
        self.use_locking = Some(use_locking);
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(ref_: Edge<T>, value: Edge<T>) -> Self {
        Self {
            phantom_T: PhantomData,
            ref_,
            value,
            use_locking: None,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(ref_: Edge<T>, value: Edge<T>) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            ref_,
            value,
            use_locking: None,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl GraphOperation for LoadTPUEmbeddingCenteredRMSPropParameters {
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("LoadTPUEmbeddingCenteredRMSPropParameters_{}")?
        };
        let mut new_op = graph.new_operation("LoadTPUEmbeddingCenteredRMSPropParameters", &op_name)?;
        {
            new_op.add_edge(&self.parameters)?
        }
        {
            new_op.add_edge(&self.ms)?
        }
        {
            new_op.add_edge(&self.mom)?
        }
        {
            new_op.add_edge(&self.mg)?
        }
        {
            match self.table_id {
                None => new_op.set_attr_value_proto("table_id", &vec![24_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 1_u8,])?,
                Some(ref value) => (|attr: &i64| {new_op.set_attr_int("table_id", *attr)})(&value)?,
            };
        }
        {
            match self.table_name {
                None => new_op.set_attr_value_proto("table_name", &vec![18_u8, 0_u8,])?,
                Some(ref value) => (|attr| {new_op.set_attr_string("table_name", attr)})(&value)?,
            };
        }
        {
            (|attr: &i64| {new_op.set_attr_int("num_shards", *attr)})(&self.num_shards)?
        }
        {
            (|attr: &i64| {new_op.set_attr_int("shard_id", *attr)})(&self.shard_id)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct LoadTPUEmbeddingCenteredRMSPropParameters {
    parameters: Edge<f32>,
    ms: Edge<f32>,
    mom: Edge<f32>,
    mg: Edge<f32>,
    table_id: Option<i64>,
    table_name: Option<String>,
    num_shards: i64,
    shard_id: i64,
    op_name: Option<String>,
    id_: usize,
}

impl LoadTPUEmbeddingCenteredRMSPropParameters {
    pub fn table_id(&mut self, table_id: i64) -> Self {
        self.table_id = Some(table_id);
        self.clone()
    }

    pub fn table_name(&mut self, table_name: &str) -> Self {
        self.table_name = Some(table_name.to_string());
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> () {
        let rc = Rc::new(self);
        (
        )
    }

    pub fn build(parameters: Edge<f32>, ms: Edge<f32>, mom: Edge<f32>, mg: Edge<f32>, num_shards: i64, shard_id: i64) -> Self {
        Self {
            parameters,
            ms,
            mom,
            mg,
            table_id: None,
            table_name: None,
            num_shards: num_shards,
            shard_id: shard_id,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(parameters: Edge<f32>, ms: Edge<f32>, mom: Edge<f32>, mg: Edge<f32>, num_shards: i64, shard_id: i64) -> () {
        Self {
            parameters,
            ms,
            mom,
            mg,
            table_id: None,
            table_name: None,
            num_shards: num_shards,
            shard_id: shard_id,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl GraphOperation for RetrieveTPUEmbeddingRMSPropParameters {
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("RetrieveTPUEmbeddingRMSPropParameters_{}")?
        };
        let mut new_op = graph.new_operation("RetrieveTPUEmbeddingRMSPropParameters", &op_name)?;
        {
            match self.table_id {
                None => new_op.set_attr_value_proto("table_id", &vec![24_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 1_u8,])?,
                Some(ref value) => (|attr: &i64| {new_op.set_attr_int("table_id", *attr)})(&value)?,
            };
        }
        {
            match self.table_name {
                None => new_op.set_attr_value_proto("table_name", &vec![18_u8, 0_u8,])?,
                Some(ref value) => (|attr| {new_op.set_attr_string("table_name", attr)})(&value)?,
            };
        }
        {
            (|attr: &i64| {new_op.set_attr_int("num_shards", *attr)})(&self.num_shards)?
        }
        {
            (|attr: &i64| {new_op.set_attr_int("shard_id", *attr)})(&self.shard_id)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct RetrieveTPUEmbeddingRMSPropParameters {
    table_id: Option<i64>,
    table_name: Option<String>,
    num_shards: i64,
    shard_id: i64,
    op_name: Option<String>,
    id_: usize,
}

impl RetrieveTPUEmbeddingRMSPropParameters {
    pub fn parameters(self) -> Edge<f32> {
        let rc = Rc::new(self);
        {
            Edge::<f32>::new(rc.clone(), 0)
        }
    }

    pub fn ms(self) -> Edge<f32> {
        let rc = Rc::new(self);
        {
            Edge::<f32>::new(rc.clone(), 1)
        }
    }

    pub fn mom(self) -> Edge<f32> {
        let rc = Rc::new(self);
        {
            Edge::<f32>::new(rc.clone(), 2)
        }
    }

    pub fn table_id(&mut self, table_id: i64) -> Self {
        self.table_id = Some(table_id);
        self.clone()
    }

    pub fn table_name(&mut self, table_name: &str) -> Self {
        self.table_name = Some(table_name.to_string());
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> (Edge<f32>, Edge<f32>, Edge<f32>) {
        let rc = Rc::new(self);
        (
        {
            Edge::<f32>::new(rc.clone(), 0)
        },
        {
            Edge::<f32>::new(rc.clone(), 1)
        },
        {
            Edge::<f32>::new(rc.clone(), 2)
        },
        )
    }

    pub fn build(num_shards: i64, shard_id: i64) -> Self {
        Self {
            table_id: None,
            table_name: None,
            num_shards: num_shards,
            shard_id: shard_id,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(num_shards: i64, shard_id: i64) -> (Edge<f32>, Edge<f32>, Edge<f32>) {
        Self {
            table_id: None,
            table_name: None,
            num_shards: num_shards,
            shard_id: shard_id,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<dtype> GraphOperation for Variable<dtype>
where dtype: TensorType,
      dtype: 'static,
      dtype: Clone,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("Variable_{}")?
        };
        let mut new_op = graph.new_operation("Variable", &op_name)?;
        {
            (|attr| {new_op.set_attr_shape("shape", attr)})(&self.shape)?
        }
        {
            match self.container {
                None => new_op.set_attr_value_proto("container", &vec![18_u8, 0_u8,])?,
                Some(ref value) => (|attr| {new_op.set_attr_string("container", attr)})(&value)?,
            };
        }
        {
            match self.shared_name {
                None => new_op.set_attr_value_proto("shared_name", &vec![18_u8, 0_u8,])?,
                Some(ref value) => (|attr| {new_op.set_attr_string("shared_name", attr)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct Variable<dtype>
where dtype: TensorType,
      dtype: 'static,
      dtype: Clone,
{
    shape: OtherShape,
    phantom_dtype: PhantomData<dtype>,
    container: Option<String>,
    shared_name: Option<String>,
    op_name: Option<String>,
    id_: usize,
}

impl<dtype> Variable<dtype>
where dtype: TensorType,
      dtype: 'static,
      dtype: Clone,
{
    pub fn ref_(self) -> Edge<dtype> {
        let rc = Rc::new(self);
        {
            Edge::<dtype>::new(rc.clone(), 0)
        }
    }

    pub fn container(&mut self, container: &str) -> Self {
        self.container = Some(container.to_string());
        self.clone()
    }

    pub fn shared_name(&mut self, shared_name: &str) -> Self {
        self.shared_name = Some(shared_name.to_string());
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<dtype> {
        let rc = Rc::new(self);
        {
            Edge::<dtype>::new(rc.clone(), 0)
        }
    }

    pub fn build(shape: &OtherShape) -> Self {
        Self {
            shape: shape.clone(),
            phantom_dtype: PhantomData,
            container: None,
            shared_name: None,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(shape: &OtherShape) -> Edge<dtype> {
        Self {
            shape: shape.clone(),
            phantom_dtype: PhantomData,
            container: None,
            shared_name: None,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl GraphOperation for LoadTPUEmbeddingADAMParametersGradAccumDebug {
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("LoadTPUEmbeddingADAMParametersGradAccumDebug_{}")?
        };
        let mut new_op = graph.new_operation("LoadTPUEmbeddingADAMParametersGradAccumDebug", &op_name)?;
        {
            new_op.add_edge(&self.parameters)?
        }
        {
            new_op.add_edge(&self.momenta)?
        }
        {
            new_op.add_edge(&self.velocities)?
        }
        {
            new_op.add_edge(&self.gradient_accumulators)?
        }
        {
            match self.table_id {
                None => new_op.set_attr_value_proto("table_id", &vec![24_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 1_u8,])?,
                Some(ref value) => (|attr: &i64| {new_op.set_attr_int("table_id", *attr)})(&value)?,
            };
        }
        {
            match self.table_name {
                None => new_op.set_attr_value_proto("table_name", &vec![18_u8, 0_u8,])?,
                Some(ref value) => (|attr| {new_op.set_attr_string("table_name", attr)})(&value)?,
            };
        }
        {
            (|attr: &i64| {new_op.set_attr_int("num_shards", *attr)})(&self.num_shards)?
        }
        {
            (|attr: &i64| {new_op.set_attr_int("shard_id", *attr)})(&self.shard_id)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct LoadTPUEmbeddingADAMParametersGradAccumDebug {
    parameters: Edge<f32>,
    momenta: Edge<f32>,
    velocities: Edge<f32>,
    gradient_accumulators: Edge<f32>,
    table_id: Option<i64>,
    table_name: Option<String>,
    num_shards: i64,
    shard_id: i64,
    op_name: Option<String>,
    id_: usize,
}

impl LoadTPUEmbeddingADAMParametersGradAccumDebug {
    pub fn table_id(&mut self, table_id: i64) -> Self {
        self.table_id = Some(table_id);
        self.clone()
    }

    pub fn table_name(&mut self, table_name: &str) -> Self {
        self.table_name = Some(table_name.to_string());
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> () {
        let rc = Rc::new(self);
        (
        )
    }

    pub fn build(parameters: Edge<f32>, momenta: Edge<f32>, velocities: Edge<f32>, gradient_accumulators: Edge<f32>, num_shards: i64, shard_id: i64) -> Self {
        Self {
            parameters,
            momenta,
            velocities,
            gradient_accumulators,
            table_id: None,
            table_name: None,
            num_shards: num_shards,
            shard_id: shard_id,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(parameters: Edge<f32>, momenta: Edge<f32>, velocities: Edge<f32>, gradient_accumulators: Edge<f32>, num_shards: i64, shard_id: i64) -> () {
        Self {
            parameters,
            momenta,
            velocities,
            gradient_accumulators,
            table_id: None,
            table_name: None,
            num_shards: num_shards,
            shard_id: shard_id,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<T> GraphOperation for AddManySparseToTensorsMap<T>
where T: TensorType,
      T: Clone,
      T: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("AddManySparseToTensorsMap_{}")?
        };
        let mut new_op = graph.new_operation("AddManySparseToTensorsMap", &op_name)?;
        {
            new_op.add_edge(&self.sparse_indices)?
        }
        {
            new_op.add_edge(&self.sparse_values)?
        }
        {
            new_op.add_edge(&self.sparse_shape)?
        }
        {
            match self.container {
                None => new_op.set_attr_value_proto("container", &vec![18_u8, 0_u8,])?,
                Some(ref value) => (|attr| {new_op.set_attr_string("container", attr)})(&value)?,
            };
        }
        {
            match self.shared_name {
                None => new_op.set_attr_value_proto("shared_name", &vec![18_u8, 0_u8,])?,
                Some(ref value) => (|attr| {new_op.set_attr_string("shared_name", attr)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct AddManySparseToTensorsMap<T>
where T: TensorType,
      T: Clone,
      T: 'static,
{
    sparse_indices: Edge<i64>,
    phantom_T: PhantomData<T>,
    sparse_values: Edge<T>,
    sparse_shape: Edge<i64>,
    container: Option<String>,
    shared_name: Option<String>,
    op_name: Option<String>,
    id_: usize,
}

impl<T> AddManySparseToTensorsMap<T>
where T: TensorType,
      T: Clone,
      T: 'static,
{
    pub fn sparse_handles(self) -> Edge<i64> {
        let rc = Rc::new(self);
        {
            Edge::<i64>::new(rc.clone(), 0)
        }
    }

    pub fn container(&mut self, container: &str) -> Self {
        self.container = Some(container.to_string());
        self.clone()
    }

    pub fn shared_name(&mut self, shared_name: &str) -> Self {
        self.shared_name = Some(shared_name.to_string());
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<i64> {
        let rc = Rc::new(self);
        {
            Edge::<i64>::new(rc.clone(), 0)
        }
    }

    pub fn build(sparse_indices: Edge<i64>, sparse_values: Edge<T>, sparse_shape: Edge<i64>) -> Self {
        Self {
            sparse_indices,
            phantom_T: PhantomData,
            sparse_values,
            sparse_shape,
            container: None,
            shared_name: None,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(sparse_indices: Edge<i64>, sparse_values: Edge<T>, sparse_shape: Edge<i64>) -> Edge<i64> {
        Self {
            sparse_indices,
            phantom_T: PhantomData,
            sparse_values,
            sparse_shape,
            container: None,
            shared_name: None,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<Tin, Tout> GraphOperation for LookupTableImport<Tin, Tout>
where Tin: TensorType,
      Tin: Clone,
      Tout: TensorType,
      Tout: Clone,
      Tin: 'static,
      Tout: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("LookupTableImport_{}")?
        };
        let mut new_op = graph.new_operation("LookupTableImport", &op_name)?;
        {
            new_op.add_edge(&self.table_handle)?
        }
        {
            new_op.add_edge(&self.keys)?
        }
        {
            new_op.add_edge(&self.values)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct LookupTableImport<Tin, Tout>
where Tin: TensorType,
      Tin: Clone,
      Tout: TensorType,
      Tout: Clone,
      Tin: 'static,
      Tout: 'static,
{
    table_handle: Edge<String>,
    phantom_Tin: PhantomData<Tin>,
    keys: Edge<Tin>,
    phantom_Tout: PhantomData<Tout>,
    values: Edge<Tout>,
    op_name: Option<String>,
    id_: usize,
}

impl<Tin, Tout> LookupTableImport<Tin, Tout>
where Tin: TensorType,
      Tin: Clone,
      Tout: TensorType,
      Tout: Clone,
      Tin: 'static,
      Tout: 'static,
{
    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> () {
        let rc = Rc::new(self);
        (
        )
    }

    pub fn build(table_handle: Edge<String>, keys: Edge<Tin>, values: Edge<Tout>) -> Self {
        Self {
            table_handle,
            phantom_Tin: PhantomData,
            keys,
            phantom_Tout: PhantomData,
            values,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(table_handle: Edge<String>, keys: Edge<Tin>, values: Edge<Tout>) -> () {
        Self {
            table_handle,
            phantom_Tin: PhantomData,
            keys,
            phantom_Tout: PhantomData,
            values,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl GraphOperation for LoadTPUEmbeddingAdadeltaParameters {
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("LoadTPUEmbeddingAdadeltaParameters_{}")?
        };
        let mut new_op = graph.new_operation("LoadTPUEmbeddingAdadeltaParameters", &op_name)?;
        {
            new_op.add_edge(&self.parameters)?
        }
        {
            new_op.add_edge(&self.accumulators)?
        }
        {
            new_op.add_edge(&self.updates)?
        }
        {
            match self.table_id {
                None => new_op.set_attr_value_proto("table_id", &vec![24_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 1_u8,])?,
                Some(ref value) => (|attr: &i64| {new_op.set_attr_int("table_id", *attr)})(&value)?,
            };
        }
        {
            match self.table_name {
                None => new_op.set_attr_value_proto("table_name", &vec![18_u8, 0_u8,])?,
                Some(ref value) => (|attr| {new_op.set_attr_string("table_name", attr)})(&value)?,
            };
        }
        {
            (|attr: &i64| {new_op.set_attr_int("num_shards", *attr)})(&self.num_shards)?
        }
        {
            (|attr: &i64| {new_op.set_attr_int("shard_id", *attr)})(&self.shard_id)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct LoadTPUEmbeddingAdadeltaParameters {
    parameters: Edge<f32>,
    accumulators: Edge<f32>,
    updates: Edge<f32>,
    table_id: Option<i64>,
    table_name: Option<String>,
    num_shards: i64,
    shard_id: i64,
    op_name: Option<String>,
    id_: usize,
}

impl LoadTPUEmbeddingAdadeltaParameters {
    pub fn table_id(&mut self, table_id: i64) -> Self {
        self.table_id = Some(table_id);
        self.clone()
    }

    pub fn table_name(&mut self, table_name: &str) -> Self {
        self.table_name = Some(table_name.to_string());
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> () {
        let rc = Rc::new(self);
        (
        )
    }

    pub fn build(parameters: Edge<f32>, accumulators: Edge<f32>, updates: Edge<f32>, num_shards: i64, shard_id: i64) -> Self {
        Self {
            parameters,
            accumulators,
            updates,
            table_id: None,
            table_name: None,
            num_shards: num_shards,
            shard_id: shard_id,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(parameters: Edge<f32>, accumulators: Edge<f32>, updates: Edge<f32>, num_shards: i64, shard_id: i64) -> () {
        Self {
            parameters,
            accumulators,
            updates,
            table_id: None,
            table_name: None,
            num_shards: num_shards,
            shard_id: shard_id,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl GraphOperation for TPUCompilationResult {
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("TPUCompilationResult_{}")?
        };
        let mut new_op = graph.new_operation("TPUCompilationResult", &op_name)?;
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct TPUCompilationResult {
    op_name: Option<String>,
    id_: usize,
}

impl TPUCompilationResult {
    pub fn output(self) -> Edge<String> {
        let rc = Rc::new(self);
        {
            Edge::<String>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<String> {
        let rc = Rc::new(self);
        {
            Edge::<String>::new(rc.clone(), 0)
        }
    }

    pub fn build() -> Self {
        Self {
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new() -> Edge<String> {
        Self {
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl GraphOperation for GcsConfigureCredentials {
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("GcsConfigureCredentials_{}")?
        };
        let mut new_op = graph.new_operation("GcsConfigureCredentials", &op_name)?;
        {
            new_op.add_edge(&self.json)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct GcsConfigureCredentials {
    json: Edge<String>,
    op_name: Option<String>,
    id_: usize,
}

impl GcsConfigureCredentials {
    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> () {
        let rc = Rc::new(self);
        (
        )
    }

    pub fn build(json: Edge<String>) -> Self {
        Self {
            json,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(json: Edge<String>) -> () {
        Self {
            json,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl GraphOperation for ReaderNumWorkUnitsCompleted {
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("ReaderNumWorkUnitsCompleted_{}")?
        };
        let mut new_op = graph.new_operation("ReaderNumWorkUnitsCompleted", &op_name)?;
        {
            new_op.add_edge(&self.reader_handle)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct ReaderNumWorkUnitsCompleted {
    reader_handle: Edge<String>,
    op_name: Option<String>,
    id_: usize,
}

impl ReaderNumWorkUnitsCompleted {
    pub fn units_completed(self) -> Edge<i64> {
        let rc = Rc::new(self);
        {
            Edge::<i64>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<i64> {
        let rc = Rc::new(self);
        {
            Edge::<i64>::new(rc.clone(), 0)
        }
    }

    pub fn build(reader_handle: Edge<String>) -> Self {
        Self {
            reader_handle,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(reader_handle: Edge<String>) -> Edge<i64> {
        Self {
            reader_handle,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<T> GraphOperation for XlaClusterOutput<T>
where T: TensorType,
      T: Clone,
      T: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("XlaClusterOutput_{}")?
        };
        let mut new_op = graph.new_operation("XlaClusterOutput", &op_name)?;
        {
            new_op.add_edge(&self.input)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct XlaClusterOutput<T>
where T: TensorType,
      T: Clone,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    input: Edge<T>,
    op_name: Option<String>,
    id_: usize,
}

impl<T> XlaClusterOutput<T>
where T: TensorType,
      T: Clone,
      T: 'static,
{
    pub fn outputs(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(input: Edge<T>) -> Self {
        Self {
            phantom_T: PhantomData,
            input,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(input: Edge<T>) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            input,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<T, Index> GraphOperation for StridedSlice<T, Index>
where T: TensorType,
      T: Clone,
      Index: TensorType,
      Index: Clone,
      T: 'static,
      Index: con_or_DT_INT32_or_DT_INT64,
      Index: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("StridedSlice_{}")?
        };
        let mut new_op = graph.new_operation("StridedSlice", &op_name)?;
        {
            new_op.add_edge(&self.input)?
        }
        {
            new_op.add_edge(&self.begin)?
        }
        {
            new_op.add_edge(&self.end)?
        }
        {
            new_op.add_edge(&self.strides)?
        }
        {
            match self.begin_mask {
                None => new_op.set_attr_value_proto("begin_mask", &vec![24_u8, 0_u8,])?,
                Some(ref value) => (|attr: &i64| {new_op.set_attr_int("begin_mask", *attr)})(&value)?,
            };
        }
        {
            match self.end_mask {
                None => new_op.set_attr_value_proto("end_mask", &vec![24_u8, 0_u8,])?,
                Some(ref value) => (|attr: &i64| {new_op.set_attr_int("end_mask", *attr)})(&value)?,
            };
        }
        {
            match self.ellipsis_mask {
                None => new_op.set_attr_value_proto("ellipsis_mask", &vec![24_u8, 0_u8,])?,
                Some(ref value) => (|attr: &i64| {new_op.set_attr_int("ellipsis_mask", *attr)})(&value)?,
            };
        }
        {
            match self.new_axis_mask {
                None => new_op.set_attr_value_proto("new_axis_mask", &vec![24_u8, 0_u8,])?,
                Some(ref value) => (|attr: &i64| {new_op.set_attr_int("new_axis_mask", *attr)})(&value)?,
            };
        }
        {
            match self.shrink_axis_mask {
                None => new_op.set_attr_value_proto("shrink_axis_mask", &vec![24_u8, 0_u8,])?,
                Some(ref value) => (|attr: &i64| {new_op.set_attr_int("shrink_axis_mask", *attr)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct StridedSlice<T, Index>
where T: TensorType,
      T: Clone,
      Index: TensorType,
      Index: Clone,
      T: 'static,
      Index: con_or_DT_INT32_or_DT_INT64,
      Index: 'static,
{
    phantom_T: PhantomData<T>,
    input: Edge<T>,
    phantom_Index: PhantomData<Index>,
    begin: Edge<Index>,
    end: Edge<Index>,
    strides: Edge<Index>,
    begin_mask: Option<i64>,
    end_mask: Option<i64>,
    ellipsis_mask: Option<i64>,
    new_axis_mask: Option<i64>,
    shrink_axis_mask: Option<i64>,
    op_name: Option<String>,
    id_: usize,
}

impl<T, Index> StridedSlice<T, Index>
where T: TensorType,
      T: Clone,
      Index: TensorType,
      Index: Clone,
      T: 'static,
      Index: con_or_DT_INT32_or_DT_INT64,
      Index: 'static,
{
    pub fn output(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn begin_mask(&mut self, begin_mask: i64) -> Self {
        self.begin_mask = Some(begin_mask);
        self.clone()
    }

    pub fn end_mask(&mut self, end_mask: i64) -> Self {
        self.end_mask = Some(end_mask);
        self.clone()
    }

    pub fn ellipsis_mask(&mut self, ellipsis_mask: i64) -> Self {
        self.ellipsis_mask = Some(ellipsis_mask);
        self.clone()
    }

    pub fn new_axis_mask(&mut self, new_axis_mask: i64) -> Self {
        self.new_axis_mask = Some(new_axis_mask);
        self.clone()
    }

    pub fn shrink_axis_mask(&mut self, shrink_axis_mask: i64) -> Self {
        self.shrink_axis_mask = Some(shrink_axis_mask);
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(input: Edge<T>, begin: Edge<Index>, end: Edge<Index>, strides: Edge<Index>) -> Self {
        Self {
            phantom_T: PhantomData,
            input,
            phantom_Index: PhantomData,
            begin,
            end,
            strides,
            begin_mask: None,
            end_mask: None,
            ellipsis_mask: None,
            new_axis_mask: None,
            shrink_axis_mask: None,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(input: Edge<T>, begin: Edge<Index>, end: Edge<Index>, strides: Edge<Index>) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            input,
            phantom_Index: PhantomData,
            begin,
            end,
            strides,
            begin_mask: None,
            end_mask: None,
            ellipsis_mask: None,
            new_axis_mask: None,
            shrink_axis_mask: None,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<T> GraphOperation for TPUReplicatedOutput<T>
where T: TensorType,
      T: Clone,
      T: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("TPUReplicatedOutput_{}")?
        };
        let mut new_op = graph.new_operation("TPUReplicatedOutput", &op_name)?;
        {
            new_op.add_edge(&self.input)?
        }
        {
            (|attr: &i64| {new_op.set_attr_int("num_replicas", *attr)})(&self.num_replicas)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct TPUReplicatedOutput<T>
where T: TensorType,
      T: Clone,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    input: Edge<T>,
    num_replicas: i64,
    op_name: Option<String>,
    id_: usize,
}

impl<T> TPUReplicatedOutput<T>
where T: TensorType,
      T: Clone,
      T: 'static,
{
    pub fn outputs(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(input: Edge<T>, num_replicas: i64) -> Self {
        Self {
            phantom_T: PhantomData,
            input,
            num_replicas: num_replicas,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(input: Edge<T>, num_replicas: i64) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            input,
            num_replicas: num_replicas,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

pub trait con_or_DT_FLOAT_or_DT_BFLOAT16 {
}

impl con_or_DT_FLOAT_or_DT_BFLOAT16 for BFloat16 {
}

impl con_or_DT_FLOAT_or_DT_BFLOAT16 for f32 {
}

impl<T> GraphOperation for CrossReplicaSum<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_BFLOAT16,
      T: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("CrossReplicaSum_{}")?
        };
        let mut new_op = graph.new_operation("CrossReplicaSum", &op_name)?;
        {
            new_op.add_edge(&self.input)?
        }
        {
            new_op.add_edge(&self.group_assignment)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct CrossReplicaSum<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_BFLOAT16,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    input: Edge<T>,
    group_assignment: Edge<i32>,
    op_name: Option<String>,
    id_: usize,
}

impl<T> CrossReplicaSum<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_BFLOAT16,
      T: 'static,
{
    pub fn output(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(input: Edge<T>, group_assignment: Edge<i32>) -> Self {
        Self {
            phantom_T: PhantomData,
            input,
            group_assignment,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(input: Edge<T>, group_assignment: Edge<i32>) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            input,
            group_assignment,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl GraphOperation for FakeQuantWithMinMaxVarsGradient {
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("FakeQuantWithMinMaxVarsGradient_{}")?
        };
        let mut new_op = graph.new_operation("FakeQuantWithMinMaxVarsGradient", &op_name)?;
        {
            new_op.add_edge(&self.gradients)?
        }
        {
            new_op.add_edge(&self.inputs)?
        }
        {
            new_op.add_edge(&self.min)?
        }
        {
            new_op.add_edge(&self.max)?
        }
        {
            match self.num_bits {
                None => new_op.set_attr_value_proto("num_bits", &vec![24_u8, 8_u8,])?,
                Some(ref value) => (|attr: &i64| {new_op.set_attr_int("num_bits", *attr)})(&value)?,
            };
        }
        {
            match self.narrow_range {
                None => new_op.set_attr_value_proto("narrow_range", &vec![40_u8, 0_u8,])?,
                Some(ref value) => (|attr: &bool| {new_op.set_attr_bool("narrow_range", *attr)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct FakeQuantWithMinMaxVarsGradient {
    gradients: Edge<f32>,
    inputs: Edge<f32>,
    min: Edge<f32>,
    max: Edge<f32>,
    num_bits: Option<i64>,
    narrow_range: Option<bool>,
    op_name: Option<String>,
    id_: usize,
}

impl FakeQuantWithMinMaxVarsGradient {
    pub fn backprops_wrt_input(self) -> Edge<f32> {
        let rc = Rc::new(self);
        {
            Edge::<f32>::new(rc.clone(), 0)
        }
    }

    pub fn backprop_wrt_min(self) -> Edge<f32> {
        let rc = Rc::new(self);
        {
            Edge::<f32>::new(rc.clone(), 1)
        }
    }

    pub fn backprop_wrt_max(self) -> Edge<f32> {
        let rc = Rc::new(self);
        {
            Edge::<f32>::new(rc.clone(), 2)
        }
    }

    pub fn num_bits(&mut self, num_bits: i64) -> Self {
        self.num_bits = Some(num_bits);
        self.clone()
    }

    pub fn narrow_range(&mut self, narrow_range: bool) -> Self {
        self.narrow_range = Some(narrow_range);
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> (Edge<f32>, Edge<f32>, Edge<f32>) {
        let rc = Rc::new(self);
        (
        {
            Edge::<f32>::new(rc.clone(), 0)
        },
        {
            Edge::<f32>::new(rc.clone(), 1)
        },
        {
            Edge::<f32>::new(rc.clone(), 2)
        },
        )
    }

    pub fn build(gradients: Edge<f32>, inputs: Edge<f32>, min: Edge<f32>, max: Edge<f32>) -> Self {
        Self {
            gradients,
            inputs,
            min,
            max,
            num_bits: None,
            narrow_range: None,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(gradients: Edge<f32>, inputs: Edge<f32>, min: Edge<f32>, max: Edge<f32>) -> (Edge<f32>, Edge<f32>, Edge<f32>) {
        Self {
            gradients,
            inputs,
            min,
            max,
            num_bits: None,
            narrow_range: None,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl GraphOperation for InitializeTableFromTextFile {
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("InitializeTableFromTextFile_{}")?
        };
        let mut new_op = graph.new_operation("InitializeTableFromTextFile", &op_name)?;
        {
            new_op.add_edge(&self.table_handle)?
        }
        {
            new_op.add_edge(&self.filename)?
        }
        {
            (|attr: &i64| {new_op.set_attr_int("key_index", *attr)})(&self.key_index)?
        }
        {
            (|attr: &i64| {new_op.set_attr_int("value_index", *attr)})(&self.value_index)?
        }
        {
            match self.vocab_size {
                None => new_op.set_attr_value_proto("vocab_size", &vec![24_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 1_u8,])?,
                Some(ref value) => (|attr: &i64| {new_op.set_attr_int("vocab_size", *attr)})(&value)?,
            };
        }
        {
            match self.delimiter {
                None => new_op.set_attr_value_proto("delimiter", &vec![18_u8, 1_u8,])?,
                Some(ref value) => (|attr| {new_op.set_attr_string("delimiter", attr)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct InitializeTableFromTextFile {
    table_handle: Edge<String>,
    filename: Edge<String>,
    key_index: i64,
    value_index: i64,
    vocab_size: Option<i64>,
    delimiter: Option<String>,
    op_name: Option<String>,
    id_: usize,
}

impl InitializeTableFromTextFile {
    pub fn vocab_size(&mut self, vocab_size: i64) -> Self {
        self.vocab_size = Some(vocab_size);
        self.clone()
    }

    pub fn delimiter(&mut self, delimiter: &str) -> Self {
        self.delimiter = Some(delimiter.to_string());
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> () {
        let rc = Rc::new(self);
        (
        )
    }

    pub fn build(table_handle: Edge<String>, filename: Edge<String>, key_index: i64, value_index: i64) -> Self {
        Self {
            table_handle,
            filename,
            key_index: key_index,
            value_index: value_index,
            vocab_size: None,
            delimiter: None,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(table_handle: Edge<String>, filename: Edge<String>, key_index: i64, value_index: i64) -> () {
        Self {
            table_handle,
            filename,
            key_index: key_index,
            value_index: value_index,
            vocab_size: None,
            delimiter: None,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<T> GraphOperation for _Send<T>
where T: TensorType,
      T: Clone,
      T: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("_Send_{}")?
        };
        let mut new_op = graph.new_operation("_Send", &op_name)?;
        {
            new_op.add_edge(&self.tensor)?
        }
        {
            (|attr| {new_op.set_attr_string("tensor_name", attr)})(&self.tensor_name)?
        }
        {
            (|attr| {new_op.set_attr_string("send_device", attr)})(&self.send_device)?
        }
        {
            (|attr: &i64| {new_op.set_attr_int("send_device_incarnation", *attr)})(&self.send_device_incarnation)?
        }
        {
            (|attr| {new_op.set_attr_string("recv_device", attr)})(&self.recv_device)?
        }
        {
            match self.client_terminated {
                None => new_op.set_attr_value_proto("client_terminated", &vec![40_u8, 0_u8,])?,
                Some(ref value) => (|attr: &bool| {new_op.set_attr_bool("client_terminated", *attr)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct _Send<T>
where T: TensorType,
      T: Clone,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    tensor: Edge<T>,
    tensor_name: String,
    send_device: String,
    send_device_incarnation: i64,
    recv_device: String,
    client_terminated: Option<bool>,
    op_name: Option<String>,
    id_: usize,
}

impl<T> _Send<T>
where T: TensorType,
      T: Clone,
      T: 'static,
{
    pub fn client_terminated(&mut self, client_terminated: bool) -> Self {
        self.client_terminated = Some(client_terminated);
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> () {
        let rc = Rc::new(self);
        (
        )
    }

    pub fn build(tensor: Edge<T>, tensor_name: &str, send_device: &str, send_device_incarnation: i64, recv_device: &str) -> Self {
        Self {
            phantom_T: PhantomData,
            tensor,
            tensor_name: tensor_name.to_string(),
            send_device: send_device.to_string(),
            send_device_incarnation: send_device_incarnation,
            recv_device: recv_device.to_string(),
            client_terminated: None,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(tensor: Edge<T>, tensor_name: &str, send_device: &str, send_device_incarnation: i64, recv_device: &str) -> () {
        Self {
            phantom_T: PhantomData,
            tensor,
            tensor_name: tensor_name.to_string(),
            send_device: send_device.to_string(),
            send_device_incarnation: send_device_incarnation,
            recv_device: recv_device.to_string(),
            client_terminated: None,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<T> GraphOperation for Minimum<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_INT64_or_DT_BFLOAT16_or_DT_HALF,
      T: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("Minimum_{}")?
        };
        let mut new_op = graph.new_operation("Minimum", &op_name)?;
        {
            new_op.add_edge(&self.x)?
        }
        {
            new_op.add_edge(&self.y)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct Minimum<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_INT64_or_DT_BFLOAT16_or_DT_HALF,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    x: Edge<T>,
    y: Edge<T>,
    op_name: Option<String>,
    id_: usize,
}

impl<T> Minimum<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_INT64_or_DT_BFLOAT16_or_DT_HALF,
      T: 'static,
{
    pub fn z(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(x: Edge<T>, y: Edge<T>) -> Self {
        Self {
            phantom_T: PhantomData,
            x,
            y,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(x: Edge<T>, y: Edge<T>) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            x,
            y,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<T> GraphOperation for ParallelConcat<T>
where T: TensorType,
      T: Clone,
      T: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("ParallelConcat_{}")?
        };
        let mut new_op = graph.new_operation("ParallelConcat", &op_name)?;
        {
            new_op.add_edge(&self.values)?
        }
        {
            (|attr: &i64| {new_op.set_attr_int("N", *attr)})(&self.N)?
        }
        {
            (|attr| {new_op.set_attr_shape("shape", attr)})(&self.shape)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct ParallelConcat<T>
where T: TensorType,
      T: Clone,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    values: Edge<T>,
    N: i64,
    shape: OtherShape,
    op_name: Option<String>,
    id_: usize,
}

impl<T> ParallelConcat<T>
where T: TensorType,
      T: Clone,
      T: 'static,
{
    pub fn output(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(values: Edge<T>, N: i64, shape: &OtherShape) -> Self {
        Self {
            phantom_T: PhantomData,
            values,
            N: N,
            shape: shape.clone(),
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(values: Edge<T>, N: i64, shape: &OtherShape) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            values,
            N: N,
            shape: shape.clone(),
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<dtype> GraphOperation for OutfeedDequeue<dtype>
where dtype: TensorType,
      dtype: 'static,
      dtype: Clone,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("OutfeedDequeue_{}")?
        };
        let mut new_op = graph.new_operation("OutfeedDequeue", &op_name)?;
        {
            (|attr| {new_op.set_attr_shape("shape", attr)})(&self.shape)?
        }
        {
            match self.device_ordinal {
                None => new_op.set_attr_value_proto("device_ordinal", &vec![24_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 1_u8,])?,
                Some(ref value) => (|attr: &i64| {new_op.set_attr_int("device_ordinal", *attr)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct OutfeedDequeue<dtype>
where dtype: TensorType,
      dtype: 'static,
      dtype: Clone,
{
    phantom_dtype: PhantomData<dtype>,
    shape: OtherShape,
    device_ordinal: Option<i64>,
    op_name: Option<String>,
    id_: usize,
}

impl<dtype> OutfeedDequeue<dtype>
where dtype: TensorType,
      dtype: 'static,
      dtype: Clone,
{
    pub fn output(self) -> Edge<dtype> {
        let rc = Rc::new(self);
        {
            Edge::<dtype>::new(rc.clone(), 0)
        }
    }

    pub fn device_ordinal(&mut self, device_ordinal: i64) -> Self {
        self.device_ordinal = Some(device_ordinal);
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<dtype> {
        let rc = Rc::new(self);
        {
            Edge::<dtype>::new(rc.clone(), 0)
        }
    }

    pub fn build(shape: &OtherShape) -> Self {
        Self {
            phantom_dtype: PhantomData,
            shape: shape.clone(),
            device_ordinal: None,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(shape: &OtherShape) -> Edge<dtype> {
        Self {
            phantom_dtype: PhantomData,
            shape: shape.clone(),
            device_ordinal: None,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl GraphOperation for RetrieveTPUEmbeddingAdagradParametersGradAccumDebug {
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("RetrieveTPUEmbeddingAdagradParametersGradAccumDebug_{}")?
        };
        let mut new_op = graph.new_operation("RetrieveTPUEmbeddingAdagradParametersGradAccumDebug", &op_name)?;
        {
            match self.table_id {
                None => new_op.set_attr_value_proto("table_id", &vec![24_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 1_u8,])?,
                Some(ref value) => (|attr: &i64| {new_op.set_attr_int("table_id", *attr)})(&value)?,
            };
        }
        {
            match self.table_name {
                None => new_op.set_attr_value_proto("table_name", &vec![18_u8, 0_u8,])?,
                Some(ref value) => (|attr| {new_op.set_attr_string("table_name", attr)})(&value)?,
            };
        }
        {
            (|attr: &i64| {new_op.set_attr_int("num_shards", *attr)})(&self.num_shards)?
        }
        {
            (|attr: &i64| {new_op.set_attr_int("shard_id", *attr)})(&self.shard_id)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct RetrieveTPUEmbeddingAdagradParametersGradAccumDebug {
    table_id: Option<i64>,
    table_name: Option<String>,
    num_shards: i64,
    shard_id: i64,
    op_name: Option<String>,
    id_: usize,
}

impl RetrieveTPUEmbeddingAdagradParametersGradAccumDebug {
    pub fn parameters(self) -> Edge<f32> {
        let rc = Rc::new(self);
        {
            Edge::<f32>::new(rc.clone(), 0)
        }
    }

    pub fn accumulators(self) -> Edge<f32> {
        let rc = Rc::new(self);
        {
            Edge::<f32>::new(rc.clone(), 1)
        }
    }

    pub fn gradient_accumulators(self) -> Edge<f32> {
        let rc = Rc::new(self);
        {
            Edge::<f32>::new(rc.clone(), 2)
        }
    }

    pub fn table_id(&mut self, table_id: i64) -> Self {
        self.table_id = Some(table_id);
        self.clone()
    }

    pub fn table_name(&mut self, table_name: &str) -> Self {
        self.table_name = Some(table_name.to_string());
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> (Edge<f32>, Edge<f32>, Edge<f32>) {
        let rc = Rc::new(self);
        (
        {
            Edge::<f32>::new(rc.clone(), 0)
        },
        {
            Edge::<f32>::new(rc.clone(), 1)
        },
        {
            Edge::<f32>::new(rc.clone(), 2)
        },
        )
    }

    pub fn build(num_shards: i64, shard_id: i64) -> Self {
        Self {
            table_id: None,
            table_name: None,
            num_shards: num_shards,
            shard_id: shard_id,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(num_shards: i64, shard_id: i64) -> (Edge<f32>, Edge<f32>, Edge<f32>) {
        Self {
            table_id: None,
            table_name: None,
            num_shards: num_shards,
            shard_id: shard_id,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<T> GraphOperation for CholeskyGrad<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE,
      T: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("CholeskyGrad_{}")?
        };
        let mut new_op = graph.new_operation("CholeskyGrad", &op_name)?;
        {
            new_op.add_edge(&self.l)?
        }
        {
            new_op.add_edge(&self.grad)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct CholeskyGrad<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    l: Edge<T>,
    grad: Edge<T>,
    op_name: Option<String>,
    id_: usize,
}

impl<T> CholeskyGrad<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE,
      T: 'static,
{
    pub fn output(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(l: Edge<T>, grad: Edge<T>) -> Self {
        Self {
            phantom_T: PhantomData,
            l,
            grad,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(l: Edge<T>, grad: Edge<T>) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            l,
            grad,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<T> GraphOperation for Atanh<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_COMPLEX64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF,
      T: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("Atanh_{}")?
        };
        let mut new_op = graph.new_operation("Atanh", &op_name)?;
        {
            new_op.add_edge(&self.x)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct Atanh<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_COMPLEX64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    x: Edge<T>,
    op_name: Option<String>,
    id_: usize,
}

impl<T> Atanh<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_COMPLEX64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF,
      T: 'static,
{
    pub fn y(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(x: Edge<T>) -> Self {
        Self {
            phantom_T: PhantomData,
            x,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(x: Edge<T>) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            x,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<T> GraphOperation for AllToAll<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_BFLOAT16,
      T: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("AllToAll_{}")?
        };
        let mut new_op = graph.new_operation("AllToAll", &op_name)?;
        {
            new_op.add_edge(&self.input)?
        }
        {
            new_op.add_edge(&self.group_assignment)?
        }
        {
            (|attr: &i64| {new_op.set_attr_int("concat_dimension", *attr)})(&self.concat_dimension)?
        }
        {
            (|attr: &i64| {new_op.set_attr_int("split_dimension", *attr)})(&self.split_dimension)?
        }
        {
            (|attr: &i64| {new_op.set_attr_int("split_count", *attr)})(&self.split_count)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct AllToAll<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_BFLOAT16,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    input: Edge<T>,
    group_assignment: Edge<i32>,
    concat_dimension: i64,
    split_dimension: i64,
    split_count: i64,
    op_name: Option<String>,
    id_: usize,
}

impl<T> AllToAll<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_BFLOAT16,
      T: 'static,
{
    pub fn output(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(input: Edge<T>, group_assignment: Edge<i32>, concat_dimension: i64, split_dimension: i64, split_count: i64) -> Self {
        Self {
            phantom_T: PhantomData,
            input,
            group_assignment,
            concat_dimension: concat_dimension,
            split_dimension: split_dimension,
            split_count: split_count,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(input: Edge<T>, group_assignment: Edge<i32>, concat_dimension: i64, split_dimension: i64, split_count: i64) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            input,
            group_assignment,
            concat_dimension: concat_dimension,
            split_dimension: split_dimension,
            split_count: split_count,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<T> GraphOperation for CudnnRNNV2<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_HALF,
      T: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("CudnnRNNV2_{}")?
        };
        let mut new_op = graph.new_operation("CudnnRNNV2", &op_name)?;
        {
            new_op.add_edge(&self.input)?
        }
        {
            new_op.add_edge(&self.input_h)?
        }
        {
            new_op.add_edge(&self.input_c)?
        }
        {
            new_op.add_edge(&self.params)?
        }
        {
            match self.rnn_mode {
                None => new_op.set_attr_value_proto("rnn_mode", &vec![18_u8, 4_u8, 108_u8, 115_u8, 116_u8, 109_u8,])?,
                Some(ref value) => (|attr| {new_op.set_attr_string("rnn_mode", attr)})(&value)?,
            };
        }
        {
            match self.input_mode {
                None => new_op.set_attr_value_proto("input_mode", &vec![18_u8, 12_u8, 108_u8, 105_u8, 110_u8, 101_u8, 97_u8, 114_u8, 95_u8, 105_u8, 110_u8, 112_u8, 117_u8, 116_u8,])?,
                Some(ref value) => (|attr| {new_op.set_attr_string("input_mode", attr)})(&value)?,
            };
        }
        {
            match self.direction {
                None => new_op.set_attr_value_proto("direction", &vec![18_u8, 14_u8, 117_u8, 110_u8, 105_u8, 100_u8, 105_u8, 114_u8, 101_u8, 99_u8, 116_u8, 105_u8, 111_u8, 110_u8, 97_u8, 108_u8,])?,
                Some(ref value) => (|attr| {new_op.set_attr_string("direction", attr)})(&value)?,
            };
        }
        {
            match self.dropout {
                None => new_op.set_attr_value_proto("dropout", &vec![37_u8, 0_u8, 0_u8, 0_u8, 0_u8,])?,
                Some(ref value) => (|attr: &f32| {new_op.set_attr_float("dropout", *attr)})(&value)?,
            };
        }
        {
            match self.seed {
                None => new_op.set_attr_value_proto("seed", &vec![24_u8, 0_u8,])?,
                Some(ref value) => (|attr: &i64| {new_op.set_attr_int("seed", *attr)})(&value)?,
            };
        }
        {
            match self.seed2 {
                None => new_op.set_attr_value_proto("seed2", &vec![24_u8, 0_u8,])?,
                Some(ref value) => (|attr: &i64| {new_op.set_attr_int("seed2", *attr)})(&value)?,
            };
        }
        {
            match self.is_training {
                None => new_op.set_attr_value_proto("is_training", &vec![40_u8, 1_u8,])?,
                Some(ref value) => (|attr: &bool| {new_op.set_attr_bool("is_training", *attr)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct CudnnRNNV2<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_HALF,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    input: Edge<T>,
    input_h: Edge<T>,
    input_c: Edge<T>,
    params: Edge<T>,
    rnn_mode: Option<String>,
    input_mode: Option<String>,
    direction: Option<String>,
    dropout: Option<f32>,
    seed: Option<i64>,
    seed2: Option<i64>,
    is_training: Option<bool>,
    op_name: Option<String>,
    id_: usize,
}

impl<T> CudnnRNNV2<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_HALF,
      T: 'static,
{
    pub fn output(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn output_h(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 1)
        }
    }

    pub fn output_c(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 2)
        }
    }

    pub fn reserve_space(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 3)
        }
    }

    pub fn host_reserved(self) -> Edge<i8> {
        let rc = Rc::new(self);
        {
            Edge::<i8>::new(rc.clone(), 4)
        }
    }

    pub fn rnn_mode(&mut self, rnn_mode: &str) -> Self {
        self.rnn_mode = Some(rnn_mode.to_string());
        self.clone()
    }

    pub fn input_mode(&mut self, input_mode: &str) -> Self {
        self.input_mode = Some(input_mode.to_string());
        self.clone()
    }

    pub fn direction(&mut self, direction: &str) -> Self {
        self.direction = Some(direction.to_string());
        self.clone()
    }

    pub fn dropout(&mut self, dropout: f32) -> Self {
        self.dropout = Some(dropout);
        self.clone()
    }

    pub fn seed(&mut self, seed: i64) -> Self {
        self.seed = Some(seed);
        self.clone()
    }

    pub fn seed2(&mut self, seed2: i64) -> Self {
        self.seed2 = Some(seed2);
        self.clone()
    }

    pub fn is_training(&mut self, is_training: bool) -> Self {
        self.is_training = Some(is_training);
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> (Edge<T>, Edge<T>, Edge<T>, Edge<T>, Edge<i8>) {
        let rc = Rc::new(self);
        (
        {
            Edge::<T>::new(rc.clone(), 0)
        },
        {
            Edge::<T>::new(rc.clone(), 1)
        },
        {
            Edge::<T>::new(rc.clone(), 2)
        },
        {
            Edge::<T>::new(rc.clone(), 3)
        },
        {
            Edge::<i8>::new(rc.clone(), 4)
        },
        )
    }

    pub fn build(input: Edge<T>, input_h: Edge<T>, input_c: Edge<T>, params: Edge<T>) -> Self {
        Self {
            phantom_T: PhantomData,
            input,
            input_h,
            input_c,
            params,
            rnn_mode: None,
            input_mode: None,
            direction: None,
            dropout: None,
            seed: None,
            seed2: None,
            is_training: None,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(input: Edge<T>, input_h: Edge<T>, input_c: Edge<T>, params: Edge<T>) -> (Edge<T>, Edge<T>, Edge<T>, Edge<T>, Edge<i8>) {
        Self {
            phantom_T: PhantomData,
            input,
            input_h,
            input_c,
            params,
            rnn_mode: None,
            input_mode: None,
            direction: None,
            dropout: None,
            seed: None,
            seed2: None,
            is_training: None,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl GraphOperation for TPUReplicateMetadata {
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("TPUReplicateMetadata_{}")?
        };
        let mut new_op = graph.new_operation("TPUReplicateMetadata", &op_name)?;
        {
            (|attr: &i64| {new_op.set_attr_int("num_replicas", *attr)})(&self.num_replicas)?
        }
        {
            match self.num_cores_per_replica {
                None => new_op.set_attr_value_proto("num_cores_per_replica", &vec![24_u8, 1_u8,])?,
                Some(ref value) => (|attr: &i64| {new_op.set_attr_int("num_cores_per_replica", *attr)})(&value)?,
            };
        }
        {
            match self.topology {
                None => new_op.set_attr_value_proto("topology", &vec![18_u8, 0_u8,])?,
                Some(ref value) => (|attr| {new_op.set_attr_string("topology", attr)})(&value)?,
            };
        }
        {
            match self.use_tpu {
                None => new_op.set_attr_value_proto("use_tpu", &vec![40_u8, 1_u8,])?,
                Some(ref value) => (|attr: &bool| {new_op.set_attr_bool("use_tpu", *attr)})(&value)?,
            };
        }
        {
            match self.device_assignment {
                None => new_op.set_attr_value_proto("device_assignment", &vec![10_u8, 0_u8,])?,
                Some(ref value) => (|attrs| {new_op.set_attr_int_list("device_assignment", attrs)})(&value)?,
            };
        }
        {
            match self.computation_shape {
                None => new_op.set_attr_value_proto("computation_shape", &vec![10_u8, 0_u8,])?,
                Some(ref value) => (|attrs| {new_op.set_attr_int_list("computation_shape", attrs)})(&value)?,
            };
        }
        {
            match self.host_compute_core {
                None => new_op.set_attr_value_proto("host_compute_core", &vec![10_u8, 0_u8,])?,
                Some(ref value) => (|attrs| {new_op.set_attr_string_list("host_compute_core", attrs)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct TPUReplicateMetadata {
    num_replicas: i64,
    num_cores_per_replica: Option<i64>,
    topology: Option<String>,
    use_tpu: Option<bool>,
    device_assignment: Option<Vec<i64>>,
    computation_shape: Option<Vec<i64>>,
    host_compute_core: Option<Vec<String>>,
    op_name: Option<String>,
    id_: usize,
}

impl TPUReplicateMetadata {
    pub fn num_cores_per_replica(&mut self, num_cores_per_replica: i64) -> Self {
        self.num_cores_per_replica = Some(num_cores_per_replica);
        self.clone()
    }

    pub fn topology(&mut self, topology: &str) -> Self {
        self.topology = Some(topology.to_string());
        self.clone()
    }

    pub fn use_tpu(&mut self, use_tpu: bool) -> Self {
        self.use_tpu = Some(use_tpu);
        self.clone()
    }

    pub fn device_assignment(&mut self, device_assignment: &[i64]) -> Self {
        self.device_assignment = Some(device_assignment.to_vec());
        self.clone()
    }

    pub fn computation_shape(&mut self, computation_shape: &[i64]) -> Self {
        self.computation_shape = Some(computation_shape.to_vec());
        self.clone()
    }

    pub fn host_compute_core(&mut self, host_compute_core: &[String]) -> Self {
        self.host_compute_core = Some(host_compute_core.to_vec());
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> () {
        let rc = Rc::new(self);
        (
        )
    }

    pub fn build(num_replicas: i64) -> Self {
        Self {
            num_replicas: num_replicas,
            num_cores_per_replica: None,
            topology: None,
            use_tpu: None,
            device_assignment: None,
            computation_shape: None,
            host_compute_core: None,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(num_replicas: i64) -> () {
        Self {
            num_replicas: num_replicas,
            num_cores_per_replica: None,
            topology: None,
            use_tpu: None,
            device_assignment: None,
            computation_shape: None,
            host_compute_core: None,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl GraphOperation for LoadTPUEmbeddingFTRLParametersGradAccumDebug {
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("LoadTPUEmbeddingFTRLParametersGradAccumDebug_{}")?
        };
        let mut new_op = graph.new_operation("LoadTPUEmbeddingFTRLParametersGradAccumDebug", &op_name)?;
        {
            new_op.add_edge(&self.parameters)?
        }
        {
            new_op.add_edge(&self.accumulators)?
        }
        {
            new_op.add_edge(&self.linears)?
        }
        {
            new_op.add_edge(&self.gradient_accumulators)?
        }
        {
            match self.table_id {
                None => new_op.set_attr_value_proto("table_id", &vec![24_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 1_u8,])?,
                Some(ref value) => (|attr: &i64| {new_op.set_attr_int("table_id", *attr)})(&value)?,
            };
        }
        {
            match self.table_name {
                None => new_op.set_attr_value_proto("table_name", &vec![18_u8, 0_u8,])?,
                Some(ref value) => (|attr| {new_op.set_attr_string("table_name", attr)})(&value)?,
            };
        }
        {
            (|attr: &i64| {new_op.set_attr_int("num_shards", *attr)})(&self.num_shards)?
        }
        {
            (|attr: &i64| {new_op.set_attr_int("shard_id", *attr)})(&self.shard_id)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct LoadTPUEmbeddingFTRLParametersGradAccumDebug {
    parameters: Edge<f32>,
    accumulators: Edge<f32>,
    linears: Edge<f32>,
    gradient_accumulators: Edge<f32>,
    table_id: Option<i64>,
    table_name: Option<String>,
    num_shards: i64,
    shard_id: i64,
    op_name: Option<String>,
    id_: usize,
}

impl LoadTPUEmbeddingFTRLParametersGradAccumDebug {
    pub fn table_id(&mut self, table_id: i64) -> Self {
        self.table_id = Some(table_id);
        self.clone()
    }

    pub fn table_name(&mut self, table_name: &str) -> Self {
        self.table_name = Some(table_name.to_string());
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> () {
        let rc = Rc::new(self);
        (
        )
    }

    pub fn build(parameters: Edge<f32>, accumulators: Edge<f32>, linears: Edge<f32>, gradient_accumulators: Edge<f32>, num_shards: i64, shard_id: i64) -> Self {
        Self {
            parameters,
            accumulators,
            linears,
            gradient_accumulators,
            table_id: None,
            table_name: None,
            num_shards: num_shards,
            shard_id: shard_id,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(parameters: Edge<f32>, accumulators: Edge<f32>, linears: Edge<f32>, gradient_accumulators: Edge<f32>, num_shards: i64, shard_id: i64) -> () {
        Self {
            parameters,
            accumulators,
            linears,
            gradient_accumulators,
            table_id: None,
            table_name: None,
            num_shards: num_shards,
            shard_id: shard_id,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<dtype> GraphOperation for IsVariableInitialized<dtype>
where dtype: TensorType,
      dtype: Clone,
      dtype: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("IsVariableInitialized_{}")?
        };
        let mut new_op = graph.new_operation("IsVariableInitialized", &op_name)?;
        {
            new_op.add_edge(&self.ref_)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct IsVariableInitialized<dtype>
where dtype: TensorType,
      dtype: Clone,
      dtype: 'static,
{
    phantom_dtype: PhantomData<dtype>,
    ref_: Edge<dtype>,
    op_name: Option<String>,
    id_: usize,
}

impl<dtype> IsVariableInitialized<dtype>
where dtype: TensorType,
      dtype: Clone,
      dtype: 'static,
{
    pub fn is_initialized(self) -> Edge<bool> {
        let rc = Rc::new(self);
        {
            Edge::<bool>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<bool> {
        let rc = Rc::new(self);
        {
            Edge::<bool>::new(rc.clone(), 0)
        }
    }

    pub fn build(ref_: Edge<dtype>) -> Self {
        Self {
            phantom_dtype: PhantomData,
            ref_,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(ref_: Edge<dtype>) -> Edge<bool> {
        Self {
            phantom_dtype: PhantomData,
            ref_,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<T> GraphOperation for QuantizeAndDequantizeV2<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
      T: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("QuantizeAndDequantizeV2_{}")?
        };
        let mut new_op = graph.new_operation("QuantizeAndDequantizeV2", &op_name)?;
        {
            new_op.add_edge(&self.input)?
        }
        {
            new_op.add_edge(&self.input_min)?
        }
        {
            new_op.add_edge(&self.input_max)?
        }
        {
            match self.signed_input {
                None => new_op.set_attr_value_proto("signed_input", &vec![40_u8, 1_u8,])?,
                Some(ref value) => (|attr: &bool| {new_op.set_attr_bool("signed_input", *attr)})(&value)?,
            };
        }
        {
            match self.num_bits {
                None => new_op.set_attr_value_proto("num_bits", &vec![24_u8, 8_u8,])?,
                Some(ref value) => (|attr: &i64| {new_op.set_attr_int("num_bits", *attr)})(&value)?,
            };
        }
        {
            match self.range_given {
                None => new_op.set_attr_value_proto("range_given", &vec![40_u8, 0_u8,])?,
                Some(ref value) => (|attr: &bool| {new_op.set_attr_bool("range_given", *attr)})(&value)?,
            };
        }
        {
            match self.round_mode {
                None => new_op.set_attr_value_proto("round_mode", &vec![18_u8, 12_u8, 72_u8, 65_u8, 76_u8, 70_u8, 95_u8, 84_u8, 79_u8, 95_u8, 69_u8, 86_u8, 69_u8, 78_u8,])?,
                Some(ref value) => (|attr| {new_op.set_attr_string("round_mode", attr)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct QuantizeAndDequantizeV2<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    input: Edge<T>,
    input_min: Edge<T>,
    input_max: Edge<T>,
    signed_input: Option<bool>,
    num_bits: Option<i64>,
    range_given: Option<bool>,
    round_mode: Option<String>,
    op_name: Option<String>,
    id_: usize,
}

impl<T> QuantizeAndDequantizeV2<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
      T: 'static,
{
    pub fn output(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn signed_input(&mut self, signed_input: bool) -> Self {
        self.signed_input = Some(signed_input);
        self.clone()
    }

    pub fn num_bits(&mut self, num_bits: i64) -> Self {
        self.num_bits = Some(num_bits);
        self.clone()
    }

    pub fn range_given(&mut self, range_given: bool) -> Self {
        self.range_given = Some(range_given);
        self.clone()
    }

    pub fn round_mode(&mut self, round_mode: &str) -> Self {
        self.round_mode = Some(round_mode.to_string());
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(input: Edge<T>, input_min: Edge<T>, input_max: Edge<T>) -> Self {
        Self {
            phantom_T: PhantomData,
            input,
            input_min,
            input_max,
            signed_input: None,
            num_bits: None,
            range_given: None,
            round_mode: None,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(input: Edge<T>, input_min: Edge<T>, input_max: Edge<T>) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            input,
            input_min,
            input_max,
            signed_input: None,
            num_bits: None,
            range_given: None,
            round_mode: None,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<T, Tblock_shape, Tpaddings> GraphOperation for SpaceToBatchND<T, Tblock_shape, Tpaddings>
where T: TensorType,
      T: Clone,
      Tblock_shape: TensorType,
      Tblock_shape: Clone,
      Tpaddings: TensorType,
      Tpaddings: Clone,
      T: 'static,
      Tblock_shape: con_or_DT_INT32_or_DT_INT64,
      Tblock_shape: 'static,
      Tpaddings: con_or_DT_INT32_or_DT_INT64,
      Tpaddings: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("SpaceToBatchND_{}")?
        };
        let mut new_op = graph.new_operation("SpaceToBatchND", &op_name)?;
        {
            new_op.add_edge(&self.input)?
        }
        {
            new_op.add_edge(&self.block_shape)?
        }
        {
            new_op.add_edge(&self.paddings)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct SpaceToBatchND<T, Tblock_shape, Tpaddings>
where T: TensorType,
      T: Clone,
      Tblock_shape: TensorType,
      Tblock_shape: Clone,
      Tpaddings: TensorType,
      Tpaddings: Clone,
      T: 'static,
      Tblock_shape: con_or_DT_INT32_or_DT_INT64,
      Tblock_shape: 'static,
      Tpaddings: con_or_DT_INT32_or_DT_INT64,
      Tpaddings: 'static,
{
    phantom_T: PhantomData<T>,
    input: Edge<T>,
    phantom_Tblock_shape: PhantomData<Tblock_shape>,
    block_shape: Edge<Tblock_shape>,
    phantom_Tpaddings: PhantomData<Tpaddings>,
    paddings: Edge<Tpaddings>,
    op_name: Option<String>,
    id_: usize,
}

impl<T, Tblock_shape, Tpaddings> SpaceToBatchND<T, Tblock_shape, Tpaddings>
where T: TensorType,
      T: Clone,
      Tblock_shape: TensorType,
      Tblock_shape: Clone,
      Tpaddings: TensorType,
      Tpaddings: Clone,
      T: 'static,
      Tblock_shape: con_or_DT_INT32_or_DT_INT64,
      Tblock_shape: 'static,
      Tpaddings: con_or_DT_INT32_or_DT_INT64,
      Tpaddings: 'static,
{
    pub fn output(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(input: Edge<T>, block_shape: Edge<Tblock_shape>, paddings: Edge<Tpaddings>) -> Self {
        Self {
            phantom_T: PhantomData,
            input,
            phantom_Tblock_shape: PhantomData,
            block_shape,
            phantom_Tpaddings: PhantomData,
            paddings,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(input: Edge<T>, block_shape: Edge<Tblock_shape>, paddings: Edge<Tpaddings>) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            input,
            phantom_Tblock_shape: PhantomData,
            block_shape,
            phantom_Tpaddings: PhantomData,
            paddings,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<T, Tseed, dtype> GraphOperation for StatelessRandomUniform<T, Tseed, dtype>
where T: TensorType,
      T: Clone,
      Tseed: TensorType,
      Tseed: Clone,
      dtype: TensorType,
      dtype: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
      dtype: 'static,
      dtype: Clone,
      T: con_or_DT_INT32_or_DT_INT64,
      T: 'static,
      Tseed: con_or_DT_INT32_or_DT_INT64,
      Tseed: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("StatelessRandomUniform_{}")?
        };
        let mut new_op = graph.new_operation("StatelessRandomUniform", &op_name)?;
        {
            new_op.add_edge(&self.shape)?
        }
        {
            new_op.add_edge(&self.seed)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct StatelessRandomUniform<T, Tseed, dtype>
where T: TensorType,
      T: Clone,
      Tseed: TensorType,
      Tseed: Clone,
      dtype: TensorType,
      dtype: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
      dtype: 'static,
      dtype: Clone,
      T: con_or_DT_INT32_or_DT_INT64,
      T: 'static,
      Tseed: con_or_DT_INT32_or_DT_INT64,
      Tseed: 'static,
{
    phantom_T: PhantomData<T>,
    shape: Edge<T>,
    phantom_Tseed: PhantomData<Tseed>,
    seed: Edge<Tseed>,
    phantom_dtype: PhantomData<dtype>,
    op_name: Option<String>,
    id_: usize,
}

impl<T, Tseed, dtype> StatelessRandomUniform<T, Tseed, dtype>
where T: TensorType,
      T: Clone,
      Tseed: TensorType,
      Tseed: Clone,
      dtype: TensorType,
      dtype: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
      dtype: 'static,
      dtype: Clone,
      T: con_or_DT_INT32_or_DT_INT64,
      T: 'static,
      Tseed: con_or_DT_INT32_or_DT_INT64,
      Tseed: 'static,
{
    pub fn output(self) -> Edge<dtype> {
        let rc = Rc::new(self);
        {
            Edge::<dtype>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<dtype> {
        let rc = Rc::new(self);
        {
            Edge::<dtype>::new(rc.clone(), 0)
        }
    }

    pub fn build(shape: Edge<T>, seed: Edge<Tseed>) -> Self {
        Self {
            phantom_T: PhantomData,
            shape,
            phantom_Tseed: PhantomData,
            seed,
            phantom_dtype: PhantomData,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(shape: Edge<T>, seed: Edge<Tseed>) -> Edge<dtype> {
        Self {
            phantom_T: PhantomData,
            shape,
            phantom_Tseed: PhantomData,
            seed,
            phantom_dtype: PhantomData,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<dtype> GraphOperation for InfeedDequeue<dtype>
where dtype: TensorType,
      dtype: 'static,
      dtype: Clone,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("InfeedDequeue_{}")?
        };
        let mut new_op = graph.new_operation("InfeedDequeue", &op_name)?;
        {
            (|attr| {new_op.set_attr_shape("shape", attr)})(&self.shape)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct InfeedDequeue<dtype>
where dtype: TensorType,
      dtype: 'static,
      dtype: Clone,
{
    phantom_dtype: PhantomData<dtype>,
    shape: OtherShape,
    op_name: Option<String>,
    id_: usize,
}

impl<dtype> InfeedDequeue<dtype>
where dtype: TensorType,
      dtype: 'static,
      dtype: Clone,
{
    pub fn output(self) -> Edge<dtype> {
        let rc = Rc::new(self);
        {
            Edge::<dtype>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<dtype> {
        let rc = Rc::new(self);
        {
            Edge::<dtype>::new(rc.clone(), 0)
        }
    }

    pub fn build(shape: &OtherShape) -> Self {
        Self {
            phantom_dtype: PhantomData,
            shape: shape.clone(),
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(shape: &OtherShape) -> Edge<dtype> {
        Self {
            phantom_dtype: PhantomData,
            shape: shape.clone(),
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<T> GraphOperation for IsFinite<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
      T: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("IsFinite_{}")?
        };
        let mut new_op = graph.new_operation("IsFinite", &op_name)?;
        {
            new_op.add_edge(&self.x)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct IsFinite<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    x: Edge<T>,
    op_name: Option<String>,
    id_: usize,
}

impl<T> IsFinite<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
      T: 'static,
{
    pub fn y(self) -> Edge<bool> {
        let rc = Rc::new(self);
        {
            Edge::<bool>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<bool> {
        let rc = Rc::new(self);
        {
            Edge::<bool>::new(rc.clone(), 0)
        }
    }

    pub fn build(x: Edge<T>) -> Self {
        Self {
            phantom_T: PhantomData,
            x,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(x: Edge<T>) -> Edge<bool> {
        Self {
            phantom_T: PhantomData,
            x,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<T> GraphOperation for GuaranteeConst<T>
where T: TensorType,
      T: Clone,
      T: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("GuaranteeConst_{}")?
        };
        let mut new_op = graph.new_operation("GuaranteeConst", &op_name)?;
        {
            new_op.add_edge(&self.input)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct GuaranteeConst<T>
where T: TensorType,
      T: Clone,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    input: Edge<T>,
    op_name: Option<String>,
    id_: usize,
}

impl<T> GuaranteeConst<T>
where T: TensorType,
      T: Clone,
      T: 'static,
{
    pub fn output(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(input: Edge<T>) -> Self {
        Self {
            phantom_T: PhantomData,
            input,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(input: Edge<T>) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            input,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<Tparams, Tindices> GraphOperation for GatherNd<Tparams, Tindices>
where Tparams: TensorType,
      Tparams: Clone,
      Tindices: TensorType,
      Tindices: Clone,
      Tparams: 'static,
      Tindices: con_or_DT_INT32_or_DT_INT64,
      Tindices: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("GatherNd_{}")?
        };
        let mut new_op = graph.new_operation("GatherNd", &op_name)?;
        {
            new_op.add_edge(&self.params)?
        }
        {
            new_op.add_edge(&self.indices)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct GatherNd<Tparams, Tindices>
where Tparams: TensorType,
      Tparams: Clone,
      Tindices: TensorType,
      Tindices: Clone,
      Tparams: 'static,
      Tindices: con_or_DT_INT32_or_DT_INT64,
      Tindices: 'static,
{
    phantom_Tparams: PhantomData<Tparams>,
    params: Edge<Tparams>,
    phantom_Tindices: PhantomData<Tindices>,
    indices: Edge<Tindices>,
    op_name: Option<String>,
    id_: usize,
}

impl<Tparams, Tindices> GatherNd<Tparams, Tindices>
where Tparams: TensorType,
      Tparams: Clone,
      Tindices: TensorType,
      Tindices: Clone,
      Tparams: 'static,
      Tindices: con_or_DT_INT32_or_DT_INT64,
      Tindices: 'static,
{
    pub fn output(self) -> Edge<Tparams> {
        let rc = Rc::new(self);
        {
            Edge::<Tparams>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<Tparams> {
        let rc = Rc::new(self);
        {
            Edge::<Tparams>::new(rc.clone(), 0)
        }
    }

    pub fn build(params: Edge<Tparams>, indices: Edge<Tindices>) -> Self {
        Self {
            phantom_Tparams: PhantomData,
            params,
            phantom_Tindices: PhantomData,
            indices,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(params: Edge<Tparams>, indices: Edge<Tindices>) -> Edge<Tparams> {
        Self {
            phantom_Tparams: PhantomData,
            params,
            phantom_Tindices: PhantomData,
            indices,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<T, out_idx> GraphOperation for UniqueWithCounts<T, out_idx>
where T: TensorType,
      T: Clone,
      out_idx: TensorType,
      T: 'static,
      out_idx: con_or_DT_INT32_or_DT_INT64,
      out_idx: 'static,
      out_idx: Clone,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("UniqueWithCounts_{}")?
        };
        let mut new_op = graph.new_operation("UniqueWithCounts", &op_name)?;
        {
            new_op.add_edge(&self.x)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct UniqueWithCounts<T, out_idx>
where T: TensorType,
      T: Clone,
      out_idx: TensorType,
      T: 'static,
      out_idx: con_or_DT_INT32_or_DT_INT64,
      out_idx: 'static,
      out_idx: Clone,
{
    phantom_T: PhantomData<T>,
    x: Edge<T>,
    phantom_out_idx: PhantomData<out_idx>,
    op_name: Option<String>,
    id_: usize,
}

impl<T, out_idx> UniqueWithCounts<T, out_idx>
where T: TensorType,
      T: Clone,
      out_idx: TensorType,
      T: 'static,
      out_idx: con_or_DT_INT32_or_DT_INT64,
      out_idx: 'static,
      out_idx: Clone,
{
    pub fn y(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn idx(self) -> Edge<out_idx> {
        let rc = Rc::new(self);
        {
            Edge::<out_idx>::new(rc.clone(), 1)
        }
    }

    pub fn count(self) -> Edge<out_idx> {
        let rc = Rc::new(self);
        {
            Edge::<out_idx>::new(rc.clone(), 2)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> (Edge<T>, Edge<out_idx>, Edge<out_idx>) {
        let rc = Rc::new(self);
        (
        {
            Edge::<T>::new(rc.clone(), 0)
        },
        {
            Edge::<out_idx>::new(rc.clone(), 1)
        },
        {
            Edge::<out_idx>::new(rc.clone(), 2)
        },
        )
    }

    pub fn build(x: Edge<T>) -> Self {
        Self {
            phantom_T: PhantomData,
            x,
            phantom_out_idx: PhantomData,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(x: Edge<T>) -> (Edge<T>, Edge<out_idx>, Edge<out_idx>) {
        Self {
            phantom_T: PhantomData,
            x,
            phantom_out_idx: PhantomData,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<T, out_idx> GraphOperation for ListDiff<T, out_idx>
where T: TensorType,
      T: Clone,
      out_idx: TensorType,
      T: 'static,
      out_idx: con_or_DT_INT32_or_DT_INT64,
      out_idx: 'static,
      out_idx: Clone,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("ListDiff_{}")?
        };
        let mut new_op = graph.new_operation("ListDiff", &op_name)?;
        {
            new_op.add_edge(&self.x)?
        }
        {
            new_op.add_edge(&self.y)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct ListDiff<T, out_idx>
where T: TensorType,
      T: Clone,
      out_idx: TensorType,
      T: 'static,
      out_idx: con_or_DT_INT32_or_DT_INT64,
      out_idx: 'static,
      out_idx: Clone,
{
    phantom_T: PhantomData<T>,
    x: Edge<T>,
    y: Edge<T>,
    phantom_out_idx: PhantomData<out_idx>,
    op_name: Option<String>,
    id_: usize,
}

impl<T, out_idx> ListDiff<T, out_idx>
where T: TensorType,
      T: Clone,
      out_idx: TensorType,
      T: 'static,
      out_idx: con_or_DT_INT32_or_DT_INT64,
      out_idx: 'static,
      out_idx: Clone,
{
    pub fn out(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn idx(self) -> Edge<out_idx> {
        let rc = Rc::new(self);
        {
            Edge::<out_idx>::new(rc.clone(), 1)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> (Edge<T>, Edge<out_idx>) {
        let rc = Rc::new(self);
        (
        {
            Edge::<T>::new(rc.clone(), 0)
        },
        {
            Edge::<out_idx>::new(rc.clone(), 1)
        },
        )
    }

    pub fn build(x: Edge<T>, y: Edge<T>) -> Self {
        Self {
            phantom_T: PhantomData,
            x,
            y,
            phantom_out_idx: PhantomData,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(x: Edge<T>, y: Edge<T>) -> (Edge<T>, Edge<out_idx>) {
        Self {
            phantom_T: PhantomData,
            x,
            y,
            phantom_out_idx: PhantomData,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl GraphOperation for LoadTPUEmbeddingAdadeltaParametersGradAccumDebug {
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("LoadTPUEmbeddingAdadeltaParametersGradAccumDebug_{}")?
        };
        let mut new_op = graph.new_operation("LoadTPUEmbeddingAdadeltaParametersGradAccumDebug", &op_name)?;
        {
            new_op.add_edge(&self.parameters)?
        }
        {
            new_op.add_edge(&self.accumulators)?
        }
        {
            new_op.add_edge(&self.updates)?
        }
        {
            new_op.add_edge(&self.gradient_accumulators)?
        }
        {
            match self.table_id {
                None => new_op.set_attr_value_proto("table_id", &vec![24_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 1_u8,])?,
                Some(ref value) => (|attr: &i64| {new_op.set_attr_int("table_id", *attr)})(&value)?,
            };
        }
        {
            match self.table_name {
                None => new_op.set_attr_value_proto("table_name", &vec![18_u8, 0_u8,])?,
                Some(ref value) => (|attr| {new_op.set_attr_string("table_name", attr)})(&value)?,
            };
        }
        {
            (|attr: &i64| {new_op.set_attr_int("num_shards", *attr)})(&self.num_shards)?
        }
        {
            (|attr: &i64| {new_op.set_attr_int("shard_id", *attr)})(&self.shard_id)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct LoadTPUEmbeddingAdadeltaParametersGradAccumDebug {
    parameters: Edge<f32>,
    accumulators: Edge<f32>,
    updates: Edge<f32>,
    gradient_accumulators: Edge<f32>,
    table_id: Option<i64>,
    table_name: Option<String>,
    num_shards: i64,
    shard_id: i64,
    op_name: Option<String>,
    id_: usize,
}

impl LoadTPUEmbeddingAdadeltaParametersGradAccumDebug {
    pub fn table_id(&mut self, table_id: i64) -> Self {
        self.table_id = Some(table_id);
        self.clone()
    }

    pub fn table_name(&mut self, table_name: &str) -> Self {
        self.table_name = Some(table_name.to_string());
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> () {
        let rc = Rc::new(self);
        (
        )
    }

    pub fn build(parameters: Edge<f32>, accumulators: Edge<f32>, updates: Edge<f32>, gradient_accumulators: Edge<f32>, num_shards: i64, shard_id: i64) -> Self {
        Self {
            parameters,
            accumulators,
            updates,
            gradient_accumulators,
            table_id: None,
            table_name: None,
            num_shards: num_shards,
            shard_id: shard_id,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(parameters: Edge<f32>, accumulators: Edge<f32>, updates: Edge<f32>, gradient_accumulators: Edge<f32>, num_shards: i64, shard_id: i64) -> () {
        Self {
            parameters,
            accumulators,
            updates,
            gradient_accumulators,
            table_id: None,
            table_name: None,
            num_shards: num_shards,
            shard_id: shard_id,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<T, Tidx> GraphOperation for BroadcastTo<T, Tidx>
where T: TensorType,
      T: Clone,
      Tidx: TensorType,
      Tidx: Clone,
      T: 'static,
      Tidx: con_or_DT_INT32_or_DT_INT64,
      Tidx: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("BroadcastTo_{}")?
        };
        let mut new_op = graph.new_operation("BroadcastTo", &op_name)?;
        {
            new_op.add_edge(&self.input)?
        }
        {
            new_op.add_edge(&self.shape)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct BroadcastTo<T, Tidx>
where T: TensorType,
      T: Clone,
      Tidx: TensorType,
      Tidx: Clone,
      T: 'static,
      Tidx: con_or_DT_INT32_or_DT_INT64,
      Tidx: 'static,
{
    phantom_T: PhantomData<T>,
    input: Edge<T>,
    phantom_Tidx: PhantomData<Tidx>,
    shape: Edge<Tidx>,
    op_name: Option<String>,
    id_: usize,
}

impl<T, Tidx> BroadcastTo<T, Tidx>
where T: TensorType,
      T: Clone,
      Tidx: TensorType,
      Tidx: Clone,
      T: 'static,
      Tidx: con_or_DT_INT32_or_DT_INT64,
      Tidx: 'static,
{
    pub fn output(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(input: Edge<T>, shape: Edge<Tidx>) -> Self {
        Self {
            phantom_T: PhantomData,
            input,
            phantom_Tidx: PhantomData,
            shape,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(input: Edge<T>, shape: Edge<Tidx>) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            input,
            phantom_Tidx: PhantomData,
            shape,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<T> GraphOperation for DebugNumericSummary<T>
where T: TensorType,
      T: Clone,
      T: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("DebugNumericSummary_{}")?
        };
        let mut new_op = graph.new_operation("DebugNumericSummary", &op_name)?;
        {
            new_op.add_edge(&self.input)?
        }
        {
            match self.device_name {
                None => new_op.set_attr_value_proto("device_name", &vec![18_u8, 0_u8,])?,
                Some(ref value) => (|attr| {new_op.set_attr_string("device_name", attr)})(&value)?,
            };
        }
        {
            match self.tensor_name {
                None => new_op.set_attr_value_proto("tensor_name", &vec![18_u8, 0_u8,])?,
                Some(ref value) => (|attr| {new_op.set_attr_string("tensor_name", attr)})(&value)?,
            };
        }
        {
            match self.debug_urls {
                None => new_op.set_attr_value_proto("debug_urls", &vec![10_u8, 0_u8,])?,
                Some(ref value) => (|attrs| {new_op.set_attr_string_list("debug_urls", attrs)})(&value)?,
            };
        }
        {
            match self.lower_bound {
                None => new_op.set_attr_value_proto("lower_bound", &vec![37_u8, 0_u8, 0_u8, 128_u8, 255_u8,])?,
                Some(ref value) => (|attr: &f32| {new_op.set_attr_float("lower_bound", *attr)})(&value)?,
            };
        }
        {
            match self.upper_bound {
                None => new_op.set_attr_value_proto("upper_bound", &vec![37_u8, 0_u8, 0_u8, 128_u8, 127_u8,])?,
                Some(ref value) => (|attr: &f32| {new_op.set_attr_float("upper_bound", *attr)})(&value)?,
            };
        }
        {
            match self.mute_if_healthy {
                None => new_op.set_attr_value_proto("mute_if_healthy", &vec![40_u8, 0_u8,])?,
                Some(ref value) => (|attr: &bool| {new_op.set_attr_bool("mute_if_healthy", *attr)})(&value)?,
            };
        }
        {
            match self.gated_grpc {
                None => new_op.set_attr_value_proto("gated_grpc", &vec![40_u8, 0_u8,])?,
                Some(ref value) => (|attr: &bool| {new_op.set_attr_bool("gated_grpc", *attr)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct DebugNumericSummary<T>
where T: TensorType,
      T: Clone,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    input: Edge<T>,
    device_name: Option<String>,
    tensor_name: Option<String>,
    debug_urls: Option<Vec<String>>,
    lower_bound: Option<f32>,
    upper_bound: Option<f32>,
    mute_if_healthy: Option<bool>,
    gated_grpc: Option<bool>,
    op_name: Option<String>,
    id_: usize,
}

impl<T> DebugNumericSummary<T>
where T: TensorType,
      T: Clone,
      T: 'static,
{
    pub fn output(self) -> Edge<f64> {
        let rc = Rc::new(self);
        {
            Edge::<f64>::new(rc.clone(), 0)
        }
    }

    pub fn device_name(&mut self, device_name: &str) -> Self {
        self.device_name = Some(device_name.to_string());
        self.clone()
    }

    pub fn tensor_name(&mut self, tensor_name: &str) -> Self {
        self.tensor_name = Some(tensor_name.to_string());
        self.clone()
    }

    pub fn debug_urls(&mut self, debug_urls: &[String]) -> Self {
        self.debug_urls = Some(debug_urls.to_vec());
        self.clone()
    }

    pub fn lower_bound(&mut self, lower_bound: f32) -> Self {
        self.lower_bound = Some(lower_bound);
        self.clone()
    }

    pub fn upper_bound(&mut self, upper_bound: f32) -> Self {
        self.upper_bound = Some(upper_bound);
        self.clone()
    }

    pub fn mute_if_healthy(&mut self, mute_if_healthy: bool) -> Self {
        self.mute_if_healthy = Some(mute_if_healthy);
        self.clone()
    }

    pub fn gated_grpc(&mut self, gated_grpc: bool) -> Self {
        self.gated_grpc = Some(gated_grpc);
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<f64> {
        let rc = Rc::new(self);
        {
            Edge::<f64>::new(rc.clone(), 0)
        }
    }

    pub fn build(input: Edge<T>) -> Self {
        Self {
            phantom_T: PhantomData,
            input,
            device_name: None,
            tensor_name: None,
            debug_urls: None,
            lower_bound: None,
            upper_bound: None,
            mute_if_healthy: None,
            gated_grpc: None,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(input: Edge<T>) -> Edge<f64> {
        Self {
            phantom_T: PhantomData,
            input,
            device_name: None,
            tensor_name: None,
            debug_urls: None,
            lower_bound: None,
            upper_bound: None,
            mute_if_healthy: None,
            gated_grpc: None,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<T> GraphOperation for AddSparseToTensorsMap<T>
where T: TensorType,
      T: Clone,
      T: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("AddSparseToTensorsMap_{}")?
        };
        let mut new_op = graph.new_operation("AddSparseToTensorsMap", &op_name)?;
        {
            new_op.add_edge(&self.sparse_indices)?
        }
        {
            new_op.add_edge(&self.sparse_values)?
        }
        {
            new_op.add_edge(&self.sparse_shape)?
        }
        {
            match self.container {
                None => new_op.set_attr_value_proto("container", &vec![18_u8, 0_u8,])?,
                Some(ref value) => (|attr| {new_op.set_attr_string("container", attr)})(&value)?,
            };
        }
        {
            match self.shared_name {
                None => new_op.set_attr_value_proto("shared_name", &vec![18_u8, 0_u8,])?,
                Some(ref value) => (|attr| {new_op.set_attr_string("shared_name", attr)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct AddSparseToTensorsMap<T>
where T: TensorType,
      T: Clone,
      T: 'static,
{
    sparse_indices: Edge<i64>,
    phantom_T: PhantomData<T>,
    sparse_values: Edge<T>,
    sparse_shape: Edge<i64>,
    container: Option<String>,
    shared_name: Option<String>,
    op_name: Option<String>,
    id_: usize,
}

impl<T> AddSparseToTensorsMap<T>
where T: TensorType,
      T: Clone,
      T: 'static,
{
    pub fn sparse_handle(self) -> Edge<i64> {
        let rc = Rc::new(self);
        {
            Edge::<i64>::new(rc.clone(), 0)
        }
    }

    pub fn container(&mut self, container: &str) -> Self {
        self.container = Some(container.to_string());
        self.clone()
    }

    pub fn shared_name(&mut self, shared_name: &str) -> Self {
        self.shared_name = Some(shared_name.to_string());
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<i64> {
        let rc = Rc::new(self);
        {
            Edge::<i64>::new(rc.clone(), 0)
        }
    }

    pub fn build(sparse_indices: Edge<i64>, sparse_values: Edge<T>, sparse_shape: Edge<i64>) -> Self {
        Self {
            sparse_indices,
            phantom_T: PhantomData,
            sparse_values,
            sparse_shape,
            container: None,
            shared_name: None,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(sparse_indices: Edge<i64>, sparse_values: Edge<T>, sparse_shape: Edge<i64>) -> Edge<i64> {
        Self {
            sparse_indices,
            phantom_T: PhantomData,
            sparse_values,
            sparse_shape,
            container: None,
            shared_name: None,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<T> GraphOperation for Dilation2DBackpropFilter<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("Dilation2DBackpropFilter_{}")?
        };
        let mut new_op = graph.new_operation("Dilation2DBackpropFilter", &op_name)?;
        {
            new_op.add_edge(&self.input)?
        }
        {
            new_op.add_edge(&self.filter)?
        }
        {
            new_op.add_edge(&self.out_backprop)?
        }
        {
            (|attrs| {new_op.set_attr_int_list("strides", attrs)})(&self.strides)?
        }
        {
            (|attrs| {new_op.set_attr_int_list("rates", attrs)})(&self.rates)?
        }
        {
            (|attr| {new_op.set_attr_string("padding", attr)})(&self.padding)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct Dilation2DBackpropFilter<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    input: Edge<T>,
    filter: Edge<T>,
    out_backprop: Edge<T>,
    strides: Vec<i64>,
    rates: Vec<i64>,
    padding: String,
    op_name: Option<String>,
    id_: usize,
}

impl<T> Dilation2DBackpropFilter<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
{
    pub fn filter_backprop(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(input: Edge<T>, filter: Edge<T>, out_backprop: Edge<T>, strides: &[i64], rates: &[i64], padding: &str) -> Self {
        Self {
            phantom_T: PhantomData,
            input,
            filter,
            out_backprop,
            strides: strides.to_vec(),
            rates: rates.to_vec(),
            padding: padding.to_string(),
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(input: Edge<T>, filter: Edge<T>, out_backprop: Edge<T>, strides: &[i64], rates: &[i64], padding: &str) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            input,
            filter,
            out_backprop,
            strides: strides.to_vec(),
            rates: rates.to_vec(),
            padding: padding.to_string(),
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<T, Tindices> GraphOperation for ScatterSub<T, Tindices>
where T: TensorType,
      T: Clone,
      Tindices: TensorType,
      Tindices: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
      Tindices: con_or_DT_INT32_or_DT_INT64,
      Tindices: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("ScatterSub_{}")?
        };
        let mut new_op = graph.new_operation("ScatterSub", &op_name)?;
        {
            new_op.add_edge(&self.ref_)?
        }
        {
            new_op.add_edge(&self.indices)?
        }
        {
            new_op.add_edge(&self.updates)?
        }
        {
            match self.use_locking {
                None => new_op.set_attr_value_proto("use_locking", &vec![40_u8, 0_u8,])?,
                Some(ref value) => (|attr: &bool| {new_op.set_attr_bool("use_locking", *attr)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct ScatterSub<T, Tindices>
where T: TensorType,
      T: Clone,
      Tindices: TensorType,
      Tindices: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
      Tindices: con_or_DT_INT32_or_DT_INT64,
      Tindices: 'static,
{
    phantom_T: PhantomData<T>,
    ref_: Edge<T>,
    phantom_Tindices: PhantomData<Tindices>,
    indices: Edge<Tindices>,
    updates: Edge<T>,
    use_locking: Option<bool>,
    op_name: Option<String>,
    id_: usize,
}

impl<T, Tindices> ScatterSub<T, Tindices>
where T: TensorType,
      T: Clone,
      Tindices: TensorType,
      Tindices: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
      Tindices: con_or_DT_INT32_or_DT_INT64,
      Tindices: 'static,
{
    pub fn output_ref(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn use_locking(&mut self, use_locking: bool) -> Self {
        self.use_locking = Some(use_locking);
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(ref_: Edge<T>, indices: Edge<Tindices>, updates: Edge<T>) -> Self {
        Self {
            phantom_T: PhantomData,
            ref_,
            phantom_Tindices: PhantomData,
            indices,
            updates,
            use_locking: None,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(ref_: Edge<T>, indices: Edge<Tindices>, updates: Edge<T>) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            ref_,
            phantom_Tindices: PhantomData,
            indices,
            updates,
            use_locking: None,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<T> GraphOperation for CudnnRNNBackprop<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_HALF,
      T: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("CudnnRNNBackprop_{}")?
        };
        let mut new_op = graph.new_operation("CudnnRNNBackprop", &op_name)?;
        {
            new_op.add_edge(&self.input)?
        }
        {
            new_op.add_edge(&self.input_h)?
        }
        {
            new_op.add_edge(&self.input_c)?
        }
        {
            new_op.add_edge(&self.params)?
        }
        {
            new_op.add_edge(&self.output)?
        }
        {
            new_op.add_edge(&self.output_h)?
        }
        {
            new_op.add_edge(&self.output_c)?
        }
        {
            new_op.add_edge(&self.output_backprop)?
        }
        {
            new_op.add_edge(&self.output_h_backprop)?
        }
        {
            new_op.add_edge(&self.output_c_backprop)?
        }
        {
            new_op.add_edge(&self.reserve_space)?
        }
        {
            match self.rnn_mode {
                None => new_op.set_attr_value_proto("rnn_mode", &vec![18_u8, 4_u8, 108_u8, 115_u8, 116_u8, 109_u8,])?,
                Some(ref value) => (|attr| {new_op.set_attr_string("rnn_mode", attr)})(&value)?,
            };
        }
        {
            match self.input_mode {
                None => new_op.set_attr_value_proto("input_mode", &vec![18_u8, 12_u8, 108_u8, 105_u8, 110_u8, 101_u8, 97_u8, 114_u8, 95_u8, 105_u8, 110_u8, 112_u8, 117_u8, 116_u8,])?,
                Some(ref value) => (|attr| {new_op.set_attr_string("input_mode", attr)})(&value)?,
            };
        }
        {
            match self.direction {
                None => new_op.set_attr_value_proto("direction", &vec![18_u8, 14_u8, 117_u8, 110_u8, 105_u8, 100_u8, 105_u8, 114_u8, 101_u8, 99_u8, 116_u8, 105_u8, 111_u8, 110_u8, 97_u8, 108_u8,])?,
                Some(ref value) => (|attr| {new_op.set_attr_string("direction", attr)})(&value)?,
            };
        }
        {
            match self.dropout {
                None => new_op.set_attr_value_proto("dropout", &vec![37_u8, 0_u8, 0_u8, 0_u8, 0_u8,])?,
                Some(ref value) => (|attr: &f32| {new_op.set_attr_float("dropout", *attr)})(&value)?,
            };
        }
        {
            match self.seed {
                None => new_op.set_attr_value_proto("seed", &vec![24_u8, 0_u8,])?,
                Some(ref value) => (|attr: &i64| {new_op.set_attr_int("seed", *attr)})(&value)?,
            };
        }
        {
            match self.seed2 {
                None => new_op.set_attr_value_proto("seed2", &vec![24_u8, 0_u8,])?,
                Some(ref value) => (|attr: &i64| {new_op.set_attr_int("seed2", *attr)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct CudnnRNNBackprop<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_HALF,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    input: Edge<T>,
    input_h: Edge<T>,
    input_c: Edge<T>,
    params: Edge<T>,
    output: Edge<T>,
    output_h: Edge<T>,
    output_c: Edge<T>,
    output_backprop: Edge<T>,
    output_h_backprop: Edge<T>,
    output_c_backprop: Edge<T>,
    reserve_space: Edge<T>,
    rnn_mode: Option<String>,
    input_mode: Option<String>,
    direction: Option<String>,
    dropout: Option<f32>,
    seed: Option<i64>,
    seed2: Option<i64>,
    op_name: Option<String>,
    id_: usize,
}

impl<T> CudnnRNNBackprop<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_HALF,
      T: 'static,
{
    pub fn input_backprop(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn input_h_backprop(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 1)
        }
    }

    pub fn input_c_backprop(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 2)
        }
    }

    pub fn params_backprop(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 3)
        }
    }

    pub fn rnn_mode(&mut self, rnn_mode: &str) -> Self {
        self.rnn_mode = Some(rnn_mode.to_string());
        self.clone()
    }

    pub fn input_mode(&mut self, input_mode: &str) -> Self {
        self.input_mode = Some(input_mode.to_string());
        self.clone()
    }

    pub fn direction(&mut self, direction: &str) -> Self {
        self.direction = Some(direction.to_string());
        self.clone()
    }

    pub fn dropout(&mut self, dropout: f32) -> Self {
        self.dropout = Some(dropout);
        self.clone()
    }

    pub fn seed(&mut self, seed: i64) -> Self {
        self.seed = Some(seed);
        self.clone()
    }

    pub fn seed2(&mut self, seed2: i64) -> Self {
        self.seed2 = Some(seed2);
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> (Edge<T>, Edge<T>, Edge<T>, Edge<T>) {
        let rc = Rc::new(self);
        (
        {
            Edge::<T>::new(rc.clone(), 0)
        },
        {
            Edge::<T>::new(rc.clone(), 1)
        },
        {
            Edge::<T>::new(rc.clone(), 2)
        },
        {
            Edge::<T>::new(rc.clone(), 3)
        },
        )
    }

    pub fn build(input: Edge<T>, input_h: Edge<T>, input_c: Edge<T>, params: Edge<T>, output: Edge<T>, output_h: Edge<T>, output_c: Edge<T>, output_backprop: Edge<T>, output_h_backprop: Edge<T>, output_c_backprop: Edge<T>, reserve_space: Edge<T>) -> Self {
        Self {
            phantom_T: PhantomData,
            input,
            input_h,
            input_c,
            params,
            output,
            output_h,
            output_c,
            output_backprop,
            output_h_backprop,
            output_c_backprop,
            reserve_space,
            rnn_mode: None,
            input_mode: None,
            direction: None,
            dropout: None,
            seed: None,
            seed2: None,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(input: Edge<T>, input_h: Edge<T>, input_c: Edge<T>, params: Edge<T>, output: Edge<T>, output_h: Edge<T>, output_c: Edge<T>, output_backprop: Edge<T>, output_h_backprop: Edge<T>, output_c_backprop: Edge<T>, reserve_space: Edge<T>) -> (Edge<T>, Edge<T>, Edge<T>, Edge<T>) {
        Self {
            phantom_T: PhantomData,
            input,
            input_h,
            input_c,
            params,
            output,
            output_h,
            output_c,
            output_backprop,
            output_h_backprop,
            output_c_backprop,
            reserve_space,
            rnn_mode: None,
            input_mode: None,
            direction: None,
            dropout: None,
            seed: None,
            seed2: None,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<dtype> GraphOperation for InfeedEnqueue<dtype>
where dtype: TensorType,
      dtype: Clone,
      dtype: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("InfeedEnqueue_{}")?
        };
        let mut new_op = graph.new_operation("InfeedEnqueue", &op_name)?;
        {
            new_op.add_edge(&self.input)?
        }
        {
            match self.shape {
                None => new_op.set_attr_value_proto("shape", &vec![58_u8, 0_u8,])?,
                Some(ref value) => (|attr| {new_op.set_attr_shape("shape", attr)})(&value)?,
            };
        }
        {
            match self.device_ordinal {
                None => new_op.set_attr_value_proto("device_ordinal", &vec![24_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 1_u8,])?,
                Some(ref value) => (|attr: &i64| {new_op.set_attr_int("device_ordinal", *attr)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct InfeedEnqueue<dtype>
where dtype: TensorType,
      dtype: Clone,
      dtype: 'static,
{
    phantom_dtype: PhantomData<dtype>,
    input: Edge<dtype>,
    shape: Option<OtherShape>,
    device_ordinal: Option<i64>,
    op_name: Option<String>,
    id_: usize,
}

impl<dtype> InfeedEnqueue<dtype>
where dtype: TensorType,
      dtype: Clone,
      dtype: 'static,
{
    pub fn shape(&mut self, shape: &OtherShape) -> Self {
        self.shape = Some(shape.clone());
        self.clone()
    }

    pub fn device_ordinal(&mut self, device_ordinal: i64) -> Self {
        self.device_ordinal = Some(device_ordinal);
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> () {
        let rc = Rc::new(self);
        (
        )
    }

    pub fn build(input: Edge<dtype>) -> Self {
        Self {
            phantom_dtype: PhantomData,
            input,
            shape: None,
            device_ordinal: None,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(input: Edge<dtype>) -> () {
        Self {
            phantom_dtype: PhantomData,
            input,
            shape: None,
            device_ordinal: None,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl GraphOperation for PrintV2 {
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("PrintV2_{}")?
        };
        let mut new_op = graph.new_operation("PrintV2", &op_name)?;
        {
            new_op.add_edge(&self.input)?
        }
        {
            match self.output_stream {
                None => new_op.set_attr_value_proto("output_stream", &vec![18_u8, 6_u8, 115_u8, 116_u8, 100_u8, 101_u8, 114_u8, 114_u8,])?,
                Some(ref value) => (|attr| {new_op.set_attr_string("output_stream", attr)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct PrintV2 {
    input: Edge<String>,
    output_stream: Option<String>,
    op_name: Option<String>,
    id_: usize,
}

impl PrintV2 {
    pub fn output_stream(&mut self, output_stream: &str) -> Self {
        self.output_stream = Some(output_stream.to_string());
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> () {
        let rc = Rc::new(self);
        (
        )
    }

    pub fn build(input: Edge<String>) -> Self {
        Self {
            input,
            output_stream: None,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(input: Edge<String>) -> () {
        Self {
            input,
            output_stream: None,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl GraphOperation for RetrieveTPUEmbeddingFTRLParameters {
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("RetrieveTPUEmbeddingFTRLParameters_{}")?
        };
        let mut new_op = graph.new_operation("RetrieveTPUEmbeddingFTRLParameters", &op_name)?;
        {
            match self.table_id {
                None => new_op.set_attr_value_proto("table_id", &vec![24_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 1_u8,])?,
                Some(ref value) => (|attr: &i64| {new_op.set_attr_int("table_id", *attr)})(&value)?,
            };
        }
        {
            match self.table_name {
                None => new_op.set_attr_value_proto("table_name", &vec![18_u8, 0_u8,])?,
                Some(ref value) => (|attr| {new_op.set_attr_string("table_name", attr)})(&value)?,
            };
        }
        {
            (|attr: &i64| {new_op.set_attr_int("num_shards", *attr)})(&self.num_shards)?
        }
        {
            (|attr: &i64| {new_op.set_attr_int("shard_id", *attr)})(&self.shard_id)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct RetrieveTPUEmbeddingFTRLParameters {
    table_id: Option<i64>,
    table_name: Option<String>,
    num_shards: i64,
    shard_id: i64,
    op_name: Option<String>,
    id_: usize,
}

impl RetrieveTPUEmbeddingFTRLParameters {
    pub fn parameters(self) -> Edge<f32> {
        let rc = Rc::new(self);
        {
            Edge::<f32>::new(rc.clone(), 0)
        }
    }

    pub fn accumulators(self) -> Edge<f32> {
        let rc = Rc::new(self);
        {
            Edge::<f32>::new(rc.clone(), 1)
        }
    }

    pub fn linears(self) -> Edge<f32> {
        let rc = Rc::new(self);
        {
            Edge::<f32>::new(rc.clone(), 2)
        }
    }

    pub fn table_id(&mut self, table_id: i64) -> Self {
        self.table_id = Some(table_id);
        self.clone()
    }

    pub fn table_name(&mut self, table_name: &str) -> Self {
        self.table_name = Some(table_name.to_string());
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> (Edge<f32>, Edge<f32>, Edge<f32>) {
        let rc = Rc::new(self);
        (
        {
            Edge::<f32>::new(rc.clone(), 0)
        },
        {
            Edge::<f32>::new(rc.clone(), 1)
        },
        {
            Edge::<f32>::new(rc.clone(), 2)
        },
        )
    }

    pub fn build(num_shards: i64, shard_id: i64) -> Self {
        Self {
            table_id: None,
            table_name: None,
            num_shards: num_shards,
            shard_id: shard_id,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(num_shards: i64, shard_id: i64) -> (Edge<f32>, Edge<f32>, Edge<f32>) {
        Self {
            table_id: None,
            table_name: None,
            num_shards: num_shards,
            shard_id: shard_id,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<T> GraphOperation for DebugNanCount<T>
where T: TensorType,
      T: Clone,
      T: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("DebugNanCount_{}")?
        };
        let mut new_op = graph.new_operation("DebugNanCount", &op_name)?;
        {
            new_op.add_edge(&self.input)?
        }
        {
            match self.device_name {
                None => new_op.set_attr_value_proto("device_name", &vec![18_u8, 0_u8,])?,
                Some(ref value) => (|attr| {new_op.set_attr_string("device_name", attr)})(&value)?,
            };
        }
        {
            match self.tensor_name {
                None => new_op.set_attr_value_proto("tensor_name", &vec![18_u8, 0_u8,])?,
                Some(ref value) => (|attr| {new_op.set_attr_string("tensor_name", attr)})(&value)?,
            };
        }
        {
            match self.debug_urls {
                None => new_op.set_attr_value_proto("debug_urls", &vec![10_u8, 0_u8,])?,
                Some(ref value) => (|attrs| {new_op.set_attr_string_list("debug_urls", attrs)})(&value)?,
            };
        }
        {
            match self.gated_grpc {
                None => new_op.set_attr_value_proto("gated_grpc", &vec![40_u8, 0_u8,])?,
                Some(ref value) => (|attr: &bool| {new_op.set_attr_bool("gated_grpc", *attr)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct DebugNanCount<T>
where T: TensorType,
      T: Clone,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    input: Edge<T>,
    device_name: Option<String>,
    tensor_name: Option<String>,
    debug_urls: Option<Vec<String>>,
    gated_grpc: Option<bool>,
    op_name: Option<String>,
    id_: usize,
}

impl<T> DebugNanCount<T>
where T: TensorType,
      T: Clone,
      T: 'static,
{
    pub fn output(self) -> Edge<i64> {
        let rc = Rc::new(self);
        {
            Edge::<i64>::new(rc.clone(), 0)
        }
    }

    pub fn device_name(&mut self, device_name: &str) -> Self {
        self.device_name = Some(device_name.to_string());
        self.clone()
    }

    pub fn tensor_name(&mut self, tensor_name: &str) -> Self {
        self.tensor_name = Some(tensor_name.to_string());
        self.clone()
    }

    pub fn debug_urls(&mut self, debug_urls: &[String]) -> Self {
        self.debug_urls = Some(debug_urls.to_vec());
        self.clone()
    }

    pub fn gated_grpc(&mut self, gated_grpc: bool) -> Self {
        self.gated_grpc = Some(gated_grpc);
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<i64> {
        let rc = Rc::new(self);
        {
            Edge::<i64>::new(rc.clone(), 0)
        }
    }

    pub fn build(input: Edge<T>) -> Self {
        Self {
            phantom_T: PhantomData,
            input,
            device_name: None,
            tensor_name: None,
            debug_urls: None,
            gated_grpc: None,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(input: Edge<T>) -> Edge<i64> {
        Self {
            phantom_T: PhantomData,
            input,
            device_name: None,
            tensor_name: None,
            debug_urls: None,
            gated_grpc: None,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<T> GraphOperation for ApplyRMSProp<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("ApplyRMSProp_{}")?
        };
        let mut new_op = graph.new_operation("ApplyRMSProp", &op_name)?;
        {
            new_op.add_edge(&self.var)?
        }
        {
            new_op.add_edge(&self.ms)?
        }
        {
            new_op.add_edge(&self.mom)?
        }
        {
            new_op.add_edge(&self.lr)?
        }
        {
            new_op.add_edge(&self.rho)?
        }
        {
            new_op.add_edge(&self.momentum)?
        }
        {
            new_op.add_edge(&self.epsilon)?
        }
        {
            new_op.add_edge(&self.grad)?
        }
        {
            match self.use_locking {
                None => new_op.set_attr_value_proto("use_locking", &vec![40_u8, 0_u8,])?,
                Some(ref value) => (|attr: &bool| {new_op.set_attr_bool("use_locking", *attr)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct ApplyRMSProp<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    var: Edge<T>,
    ms: Edge<T>,
    mom: Edge<T>,
    lr: Edge<T>,
    rho: Edge<T>,
    momentum: Edge<T>,
    epsilon: Edge<T>,
    grad: Edge<T>,
    use_locking: Option<bool>,
    op_name: Option<String>,
    id_: usize,
}

impl<T> ApplyRMSProp<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
{
    pub fn out(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn use_locking(&mut self, use_locking: bool) -> Self {
        self.use_locking = Some(use_locking);
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(var: Edge<T>, ms: Edge<T>, mom: Edge<T>, lr: Edge<T>, rho: Edge<T>, momentum: Edge<T>, epsilon: Edge<T>, grad: Edge<T>) -> Self {
        Self {
            phantom_T: PhantomData,
            var,
            ms,
            mom,
            lr,
            rho,
            momentum,
            epsilon,
            grad,
            use_locking: None,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(var: Edge<T>, ms: Edge<T>, mom: Edge<T>, lr: Edge<T>, rho: Edge<T>, momentum: Edge<T>, epsilon: Edge<T>, grad: Edge<T>) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            var,
            ms,
            mom,
            lr,
            rho,
            momentum,
            epsilon,
            grad,
            use_locking: None,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl GraphOperation for FakeQuantWithMinMaxVars {
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("FakeQuantWithMinMaxVars_{}")?
        };
        let mut new_op = graph.new_operation("FakeQuantWithMinMaxVars", &op_name)?;
        {
            new_op.add_edge(&self.inputs)?
        }
        {
            new_op.add_edge(&self.min)?
        }
        {
            new_op.add_edge(&self.max)?
        }
        {
            match self.num_bits {
                None => new_op.set_attr_value_proto("num_bits", &vec![24_u8, 8_u8,])?,
                Some(ref value) => (|attr: &i64| {new_op.set_attr_int("num_bits", *attr)})(&value)?,
            };
        }
        {
            match self.narrow_range {
                None => new_op.set_attr_value_proto("narrow_range", &vec![40_u8, 0_u8,])?,
                Some(ref value) => (|attr: &bool| {new_op.set_attr_bool("narrow_range", *attr)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct FakeQuantWithMinMaxVars {
    inputs: Edge<f32>,
    min: Edge<f32>,
    max: Edge<f32>,
    num_bits: Option<i64>,
    narrow_range: Option<bool>,
    op_name: Option<String>,
    id_: usize,
}

impl FakeQuantWithMinMaxVars {
    pub fn outputs(self) -> Edge<f32> {
        let rc = Rc::new(self);
        {
            Edge::<f32>::new(rc.clone(), 0)
        }
    }

    pub fn num_bits(&mut self, num_bits: i64) -> Self {
        self.num_bits = Some(num_bits);
        self.clone()
    }

    pub fn narrow_range(&mut self, narrow_range: bool) -> Self {
        self.narrow_range = Some(narrow_range);
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<f32> {
        let rc = Rc::new(self);
        {
            Edge::<f32>::new(rc.clone(), 0)
        }
    }

    pub fn build(inputs: Edge<f32>, min: Edge<f32>, max: Edge<f32>) -> Self {
        Self {
            inputs,
            min,
            max,
            num_bits: None,
            narrow_range: None,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(inputs: Edge<f32>, min: Edge<f32>, max: Edge<f32>) -> Edge<f32> {
        Self {
            inputs,
            min,
            max,
            num_bits: None,
            narrow_range: None,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<T, Tidx, output_type> GraphOperation for ArgMax<T, Tidx, output_type>
where T: TensorType,
      T: Clone,
      Tidx: TensorType,
      Tidx: Clone,
      output_type: TensorType,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
      Tidx: con_or_DT_INT32_or_DT_INT64,
      Tidx: 'static,
      output_type: con_or_DT_INT32_or_DT_INT64,
      output_type: 'static,
      output_type: Clone,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("ArgMax_{}")?
        };
        let mut new_op = graph.new_operation("ArgMax", &op_name)?;
        {
            new_op.add_edge(&self.input)?
        }
        {
            new_op.add_edge(&self.dimension)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct ArgMax<T, Tidx, output_type>
where T: TensorType,
      T: Clone,
      Tidx: TensorType,
      Tidx: Clone,
      output_type: TensorType,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
      Tidx: con_or_DT_INT32_or_DT_INT64,
      Tidx: 'static,
      output_type: con_or_DT_INT32_or_DT_INT64,
      output_type: 'static,
      output_type: Clone,
{
    phantom_T: PhantomData<T>,
    input: Edge<T>,
    phantom_Tidx: PhantomData<Tidx>,
    dimension: Edge<Tidx>,
    phantom_output_type: PhantomData<output_type>,
    op_name: Option<String>,
    id_: usize,
}

impl<T, Tidx, output_type> ArgMax<T, Tidx, output_type>
where T: TensorType,
      T: Clone,
      Tidx: TensorType,
      Tidx: Clone,
      output_type: TensorType,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
      Tidx: con_or_DT_INT32_or_DT_INT64,
      Tidx: 'static,
      output_type: con_or_DT_INT32_or_DT_INT64,
      output_type: 'static,
      output_type: Clone,
{
    pub fn output(self) -> Edge<output_type> {
        let rc = Rc::new(self);
        {
            Edge::<output_type>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<output_type> {
        let rc = Rc::new(self);
        {
            Edge::<output_type>::new(rc.clone(), 0)
        }
    }

    pub fn build(input: Edge<T>, dimension: Edge<Tidx>) -> Self {
        Self {
            phantom_T: PhantomData,
            input,
            phantom_Tidx: PhantomData,
            dimension,
            phantom_output_type: PhantomData,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(input: Edge<T>, dimension: Edge<Tidx>) -> Edge<output_type> {
        Self {
            phantom_T: PhantomData,
            input,
            phantom_Tidx: PhantomData,
            dimension,
            phantom_output_type: PhantomData,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<T> GraphOperation for FractionalMaxPool<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_INT64,
      T: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("FractionalMaxPool_{}")?
        };
        let mut new_op = graph.new_operation("FractionalMaxPool", &op_name)?;
        {
            new_op.add_edge(&self.value)?
        }
        {
            (|attrs| {new_op.set_attr_float_list("pooling_ratio", attrs)})(&self.pooling_ratio)?
        }
        {
            match self.pseudo_random {
                None => new_op.set_attr_value_proto("pseudo_random", &vec![40_u8, 0_u8,])?,
                Some(ref value) => (|attr: &bool| {new_op.set_attr_bool("pseudo_random", *attr)})(&value)?,
            };
        }
        {
            match self.overlapping {
                None => new_op.set_attr_value_proto("overlapping", &vec![40_u8, 0_u8,])?,
                Some(ref value) => (|attr: &bool| {new_op.set_attr_bool("overlapping", *attr)})(&value)?,
            };
        }
        {
            match self.deterministic {
                None => new_op.set_attr_value_proto("deterministic", &vec![40_u8, 0_u8,])?,
                Some(ref value) => (|attr: &bool| {new_op.set_attr_bool("deterministic", *attr)})(&value)?,
            };
        }
        {
            match self.seed {
                None => new_op.set_attr_value_proto("seed", &vec![24_u8, 0_u8,])?,
                Some(ref value) => (|attr: &i64| {new_op.set_attr_int("seed", *attr)})(&value)?,
            };
        }
        {
            match self.seed2 {
                None => new_op.set_attr_value_proto("seed2", &vec![24_u8, 0_u8,])?,
                Some(ref value) => (|attr: &i64| {new_op.set_attr_int("seed2", *attr)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct FractionalMaxPool<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_INT64,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    value: Edge<T>,
    pooling_ratio: Vec<f32>,
    pseudo_random: Option<bool>,
    overlapping: Option<bool>,
    deterministic: Option<bool>,
    seed: Option<i64>,
    seed2: Option<i64>,
    op_name: Option<String>,
    id_: usize,
}

impl<T> FractionalMaxPool<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_INT64,
      T: 'static,
{
    pub fn output(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn row_pooling_sequence(self) -> Edge<i64> {
        let rc = Rc::new(self);
        {
            Edge::<i64>::new(rc.clone(), 1)
        }
    }

    pub fn col_pooling_sequence(self) -> Edge<i64> {
        let rc = Rc::new(self);
        {
            Edge::<i64>::new(rc.clone(), 2)
        }
    }

    pub fn pseudo_random(&mut self, pseudo_random: bool) -> Self {
        self.pseudo_random = Some(pseudo_random);
        self.clone()
    }

    pub fn overlapping(&mut self, overlapping: bool) -> Self {
        self.overlapping = Some(overlapping);
        self.clone()
    }

    pub fn deterministic(&mut self, deterministic: bool) -> Self {
        self.deterministic = Some(deterministic);
        self.clone()
    }

    pub fn seed(&mut self, seed: i64) -> Self {
        self.seed = Some(seed);
        self.clone()
    }

    pub fn seed2(&mut self, seed2: i64) -> Self {
        self.seed2 = Some(seed2);
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> (Edge<T>, Edge<i64>, Edge<i64>) {
        let rc = Rc::new(self);
        (
        {
            Edge::<T>::new(rc.clone(), 0)
        },
        {
            Edge::<i64>::new(rc.clone(), 1)
        },
        {
            Edge::<i64>::new(rc.clone(), 2)
        },
        )
    }

    pub fn build(value: Edge<T>, pooling_ratio: &[f32]) -> Self {
        Self {
            phantom_T: PhantomData,
            value,
            pooling_ratio: pooling_ratio.to_vec(),
            pseudo_random: None,
            overlapping: None,
            deterministic: None,
            seed: None,
            seed2: None,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(value: Edge<T>, pooling_ratio: &[f32]) -> (Edge<T>, Edge<i64>, Edge<i64>) {
        Self {
            phantom_T: PhantomData,
            value,
            pooling_ratio: pooling_ratio.to_vec(),
            pseudo_random: None,
            overlapping: None,
            deterministic: None,
            seed: None,
            seed2: None,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

pub trait con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_BOOL_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_BOOL_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64 for BFloat16 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_BOOL_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64 for OtherComplex<f32> {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_BOOL_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64 for OtherComplex<f64> {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_BOOL_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64 for bool {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_BOOL_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64 for f32 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_BOOL_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64 for f64 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_BOOL_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64 for i16 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_BOOL_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64 for i32 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_BOOL_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64 for i64 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_BOOL_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64 for i8 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_BOOL_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64 for u16 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_BOOL_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64 for u32 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_BOOL_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64 for u64 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_BOOL_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64 for u8 {
}

impl<T, Tindices> GraphOperation for ScatterNdNonAliasingAdd<T, Tindices>
where T: TensorType,
      T: Clone,
      Tindices: TensorType,
      Tindices: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_BOOL_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
      Tindices: con_or_DT_INT32_or_DT_INT64,
      Tindices: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("ScatterNdNonAliasingAdd_{}")?
        };
        let mut new_op = graph.new_operation("ScatterNdNonAliasingAdd", &op_name)?;
        {
            new_op.add_edge(&self.input)?
        }
        {
            new_op.add_edge(&self.indices)?
        }
        {
            new_op.add_edge(&self.updates)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct ScatterNdNonAliasingAdd<T, Tindices>
where T: TensorType,
      T: Clone,
      Tindices: TensorType,
      Tindices: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_BOOL_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
      Tindices: con_or_DT_INT32_or_DT_INT64,
      Tindices: 'static,
{
    phantom_T: PhantomData<T>,
    input: Edge<T>,
    phantom_Tindices: PhantomData<Tindices>,
    indices: Edge<Tindices>,
    updates: Edge<T>,
    op_name: Option<String>,
    id_: usize,
}

impl<T, Tindices> ScatterNdNonAliasingAdd<T, Tindices>
where T: TensorType,
      T: Clone,
      Tindices: TensorType,
      Tindices: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_BOOL_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
      Tindices: con_or_DT_INT32_or_DT_INT64,
      Tindices: 'static,
{
    pub fn output(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(input: Edge<T>, indices: Edge<Tindices>, updates: Edge<T>) -> Self {
        Self {
            phantom_T: PhantomData,
            input,
            phantom_Tindices: PhantomData,
            indices,
            updates,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(input: Edge<T>, indices: Edge<Tindices>, updates: Edge<T>) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            input,
            phantom_Tindices: PhantomData,
            indices,
            updates,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl GraphOperation for TensorArraySize {
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("TensorArraySize_{}")?
        };
        let mut new_op = graph.new_operation("TensorArraySize", &op_name)?;
        {
            new_op.add_edge(&self.handle)?
        }
        {
            new_op.add_edge(&self.flow_in)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct TensorArraySize {
    handle: Edge<String>,
    flow_in: Edge<f32>,
    op_name: Option<String>,
    id_: usize,
}

impl TensorArraySize {
    pub fn size(self) -> Edge<i32> {
        let rc = Rc::new(self);
        {
            Edge::<i32>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<i32> {
        let rc = Rc::new(self);
        {
            Edge::<i32>::new(rc.clone(), 0)
        }
    }

    pub fn build(handle: Edge<String>, flow_in: Edge<f32>) -> Self {
        Self {
            handle,
            flow_in,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(handle: Edge<String>, flow_in: Edge<f32>) -> Edge<i32> {
        Self {
            handle,
            flow_in,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl GraphOperation for CTCGreedyDecoder {
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("CTCGreedyDecoder_{}")?
        };
        let mut new_op = graph.new_operation("CTCGreedyDecoder", &op_name)?;
        {
            new_op.add_edge(&self.inputs)?
        }
        {
            new_op.add_edge(&self.sequence_length)?
        }
        {
            match self.merge_repeated {
                None => new_op.set_attr_value_proto("merge_repeated", &vec![40_u8, 0_u8,])?,
                Some(ref value) => (|attr: &bool| {new_op.set_attr_bool("merge_repeated", *attr)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct CTCGreedyDecoder {
    inputs: Edge<f32>,
    sequence_length: Edge<i32>,
    merge_repeated: Option<bool>,
    op_name: Option<String>,
    id_: usize,
}

impl CTCGreedyDecoder {
    pub fn decoded_indices(self) -> Edge<i64> {
        let rc = Rc::new(self);
        {
            Edge::<i64>::new(rc.clone(), 0)
        }
    }

    pub fn decoded_values(self) -> Edge<i64> {
        let rc = Rc::new(self);
        {
            Edge::<i64>::new(rc.clone(), 1)
        }
    }

    pub fn decoded_shape(self) -> Edge<i64> {
        let rc = Rc::new(self);
        {
            Edge::<i64>::new(rc.clone(), 2)
        }
    }

    pub fn log_probability(self) -> Edge<f32> {
        let rc = Rc::new(self);
        {
            Edge::<f32>::new(rc.clone(), 3)
        }
    }

    pub fn merge_repeated(&mut self, merge_repeated: bool) -> Self {
        self.merge_repeated = Some(merge_repeated);
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> (Edge<i64>, Edge<i64>, Edge<i64>, Edge<f32>) {
        let rc = Rc::new(self);
        (
        {
            Edge::<i64>::new(rc.clone(), 0)
        },
        {
            Edge::<i64>::new(rc.clone(), 1)
        },
        {
            Edge::<i64>::new(rc.clone(), 2)
        },
        {
            Edge::<f32>::new(rc.clone(), 3)
        },
        )
    }

    pub fn build(inputs: Edge<f32>, sequence_length: Edge<i32>) -> Self {
        Self {
            inputs,
            sequence_length,
            merge_repeated: None,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(inputs: Edge<f32>, sequence_length: Edge<i32>) -> (Edge<i64>, Edge<i64>, Edge<i64>, Edge<f32>) {
        Self {
            inputs,
            sequence_length,
            merge_repeated: None,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl GraphOperation for LoadTPUEmbeddingMomentumParameters {
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("LoadTPUEmbeddingMomentumParameters_{}")?
        };
        let mut new_op = graph.new_operation("LoadTPUEmbeddingMomentumParameters", &op_name)?;
        {
            new_op.add_edge(&self.parameters)?
        }
        {
            new_op.add_edge(&self.momenta)?
        }
        {
            match self.table_id {
                None => new_op.set_attr_value_proto("table_id", &vec![24_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 1_u8,])?,
                Some(ref value) => (|attr: &i64| {new_op.set_attr_int("table_id", *attr)})(&value)?,
            };
        }
        {
            match self.table_name {
                None => new_op.set_attr_value_proto("table_name", &vec![18_u8, 0_u8,])?,
                Some(ref value) => (|attr| {new_op.set_attr_string("table_name", attr)})(&value)?,
            };
        }
        {
            (|attr: &i64| {new_op.set_attr_int("num_shards", *attr)})(&self.num_shards)?
        }
        {
            (|attr: &i64| {new_op.set_attr_int("shard_id", *attr)})(&self.shard_id)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct LoadTPUEmbeddingMomentumParameters {
    parameters: Edge<f32>,
    momenta: Edge<f32>,
    table_id: Option<i64>,
    table_name: Option<String>,
    num_shards: i64,
    shard_id: i64,
    op_name: Option<String>,
    id_: usize,
}

impl LoadTPUEmbeddingMomentumParameters {
    pub fn table_id(&mut self, table_id: i64) -> Self {
        self.table_id = Some(table_id);
        self.clone()
    }

    pub fn table_name(&mut self, table_name: &str) -> Self {
        self.table_name = Some(table_name.to_string());
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> () {
        let rc = Rc::new(self);
        (
        )
    }

    pub fn build(parameters: Edge<f32>, momenta: Edge<f32>, num_shards: i64, shard_id: i64) -> Self {
        Self {
            parameters,
            momenta,
            table_id: None,
            table_name: None,
            num_shards: num_shards,
            shard_id: shard_id,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(parameters: Edge<f32>, momenta: Edge<f32>, num_shards: i64, shard_id: i64) -> () {
        Self {
            parameters,
            momenta,
            table_id: None,
            table_name: None,
            num_shards: num_shards,
            shard_id: shard_id,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl GraphOperation for BoostedTreesBucketize {
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("BoostedTreesBucketize_{}")?
        };
        let mut new_op = graph.new_operation("BoostedTreesBucketize", &op_name)?;
        {
            new_op.add_edge(&self.float_values)?
        }
        {
            new_op.add_edge(&self.bucket_boundaries)?
        }
        {
            (|attr: &i64| {new_op.set_attr_int("num_features", *attr)})(&self.num_features)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct BoostedTreesBucketize {
    float_values: Edge<f32>,
    bucket_boundaries: Edge<f32>,
    num_features: i64,
    op_name: Option<String>,
    id_: usize,
}

impl BoostedTreesBucketize {
    pub fn buckets(self) -> Edge<i32> {
        let rc = Rc::new(self);
        {
            Edge::<i32>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<i32> {
        let rc = Rc::new(self);
        {
            Edge::<i32>::new(rc.clone(), 0)
        }
    }

    pub fn build(float_values: Edge<f32>, bucket_boundaries: Edge<f32>, num_features: i64) -> Self {
        Self {
            float_values,
            bucket_boundaries,
            num_features: num_features,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(float_values: Edge<f32>, bucket_boundaries: Edge<f32>, num_features: i64) -> Edge<i32> {
        Self {
            float_values,
            bucket_boundaries,
            num_features: num_features,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<T, Tindices> GraphOperation for ScatterNdAdd<T, Tindices>
where T: TensorType,
      T: Clone,
      Tindices: TensorType,
      Tindices: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
      Tindices: con_or_DT_INT32_or_DT_INT64,
      Tindices: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("ScatterNdAdd_{}")?
        };
        let mut new_op = graph.new_operation("ScatterNdAdd", &op_name)?;
        {
            new_op.add_edge(&self.ref_)?
        }
        {
            new_op.add_edge(&self.indices)?
        }
        {
            new_op.add_edge(&self.updates)?
        }
        {
            match self.use_locking {
                None => new_op.set_attr_value_proto("use_locking", &vec![40_u8, 0_u8,])?,
                Some(ref value) => (|attr: &bool| {new_op.set_attr_bool("use_locking", *attr)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct ScatterNdAdd<T, Tindices>
where T: TensorType,
      T: Clone,
      Tindices: TensorType,
      Tindices: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
      Tindices: con_or_DT_INT32_or_DT_INT64,
      Tindices: 'static,
{
    phantom_T: PhantomData<T>,
    ref_: Edge<T>,
    phantom_Tindices: PhantomData<Tindices>,
    indices: Edge<Tindices>,
    updates: Edge<T>,
    use_locking: Option<bool>,
    op_name: Option<String>,
    id_: usize,
}

impl<T, Tindices> ScatterNdAdd<T, Tindices>
where T: TensorType,
      T: Clone,
      Tindices: TensorType,
      Tindices: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
      Tindices: con_or_DT_INT32_or_DT_INT64,
      Tindices: 'static,
{
    pub fn output_ref(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn use_locking(&mut self, use_locking: bool) -> Self {
        self.use_locking = Some(use_locking);
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(ref_: Edge<T>, indices: Edge<Tindices>, updates: Edge<T>) -> Self {
        Self {
            phantom_T: PhantomData,
            ref_,
            phantom_Tindices: PhantomData,
            indices,
            updates,
            use_locking: None,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(ref_: Edge<T>, indices: Edge<Tindices>, updates: Edge<T>) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            ref_,
            phantom_Tindices: PhantomData,
            indices,
            updates,
            use_locking: None,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<T, Tindices> GraphOperation for ScatterDiv<T, Tindices>
where T: TensorType,
      T: Clone,
      Tindices: TensorType,
      Tindices: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
      Tindices: con_or_DT_INT32_or_DT_INT64,
      Tindices: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("ScatterDiv_{}")?
        };
        let mut new_op = graph.new_operation("ScatterDiv", &op_name)?;
        {
            new_op.add_edge(&self.ref_)?
        }
        {
            new_op.add_edge(&self.indices)?
        }
        {
            new_op.add_edge(&self.updates)?
        }
        {
            match self.use_locking {
                None => new_op.set_attr_value_proto("use_locking", &vec![40_u8, 0_u8,])?,
                Some(ref value) => (|attr: &bool| {new_op.set_attr_bool("use_locking", *attr)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct ScatterDiv<T, Tindices>
where T: TensorType,
      T: Clone,
      Tindices: TensorType,
      Tindices: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
      Tindices: con_or_DT_INT32_or_DT_INT64,
      Tindices: 'static,
{
    phantom_T: PhantomData<T>,
    ref_: Edge<T>,
    phantom_Tindices: PhantomData<Tindices>,
    indices: Edge<Tindices>,
    updates: Edge<T>,
    use_locking: Option<bool>,
    op_name: Option<String>,
    id_: usize,
}

impl<T, Tindices> ScatterDiv<T, Tindices>
where T: TensorType,
      T: Clone,
      Tindices: TensorType,
      Tindices: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
      Tindices: con_or_DT_INT32_or_DT_INT64,
      Tindices: 'static,
{
    pub fn output_ref(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn use_locking(&mut self, use_locking: bool) -> Self {
        self.use_locking = Some(use_locking);
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(ref_: Edge<T>, indices: Edge<Tindices>, updates: Edge<T>) -> Self {
        Self {
            phantom_T: PhantomData,
            ref_,
            phantom_Tindices: PhantomData,
            indices,
            updates,
            use_locking: None,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(ref_: Edge<T>, indices: Edge<Tindices>, updates: Edge<T>) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            ref_,
            phantom_Tindices: PhantomData,
            indices,
            updates,
            use_locking: None,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<T> GraphOperation for Atan<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_COMPLEX64_or_DT_INT64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF,
      T: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("Atan_{}")?
        };
        let mut new_op = graph.new_operation("Atan", &op_name)?;
        {
            new_op.add_edge(&self.x)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct Atan<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_COMPLEX64_or_DT_INT64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    x: Edge<T>,
    op_name: Option<String>,
    id_: usize,
}

impl<T> Atan<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_COMPLEX64_or_DT_INT64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF,
      T: 'static,
{
    pub fn y(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(x: Edge<T>) -> Self {
        Self {
            phantom_T: PhantomData,
            x,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(x: Edge<T>) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            x,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl GraphOperation for EncodeWav {
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("EncodeWav_{}")?
        };
        let mut new_op = graph.new_operation("EncodeWav", &op_name)?;
        {
            new_op.add_edge(&self.audio)?
        }
        {
            new_op.add_edge(&self.sample_rate)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct EncodeWav {
    audio: Edge<f32>,
    sample_rate: Edge<i32>,
    op_name: Option<String>,
    id_: usize,
}

impl EncodeWav {
    pub fn contents(self) -> Edge<String> {
        let rc = Rc::new(self);
        {
            Edge::<String>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<String> {
        let rc = Rc::new(self);
        {
            Edge::<String>::new(rc.clone(), 0)
        }
    }

    pub fn build(audio: Edge<f32>, sample_rate: Edge<i32>) -> Self {
        Self {
            audio,
            sample_rate,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(audio: Edge<f32>, sample_rate: Edge<i32>) -> Edge<String> {
        Self {
            audio,
            sample_rate,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<T> GraphOperation for Squeeze<T>
where T: TensorType,
      T: Clone,
      T: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("Squeeze_{}")?
        };
        let mut new_op = graph.new_operation("Squeeze", &op_name)?;
        {
            new_op.add_edge(&self.input)?
        }
        {
            match self.squeeze_dims {
                None => new_op.set_attr_value_proto("squeeze_dims", &vec![10_u8, 0_u8,])?,
                Some(ref value) => (|attrs| {new_op.set_attr_int_list("squeeze_dims", attrs)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct Squeeze<T>
where T: TensorType,
      T: Clone,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    input: Edge<T>,
    squeeze_dims: Option<Vec<i64>>,
    op_name: Option<String>,
    id_: usize,
}

impl<T> Squeeze<T>
where T: TensorType,
      T: Clone,
      T: 'static,
{
    pub fn output(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn squeeze_dims(&mut self, squeeze_dims: &[i64]) -> Self {
        self.squeeze_dims = Some(squeeze_dims.to_vec());
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(input: Edge<T>) -> Self {
        Self {
            phantom_T: PhantomData,
            input,
            squeeze_dims: None,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(input: Edge<T>) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            input,
            squeeze_dims: None,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl GraphOperation for LoadTPUEmbeddingADAMParameters {
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("LoadTPUEmbeddingADAMParameters_{}")?
        };
        let mut new_op = graph.new_operation("LoadTPUEmbeddingADAMParameters", &op_name)?;
        {
            new_op.add_edge(&self.parameters)?
        }
        {
            new_op.add_edge(&self.momenta)?
        }
        {
            new_op.add_edge(&self.velocities)?
        }
        {
            match self.table_id {
                None => new_op.set_attr_value_proto("table_id", &vec![24_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 1_u8,])?,
                Some(ref value) => (|attr: &i64| {new_op.set_attr_int("table_id", *attr)})(&value)?,
            };
        }
        {
            match self.table_name {
                None => new_op.set_attr_value_proto("table_name", &vec![18_u8, 0_u8,])?,
                Some(ref value) => (|attr| {new_op.set_attr_string("table_name", attr)})(&value)?,
            };
        }
        {
            (|attr: &i64| {new_op.set_attr_int("num_shards", *attr)})(&self.num_shards)?
        }
        {
            (|attr: &i64| {new_op.set_attr_int("shard_id", *attr)})(&self.shard_id)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct LoadTPUEmbeddingADAMParameters {
    parameters: Edge<f32>,
    momenta: Edge<f32>,
    velocities: Edge<f32>,
    table_id: Option<i64>,
    table_name: Option<String>,
    num_shards: i64,
    shard_id: i64,
    op_name: Option<String>,
    id_: usize,
}

impl LoadTPUEmbeddingADAMParameters {
    pub fn table_id(&mut self, table_id: i64) -> Self {
        self.table_id = Some(table_id);
        self.clone()
    }

    pub fn table_name(&mut self, table_name: &str) -> Self {
        self.table_name = Some(table_name.to_string());
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> () {
        let rc = Rc::new(self);
        (
        )
    }

    pub fn build(parameters: Edge<f32>, momenta: Edge<f32>, velocities: Edge<f32>, num_shards: i64, shard_id: i64) -> Self {
        Self {
            parameters,
            momenta,
            velocities,
            table_id: None,
            table_name: None,
            num_shards: num_shards,
            shard_id: shard_id,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(parameters: Edge<f32>, momenta: Edge<f32>, velocities: Edge<f32>, num_shards: i64, shard_id: i64) -> () {
        Self {
            parameters,
            momenta,
            velocities,
            table_id: None,
            table_name: None,
            num_shards: num_shards,
            shard_id: shard_id,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<T> GraphOperation for NcclBroadcast<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_INT64_or_DT_HALF,
      T: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("NcclBroadcast_{}")?
        };
        let mut new_op = graph.new_operation("NcclBroadcast", &op_name)?;
        {
            new_op.add_edge(&self.input)?
        }
        {
            (|attr| {new_op.set_attr_shape("shape", attr)})(&self.shape)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct NcclBroadcast<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_INT64_or_DT_HALF,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    input: Edge<T>,
    shape: OtherShape,
    op_name: Option<String>,
    id_: usize,
}

impl<T> NcclBroadcast<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_INT64_or_DT_HALF,
      T: 'static,
{
    pub fn output(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(input: Edge<T>, shape: &OtherShape) -> Self {
        Self {
            phantom_T: PhantomData,
            input,
            shape: shape.clone(),
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(input: Edge<T>, shape: &OtherShape) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            input,
            shape: shape.clone(),
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<T> GraphOperation for ResizeArea<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_UINT16_or_DT_HALF,
      T: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("ResizeArea_{}")?
        };
        let mut new_op = graph.new_operation("ResizeArea", &op_name)?;
        {
            new_op.add_edge(&self.images)?
        }
        {
            new_op.add_edge(&self.size)?
        }
        {
            match self.align_corners {
                None => new_op.set_attr_value_proto("align_corners", &vec![40_u8, 0_u8,])?,
                Some(ref value) => (|attr: &bool| {new_op.set_attr_bool("align_corners", *attr)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct ResizeArea<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_UINT16_or_DT_HALF,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    images: Edge<T>,
    size: Edge<i32>,
    align_corners: Option<bool>,
    op_name: Option<String>,
    id_: usize,
}

impl<T> ResizeArea<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_UINT16_or_DT_HALF,
      T: 'static,
{
    pub fn resized_images(self) -> Edge<f32> {
        let rc = Rc::new(self);
        {
            Edge::<f32>::new(rc.clone(), 0)
        }
    }

    pub fn align_corners(&mut self, align_corners: bool) -> Self {
        self.align_corners = Some(align_corners);
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<f32> {
        let rc = Rc::new(self);
        {
            Edge::<f32>::new(rc.clone(), 0)
        }
    }

    pub fn build(images: Edge<T>, size: Edge<i32>) -> Self {
        Self {
            phantom_T: PhantomData,
            images,
            size,
            align_corners: None,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(images: Edge<T>, size: Edge<i32>) -> Edge<f32> {
        Self {
            phantom_T: PhantomData,
            images,
            size,
            align_corners: None,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl GraphOperation for NegTrain {
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("NegTrain_{}")?
        };
        let mut new_op = graph.new_operation("NegTrain", &op_name)?;
        {
            new_op.add_edge(&self.w_in)?
        }
        {
            new_op.add_edge(&self.w_out)?
        }
        {
            new_op.add_edge(&self.examples)?
        }
        {
            new_op.add_edge(&self.labels)?
        }
        {
            new_op.add_edge(&self.lr)?
        }
        {
            (|attrs| {new_op.set_attr_int_list("vocab_count", attrs)})(&self.vocab_count)?
        }
        {
            (|attr: &i64| {new_op.set_attr_int("num_negative_samples", *attr)})(&self.num_negative_samples)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct NegTrain {
    w_in: Edge<f32>,
    w_out: Edge<f32>,
    examples: Edge<i32>,
    labels: Edge<i32>,
    lr: Edge<f32>,
    vocab_count: Vec<i64>,
    num_negative_samples: i64,
    op_name: Option<String>,
    id_: usize,
}

impl NegTrain {
    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> () {
        let rc = Rc::new(self);
        (
        )
    }

    pub fn build(w_in: Edge<f32>, w_out: Edge<f32>, examples: Edge<i32>, labels: Edge<i32>, lr: Edge<f32>, vocab_count: &[i64], num_negative_samples: i64) -> Self {
        Self {
            w_in,
            w_out,
            examples,
            labels,
            lr,
            vocab_count: vocab_count.to_vec(),
            num_negative_samples: num_negative_samples,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(w_in: Edge<f32>, w_out: Edge<f32>, examples: Edge<i32>, labels: Edge<i32>, lr: Edge<f32>, vocab_count: &[i64], num_negative_samples: i64) -> () {
        Self {
            w_in,
            w_out,
            examples,
            labels,
            lr,
            vocab_count: vocab_count.to_vec(),
            num_negative_samples: num_negative_samples,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<T, Tout> GraphOperation for Real<T, Tout>
where T: TensorType,
      T: Clone,
      Tout: TensorType,
      T: con_or_DT_COMPLEX64_or_DT_COMPLEX128,
      T: 'static,
      Tout: con_or_DT_FLOAT_or_DT_DOUBLE,
      Tout: 'static,
      Tout: Clone,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("Real_{}")?
        };
        let mut new_op = graph.new_operation("Real", &op_name)?;
        {
            new_op.add_edge(&self.input)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct Real<T, Tout>
where T: TensorType,
      T: Clone,
      Tout: TensorType,
      T: con_or_DT_COMPLEX64_or_DT_COMPLEX128,
      T: 'static,
      Tout: con_or_DT_FLOAT_or_DT_DOUBLE,
      Tout: 'static,
      Tout: Clone,
{
    phantom_T: PhantomData<T>,
    input: Edge<T>,
    phantom_Tout: PhantomData<Tout>,
    op_name: Option<String>,
    id_: usize,
}

impl<T, Tout> Real<T, Tout>
where T: TensorType,
      T: Clone,
      Tout: TensorType,
      T: con_or_DT_COMPLEX64_or_DT_COMPLEX128,
      T: 'static,
      Tout: con_or_DT_FLOAT_or_DT_DOUBLE,
      Tout: 'static,
      Tout: Clone,
{
    pub fn output(self) -> Edge<Tout> {
        let rc = Rc::new(self);
        {
            Edge::<Tout>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<Tout> {
        let rc = Rc::new(self);
        {
            Edge::<Tout>::new(rc.clone(), 0)
        }
    }

    pub fn build(input: Edge<T>) -> Self {
        Self {
            phantom_T: PhantomData,
            input,
            phantom_Tout: PhantomData,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(input: Edge<T>) -> Edge<Tout> {
        Self {
            phantom_T: PhantomData,
            input,
            phantom_Tout: PhantomData,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<T> GraphOperation for RealDiv<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF,
      T: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("RealDiv_{}")?
        };
        let mut new_op = graph.new_operation("RealDiv", &op_name)?;
        {
            new_op.add_edge(&self.x)?
        }
        {
            new_op.add_edge(&self.y)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct RealDiv<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    x: Edge<T>,
    y: Edge<T>,
    op_name: Option<String>,
    id_: usize,
}

impl<T> RealDiv<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF,
      T: 'static,
{
    pub fn z(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(x: Edge<T>, y: Edge<T>) -> Self {
        Self {
            phantom_T: PhantomData,
            x,
            y,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(x: Edge<T>, y: Edge<T>) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            x,
            y,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl GraphOperation for LoadTPUEmbeddingAdagradParameters {
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("LoadTPUEmbeddingAdagradParameters_{}")?
        };
        let mut new_op = graph.new_operation("LoadTPUEmbeddingAdagradParameters", &op_name)?;
        {
            new_op.add_edge(&self.parameters)?
        }
        {
            new_op.add_edge(&self.accumulators)?
        }
        {
            match self.table_id {
                None => new_op.set_attr_value_proto("table_id", &vec![24_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 1_u8,])?,
                Some(ref value) => (|attr: &i64| {new_op.set_attr_int("table_id", *attr)})(&value)?,
            };
        }
        {
            match self.table_name {
                None => new_op.set_attr_value_proto("table_name", &vec![18_u8, 0_u8,])?,
                Some(ref value) => (|attr| {new_op.set_attr_string("table_name", attr)})(&value)?,
            };
        }
        {
            (|attr: &i64| {new_op.set_attr_int("num_shards", *attr)})(&self.num_shards)?
        }
        {
            (|attr: &i64| {new_op.set_attr_int("shard_id", *attr)})(&self.shard_id)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct LoadTPUEmbeddingAdagradParameters {
    parameters: Edge<f32>,
    accumulators: Edge<f32>,
    table_id: Option<i64>,
    table_name: Option<String>,
    num_shards: i64,
    shard_id: i64,
    op_name: Option<String>,
    id_: usize,
}

impl LoadTPUEmbeddingAdagradParameters {
    pub fn table_id(&mut self, table_id: i64) -> Self {
        self.table_id = Some(table_id);
        self.clone()
    }

    pub fn table_name(&mut self, table_name: &str) -> Self {
        self.table_name = Some(table_name.to_string());
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> () {
        let rc = Rc::new(self);
        (
        )
    }

    pub fn build(parameters: Edge<f32>, accumulators: Edge<f32>, num_shards: i64, shard_id: i64) -> Self {
        Self {
            parameters,
            accumulators,
            table_id: None,
            table_name: None,
            num_shards: num_shards,
            shard_id: shard_id,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(parameters: Edge<f32>, accumulators: Edge<f32>, num_shards: i64, shard_id: i64) -> () {
        Self {
            parameters,
            accumulators,
            table_id: None,
            table_name: None,
            num_shards: num_shards,
            shard_id: shard_id,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<T> GraphOperation for ApplyAdam<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("ApplyAdam_{}")?
        };
        let mut new_op = graph.new_operation("ApplyAdam", &op_name)?;
        {
            new_op.add_edge(&self.var)?
        }
        {
            new_op.add_edge(&self.m)?
        }
        {
            new_op.add_edge(&self.v)?
        }
        {
            new_op.add_edge(&self.beta1_power)?
        }
        {
            new_op.add_edge(&self.beta2_power)?
        }
        {
            new_op.add_edge(&self.lr)?
        }
        {
            new_op.add_edge(&self.beta1)?
        }
        {
            new_op.add_edge(&self.beta2)?
        }
        {
            new_op.add_edge(&self.epsilon)?
        }
        {
            new_op.add_edge(&self.grad)?
        }
        {
            match self.use_locking {
                None => new_op.set_attr_value_proto("use_locking", &vec![40_u8, 0_u8,])?,
                Some(ref value) => (|attr: &bool| {new_op.set_attr_bool("use_locking", *attr)})(&value)?,
            };
        }
        {
            match self.use_nesterov {
                None => new_op.set_attr_value_proto("use_nesterov", &vec![40_u8, 0_u8,])?,
                Some(ref value) => (|attr: &bool| {new_op.set_attr_bool("use_nesterov", *attr)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct ApplyAdam<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    var: Edge<T>,
    m: Edge<T>,
    v: Edge<T>,
    beta1_power: Edge<T>,
    beta2_power: Edge<T>,
    lr: Edge<T>,
    beta1: Edge<T>,
    beta2: Edge<T>,
    epsilon: Edge<T>,
    grad: Edge<T>,
    use_locking: Option<bool>,
    use_nesterov: Option<bool>,
    op_name: Option<String>,
    id_: usize,
}

impl<T> ApplyAdam<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
{
    pub fn out(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn use_locking(&mut self, use_locking: bool) -> Self {
        self.use_locking = Some(use_locking);
        self.clone()
    }

    pub fn use_nesterov(&mut self, use_nesterov: bool) -> Self {
        self.use_nesterov = Some(use_nesterov);
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(var: Edge<T>, m: Edge<T>, v: Edge<T>, beta1_power: Edge<T>, beta2_power: Edge<T>, lr: Edge<T>, beta1: Edge<T>, beta2: Edge<T>, epsilon: Edge<T>, grad: Edge<T>) -> Self {
        Self {
            phantom_T: PhantomData,
            var,
            m,
            v,
            beta1_power,
            beta2_power,
            lr,
            beta1,
            beta2,
            epsilon,
            grad,
            use_locking: None,
            use_nesterov: None,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(var: Edge<T>, m: Edge<T>, v: Edge<T>, beta1_power: Edge<T>, beta2_power: Edge<T>, lr: Edge<T>, beta1: Edge<T>, beta2: Edge<T>, epsilon: Edge<T>, grad: Edge<T>) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            var,
            m,
            v,
            beta1_power,
            beta2_power,
            lr,
            beta1,
            beta2,
            epsilon,
            grad,
            use_locking: None,
            use_nesterov: None,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<dtype> GraphOperation for TemporaryVariable<dtype>
where dtype: TensorType,
      dtype: 'static,
      dtype: Clone,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("TemporaryVariable_{}")?
        };
        let mut new_op = graph.new_operation("TemporaryVariable", &op_name)?;
        {
            (|attr| {new_op.set_attr_shape("shape", attr)})(&self.shape)?
        }
        {
            match self.var_name {
                None => new_op.set_attr_value_proto("var_name", &vec![18_u8, 0_u8,])?,
                Some(ref value) => (|attr| {new_op.set_attr_string("var_name", attr)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct TemporaryVariable<dtype>
where dtype: TensorType,
      dtype: 'static,
      dtype: Clone,
{
    shape: OtherShape,
    phantom_dtype: PhantomData<dtype>,
    var_name: Option<String>,
    op_name: Option<String>,
    id_: usize,
}

impl<dtype> TemporaryVariable<dtype>
where dtype: TensorType,
      dtype: 'static,
      dtype: Clone,
{
    pub fn ref_(self) -> Edge<dtype> {
        let rc = Rc::new(self);
        {
            Edge::<dtype>::new(rc.clone(), 0)
        }
    }

    pub fn var_name(&mut self, var_name: &str) -> Self {
        self.var_name = Some(var_name.to_string());
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<dtype> {
        let rc = Rc::new(self);
        {
            Edge::<dtype>::new(rc.clone(), 0)
        }
    }

    pub fn build(shape: &OtherShape) -> Self {
        Self {
            shape: shape.clone(),
            phantom_dtype: PhantomData,
            var_name: None,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(shape: &OtherShape) -> Edge<dtype> {
        Self {
            shape: shape.clone(),
            phantom_dtype: PhantomData,
            var_name: None,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<T> GraphOperation for Zeta<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE,
      T: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("Zeta_{}")?
        };
        let mut new_op = graph.new_operation("Zeta", &op_name)?;
        {
            new_op.add_edge(&self.x)?
        }
        {
            new_op.add_edge(&self.q)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct Zeta<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    x: Edge<T>,
    q: Edge<T>,
    op_name: Option<String>,
    id_: usize,
}

impl<T> Zeta<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE,
      T: 'static,
{
    pub fn z(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(x: Edge<T>, q: Edge<T>) -> Self {
        Self {
            phantom_T: PhantomData,
            x,
            q,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(x: Edge<T>, q: Edge<T>) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            x,
            q,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<T> GraphOperation for ReciprocalGrad<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_COMPLEX64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF,
      T: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("ReciprocalGrad_{}")?
        };
        let mut new_op = graph.new_operation("ReciprocalGrad", &op_name)?;
        {
            new_op.add_edge(&self.y)?
        }
        {
            new_op.add_edge(&self.dy)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct ReciprocalGrad<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_COMPLEX64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    y: Edge<T>,
    dy: Edge<T>,
    op_name: Option<String>,
    id_: usize,
}

impl<T> ReciprocalGrad<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_COMPLEX64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF,
      T: 'static,
{
    pub fn z(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(y: Edge<T>, dy: Edge<T>) -> Self {
        Self {
            phantom_T: PhantomData,
            y,
            dy,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(y: Edge<T>, dy: Edge<T>) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            y,
            dy,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl GraphOperation for SendTPUEmbeddingGradients {
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("SendTPUEmbeddingGradients_{}")?
        };
        let mut new_op = graph.new_operation("SendTPUEmbeddingGradients", &op_name)?;
        {
            new_op.add_edge(&self.inputs)?
        }
        {
            new_op.add_edge(&self.learning_rates)?
        }
        {
            (|attr: &i64| {new_op.set_attr_int("N", *attr)})(&self.N)?
        }
        {
            match self.NN {
                None => new_op.set_attr_value_proto("NN", &vec![24_u8, 0_u8,])?,
                Some(ref value) => (|attr: &i64| {new_op.set_attr_int("NN", *attr)})(&value)?,
            };
        }
        {
            (|attr| {new_op.set_attr_string("config", attr)})(&self.config)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct SendTPUEmbeddingGradients {
    inputs: Edge<f32>,
    learning_rates: Edge<f32>,
    N: i64,
    NN: Option<i64>,
    config: String,
    op_name: Option<String>,
    id_: usize,
}

impl SendTPUEmbeddingGradients {
    pub fn NN(&mut self, NN: i64) -> Self {
        self.NN = Some(NN);
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> () {
        let rc = Rc::new(self);
        (
        )
    }

    pub fn build(inputs: Edge<f32>, learning_rates: Edge<f32>, N: i64, config: &str) -> Self {
        Self {
            inputs,
            learning_rates,
            N: N,
            NN: None,
            config: config.to_string(),
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(inputs: Edge<f32>, learning_rates: Edge<f32>, N: i64, config: &str) -> () {
        Self {
            inputs,
            learning_rates,
            N: N,
            NN: None,
            config: config.to_string(),
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<T, Tindices> GraphOperation for XlaPad<T, Tindices>
where T: TensorType,
      T: Clone,
      Tindices: TensorType,
      Tindices: Clone,
      T: 'static,
      Tindices: con_or_DT_INT32_or_DT_INT64,
      Tindices: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("XlaPad_{}")?
        };
        let mut new_op = graph.new_operation("XlaPad", &op_name)?;
        {
            new_op.add_edge(&self.input)?
        }
        {
            new_op.add_edge(&self.padding_value)?
        }
        {
            new_op.add_edge(&self.padding_low)?
        }
        {
            new_op.add_edge(&self.padding_high)?
        }
        {
            new_op.add_edge(&self.padding_interior)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct XlaPad<T, Tindices>
where T: TensorType,
      T: Clone,
      Tindices: TensorType,
      Tindices: Clone,
      T: 'static,
      Tindices: con_or_DT_INT32_or_DT_INT64,
      Tindices: 'static,
{
    phantom_T: PhantomData<T>,
    input: Edge<T>,
    padding_value: Edge<T>,
    phantom_Tindices: PhantomData<Tindices>,
    padding_low: Edge<Tindices>,
    padding_high: Edge<Tindices>,
    padding_interior: Edge<Tindices>,
    op_name: Option<String>,
    id_: usize,
}

impl<T, Tindices> XlaPad<T, Tindices>
where T: TensorType,
      T: Clone,
      Tindices: TensorType,
      Tindices: Clone,
      T: 'static,
      Tindices: con_or_DT_INT32_or_DT_INT64,
      Tindices: 'static,
{
    pub fn output(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(input: Edge<T>, padding_value: Edge<T>, padding_low: Edge<Tindices>, padding_high: Edge<Tindices>, padding_interior: Edge<Tindices>) -> Self {
        Self {
            phantom_T: PhantomData,
            input,
            padding_value,
            phantom_Tindices: PhantomData,
            padding_low,
            padding_high,
            padding_interior,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(input: Edge<T>, padding_value: Edge<T>, padding_low: Edge<Tindices>, padding_high: Edge<Tindices>, padding_interior: Edge<Tindices>) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            input,
            padding_value,
            phantom_Tindices: PhantomData,
            padding_low,
            padding_high,
            padding_interior,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<T> GraphOperation for Neg<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_COMPLEX64_or_DT_INT64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF,
      T: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("Neg_{}")?
        };
        let mut new_op = graph.new_operation("Neg", &op_name)?;
        {
            new_op.add_edge(&self.x)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct Neg<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_COMPLEX64_or_DT_INT64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    x: Edge<T>,
    op_name: Option<String>,
    id_: usize,
}

impl<T> Neg<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_COMPLEX64_or_DT_INT64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF,
      T: 'static,
{
    pub fn y(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(x: Edge<T>) -> Self {
        Self {
            phantom_T: PhantomData,
            x,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(x: Edge<T>) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            x,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<T> GraphOperation for CudnnRNNBackpropV2<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_HALF,
      T: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("CudnnRNNBackpropV2_{}")?
        };
        let mut new_op = graph.new_operation("CudnnRNNBackpropV2", &op_name)?;
        {
            new_op.add_edge(&self.input)?
        }
        {
            new_op.add_edge(&self.input_h)?
        }
        {
            new_op.add_edge(&self.input_c)?
        }
        {
            new_op.add_edge(&self.params)?
        }
        {
            new_op.add_edge(&self.output)?
        }
        {
            new_op.add_edge(&self.output_h)?
        }
        {
            new_op.add_edge(&self.output_c)?
        }
        {
            new_op.add_edge(&self.output_backprop)?
        }
        {
            new_op.add_edge(&self.output_h_backprop)?
        }
        {
            new_op.add_edge(&self.output_c_backprop)?
        }
        {
            new_op.add_edge(&self.reserve_space)?
        }
        {
            new_op.add_edge(&self.host_reserved)?
        }
        {
            match self.rnn_mode {
                None => new_op.set_attr_value_proto("rnn_mode", &vec![18_u8, 4_u8, 108_u8, 115_u8, 116_u8, 109_u8,])?,
                Some(ref value) => (|attr| {new_op.set_attr_string("rnn_mode", attr)})(&value)?,
            };
        }
        {
            match self.input_mode {
                None => new_op.set_attr_value_proto("input_mode", &vec![18_u8, 12_u8, 108_u8, 105_u8, 110_u8, 101_u8, 97_u8, 114_u8, 95_u8, 105_u8, 110_u8, 112_u8, 117_u8, 116_u8,])?,
                Some(ref value) => (|attr| {new_op.set_attr_string("input_mode", attr)})(&value)?,
            };
        }
        {
            match self.direction {
                None => new_op.set_attr_value_proto("direction", &vec![18_u8, 14_u8, 117_u8, 110_u8, 105_u8, 100_u8, 105_u8, 114_u8, 101_u8, 99_u8, 116_u8, 105_u8, 111_u8, 110_u8, 97_u8, 108_u8,])?,
                Some(ref value) => (|attr| {new_op.set_attr_string("direction", attr)})(&value)?,
            };
        }
        {
            match self.dropout {
                None => new_op.set_attr_value_proto("dropout", &vec![37_u8, 0_u8, 0_u8, 0_u8, 0_u8,])?,
                Some(ref value) => (|attr: &f32| {new_op.set_attr_float("dropout", *attr)})(&value)?,
            };
        }
        {
            match self.seed {
                None => new_op.set_attr_value_proto("seed", &vec![24_u8, 0_u8,])?,
                Some(ref value) => (|attr: &i64| {new_op.set_attr_int("seed", *attr)})(&value)?,
            };
        }
        {
            match self.seed2 {
                None => new_op.set_attr_value_proto("seed2", &vec![24_u8, 0_u8,])?,
                Some(ref value) => (|attr: &i64| {new_op.set_attr_int("seed2", *attr)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct CudnnRNNBackpropV2<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_HALF,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    input: Edge<T>,
    input_h: Edge<T>,
    input_c: Edge<T>,
    params: Edge<T>,
    output: Edge<T>,
    output_h: Edge<T>,
    output_c: Edge<T>,
    output_backprop: Edge<T>,
    output_h_backprop: Edge<T>,
    output_c_backprop: Edge<T>,
    reserve_space: Edge<T>,
    host_reserved: Edge<i8>,
    rnn_mode: Option<String>,
    input_mode: Option<String>,
    direction: Option<String>,
    dropout: Option<f32>,
    seed: Option<i64>,
    seed2: Option<i64>,
    op_name: Option<String>,
    id_: usize,
}

impl<T> CudnnRNNBackpropV2<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_HALF,
      T: 'static,
{
    pub fn input_backprop(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn input_h_backprop(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 1)
        }
    }

    pub fn input_c_backprop(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 2)
        }
    }

    pub fn params_backprop(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 3)
        }
    }

    pub fn rnn_mode(&mut self, rnn_mode: &str) -> Self {
        self.rnn_mode = Some(rnn_mode.to_string());
        self.clone()
    }

    pub fn input_mode(&mut self, input_mode: &str) -> Self {
        self.input_mode = Some(input_mode.to_string());
        self.clone()
    }

    pub fn direction(&mut self, direction: &str) -> Self {
        self.direction = Some(direction.to_string());
        self.clone()
    }

    pub fn dropout(&mut self, dropout: f32) -> Self {
        self.dropout = Some(dropout);
        self.clone()
    }

    pub fn seed(&mut self, seed: i64) -> Self {
        self.seed = Some(seed);
        self.clone()
    }

    pub fn seed2(&mut self, seed2: i64) -> Self {
        self.seed2 = Some(seed2);
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> (Edge<T>, Edge<T>, Edge<T>, Edge<T>) {
        let rc = Rc::new(self);
        (
        {
            Edge::<T>::new(rc.clone(), 0)
        },
        {
            Edge::<T>::new(rc.clone(), 1)
        },
        {
            Edge::<T>::new(rc.clone(), 2)
        },
        {
            Edge::<T>::new(rc.clone(), 3)
        },
        )
    }

    pub fn build(input: Edge<T>, input_h: Edge<T>, input_c: Edge<T>, params: Edge<T>, output: Edge<T>, output_h: Edge<T>, output_c: Edge<T>, output_backprop: Edge<T>, output_h_backprop: Edge<T>, output_c_backprop: Edge<T>, reserve_space: Edge<T>, host_reserved: Edge<i8>) -> Self {
        Self {
            phantom_T: PhantomData,
            input,
            input_h,
            input_c,
            params,
            output,
            output_h,
            output_c,
            output_backprop,
            output_h_backprop,
            output_c_backprop,
            reserve_space,
            host_reserved,
            rnn_mode: None,
            input_mode: None,
            direction: None,
            dropout: None,
            seed: None,
            seed2: None,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(input: Edge<T>, input_h: Edge<T>, input_c: Edge<T>, params: Edge<T>, output: Edge<T>, output_h: Edge<T>, output_c: Edge<T>, output_backprop: Edge<T>, output_h_backprop: Edge<T>, output_c_backprop: Edge<T>, reserve_space: Edge<T>, host_reserved: Edge<i8>) -> (Edge<T>, Edge<T>, Edge<T>, Edge<T>) {
        Self {
            phantom_T: PhantomData,
            input,
            input_h,
            input_c,
            params,
            output,
            output_h,
            output_c,
            output_backprop,
            output_h_backprop,
            output_c_backprop,
            reserve_space,
            host_reserved,
            rnn_mode: None,
            input_mode: None,
            direction: None,
            dropout: None,
            seed: None,
            seed2: None,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<T> GraphOperation for EnsureShape<T>
where T: TensorType,
      T: Clone,
      T: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("EnsureShape_{}")?
        };
        let mut new_op = graph.new_operation("EnsureShape", &op_name)?;
        {
            new_op.add_edge(&self.input)?
        }
        {
            (|attr| {new_op.set_attr_shape("shape", attr)})(&self.shape)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct EnsureShape<T>
where T: TensorType,
      T: Clone,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    input: Edge<T>,
    shape: OtherShape,
    op_name: Option<String>,
    id_: usize,
}

impl<T> EnsureShape<T>
where T: TensorType,
      T: Clone,
      T: 'static,
{
    pub fn output(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(input: Edge<T>, shape: &OtherShape) -> Self {
        Self {
            phantom_T: PhantomData,
            input,
            shape: shape.clone(),
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(input: Edge<T>, shape: &OtherShape) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            input,
            shape: shape.clone(),
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<Tin, Tout> GraphOperation for LookupTableFind<Tin, Tout>
where Tin: TensorType,
      Tin: Clone,
      Tout: TensorType,
      Tout: Clone,
      Tin: 'static,
      Tout: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("LookupTableFind_{}")?
        };
        let mut new_op = graph.new_operation("LookupTableFind", &op_name)?;
        {
            new_op.add_edge(&self.table_handle)?
        }
        {
            new_op.add_edge(&self.keys)?
        }
        {
            new_op.add_edge(&self.default_value)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct LookupTableFind<Tin, Tout>
where Tin: TensorType,
      Tin: Clone,
      Tout: TensorType,
      Tout: Clone,
      Tin: 'static,
      Tout: 'static,
{
    table_handle: Edge<String>,
    phantom_Tin: PhantomData<Tin>,
    keys: Edge<Tin>,
    phantom_Tout: PhantomData<Tout>,
    default_value: Edge<Tout>,
    op_name: Option<String>,
    id_: usize,
}

impl<Tin, Tout> LookupTableFind<Tin, Tout>
where Tin: TensorType,
      Tin: Clone,
      Tout: TensorType,
      Tout: Clone,
      Tin: 'static,
      Tout: 'static,
{
    pub fn values(self) -> Edge<Tout> {
        let rc = Rc::new(self);
        {
            Edge::<Tout>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<Tout> {
        let rc = Rc::new(self);
        {
            Edge::<Tout>::new(rc.clone(), 0)
        }
    }

    pub fn build(table_handle: Edge<String>, keys: Edge<Tin>, default_value: Edge<Tout>) -> Self {
        Self {
            table_handle,
            phantom_Tin: PhantomData,
            keys,
            phantom_Tout: PhantomData,
            default_value,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(table_handle: Edge<String>, keys: Edge<Tin>, default_value: Edge<Tout>) -> Edge<Tout> {
        Self {
            table_handle,
            phantom_Tin: PhantomData,
            keys,
            phantom_Tout: PhantomData,
            default_value,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<dtype> GraphOperation for SparseConditionalAccumulator<dtype>
where dtype: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      dtype: 'static,
      dtype: Clone,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("SparseConditionalAccumulator_{}")?
        };
        let mut new_op = graph.new_operation("SparseConditionalAccumulator", &op_name)?;
        {
            (|attr| {new_op.set_attr_shape("shape", attr)})(&self.shape)?
        }
        {
            match self.container {
                None => new_op.set_attr_value_proto("container", &vec![18_u8, 0_u8,])?,
                Some(ref value) => (|attr| {new_op.set_attr_string("container", attr)})(&value)?,
            };
        }
        {
            match self.shared_name {
                None => new_op.set_attr_value_proto("shared_name", &vec![18_u8, 0_u8,])?,
                Some(ref value) => (|attr| {new_op.set_attr_string("shared_name", attr)})(&value)?,
            };
        }
        {
            match self.reduction_type {
                None => new_op.set_attr_value_proto("reduction_type", &vec![18_u8, 4_u8, 77_u8, 69_u8, 65_u8, 78_u8,])?,
                Some(ref value) => (|attr| {new_op.set_attr_string("reduction_type", attr)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct SparseConditionalAccumulator<dtype>
where dtype: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      dtype: 'static,
      dtype: Clone,
{
    phantom_dtype: PhantomData<dtype>,
    shape: OtherShape,
    container: Option<String>,
    shared_name: Option<String>,
    reduction_type: Option<String>,
    op_name: Option<String>,
    id_: usize,
}

impl<dtype> SparseConditionalAccumulator<dtype>
where dtype: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      dtype: 'static,
      dtype: Clone,
{
    pub fn handle(self) -> Edge<String> {
        let rc = Rc::new(self);
        {
            Edge::<String>::new(rc.clone(), 0)
        }
    }

    pub fn container(&mut self, container: &str) -> Self {
        self.container = Some(container.to_string());
        self.clone()
    }

    pub fn shared_name(&mut self, shared_name: &str) -> Self {
        self.shared_name = Some(shared_name.to_string());
        self.clone()
    }

    pub fn reduction_type(&mut self, reduction_type: &str) -> Self {
        self.reduction_type = Some(reduction_type.to_string());
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<String> {
        let rc = Rc::new(self);
        {
            Edge::<String>::new(rc.clone(), 0)
        }
    }

    pub fn build(shape: &OtherShape) -> Self {
        Self {
            phantom_dtype: PhantomData,
            shape: shape.clone(),
            container: None,
            shared_name: None,
            reduction_type: None,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(shape: &OtherShape) -> Edge<String> {
        Self {
            phantom_dtype: PhantomData,
            shape: shape.clone(),
            container: None,
            shared_name: None,
            reduction_type: None,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl GraphOperation for Mfcc {
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("Mfcc_{}")?
        };
        let mut new_op = graph.new_operation("Mfcc", &op_name)?;
        {
            new_op.add_edge(&self.spectrogram)?
        }
        {
            new_op.add_edge(&self.sample_rate)?
        }
        {
            match self.upper_frequency_limit {
                None => new_op.set_attr_value_proto("upper_frequency_limit", &vec![37_u8, 0_u8, 0_u8, 122_u8, 69_u8,])?,
                Some(ref value) => (|attr: &f32| {new_op.set_attr_float("upper_frequency_limit", *attr)})(&value)?,
            };
        }
        {
            match self.lower_frequency_limit {
                None => new_op.set_attr_value_proto("lower_frequency_limit", &vec![37_u8, 0_u8, 0_u8, 160_u8, 65_u8,])?,
                Some(ref value) => (|attr: &f32| {new_op.set_attr_float("lower_frequency_limit", *attr)})(&value)?,
            };
        }
        {
            match self.filterbank_channel_count {
                None => new_op.set_attr_value_proto("filterbank_channel_count", &vec![24_u8, 40_u8,])?,
                Some(ref value) => (|attr: &i64| {new_op.set_attr_int("filterbank_channel_count", *attr)})(&value)?,
            };
        }
        {
            match self.dct_coefficient_count {
                None => new_op.set_attr_value_proto("dct_coefficient_count", &vec![24_u8, 13_u8,])?,
                Some(ref value) => (|attr: &i64| {new_op.set_attr_int("dct_coefficient_count", *attr)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct Mfcc {
    spectrogram: Edge<f32>,
    sample_rate: Edge<i32>,
    upper_frequency_limit: Option<f32>,
    lower_frequency_limit: Option<f32>,
    filterbank_channel_count: Option<i64>,
    dct_coefficient_count: Option<i64>,
    op_name: Option<String>,
    id_: usize,
}

impl Mfcc {
    pub fn output(self) -> Edge<f32> {
        let rc = Rc::new(self);
        {
            Edge::<f32>::new(rc.clone(), 0)
        }
    }

    pub fn upper_frequency_limit(&mut self, upper_frequency_limit: f32) -> Self {
        self.upper_frequency_limit = Some(upper_frequency_limit);
        self.clone()
    }

    pub fn lower_frequency_limit(&mut self, lower_frequency_limit: f32) -> Self {
        self.lower_frequency_limit = Some(lower_frequency_limit);
        self.clone()
    }

    pub fn filterbank_channel_count(&mut self, filterbank_channel_count: i64) -> Self {
        self.filterbank_channel_count = Some(filterbank_channel_count);
        self.clone()
    }

    pub fn dct_coefficient_count(&mut self, dct_coefficient_count: i64) -> Self {
        self.dct_coefficient_count = Some(dct_coefficient_count);
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<f32> {
        let rc = Rc::new(self);
        {
            Edge::<f32>::new(rc.clone(), 0)
        }
    }

    pub fn build(spectrogram: Edge<f32>, sample_rate: Edge<i32>) -> Self {
        Self {
            spectrogram,
            sample_rate,
            upper_frequency_limit: None,
            lower_frequency_limit: None,
            filterbank_channel_count: None,
            dct_coefficient_count: None,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(spectrogram: Edge<f32>, sample_rate: Edge<i32>) -> Edge<f32> {
        Self {
            spectrogram,
            sample_rate,
            upper_frequency_limit: None,
            lower_frequency_limit: None,
            filterbank_channel_count: None,
            dct_coefficient_count: None,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<component_types> GraphOperation for PriorityQueue<component_types>
where component_types: 'static,
      component_types: Clone,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("PriorityQueue_{}")?
        };
        let mut new_op = graph.new_operation("PriorityQueue", &op_name)?;
        {
            (|attrs| {new_op.set_attr_shape_list("shapes", attrs)})(&self.shapes)?
        }
        {
            match self.capacity {
                None => new_op.set_attr_value_proto("capacity", &vec![24_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 1_u8,])?,
                Some(ref value) => (|attr: &i64| {new_op.set_attr_int("capacity", *attr)})(&value)?,
            };
        }
        {
            match self.container {
                None => new_op.set_attr_value_proto("container", &vec![18_u8, 0_u8,])?,
                Some(ref value) => (|attr| {new_op.set_attr_string("container", attr)})(&value)?,
            };
        }
        {
            match self.shared_name {
                None => new_op.set_attr_value_proto("shared_name", &vec![18_u8, 0_u8,])?,
                Some(ref value) => (|attr| {new_op.set_attr_string("shared_name", attr)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct PriorityQueue<component_types>
where component_types: 'static,
      component_types: Clone,
{
    phantom_component_types: PhantomData<component_types>,
    shapes: Vec<OtherShape>,
    capacity: Option<i64>,
    container: Option<String>,
    shared_name: Option<String>,
    op_name: Option<String>,
    id_: usize,
}

impl<component_types> PriorityQueue<component_types>
where component_types: 'static,
      component_types: Clone,
{
    pub fn handle(self) -> Edge<String> {
        let rc = Rc::new(self);
        {
            Edge::<String>::new(rc.clone(), 0)
        }
    }

    pub fn capacity(&mut self, capacity: i64) -> Self {
        self.capacity = Some(capacity);
        self.clone()
    }

    pub fn container(&mut self, container: &str) -> Self {
        self.container = Some(container.to_string());
        self.clone()
    }

    pub fn shared_name(&mut self, shared_name: &str) -> Self {
        self.shared_name = Some(shared_name.to_string());
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<String> {
        let rc = Rc::new(self);
        {
            Edge::<String>::new(rc.clone(), 0)
        }
    }

    pub fn build(shapes: &[OtherShape]) -> Self {
        Self {
            phantom_component_types: PhantomData,
            shapes: shapes.to_vec(),
            capacity: None,
            container: None,
            shared_name: None,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(shapes: &[OtherShape]) -> Edge<String> {
        Self {
            phantom_component_types: PhantomData,
            shapes: shapes.to_vec(),
            capacity: None,
            container: None,
            shared_name: None,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<T> GraphOperation for Reciprocal<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_COMPLEX64_or_DT_INT64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF,
      T: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("Reciprocal_{}")?
        };
        let mut new_op = graph.new_operation("Reciprocal", &op_name)?;
        {
            new_op.add_edge(&self.x)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct Reciprocal<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_COMPLEX64_or_DT_INT64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    x: Edge<T>,
    op_name: Option<String>,
    id_: usize,
}

impl<T> Reciprocal<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_COMPLEX64_or_DT_INT64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF,
      T: 'static,
{
    pub fn y(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(x: Edge<T>) -> Self {
        Self {
            phantom_T: PhantomData,
            x,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(x: Edge<T>) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            x,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<T> GraphOperation for BatchMatrixBandPart<T>
where T: TensorType,
      T: Clone,
      T: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("BatchMatrixBandPart_{}")?
        };
        let mut new_op = graph.new_operation("BatchMatrixBandPart", &op_name)?;
        {
            new_op.add_edge(&self.input)?
        }
        {
            new_op.add_edge(&self.num_lower)?
        }
        {
            new_op.add_edge(&self.num_upper)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct BatchMatrixBandPart<T>
where T: TensorType,
      T: Clone,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    input: Edge<T>,
    num_lower: Edge<i64>,
    num_upper: Edge<i64>,
    op_name: Option<String>,
    id_: usize,
}

impl<T> BatchMatrixBandPart<T>
where T: TensorType,
      T: Clone,
      T: 'static,
{
    pub fn band(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(input: Edge<T>, num_lower: Edge<i64>, num_upper: Edge<i64>) -> Self {
        Self {
            phantom_T: PhantomData,
            input,
            num_lower,
            num_upper,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(input: Edge<T>, num_lower: Edge<i64>, num_upper: Edge<i64>) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            input,
            num_lower,
            num_upper,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl GraphOperation for _InitializeHostForDistributedTPU {
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("_InitializeHostForDistributedTPU_{}")?
        };
        let mut new_op = graph.new_operation("_InitializeHostForDistributedTPU", &op_name)?;
        {
            new_op.add_edge(&self.input)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct _InitializeHostForDistributedTPU {
    input: Edge<String>,
    op_name: Option<String>,
    id_: usize,
}

impl _InitializeHostForDistributedTPU {
    pub fn tpu_ids(self) -> Edge<i32> {
        let rc = Rc::new(self);
        {
            Edge::<i32>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<i32> {
        let rc = Rc::new(self);
        {
            Edge::<i32>::new(rc.clone(), 0)
        }
    }

    pub fn build(input: Edge<String>) -> Self {
        Self {
            input,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(input: Edge<String>) -> Edge<i32> {
        Self {
            input,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl GraphOperation for ComputeAccidentalHits {
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("ComputeAccidentalHits_{}")?
        };
        let mut new_op = graph.new_operation("ComputeAccidentalHits", &op_name)?;
        {
            new_op.add_edge(&self.true_classes)?
        }
        {
            new_op.add_edge(&self.sampled_candidates)?
        }
        {
            (|attr: &i64| {new_op.set_attr_int("num_true", *attr)})(&self.num_true)?
        }
        {
            match self.seed {
                None => new_op.set_attr_value_proto("seed", &vec![24_u8, 0_u8,])?,
                Some(ref value) => (|attr: &i64| {new_op.set_attr_int("seed", *attr)})(&value)?,
            };
        }
        {
            match self.seed2 {
                None => new_op.set_attr_value_proto("seed2", &vec![24_u8, 0_u8,])?,
                Some(ref value) => (|attr: &i64| {new_op.set_attr_int("seed2", *attr)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct ComputeAccidentalHits {
    true_classes: Edge<i64>,
    sampled_candidates: Edge<i64>,
    num_true: i64,
    seed: Option<i64>,
    seed2: Option<i64>,
    op_name: Option<String>,
    id_: usize,
}

impl ComputeAccidentalHits {
    pub fn indices(self) -> Edge<i32> {
        let rc = Rc::new(self);
        {
            Edge::<i32>::new(rc.clone(), 0)
        }
    }

    pub fn ids(self) -> Edge<i64> {
        let rc = Rc::new(self);
        {
            Edge::<i64>::new(rc.clone(), 1)
        }
    }

    pub fn weights(self) -> Edge<f32> {
        let rc = Rc::new(self);
        {
            Edge::<f32>::new(rc.clone(), 2)
        }
    }

    pub fn seed(&mut self, seed: i64) -> Self {
        self.seed = Some(seed);
        self.clone()
    }

    pub fn seed2(&mut self, seed2: i64) -> Self {
        self.seed2 = Some(seed2);
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> (Edge<i32>, Edge<i64>, Edge<f32>) {
        let rc = Rc::new(self);
        (
        {
            Edge::<i32>::new(rc.clone(), 0)
        },
        {
            Edge::<i64>::new(rc.clone(), 1)
        },
        {
            Edge::<f32>::new(rc.clone(), 2)
        },
        )
    }

    pub fn build(true_classes: Edge<i64>, sampled_candidates: Edge<i64>, num_true: i64) -> Self {
        Self {
            true_classes,
            sampled_candidates,
            num_true: num_true,
            seed: None,
            seed2: None,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(true_classes: Edge<i64>, sampled_candidates: Edge<i64>, num_true: i64) -> (Edge<i32>, Edge<i64>, Edge<f32>) {
        Self {
            true_classes,
            sampled_candidates,
            num_true: num_true,
            seed: None,
            seed2: None,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<T, Tindices> GraphOperation for XlaConv<T, Tindices>
where T: TensorType,
      T: Clone,
      Tindices: TensorType,
      Tindices: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
      Tindices: con_or_DT_INT32_or_DT_INT64,
      Tindices: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("XlaConv_{}")?
        };
        let mut new_op = graph.new_operation("XlaConv", &op_name)?;
        {
            new_op.add_edge(&self.lhs)?
        }
        {
            new_op.add_edge(&self.rhs)?
        }
        {
            new_op.add_edge(&self.window_strides)?
        }
        {
            new_op.add_edge(&self.padding)?
        }
        {
            new_op.add_edge(&self.lhs_dilation)?
        }
        {
            new_op.add_edge(&self.rhs_dilation)?
        }
        {
            new_op.add_edge(&self.feature_group_count)?
        }
        {
            (|attr| {new_op.set_attr_string("dimension_numbers", attr)})(&self.dimension_numbers)?
        }
        {
            (|attr| {new_op.set_attr_string("precision_config", attr)})(&self.precision_config)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct XlaConv<T, Tindices>
where T: TensorType,
      T: Clone,
      Tindices: TensorType,
      Tindices: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
      Tindices: con_or_DT_INT32_or_DT_INT64,
      Tindices: 'static,
{
    phantom_T: PhantomData<T>,
    lhs: Edge<T>,
    rhs: Edge<T>,
    phantom_Tindices: PhantomData<Tindices>,
    window_strides: Edge<Tindices>,
    padding: Edge<Tindices>,
    lhs_dilation: Edge<Tindices>,
    rhs_dilation: Edge<Tindices>,
    feature_group_count: Edge<Tindices>,
    dimension_numbers: String,
    precision_config: String,
    op_name: Option<String>,
    id_: usize,
}

impl<T, Tindices> XlaConv<T, Tindices>
where T: TensorType,
      T: Clone,
      Tindices: TensorType,
      Tindices: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
      Tindices: con_or_DT_INT32_or_DT_INT64,
      Tindices: 'static,
{
    pub fn output(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(lhs: Edge<T>, rhs: Edge<T>, window_strides: Edge<Tindices>, padding: Edge<Tindices>, lhs_dilation: Edge<Tindices>, rhs_dilation: Edge<Tindices>, feature_group_count: Edge<Tindices>, dimension_numbers: &str, precision_config: &str) -> Self {
        Self {
            phantom_T: PhantomData,
            lhs,
            rhs,
            phantom_Tindices: PhantomData,
            window_strides,
            padding,
            lhs_dilation,
            rhs_dilation,
            feature_group_count,
            dimension_numbers: dimension_numbers.to_string(),
            precision_config: precision_config.to_string(),
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(lhs: Edge<T>, rhs: Edge<T>, window_strides: Edge<Tindices>, padding: Edge<Tindices>, lhs_dilation: Edge<Tindices>, rhs_dilation: Edge<Tindices>, feature_group_count: Edge<Tindices>, dimension_numbers: &str, precision_config: &str) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            lhs,
            rhs,
            phantom_Tindices: PhantomData,
            window_strides,
            padding,
            lhs_dilation,
            rhs_dilation,
            feature_group_count,
            dimension_numbers: dimension_numbers.to_string(),
            precision_config: precision_config.to_string(),
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl GraphOperation for RetrieveTPUEmbeddingMomentumParameters {
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("RetrieveTPUEmbeddingMomentumParameters_{}")?
        };
        let mut new_op = graph.new_operation("RetrieveTPUEmbeddingMomentumParameters", &op_name)?;
        {
            match self.table_id {
                None => new_op.set_attr_value_proto("table_id", &vec![24_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 1_u8,])?,
                Some(ref value) => (|attr: &i64| {new_op.set_attr_int("table_id", *attr)})(&value)?,
            };
        }
        {
            match self.table_name {
                None => new_op.set_attr_value_proto("table_name", &vec![18_u8, 0_u8,])?,
                Some(ref value) => (|attr| {new_op.set_attr_string("table_name", attr)})(&value)?,
            };
        }
        {
            (|attr: &i64| {new_op.set_attr_int("num_shards", *attr)})(&self.num_shards)?
        }
        {
            (|attr: &i64| {new_op.set_attr_int("shard_id", *attr)})(&self.shard_id)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct RetrieveTPUEmbeddingMomentumParameters {
    table_id: Option<i64>,
    table_name: Option<String>,
    num_shards: i64,
    shard_id: i64,
    op_name: Option<String>,
    id_: usize,
}

impl RetrieveTPUEmbeddingMomentumParameters {
    pub fn parameters(self) -> Edge<f32> {
        let rc = Rc::new(self);
        {
            Edge::<f32>::new(rc.clone(), 0)
        }
    }

    pub fn momenta(self) -> Edge<f32> {
        let rc = Rc::new(self);
        {
            Edge::<f32>::new(rc.clone(), 1)
        }
    }

    pub fn table_id(&mut self, table_id: i64) -> Self {
        self.table_id = Some(table_id);
        self.clone()
    }

    pub fn table_name(&mut self, table_name: &str) -> Self {
        self.table_name = Some(table_name.to_string());
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> (Edge<f32>, Edge<f32>) {
        let rc = Rc::new(self);
        (
        {
            Edge::<f32>::new(rc.clone(), 0)
        },
        {
            Edge::<f32>::new(rc.clone(), 1)
        },
        )
    }

    pub fn build(num_shards: i64, shard_id: i64) -> Self {
        Self {
            table_id: None,
            table_name: None,
            num_shards: num_shards,
            shard_id: shard_id,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(num_shards: i64, shard_id: i64) -> (Edge<f32>, Edge<f32>) {
        Self {
            table_id: None,
            table_name: None,
            num_shards: num_shards,
            shard_id: shard_id,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<dtype> GraphOperation for PlaceholderV2<dtype>
where dtype: TensorType,
      dtype: 'static,
      dtype: Clone,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("PlaceholderV2_{}")?
        };
        let mut new_op = graph.new_operation("PlaceholderV2", &op_name)?;
        {
            (|attr| {new_op.set_attr_shape("shape", attr)})(&self.shape)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct PlaceholderV2<dtype>
where dtype: TensorType,
      dtype: 'static,
      dtype: Clone,
{
    phantom_dtype: PhantomData<dtype>,
    shape: OtherShape,
    op_name: Option<String>,
    id_: usize,
}

impl<dtype> PlaceholderV2<dtype>
where dtype: TensorType,
      dtype: 'static,
      dtype: Clone,
{
    pub fn output(self) -> Edge<dtype> {
        let rc = Rc::new(self);
        {
            Edge::<dtype>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<dtype> {
        let rc = Rc::new(self);
        {
            Edge::<dtype>::new(rc.clone(), 0)
        }
    }

    pub fn build(shape: &OtherShape) -> Self {
        Self {
            phantom_dtype: PhantomData,
            shape: shape.clone(),
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(shape: &OtherShape) -> Edge<dtype> {
        Self {
            phantom_dtype: PhantomData,
            shape: shape.clone(),
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<T> GraphOperation for BatchMatrixDiag<T>
where T: TensorType,
      T: Clone,
      T: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("BatchMatrixDiag_{}")?
        };
        let mut new_op = graph.new_operation("BatchMatrixDiag", &op_name)?;
        {
            new_op.add_edge(&self.diagonal)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct BatchMatrixDiag<T>
where T: TensorType,
      T: Clone,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    diagonal: Edge<T>,
    op_name: Option<String>,
    id_: usize,
}

impl<T> BatchMatrixDiag<T>
where T: TensorType,
      T: Clone,
      T: 'static,
{
    pub fn output(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(diagonal: Edge<T>) -> Self {
        Self {
            phantom_T: PhantomData,
            diagonal,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(diagonal: Edge<T>) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            diagonal,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl GraphOperation for FakeQuantWithMinMaxArgsGradient {
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("FakeQuantWithMinMaxArgsGradient_{}")?
        };
        let mut new_op = graph.new_operation("FakeQuantWithMinMaxArgsGradient", &op_name)?;
        {
            new_op.add_edge(&self.gradients)?
        }
        {
            new_op.add_edge(&self.inputs)?
        }
        {
            match self.min {
                None => new_op.set_attr_value_proto("min", &vec![37_u8, 0_u8, 0_u8, 192_u8, 192_u8,])?,
                Some(ref value) => (|attr: &f32| {new_op.set_attr_float("min", *attr)})(&value)?,
            };
        }
        {
            match self.max {
                None => new_op.set_attr_value_proto("max", &vec![37_u8, 0_u8, 0_u8, 192_u8, 64_u8,])?,
                Some(ref value) => (|attr: &f32| {new_op.set_attr_float("max", *attr)})(&value)?,
            };
        }
        {
            match self.num_bits {
                None => new_op.set_attr_value_proto("num_bits", &vec![24_u8, 8_u8,])?,
                Some(ref value) => (|attr: &i64| {new_op.set_attr_int("num_bits", *attr)})(&value)?,
            };
        }
        {
            match self.narrow_range {
                None => new_op.set_attr_value_proto("narrow_range", &vec![40_u8, 0_u8,])?,
                Some(ref value) => (|attr: &bool| {new_op.set_attr_bool("narrow_range", *attr)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct FakeQuantWithMinMaxArgsGradient {
    gradients: Edge<f32>,
    inputs: Edge<f32>,
    min: Option<f32>,
    max: Option<f32>,
    num_bits: Option<i64>,
    narrow_range: Option<bool>,
    op_name: Option<String>,
    id_: usize,
}

impl FakeQuantWithMinMaxArgsGradient {
    pub fn backprops(self) -> Edge<f32> {
        let rc = Rc::new(self);
        {
            Edge::<f32>::new(rc.clone(), 0)
        }
    }

    pub fn min(&mut self, min: f32) -> Self {
        self.min = Some(min);
        self.clone()
    }

    pub fn max(&mut self, max: f32) -> Self {
        self.max = Some(max);
        self.clone()
    }

    pub fn num_bits(&mut self, num_bits: i64) -> Self {
        self.num_bits = Some(num_bits);
        self.clone()
    }

    pub fn narrow_range(&mut self, narrow_range: bool) -> Self {
        self.narrow_range = Some(narrow_range);
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<f32> {
        let rc = Rc::new(self);
        {
            Edge::<f32>::new(rc.clone(), 0)
        }
    }

    pub fn build(gradients: Edge<f32>, inputs: Edge<f32>) -> Self {
        Self {
            gradients,
            inputs,
            min: None,
            max: None,
            num_bits: None,
            narrow_range: None,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(gradients: Edge<f32>, inputs: Edge<f32>) -> Edge<f32> {
        Self {
            gradients,
            inputs,
            min: None,
            max: None,
            num_bits: None,
            narrow_range: None,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<T> GraphOperation for InplaceUpdate<T>
where T: TensorType,
      T: Clone,
      T: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("InplaceUpdate_{}")?
        };
        let mut new_op = graph.new_operation("InplaceUpdate", &op_name)?;
        {
            new_op.add_edge(&self.x)?
        }
        {
            new_op.add_edge(&self.i)?
        }
        {
            new_op.add_edge(&self.v)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct InplaceUpdate<T>
where T: TensorType,
      T: Clone,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    x: Edge<T>,
    i: Edge<i32>,
    v: Edge<T>,
    op_name: Option<String>,
    id_: usize,
}

impl<T> InplaceUpdate<T>
where T: TensorType,
      T: Clone,
      T: 'static,
{
    pub fn y(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(x: Edge<T>, i: Edge<i32>, v: Edge<T>) -> Self {
        Self {
            phantom_T: PhantomData,
            x,
            i,
            v,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(x: Edge<T>, i: Edge<i32>, v: Edge<T>) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            x,
            i,
            v,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<T> GraphOperation for Sigmoid<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_COMPLEX64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF,
      T: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("Sigmoid_{}")?
        };
        let mut new_op = graph.new_operation("Sigmoid", &op_name)?;
        {
            new_op.add_edge(&self.x)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct Sigmoid<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_COMPLEX64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    x: Edge<T>,
    op_name: Option<String>,
    id_: usize,
}

impl<T> Sigmoid<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_COMPLEX64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF,
      T: 'static,
{
    pub fn y(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(x: Edge<T>) -> Self {
        Self {
            phantom_T: PhantomData,
            x,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(x: Edge<T>) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            x,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl GraphOperation for TensorArrayGrad {
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("TensorArrayGrad_{}")?
        };
        let mut new_op = graph.new_operation("TensorArrayGrad", &op_name)?;
        {
            new_op.add_edge(&self.handle)?
        }
        {
            new_op.add_edge(&self.flow_in)?
        }
        {
            (|attr| {new_op.set_attr_string("source", attr)})(&self.source)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct TensorArrayGrad {
    handle: Edge<String>,
    flow_in: Edge<f32>,
    source: String,
    op_name: Option<String>,
    id_: usize,
}

impl TensorArrayGrad {
    pub fn grad_handle(self) -> Edge<String> {
        let rc = Rc::new(self);
        {
            Edge::<String>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<String> {
        let rc = Rc::new(self);
        {
            Edge::<String>::new(rc.clone(), 0)
        }
    }

    pub fn build(handle: Edge<String>, flow_in: Edge<f32>, source: &str) -> Self {
        Self {
            handle,
            flow_in,
            source: source.to_string(),
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(handle: Edge<String>, flow_in: Edge<f32>, source: &str) -> Edge<String> {
        Self {
            handle,
            flow_in,
            source: source.to_string(),
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<T> GraphOperation for Qr<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_COMPLEX64_or_DT_COMPLEX128,
      T: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("Qr_{}")?
        };
        let mut new_op = graph.new_operation("Qr", &op_name)?;
        {
            new_op.add_edge(&self.input)?
        }
        {
            match self.full_matrices {
                None => new_op.set_attr_value_proto("full_matrices", &vec![40_u8, 0_u8,])?,
                Some(ref value) => (|attr: &bool| {new_op.set_attr_bool("full_matrices", *attr)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct Qr<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_COMPLEX64_or_DT_COMPLEX128,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    input: Edge<T>,
    full_matrices: Option<bool>,
    op_name: Option<String>,
    id_: usize,
}

impl<T> Qr<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_COMPLEX64_or_DT_COMPLEX128,
      T: 'static,
{
    pub fn q(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn r(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 1)
        }
    }

    pub fn full_matrices(&mut self, full_matrices: bool) -> Self {
        self.full_matrices = Some(full_matrices);
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> (Edge<T>, Edge<T>) {
        let rc = Rc::new(self);
        (
        {
            Edge::<T>::new(rc.clone(), 0)
        },
        {
            Edge::<T>::new(rc.clone(), 1)
        },
        )
    }

    pub fn build(input: Edge<T>) -> Self {
        Self {
            phantom_T: PhantomData,
            input,
            full_matrices: None,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(input: Edge<T>) -> (Edge<T>, Edge<T>) {
        Self {
            phantom_T: PhantomData,
            input,
            full_matrices: None,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl GraphOperation for AudioSummary {
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("AudioSummary_{}")?
        };
        let mut new_op = graph.new_operation("AudioSummary", &op_name)?;
        {
            new_op.add_edge(&self.tag)?
        }
        {
            new_op.add_edge(&self.tensor)?
        }
        {
            (|attr: &f32| {new_op.set_attr_float("sample_rate", *attr)})(&self.sample_rate)?
        }
        {
            match self.max_outputs {
                None => new_op.set_attr_value_proto("max_outputs", &vec![24_u8, 3_u8,])?,
                Some(ref value) => (|attr: &i64| {new_op.set_attr_int("max_outputs", *attr)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct AudioSummary {
    tag: Edge<String>,
    tensor: Edge<f32>,
    sample_rate: f32,
    max_outputs: Option<i64>,
    op_name: Option<String>,
    id_: usize,
}

impl AudioSummary {
    pub fn summary(self) -> Edge<String> {
        let rc = Rc::new(self);
        {
            Edge::<String>::new(rc.clone(), 0)
        }
    }

    pub fn max_outputs(&mut self, max_outputs: i64) -> Self {
        self.max_outputs = Some(max_outputs);
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<String> {
        let rc = Rc::new(self);
        {
            Edge::<String>::new(rc.clone(), 0)
        }
    }

    pub fn build(tag: Edge<String>, tensor: Edge<f32>, sample_rate: f32) -> Self {
        Self {
            tag,
            tensor,
            sample_rate: sample_rate,
            max_outputs: None,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(tag: Edge<String>, tensor: Edge<f32>, sample_rate: f32) -> Edge<String> {
        Self {
            tag,
            tensor,
            sample_rate: sample_rate,
            max_outputs: None,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<T> GraphOperation for CollectivePermute<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("CollectivePermute_{}")?
        };
        let mut new_op = graph.new_operation("CollectivePermute", &op_name)?;
        {
            new_op.add_edge(&self.input)?
        }
        {
            new_op.add_edge(&self.source_target_pairs)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct CollectivePermute<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    input: Edge<T>,
    source_target_pairs: Edge<i32>,
    op_name: Option<String>,
    id_: usize,
}

impl<T> CollectivePermute<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
{
    pub fn output(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(input: Edge<T>, source_target_pairs: Edge<i32>) -> Self {
        Self {
            phantom_T: PhantomData,
            input,
            source_target_pairs,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(input: Edge<T>, source_target_pairs: Edge<i32>) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            input,
            source_target_pairs,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

pub trait con_or_DT_COMPLEX64_or_DT_COMPLEX128_or_DT_VARIANT {
}

impl con_or_DT_COMPLEX64_or_DT_COMPLEX128_or_DT_VARIANT for OtherComplex<f32> {
}

impl con_or_DT_COMPLEX64_or_DT_COMPLEX128_or_DT_VARIANT for OtherComplex<f64> {
}

impl<T> GraphOperation for Conj<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_COMPLEX64_or_DT_COMPLEX128_or_DT_VARIANT,
      T: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("Conj_{}")?
        };
        let mut new_op = graph.new_operation("Conj", &op_name)?;
        {
            new_op.add_edge(&self.input)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct Conj<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_COMPLEX64_or_DT_COMPLEX128_or_DT_VARIANT,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    input: Edge<T>,
    op_name: Option<String>,
    id_: usize,
}

impl<T> Conj<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_COMPLEX64_or_DT_COMPLEX128_or_DT_VARIANT,
      T: 'static,
{
    pub fn output(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(input: Edge<T>) -> Self {
        Self {
            phantom_T: PhantomData,
            input,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(input: Edge<T>) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            input,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl GraphOperation for RetrieveTPUEmbeddingAdadeltaParameters {
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("RetrieveTPUEmbeddingAdadeltaParameters_{}")?
        };
        let mut new_op = graph.new_operation("RetrieveTPUEmbeddingAdadeltaParameters", &op_name)?;
        {
            match self.table_id {
                None => new_op.set_attr_value_proto("table_id", &vec![24_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 1_u8,])?,
                Some(ref value) => (|attr: &i64| {new_op.set_attr_int("table_id", *attr)})(&value)?,
            };
        }
        {
            match self.table_name {
                None => new_op.set_attr_value_proto("table_name", &vec![18_u8, 0_u8,])?,
                Some(ref value) => (|attr| {new_op.set_attr_string("table_name", attr)})(&value)?,
            };
        }
        {
            (|attr: &i64| {new_op.set_attr_int("num_shards", *attr)})(&self.num_shards)?
        }
        {
            (|attr: &i64| {new_op.set_attr_int("shard_id", *attr)})(&self.shard_id)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct RetrieveTPUEmbeddingAdadeltaParameters {
    table_id: Option<i64>,
    table_name: Option<String>,
    num_shards: i64,
    shard_id: i64,
    op_name: Option<String>,
    id_: usize,
}

impl RetrieveTPUEmbeddingAdadeltaParameters {
    pub fn parameters(self) -> Edge<f32> {
        let rc = Rc::new(self);
        {
            Edge::<f32>::new(rc.clone(), 0)
        }
    }

    pub fn accumulators(self) -> Edge<f32> {
        let rc = Rc::new(self);
        {
            Edge::<f32>::new(rc.clone(), 1)
        }
    }

    pub fn updates(self) -> Edge<f32> {
        let rc = Rc::new(self);
        {
            Edge::<f32>::new(rc.clone(), 2)
        }
    }

    pub fn table_id(&mut self, table_id: i64) -> Self {
        self.table_id = Some(table_id);
        self.clone()
    }

    pub fn table_name(&mut self, table_name: &str) -> Self {
        self.table_name = Some(table_name.to_string());
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> (Edge<f32>, Edge<f32>, Edge<f32>) {
        let rc = Rc::new(self);
        (
        {
            Edge::<f32>::new(rc.clone(), 0)
        },
        {
            Edge::<f32>::new(rc.clone(), 1)
        },
        {
            Edge::<f32>::new(rc.clone(), 2)
        },
        )
    }

    pub fn build(num_shards: i64, shard_id: i64) -> Self {
        Self {
            table_id: None,
            table_name: None,
            num_shards: num_shards,
            shard_id: shard_id,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(num_shards: i64, shard_id: i64) -> (Edge<f32>, Edge<f32>, Edge<f32>) {
        Self {
            table_id: None,
            table_name: None,
            num_shards: num_shards,
            shard_id: shard_id,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl GraphOperation for ConfigureDistributedTPU {
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("ConfigureDistributedTPU_{}")?
        };
        let mut new_op = graph.new_operation("ConfigureDistributedTPU", &op_name)?;
        {
            match self.embedding_config {
                None => new_op.set_attr_value_proto("embedding_config", &vec![18_u8, 0_u8,])?,
                Some(ref value) => (|attr| {new_op.set_attr_string("embedding_config", attr)})(&value)?,
            };
        }
        {
            match self.tpu_embedding_config {
                None => new_op.set_attr_value_proto("tpu_embedding_config", &vec![18_u8, 0_u8,])?,
                Some(ref value) => (|attr| {new_op.set_attr_string("tpu_embedding_config", attr)})(&value)?,
            };
        }
        {
            match self.is_global_init {
                None => new_op.set_attr_value_proto("is_global_init", &vec![40_u8, 0_u8,])?,
                Some(ref value) => (|attr: &bool| {new_op.set_attr_bool("is_global_init", *attr)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct ConfigureDistributedTPU {
    embedding_config: Option<String>,
    tpu_embedding_config: Option<String>,
    is_global_init: Option<bool>,
    op_name: Option<String>,
    id_: usize,
}

impl ConfigureDistributedTPU {
    pub fn topology(self) -> Edge<String> {
        let rc = Rc::new(self);
        {
            Edge::<String>::new(rc.clone(), 0)
        }
    }

    pub fn embedding_config(&mut self, embedding_config: &str) -> Self {
        self.embedding_config = Some(embedding_config.to_string());
        self.clone()
    }

    pub fn tpu_embedding_config(&mut self, tpu_embedding_config: &str) -> Self {
        self.tpu_embedding_config = Some(tpu_embedding_config.to_string());
        self.clone()
    }

    pub fn is_global_init(&mut self, is_global_init: bool) -> Self {
        self.is_global_init = Some(is_global_init);
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<String> {
        let rc = Rc::new(self);
        {
            Edge::<String>::new(rc.clone(), 0)
        }
    }

    pub fn build() -> Self {
        Self {
            embedding_config: None,
            tpu_embedding_config: None,
            is_global_init: None,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new() -> Edge<String> {
        Self {
            embedding_config: None,
            tpu_embedding_config: None,
            is_global_init: None,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl GraphOperation for BoostedTreesMakeQuantileSummaries {
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("BoostedTreesMakeQuantileSummaries_{}")?
        };
        let mut new_op = graph.new_operation("BoostedTreesMakeQuantileSummaries", &op_name)?;
        {
            new_op.add_edge(&self.float_values)?
        }
        {
            new_op.add_edge(&self.example_weights)?
        }
        {
            new_op.add_edge(&self.epsilon)?
        }
        {
            (|attr: &i64| {new_op.set_attr_int("num_features", *attr)})(&self.num_features)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct BoostedTreesMakeQuantileSummaries {
    float_values: Edge<f32>,
    example_weights: Edge<f32>,
    epsilon: Edge<f32>,
    num_features: i64,
    op_name: Option<String>,
    id_: usize,
}

impl BoostedTreesMakeQuantileSummaries {
    pub fn summaries(self) -> Edge<f32> {
        let rc = Rc::new(self);
        {
            Edge::<f32>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<f32> {
        let rc = Rc::new(self);
        {
            Edge::<f32>::new(rc.clone(), 0)
        }
    }

    pub fn build(float_values: Edge<f32>, example_weights: Edge<f32>, epsilon: Edge<f32>, num_features: i64) -> Self {
        Self {
            float_values,
            example_weights,
            epsilon,
            num_features: num_features,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(float_values: Edge<f32>, example_weights: Edge<f32>, epsilon: Edge<f32>, num_features: i64) -> Edge<f32> {
        Self {
            float_values,
            example_weights,
            epsilon,
            num_features: num_features,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl GraphOperation for NonMaxSuppression {
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("NonMaxSuppression_{}")?
        };
        let mut new_op = graph.new_operation("NonMaxSuppression", &op_name)?;
        {
            new_op.add_edge(&self.boxes)?
        }
        {
            new_op.add_edge(&self.scores)?
        }
        {
            new_op.add_edge(&self.max_output_size)?
        }
        {
            match self.iou_threshold {
                None => new_op.set_attr_value_proto("iou_threshold", &vec![37_u8, 0_u8, 0_u8, 0_u8, 63_u8,])?,
                Some(ref value) => (|attr: &f32| {new_op.set_attr_float("iou_threshold", *attr)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct NonMaxSuppression {
    boxes: Edge<f32>,
    scores: Edge<f32>,
    max_output_size: Edge<i32>,
    iou_threshold: Option<f32>,
    op_name: Option<String>,
    id_: usize,
}

impl NonMaxSuppression {
    pub fn selected_indices(self) -> Edge<i32> {
        let rc = Rc::new(self);
        {
            Edge::<i32>::new(rc.clone(), 0)
        }
    }

    pub fn iou_threshold(&mut self, iou_threshold: f32) -> Self {
        self.iou_threshold = Some(iou_threshold);
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<i32> {
        let rc = Rc::new(self);
        {
            Edge::<i32>::new(rc.clone(), 0)
        }
    }

    pub fn build(boxes: Edge<f32>, scores: Edge<f32>, max_output_size: Edge<i32>) -> Self {
        Self {
            boxes,
            scores,
            max_output_size,
            iou_threshold: None,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(boxes: Edge<f32>, scores: Edge<f32>, max_output_size: Edge<i32>) -> Edge<i32> {
        Self {
            boxes,
            scores,
            max_output_size,
            iou_threshold: None,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl GraphOperation for LoadTPUEmbeddingAdagradParametersGradAccumDebug {
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("LoadTPUEmbeddingAdagradParametersGradAccumDebug_{}")?
        };
        let mut new_op = graph.new_operation("LoadTPUEmbeddingAdagradParametersGradAccumDebug", &op_name)?;
        {
            new_op.add_edge(&self.parameters)?
        }
        {
            new_op.add_edge(&self.accumulators)?
        }
        {
            new_op.add_edge(&self.gradient_accumulators)?
        }
        {
            match self.table_id {
                None => new_op.set_attr_value_proto("table_id", &vec![24_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 1_u8,])?,
                Some(ref value) => (|attr: &i64| {new_op.set_attr_int("table_id", *attr)})(&value)?,
            };
        }
        {
            match self.table_name {
                None => new_op.set_attr_value_proto("table_name", &vec![18_u8, 0_u8,])?,
                Some(ref value) => (|attr| {new_op.set_attr_string("table_name", attr)})(&value)?,
            };
        }
        {
            (|attr: &i64| {new_op.set_attr_int("num_shards", *attr)})(&self.num_shards)?
        }
        {
            (|attr: &i64| {new_op.set_attr_int("shard_id", *attr)})(&self.shard_id)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct LoadTPUEmbeddingAdagradParametersGradAccumDebug {
    parameters: Edge<f32>,
    accumulators: Edge<f32>,
    gradient_accumulators: Edge<f32>,
    table_id: Option<i64>,
    table_name: Option<String>,
    num_shards: i64,
    shard_id: i64,
    op_name: Option<String>,
    id_: usize,
}

impl LoadTPUEmbeddingAdagradParametersGradAccumDebug {
    pub fn table_id(&mut self, table_id: i64) -> Self {
        self.table_id = Some(table_id);
        self.clone()
    }

    pub fn table_name(&mut self, table_name: &str) -> Self {
        self.table_name = Some(table_name.to_string());
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> () {
        let rc = Rc::new(self);
        (
        )
    }

    pub fn build(parameters: Edge<f32>, accumulators: Edge<f32>, gradient_accumulators: Edge<f32>, num_shards: i64, shard_id: i64) -> Self {
        Self {
            parameters,
            accumulators,
            gradient_accumulators,
            table_id: None,
            table_name: None,
            num_shards: num_shards,
            shard_id: shard_id,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(parameters: Edge<f32>, accumulators: Edge<f32>, gradient_accumulators: Edge<f32>, num_shards: i64, shard_id: i64) -> () {
        Self {
            parameters,
            accumulators,
            gradient_accumulators,
            table_id: None,
            table_name: None,
            num_shards: num_shards,
            shard_id: shard_id,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl GraphOperation for RetrieveTPUEmbeddingFTRLParametersGradAccumDebug {
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("RetrieveTPUEmbeddingFTRLParametersGradAccumDebug_{}")?
        };
        let mut new_op = graph.new_operation("RetrieveTPUEmbeddingFTRLParametersGradAccumDebug", &op_name)?;
        {
            match self.table_id {
                None => new_op.set_attr_value_proto("table_id", &vec![24_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 1_u8,])?,
                Some(ref value) => (|attr: &i64| {new_op.set_attr_int("table_id", *attr)})(&value)?,
            };
        }
        {
            match self.table_name {
                None => new_op.set_attr_value_proto("table_name", &vec![18_u8, 0_u8,])?,
                Some(ref value) => (|attr| {new_op.set_attr_string("table_name", attr)})(&value)?,
            };
        }
        {
            (|attr: &i64| {new_op.set_attr_int("num_shards", *attr)})(&self.num_shards)?
        }
        {
            (|attr: &i64| {new_op.set_attr_int("shard_id", *attr)})(&self.shard_id)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct RetrieveTPUEmbeddingFTRLParametersGradAccumDebug {
    table_id: Option<i64>,
    table_name: Option<String>,
    num_shards: i64,
    shard_id: i64,
    op_name: Option<String>,
    id_: usize,
}

impl RetrieveTPUEmbeddingFTRLParametersGradAccumDebug {
    pub fn parameters(self) -> Edge<f32> {
        let rc = Rc::new(self);
        {
            Edge::<f32>::new(rc.clone(), 0)
        }
    }

    pub fn accumulators(self) -> Edge<f32> {
        let rc = Rc::new(self);
        {
            Edge::<f32>::new(rc.clone(), 1)
        }
    }

    pub fn linears(self) -> Edge<f32> {
        let rc = Rc::new(self);
        {
            Edge::<f32>::new(rc.clone(), 2)
        }
    }

    pub fn gradient_accumulators(self) -> Edge<f32> {
        let rc = Rc::new(self);
        {
            Edge::<f32>::new(rc.clone(), 3)
        }
    }

    pub fn table_id(&mut self, table_id: i64) -> Self {
        self.table_id = Some(table_id);
        self.clone()
    }

    pub fn table_name(&mut self, table_name: &str) -> Self {
        self.table_name = Some(table_name.to_string());
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> (Edge<f32>, Edge<f32>, Edge<f32>, Edge<f32>) {
        let rc = Rc::new(self);
        (
        {
            Edge::<f32>::new(rc.clone(), 0)
        },
        {
            Edge::<f32>::new(rc.clone(), 1)
        },
        {
            Edge::<f32>::new(rc.clone(), 2)
        },
        {
            Edge::<f32>::new(rc.clone(), 3)
        },
        )
    }

    pub fn build(num_shards: i64, shard_id: i64) -> Self {
        Self {
            table_id: None,
            table_name: None,
            num_shards: num_shards,
            shard_id: shard_id,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(num_shards: i64, shard_id: i64) -> (Edge<f32>, Edge<f32>, Edge<f32>, Edge<f32>) {
        Self {
            table_id: None,
            table_name: None,
            num_shards: num_shards,
            shard_id: shard_id,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl GraphOperation for BatchFFT {
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("BatchFFT_{}")?
        };
        let mut new_op = graph.new_operation("BatchFFT", &op_name)?;
        {
            new_op.add_edge(&self.input)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct BatchFFT {
    input: Edge<OtherComplex<f32>>,
    op_name: Option<String>,
    id_: usize,
}

impl BatchFFT {
    pub fn output(self) -> Edge<OtherComplex<f32>> {
        let rc = Rc::new(self);
        {
            Edge::<OtherComplex::<f32>>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<OtherComplex<f32>> {
        let rc = Rc::new(self);
        {
            Edge::<OtherComplex::<f32>>::new(rc.clone(), 0)
        }
    }

    pub fn build(input: Edge<OtherComplex<f32>>) -> Self {
        Self {
            input,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(input: Edge<OtherComplex<f32>>) -> Edge<OtherComplex<f32>> {
        Self {
            input,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl GraphOperation for LoadTPUEmbeddingMomentumParametersGradAccumDebug {
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("LoadTPUEmbeddingMomentumParametersGradAccumDebug_{}")?
        };
        let mut new_op = graph.new_operation("LoadTPUEmbeddingMomentumParametersGradAccumDebug", &op_name)?;
        {
            new_op.add_edge(&self.parameters)?
        }
        {
            new_op.add_edge(&self.momenta)?
        }
        {
            new_op.add_edge(&self.gradient_accumulators)?
        }
        {
            match self.table_id {
                None => new_op.set_attr_value_proto("table_id", &vec![24_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 1_u8,])?,
                Some(ref value) => (|attr: &i64| {new_op.set_attr_int("table_id", *attr)})(&value)?,
            };
        }
        {
            match self.table_name {
                None => new_op.set_attr_value_proto("table_name", &vec![18_u8, 0_u8,])?,
                Some(ref value) => (|attr| {new_op.set_attr_string("table_name", attr)})(&value)?,
            };
        }
        {
            (|attr: &i64| {new_op.set_attr_int("num_shards", *attr)})(&self.num_shards)?
        }
        {
            (|attr: &i64| {new_op.set_attr_int("shard_id", *attr)})(&self.shard_id)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct LoadTPUEmbeddingMomentumParametersGradAccumDebug {
    parameters: Edge<f32>,
    momenta: Edge<f32>,
    gradient_accumulators: Edge<f32>,
    table_id: Option<i64>,
    table_name: Option<String>,
    num_shards: i64,
    shard_id: i64,
    op_name: Option<String>,
    id_: usize,
}

impl LoadTPUEmbeddingMomentumParametersGradAccumDebug {
    pub fn table_id(&mut self, table_id: i64) -> Self {
        self.table_id = Some(table_id);
        self.clone()
    }

    pub fn table_name(&mut self, table_name: &str) -> Self {
        self.table_name = Some(table_name.to_string());
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> () {
        let rc = Rc::new(self);
        (
        )
    }

    pub fn build(parameters: Edge<f32>, momenta: Edge<f32>, gradient_accumulators: Edge<f32>, num_shards: i64, shard_id: i64) -> Self {
        Self {
            parameters,
            momenta,
            gradient_accumulators,
            table_id: None,
            table_name: None,
            num_shards: num_shards,
            shard_id: shard_id,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(parameters: Edge<f32>, momenta: Edge<f32>, gradient_accumulators: Edge<f32>, num_shards: i64, shard_id: i64) -> () {
        Self {
            parameters,
            momenta,
            gradient_accumulators,
            table_id: None,
            table_name: None,
            num_shards: num_shards,
            shard_id: shard_id,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<dtype> GraphOperation for HostConst<dtype>
where dtype: TensorType,
      dtype: 'static,
      dtype: Clone,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("HostConst_{}")?
        };
        let mut new_op = graph.new_operation("HostConst", &op_name)?;
        {
            (|attr: &Rc<AnyTensor>| {new_op.set_attr_tensor_owned("value", attr.clone())})(&self.value)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct HostConst<dtype>
where dtype: TensorType,
      dtype: 'static,
      dtype: Clone,
{
    value: Rc<AnyTensor>,
    phantom_dtype: PhantomData<dtype>,
    op_name: Option<String>,
    id_: usize,
}

impl<dtype> HostConst<dtype>
where dtype: TensorType,
      dtype: 'static,
      dtype: Clone,
{
    pub fn output(self) -> Edge<dtype> {
        let rc = Rc::new(self);
        {
            Edge::<dtype>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<dtype> {
        let rc = Rc::new(self);
        {
            Edge::<dtype>::new(rc.clone(), 0)
        }
    }

    pub fn build<value_T>(value: value_T) -> Self
    where value_T: AnyTensor,
          value_T: 'static,
    {
        Self {
            value: Rc::new(value),
            phantom_dtype: PhantomData,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new<value_T>(value: value_T) -> Edge<dtype>
    where value_T: AnyTensor,
          value_T: 'static,
    {
        Self {
            value: Rc::new(value),
            phantom_dtype: PhantomData,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<T, Tidx> GraphOperation for Sum<T, Tidx>
where T: TensorType,
      T: Clone,
      Tidx: TensorType,
      Tidx: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
      Tidx: con_or_DT_INT32_or_DT_INT64,
      Tidx: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("Sum_{}")?
        };
        let mut new_op = graph.new_operation("Sum", &op_name)?;
        {
            new_op.add_edge(&self.input)?
        }
        {
            new_op.add_edge(&self.reduction_indices)?
        }
        {
            match self.keep_dims {
                None => new_op.set_attr_value_proto("keep_dims", &vec![40_u8, 0_u8,])?,
                Some(ref value) => (|attr: &bool| {new_op.set_attr_bool("keep_dims", *attr)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct Sum<T, Tidx>
where T: TensorType,
      T: Clone,
      Tidx: TensorType,
      Tidx: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
      Tidx: con_or_DT_INT32_or_DT_INT64,
      Tidx: 'static,
{
    phantom_T: PhantomData<T>,
    input: Edge<T>,
    phantom_Tidx: PhantomData<Tidx>,
    reduction_indices: Edge<Tidx>,
    keep_dims: Option<bool>,
    op_name: Option<String>,
    id_: usize,
}

impl<T, Tidx> Sum<T, Tidx>
where T: TensorType,
      T: Clone,
      Tidx: TensorType,
      Tidx: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
      Tidx: con_or_DT_INT32_or_DT_INT64,
      Tidx: 'static,
{
    pub fn output(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn keep_dims(&mut self, keep_dims: bool) -> Self {
        self.keep_dims = Some(keep_dims);
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(input: Edge<T>, reduction_indices: Edge<Tidx>) -> Self {
        Self {
            phantom_T: PhantomData,
            input,
            phantom_Tidx: PhantomData,
            reduction_indices,
            keep_dims: None,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(input: Edge<T>, reduction_indices: Edge<Tidx>) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            input,
            phantom_Tidx: PhantomData,
            reduction_indices,
            keep_dims: None,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

pub trait con_or_DT_FLOAT {
}

impl con_or_DT_FLOAT for f32 {
}

impl<T, U> GraphOperation for FusedBatchNormGradV2<T, U>
where T: TensorType,
      T: Clone,
      U: TensorType,
      U: Clone,
      T: con_or_DT_FLOAT_or_DT_BFLOAT16_or_DT_HALF,
      T: 'static,
      U: con_or_DT_FLOAT,
      U: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("FusedBatchNormGradV2_{}")?
        };
        let mut new_op = graph.new_operation("FusedBatchNormGradV2", &op_name)?;
        {
            new_op.add_edge(&self.y_backprop)?
        }
        {
            new_op.add_edge(&self.x)?
        }
        {
            new_op.add_edge(&self.scale)?
        }
        {
            new_op.add_edge(&self.reserve_space_1)?
        }
        {
            new_op.add_edge(&self.reserve_space_2)?
        }
        {
            match self.epsilon {
                None => new_op.set_attr_value_proto("epsilon", &vec![37_u8, 23_u8, 183_u8, 209_u8, 56_u8,])?,
                Some(ref value) => (|attr: &f32| {new_op.set_attr_float("epsilon", *attr)})(&value)?,
            };
        }
        {
            match self.data_format {
                None => new_op.set_attr_value_proto("data_format", &vec![18_u8, 4_u8, 78_u8, 72_u8, 87_u8, 67_u8,])?,
                Some(ref value) => (|attr| {new_op.set_attr_string("data_format", attr)})(&value)?,
            };
        }
        {
            match self.is_training {
                None => new_op.set_attr_value_proto("is_training", &vec![40_u8, 1_u8,])?,
                Some(ref value) => (|attr: &bool| {new_op.set_attr_bool("is_training", *attr)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct FusedBatchNormGradV2<T, U>
where T: TensorType,
      T: Clone,
      U: TensorType,
      U: Clone,
      T: con_or_DT_FLOAT_or_DT_BFLOAT16_or_DT_HALF,
      T: 'static,
      U: con_or_DT_FLOAT,
      U: 'static,
{
    phantom_T: PhantomData<T>,
    y_backprop: Edge<T>,
    x: Edge<T>,
    scale: Edge<f32>,
    phantom_U: PhantomData<U>,
    reserve_space_1: Edge<U>,
    reserve_space_2: Edge<U>,
    epsilon: Option<f32>,
    data_format: Option<String>,
    is_training: Option<bool>,
    op_name: Option<String>,
    id_: usize,
}

impl<T, U> FusedBatchNormGradV2<T, U>
where T: TensorType,
      T: Clone,
      U: TensorType,
      U: Clone,
      T: con_or_DT_FLOAT_or_DT_BFLOAT16_or_DT_HALF,
      T: 'static,
      U: con_or_DT_FLOAT,
      U: 'static,
{
    pub fn x_backprop(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn scale_backprop(self) -> Edge<U> {
        let rc = Rc::new(self);
        {
            Edge::<U>::new(rc.clone(), 1)
        }
    }

    pub fn offset_backprop(self) -> Edge<U> {
        let rc = Rc::new(self);
        {
            Edge::<U>::new(rc.clone(), 2)
        }
    }

    pub fn reserve_space_3(self) -> Edge<U> {
        let rc = Rc::new(self);
        {
            Edge::<U>::new(rc.clone(), 3)
        }
    }

    pub fn reserve_space_4(self) -> Edge<U> {
        let rc = Rc::new(self);
        {
            Edge::<U>::new(rc.clone(), 4)
        }
    }

    pub fn epsilon(&mut self, epsilon: f32) -> Self {
        self.epsilon = Some(epsilon);
        self.clone()
    }

    pub fn data_format(&mut self, data_format: &str) -> Self {
        self.data_format = Some(data_format.to_string());
        self.clone()
    }

    pub fn is_training(&mut self, is_training: bool) -> Self {
        self.is_training = Some(is_training);
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> (Edge<T>, Edge<U>, Edge<U>, Edge<U>, Edge<U>) {
        let rc = Rc::new(self);
        (
        {
            Edge::<T>::new(rc.clone(), 0)
        },
        {
            Edge::<U>::new(rc.clone(), 1)
        },
        {
            Edge::<U>::new(rc.clone(), 2)
        },
        {
            Edge::<U>::new(rc.clone(), 3)
        },
        {
            Edge::<U>::new(rc.clone(), 4)
        },
        )
    }

    pub fn build(y_backprop: Edge<T>, x: Edge<T>, scale: Edge<f32>, reserve_space_1: Edge<U>, reserve_space_2: Edge<U>) -> Self {
        Self {
            phantom_T: PhantomData,
            y_backprop,
            x,
            scale,
            phantom_U: PhantomData,
            reserve_space_1,
            reserve_space_2,
            epsilon: None,
            data_format: None,
            is_training: None,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(y_backprop: Edge<T>, x: Edge<T>, scale: Edge<f32>, reserve_space_1: Edge<U>, reserve_space_2: Edge<U>) -> (Edge<T>, Edge<U>, Edge<U>, Edge<U>, Edge<U>) {
        Self {
            phantom_T: PhantomData,
            y_backprop,
            x,
            scale,
            phantom_U: PhantomData,
            reserve_space_1,
            reserve_space_2,
            epsilon: None,
            data_format: None,
            is_training: None,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<elem_type> GraphOperation for Stack<elem_type>
where elem_type: 'static,
      elem_type: Clone,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("Stack_{}")?
        };
        let mut new_op = graph.new_operation("Stack", &op_name)?;
        {
            match self.stack_name {
                None => new_op.set_attr_value_proto("stack_name", &vec![18_u8, 0_u8,])?,
                Some(ref value) => (|attr| {new_op.set_attr_string("stack_name", attr)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct Stack<elem_type>
where elem_type: 'static,
      elem_type: Clone,
{
    phantom_elem_type: PhantomData<elem_type>,
    stack_name: Option<String>,
    op_name: Option<String>,
    id_: usize,
}

impl<elem_type> Stack<elem_type>
where elem_type: 'static,
      elem_type: Clone,
{
    pub fn handle(self) -> Edge<String> {
        let rc = Rc::new(self);
        {
            Edge::<String>::new(rc.clone(), 0)
        }
    }

    pub fn stack_name(&mut self, stack_name: &str) -> Self {
        self.stack_name = Some(stack_name.to_string());
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<String> {
        let rc = Rc::new(self);
        {
            Edge::<String>::new(rc.clone(), 0)
        }
    }

    pub fn build() -> Self {
        Self {
            phantom_elem_type: PhantomData,
            stack_name: None,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new() -> Edge<String> {
        Self {
            phantom_elem_type: PhantomData,
            stack_name: None,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

pub trait con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_COMPLEX64_or_DT_COMPLEX128_or_DT_HALF {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_COMPLEX64_or_DT_COMPLEX128_or_DT_HALF for OtherComplex<f32> {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_COMPLEX64_or_DT_COMPLEX128_or_DT_HALF for OtherComplex<f64> {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_COMPLEX64_or_DT_COMPLEX128_or_DT_HALF for f32 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_COMPLEX64_or_DT_COMPLEX128_or_DT_HALF for f64 {
}

impl<T> GraphOperation for Xlogy<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_COMPLEX64_or_DT_COMPLEX128_or_DT_HALF,
      T: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("Xlogy_{}")?
        };
        let mut new_op = graph.new_operation("Xlogy", &op_name)?;
        {
            new_op.add_edge(&self.x)?
        }
        {
            new_op.add_edge(&self.y)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct Xlogy<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_COMPLEX64_or_DT_COMPLEX128_or_DT_HALF,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    x: Edge<T>,
    y: Edge<T>,
    op_name: Option<String>,
    id_: usize,
}

impl<T> Xlogy<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_COMPLEX64_or_DT_COMPLEX128_or_DT_HALF,
      T: 'static,
{
    pub fn z(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(x: Edge<T>, y: Edge<T>) -> Self {
        Self {
            phantom_T: PhantomData,
            x,
            y,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(x: Edge<T>, y: Edge<T>) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            x,
            y,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<T> GraphOperation for EditDistance<T>
where T: TensorType,
      T: Clone,
      T: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("EditDistance_{}")?
        };
        let mut new_op = graph.new_operation("EditDistance", &op_name)?;
        {
            new_op.add_edge(&self.hypothesis_indices)?
        }
        {
            new_op.add_edge(&self.hypothesis_values)?
        }
        {
            new_op.add_edge(&self.hypothesis_shape)?
        }
        {
            new_op.add_edge(&self.truth_indices)?
        }
        {
            new_op.add_edge(&self.truth_values)?
        }
        {
            new_op.add_edge(&self.truth_shape)?
        }
        {
            match self.normalize {
                None => new_op.set_attr_value_proto("normalize", &vec![40_u8, 1_u8,])?,
                Some(ref value) => (|attr: &bool| {new_op.set_attr_bool("normalize", *attr)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct EditDistance<T>
where T: TensorType,
      T: Clone,
      T: 'static,
{
    hypothesis_indices: Edge<i64>,
    phantom_T: PhantomData<T>,
    hypothesis_values: Edge<T>,
    hypothesis_shape: Edge<i64>,
    truth_indices: Edge<i64>,
    truth_values: Edge<T>,
    truth_shape: Edge<i64>,
    normalize: Option<bool>,
    op_name: Option<String>,
    id_: usize,
}

impl<T> EditDistance<T>
where T: TensorType,
      T: Clone,
      T: 'static,
{
    pub fn output(self) -> Edge<f32> {
        let rc = Rc::new(self);
        {
            Edge::<f32>::new(rc.clone(), 0)
        }
    }

    pub fn normalize(&mut self, normalize: bool) -> Self {
        self.normalize = Some(normalize);
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<f32> {
        let rc = Rc::new(self);
        {
            Edge::<f32>::new(rc.clone(), 0)
        }
    }

    pub fn build(hypothesis_indices: Edge<i64>, hypothesis_values: Edge<T>, hypothesis_shape: Edge<i64>, truth_indices: Edge<i64>, truth_values: Edge<T>, truth_shape: Edge<i64>) -> Self {
        Self {
            hypothesis_indices,
            phantom_T: PhantomData,
            hypothesis_values,
            hypothesis_shape,
            truth_indices,
            truth_values,
            truth_shape,
            normalize: None,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(hypothesis_indices: Edge<i64>, hypothesis_values: Edge<T>, hypothesis_shape: Edge<i64>, truth_indices: Edge<i64>, truth_values: Edge<T>, truth_shape: Edge<i64>) -> Edge<f32> {
        Self {
            hypothesis_indices,
            phantom_T: PhantomData,
            hypothesis_values,
            hypothesis_shape,
            truth_indices,
            truth_values,
            truth_shape,
            normalize: None,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl GraphOperation for AccumulatorNumAccumulated {
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("AccumulatorNumAccumulated_{}")?
        };
        let mut new_op = graph.new_operation("AccumulatorNumAccumulated", &op_name)?;
        {
            new_op.add_edge(&self.handle)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct AccumulatorNumAccumulated {
    handle: Edge<String>,
    op_name: Option<String>,
    id_: usize,
}

impl AccumulatorNumAccumulated {
    pub fn num_accumulated(self) -> Edge<i32> {
        let rc = Rc::new(self);
        {
            Edge::<i32>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<i32> {
        let rc = Rc::new(self);
        {
            Edge::<i32>::new(rc.clone(), 0)
        }
    }

    pub fn build(handle: Edge<String>) -> Self {
        Self {
            handle,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(handle: Edge<String>) -> Edge<i32> {
        Self {
            handle,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

pub trait con_or_DT_INT32_or_DT_UINT8_or_DT_INT64 {
}

impl con_or_DT_INT32_or_DT_UINT8_or_DT_INT64 for i32 {
}

impl con_or_DT_INT32_or_DT_UINT8_or_DT_INT64 for i64 {
}

impl con_or_DT_INT32_or_DT_UINT8_or_DT_INT64 for u8 {
}

impl<TI, T> GraphOperation for OneHot<TI, T>
where TI: TensorType,
      TI: Clone,
      T: TensorType,
      T: Clone,
      T: 'static,
      TI: con_or_DT_INT32_or_DT_UINT8_or_DT_INT64,
      TI: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("OneHot_{}")?
        };
        let mut new_op = graph.new_operation("OneHot", &op_name)?;
        {
            new_op.add_edge(&self.indices)?
        }
        {
            new_op.add_edge(&self.depth)?
        }
        {
            new_op.add_edge(&self.on_value)?
        }
        {
            new_op.add_edge(&self.off_value)?
        }
        {
            match self.axis {
                None => new_op.set_attr_value_proto("axis", &vec![24_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 1_u8,])?,
                Some(ref value) => (|attr: &i64| {new_op.set_attr_int("axis", *attr)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct OneHot<TI, T>
where TI: TensorType,
      TI: Clone,
      T: TensorType,
      T: Clone,
      T: 'static,
      TI: con_or_DT_INT32_or_DT_UINT8_or_DT_INT64,
      TI: 'static,
{
    phantom_TI: PhantomData<TI>,
    indices: Edge<TI>,
    depth: Edge<i32>,
    phantom_T: PhantomData<T>,
    on_value: Edge<T>,
    off_value: Edge<T>,
    axis: Option<i64>,
    op_name: Option<String>,
    id_: usize,
}

impl<TI, T> OneHot<TI, T>
where TI: TensorType,
      TI: Clone,
      T: TensorType,
      T: Clone,
      T: 'static,
      TI: con_or_DT_INT32_or_DT_UINT8_or_DT_INT64,
      TI: 'static,
{
    pub fn output(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn axis(&mut self, axis: i64) -> Self {
        self.axis = Some(axis);
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(indices: Edge<TI>, depth: Edge<i32>, on_value: Edge<T>, off_value: Edge<T>) -> Self {
        Self {
            phantom_TI: PhantomData,
            indices,
            depth,
            phantom_T: PhantomData,
            on_value,
            off_value,
            axis: None,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(indices: Edge<TI>, depth: Edge<i32>, on_value: Edge<T>, off_value: Edge<T>) -> Edge<T> {
        Self {
            phantom_TI: PhantomData,
            indices,
            depth,
            phantom_T: PhantomData,
            on_value,
            off_value,
            axis: None,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<T, Tperm> GraphOperation for ConjugateTranspose<T, Tperm>
where T: TensorType,
      T: Clone,
      Tperm: TensorType,
      Tperm: Clone,
      T: 'static,
      Tperm: con_or_DT_INT32_or_DT_INT64,
      Tperm: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("ConjugateTranspose_{}")?
        };
        let mut new_op = graph.new_operation("ConjugateTranspose", &op_name)?;
        {
            new_op.add_edge(&self.x)?
        }
        {
            new_op.add_edge(&self.perm)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct ConjugateTranspose<T, Tperm>
where T: TensorType,
      T: Clone,
      Tperm: TensorType,
      Tperm: Clone,
      T: 'static,
      Tperm: con_or_DT_INT32_or_DT_INT64,
      Tperm: 'static,
{
    phantom_T: PhantomData<T>,
    x: Edge<T>,
    phantom_Tperm: PhantomData<Tperm>,
    perm: Edge<Tperm>,
    op_name: Option<String>,
    id_: usize,
}

impl<T, Tperm> ConjugateTranspose<T, Tperm>
where T: TensorType,
      T: Clone,
      Tperm: TensorType,
      Tperm: Clone,
      T: 'static,
      Tperm: con_or_DT_INT32_or_DT_INT64,
      Tperm: 'static,
{
    pub fn y(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(x: Edge<T>, perm: Edge<Tperm>) -> Self {
        Self {
            phantom_T: PhantomData,
            x,
            phantom_Tperm: PhantomData,
            perm,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(x: Edge<T>, perm: Edge<Tperm>) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            x,
            phantom_Tperm: PhantomData,
            perm,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

pub trait con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BOOL_or_DT_HALF {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BOOL_or_DT_HALF for bool {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BOOL_or_DT_HALF for f32 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BOOL_or_DT_HALF for f64 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BOOL_or_DT_HALF for i16 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BOOL_or_DT_HALF for i32 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BOOL_or_DT_HALF for i64 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BOOL_or_DT_HALF for i8 {
}

impl<T> GraphOperation for CompareAndBitpack<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BOOL_or_DT_HALF,
      T: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("CompareAndBitpack_{}")?
        };
        let mut new_op = graph.new_operation("CompareAndBitpack", &op_name)?;
        {
            new_op.add_edge(&self.input)?
        }
        {
            new_op.add_edge(&self.threshold)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct CompareAndBitpack<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BOOL_or_DT_HALF,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    input: Edge<T>,
    threshold: Edge<T>,
    op_name: Option<String>,
    id_: usize,
}

impl<T> CompareAndBitpack<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BOOL_or_DT_HALF,
      T: 'static,
{
    pub fn output(self) -> Edge<u8> {
        let rc = Rc::new(self);
        {
            Edge::<u8>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<u8> {
        let rc = Rc::new(self);
        {
            Edge::<u8>::new(rc.clone(), 0)
        }
    }

    pub fn build(input: Edge<T>, threshold: Edge<T>) -> Self {
        Self {
            phantom_T: PhantomData,
            input,
            threshold,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(input: Edge<T>, threshold: Edge<T>) -> Edge<u8> {
        Self {
            phantom_T: PhantomData,
            input,
            threshold,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl GraphOperation for RetrieveTPUEmbeddingAdagradParameters {
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("RetrieveTPUEmbeddingAdagradParameters_{}")?
        };
        let mut new_op = graph.new_operation("RetrieveTPUEmbeddingAdagradParameters", &op_name)?;
        {
            match self.table_id {
                None => new_op.set_attr_value_proto("table_id", &vec![24_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 1_u8,])?,
                Some(ref value) => (|attr: &i64| {new_op.set_attr_int("table_id", *attr)})(&value)?,
            };
        }
        {
            match self.table_name {
                None => new_op.set_attr_value_proto("table_name", &vec![18_u8, 0_u8,])?,
                Some(ref value) => (|attr| {new_op.set_attr_string("table_name", attr)})(&value)?,
            };
        }
        {
            (|attr: &i64| {new_op.set_attr_int("num_shards", *attr)})(&self.num_shards)?
        }
        {
            (|attr: &i64| {new_op.set_attr_int("shard_id", *attr)})(&self.shard_id)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct RetrieveTPUEmbeddingAdagradParameters {
    table_id: Option<i64>,
    table_name: Option<String>,
    num_shards: i64,
    shard_id: i64,
    op_name: Option<String>,
    id_: usize,
}

impl RetrieveTPUEmbeddingAdagradParameters {
    pub fn parameters(self) -> Edge<f32> {
        let rc = Rc::new(self);
        {
            Edge::<f32>::new(rc.clone(), 0)
        }
    }

    pub fn accumulators(self) -> Edge<f32> {
        let rc = Rc::new(self);
        {
            Edge::<f32>::new(rc.clone(), 1)
        }
    }

    pub fn table_id(&mut self, table_id: i64) -> Self {
        self.table_id = Some(table_id);
        self.clone()
    }

    pub fn table_name(&mut self, table_name: &str) -> Self {
        self.table_name = Some(table_name.to_string());
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> (Edge<f32>, Edge<f32>) {
        let rc = Rc::new(self);
        (
        {
            Edge::<f32>::new(rc.clone(), 0)
        },
        {
            Edge::<f32>::new(rc.clone(), 1)
        },
        )
    }

    pub fn build(num_shards: i64, shard_id: i64) -> Self {
        Self {
            table_id: None,
            table_name: None,
            num_shards: num_shards,
            shard_id: shard_id,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(num_shards: i64, shard_id: i64) -> (Edge<f32>, Edge<f32>) {
        Self {
            table_id: None,
            table_name: None,
            num_shards: num_shards,
            shard_id: shard_id,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<T> GraphOperation for CountUpTo<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_INT32_or_DT_INT64,
      T: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("CountUpTo_{}")?
        };
        let mut new_op = graph.new_operation("CountUpTo", &op_name)?;
        {
            new_op.add_edge(&self.ref_)?
        }
        {
            (|attr: &i64| {new_op.set_attr_int("limit", *attr)})(&self.limit)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct CountUpTo<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_INT32_or_DT_INT64,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    ref_: Edge<T>,
    limit: i64,
    op_name: Option<String>,
    id_: usize,
}

impl<T> CountUpTo<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_INT32_or_DT_INT64,
      T: 'static,
{
    pub fn output(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(ref_: Edge<T>, limit: i64) -> Self {
        Self {
            phantom_T: PhantomData,
            ref_,
            limit: limit,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(ref_: Edge<T>, limit: i64) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            ref_,
            limit: limit,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<T> GraphOperation for CudnnRNNCanonicalToParams<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_HALF,
      T: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("CudnnRNNCanonicalToParams_{}")?
        };
        let mut new_op = graph.new_operation("CudnnRNNCanonicalToParams", &op_name)?;
        {
            new_op.add_edge(&self.num_layers)?
        }
        {
            new_op.add_edge(&self.num_units)?
        }
        {
            new_op.add_edge(&self.input_size)?
        }
        {
            new_op.add_edge(&self.weights)?
        }
        {
            new_op.add_edge(&self.biases)?
        }
        {
            (|attr: &i64| {new_op.set_attr_int("num_params", *attr)})(&self.num_params)?
        }
        {
            match self.rnn_mode {
                None => new_op.set_attr_value_proto("rnn_mode", &vec![18_u8, 4_u8, 108_u8, 115_u8, 116_u8, 109_u8,])?,
                Some(ref value) => (|attr| {new_op.set_attr_string("rnn_mode", attr)})(&value)?,
            };
        }
        {
            match self.input_mode {
                None => new_op.set_attr_value_proto("input_mode", &vec![18_u8, 12_u8, 108_u8, 105_u8, 110_u8, 101_u8, 97_u8, 114_u8, 95_u8, 105_u8, 110_u8, 112_u8, 117_u8, 116_u8,])?,
                Some(ref value) => (|attr| {new_op.set_attr_string("input_mode", attr)})(&value)?,
            };
        }
        {
            match self.direction {
                None => new_op.set_attr_value_proto("direction", &vec![18_u8, 14_u8, 117_u8, 110_u8, 105_u8, 100_u8, 105_u8, 114_u8, 101_u8, 99_u8, 116_u8, 105_u8, 111_u8, 110_u8, 97_u8, 108_u8,])?,
                Some(ref value) => (|attr| {new_op.set_attr_string("direction", attr)})(&value)?,
            };
        }
        {
            match self.dropout {
                None => new_op.set_attr_value_proto("dropout", &vec![37_u8, 0_u8, 0_u8, 0_u8, 0_u8,])?,
                Some(ref value) => (|attr: &f32| {new_op.set_attr_float("dropout", *attr)})(&value)?,
            };
        }
        {
            match self.seed {
                None => new_op.set_attr_value_proto("seed", &vec![24_u8, 0_u8,])?,
                Some(ref value) => (|attr: &i64| {new_op.set_attr_int("seed", *attr)})(&value)?,
            };
        }
        {
            match self.seed2 {
                None => new_op.set_attr_value_proto("seed2", &vec![24_u8, 0_u8,])?,
                Some(ref value) => (|attr: &i64| {new_op.set_attr_int("seed2", *attr)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct CudnnRNNCanonicalToParams<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_HALF,
      T: 'static,
{
    num_layers: Edge<i32>,
    num_units: Edge<i32>,
    input_size: Edge<i32>,
    phantom_T: PhantomData<T>,
    weights: Edge<T>,
    biases: Edge<T>,
    num_params: i64,
    rnn_mode: Option<String>,
    input_mode: Option<String>,
    direction: Option<String>,
    dropout: Option<f32>,
    seed: Option<i64>,
    seed2: Option<i64>,
    op_name: Option<String>,
    id_: usize,
}

impl<T> CudnnRNNCanonicalToParams<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_HALF,
      T: 'static,
{
    pub fn params(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn rnn_mode(&mut self, rnn_mode: &str) -> Self {
        self.rnn_mode = Some(rnn_mode.to_string());
        self.clone()
    }

    pub fn input_mode(&mut self, input_mode: &str) -> Self {
        self.input_mode = Some(input_mode.to_string());
        self.clone()
    }

    pub fn direction(&mut self, direction: &str) -> Self {
        self.direction = Some(direction.to_string());
        self.clone()
    }

    pub fn dropout(&mut self, dropout: f32) -> Self {
        self.dropout = Some(dropout);
        self.clone()
    }

    pub fn seed(&mut self, seed: i64) -> Self {
        self.seed = Some(seed);
        self.clone()
    }

    pub fn seed2(&mut self, seed2: i64) -> Self {
        self.seed2 = Some(seed2);
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(num_layers: Edge<i32>, num_units: Edge<i32>, input_size: Edge<i32>, weights: Edge<T>, biases: Edge<T>, num_params: i64) -> Self {
        Self {
            num_layers,
            num_units,
            input_size,
            phantom_T: PhantomData,
            weights,
            biases,
            num_params: num_params,
            rnn_mode: None,
            input_mode: None,
            direction: None,
            dropout: None,
            seed: None,
            seed2: None,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(num_layers: Edge<i32>, num_units: Edge<i32>, input_size: Edge<i32>, weights: Edge<T>, biases: Edge<T>, num_params: i64) -> Edge<T> {
        Self {
            num_layers,
            num_units,
            input_size,
            phantom_T: PhantomData,
            weights,
            biases,
            num_params: num_params,
            rnn_mode: None,
            input_mode: None,
            direction: None,
            dropout: None,
            seed: None,
            seed2: None,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<Ta, Tb> GraphOperation for SparseMatMul<Ta, Tb>
where Ta: TensorType,
      Ta: Clone,
      Tb: TensorType,
      Tb: Clone,
      Ta: con_or_DT_FLOAT_or_DT_BFLOAT16,
      Ta: 'static,
      Tb: con_or_DT_FLOAT_or_DT_BFLOAT16,
      Tb: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("SparseMatMul_{}")?
        };
        let mut new_op = graph.new_operation("SparseMatMul", &op_name)?;
        {
            new_op.add_edge(&self.a)?
        }
        {
            new_op.add_edge(&self.b)?
        }
        {
            match self.transpose_a {
                None => new_op.set_attr_value_proto("transpose_a", &vec![40_u8, 0_u8,])?,
                Some(ref value) => (|attr: &bool| {new_op.set_attr_bool("transpose_a", *attr)})(&value)?,
            };
        }
        {
            match self.transpose_b {
                None => new_op.set_attr_value_proto("transpose_b", &vec![40_u8, 0_u8,])?,
                Some(ref value) => (|attr: &bool| {new_op.set_attr_bool("transpose_b", *attr)})(&value)?,
            };
        }
        {
            match self.a_is_sparse {
                None => new_op.set_attr_value_proto("a_is_sparse", &vec![40_u8, 0_u8,])?,
                Some(ref value) => (|attr: &bool| {new_op.set_attr_bool("a_is_sparse", *attr)})(&value)?,
            };
        }
        {
            match self.b_is_sparse {
                None => new_op.set_attr_value_proto("b_is_sparse", &vec![40_u8, 0_u8,])?,
                Some(ref value) => (|attr: &bool| {new_op.set_attr_bool("b_is_sparse", *attr)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct SparseMatMul<Ta, Tb>
where Ta: TensorType,
      Ta: Clone,
      Tb: TensorType,
      Tb: Clone,
      Ta: con_or_DT_FLOAT_or_DT_BFLOAT16,
      Ta: 'static,
      Tb: con_or_DT_FLOAT_or_DT_BFLOAT16,
      Tb: 'static,
{
    phantom_Ta: PhantomData<Ta>,
    a: Edge<Ta>,
    phantom_Tb: PhantomData<Tb>,
    b: Edge<Tb>,
    transpose_a: Option<bool>,
    transpose_b: Option<bool>,
    a_is_sparse: Option<bool>,
    b_is_sparse: Option<bool>,
    op_name: Option<String>,
    id_: usize,
}

impl<Ta, Tb> SparseMatMul<Ta, Tb>
where Ta: TensorType,
      Ta: Clone,
      Tb: TensorType,
      Tb: Clone,
      Ta: con_or_DT_FLOAT_or_DT_BFLOAT16,
      Ta: 'static,
      Tb: con_or_DT_FLOAT_or_DT_BFLOAT16,
      Tb: 'static,
{
    pub fn product(self) -> Edge<f32> {
        let rc = Rc::new(self);
        {
            Edge::<f32>::new(rc.clone(), 0)
        }
    }

    pub fn transpose_a(&mut self, transpose_a: bool) -> Self {
        self.transpose_a = Some(transpose_a);
        self.clone()
    }

    pub fn transpose_b(&mut self, transpose_b: bool) -> Self {
        self.transpose_b = Some(transpose_b);
        self.clone()
    }

    pub fn a_is_sparse(&mut self, a_is_sparse: bool) -> Self {
        self.a_is_sparse = Some(a_is_sparse);
        self.clone()
    }

    pub fn b_is_sparse(&mut self, b_is_sparse: bool) -> Self {
        self.b_is_sparse = Some(b_is_sparse);
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<f32> {
        let rc = Rc::new(self);
        {
            Edge::<f32>::new(rc.clone(), 0)
        }
    }

    pub fn build(a: Edge<Ta>, b: Edge<Tb>) -> Self {
        Self {
            phantom_Ta: PhantomData,
            a,
            phantom_Tb: PhantomData,
            b,
            transpose_a: None,
            transpose_b: None,
            a_is_sparse: None,
            b_is_sparse: None,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(a: Edge<Ta>, b: Edge<Tb>) -> Edge<f32> {
        Self {
            phantom_Ta: PhantomData,
            a,
            phantom_Tb: PhantomData,
            b,
            transpose_a: None,
            transpose_b: None,
            a_is_sparse: None,
            b_is_sparse: None,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl GraphOperation for TPUEmbeddingActivations {
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("TPUEmbeddingActivations_{}")?
        };
        let mut new_op = graph.new_operation("TPUEmbeddingActivations", &op_name)?;
        {
            new_op.add_edge(&self.embedding_variable)?
        }
        {
            new_op.add_edge(&self.sliced_activations)?
        }
        {
            (|attr: &i64| {new_op.set_attr_int("table_id", *attr)})(&self.table_id)?
        }
        {
            (|attr: &i64| {new_op.set_attr_int("lookup_id", *attr)})(&self.lookup_id)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct TPUEmbeddingActivations {
    embedding_variable: Edge<f32>,
    sliced_activations: Edge<f32>,
    table_id: i64,
    lookup_id: i64,
    op_name: Option<String>,
    id_: usize,
}

impl TPUEmbeddingActivations {
    pub fn output(self) -> Edge<f32> {
        let rc = Rc::new(self);
        {
            Edge::<f32>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<f32> {
        let rc = Rc::new(self);
        {
            Edge::<f32>::new(rc.clone(), 0)
        }
    }

    pub fn build(embedding_variable: Edge<f32>, sliced_activations: Edge<f32>, table_id: i64, lookup_id: i64) -> Self {
        Self {
            embedding_variable,
            sliced_activations,
            table_id: table_id,
            lookup_id: lookup_id,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(embedding_variable: Edge<f32>, sliced_activations: Edge<f32>, table_id: i64, lookup_id: i64) -> Edge<f32> {
        Self {
            embedding_variable,
            sliced_activations,
            table_id: table_id,
            lookup_id: lookup_id,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<T> GraphOperation for InplaceSub<T>
where T: TensorType,
      T: Clone,
      T: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("InplaceSub_{}")?
        };
        let mut new_op = graph.new_operation("InplaceSub", &op_name)?;
        {
            new_op.add_edge(&self.x)?
        }
        {
            new_op.add_edge(&self.i)?
        }
        {
            new_op.add_edge(&self.v)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct InplaceSub<T>
where T: TensorType,
      T: Clone,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    x: Edge<T>,
    i: Edge<i32>,
    v: Edge<T>,
    op_name: Option<String>,
    id_: usize,
}

impl<T> InplaceSub<T>
where T: TensorType,
      T: Clone,
      T: 'static,
{
    pub fn y(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(x: Edge<T>, i: Edge<i32>, v: Edge<T>) -> Self {
        Self {
            phantom_T: PhantomData,
            x,
            i,
            v,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(x: Edge<T>, i: Edge<i32>, v: Edge<T>) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            x,
            i,
            v,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl GraphOperation for LoadTPUEmbeddingRMSPropParameters {
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("LoadTPUEmbeddingRMSPropParameters_{}")?
        };
        let mut new_op = graph.new_operation("LoadTPUEmbeddingRMSPropParameters", &op_name)?;
        {
            new_op.add_edge(&self.parameters)?
        }
        {
            new_op.add_edge(&self.ms)?
        }
        {
            new_op.add_edge(&self.mom)?
        }
        {
            match self.table_id {
                None => new_op.set_attr_value_proto("table_id", &vec![24_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 1_u8,])?,
                Some(ref value) => (|attr: &i64| {new_op.set_attr_int("table_id", *attr)})(&value)?,
            };
        }
        {
            match self.table_name {
                None => new_op.set_attr_value_proto("table_name", &vec![18_u8, 0_u8,])?,
                Some(ref value) => (|attr| {new_op.set_attr_string("table_name", attr)})(&value)?,
            };
        }
        {
            (|attr: &i64| {new_op.set_attr_int("num_shards", *attr)})(&self.num_shards)?
        }
        {
            (|attr: &i64| {new_op.set_attr_int("shard_id", *attr)})(&self.shard_id)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct LoadTPUEmbeddingRMSPropParameters {
    parameters: Edge<f32>,
    ms: Edge<f32>,
    mom: Edge<f32>,
    table_id: Option<i64>,
    table_name: Option<String>,
    num_shards: i64,
    shard_id: i64,
    op_name: Option<String>,
    id_: usize,
}

impl LoadTPUEmbeddingRMSPropParameters {
    pub fn table_id(&mut self, table_id: i64) -> Self {
        self.table_id = Some(table_id);
        self.clone()
    }

    pub fn table_name(&mut self, table_name: &str) -> Self {
        self.table_name = Some(table_name.to_string());
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> () {
        let rc = Rc::new(self);
        (
        )
    }

    pub fn build(parameters: Edge<f32>, ms: Edge<f32>, mom: Edge<f32>, num_shards: i64, shard_id: i64) -> Self {
        Self {
            parameters,
            ms,
            mom,
            table_id: None,
            table_name: None,
            num_shards: num_shards,
            shard_id: shard_id,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(parameters: Edge<f32>, ms: Edge<f32>, mom: Edge<f32>, num_shards: i64, shard_id: i64) -> () {
        Self {
            parameters,
            ms,
            mom,
            table_id: None,
            table_name: None,
            num_shards: num_shards,
            shard_id: shard_id,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<T> GraphOperation for Copy<T>
where T: TensorType,
      T: Clone,
      T: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("Copy_{}")?
        };
        let mut new_op = graph.new_operation("Copy", &op_name)?;
        {
            new_op.add_edge(&self.input)?
        }
        {
            match self.tensor_name {
                None => new_op.set_attr_value_proto("tensor_name", &vec![18_u8, 0_u8,])?,
                Some(ref value) => (|attr| {new_op.set_attr_string("tensor_name", attr)})(&value)?,
            };
        }
        {
            match self.debug_ops_spec {
                None => new_op.set_attr_value_proto("debug_ops_spec", &vec![10_u8, 0_u8,])?,
                Some(ref value) => (|attrs| {new_op.set_attr_string_list("debug_ops_spec", attrs)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct Copy<T>
where T: TensorType,
      T: Clone,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    input: Edge<T>,
    tensor_name: Option<String>,
    debug_ops_spec: Option<Vec<String>>,
    op_name: Option<String>,
    id_: usize,
}

impl<T> Copy<T>
where T: TensorType,
      T: Clone,
      T: 'static,
{
    pub fn output(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn tensor_name(&mut self, tensor_name: &str) -> Self {
        self.tensor_name = Some(tensor_name.to_string());
        self.clone()
    }

    pub fn debug_ops_spec(&mut self, debug_ops_spec: &[String]) -> Self {
        self.debug_ops_spec = Some(debug_ops_spec.to_vec());
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(input: Edge<T>) -> Self {
        Self {
            phantom_T: PhantomData,
            input,
            tensor_name: None,
            debug_ops_spec: None,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(input: Edge<T>) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            input,
            tensor_name: None,
            debug_ops_spec: None,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<Index, T> GraphOperation for StridedSliceGrad<Index, T>
where Index: TensorType,
      Index: Clone,
      T: TensorType,
      T: Clone,
      T: 'static,
      Index: con_or_DT_INT32_or_DT_INT64,
      Index: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("StridedSliceGrad_{}")?
        };
        let mut new_op = graph.new_operation("StridedSliceGrad", &op_name)?;
        {
            new_op.add_edge(&self.shape)?
        }
        {
            new_op.add_edge(&self.begin)?
        }
        {
            new_op.add_edge(&self.end)?
        }
        {
            new_op.add_edge(&self.strides)?
        }
        {
            new_op.add_edge(&self.dy)?
        }
        {
            match self.begin_mask {
                None => new_op.set_attr_value_proto("begin_mask", &vec![24_u8, 0_u8,])?,
                Some(ref value) => (|attr: &i64| {new_op.set_attr_int("begin_mask", *attr)})(&value)?,
            };
        }
        {
            match self.end_mask {
                None => new_op.set_attr_value_proto("end_mask", &vec![24_u8, 0_u8,])?,
                Some(ref value) => (|attr: &i64| {new_op.set_attr_int("end_mask", *attr)})(&value)?,
            };
        }
        {
            match self.ellipsis_mask {
                None => new_op.set_attr_value_proto("ellipsis_mask", &vec![24_u8, 0_u8,])?,
                Some(ref value) => (|attr: &i64| {new_op.set_attr_int("ellipsis_mask", *attr)})(&value)?,
            };
        }
        {
            match self.new_axis_mask {
                None => new_op.set_attr_value_proto("new_axis_mask", &vec![24_u8, 0_u8,])?,
                Some(ref value) => (|attr: &i64| {new_op.set_attr_int("new_axis_mask", *attr)})(&value)?,
            };
        }
        {
            match self.shrink_axis_mask {
                None => new_op.set_attr_value_proto("shrink_axis_mask", &vec![24_u8, 0_u8,])?,
                Some(ref value) => (|attr: &i64| {new_op.set_attr_int("shrink_axis_mask", *attr)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct StridedSliceGrad<Index, T>
where Index: TensorType,
      Index: Clone,
      T: TensorType,
      T: Clone,
      T: 'static,
      Index: con_or_DT_INT32_or_DT_INT64,
      Index: 'static,
{
    phantom_Index: PhantomData<Index>,
    shape: Edge<Index>,
    begin: Edge<Index>,
    end: Edge<Index>,
    strides: Edge<Index>,
    phantom_T: PhantomData<T>,
    dy: Edge<T>,
    begin_mask: Option<i64>,
    end_mask: Option<i64>,
    ellipsis_mask: Option<i64>,
    new_axis_mask: Option<i64>,
    shrink_axis_mask: Option<i64>,
    op_name: Option<String>,
    id_: usize,
}

impl<Index, T> StridedSliceGrad<Index, T>
where Index: TensorType,
      Index: Clone,
      T: TensorType,
      T: Clone,
      T: 'static,
      Index: con_or_DT_INT32_or_DT_INT64,
      Index: 'static,
{
    pub fn output(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn begin_mask(&mut self, begin_mask: i64) -> Self {
        self.begin_mask = Some(begin_mask);
        self.clone()
    }

    pub fn end_mask(&mut self, end_mask: i64) -> Self {
        self.end_mask = Some(end_mask);
        self.clone()
    }

    pub fn ellipsis_mask(&mut self, ellipsis_mask: i64) -> Self {
        self.ellipsis_mask = Some(ellipsis_mask);
        self.clone()
    }

    pub fn new_axis_mask(&mut self, new_axis_mask: i64) -> Self {
        self.new_axis_mask = Some(new_axis_mask);
        self.clone()
    }

    pub fn shrink_axis_mask(&mut self, shrink_axis_mask: i64) -> Self {
        self.shrink_axis_mask = Some(shrink_axis_mask);
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(shape: Edge<Index>, begin: Edge<Index>, end: Edge<Index>, strides: Edge<Index>, dy: Edge<T>) -> Self {
        Self {
            phantom_Index: PhantomData,
            shape,
            begin,
            end,
            strides,
            phantom_T: PhantomData,
            dy,
            begin_mask: None,
            end_mask: None,
            ellipsis_mask: None,
            new_axis_mask: None,
            shrink_axis_mask: None,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(shape: Edge<Index>, begin: Edge<Index>, end: Edge<Index>, strides: Edge<Index>, dy: Edge<T>) -> Edge<T> {
        Self {
            phantom_Index: PhantomData,
            shape,
            begin,
            end,
            strides,
            phantom_T: PhantomData,
            dy,
            begin_mask: None,
            end_mask: None,
            ellipsis_mask: None,
            new_axis_mask: None,
            shrink_axis_mask: None,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<Tidx> GraphOperation for UnravelIndex<Tidx>
where Tidx: TensorType,
      Tidx: Clone,
      Tidx: con_or_DT_INT32_or_DT_INT64,
      Tidx: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("UnravelIndex_{}")?
        };
        let mut new_op = graph.new_operation("UnravelIndex", &op_name)?;
        {
            new_op.add_edge(&self.indices)?
        }
        {
            new_op.add_edge(&self.dims)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct UnravelIndex<Tidx>
where Tidx: TensorType,
      Tidx: Clone,
      Tidx: con_or_DT_INT32_or_DT_INT64,
      Tidx: 'static,
{
    phantom_Tidx: PhantomData<Tidx>,
    indices: Edge<Tidx>,
    dims: Edge<Tidx>,
    op_name: Option<String>,
    id_: usize,
}

impl<Tidx> UnravelIndex<Tidx>
where Tidx: TensorType,
      Tidx: Clone,
      Tidx: con_or_DT_INT32_or_DT_INT64,
      Tidx: 'static,
{
    pub fn output(self) -> Edge<Tidx> {
        let rc = Rc::new(self);
        {
            Edge::<Tidx>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<Tidx> {
        let rc = Rc::new(self);
        {
            Edge::<Tidx>::new(rc.clone(), 0)
        }
    }

    pub fn build(indices: Edge<Tidx>, dims: Edge<Tidx>) -> Self {
        Self {
            phantom_Tidx: PhantomData,
            indices,
            dims,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(indices: Edge<Tidx>, dims: Edge<Tidx>) -> Edge<Tidx> {
        Self {
            phantom_Tidx: PhantomData,
            indices,
            dims,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<T, Tindices> GraphOperation for TensorScatterUpdate<T, Tindices>
where T: TensorType,
      T: Clone,
      Tindices: TensorType,
      Tindices: Clone,
      T: 'static,
      Tindices: con_or_DT_INT32_or_DT_INT64,
      Tindices: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("TensorScatterUpdate_{}")?
        };
        let mut new_op = graph.new_operation("TensorScatterUpdate", &op_name)?;
        {
            new_op.add_edge(&self.tensor)?
        }
        {
            new_op.add_edge(&self.indices)?
        }
        {
            new_op.add_edge(&self.updates)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct TensorScatterUpdate<T, Tindices>
where T: TensorType,
      T: Clone,
      Tindices: TensorType,
      Tindices: Clone,
      T: 'static,
      Tindices: con_or_DT_INT32_or_DT_INT64,
      Tindices: 'static,
{
    phantom_T: PhantomData<T>,
    tensor: Edge<T>,
    phantom_Tindices: PhantomData<Tindices>,
    indices: Edge<Tindices>,
    updates: Edge<T>,
    op_name: Option<String>,
    id_: usize,
}

impl<T, Tindices> TensorScatterUpdate<T, Tindices>
where T: TensorType,
      T: Clone,
      Tindices: TensorType,
      Tindices: Clone,
      T: 'static,
      Tindices: con_or_DT_INT32_or_DT_INT64,
      Tindices: 'static,
{
    pub fn output(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(tensor: Edge<T>, indices: Edge<Tindices>, updates: Edge<T>) -> Self {
        Self {
            phantom_T: PhantomData,
            tensor,
            phantom_Tindices: PhantomData,
            indices,
            updates,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(tensor: Edge<T>, indices: Edge<Tindices>, updates: Edge<T>) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            tensor,
            phantom_Tindices: PhantomData,
            indices,
            updates,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl GraphOperation for Rpc {
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("Rpc_{}")?
        };
        let mut new_op = graph.new_operation("Rpc", &op_name)?;
        {
            new_op.add_edge(&self.address)?
        }
        {
            new_op.add_edge(&self.method)?
        }
        {
            new_op.add_edge(&self.request)?
        }
        {
            match self.protocol {
                None => new_op.set_attr_value_proto("protocol", &vec![18_u8, 0_u8,])?,
                Some(ref value) => (|attr| {new_op.set_attr_string("protocol", attr)})(&value)?,
            };
        }
        {
            match self.fail_fast {
                None => new_op.set_attr_value_proto("fail_fast", &vec![40_u8, 1_u8,])?,
                Some(ref value) => (|attr: &bool| {new_op.set_attr_bool("fail_fast", *attr)})(&value)?,
            };
        }
        {
            match self.timeout_in_ms {
                None => new_op.set_attr_value_proto("timeout_in_ms", &vec![24_u8, 0_u8,])?,
                Some(ref value) => (|attr: &i64| {new_op.set_attr_int("timeout_in_ms", *attr)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct Rpc {
    address: Edge<String>,
    method: Edge<String>,
    request: Edge<String>,
    protocol: Option<String>,
    fail_fast: Option<bool>,
    timeout_in_ms: Option<i64>,
    op_name: Option<String>,
    id_: usize,
}

impl Rpc {
    pub fn response(self) -> Edge<String> {
        let rc = Rc::new(self);
        {
            Edge::<String>::new(rc.clone(), 0)
        }
    }

    pub fn protocol(&mut self, protocol: &str) -> Self {
        self.protocol = Some(protocol.to_string());
        self.clone()
    }

    pub fn fail_fast(&mut self, fail_fast: bool) -> Self {
        self.fail_fast = Some(fail_fast);
        self.clone()
    }

    pub fn timeout_in_ms(&mut self, timeout_in_ms: i64) -> Self {
        self.timeout_in_ms = Some(timeout_in_ms);
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<String> {
        let rc = Rc::new(self);
        {
            Edge::<String>::new(rc.clone(), 0)
        }
    }

    pub fn build(address: Edge<String>, method: Edge<String>, request: Edge<String>) -> Self {
        Self {
            address,
            method,
            request,
            protocol: None,
            fail_fast: None,
            timeout_in_ms: None,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(address: Edge<String>, method: Edge<String>, request: Edge<String>) -> Edge<String> {
        Self {
            address,
            method,
            request,
            protocol: None,
            fail_fast: None,
            timeout_in_ms: None,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<T> GraphOperation for ScalarSummary<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("ScalarSummary_{}")?
        };
        let mut new_op = graph.new_operation("ScalarSummary", &op_name)?;
        {
            new_op.add_edge(&self.tags)?
        }
        {
            new_op.add_edge(&self.values)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct ScalarSummary<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
{
    tags: Edge<String>,
    phantom_T: PhantomData<T>,
    values: Edge<T>,
    op_name: Option<String>,
    id_: usize,
}

impl<T> ScalarSummary<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
{
    pub fn summary(self) -> Edge<String> {
        let rc = Rc::new(self);
        {
            Edge::<String>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<String> {
        let rc = Rc::new(self);
        {
            Edge::<String>::new(rc.clone(), 0)
        }
    }

    pub fn build(tags: Edge<String>, values: Edge<T>) -> Self {
        Self {
            tags,
            phantom_T: PhantomData,
            values,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(tags: Edge<String>, values: Edge<T>) -> Edge<String> {
        Self {
            tags,
            phantom_T: PhantomData,
            values,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<T> GraphOperation for TanhGrad<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_COMPLEX64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF,
      T: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("TanhGrad_{}")?
        };
        let mut new_op = graph.new_operation("TanhGrad", &op_name)?;
        {
            new_op.add_edge(&self.y)?
        }
        {
            new_op.add_edge(&self.dy)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct TanhGrad<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_COMPLEX64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    y: Edge<T>,
    dy: Edge<T>,
    op_name: Option<String>,
    id_: usize,
}

impl<T> TanhGrad<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_COMPLEX64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF,
      T: 'static,
{
    pub fn z(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(y: Edge<T>, dy: Edge<T>) -> Self {
        Self {
            phantom_T: PhantomData,
            y,
            dy,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(y: Edge<T>, dy: Edge<T>) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            y,
            dy,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl GraphOperation for RetrieveTPUEmbeddingADAMParameters {
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("RetrieveTPUEmbeddingADAMParameters_{}")?
        };
        let mut new_op = graph.new_operation("RetrieveTPUEmbeddingADAMParameters", &op_name)?;
        {
            match self.table_id {
                None => new_op.set_attr_value_proto("table_id", &vec![24_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 1_u8,])?,
                Some(ref value) => (|attr: &i64| {new_op.set_attr_int("table_id", *attr)})(&value)?,
            };
        }
        {
            match self.table_name {
                None => new_op.set_attr_value_proto("table_name", &vec![18_u8, 0_u8,])?,
                Some(ref value) => (|attr| {new_op.set_attr_string("table_name", attr)})(&value)?,
            };
        }
        {
            (|attr: &i64| {new_op.set_attr_int("num_shards", *attr)})(&self.num_shards)?
        }
        {
            (|attr: &i64| {new_op.set_attr_int("shard_id", *attr)})(&self.shard_id)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct RetrieveTPUEmbeddingADAMParameters {
    table_id: Option<i64>,
    table_name: Option<String>,
    num_shards: i64,
    shard_id: i64,
    op_name: Option<String>,
    id_: usize,
}

impl RetrieveTPUEmbeddingADAMParameters {
    pub fn parameters(self) -> Edge<f32> {
        let rc = Rc::new(self);
        {
            Edge::<f32>::new(rc.clone(), 0)
        }
    }

    pub fn momenta(self) -> Edge<f32> {
        let rc = Rc::new(self);
        {
            Edge::<f32>::new(rc.clone(), 1)
        }
    }

    pub fn velocities(self) -> Edge<f32> {
        let rc = Rc::new(self);
        {
            Edge::<f32>::new(rc.clone(), 2)
        }
    }

    pub fn table_id(&mut self, table_id: i64) -> Self {
        self.table_id = Some(table_id);
        self.clone()
    }

    pub fn table_name(&mut self, table_name: &str) -> Self {
        self.table_name = Some(table_name.to_string());
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> (Edge<f32>, Edge<f32>, Edge<f32>) {
        let rc = Rc::new(self);
        (
        {
            Edge::<f32>::new(rc.clone(), 0)
        },
        {
            Edge::<f32>::new(rc.clone(), 1)
        },
        {
            Edge::<f32>::new(rc.clone(), 2)
        },
        )
    }

    pub fn build(num_shards: i64, shard_id: i64) -> Self {
        Self {
            table_id: None,
            table_name: None,
            num_shards: num_shards,
            shard_id: shard_id,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(num_shards: i64, shard_id: i64) -> (Edge<f32>, Edge<f32>, Edge<f32>) {
        Self {
            table_id: None,
            table_name: None,
            num_shards: num_shards,
            shard_id: shard_id,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<T> GraphOperation for Concat<T>
where T: TensorType,
      T: Clone,
      T: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("Concat_{}")?
        };
        let mut new_op = graph.new_operation("Concat", &op_name)?;
        {
            new_op.add_edge(&self.concat_dim)?
        }
        {
            new_op.add_edge(&self.values)?
        }
        {
            (|attr: &i64| {new_op.set_attr_int("N", *attr)})(&self.N)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct Concat<T>
where T: TensorType,
      T: Clone,
      T: 'static,
{
    concat_dim: Edge<i32>,
    phantom_T: PhantomData<T>,
    values: Edge<T>,
    N: i64,
    op_name: Option<String>,
    id_: usize,
}

impl<T> Concat<T>
where T: TensorType,
      T: Clone,
      T: 'static,
{
    pub fn output(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(concat_dim: Edge<i32>, values: Edge<T>, N: i64) -> Self {
        Self {
            concat_dim,
            phantom_T: PhantomData,
            values,
            N: N,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(concat_dim: Edge<i32>, values: Edge<T>, N: i64) -> Edge<T> {
        Self {
            concat_dim,
            phantom_T: PhantomData,
            values,
            N: N,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl GraphOperation for _WaitForDistributedTPU {
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("_WaitForDistributedTPU_{}")?
        };
        let mut new_op = graph.new_operation("_WaitForDistributedTPU", &op_name)?;
        {
            new_op.add_edge(&self.inputs)?
        }
        {
            match self.startup_timeout_sec {
                None => new_op.set_attr_value_proto("startup_timeout_sec", &vec![24_u8, 20_u8,])?,
                Some(ref value) => (|attr: &i64| {new_op.set_attr_int("startup_timeout_sec", *attr)})(&value)?,
            };
        }
        {
            (|attr: &i64| {new_op.set_attr_int("N", *attr)})(&self.N)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct _WaitForDistributedTPU {
    inputs: Edge<i32>,
    startup_timeout_sec: Option<i64>,
    N: i64,
    op_name: Option<String>,
    id_: usize,
}

impl _WaitForDistributedTPU {
    pub fn topology(self) -> Edge<String> {
        let rc = Rc::new(self);
        {
            Edge::<String>::new(rc.clone(), 0)
        }
    }

    pub fn startup_timeout_sec(&mut self, startup_timeout_sec: i64) -> Self {
        self.startup_timeout_sec = Some(startup_timeout_sec);
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<String> {
        let rc = Rc::new(self);
        {
            Edge::<String>::new(rc.clone(), 0)
        }
    }

    pub fn build(inputs: Edge<i32>, N: i64) -> Self {
        Self {
            inputs,
            startup_timeout_sec: None,
            N: N,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(inputs: Edge<i32>, N: i64) -> Edge<String> {
        Self {
            inputs,
            startup_timeout_sec: None,
            N: N,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

pub trait con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_STRING_or_DT_COMPLEX64_or_DT_INT64_or_DT_COMPLEX128_or_DT_HALF {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_STRING_or_DT_COMPLEX64_or_DT_INT64_or_DT_COMPLEX128_or_DT_HALF for OtherComplex<f32> {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_STRING_or_DT_COMPLEX64_or_DT_INT64_or_DT_COMPLEX128_or_DT_HALF for OtherComplex<f64> {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_STRING_or_DT_COMPLEX64_or_DT_INT64_or_DT_COMPLEX128_or_DT_HALF for String {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_STRING_or_DT_COMPLEX64_or_DT_INT64_or_DT_COMPLEX128_or_DT_HALF for f32 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_STRING_or_DT_COMPLEX64_or_DT_INT64_or_DT_COMPLEX128_or_DT_HALF for f64 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_STRING_or_DT_COMPLEX64_or_DT_INT64_or_DT_COMPLEX128_or_DT_HALF for i16 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_STRING_or_DT_COMPLEX64_or_DT_INT64_or_DT_COMPLEX128_or_DT_HALF for i32 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_STRING_or_DT_COMPLEX64_or_DT_INT64_or_DT_COMPLEX128_or_DT_HALF for i64 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_STRING_or_DT_COMPLEX64_or_DT_INT64_or_DT_COMPLEX128_or_DT_HALF for i8 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_STRING_or_DT_COMPLEX64_or_DT_INT64_or_DT_COMPLEX128_or_DT_HALF for u8 {
}

impl<T> GraphOperation for _MklAdd<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_STRING_or_DT_COMPLEX64_or_DT_INT64_or_DT_COMPLEX128_or_DT_HALF,
      T: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("_MklAdd_{}")?
        };
        let mut new_op = graph.new_operation("_MklAdd", &op_name)?;
        {
            new_op.add_edge(&self.x)?
        }
        {
            new_op.add_edge(&self.y)?
        }
        {
            new_op.add_edge(&self.mkl_x)?
        }
        {
            new_op.add_edge(&self.mkl_y)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct _MklAdd<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_STRING_or_DT_COMPLEX64_or_DT_INT64_or_DT_COMPLEX128_or_DT_HALF,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    x: Edge<T>,
    y: Edge<T>,
    mkl_x: Edge<u8>,
    mkl_y: Edge<u8>,
    op_name: Option<String>,
    id_: usize,
}

impl<T> _MklAdd<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_STRING_or_DT_COMPLEX64_or_DT_INT64_or_DT_COMPLEX128_or_DT_HALF,
      T: 'static,
{
    pub fn z(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn mkl_z(self) -> Edge<u8> {
        let rc = Rc::new(self);
        {
            Edge::<u8>::new(rc.clone(), 1)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> (Edge<T>, Edge<u8>) {
        let rc = Rc::new(self);
        (
        {
            Edge::<T>::new(rc.clone(), 0)
        },
        {
            Edge::<u8>::new(rc.clone(), 1)
        },
        )
    }

    pub fn build(x: Edge<T>, y: Edge<T>, mkl_x: Edge<u8>, mkl_y: Edge<u8>) -> Self {
        Self {
            phantom_T: PhantomData,
            x,
            y,
            mkl_x,
            mkl_y,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(x: Edge<T>, y: Edge<T>, mkl_x: Edge<u8>, mkl_y: Edge<u8>) -> (Edge<T>, Edge<u8>) {
        Self {
            phantom_T: PhantomData,
            x,
            y,
            mkl_x,
            mkl_y,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl GraphOperation for AllCandidateSampler {
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("AllCandidateSampler_{}")?
        };
        let mut new_op = graph.new_operation("AllCandidateSampler", &op_name)?;
        {
            new_op.add_edge(&self.true_classes)?
        }
        {
            (|attr: &i64| {new_op.set_attr_int("num_true", *attr)})(&self.num_true)?
        }
        {
            (|attr: &i64| {new_op.set_attr_int("num_sampled", *attr)})(&self.num_sampled)?
        }
        {
            (|attr: &bool| {new_op.set_attr_bool("unique", *attr)})(&self.unique)?
        }
        {
            match self.seed {
                None => new_op.set_attr_value_proto("seed", &vec![24_u8, 0_u8,])?,
                Some(ref value) => (|attr: &i64| {new_op.set_attr_int("seed", *attr)})(&value)?,
            };
        }
        {
            match self.seed2 {
                None => new_op.set_attr_value_proto("seed2", &vec![24_u8, 0_u8,])?,
                Some(ref value) => (|attr: &i64| {new_op.set_attr_int("seed2", *attr)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct AllCandidateSampler {
    true_classes: Edge<i64>,
    num_true: i64,
    num_sampled: i64,
    unique: bool,
    seed: Option<i64>,
    seed2: Option<i64>,
    op_name: Option<String>,
    id_: usize,
}

impl AllCandidateSampler {
    pub fn sampled_candidates(self) -> Edge<i64> {
        let rc = Rc::new(self);
        {
            Edge::<i64>::new(rc.clone(), 0)
        }
    }

    pub fn true_expected_count(self) -> Edge<f32> {
        let rc = Rc::new(self);
        {
            Edge::<f32>::new(rc.clone(), 1)
        }
    }

    pub fn sampled_expected_count(self) -> Edge<f32> {
        let rc = Rc::new(self);
        {
            Edge::<f32>::new(rc.clone(), 2)
        }
    }

    pub fn seed(&mut self, seed: i64) -> Self {
        self.seed = Some(seed);
        self.clone()
    }

    pub fn seed2(&mut self, seed2: i64) -> Self {
        self.seed2 = Some(seed2);
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> (Edge<i64>, Edge<f32>, Edge<f32>) {
        let rc = Rc::new(self);
        (
        {
            Edge::<i64>::new(rc.clone(), 0)
        },
        {
            Edge::<f32>::new(rc.clone(), 1)
        },
        {
            Edge::<f32>::new(rc.clone(), 2)
        },
        )
    }

    pub fn build(true_classes: Edge<i64>, num_true: i64, num_sampled: i64, unique: bool) -> Self {
        Self {
            true_classes,
            num_true: num_true,
            num_sampled: num_sampled,
            unique: unique,
            seed: None,
            seed2: None,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(true_classes: Edge<i64>, num_true: i64, num_sampled: i64, unique: bool) -> (Edge<i64>, Edge<f32>, Edge<f32>) {
        Self {
            true_classes,
            num_true: num_true,
            num_sampled: num_sampled,
            unique: unique,
            seed: None,
            seed2: None,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl GraphOperation for DecodeAndCropJpeg {
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("DecodeAndCropJpeg_{}")?
        };
        let mut new_op = graph.new_operation("DecodeAndCropJpeg", &op_name)?;
        {
            new_op.add_edge(&self.contents)?
        }
        {
            new_op.add_edge(&self.crop_window)?
        }
        {
            match self.channels {
                None => new_op.set_attr_value_proto("channels", &vec![24_u8, 0_u8,])?,
                Some(ref value) => (|attr: &i64| {new_op.set_attr_int("channels", *attr)})(&value)?,
            };
        }
        {
            match self.ratio {
                None => new_op.set_attr_value_proto("ratio", &vec![24_u8, 1_u8,])?,
                Some(ref value) => (|attr: &i64| {new_op.set_attr_int("ratio", *attr)})(&value)?,
            };
        }
        {
            match self.fancy_upscaling {
                None => new_op.set_attr_value_proto("fancy_upscaling", &vec![40_u8, 1_u8,])?,
                Some(ref value) => (|attr: &bool| {new_op.set_attr_bool("fancy_upscaling", *attr)})(&value)?,
            };
        }
        {
            match self.try_recover_truncated {
                None => new_op.set_attr_value_proto("try_recover_truncated", &vec![40_u8, 0_u8,])?,
                Some(ref value) => (|attr: &bool| {new_op.set_attr_bool("try_recover_truncated", *attr)})(&value)?,
            };
        }
        {
            match self.acceptable_fraction {
                None => new_op.set_attr_value_proto("acceptable_fraction", &vec![37_u8, 0_u8, 0_u8, 128_u8, 63_u8,])?,
                Some(ref value) => (|attr: &f32| {new_op.set_attr_float("acceptable_fraction", *attr)})(&value)?,
            };
        }
        {
            match self.dct_method {
                None => new_op.set_attr_value_proto("dct_method", &vec![18_u8, 0_u8,])?,
                Some(ref value) => (|attr| {new_op.set_attr_string("dct_method", attr)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct DecodeAndCropJpeg {
    contents: Edge<String>,
    crop_window: Edge<i32>,
    channels: Option<i64>,
    ratio: Option<i64>,
    fancy_upscaling: Option<bool>,
    try_recover_truncated: Option<bool>,
    acceptable_fraction: Option<f32>,
    dct_method: Option<String>,
    op_name: Option<String>,
    id_: usize,
}

impl DecodeAndCropJpeg {
    pub fn image(self) -> Edge<u8> {
        let rc = Rc::new(self);
        {
            Edge::<u8>::new(rc.clone(), 0)
        }
    }

    pub fn channels(&mut self, channels: i64) -> Self {
        self.channels = Some(channels);
        self.clone()
    }

    pub fn ratio(&mut self, ratio: i64) -> Self {
        self.ratio = Some(ratio);
        self.clone()
    }

    pub fn fancy_upscaling(&mut self, fancy_upscaling: bool) -> Self {
        self.fancy_upscaling = Some(fancy_upscaling);
        self.clone()
    }

    pub fn try_recover_truncated(&mut self, try_recover_truncated: bool) -> Self {
        self.try_recover_truncated = Some(try_recover_truncated);
        self.clone()
    }

    pub fn acceptable_fraction(&mut self, acceptable_fraction: f32) -> Self {
        self.acceptable_fraction = Some(acceptable_fraction);
        self.clone()
    }

    pub fn dct_method(&mut self, dct_method: &str) -> Self {
        self.dct_method = Some(dct_method.to_string());
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<u8> {
        let rc = Rc::new(self);
        {
            Edge::<u8>::new(rc.clone(), 0)
        }
    }

    pub fn build(contents: Edge<String>, crop_window: Edge<i32>) -> Self {
        Self {
            contents,
            crop_window,
            channels: None,
            ratio: None,
            fancy_upscaling: None,
            try_recover_truncated: None,
            acceptable_fraction: None,
            dct_method: None,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(contents: Edge<String>, crop_window: Edge<i32>) -> Edge<u8> {
        Self {
            contents,
            crop_window,
            channels: None,
            ratio: None,
            fancy_upscaling: None,
            try_recover_truncated: None,
            acceptable_fraction: None,
            dct_method: None,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<tensor_type> GraphOperation for _Recv<tensor_type>
where tensor_type: TensorType,
      tensor_type: 'static,
      tensor_type: Clone,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("_Recv_{}")?
        };
        let mut new_op = graph.new_operation("_Recv", &op_name)?;
        {
            (|attr| {new_op.set_attr_string("tensor_name", attr)})(&self.tensor_name)?
        }
        {
            (|attr| {new_op.set_attr_string("send_device", attr)})(&self.send_device)?
        }
        {
            (|attr: &i64| {new_op.set_attr_int("send_device_incarnation", *attr)})(&self.send_device_incarnation)?
        }
        {
            (|attr| {new_op.set_attr_string("recv_device", attr)})(&self.recv_device)?
        }
        {
            match self.client_terminated {
                None => new_op.set_attr_value_proto("client_terminated", &vec![40_u8, 0_u8,])?,
                Some(ref value) => (|attr: &bool| {new_op.set_attr_bool("client_terminated", *attr)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct _Recv<tensor_type>
where tensor_type: TensorType,
      tensor_type: 'static,
      tensor_type: Clone,
{
    phantom_tensor_type: PhantomData<tensor_type>,
    tensor_name: String,
    send_device: String,
    send_device_incarnation: i64,
    recv_device: String,
    client_terminated: Option<bool>,
    op_name: Option<String>,
    id_: usize,
}

impl<tensor_type> _Recv<tensor_type>
where tensor_type: TensorType,
      tensor_type: 'static,
      tensor_type: Clone,
{
    pub fn tensor(self) -> Edge<tensor_type> {
        let rc = Rc::new(self);
        {
            Edge::<tensor_type>::new(rc.clone(), 0)
        }
    }

    pub fn client_terminated(&mut self, client_terminated: bool) -> Self {
        self.client_terminated = Some(client_terminated);
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<tensor_type> {
        let rc = Rc::new(self);
        {
            Edge::<tensor_type>::new(rc.clone(), 0)
        }
    }

    pub fn build(tensor_name: &str, send_device: &str, send_device_incarnation: i64, recv_device: &str) -> Self {
        Self {
            phantom_tensor_type: PhantomData,
            tensor_name: tensor_name.to_string(),
            send_device: send_device.to_string(),
            send_device_incarnation: send_device_incarnation,
            recv_device: recv_device.to_string(),
            client_terminated: None,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(tensor_name: &str, send_device: &str, send_device_incarnation: i64, recv_device: &str) -> Edge<tensor_type> {
        Self {
            phantom_tensor_type: PhantomData,
            tensor_name: tensor_name.to_string(),
            send_device: send_device.to_string(),
            send_device_incarnation: send_device_incarnation,
            recv_device: recv_device.to_string(),
            client_terminated: None,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl GraphOperation for SdcaFprint {
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("SdcaFprint_{}")?
        };
        let mut new_op = graph.new_operation("SdcaFprint", &op_name)?;
        {
            new_op.add_edge(&self.input)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct SdcaFprint {
    input: Edge<String>,
    op_name: Option<String>,
    id_: usize,
}

impl SdcaFprint {
    pub fn output(self) -> Edge<i64> {
        let rc = Rc::new(self);
        {
            Edge::<i64>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<i64> {
        let rc = Rc::new(self);
        {
            Edge::<i64>::new(rc.clone(), 0)
        }
    }

    pub fn build(input: Edge<String>) -> Self {
        Self {
            input,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(input: Edge<String>) -> Edge<i64> {
        Self {
            input,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl GraphOperation for ReaderReadUpTo {
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("ReaderReadUpTo_{}")?
        };
        let mut new_op = graph.new_operation("ReaderReadUpTo", &op_name)?;
        {
            new_op.add_edge(&self.reader_handle)?
        }
        {
            new_op.add_edge(&self.queue_handle)?
        }
        {
            new_op.add_edge(&self.num_records)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct ReaderReadUpTo {
    reader_handle: Edge<String>,
    queue_handle: Edge<String>,
    num_records: Edge<i64>,
    op_name: Option<String>,
    id_: usize,
}

impl ReaderReadUpTo {
    pub fn keys(self) -> Edge<String> {
        let rc = Rc::new(self);
        {
            Edge::<String>::new(rc.clone(), 0)
        }
    }

    pub fn values(self) -> Edge<String> {
        let rc = Rc::new(self);
        {
            Edge::<String>::new(rc.clone(), 1)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> (Edge<String>, Edge<String>) {
        let rc = Rc::new(self);
        (
        {
            Edge::<String>::new(rc.clone(), 0)
        },
        {
            Edge::<String>::new(rc.clone(), 1)
        },
        )
    }

    pub fn build(reader_handle: Edge<String>, queue_handle: Edge<String>, num_records: Edge<i64>) -> Self {
        Self {
            reader_handle,
            queue_handle,
            num_records,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(reader_handle: Edge<String>, queue_handle: Edge<String>, num_records: Edge<i64>) -> (Edge<String>, Edge<String>) {
        Self {
            reader_handle,
            queue_handle,
            num_records,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<T, out_type> GraphOperation for Shape<T, out_type>
where T: TensorType,
      T: Clone,
      out_type: TensorType,
      T: 'static,
      out_type: con_or_DT_INT32_or_DT_INT64,
      out_type: 'static,
      out_type: Clone,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("Shape_{}")?
        };
        let mut new_op = graph.new_operation("Shape", &op_name)?;
        {
            new_op.add_edge(&self.input)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct Shape<T, out_type>
where T: TensorType,
      T: Clone,
      out_type: TensorType,
      T: 'static,
      out_type: con_or_DT_INT32_or_DT_INT64,
      out_type: 'static,
      out_type: Clone,
{
    phantom_T: PhantomData<T>,
    input: Edge<T>,
    phantom_out_type: PhantomData<out_type>,
    op_name: Option<String>,
    id_: usize,
}

impl<T, out_type> Shape<T, out_type>
where T: TensorType,
      T: Clone,
      out_type: TensorType,
      T: 'static,
      out_type: con_or_DT_INT32_or_DT_INT64,
      out_type: 'static,
      out_type: Clone,
{
    pub fn output(self) -> Edge<out_type> {
        let rc = Rc::new(self);
        {
            Edge::<out_type>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<out_type> {
        let rc = Rc::new(self);
        {
            Edge::<out_type>::new(rc.clone(), 0)
        }
    }

    pub fn build(input: Edge<T>) -> Self {
        Self {
            phantom_T: PhantomData,
            input,
            phantom_out_type: PhantomData,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(input: Edge<T>) -> Edge<out_type> {
        Self {
            phantom_T: PhantomData,
            input,
            phantom_out_type: PhantomData,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<T> GraphOperation for Pow<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_COMPLEX64_or_DT_INT64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF,
      T: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("Pow_{}")?
        };
        let mut new_op = graph.new_operation("Pow", &op_name)?;
        {
            new_op.add_edge(&self.x)?
        }
        {
            new_op.add_edge(&self.y)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct Pow<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_COMPLEX64_or_DT_INT64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    x: Edge<T>,
    y: Edge<T>,
    op_name: Option<String>,
    id_: usize,
}

impl<T> Pow<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_COMPLEX64_or_DT_INT64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF,
      T: 'static,
{
    pub fn z(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(x: Edge<T>, y: Edge<T>) -> Self {
        Self {
            phantom_T: PhantomData,
            x,
            y,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(x: Edge<T>, y: Edge<T>) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            x,
            y,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<T> GraphOperation for QuantizeV2<T>
where T: TensorType,
      T: con_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_QINT16_or_DT_QUINT16,
      T: 'static,
      T: Clone,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("QuantizeV2_{}")?
        };
        let mut new_op = graph.new_operation("QuantizeV2", &op_name)?;
        {
            new_op.add_edge(&self.input)?
        }
        {
            new_op.add_edge(&self.min_range)?
        }
        {
            new_op.add_edge(&self.max_range)?
        }
        {
            match self.mode {
                None => new_op.set_attr_value_proto("mode", &vec![18_u8, 12_u8, 77_u8, 73_u8, 78_u8, 95_u8, 67_u8, 79_u8, 77_u8, 66_u8, 73_u8, 78_u8, 69_u8, 68_u8,])?,
                Some(ref value) => (|attr| {new_op.set_attr_string("mode", attr)})(&value)?,
            };
        }
        {
            match self.round_mode {
                None => new_op.set_attr_value_proto("round_mode", &vec![18_u8, 19_u8, 72_u8, 65_u8, 76_u8, 70_u8, 95_u8, 65_u8, 87_u8, 65_u8, 89_u8, 95_u8, 70_u8, 82_u8, 79_u8, 77_u8, 95_u8, 90_u8, 69_u8, 82_u8, 79_u8,])?,
                Some(ref value) => (|attr| {new_op.set_attr_string("round_mode", attr)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct QuantizeV2<T>
where T: TensorType,
      T: con_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_QINT16_or_DT_QUINT16,
      T: 'static,
      T: Clone,
{
    input: Edge<f32>,
    min_range: Edge<f32>,
    max_range: Edge<f32>,
    phantom_T: PhantomData<T>,
    mode: Option<String>,
    round_mode: Option<String>,
    op_name: Option<String>,
    id_: usize,
}

impl<T> QuantizeV2<T>
where T: TensorType,
      T: con_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_QINT16_or_DT_QUINT16,
      T: 'static,
      T: Clone,
{
    pub fn output(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn output_min(self) -> Edge<f32> {
        let rc = Rc::new(self);
        {
            Edge::<f32>::new(rc.clone(), 1)
        }
    }

    pub fn output_max(self) -> Edge<f32> {
        let rc = Rc::new(self);
        {
            Edge::<f32>::new(rc.clone(), 2)
        }
    }

    pub fn mode(&mut self, mode: &str) -> Self {
        self.mode = Some(mode.to_string());
        self.clone()
    }

    pub fn round_mode(&mut self, round_mode: &str) -> Self {
        self.round_mode = Some(round_mode.to_string());
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> (Edge<T>, Edge<f32>, Edge<f32>) {
        let rc = Rc::new(self);
        (
        {
            Edge::<T>::new(rc.clone(), 0)
        },
        {
            Edge::<f32>::new(rc.clone(), 1)
        },
        {
            Edge::<f32>::new(rc.clone(), 2)
        },
        )
    }

    pub fn build(input: Edge<f32>, min_range: Edge<f32>, max_range: Edge<f32>) -> Self {
        Self {
            input,
            min_range,
            max_range,
            phantom_T: PhantomData,
            mode: None,
            round_mode: None,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(input: Edge<f32>, min_range: Edge<f32>, max_range: Edge<f32>) -> (Edge<T>, Edge<f32>, Edge<f32>) {
        Self {
            input,
            min_range,
            max_range,
            phantom_T: PhantomData,
            mode: None,
            round_mode: None,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<T> GraphOperation for Split<T>
where T: TensorType,
      T: Clone,
      T: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("Split_{}")?
        };
        let mut new_op = graph.new_operation("Split", &op_name)?;
        {
            new_op.add_edge(&self.split_dim)?
        }
        {
            new_op.add_edge(&self.value)?
        }
        {
            (|attr: &i64| {new_op.set_attr_int("num_split", *attr)})(&self.num_split)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct Split<T>
where T: TensorType,
      T: Clone,
      T: 'static,
{
    split_dim: Edge<i32>,
    phantom_T: PhantomData<T>,
    value: Edge<T>,
    num_split: i64,
    op_name: Option<String>,
    id_: usize,
}

impl<T> Split<T>
where T: TensorType,
      T: Clone,
      T: 'static,
{
    pub fn output(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(split_dim: Edge<i32>, value: Edge<T>, num_split: i64) -> Self {
        Self {
            split_dim,
            phantom_T: PhantomData,
            value,
            num_split: num_split,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(split_dim: Edge<i32>, value: Edge<T>, num_split: i64) -> Edge<T> {
        Self {
            split_dim,
            phantom_T: PhantomData,
            value,
            num_split: num_split,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<T, Tout> GraphOperation for Complex<T, Tout>
where T: TensorType,
      T: Clone,
      Tout: TensorType,
      T: con_or_DT_FLOAT_or_DT_DOUBLE,
      T: 'static,
      Tout: con_or_DT_COMPLEX64_or_DT_COMPLEX128,
      Tout: 'static,
      Tout: Clone,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("Complex_{}")?
        };
        let mut new_op = graph.new_operation("Complex", &op_name)?;
        {
            new_op.add_edge(&self.real)?
        }
        {
            new_op.add_edge(&self.imag)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct Complex<T, Tout>
where T: TensorType,
      T: Clone,
      Tout: TensorType,
      T: con_or_DT_FLOAT_or_DT_DOUBLE,
      T: 'static,
      Tout: con_or_DT_COMPLEX64_or_DT_COMPLEX128,
      Tout: 'static,
      Tout: Clone,
{
    phantom_T: PhantomData<T>,
    real: Edge<T>,
    imag: Edge<T>,
    phantom_Tout: PhantomData<Tout>,
    op_name: Option<String>,
    id_: usize,
}

impl<T, Tout> Complex<T, Tout>
where T: TensorType,
      T: Clone,
      Tout: TensorType,
      T: con_or_DT_FLOAT_or_DT_DOUBLE,
      T: 'static,
      Tout: con_or_DT_COMPLEX64_or_DT_COMPLEX128,
      Tout: 'static,
      Tout: Clone,
{
    pub fn out(self) -> Edge<Tout> {
        let rc = Rc::new(self);
        {
            Edge::<Tout>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<Tout> {
        let rc = Rc::new(self);
        {
            Edge::<Tout>::new(rc.clone(), 0)
        }
    }

    pub fn build(real: Edge<T>, imag: Edge<T>) -> Self {
        Self {
            phantom_T: PhantomData,
            real,
            imag,
            phantom_Tout: PhantomData,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(real: Edge<T>, imag: Edge<T>) -> Edge<Tout> {
        Self {
            phantom_T: PhantomData,
            real,
            imag,
            phantom_Tout: PhantomData,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<T, Tout> GraphOperation for Imag<T, Tout>
where T: TensorType,
      T: Clone,
      Tout: TensorType,
      T: con_or_DT_COMPLEX64_or_DT_COMPLEX128,
      T: 'static,
      Tout: con_or_DT_FLOAT_or_DT_DOUBLE,
      Tout: 'static,
      Tout: Clone,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("Imag_{}")?
        };
        let mut new_op = graph.new_operation("Imag", &op_name)?;
        {
            new_op.add_edge(&self.input)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct Imag<T, Tout>
where T: TensorType,
      T: Clone,
      Tout: TensorType,
      T: con_or_DT_COMPLEX64_or_DT_COMPLEX128,
      T: 'static,
      Tout: con_or_DT_FLOAT_or_DT_DOUBLE,
      Tout: 'static,
      Tout: Clone,
{
    phantom_T: PhantomData<T>,
    input: Edge<T>,
    phantom_Tout: PhantomData<Tout>,
    op_name: Option<String>,
    id_: usize,
}

impl<T, Tout> Imag<T, Tout>
where T: TensorType,
      T: Clone,
      Tout: TensorType,
      T: con_or_DT_COMPLEX64_or_DT_COMPLEX128,
      T: 'static,
      Tout: con_or_DT_FLOAT_or_DT_DOUBLE,
      Tout: 'static,
      Tout: Clone,
{
    pub fn output(self) -> Edge<Tout> {
        let rc = Rc::new(self);
        {
            Edge::<Tout>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<Tout> {
        let rc = Rc::new(self);
        {
            Edge::<Tout>::new(rc.clone(), 0)
        }
    }

    pub fn build(input: Edge<T>) -> Self {
        Self {
            phantom_T: PhantomData,
            input,
            phantom_Tout: PhantomData,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(input: Edge<T>) -> Edge<Tout> {
        Self {
            phantom_T: PhantomData,
            input,
            phantom_Tout: PhantomData,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<T, Tidx, Tnumsegments> GraphOperation for SparseSegmentSumWithNumSegments<T, Tidx, Tnumsegments>
where T: TensorType,
      T: Clone,
      Tidx: TensorType,
      Tidx: Clone,
      Tnumsegments: TensorType,
      Tnumsegments: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
      Tidx: con_or_DT_INT32_or_DT_INT64,
      Tidx: 'static,
      Tnumsegments: con_or_DT_INT32_or_DT_INT64,
      Tnumsegments: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("SparseSegmentSumWithNumSegments_{}")?
        };
        let mut new_op = graph.new_operation("SparseSegmentSumWithNumSegments", &op_name)?;
        {
            new_op.add_edge(&self.data)?
        }
        {
            new_op.add_edge(&self.indices)?
        }
        {
            new_op.add_edge(&self.segment_ids)?
        }
        {
            new_op.add_edge(&self.num_segments)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct SparseSegmentSumWithNumSegments<T, Tidx, Tnumsegments>
where T: TensorType,
      T: Clone,
      Tidx: TensorType,
      Tidx: Clone,
      Tnumsegments: TensorType,
      Tnumsegments: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
      Tidx: con_or_DT_INT32_or_DT_INT64,
      Tidx: 'static,
      Tnumsegments: con_or_DT_INT32_or_DT_INT64,
      Tnumsegments: 'static,
{
    phantom_T: PhantomData<T>,
    data: Edge<T>,
    phantom_Tidx: PhantomData<Tidx>,
    indices: Edge<Tidx>,
    segment_ids: Edge<i32>,
    phantom_Tnumsegments: PhantomData<Tnumsegments>,
    num_segments: Edge<Tnumsegments>,
    op_name: Option<String>,
    id_: usize,
}

impl<T, Tidx, Tnumsegments> SparseSegmentSumWithNumSegments<T, Tidx, Tnumsegments>
where T: TensorType,
      T: Clone,
      Tidx: TensorType,
      Tidx: Clone,
      Tnumsegments: TensorType,
      Tnumsegments: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
      Tidx: con_or_DT_INT32_or_DT_INT64,
      Tidx: 'static,
      Tnumsegments: con_or_DT_INT32_or_DT_INT64,
      Tnumsegments: 'static,
{
    pub fn output(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(data: Edge<T>, indices: Edge<Tidx>, segment_ids: Edge<i32>, num_segments: Edge<Tnumsegments>) -> Self {
        Self {
            phantom_T: PhantomData,
            data,
            phantom_Tidx: PhantomData,
            indices,
            segment_ids,
            phantom_Tnumsegments: PhantomData,
            num_segments,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(data: Edge<T>, indices: Edge<Tidx>, segment_ids: Edge<i32>, num_segments: Edge<Tnumsegments>) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            data,
            phantom_Tidx: PhantomData,
            indices,
            segment_ids,
            phantom_Tnumsegments: PhantomData,
            num_segments,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<T> GraphOperation for Merge<T>
where T: TensorType,
      T: Clone,
      T: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("Merge_{}")?
        };
        let mut new_op = graph.new_operation("Merge", &op_name)?;
        {
            new_op.add_edge(&self.inputs)?
        }
        {
            (|attr: &i64| {new_op.set_attr_int("N", *attr)})(&self.N)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct Merge<T>
where T: TensorType,
      T: Clone,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    inputs: Edge<T>,
    N: i64,
    op_name: Option<String>,
    id_: usize,
}

impl<T> Merge<T>
where T: TensorType,
      T: Clone,
      T: 'static,
{
    pub fn output(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn value_index(self) -> Edge<i32> {
        let rc = Rc::new(self);
        {
            Edge::<i32>::new(rc.clone(), 1)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> (Edge<T>, Edge<i32>) {
        let rc = Rc::new(self);
        (
        {
            Edge::<T>::new(rc.clone(), 0)
        },
        {
            Edge::<i32>::new(rc.clone(), 1)
        },
        )
    }

    pub fn build(inputs: Edge<T>, N: i64) -> Self {
        Self {
            phantom_T: PhantomData,
            inputs,
            N: N,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(inputs: Edge<T>, N: i64) -> (Edge<T>, Edge<i32>) {
        Self {
            phantom_T: PhantomData,
            inputs,
            N: N,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<index_type, T> GraphOperation for Fill<index_type, T>
where index_type: TensorType,
      index_type: Clone,
      T: TensorType,
      T: Clone,
      T: 'static,
      index_type: con_or_DT_INT32_or_DT_INT64,
      index_type: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("Fill_{}")?
        };
        let mut new_op = graph.new_operation("Fill", &op_name)?;
        {
            new_op.add_edge(&self.dims)?
        }
        {
            new_op.add_edge(&self.value)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct Fill<index_type, T>
where index_type: TensorType,
      index_type: Clone,
      T: TensorType,
      T: Clone,
      T: 'static,
      index_type: con_or_DT_INT32_or_DT_INT64,
      index_type: 'static,
{
    phantom_index_type: PhantomData<index_type>,
    dims: Edge<index_type>,
    phantom_T: PhantomData<T>,
    value: Edge<T>,
    op_name: Option<String>,
    id_: usize,
}

impl<index_type, T> Fill<index_type, T>
where index_type: TensorType,
      index_type: Clone,
      T: TensorType,
      T: Clone,
      T: 'static,
      index_type: con_or_DT_INT32_or_DT_INT64,
      index_type: 'static,
{
    pub fn output(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(dims: Edge<index_type>, value: Edge<T>) -> Self {
        Self {
            phantom_index_type: PhantomData,
            dims,
            phantom_T: PhantomData,
            value,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(dims: Edge<index_type>, value: Edge<T>) -> Edge<T> {
        Self {
            phantom_index_type: PhantomData,
            dims,
            phantom_T: PhantomData,
            value,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<T, Tindices> GraphOperation for TensorScatterSub<T, Tindices>
where T: TensorType,
      T: Clone,
      Tindices: TensorType,
      Tindices: Clone,
      T: 'static,
      Tindices: con_or_DT_INT32_or_DT_INT64,
      Tindices: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("TensorScatterSub_{}")?
        };
        let mut new_op = graph.new_operation("TensorScatterSub", &op_name)?;
        {
            new_op.add_edge(&self.tensor)?
        }
        {
            new_op.add_edge(&self.indices)?
        }
        {
            new_op.add_edge(&self.updates)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct TensorScatterSub<T, Tindices>
where T: TensorType,
      T: Clone,
      Tindices: TensorType,
      Tindices: Clone,
      T: 'static,
      Tindices: con_or_DT_INT32_or_DT_INT64,
      Tindices: 'static,
{
    phantom_T: PhantomData<T>,
    tensor: Edge<T>,
    phantom_Tindices: PhantomData<Tindices>,
    indices: Edge<Tindices>,
    updates: Edge<T>,
    op_name: Option<String>,
    id_: usize,
}

impl<T, Tindices> TensorScatterSub<T, Tindices>
where T: TensorType,
      T: Clone,
      Tindices: TensorType,
      Tindices: Clone,
      T: 'static,
      Tindices: con_or_DT_INT32_or_DT_INT64,
      Tindices: 'static,
{
    pub fn output(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(tensor: Edge<T>, indices: Edge<Tindices>, updates: Edge<T>) -> Self {
        Self {
            phantom_T: PhantomData,
            tensor,
            phantom_Tindices: PhantomData,
            indices,
            updates,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(tensor: Edge<T>, indices: Edge<Tindices>, updates: Edge<T>) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            tensor,
            phantom_Tindices: PhantomData,
            indices,
            updates,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<T> GraphOperation for MatrixDiag<T>
where T: TensorType,
      T: Clone,
      T: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("MatrixDiag_{}")?
        };
        let mut new_op = graph.new_operation("MatrixDiag", &op_name)?;
        {
            new_op.add_edge(&self.diagonal)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct MatrixDiag<T>
where T: TensorType,
      T: Clone,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    diagonal: Edge<T>,
    op_name: Option<String>,
    id_: usize,
}

impl<T> MatrixDiag<T>
where T: TensorType,
      T: Clone,
      T: 'static,
{
    pub fn output(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(diagonal: Edge<T>) -> Self {
        Self {
            phantom_T: PhantomData,
            diagonal,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(diagonal: Edge<T>) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            diagonal,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<T> GraphOperation for FloorDiv<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF,
      T: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("FloorDiv_{}")?
        };
        let mut new_op = graph.new_operation("FloorDiv", &op_name)?;
        {
            new_op.add_edge(&self.x)?
        }
        {
            new_op.add_edge(&self.y)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct FloorDiv<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    x: Edge<T>,
    y: Edge<T>,
    op_name: Option<String>,
    id_: usize,
}

impl<T> FloorDiv<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF,
      T: 'static,
{
    pub fn z(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(x: Edge<T>, y: Edge<T>) -> Self {
        Self {
            phantom_T: PhantomData,
            x,
            y,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(x: Edge<T>, y: Edge<T>) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            x,
            y,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<T> GraphOperation for XlaReduce<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("XlaReduce_{}")?
        };
        let mut new_op = graph.new_operation("XlaReduce", &op_name)?;
        {
            new_op.add_edge(&self.input)?
        }
        {
            new_op.add_edge(&self.init_value)?
        }
        {
            (|attrs| {new_op.set_attr_int_list("dimensions_to_reduce", attrs)})(&self.dimensions_to_reduce)?
        }
        {
            (|attr| {new_op.set_attr_func_name("reducer", attr)})(&self.reducer)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct XlaReduce<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    input: Edge<T>,
    init_value: Edge<T>,
    dimensions_to_reduce: Vec<i64>,
    reducer: String,
    op_name: Option<String>,
    id_: usize,
}

impl<T> XlaReduce<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
{
    pub fn output(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(input: Edge<T>, init_value: Edge<T>, dimensions_to_reduce: &[i64], reducer: &str) -> Self {
        Self {
            phantom_T: PhantomData,
            input,
            init_value,
            dimensions_to_reduce: dimensions_to_reduce.to_vec(),
            reducer: reducer.to_string(),
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(input: Edge<T>, init_value: Edge<T>, dimensions_to_reduce: &[i64], reducer: &str) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            input,
            init_value,
            dimensions_to_reduce: dimensions_to_reduce.to_vec(),
            reducer: reducer.to_string(),
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<Tparams, Tindices> GraphOperation for Gather<Tparams, Tindices>
where Tparams: TensorType,
      Tparams: Clone,
      Tindices: TensorType,
      Tindices: Clone,
      Tparams: 'static,
      Tindices: con_or_DT_INT32_or_DT_INT64,
      Tindices: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("Gather_{}")?
        };
        let mut new_op = graph.new_operation("Gather", &op_name)?;
        {
            new_op.add_edge(&self.params)?
        }
        {
            new_op.add_edge(&self.indices)?
        }
        {
            match self.validate_indices {
                None => new_op.set_attr_value_proto("validate_indices", &vec![40_u8, 1_u8,])?,
                Some(ref value) => (|attr: &bool| {new_op.set_attr_bool("validate_indices", *attr)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct Gather<Tparams, Tindices>
where Tparams: TensorType,
      Tparams: Clone,
      Tindices: TensorType,
      Tindices: Clone,
      Tparams: 'static,
      Tindices: con_or_DT_INT32_or_DT_INT64,
      Tindices: 'static,
{
    phantom_Tparams: PhantomData<Tparams>,
    params: Edge<Tparams>,
    phantom_Tindices: PhantomData<Tindices>,
    indices: Edge<Tindices>,
    validate_indices: Option<bool>,
    op_name: Option<String>,
    id_: usize,
}

impl<Tparams, Tindices> Gather<Tparams, Tindices>
where Tparams: TensorType,
      Tparams: Clone,
      Tindices: TensorType,
      Tindices: Clone,
      Tparams: 'static,
      Tindices: con_or_DT_INT32_or_DT_INT64,
      Tindices: 'static,
{
    pub fn output(self) -> Edge<Tparams> {
        let rc = Rc::new(self);
        {
            Edge::<Tparams>::new(rc.clone(), 0)
        }
    }

    pub fn validate_indices(&mut self, validate_indices: bool) -> Self {
        self.validate_indices = Some(validate_indices);
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<Tparams> {
        let rc = Rc::new(self);
        {
            Edge::<Tparams>::new(rc.clone(), 0)
        }
    }

    pub fn build(params: Edge<Tparams>, indices: Edge<Tindices>) -> Self {
        Self {
            phantom_Tparams: PhantomData,
            params,
            phantom_Tindices: PhantomData,
            indices,
            validate_indices: None,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(params: Edge<Tparams>, indices: Edge<Tindices>) -> Edge<Tparams> {
        Self {
            phantom_Tparams: PhantomData,
            params,
            phantom_Tindices: PhantomData,
            indices,
            validate_indices: None,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<Tparams, Tindices, Taxis> GraphOperation for GatherV2<Tparams, Tindices, Taxis>
where Tparams: TensorType,
      Tparams: Clone,
      Tindices: TensorType,
      Tindices: Clone,
      Taxis: TensorType,
      Taxis: Clone,
      Tparams: 'static,
      Tindices: con_or_DT_INT32_or_DT_INT64,
      Tindices: 'static,
      Taxis: con_or_DT_INT32_or_DT_INT64,
      Taxis: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("GatherV2_{}")?
        };
        let mut new_op = graph.new_operation("GatherV2", &op_name)?;
        {
            new_op.add_edge(&self.params)?
        }
        {
            new_op.add_edge(&self.indices)?
        }
        {
            new_op.add_edge(&self.axis)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct GatherV2<Tparams, Tindices, Taxis>
where Tparams: TensorType,
      Tparams: Clone,
      Tindices: TensorType,
      Tindices: Clone,
      Taxis: TensorType,
      Taxis: Clone,
      Tparams: 'static,
      Tindices: con_or_DT_INT32_or_DT_INT64,
      Tindices: 'static,
      Taxis: con_or_DT_INT32_or_DT_INT64,
      Taxis: 'static,
{
    phantom_Tparams: PhantomData<Tparams>,
    params: Edge<Tparams>,
    phantom_Tindices: PhantomData<Tindices>,
    indices: Edge<Tindices>,
    phantom_Taxis: PhantomData<Taxis>,
    axis: Edge<Taxis>,
    op_name: Option<String>,
    id_: usize,
}

impl<Tparams, Tindices, Taxis> GatherV2<Tparams, Tindices, Taxis>
where Tparams: TensorType,
      Tparams: Clone,
      Tindices: TensorType,
      Tindices: Clone,
      Taxis: TensorType,
      Taxis: Clone,
      Tparams: 'static,
      Tindices: con_or_DT_INT32_or_DT_INT64,
      Tindices: 'static,
      Taxis: con_or_DT_INT32_or_DT_INT64,
      Taxis: 'static,
{
    pub fn output(self) -> Edge<Tparams> {
        let rc = Rc::new(self);
        {
            Edge::<Tparams>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<Tparams> {
        let rc = Rc::new(self);
        {
            Edge::<Tparams>::new(rc.clone(), 0)
        }
    }

    pub fn build(params: Edge<Tparams>, indices: Edge<Tindices>, axis: Edge<Taxis>) -> Self {
        Self {
            phantom_Tparams: PhantomData,
            params,
            phantom_Tindices: PhantomData,
            indices,
            phantom_Taxis: PhantomData,
            axis,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(params: Edge<Tparams>, indices: Edge<Tindices>, axis: Edge<Taxis>) -> Edge<Tparams> {
        Self {
            phantom_Tparams: PhantomData,
            params,
            phantom_Tindices: PhantomData,
            indices,
            phantom_Taxis: PhantomData,
            axis,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl GraphOperation for UnicodeEncode {
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("UnicodeEncode_{}")?
        };
        let mut new_op = graph.new_operation("UnicodeEncode", &op_name)?;
        {
            new_op.add_edge(&self.input_values)?
        }
        {
            new_op.add_edge(&self.input_splits)?
        }
        {
            match self.errors {
                None => new_op.set_attr_value_proto("errors", &vec![18_u8, 7_u8, 114_u8, 101_u8, 112_u8, 108_u8, 97_u8, 99_u8, 101_u8,])?,
                Some(ref value) => (|attr| {new_op.set_attr_string("errors", attr)})(&value)?,
            };
        }
        {
            (|attr| {new_op.set_attr_string("output_encoding", attr)})(&self.output_encoding)?
        }
        {
            match self.replacement_char {
                None => new_op.set_attr_value_proto("replacement_char", &vec![24_u8, 253_u8, 255_u8, 3_u8,])?,
                Some(ref value) => (|attr: &i64| {new_op.set_attr_int("replacement_char", *attr)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct UnicodeEncode {
    input_values: Edge<i32>,
    input_splits: Edge<i64>,
    errors: Option<String>,
    output_encoding: String,
    replacement_char: Option<i64>,
    op_name: Option<String>,
    id_: usize,
}

impl UnicodeEncode {
    pub fn output(self) -> Edge<String> {
        let rc = Rc::new(self);
        {
            Edge::<String>::new(rc.clone(), 0)
        }
    }

    pub fn errors(&mut self, errors: &str) -> Self {
        self.errors = Some(errors.to_string());
        self.clone()
    }

    pub fn replacement_char(&mut self, replacement_char: i64) -> Self {
        self.replacement_char = Some(replacement_char);
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<String> {
        let rc = Rc::new(self);
        {
            Edge::<String>::new(rc.clone(), 0)
        }
    }

    pub fn build(input_values: Edge<i32>, input_splits: Edge<i64>, output_encoding: &str) -> Self {
        Self {
            input_values,
            input_splits,
            errors: None,
            output_encoding: output_encoding.to_string(),
            replacement_char: None,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(input_values: Edge<i32>, input_splits: Edge<i64>, output_encoding: &str) -> Edge<String> {
        Self {
            input_values,
            input_splits,
            errors: None,
            output_encoding: output_encoding.to_string(),
            replacement_char: None,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<T> GraphOperation for Erfc<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
      T: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("Erfc_{}")?
        };
        let mut new_op = graph.new_operation("Erfc", &op_name)?;
        {
            new_op.add_edge(&self.x)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct Erfc<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    x: Edge<T>,
    op_name: Option<String>,
    id_: usize,
}

impl<T> Erfc<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
      T: 'static,
{
    pub fn y(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(x: Edge<T>) -> Self {
        Self {
            phantom_T: PhantomData,
            x,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(x: Edge<T>) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            x,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<T> GraphOperation for DiagPart<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_COMPLEX64_or_DT_INT64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF,
      T: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("DiagPart_{}")?
        };
        let mut new_op = graph.new_operation("DiagPart", &op_name)?;
        {
            new_op.add_edge(&self.input)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct DiagPart<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_COMPLEX64_or_DT_INT64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    input: Edge<T>,
    op_name: Option<String>,
    id_: usize,
}

impl<T> DiagPart<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_COMPLEX64_or_DT_INT64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF,
      T: 'static,
{
    pub fn diagonal(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(input: Edge<T>) -> Self {
        Self {
            phantom_T: PhantomData,
            input,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(input: Edge<T>) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            input,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<T> GraphOperation for QuantizedInstanceNorm<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_QINT16_or_DT_QUINT16,
      T: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("QuantizedInstanceNorm_{}")?
        };
        let mut new_op = graph.new_operation("QuantizedInstanceNorm", &op_name)?;
        {
            new_op.add_edge(&self.x)?
        }
        {
            new_op.add_edge(&self.x_min)?
        }
        {
            new_op.add_edge(&self.x_max)?
        }
        {
            match self.output_range_given {
                None => new_op.set_attr_value_proto("output_range_given", &vec![40_u8, 0_u8,])?,
                Some(ref value) => (|attr: &bool| {new_op.set_attr_bool("output_range_given", *attr)})(&value)?,
            };
        }
        {
            match self.given_y_min {
                None => new_op.set_attr_value_proto("given_y_min", &vec![37_u8, 0_u8, 0_u8, 0_u8, 0_u8,])?,
                Some(ref value) => (|attr: &f32| {new_op.set_attr_float("given_y_min", *attr)})(&value)?,
            };
        }
        {
            match self.given_y_max {
                None => new_op.set_attr_value_proto("given_y_max", &vec![37_u8, 0_u8, 0_u8, 0_u8, 0_u8,])?,
                Some(ref value) => (|attr: &f32| {new_op.set_attr_float("given_y_max", *attr)})(&value)?,
            };
        }
        {
            match self.variance_epsilon {
                None => new_op.set_attr_value_proto("variance_epsilon", &vec![37_u8, 172_u8, 197_u8, 39_u8, 55_u8,])?,
                Some(ref value) => (|attr: &f32| {new_op.set_attr_float("variance_epsilon", *attr)})(&value)?,
            };
        }
        {
            match self.min_separation {
                None => new_op.set_attr_value_proto("min_separation", &vec![37_u8, 111_u8, 18_u8, 131_u8, 58_u8,])?,
                Some(ref value) => (|attr: &f32| {new_op.set_attr_float("min_separation", *attr)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct QuantizedInstanceNorm<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_QINT16_or_DT_QUINT16,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    x: Edge<T>,
    x_min: Edge<f32>,
    x_max: Edge<f32>,
    output_range_given: Option<bool>,
    given_y_min: Option<f32>,
    given_y_max: Option<f32>,
    variance_epsilon: Option<f32>,
    min_separation: Option<f32>,
    op_name: Option<String>,
    id_: usize,
}

impl<T> QuantizedInstanceNorm<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_QINT16_or_DT_QUINT16,
      T: 'static,
{
    pub fn y(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn y_min(self) -> Edge<f32> {
        let rc = Rc::new(self);
        {
            Edge::<f32>::new(rc.clone(), 1)
        }
    }

    pub fn y_max(self) -> Edge<f32> {
        let rc = Rc::new(self);
        {
            Edge::<f32>::new(rc.clone(), 2)
        }
    }

    pub fn output_range_given(&mut self, output_range_given: bool) -> Self {
        self.output_range_given = Some(output_range_given);
        self.clone()
    }

    pub fn given_y_min(&mut self, given_y_min: f32) -> Self {
        self.given_y_min = Some(given_y_min);
        self.clone()
    }

    pub fn given_y_max(&mut self, given_y_max: f32) -> Self {
        self.given_y_max = Some(given_y_max);
        self.clone()
    }

    pub fn variance_epsilon(&mut self, variance_epsilon: f32) -> Self {
        self.variance_epsilon = Some(variance_epsilon);
        self.clone()
    }

    pub fn min_separation(&mut self, min_separation: f32) -> Self {
        self.min_separation = Some(min_separation);
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> (Edge<T>, Edge<f32>, Edge<f32>) {
        let rc = Rc::new(self);
        (
        {
            Edge::<T>::new(rc.clone(), 0)
        },
        {
            Edge::<f32>::new(rc.clone(), 1)
        },
        {
            Edge::<f32>::new(rc.clone(), 2)
        },
        )
    }

    pub fn build(x: Edge<T>, x_min: Edge<f32>, x_max: Edge<f32>) -> Self {
        Self {
            phantom_T: PhantomData,
            x,
            x_min,
            x_max,
            output_range_given: None,
            given_y_min: None,
            given_y_max: None,
            variance_epsilon: None,
            min_separation: None,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(x: Edge<T>, x_min: Edge<f32>, x_max: Edge<f32>) -> (Edge<T>, Edge<f32>, Edge<f32>) {
        Self {
            phantom_T: PhantomData,
            x,
            x_min,
            x_max,
            output_range_given: None,
            given_y_min: None,
            given_y_max: None,
            variance_epsilon: None,
            min_separation: None,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<T> GraphOperation for RefIdentity<T>
where T: TensorType,
      T: Clone,
      T: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("RefIdentity_{}")?
        };
        let mut new_op = graph.new_operation("RefIdentity", &op_name)?;
        {
            new_op.add_edge(&self.input)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct RefIdentity<T>
where T: TensorType,
      T: Clone,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    input: Edge<T>,
    op_name: Option<String>,
    id_: usize,
}

impl<T> RefIdentity<T>
where T: TensorType,
      T: Clone,
      T: 'static,
{
    pub fn output(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(input: Edge<T>) -> Self {
        Self {
            phantom_T: PhantomData,
            input,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(input: Edge<T>) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            input,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<T> GraphOperation for StopGradient<T>
where T: TensorType,
      T: Clone,
      T: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("StopGradient_{}")?
        };
        let mut new_op = graph.new_operation("StopGradient", &op_name)?;
        {
            new_op.add_edge(&self.input)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct StopGradient<T>
where T: TensorType,
      T: Clone,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    input: Edge<T>,
    op_name: Option<String>,
    id_: usize,
}

impl<T> StopGradient<T>
where T: TensorType,
      T: Clone,
      T: 'static,
{
    pub fn output(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(input: Edge<T>) -> Self {
        Self {
            phantom_T: PhantomData,
            input,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(input: Edge<T>) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            input,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<T> GraphOperation for Asin<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_COMPLEX64_or_DT_INT64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF,
      T: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("Asin_{}")?
        };
        let mut new_op = graph.new_operation("Asin", &op_name)?;
        {
            new_op.add_edge(&self.x)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct Asin<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_COMPLEX64_or_DT_INT64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    x: Edge<T>,
    op_name: Option<String>,
    id_: usize,
}

impl<T> Asin<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_COMPLEX64_or_DT_INT64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF,
      T: 'static,
{
    pub fn y(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(x: Edge<T>) -> Self {
        Self {
            phantom_T: PhantomData,
            x,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(x: Edge<T>) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            x,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<T> GraphOperation for PreventGradient<T>
where T: TensorType,
      T: Clone,
      T: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("PreventGradient_{}")?
        };
        let mut new_op = graph.new_operation("PreventGradient", &op_name)?;
        {
            new_op.add_edge(&self.input)?
        }
        {
            match self.message {
                None => new_op.set_attr_value_proto("message", &vec![18_u8, 0_u8,])?,
                Some(ref value) => (|attr| {new_op.set_attr_string("message", attr)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct PreventGradient<T>
where T: TensorType,
      T: Clone,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    input: Edge<T>,
    message: Option<String>,
    op_name: Option<String>,
    id_: usize,
}

impl<T> PreventGradient<T>
where T: TensorType,
      T: Clone,
      T: 'static,
{
    pub fn output(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn message(&mut self, message: &str) -> Self {
        self.message = Some(message.to_string());
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(input: Edge<T>) -> Self {
        Self {
            phantom_T: PhantomData,
            input,
            message: None,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(input: Edge<T>) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            input,
            message: None,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<T, Tidx> GraphOperation for ConcatV2<T, Tidx>
where T: TensorType,
      T: Clone,
      Tidx: TensorType,
      Tidx: Clone,
      T: 'static,
      Tidx: con_or_DT_INT32_or_DT_INT64,
      Tidx: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("ConcatV2_{}")?
        };
        let mut new_op = graph.new_operation("ConcatV2", &op_name)?;
        {
            new_op.add_edge(&self.values)?
        }
        {
            new_op.add_edge(&self.axis)?
        }
        {
            (|attr: &i64| {new_op.set_attr_int("N", *attr)})(&self.N)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct ConcatV2<T, Tidx>
where T: TensorType,
      T: Clone,
      Tidx: TensorType,
      Tidx: Clone,
      T: 'static,
      Tidx: con_or_DT_INT32_or_DT_INT64,
      Tidx: 'static,
{
    phantom_T: PhantomData<T>,
    values: Edge<T>,
    phantom_Tidx: PhantomData<Tidx>,
    axis: Edge<Tidx>,
    N: i64,
    op_name: Option<String>,
    id_: usize,
}

impl<T, Tidx> ConcatV2<T, Tidx>
where T: TensorType,
      T: Clone,
      Tidx: TensorType,
      Tidx: Clone,
      T: 'static,
      Tidx: con_or_DT_INT32_or_DT_INT64,
      Tidx: 'static,
{
    pub fn output(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(values: Edge<T>, axis: Edge<Tidx>, N: i64) -> Self {
        Self {
            phantom_T: PhantomData,
            values,
            phantom_Tidx: PhantomData,
            axis,
            N: N,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(values: Edge<T>, axis: Edge<Tidx>, N: i64) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            values,
            phantom_Tidx: PhantomData,
            axis,
            N: N,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl GraphOperation for ReadFile {
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("ReadFile_{}")?
        };
        let mut new_op = graph.new_operation("ReadFile", &op_name)?;
        {
            new_op.add_edge(&self.filename)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct ReadFile {
    filename: Edge<String>,
    op_name: Option<String>,
    id_: usize,
}

impl ReadFile {
    pub fn contents(self) -> Edge<String> {
        let rc = Rc::new(self);
        {
            Edge::<String>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<String> {
        let rc = Rc::new(self);
        {
            Edge::<String>::new(rc.clone(), 0)
        }
    }

    pub fn build(filename: Edge<String>) -> Self {
        Self {
            filename,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(filename: Edge<String>) -> Edge<String> {
        Self {
            filename,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<dtype> GraphOperation for PlaceholderWithDefault<dtype>
where dtype: TensorType,
      dtype: Clone,
      dtype: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("PlaceholderWithDefault_{}")?
        };
        let mut new_op = graph.new_operation("PlaceholderWithDefault", &op_name)?;
        {
            new_op.add_edge(&self.input)?
        }
        {
            (|attr| {new_op.set_attr_shape("shape", attr)})(&self.shape)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct PlaceholderWithDefault<dtype>
where dtype: TensorType,
      dtype: Clone,
      dtype: 'static,
{
    phantom_dtype: PhantomData<dtype>,
    input: Edge<dtype>,
    shape: OtherShape,
    op_name: Option<String>,
    id_: usize,
}

impl<dtype> PlaceholderWithDefault<dtype>
where dtype: TensorType,
      dtype: Clone,
      dtype: 'static,
{
    pub fn output(self) -> Edge<dtype> {
        let rc = Rc::new(self);
        {
            Edge::<dtype>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<dtype> {
        let rc = Rc::new(self);
        {
            Edge::<dtype>::new(rc.clone(), 0)
        }
    }

    pub fn build(input: Edge<dtype>, shape: &OtherShape) -> Self {
        Self {
            phantom_dtype: PhantomData,
            input,
            shape: shape.clone(),
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(input: Edge<dtype>, shape: &OtherShape) -> Edge<dtype> {
        Self {
            phantom_dtype: PhantomData,
            input,
            shape: shape.clone(),
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<T1, T2, Toutput, Tactivation> GraphOperation for QuantizedMatMul<T1, T2, Toutput, Tactivation>
where T1: TensorType,
      T1: Clone,
      T2: TensorType,
      T2: Clone,
      Toutput: TensorType,
      T1: con_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_QINT16_or_DT_QUINT16,
      T1: 'static,
      T2: con_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_QINT16_or_DT_QUINT16,
      T2: 'static,
      Toutput: con_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_QINT16_or_DT_QUINT16,
      Toutput: 'static,
      Toutput: Clone,
      Tactivation: con_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_QINT16_or_DT_QUINT16,
      Tactivation: 'static,
      Tactivation: Clone,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("QuantizedMatMul_{}")?
        };
        let mut new_op = graph.new_operation("QuantizedMatMul", &op_name)?;
        {
            new_op.add_edge(&self.a)?
        }
        {
            new_op.add_edge(&self.b)?
        }
        {
            new_op.add_edge(&self.min_a)?
        }
        {
            new_op.add_edge(&self.max_a)?
        }
        {
            new_op.add_edge(&self.min_b)?
        }
        {
            new_op.add_edge(&self.max_b)?
        }
        {
            match self.transpose_a {
                None => new_op.set_attr_value_proto("transpose_a", &vec![40_u8, 0_u8,])?,
                Some(ref value) => (|attr: &bool| {new_op.set_attr_bool("transpose_a", *attr)})(&value)?,
            };
        }
        {
            match self.transpose_b {
                None => new_op.set_attr_value_proto("transpose_b", &vec![40_u8, 0_u8,])?,
                Some(ref value) => (|attr: &bool| {new_op.set_attr_bool("transpose_b", *attr)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct QuantizedMatMul<T1, T2, Toutput, Tactivation>
where T1: TensorType,
      T1: Clone,
      T2: TensorType,
      T2: Clone,
      Toutput: TensorType,
      T1: con_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_QINT16_or_DT_QUINT16,
      T1: 'static,
      T2: con_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_QINT16_or_DT_QUINT16,
      T2: 'static,
      Toutput: con_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_QINT16_or_DT_QUINT16,
      Toutput: 'static,
      Toutput: Clone,
      Tactivation: con_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_QINT16_or_DT_QUINT16,
      Tactivation: 'static,
      Tactivation: Clone,
{
    phantom_T1: PhantomData<T1>,
    a: Edge<T1>,
    phantom_T2: PhantomData<T2>,
    b: Edge<T2>,
    min_a: Edge<f32>,
    max_a: Edge<f32>,
    min_b: Edge<f32>,
    max_b: Edge<f32>,
    phantom_Toutput: PhantomData<Toutput>,
    transpose_a: Option<bool>,
    transpose_b: Option<bool>,
    phantom_Tactivation: PhantomData<Tactivation>,
    op_name: Option<String>,
    id_: usize,
}

impl<T1, T2, Toutput, Tactivation> QuantizedMatMul<T1, T2, Toutput, Tactivation>
where T1: TensorType,
      T1: Clone,
      T2: TensorType,
      T2: Clone,
      Toutput: TensorType,
      T1: con_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_QINT16_or_DT_QUINT16,
      T1: 'static,
      T2: con_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_QINT16_or_DT_QUINT16,
      T2: 'static,
      Toutput: con_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_QINT16_or_DT_QUINT16,
      Toutput: 'static,
      Toutput: Clone,
      Tactivation: con_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_QINT16_or_DT_QUINT16,
      Tactivation: 'static,
      Tactivation: Clone,
{
    pub fn out(self) -> Edge<Toutput> {
        let rc = Rc::new(self);
        {
            Edge::<Toutput>::new(rc.clone(), 0)
        }
    }

    pub fn min_out(self) -> Edge<f32> {
        let rc = Rc::new(self);
        {
            Edge::<f32>::new(rc.clone(), 1)
        }
    }

    pub fn max_out(self) -> Edge<f32> {
        let rc = Rc::new(self);
        {
            Edge::<f32>::new(rc.clone(), 2)
        }
    }

    pub fn transpose_a(&mut self, transpose_a: bool) -> Self {
        self.transpose_a = Some(transpose_a);
        self.clone()
    }

    pub fn transpose_b(&mut self, transpose_b: bool) -> Self {
        self.transpose_b = Some(transpose_b);
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> (Edge<Toutput>, Edge<f32>, Edge<f32>) {
        let rc = Rc::new(self);
        (
        {
            Edge::<Toutput>::new(rc.clone(), 0)
        },
        {
            Edge::<f32>::new(rc.clone(), 1)
        },
        {
            Edge::<f32>::new(rc.clone(), 2)
        },
        )
    }

    pub fn build(a: Edge<T1>, b: Edge<T2>, min_a: Edge<f32>, max_a: Edge<f32>, min_b: Edge<f32>, max_b: Edge<f32>) -> Self {
        Self {
            phantom_T1: PhantomData,
            a,
            phantom_T2: PhantomData,
            b,
            min_a,
            max_a,
            min_b,
            max_b,
            phantom_Toutput: PhantomData,
            transpose_a: None,
            transpose_b: None,
            phantom_Tactivation: PhantomData,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(a: Edge<T1>, b: Edge<T2>, min_a: Edge<f32>, max_a: Edge<f32>, min_b: Edge<f32>, max_b: Edge<f32>) -> (Edge<Toutput>, Edge<f32>, Edge<f32>) {
        Self {
            phantom_T1: PhantomData,
            a,
            phantom_T2: PhantomData,
            b,
            min_a,
            max_a,
            min_b,
            max_b,
            phantom_Toutput: PhantomData,
            transpose_a: None,
            transpose_b: None,
            phantom_Tactivation: PhantomData,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<T> GraphOperation for BatchMatrixSetDiag<T>
where T: TensorType,
      T: Clone,
      T: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("BatchMatrixSetDiag_{}")?
        };
        let mut new_op = graph.new_operation("BatchMatrixSetDiag", &op_name)?;
        {
            new_op.add_edge(&self.input)?
        }
        {
            new_op.add_edge(&self.diagonal)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct BatchMatrixSetDiag<T>
where T: TensorType,
      T: Clone,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    input: Edge<T>,
    diagonal: Edge<T>,
    op_name: Option<String>,
    id_: usize,
}

impl<T> BatchMatrixSetDiag<T>
where T: TensorType,
      T: Clone,
      T: 'static,
{
    pub fn output(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(input: Edge<T>, diagonal: Edge<T>) -> Self {
        Self {
            phantom_T: PhantomData,
            input,
            diagonal,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(input: Edge<T>, diagonal: Edge<T>) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            input,
            diagonal,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<dtype> GraphOperation for XlaRecv<dtype>
where dtype: TensorType,
      dtype: 'static,
      dtype: Clone,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("XlaRecv_{}")?
        };
        let mut new_op = graph.new_operation("XlaRecv", &op_name)?;
        {
            (|attr| {new_op.set_attr_string("tensor_name", attr)})(&self.tensor_name)?
        }
        {
            (|attr| {new_op.set_attr_shape("shape", attr)})(&self.shape)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct XlaRecv<dtype>
where dtype: TensorType,
      dtype: 'static,
      dtype: Clone,
{
    phantom_dtype: PhantomData<dtype>,
    tensor_name: String,
    shape: OtherShape,
    op_name: Option<String>,
    id_: usize,
}

impl<dtype> XlaRecv<dtype>
where dtype: TensorType,
      dtype: 'static,
      dtype: Clone,
{
    pub fn tensor(self) -> Edge<dtype> {
        let rc = Rc::new(self);
        {
            Edge::<dtype>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<dtype> {
        let rc = Rc::new(self);
        {
            Edge::<dtype>::new(rc.clone(), 0)
        }
    }

    pub fn build(tensor_name: &str, shape: &OtherShape) -> Self {
        Self {
            phantom_dtype: PhantomData,
            tensor_name: tensor_name.to_string(),
            shape: shape.clone(),
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(tensor_name: &str, shape: &OtherShape) -> Edge<dtype> {
        Self {
            phantom_dtype: PhantomData,
            tensor_name: tensor_name.to_string(),
            shape: shape.clone(),
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<T> GraphOperation for ExtractImagePatches<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("ExtractImagePatches_{}")?
        };
        let mut new_op = graph.new_operation("ExtractImagePatches", &op_name)?;
        {
            new_op.add_edge(&self.images)?
        }
        {
            (|attrs| {new_op.set_attr_int_list("ksizes", attrs)})(&self.ksizes)?
        }
        {
            (|attrs| {new_op.set_attr_int_list("strides", attrs)})(&self.strides)?
        }
        {
            (|attrs| {new_op.set_attr_int_list("rates", attrs)})(&self.rates)?
        }
        {
            (|attr| {new_op.set_attr_string("padding", attr)})(&self.padding)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct ExtractImagePatches<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    images: Edge<T>,
    ksizes: Vec<i64>,
    strides: Vec<i64>,
    rates: Vec<i64>,
    padding: String,
    op_name: Option<String>,
    id_: usize,
}

impl<T> ExtractImagePatches<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
{
    pub fn patches(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(images: Edge<T>, ksizes: &[i64], strides: &[i64], rates: &[i64], padding: &str) -> Self {
        Self {
            phantom_T: PhantomData,
            images,
            ksizes: ksizes.to_vec(),
            strides: strides.to_vec(),
            rates: rates.to_vec(),
            padding: padding.to_string(),
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(images: Edge<T>, ksizes: &[i64], strides: &[i64], rates: &[i64], padding: &str) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            images,
            ksizes: ksizes.to_vec(),
            strides: strides.to_vec(),
            rates: rates.to_vec(),
            padding: padding.to_string(),
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<T> GraphOperation for CudnnRNNParamsToCanonical<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_HALF,
      T: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("CudnnRNNParamsToCanonical_{}")?
        };
        let mut new_op = graph.new_operation("CudnnRNNParamsToCanonical", &op_name)?;
        {
            new_op.add_edge(&self.num_layers)?
        }
        {
            new_op.add_edge(&self.num_units)?
        }
        {
            new_op.add_edge(&self.input_size)?
        }
        {
            new_op.add_edge(&self.params)?
        }
        {
            (|attr: &i64| {new_op.set_attr_int("num_params", *attr)})(&self.num_params)?
        }
        {
            match self.rnn_mode {
                None => new_op.set_attr_value_proto("rnn_mode", &vec![18_u8, 4_u8, 108_u8, 115_u8, 116_u8, 109_u8,])?,
                Some(ref value) => (|attr| {new_op.set_attr_string("rnn_mode", attr)})(&value)?,
            };
        }
        {
            match self.input_mode {
                None => new_op.set_attr_value_proto("input_mode", &vec![18_u8, 12_u8, 108_u8, 105_u8, 110_u8, 101_u8, 97_u8, 114_u8, 95_u8, 105_u8, 110_u8, 112_u8, 117_u8, 116_u8,])?,
                Some(ref value) => (|attr| {new_op.set_attr_string("input_mode", attr)})(&value)?,
            };
        }
        {
            match self.direction {
                None => new_op.set_attr_value_proto("direction", &vec![18_u8, 14_u8, 117_u8, 110_u8, 105_u8, 100_u8, 105_u8, 114_u8, 101_u8, 99_u8, 116_u8, 105_u8, 111_u8, 110_u8, 97_u8, 108_u8,])?,
                Some(ref value) => (|attr| {new_op.set_attr_string("direction", attr)})(&value)?,
            };
        }
        {
            match self.dropout {
                None => new_op.set_attr_value_proto("dropout", &vec![37_u8, 0_u8, 0_u8, 0_u8, 0_u8,])?,
                Some(ref value) => (|attr: &f32| {new_op.set_attr_float("dropout", *attr)})(&value)?,
            };
        }
        {
            match self.seed {
                None => new_op.set_attr_value_proto("seed", &vec![24_u8, 0_u8,])?,
                Some(ref value) => (|attr: &i64| {new_op.set_attr_int("seed", *attr)})(&value)?,
            };
        }
        {
            match self.seed2 {
                None => new_op.set_attr_value_proto("seed2", &vec![24_u8, 0_u8,])?,
                Some(ref value) => (|attr: &i64| {new_op.set_attr_int("seed2", *attr)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct CudnnRNNParamsToCanonical<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_HALF,
      T: 'static,
{
    num_layers: Edge<i32>,
    num_units: Edge<i32>,
    input_size: Edge<i32>,
    phantom_T: PhantomData<T>,
    params: Edge<T>,
    num_params: i64,
    rnn_mode: Option<String>,
    input_mode: Option<String>,
    direction: Option<String>,
    dropout: Option<f32>,
    seed: Option<i64>,
    seed2: Option<i64>,
    op_name: Option<String>,
    id_: usize,
}

impl<T> CudnnRNNParamsToCanonical<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_HALF,
      T: 'static,
{
    pub fn weights(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn biases(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 1)
        }
    }

    pub fn rnn_mode(&mut self, rnn_mode: &str) -> Self {
        self.rnn_mode = Some(rnn_mode.to_string());
        self.clone()
    }

    pub fn input_mode(&mut self, input_mode: &str) -> Self {
        self.input_mode = Some(input_mode.to_string());
        self.clone()
    }

    pub fn direction(&mut self, direction: &str) -> Self {
        self.direction = Some(direction.to_string());
        self.clone()
    }

    pub fn dropout(&mut self, dropout: f32) -> Self {
        self.dropout = Some(dropout);
        self.clone()
    }

    pub fn seed(&mut self, seed: i64) -> Self {
        self.seed = Some(seed);
        self.clone()
    }

    pub fn seed2(&mut self, seed2: i64) -> Self {
        self.seed2 = Some(seed2);
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> (Edge<T>, Edge<T>) {
        let rc = Rc::new(self);
        (
        {
            Edge::<T>::new(rc.clone(), 0)
        },
        {
            Edge::<T>::new(rc.clone(), 1)
        },
        )
    }

    pub fn build(num_layers: Edge<i32>, num_units: Edge<i32>, input_size: Edge<i32>, params: Edge<T>, num_params: i64) -> Self {
        Self {
            num_layers,
            num_units,
            input_size,
            phantom_T: PhantomData,
            params,
            num_params: num_params,
            rnn_mode: None,
            input_mode: None,
            direction: None,
            dropout: None,
            seed: None,
            seed2: None,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(num_layers: Edge<i32>, num_units: Edge<i32>, input_size: Edge<i32>, params: Edge<T>, num_params: i64) -> (Edge<T>, Edge<T>) {
        Self {
            num_layers,
            num_units,
            input_size,
            phantom_T: PhantomData,
            params,
            num_params: num_params,
            rnn_mode: None,
            input_mode: None,
            direction: None,
            dropout: None,
            seed: None,
            seed2: None,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<T, out_type> GraphOperation for ShapeN<T, out_type>
where T: TensorType,
      T: Clone,
      out_type: TensorType,
      T: 'static,
      out_type: con_or_DT_INT32_or_DT_INT64,
      out_type: 'static,
      out_type: Clone,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("ShapeN_{}")?
        };
        let mut new_op = graph.new_operation("ShapeN", &op_name)?;
        {
            new_op.add_edge(&self.input)?
        }
        {
            (|attr: &i64| {new_op.set_attr_int("N", *attr)})(&self.N)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct ShapeN<T, out_type>
where T: TensorType,
      T: Clone,
      out_type: TensorType,
      T: 'static,
      out_type: con_or_DT_INT32_or_DT_INT64,
      out_type: 'static,
      out_type: Clone,
{
    phantom_T: PhantomData<T>,
    input: Edge<T>,
    N: i64,
    phantom_out_type: PhantomData<out_type>,
    op_name: Option<String>,
    id_: usize,
}

impl<T, out_type> ShapeN<T, out_type>
where T: TensorType,
      T: Clone,
      out_type: TensorType,
      T: 'static,
      out_type: con_or_DT_INT32_or_DT_INT64,
      out_type: 'static,
      out_type: Clone,
{
    pub fn output(self) -> Edge<out_type> {
        let rc = Rc::new(self);
        {
            Edge::<out_type>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<out_type> {
        let rc = Rc::new(self);
        {
            Edge::<out_type>::new(rc.clone(), 0)
        }
    }

    pub fn build(input: Edge<T>, N: i64) -> Self {
        Self {
            phantom_T: PhantomData,
            input,
            N: N,
            phantom_out_type: PhantomData,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(input: Edge<T>, N: i64) -> Edge<out_type> {
        Self {
            phantom_T: PhantomData,
            input,
            N: N,
            phantom_out_type: PhantomData,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<T> GraphOperation for Rank<T>
where T: TensorType,
      T: Clone,
      T: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("Rank_{}")?
        };
        let mut new_op = graph.new_operation("Rank", &op_name)?;
        {
            new_op.add_edge(&self.input)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct Rank<T>
where T: TensorType,
      T: Clone,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    input: Edge<T>,
    op_name: Option<String>,
    id_: usize,
}

impl<T> Rank<T>
where T: TensorType,
      T: Clone,
      T: 'static,
{
    pub fn output(self) -> Edge<i32> {
        let rc = Rc::new(self);
        {
            Edge::<i32>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<i32> {
        let rc = Rc::new(self);
        {
            Edge::<i32>::new(rc.clone(), 0)
        }
    }

    pub fn build(input: Edge<T>) -> Self {
        Self {
            phantom_T: PhantomData,
            input,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(input: Edge<T>) -> Edge<i32> {
        Self {
            phantom_T: PhantomData,
            input,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<T, out_type> GraphOperation for Size<T, out_type>
where T: TensorType,
      T: Clone,
      out_type: TensorType,
      T: 'static,
      out_type: con_or_DT_INT32_or_DT_INT64,
      out_type: 'static,
      out_type: Clone,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("Size_{}")?
        };
        let mut new_op = graph.new_operation("Size", &op_name)?;
        {
            new_op.add_edge(&self.input)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct Size<T, out_type>
where T: TensorType,
      T: Clone,
      out_type: TensorType,
      T: 'static,
      out_type: con_or_DT_INT32_or_DT_INT64,
      out_type: 'static,
      out_type: Clone,
{
    phantom_T: PhantomData<T>,
    input: Edge<T>,
    phantom_out_type: PhantomData<out_type>,
    op_name: Option<String>,
    id_: usize,
}

impl<T, out_type> Size<T, out_type>
where T: TensorType,
      T: Clone,
      out_type: TensorType,
      T: 'static,
      out_type: con_or_DT_INT32_or_DT_INT64,
      out_type: 'static,
      out_type: Clone,
{
    pub fn output(self) -> Edge<out_type> {
        let rc = Rc::new(self);
        {
            Edge::<out_type>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<out_type> {
        let rc = Rc::new(self);
        {
            Edge::<out_type>::new(rc.clone(), 0)
        }
    }

    pub fn build(input: Edge<T>) -> Self {
        Self {
            phantom_T: PhantomData,
            input,
            phantom_out_type: PhantomData,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(input: Edge<T>) -> Edge<out_type> {
        Self {
            phantom_T: PhantomData,
            input,
            phantom_out_type: PhantomData,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl GraphOperation for _DisconnectHostFromDistributedTPUSystem {
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("_DisconnectHostFromDistributedTPUSystem_{}")?
        };
        let mut new_op = graph.new_operation("_DisconnectHostFromDistributedTPUSystem", &op_name)?;
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct _DisconnectHostFromDistributedTPUSystem {
    op_name: Option<String>,
    id_: usize,
}

impl _DisconnectHostFromDistributedTPUSystem {
    pub fn number_of_tpu_chips(self) -> Edge<i32> {
        let rc = Rc::new(self);
        {
            Edge::<i32>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<i32> {
        let rc = Rc::new(self);
        {
            Edge::<i32>::new(rc.clone(), 0)
        }
    }

    pub fn build() -> Self {
        Self {
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new() -> Edge<i32> {
        Self {
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<T, Index> GraphOperation for Slice<T, Index>
where T: TensorType,
      T: Clone,
      Index: TensorType,
      Index: Clone,
      T: 'static,
      Index: con_or_DT_INT32_or_DT_INT64,
      Index: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("Slice_{}")?
        };
        let mut new_op = graph.new_operation("Slice", &op_name)?;
        {
            new_op.add_edge(&self.input)?
        }
        {
            new_op.add_edge(&self.begin)?
        }
        {
            new_op.add_edge(&self.size)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct Slice<T, Index>
where T: TensorType,
      T: Clone,
      Index: TensorType,
      Index: Clone,
      T: 'static,
      Index: con_or_DT_INT32_or_DT_INT64,
      Index: 'static,
{
    phantom_T: PhantomData<T>,
    input: Edge<T>,
    phantom_Index: PhantomData<Index>,
    begin: Edge<Index>,
    size: Edge<Index>,
    op_name: Option<String>,
    id_: usize,
}

impl<T, Index> Slice<T, Index>
where T: TensorType,
      T: Clone,
      Index: TensorType,
      Index: Clone,
      T: 'static,
      Index: con_or_DT_INT32_or_DT_INT64,
      Index: 'static,
{
    pub fn output(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(input: Edge<T>, begin: Edge<Index>, size: Edge<Index>) -> Self {
        Self {
            phantom_T: PhantomData,
            input,
            phantom_Index: PhantomData,
            begin,
            size,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(input: Edge<T>, begin: Edge<Index>, size: Edge<Index>) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            input,
            phantom_Index: PhantomData,
            begin,
            size,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<T> GraphOperation for Unbatch<T>
where T: TensorType,
      T: Clone,
      T: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("Unbatch_{}")?
        };
        let mut new_op = graph.new_operation("Unbatch", &op_name)?;
        {
            new_op.add_edge(&self.batched_tensor)?
        }
        {
            new_op.add_edge(&self.batch_index)?
        }
        {
            new_op.add_edge(&self.id)?
        }
        {
            (|attr: &i64| {new_op.set_attr_int("timeout_micros", *attr)})(&self.timeout_micros)?
        }
        {
            match self.container {
                None => new_op.set_attr_value_proto("container", &vec![18_u8, 0_u8,])?,
                Some(ref value) => (|attr| {new_op.set_attr_string("container", attr)})(&value)?,
            };
        }
        {
            match self.shared_name {
                None => new_op.set_attr_value_proto("shared_name", &vec![18_u8, 0_u8,])?,
                Some(ref value) => (|attr| {new_op.set_attr_string("shared_name", attr)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct Unbatch<T>
where T: TensorType,
      T: Clone,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    batched_tensor: Edge<T>,
    batch_index: Edge<i64>,
    id: Edge<i64>,
    timeout_micros: i64,
    container: Option<String>,
    shared_name: Option<String>,
    op_name: Option<String>,
    id_: usize,
}

impl<T> Unbatch<T>
where T: TensorType,
      T: Clone,
      T: 'static,
{
    pub fn unbatched_tensor(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn container(&mut self, container: &str) -> Self {
        self.container = Some(container.to_string());
        self.clone()
    }

    pub fn shared_name(&mut self, shared_name: &str) -> Self {
        self.shared_name = Some(shared_name.to_string());
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(batched_tensor: Edge<T>, batch_index: Edge<i64>, id: Edge<i64>, timeout_micros: i64) -> Self {
        Self {
            phantom_T: PhantomData,
            batched_tensor,
            batch_index,
            id,
            timeout_micros: timeout_micros,
            container: None,
            shared_name: None,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(batched_tensor: Edge<T>, batch_index: Edge<i64>, id: Edge<i64>, timeout_micros: i64) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            batched_tensor,
            batch_index,
            id,
            timeout_micros: timeout_micros,
            container: None,
            shared_name: None,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<T, Tlen> GraphOperation for SplitV<T, Tlen>
where T: TensorType,
      T: Clone,
      Tlen: TensorType,
      Tlen: Clone,
      T: 'static,
      Tlen: con_or_DT_INT32_or_DT_INT64,
      Tlen: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("SplitV_{}")?
        };
        let mut new_op = graph.new_operation("SplitV", &op_name)?;
        {
            new_op.add_edge(&self.value)?
        }
        {
            new_op.add_edge(&self.size_splits)?
        }
        {
            new_op.add_edge(&self.split_dim)?
        }
        {
            (|attr: &i64| {new_op.set_attr_int("num_split", *attr)})(&self.num_split)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct SplitV<T, Tlen>
where T: TensorType,
      T: Clone,
      Tlen: TensorType,
      Tlen: Clone,
      T: 'static,
      Tlen: con_or_DT_INT32_or_DT_INT64,
      Tlen: 'static,
{
    phantom_T: PhantomData<T>,
    value: Edge<T>,
    phantom_Tlen: PhantomData<Tlen>,
    size_splits: Edge<Tlen>,
    split_dim: Edge<i32>,
    num_split: i64,
    op_name: Option<String>,
    id_: usize,
}

impl<T, Tlen> SplitV<T, Tlen>
where T: TensorType,
      T: Clone,
      Tlen: TensorType,
      Tlen: Clone,
      T: 'static,
      Tlen: con_or_DT_INT32_or_DT_INT64,
      Tlen: 'static,
{
    pub fn output(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(value: Edge<T>, size_splits: Edge<Tlen>, split_dim: Edge<i32>, num_split: i64) -> Self {
        Self {
            phantom_T: PhantomData,
            value,
            phantom_Tlen: PhantomData,
            size_splits,
            split_dim,
            num_split: num_split,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(value: Edge<T>, size_splits: Edge<Tlen>, split_dim: Edge<i32>, num_split: i64) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            value,
            phantom_Tlen: PhantomData,
            size_splits,
            split_dim,
            num_split: num_split,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<T, Index> GraphOperation for StridedSliceAssign<T, Index>
where T: TensorType,
      T: Clone,
      Index: TensorType,
      Index: Clone,
      T: 'static,
      Index: con_or_DT_INT32_or_DT_INT64,
      Index: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("StridedSliceAssign_{}")?
        };
        let mut new_op = graph.new_operation("StridedSliceAssign", &op_name)?;
        {
            new_op.add_edge(&self.ref_)?
        }
        {
            new_op.add_edge(&self.begin)?
        }
        {
            new_op.add_edge(&self.end)?
        }
        {
            new_op.add_edge(&self.strides)?
        }
        {
            new_op.add_edge(&self.value)?
        }
        {
            match self.begin_mask {
                None => new_op.set_attr_value_proto("begin_mask", &vec![24_u8, 0_u8,])?,
                Some(ref value) => (|attr: &i64| {new_op.set_attr_int("begin_mask", *attr)})(&value)?,
            };
        }
        {
            match self.end_mask {
                None => new_op.set_attr_value_proto("end_mask", &vec![24_u8, 0_u8,])?,
                Some(ref value) => (|attr: &i64| {new_op.set_attr_int("end_mask", *attr)})(&value)?,
            };
        }
        {
            match self.ellipsis_mask {
                None => new_op.set_attr_value_proto("ellipsis_mask", &vec![24_u8, 0_u8,])?,
                Some(ref value) => (|attr: &i64| {new_op.set_attr_int("ellipsis_mask", *attr)})(&value)?,
            };
        }
        {
            match self.new_axis_mask {
                None => new_op.set_attr_value_proto("new_axis_mask", &vec![24_u8, 0_u8,])?,
                Some(ref value) => (|attr: &i64| {new_op.set_attr_int("new_axis_mask", *attr)})(&value)?,
            };
        }
        {
            match self.shrink_axis_mask {
                None => new_op.set_attr_value_proto("shrink_axis_mask", &vec![24_u8, 0_u8,])?,
                Some(ref value) => (|attr: &i64| {new_op.set_attr_int("shrink_axis_mask", *attr)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct StridedSliceAssign<T, Index>
where T: TensorType,
      T: Clone,
      Index: TensorType,
      Index: Clone,
      T: 'static,
      Index: con_or_DT_INT32_or_DT_INT64,
      Index: 'static,
{
    phantom_T: PhantomData<T>,
    ref_: Edge<T>,
    phantom_Index: PhantomData<Index>,
    begin: Edge<Index>,
    end: Edge<Index>,
    strides: Edge<Index>,
    value: Edge<T>,
    begin_mask: Option<i64>,
    end_mask: Option<i64>,
    ellipsis_mask: Option<i64>,
    new_axis_mask: Option<i64>,
    shrink_axis_mask: Option<i64>,
    op_name: Option<String>,
    id_: usize,
}

impl<T, Index> StridedSliceAssign<T, Index>
where T: TensorType,
      T: Clone,
      Index: TensorType,
      Index: Clone,
      T: 'static,
      Index: con_or_DT_INT32_or_DT_INT64,
      Index: 'static,
{
    pub fn output_ref(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn begin_mask(&mut self, begin_mask: i64) -> Self {
        self.begin_mask = Some(begin_mask);
        self.clone()
    }

    pub fn end_mask(&mut self, end_mask: i64) -> Self {
        self.end_mask = Some(end_mask);
        self.clone()
    }

    pub fn ellipsis_mask(&mut self, ellipsis_mask: i64) -> Self {
        self.ellipsis_mask = Some(ellipsis_mask);
        self.clone()
    }

    pub fn new_axis_mask(&mut self, new_axis_mask: i64) -> Self {
        self.new_axis_mask = Some(new_axis_mask);
        self.clone()
    }

    pub fn shrink_axis_mask(&mut self, shrink_axis_mask: i64) -> Self {
        self.shrink_axis_mask = Some(shrink_axis_mask);
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(ref_: Edge<T>, begin: Edge<Index>, end: Edge<Index>, strides: Edge<Index>, value: Edge<T>) -> Self {
        Self {
            phantom_T: PhantomData,
            ref_,
            phantom_Index: PhantomData,
            begin,
            end,
            strides,
            value,
            begin_mask: None,
            end_mask: None,
            ellipsis_mask: None,
            new_axis_mask: None,
            shrink_axis_mask: None,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(ref_: Edge<T>, begin: Edge<Index>, end: Edge<Index>, strides: Edge<Index>, value: Edge<T>) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            ref_,
            phantom_Index: PhantomData,
            begin,
            end,
            strides,
            value,
            begin_mask: None,
            end_mask: None,
            ellipsis_mask: None,
            new_axis_mask: None,
            shrink_axis_mask: None,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<T> GraphOperation for TensorArrayWrite<T>
where T: TensorType,
      T: Clone,
      T: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("TensorArrayWrite_{}")?
        };
        let mut new_op = graph.new_operation("TensorArrayWrite", &op_name)?;
        {
            new_op.add_edge(&self.handle)?
        }
        {
            new_op.add_edge(&self.index)?
        }
        {
            new_op.add_edge(&self.value)?
        }
        {
            new_op.add_edge(&self.flow_in)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct TensorArrayWrite<T>
where T: TensorType,
      T: Clone,
      T: 'static,
{
    handle: Edge<String>,
    index: Edge<i32>,
    phantom_T: PhantomData<T>,
    value: Edge<T>,
    flow_in: Edge<f32>,
    op_name: Option<String>,
    id_: usize,
}

impl<T> TensorArrayWrite<T>
where T: TensorType,
      T: Clone,
      T: 'static,
{
    pub fn flow_out(self) -> Edge<f32> {
        let rc = Rc::new(self);
        {
            Edge::<f32>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<f32> {
        let rc = Rc::new(self);
        {
            Edge::<f32>::new(rc.clone(), 0)
        }
    }

    pub fn build(handle: Edge<String>, index: Edge<i32>, value: Edge<T>, flow_in: Edge<f32>) -> Self {
        Self {
            handle,
            index,
            phantom_T: PhantomData,
            value,
            flow_in,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(handle: Edge<String>, index: Edge<i32>, value: Edge<T>, flow_in: Edge<f32>) -> Edge<f32> {
        Self {
            handle,
            index,
            phantom_T: PhantomData,
            value,
            flow_in,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<T> GraphOperation for TileGrad<T>
where T: TensorType,
      T: Clone,
      T: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("TileGrad_{}")?
        };
        let mut new_op = graph.new_operation("TileGrad", &op_name)?;
        {
            new_op.add_edge(&self.input)?
        }
        {
            new_op.add_edge(&self.multiples)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct TileGrad<T>
where T: TensorType,
      T: Clone,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    input: Edge<T>,
    multiples: Edge<i32>,
    op_name: Option<String>,
    id_: usize,
}

impl<T> TileGrad<T>
where T: TensorType,
      T: Clone,
      T: 'static,
{
    pub fn output(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(input: Edge<T>, multiples: Edge<i32>) -> Self {
        Self {
            phantom_T: PhantomData,
            input,
            multiples,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(input: Edge<T>, multiples: Edge<i32>) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            input,
            multiples,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl GraphOperation for StringJoin {
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("StringJoin_{}")?
        };
        let mut new_op = graph.new_operation("StringJoin", &op_name)?;
        {
            new_op.add_edge(&self.inputs)?
        }
        {
            (|attr: &i64| {new_op.set_attr_int("N", *attr)})(&self.N)?
        }
        {
            match self.separator {
                None => new_op.set_attr_value_proto("separator", &vec![18_u8, 0_u8,])?,
                Some(ref value) => (|attr| {new_op.set_attr_string("separator", attr)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct StringJoin {
    inputs: Edge<String>,
    N: i64,
    separator: Option<String>,
    op_name: Option<String>,
    id_: usize,
}

impl StringJoin {
    pub fn output(self) -> Edge<String> {
        let rc = Rc::new(self);
        {
            Edge::<String>::new(rc.clone(), 0)
        }
    }

    pub fn separator(&mut self, separator: &str) -> Self {
        self.separator = Some(separator.to_string());
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<String> {
        let rc = Rc::new(self);
        {
            Edge::<String>::new(rc.clone(), 0)
        }
    }

    pub fn build(inputs: Edge<String>, N: i64) -> Self {
        Self {
            inputs,
            N: N,
            separator: None,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(inputs: Edge<String>, N: i64) -> Edge<String> {
        Self {
            inputs,
            N: N,
            separator: None,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<dtype> GraphOperation for ImmutableConst<dtype>
where dtype: TensorType,
      dtype: 'static,
      dtype: Clone,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("ImmutableConst_{}")?
        };
        let mut new_op = graph.new_operation("ImmutableConst", &op_name)?;
        {
            (|attr| {new_op.set_attr_shape("shape", attr)})(&self.shape)?
        }
        {
            (|attr| {new_op.set_attr_string("memory_region_name", attr)})(&self.memory_region_name)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct ImmutableConst<dtype>
where dtype: TensorType,
      dtype: 'static,
      dtype: Clone,
{
    phantom_dtype: PhantomData<dtype>,
    shape: OtherShape,
    memory_region_name: String,
    op_name: Option<String>,
    id_: usize,
}

impl<dtype> ImmutableConst<dtype>
where dtype: TensorType,
      dtype: 'static,
      dtype: Clone,
{
    pub fn tensor(self) -> Edge<dtype> {
        let rc = Rc::new(self);
        {
            Edge::<dtype>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<dtype> {
        let rc = Rc::new(self);
        {
            Edge::<dtype>::new(rc.clone(), 0)
        }
    }

    pub fn build(shape: &OtherShape, memory_region_name: &str) -> Self {
        Self {
            phantom_dtype: PhantomData,
            shape: shape.clone(),
            memory_region_name: memory_region_name.to_string(),
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(shape: &OtherShape, memory_region_name: &str) -> Edge<dtype> {
        Self {
            phantom_dtype: PhantomData,
            shape: shape.clone(),
            memory_region_name: memory_region_name.to_string(),
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<T> GraphOperation for SparseSparseMaximum<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("SparseSparseMaximum_{}")?
        };
        let mut new_op = graph.new_operation("SparseSparseMaximum", &op_name)?;
        {
            new_op.add_edge(&self.a_indices)?
        }
        {
            new_op.add_edge(&self.a_values)?
        }
        {
            new_op.add_edge(&self.a_shape)?
        }
        {
            new_op.add_edge(&self.b_indices)?
        }
        {
            new_op.add_edge(&self.b_values)?
        }
        {
            new_op.add_edge(&self.b_shape)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct SparseSparseMaximum<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
{
    a_indices: Edge<i64>,
    phantom_T: PhantomData<T>,
    a_values: Edge<T>,
    a_shape: Edge<i64>,
    b_indices: Edge<i64>,
    b_values: Edge<T>,
    b_shape: Edge<i64>,
    op_name: Option<String>,
    id_: usize,
}

impl<T> SparseSparseMaximum<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
{
    pub fn output_indices(self) -> Edge<i64> {
        let rc = Rc::new(self);
        {
            Edge::<i64>::new(rc.clone(), 0)
        }
    }

    pub fn output_values(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 1)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> (Edge<i64>, Edge<T>) {
        let rc = Rc::new(self);
        (
        {
            Edge::<i64>::new(rc.clone(), 0)
        },
        {
            Edge::<T>::new(rc.clone(), 1)
        },
        )
    }

    pub fn build(a_indices: Edge<i64>, a_values: Edge<T>, a_shape: Edge<i64>, b_indices: Edge<i64>, b_values: Edge<T>, b_shape: Edge<i64>) -> Self {
        Self {
            a_indices,
            phantom_T: PhantomData,
            a_values,
            a_shape,
            b_indices,
            b_values,
            b_shape,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(a_indices: Edge<i64>, a_values: Edge<T>, a_shape: Edge<i64>, b_indices: Edge<i64>, b_values: Edge<T>, b_shape: Edge<i64>) -> (Edge<i64>, Edge<T>) {
        Self {
            a_indices,
            phantom_T: PhantomData,
            a_values,
            a_shape,
            b_indices,
            b_values,
            b_shape,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<T> GraphOperation for MatrixSetDiag<T>
where T: TensorType,
      T: Clone,
      T: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("MatrixSetDiag_{}")?
        };
        let mut new_op = graph.new_operation("MatrixSetDiag", &op_name)?;
        {
            new_op.add_edge(&self.input)?
        }
        {
            new_op.add_edge(&self.diagonal)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct MatrixSetDiag<T>
where T: TensorType,
      T: Clone,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    input: Edge<T>,
    diagonal: Edge<T>,
    op_name: Option<String>,
    id_: usize,
}

impl<T> MatrixSetDiag<T>
where T: TensorType,
      T: Clone,
      T: 'static,
{
    pub fn output(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(input: Edge<T>, diagonal: Edge<T>) -> Self {
        Self {
            phantom_T: PhantomData,
            input,
            diagonal,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(input: Edge<T>, diagonal: Edge<T>) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            input,
            diagonal,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl GraphOperation for EncodeBase64 {
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("EncodeBase64_{}")?
        };
        let mut new_op = graph.new_operation("EncodeBase64", &op_name)?;
        {
            new_op.add_edge(&self.input)?
        }
        {
            match self.pad {
                None => new_op.set_attr_value_proto("pad", &vec![40_u8, 0_u8,])?,
                Some(ref value) => (|attr: &bool| {new_op.set_attr_bool("pad", *attr)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct EncodeBase64 {
    input: Edge<String>,
    pad: Option<bool>,
    op_name: Option<String>,
    id_: usize,
}

impl EncodeBase64 {
    pub fn output(self) -> Edge<String> {
        let rc = Rc::new(self);
        {
            Edge::<String>::new(rc.clone(), 0)
        }
    }

    pub fn pad(&mut self, pad: bool) -> Self {
        self.pad = Some(pad);
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<String> {
        let rc = Rc::new(self);
        {
            Edge::<String>::new(rc.clone(), 0)
        }
    }

    pub fn build(input: Edge<String>) -> Self {
        Self {
            input,
            pad: None,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(input: Edge<String>) -> Edge<String> {
        Self {
            input,
            pad: None,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl GraphOperation for TensorArrayCloseV2 {
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("TensorArrayCloseV2_{}")?
        };
        let mut new_op = graph.new_operation("TensorArrayCloseV2", &op_name)?;
        {
            new_op.add_edge(&self.handle)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct TensorArrayCloseV2 {
    handle: Edge<String>,
    op_name: Option<String>,
    id_: usize,
}

impl TensorArrayCloseV2 {
    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> () {
        let rc = Rc::new(self);
        (
        )
    }

    pub fn build(handle: Edge<String>) -> Self {
        Self {
            handle,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(handle: Edge<String>) -> () {
        Self {
            handle,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<T, output_idx_type> GraphOperation for Lu<T, output_idx_type>
where T: TensorType,
      T: Clone,
      output_idx_type: TensorType,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_COMPLEX64_or_DT_COMPLEX128,
      T: 'static,
      output_idx_type: con_or_DT_INT32_or_DT_INT64,
      output_idx_type: 'static,
      output_idx_type: Clone,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("Lu_{}")?
        };
        let mut new_op = graph.new_operation("Lu", &op_name)?;
        {
            new_op.add_edge(&self.input)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct Lu<T, output_idx_type>
where T: TensorType,
      T: Clone,
      output_idx_type: TensorType,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_COMPLEX64_or_DT_COMPLEX128,
      T: 'static,
      output_idx_type: con_or_DT_INT32_or_DT_INT64,
      output_idx_type: 'static,
      output_idx_type: Clone,
{
    phantom_T: PhantomData<T>,
    input: Edge<T>,
    phantom_output_idx_type: PhantomData<output_idx_type>,
    op_name: Option<String>,
    id_: usize,
}

impl<T, output_idx_type> Lu<T, output_idx_type>
where T: TensorType,
      T: Clone,
      output_idx_type: TensorType,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_COMPLEX64_or_DT_COMPLEX128,
      T: 'static,
      output_idx_type: con_or_DT_INT32_or_DT_INT64,
      output_idx_type: 'static,
      output_idx_type: Clone,
{
    pub fn lu(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn p(self) -> Edge<output_idx_type> {
        let rc = Rc::new(self);
        {
            Edge::<output_idx_type>::new(rc.clone(), 1)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> (Edge<T>, Edge<output_idx_type>) {
        let rc = Rc::new(self);
        (
        {
            Edge::<T>::new(rc.clone(), 0)
        },
        {
            Edge::<output_idx_type>::new(rc.clone(), 1)
        },
        )
    }

    pub fn build(input: Edge<T>) -> Self {
        Self {
            phantom_T: PhantomData,
            input,
            phantom_output_idx_type: PhantomData,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(input: Edge<T>) -> (Edge<T>, Edge<output_idx_type>) {
        Self {
            phantom_T: PhantomData,
            input,
            phantom_output_idx_type: PhantomData,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<T> GraphOperation for BroadcastGradientArgs<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_INT32_or_DT_INT64,
      T: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("BroadcastGradientArgs_{}")?
        };
        let mut new_op = graph.new_operation("BroadcastGradientArgs", &op_name)?;
        {
            new_op.add_edge(&self.s0)?
        }
        {
            new_op.add_edge(&self.s1)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct BroadcastGradientArgs<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_INT32_or_DT_INT64,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    s0: Edge<T>,
    s1: Edge<T>,
    op_name: Option<String>,
    id_: usize,
}

impl<T> BroadcastGradientArgs<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_INT32_or_DT_INT64,
      T: 'static,
{
    pub fn r0(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn r1(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 1)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> (Edge<T>, Edge<T>) {
        let rc = Rc::new(self);
        (
        {
            Edge::<T>::new(rc.clone(), 0)
        },
        {
            Edge::<T>::new(rc.clone(), 1)
        },
        )
    }

    pub fn build(s0: Edge<T>, s1: Edge<T>) -> Self {
        Self {
            phantom_T: PhantomData,
            s0,
            s1,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(s0: Edge<T>, s1: Edge<T>) -> (Edge<T>, Edge<T>) {
        Self {
            phantom_T: PhantomData,
            s0,
            s1,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<T, Tindices> GraphOperation for SparseApplyProximalAdagrad<T, Tindices>
where T: TensorType,
      T: Clone,
      Tindices: TensorType,
      Tindices: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
      Tindices: con_or_DT_INT32_or_DT_INT64,
      Tindices: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("SparseApplyProximalAdagrad_{}")?
        };
        let mut new_op = graph.new_operation("SparseApplyProximalAdagrad", &op_name)?;
        {
            new_op.add_edge(&self.var)?
        }
        {
            new_op.add_edge(&self.accum)?
        }
        {
            new_op.add_edge(&self.lr)?
        }
        {
            new_op.add_edge(&self.l1)?
        }
        {
            new_op.add_edge(&self.l2)?
        }
        {
            new_op.add_edge(&self.grad)?
        }
        {
            new_op.add_edge(&self.indices)?
        }
        {
            match self.use_locking {
                None => new_op.set_attr_value_proto("use_locking", &vec![40_u8, 0_u8,])?,
                Some(ref value) => (|attr: &bool| {new_op.set_attr_bool("use_locking", *attr)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct SparseApplyProximalAdagrad<T, Tindices>
where T: TensorType,
      T: Clone,
      Tindices: TensorType,
      Tindices: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
      Tindices: con_or_DT_INT32_or_DT_INT64,
      Tindices: 'static,
{
    phantom_T: PhantomData<T>,
    var: Edge<T>,
    accum: Edge<T>,
    lr: Edge<T>,
    l1: Edge<T>,
    l2: Edge<T>,
    grad: Edge<T>,
    phantom_Tindices: PhantomData<Tindices>,
    indices: Edge<Tindices>,
    use_locking: Option<bool>,
    op_name: Option<String>,
    id_: usize,
}

impl<T, Tindices> SparseApplyProximalAdagrad<T, Tindices>
where T: TensorType,
      T: Clone,
      Tindices: TensorType,
      Tindices: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
      Tindices: con_or_DT_INT32_or_DT_INT64,
      Tindices: 'static,
{
    pub fn out(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn use_locking(&mut self, use_locking: bool) -> Self {
        self.use_locking = Some(use_locking);
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(var: Edge<T>, accum: Edge<T>, lr: Edge<T>, l1: Edge<T>, l2: Edge<T>, grad: Edge<T>, indices: Edge<Tindices>) -> Self {
        Self {
            phantom_T: PhantomData,
            var,
            accum,
            lr,
            l1,
            l2,
            grad,
            phantom_Tindices: PhantomData,
            indices,
            use_locking: None,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(var: Edge<T>, accum: Edge<T>, lr: Edge<T>, l1: Edge<T>, l2: Edge<T>, grad: Edge<T>, indices: Edge<Tindices>) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            var,
            accum,
            lr,
            l1,
            l2,
            grad,
            phantom_Tindices: PhantomData,
            indices,
            use_locking: None,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<T, Tshape> GraphOperation for QuantizedReshape<T, Tshape>
where T: TensorType,
      T: Clone,
      Tshape: TensorType,
      Tshape: Clone,
      T: 'static,
      Tshape: con_or_DT_INT32_or_DT_INT64,
      Tshape: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("QuantizedReshape_{}")?
        };
        let mut new_op = graph.new_operation("QuantizedReshape", &op_name)?;
        {
            new_op.add_edge(&self.tensor)?
        }
        {
            new_op.add_edge(&self.shape)?
        }
        {
            new_op.add_edge(&self.input_min)?
        }
        {
            new_op.add_edge(&self.input_max)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct QuantizedReshape<T, Tshape>
where T: TensorType,
      T: Clone,
      Tshape: TensorType,
      Tshape: Clone,
      T: 'static,
      Tshape: con_or_DT_INT32_or_DT_INT64,
      Tshape: 'static,
{
    phantom_T: PhantomData<T>,
    tensor: Edge<T>,
    phantom_Tshape: PhantomData<Tshape>,
    shape: Edge<Tshape>,
    input_min: Edge<f32>,
    input_max: Edge<f32>,
    op_name: Option<String>,
    id_: usize,
}

impl<T, Tshape> QuantizedReshape<T, Tshape>
where T: TensorType,
      T: Clone,
      Tshape: TensorType,
      Tshape: Clone,
      T: 'static,
      Tshape: con_or_DT_INT32_or_DT_INT64,
      Tshape: 'static,
{
    pub fn output(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn output_min(self) -> Edge<f32> {
        let rc = Rc::new(self);
        {
            Edge::<f32>::new(rc.clone(), 1)
        }
    }

    pub fn output_max(self) -> Edge<f32> {
        let rc = Rc::new(self);
        {
            Edge::<f32>::new(rc.clone(), 2)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> (Edge<T>, Edge<f32>, Edge<f32>) {
        let rc = Rc::new(self);
        (
        {
            Edge::<T>::new(rc.clone(), 0)
        },
        {
            Edge::<f32>::new(rc.clone(), 1)
        },
        {
            Edge::<f32>::new(rc.clone(), 2)
        },
        )
    }

    pub fn build(tensor: Edge<T>, shape: Edge<Tshape>, input_min: Edge<f32>, input_max: Edge<f32>) -> Self {
        Self {
            phantom_T: PhantomData,
            tensor,
            phantom_Tshape: PhantomData,
            shape,
            input_min,
            input_max,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(tensor: Edge<T>, shape: Edge<Tshape>, input_min: Edge<f32>, input_max: Edge<f32>) -> (Edge<T>, Edge<f32>, Edge<f32>) {
        Self {
            phantom_T: PhantomData,
            tensor,
            phantom_Tshape: PhantomData,
            shape,
            input_min,
            input_max,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<T, Tidx> GraphOperation for SparseSegmentSqrtNGrad<T, Tidx>
where T: TensorType,
      T: Clone,
      Tidx: TensorType,
      Tidx: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE,
      T: 'static,
      Tidx: con_or_DT_INT32_or_DT_INT64,
      Tidx: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("SparseSegmentSqrtNGrad_{}")?
        };
        let mut new_op = graph.new_operation("SparseSegmentSqrtNGrad", &op_name)?;
        {
            new_op.add_edge(&self.grad)?
        }
        {
            new_op.add_edge(&self.indices)?
        }
        {
            new_op.add_edge(&self.segment_ids)?
        }
        {
            new_op.add_edge(&self.output_dim0)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct SparseSegmentSqrtNGrad<T, Tidx>
where T: TensorType,
      T: Clone,
      Tidx: TensorType,
      Tidx: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE,
      T: 'static,
      Tidx: con_or_DT_INT32_or_DT_INT64,
      Tidx: 'static,
{
    phantom_T: PhantomData<T>,
    grad: Edge<T>,
    phantom_Tidx: PhantomData<Tidx>,
    indices: Edge<Tidx>,
    segment_ids: Edge<i32>,
    output_dim0: Edge<i32>,
    op_name: Option<String>,
    id_: usize,
}

impl<T, Tidx> SparseSegmentSqrtNGrad<T, Tidx>
where T: TensorType,
      T: Clone,
      Tidx: TensorType,
      Tidx: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE,
      T: 'static,
      Tidx: con_or_DT_INT32_or_DT_INT64,
      Tidx: 'static,
{
    pub fn output(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(grad: Edge<T>, indices: Edge<Tidx>, segment_ids: Edge<i32>, output_dim0: Edge<i32>) -> Self {
        Self {
            phantom_T: PhantomData,
            grad,
            phantom_Tidx: PhantomData,
            indices,
            segment_ids,
            output_dim0,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(grad: Edge<T>, indices: Edge<Tidx>, segment_ids: Edge<i32>, output_dim0: Edge<i32>) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            grad,
            phantom_Tidx: PhantomData,
            indices,
            segment_ids,
            output_dim0,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<T, Tpaddings> GraphOperation for Pad<T, Tpaddings>
where T: TensorType,
      T: Clone,
      Tpaddings: TensorType,
      Tpaddings: Clone,
      T: 'static,
      Tpaddings: con_or_DT_INT32_or_DT_INT64,
      Tpaddings: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("Pad_{}")?
        };
        let mut new_op = graph.new_operation("Pad", &op_name)?;
        {
            new_op.add_edge(&self.input)?
        }
        {
            new_op.add_edge(&self.paddings)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct Pad<T, Tpaddings>
where T: TensorType,
      T: Clone,
      Tpaddings: TensorType,
      Tpaddings: Clone,
      T: 'static,
      Tpaddings: con_or_DT_INT32_or_DT_INT64,
      Tpaddings: 'static,
{
    phantom_T: PhantomData<T>,
    input: Edge<T>,
    phantom_Tpaddings: PhantomData<Tpaddings>,
    paddings: Edge<Tpaddings>,
    op_name: Option<String>,
    id_: usize,
}

impl<T, Tpaddings> Pad<T, Tpaddings>
where T: TensorType,
      T: Clone,
      Tpaddings: TensorType,
      Tpaddings: Clone,
      T: 'static,
      Tpaddings: con_or_DT_INT32_or_DT_INT64,
      Tpaddings: 'static,
{
    pub fn output(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(input: Edge<T>, paddings: Edge<Tpaddings>) -> Self {
        Self {
            phantom_T: PhantomData,
            input,
            phantom_Tpaddings: PhantomData,
            paddings,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(input: Edge<T>, paddings: Edge<Tpaddings>) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            input,
            phantom_Tpaddings: PhantomData,
            paddings,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<T> GraphOperation for _ParallelConcatUpdate<T>
where T: TensorType,
      T: Clone,
      T: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("_ParallelConcatUpdate_{}")?
        };
        let mut new_op = graph.new_operation("_ParallelConcatUpdate", &op_name)?;
        {
            new_op.add_edge(&self.value)?
        }
        {
            new_op.add_edge(&self.update)?
        }
        {
            (|attr: &i64| {new_op.set_attr_int("loc", *attr)})(&self.loc)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct _ParallelConcatUpdate<T>
where T: TensorType,
      T: Clone,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    value: Edge<T>,
    update: Edge<T>,
    loc: i64,
    op_name: Option<String>,
    id_: usize,
}

impl<T> _ParallelConcatUpdate<T>
where T: TensorType,
      T: Clone,
      T: 'static,
{
    pub fn output(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(value: Edge<T>, update: Edge<T>, loc: i64) -> Self {
        Self {
            phantom_T: PhantomData,
            value,
            update,
            loc: loc,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(value: Edge<T>, update: Edge<T>, loc: i64) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            value,
            update,
            loc: loc,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<T> GraphOperation for Digamma<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
      T: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("Digamma_{}")?
        };
        let mut new_op = graph.new_operation("Digamma", &op_name)?;
        {
            new_op.add_edge(&self.x)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct Digamma<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    x: Edge<T>,
    op_name: Option<String>,
    id_: usize,
}

impl<T> Digamma<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
      T: 'static,
{
    pub fn y(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(x: Edge<T>) -> Self {
        Self {
            phantom_T: PhantomData,
            x,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(x: Edge<T>) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            x,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<T> GraphOperation for Conv2DBackpropFilter<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
      T: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("Conv2DBackpropFilter_{}")?
        };
        let mut new_op = graph.new_operation("Conv2DBackpropFilter", &op_name)?;
        {
            new_op.add_edge(&self.input)?
        }
        {
            new_op.add_edge(&self.filter_sizes)?
        }
        {
            new_op.add_edge(&self.out_backprop)?
        }
        {
            (|attrs| {new_op.set_attr_int_list("strides", attrs)})(&self.strides)?
        }
        {
            match self.use_cudnn_on_gpu {
                None => new_op.set_attr_value_proto("use_cudnn_on_gpu", &vec![40_u8, 1_u8,])?,
                Some(ref value) => (|attr: &bool| {new_op.set_attr_bool("use_cudnn_on_gpu", *attr)})(&value)?,
            };
        }
        {
            (|attr| {new_op.set_attr_string("padding", attr)})(&self.padding)?
        }
        {
            match self.data_format {
                None => new_op.set_attr_value_proto("data_format", &vec![18_u8, 4_u8, 78_u8, 72_u8, 87_u8, 67_u8,])?,
                Some(ref value) => (|attr| {new_op.set_attr_string("data_format", attr)})(&value)?,
            };
        }
        {
            match self.dilations {
                None => new_op.set_attr_value_proto("dilations", &vec![10_u8, 0_u8, 26_u8, 4_u8,])?,
                Some(ref value) => (|attrs| {new_op.set_attr_int_list("dilations", attrs)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct Conv2DBackpropFilter<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    input: Edge<T>,
    filter_sizes: Edge<i32>,
    out_backprop: Edge<T>,
    strides: Vec<i64>,
    use_cudnn_on_gpu: Option<bool>,
    padding: String,
    data_format: Option<String>,
    dilations: Option<Vec<i64>>,
    op_name: Option<String>,
    id_: usize,
}

impl<T> Conv2DBackpropFilter<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
      T: 'static,
{
    pub fn output(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn use_cudnn_on_gpu(&mut self, use_cudnn_on_gpu: bool) -> Self {
        self.use_cudnn_on_gpu = Some(use_cudnn_on_gpu);
        self.clone()
    }

    pub fn data_format(&mut self, data_format: &str) -> Self {
        self.data_format = Some(data_format.to_string());
        self.clone()
    }

    pub fn dilations(&mut self, dilations: &[i64]) -> Self {
        self.dilations = Some(dilations.to_vec());
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(input: Edge<T>, filter_sizes: Edge<i32>, out_backprop: Edge<T>, strides: &[i64], padding: &str) -> Self {
        Self {
            phantom_T: PhantomData,
            input,
            filter_sizes,
            out_backprop,
            strides: strides.to_vec(),
            use_cudnn_on_gpu: None,
            padding: padding.to_string(),
            data_format: None,
            dilations: None,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(input: Edge<T>, filter_sizes: Edge<i32>, out_backprop: Edge<T>, strides: &[i64], padding: &str) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            input,
            filter_sizes,
            out_backprop,
            strides: strides.to_vec(),
            use_cudnn_on_gpu: None,
            padding: padding.to_string(),
            data_format: None,
            dilations: None,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<dtype> GraphOperation for Placeholder<dtype>
where dtype: TensorType,
      dtype: 'static,
      dtype: Clone,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("Placeholder_{}")?
        };
        let mut new_op = graph.new_operation("Placeholder", &op_name)?;
        {
            match self.shape {
                None => new_op.set_attr_value_proto("shape", &vec![58_u8, 0_u8,])?,
                Some(ref value) => (|attr| {new_op.set_attr_shape("shape", attr)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct Placeholder<dtype>
where dtype: TensorType,
      dtype: 'static,
      dtype: Clone,
{
    phantom_dtype: PhantomData<dtype>,
    shape: Option<OtherShape>,
    op_name: Option<String>,
    id_: usize,
}

impl<dtype> Placeholder<dtype>
where dtype: TensorType,
      dtype: 'static,
      dtype: Clone,
{
    pub fn output(self) -> Edge<dtype> {
        let rc = Rc::new(self);
        {
            Edge::<dtype>::new(rc.clone(), 0)
        }
    }

    pub fn shape(&mut self, shape: &OtherShape) -> Self {
        self.shape = Some(shape.clone());
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<dtype> {
        let rc = Rc::new(self);
        {
            Edge::<dtype>::new(rc.clone(), 0)
        }
    }

    pub fn build() -> Self {
        Self {
            phantom_dtype: PhantomData,
            shape: None,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new() -> Edge<dtype> {
        Self {
            phantom_dtype: PhantomData,
            shape: None,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<T> GraphOperation for SparseSlice<T>
where T: TensorType,
      T: Clone,
      T: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("SparseSlice_{}")?
        };
        let mut new_op = graph.new_operation("SparseSlice", &op_name)?;
        {
            new_op.add_edge(&self.indices)?
        }
        {
            new_op.add_edge(&self.values)?
        }
        {
            new_op.add_edge(&self.shape)?
        }
        {
            new_op.add_edge(&self.start)?
        }
        {
            new_op.add_edge(&self.size)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct SparseSlice<T>
where T: TensorType,
      T: Clone,
      T: 'static,
{
    indices: Edge<i64>,
    phantom_T: PhantomData<T>,
    values: Edge<T>,
    shape: Edge<i64>,
    start: Edge<i64>,
    size: Edge<i64>,
    op_name: Option<String>,
    id_: usize,
}

impl<T> SparseSlice<T>
where T: TensorType,
      T: Clone,
      T: 'static,
{
    pub fn output_indices(self) -> Edge<i64> {
        let rc = Rc::new(self);
        {
            Edge::<i64>::new(rc.clone(), 0)
        }
    }

    pub fn output_values(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 1)
        }
    }

    pub fn output_shape(self) -> Edge<i64> {
        let rc = Rc::new(self);
        {
            Edge::<i64>::new(rc.clone(), 2)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> (Edge<i64>, Edge<T>, Edge<i64>) {
        let rc = Rc::new(self);
        (
        {
            Edge::<i64>::new(rc.clone(), 0)
        },
        {
            Edge::<T>::new(rc.clone(), 1)
        },
        {
            Edge::<i64>::new(rc.clone(), 2)
        },
        )
    }

    pub fn build(indices: Edge<i64>, values: Edge<T>, shape: Edge<i64>, start: Edge<i64>, size: Edge<i64>) -> Self {
        Self {
            indices,
            phantom_T: PhantomData,
            values,
            shape,
            start,
            size,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(indices: Edge<i64>, values: Edge<T>, shape: Edge<i64>, start: Edge<i64>, size: Edge<i64>) -> (Edge<i64>, Edge<T>, Edge<i64>) {
        Self {
            indices,
            phantom_T: PhantomData,
            values,
            shape,
            start,
            size,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<T> GraphOperation for QuantizedConcat<T>
where T: TensorType,
      T: Clone,
      T: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("QuantizedConcat_{}")?
        };
        let mut new_op = graph.new_operation("QuantizedConcat", &op_name)?;
        {
            new_op.add_edge(&self.concat_dim)?
        }
        {
            new_op.add_edge(&self.values)?
        }
        {
            new_op.add_edge(&self.input_mins)?
        }
        {
            new_op.add_edge(&self.input_maxes)?
        }
        {
            (|attr: &i64| {new_op.set_attr_int("N", *attr)})(&self.N)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct QuantizedConcat<T>
where T: TensorType,
      T: Clone,
      T: 'static,
{
    concat_dim: Edge<i32>,
    phantom_T: PhantomData<T>,
    values: Edge<T>,
    input_mins: Edge<f32>,
    input_maxes: Edge<f32>,
    N: i64,
    op_name: Option<String>,
    id_: usize,
}

impl<T> QuantizedConcat<T>
where T: TensorType,
      T: Clone,
      T: 'static,
{
    pub fn output(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn output_min(self) -> Edge<f32> {
        let rc = Rc::new(self);
        {
            Edge::<f32>::new(rc.clone(), 1)
        }
    }

    pub fn output_max(self) -> Edge<f32> {
        let rc = Rc::new(self);
        {
            Edge::<f32>::new(rc.clone(), 2)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> (Edge<T>, Edge<f32>, Edge<f32>) {
        let rc = Rc::new(self);
        (
        {
            Edge::<T>::new(rc.clone(), 0)
        },
        {
            Edge::<f32>::new(rc.clone(), 1)
        },
        {
            Edge::<f32>::new(rc.clone(), 2)
        },
        )
    }

    pub fn build(concat_dim: Edge<i32>, values: Edge<T>, input_mins: Edge<f32>, input_maxes: Edge<f32>, N: i64) -> Self {
        Self {
            concat_dim,
            phantom_T: PhantomData,
            values,
            input_mins,
            input_maxes,
            N: N,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(concat_dim: Edge<i32>, values: Edge<T>, input_mins: Edge<f32>, input_maxes: Edge<f32>, N: i64) -> (Edge<T>, Edge<f32>, Edge<f32>) {
        Self {
            concat_dim,
            phantom_T: PhantomData,
            values,
            input_mins,
            input_maxes,
            N: N,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<T, Tpaddings> GraphOperation for SpaceToBatch<T, Tpaddings>
where T: TensorType,
      T: Clone,
      Tpaddings: TensorType,
      Tpaddings: Clone,
      T: 'static,
      Tpaddings: con_or_DT_INT32_or_DT_INT64,
      Tpaddings: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("SpaceToBatch_{}")?
        };
        let mut new_op = graph.new_operation("SpaceToBatch", &op_name)?;
        {
            new_op.add_edge(&self.input)?
        }
        {
            new_op.add_edge(&self.paddings)?
        }
        {
            (|attr: &i64| {new_op.set_attr_int("block_size", *attr)})(&self.block_size)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct SpaceToBatch<T, Tpaddings>
where T: TensorType,
      T: Clone,
      Tpaddings: TensorType,
      Tpaddings: Clone,
      T: 'static,
      Tpaddings: con_or_DT_INT32_or_DT_INT64,
      Tpaddings: 'static,
{
    phantom_T: PhantomData<T>,
    input: Edge<T>,
    phantom_Tpaddings: PhantomData<Tpaddings>,
    paddings: Edge<Tpaddings>,
    block_size: i64,
    op_name: Option<String>,
    id_: usize,
}

impl<T, Tpaddings> SpaceToBatch<T, Tpaddings>
where T: TensorType,
      T: Clone,
      Tpaddings: TensorType,
      Tpaddings: Clone,
      T: 'static,
      Tpaddings: con_or_DT_INT32_or_DT_INT64,
      Tpaddings: 'static,
{
    pub fn output(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(input: Edge<T>, paddings: Edge<Tpaddings>, block_size: i64) -> Self {
        Self {
            phantom_T: PhantomData,
            input,
            phantom_Tpaddings: PhantomData,
            paddings,
            block_size: block_size,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(input: Edge<T>, paddings: Edge<Tpaddings>, block_size: i64) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            input,
            phantom_Tpaddings: PhantomData,
            paddings,
            block_size: block_size,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl GraphOperation for DecodeGif {
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("DecodeGif_{}")?
        };
        let mut new_op = graph.new_operation("DecodeGif", &op_name)?;
        {
            new_op.add_edge(&self.contents)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct DecodeGif {
    contents: Edge<String>,
    op_name: Option<String>,
    id_: usize,
}

impl DecodeGif {
    pub fn image(self) -> Edge<u8> {
        let rc = Rc::new(self);
        {
            Edge::<u8>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<u8> {
        let rc = Rc::new(self);
        {
            Edge::<u8>::new(rc.clone(), 0)
        }
    }

    pub fn build(contents: Edge<String>) -> Self {
        Self {
            contents,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(contents: Edge<String>) -> Edge<u8> {
        Self {
            contents,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<T> GraphOperation for Unpack<T>
where T: TensorType,
      T: Clone,
      T: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("Unpack_{}")?
        };
        let mut new_op = graph.new_operation("Unpack", &op_name)?;
        {
            new_op.add_edge(&self.value)?
        }
        {
            (|attr: &i64| {new_op.set_attr_int("num", *attr)})(&self.num)?
        }
        {
            match self.axis {
                None => new_op.set_attr_value_proto("axis", &vec![24_u8, 0_u8,])?,
                Some(ref value) => (|attr: &i64| {new_op.set_attr_int("axis", *attr)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct Unpack<T>
where T: TensorType,
      T: Clone,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    value: Edge<T>,
    num: i64,
    axis: Option<i64>,
    op_name: Option<String>,
    id_: usize,
}

impl<T> Unpack<T>
where T: TensorType,
      T: Clone,
      T: 'static,
{
    pub fn output(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn axis(&mut self, axis: i64) -> Self {
        self.axis = Some(axis);
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(value: Edge<T>, num: i64) -> Self {
        Self {
            phantom_T: PhantomData,
            value,
            num: num,
            axis: None,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(value: Edge<T>, num: i64) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            value,
            num: num,
            axis: None,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<T, Tblock_shape, Tcrops> GraphOperation for BatchToSpaceND<T, Tblock_shape, Tcrops>
where T: TensorType,
      T: Clone,
      Tblock_shape: TensorType,
      Tblock_shape: Clone,
      Tcrops: TensorType,
      Tcrops: Clone,
      T: 'static,
      Tblock_shape: con_or_DT_INT32_or_DT_INT64,
      Tblock_shape: 'static,
      Tcrops: con_or_DT_INT32_or_DT_INT64,
      Tcrops: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("BatchToSpaceND_{}")?
        };
        let mut new_op = graph.new_operation("BatchToSpaceND", &op_name)?;
        {
            new_op.add_edge(&self.input)?
        }
        {
            new_op.add_edge(&self.block_shape)?
        }
        {
            new_op.add_edge(&self.crops)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct BatchToSpaceND<T, Tblock_shape, Tcrops>
where T: TensorType,
      T: Clone,
      Tblock_shape: TensorType,
      Tblock_shape: Clone,
      Tcrops: TensorType,
      Tcrops: Clone,
      T: 'static,
      Tblock_shape: con_or_DT_INT32_or_DT_INT64,
      Tblock_shape: 'static,
      Tcrops: con_or_DT_INT32_or_DT_INT64,
      Tcrops: 'static,
{
    phantom_T: PhantomData<T>,
    input: Edge<T>,
    phantom_Tblock_shape: PhantomData<Tblock_shape>,
    block_shape: Edge<Tblock_shape>,
    phantom_Tcrops: PhantomData<Tcrops>,
    crops: Edge<Tcrops>,
    op_name: Option<String>,
    id_: usize,
}

impl<T, Tblock_shape, Tcrops> BatchToSpaceND<T, Tblock_shape, Tcrops>
where T: TensorType,
      T: Clone,
      Tblock_shape: TensorType,
      Tblock_shape: Clone,
      Tcrops: TensorType,
      Tcrops: Clone,
      T: 'static,
      Tblock_shape: con_or_DT_INT32_or_DT_INT64,
      Tblock_shape: 'static,
      Tcrops: con_or_DT_INT32_or_DT_INT64,
      Tcrops: 'static,
{
    pub fn output(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(input: Edge<T>, block_shape: Edge<Tblock_shape>, crops: Edge<Tcrops>) -> Self {
        Self {
            phantom_T: PhantomData,
            input,
            phantom_Tblock_shape: PhantomData,
            block_shape,
            phantom_Tcrops: PhantomData,
            crops,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(input: Edge<T>, block_shape: Edge<Tblock_shape>, crops: Edge<Tcrops>) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            input,
            phantom_Tblock_shape: PhantomData,
            block_shape,
            phantom_Tcrops: PhantomData,
            crops,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

pub trait con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_QINT16_or_DT_QUINT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_QINT16_or_DT_QUINT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64 for BFloat16 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_QINT16_or_DT_QUINT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64 for OtherComplex<f32> {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_QINT16_or_DT_QUINT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64 for OtherComplex<f64> {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_QINT16_or_DT_QUINT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64 for f32 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_QINT16_or_DT_QUINT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64 for f64 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_QINT16_or_DT_QUINT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64 for i16 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_QINT16_or_DT_QUINT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64 for i32 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_QINT16_or_DT_QUINT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64 for i64 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_QINT16_or_DT_QUINT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64 for i8 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_QINT16_or_DT_QUINT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64 for u16 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_QINT16_or_DT_QUINT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64 for u32 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_QINT16_or_DT_QUINT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64 for u64 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_QINT16_or_DT_QUINT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64 for u8 {
}

impl<T, type_> GraphOperation for Bitcast<T, type_>
where T: TensorType,
      T: Clone,
      type_: TensorType,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_QINT16_or_DT_QUINT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
      type_: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_QINT16_or_DT_QUINT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      type_: 'static,
      type_: Clone,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("Bitcast_{}")?
        };
        let mut new_op = graph.new_operation("Bitcast", &op_name)?;
        {
            new_op.add_edge(&self.input)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct Bitcast<T, type_>
where T: TensorType,
      T: Clone,
      type_: TensorType,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_QINT16_or_DT_QUINT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
      type_: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_QINT16_or_DT_QUINT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      type_: 'static,
      type_: Clone,
{
    phantom_T: PhantomData<T>,
    input: Edge<T>,
    phantom_type_: PhantomData<type_>,
    op_name: Option<String>,
    id_: usize,
}

impl<T, type_> Bitcast<T, type_>
where T: TensorType,
      T: Clone,
      type_: TensorType,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_QINT16_or_DT_QUINT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
      type_: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_QINT16_or_DT_QUINT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      type_: 'static,
      type_: Clone,
{
    pub fn output(self) -> Edge<type_> {
        let rc = Rc::new(self);
        {
            Edge::<type_>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<type_> {
        let rc = Rc::new(self);
        {
            Edge::<type_>::new(rc.clone(), 0)
        }
    }

    pub fn build(input: Edge<T>) -> Self {
        Self {
            phantom_T: PhantomData,
            input,
            phantom_type_: PhantomData,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(input: Edge<T>) -> Edge<type_> {
        Self {
            phantom_T: PhantomData,
            input,
            phantom_type_: PhantomData,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<T> GraphOperation for Where<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_BOOL_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("Where_{}")?
        };
        let mut new_op = graph.new_operation("Where", &op_name)?;
        {
            new_op.add_edge(&self.input)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct Where<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_BOOL_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    input: Edge<T>,
    op_name: Option<String>,
    id_: usize,
}

impl<T> Where<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_BOOL_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
{
    pub fn index(self) -> Edge<i64> {
        let rc = Rc::new(self);
        {
            Edge::<i64>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<i64> {
        let rc = Rc::new(self);
        {
            Edge::<i64>::new(rc.clone(), 0)
        }
    }

    pub fn build(input: Edge<T>) -> Self {
        Self {
            phantom_T: PhantomData,
            input,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(input: Edge<T>) -> Edge<i64> {
        Self {
            phantom_T: PhantomData,
            input,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<T> GraphOperation for QuantizeAndDequantize<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
      T: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("QuantizeAndDequantize_{}")?
        };
        let mut new_op = graph.new_operation("QuantizeAndDequantize", &op_name)?;
        {
            new_op.add_edge(&self.input)?
        }
        {
            match self.signed_input {
                None => new_op.set_attr_value_proto("signed_input", &vec![40_u8, 1_u8,])?,
                Some(ref value) => (|attr: &bool| {new_op.set_attr_bool("signed_input", *attr)})(&value)?,
            };
        }
        {
            match self.num_bits {
                None => new_op.set_attr_value_proto("num_bits", &vec![24_u8, 8_u8,])?,
                Some(ref value) => (|attr: &i64| {new_op.set_attr_int("num_bits", *attr)})(&value)?,
            };
        }
        {
            match self.range_given {
                None => new_op.set_attr_value_proto("range_given", &vec![40_u8, 0_u8,])?,
                Some(ref value) => (|attr: &bool| {new_op.set_attr_bool("range_given", *attr)})(&value)?,
            };
        }
        {
            match self.input_min {
                None => new_op.set_attr_value_proto("input_min", &vec![37_u8, 0_u8, 0_u8, 0_u8, 0_u8,])?,
                Some(ref value) => (|attr: &f32| {new_op.set_attr_float("input_min", *attr)})(&value)?,
            };
        }
        {
            match self.input_max {
                None => new_op.set_attr_value_proto("input_max", &vec![37_u8, 0_u8, 0_u8, 0_u8, 0_u8,])?,
                Some(ref value) => (|attr: &f32| {new_op.set_attr_float("input_max", *attr)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct QuantizeAndDequantize<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    input: Edge<T>,
    signed_input: Option<bool>,
    num_bits: Option<i64>,
    range_given: Option<bool>,
    input_min: Option<f32>,
    input_max: Option<f32>,
    op_name: Option<String>,
    id_: usize,
}

impl<T> QuantizeAndDequantize<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
      T: 'static,
{
    pub fn output(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn signed_input(&mut self, signed_input: bool) -> Self {
        self.signed_input = Some(signed_input);
        self.clone()
    }

    pub fn num_bits(&mut self, num_bits: i64) -> Self {
        self.num_bits = Some(num_bits);
        self.clone()
    }

    pub fn range_given(&mut self, range_given: bool) -> Self {
        self.range_given = Some(range_given);
        self.clone()
    }

    pub fn input_min(&mut self, input_min: f32) -> Self {
        self.input_min = Some(input_min);
        self.clone()
    }

    pub fn input_max(&mut self, input_max: f32) -> Self {
        self.input_max = Some(input_max);
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(input: Edge<T>) -> Self {
        Self {
            phantom_T: PhantomData,
            input,
            signed_input: None,
            num_bits: None,
            range_given: None,
            input_min: None,
            input_max: None,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(input: Edge<T>) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            input,
            signed_input: None,
            num_bits: None,
            range_given: None,
            input_min: None,
            input_max: None,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl GraphOperation for SdcaOptimizerV2 {
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("SdcaOptimizerV2_{}")?
        };
        let mut new_op = graph.new_operation("SdcaOptimizerV2", &op_name)?;
        {
            new_op.add_edge(&self.sparse_example_indices)?
        }
        {
            new_op.add_edge(&self.sparse_feature_indices)?
        }
        {
            new_op.add_edge(&self.sparse_feature_values)?
        }
        {
            new_op.add_edge(&self.dense_features)?
        }
        {
            new_op.add_edge(&self.example_weights)?
        }
        {
            new_op.add_edge(&self.example_labels)?
        }
        {
            new_op.add_edge(&self.sparse_indices)?
        }
        {
            new_op.add_edge(&self.sparse_weights)?
        }
        {
            new_op.add_edge(&self.dense_weights)?
        }
        {
            new_op.add_edge(&self.example_state_data)?
        }
        {
            (|attr| {new_op.set_attr_string("loss_type", attr)})(&self.loss_type)?
        }
        {
            match self.adaptive {
                None => new_op.set_attr_value_proto("adaptive", &vec![40_u8, 0_u8,])?,
                Some(ref value) => (|attr: &bool| {new_op.set_attr_bool("adaptive", *attr)})(&value)?,
            };
        }
        {
            (|attr: &i64| {new_op.set_attr_int("num_sparse_features", *attr)})(&self.num_sparse_features)?
        }
        {
            (|attr: &i64| {new_op.set_attr_int("num_sparse_features_with_values", *attr)})(&self.num_sparse_features_with_values)?
        }
        {
            (|attr: &i64| {new_op.set_attr_int("num_dense_features", *attr)})(&self.num_dense_features)?
        }
        {
            (|attr: &f32| {new_op.set_attr_float("l1", *attr)})(&self.l1)?
        }
        {
            (|attr: &f32| {new_op.set_attr_float("l2", *attr)})(&self.l2)?
        }
        {
            (|attr: &i64| {new_op.set_attr_int("num_loss_partitions", *attr)})(&self.num_loss_partitions)?
        }
        {
            (|attr: &i64| {new_op.set_attr_int("num_inner_iterations", *attr)})(&self.num_inner_iterations)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct SdcaOptimizerV2 {
    sparse_example_indices: Edge<i64>,
    sparse_feature_indices: Edge<i64>,
    sparse_feature_values: Edge<f32>,
    dense_features: Edge<f32>,
    example_weights: Edge<f32>,
    example_labels: Edge<f32>,
    sparse_indices: Edge<i64>,
    sparse_weights: Edge<f32>,
    dense_weights: Edge<f32>,
    example_state_data: Edge<f32>,
    loss_type: String,
    adaptive: Option<bool>,
    num_sparse_features: i64,
    num_sparse_features_with_values: i64,
    num_dense_features: i64,
    l1: f32,
    l2: f32,
    num_loss_partitions: i64,
    num_inner_iterations: i64,
    op_name: Option<String>,
    id_: usize,
}

impl SdcaOptimizerV2 {
    pub fn out_example_state_data(self) -> Edge<f32> {
        let rc = Rc::new(self);
        {
            Edge::<f32>::new(rc.clone(), 0)
        }
    }

    pub fn out_delta_sparse_weights(self) -> Edge<f32> {
        let rc = Rc::new(self);
        {
            Edge::<f32>::new(rc.clone(), 1)
        }
    }

    pub fn out_delta_dense_weights(self) -> Edge<f32> {
        let rc = Rc::new(self);
        {
            Edge::<f32>::new(rc.clone(), 2)
        }
    }

    pub fn adaptive(&mut self, adaptive: bool) -> Self {
        self.adaptive = Some(adaptive);
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> (Edge<f32>, Edge<f32>, Edge<f32>) {
        let rc = Rc::new(self);
        (
        {
            Edge::<f32>::new(rc.clone(), 0)
        },
        {
            Edge::<f32>::new(rc.clone(), 1)
        },
        {
            Edge::<f32>::new(rc.clone(), 2)
        },
        )
    }

    pub fn build(sparse_example_indices: Edge<i64>, sparse_feature_indices: Edge<i64>, sparse_feature_values: Edge<f32>, dense_features: Edge<f32>, example_weights: Edge<f32>, example_labels: Edge<f32>, sparse_indices: Edge<i64>, sparse_weights: Edge<f32>, dense_weights: Edge<f32>, example_state_data: Edge<f32>, loss_type: &str, num_sparse_features: i64, num_sparse_features_with_values: i64, num_dense_features: i64, l1: f32, l2: f32, num_loss_partitions: i64, num_inner_iterations: i64) -> Self {
        Self {
            sparse_example_indices,
            sparse_feature_indices,
            sparse_feature_values,
            dense_features,
            example_weights,
            example_labels,
            sparse_indices,
            sparse_weights,
            dense_weights,
            example_state_data,
            loss_type: loss_type.to_string(),
            adaptive: None,
            num_sparse_features: num_sparse_features,
            num_sparse_features_with_values: num_sparse_features_with_values,
            num_dense_features: num_dense_features,
            l1: l1,
            l2: l2,
            num_loss_partitions: num_loss_partitions,
            num_inner_iterations: num_inner_iterations,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(sparse_example_indices: Edge<i64>, sparse_feature_indices: Edge<i64>, sparse_feature_values: Edge<f32>, dense_features: Edge<f32>, example_weights: Edge<f32>, example_labels: Edge<f32>, sparse_indices: Edge<i64>, sparse_weights: Edge<f32>, dense_weights: Edge<f32>, example_state_data: Edge<f32>, loss_type: &str, num_sparse_features: i64, num_sparse_features_with_values: i64, num_dense_features: i64, l1: f32, l2: f32, num_loss_partitions: i64, num_inner_iterations: i64) -> (Edge<f32>, Edge<f32>, Edge<f32>) {
        Self {
            sparse_example_indices,
            sparse_feature_indices,
            sparse_feature_values,
            dense_features,
            example_weights,
            example_labels,
            sparse_indices,
            sparse_weights,
            dense_weights,
            example_state_data,
            loss_type: loss_type.to_string(),
            adaptive: None,
            num_sparse_features: num_sparse_features,
            num_sparse_features_with_values: num_sparse_features_with_values,
            num_dense_features: num_dense_features,
            l1: l1,
            l2: l2,
            num_loss_partitions: num_loss_partitions,
            num_inner_iterations: num_inner_iterations,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<T> GraphOperation for CopyHost<T>
where T: TensorType,
      T: Clone,
      T: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("CopyHost_{}")?
        };
        let mut new_op = graph.new_operation("CopyHost", &op_name)?;
        {
            new_op.add_edge(&self.input)?
        }
        {
            match self.tensor_name {
                None => new_op.set_attr_value_proto("tensor_name", &vec![18_u8, 0_u8,])?,
                Some(ref value) => (|attr| {new_op.set_attr_string("tensor_name", attr)})(&value)?,
            };
        }
        {
            match self.debug_ops_spec {
                None => new_op.set_attr_value_proto("debug_ops_spec", &vec![10_u8, 0_u8,])?,
                Some(ref value) => (|attrs| {new_op.set_attr_string_list("debug_ops_spec", attrs)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct CopyHost<T>
where T: TensorType,
      T: Clone,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    input: Edge<T>,
    tensor_name: Option<String>,
    debug_ops_spec: Option<Vec<String>>,
    op_name: Option<String>,
    id_: usize,
}

impl<T> CopyHost<T>
where T: TensorType,
      T: Clone,
      T: 'static,
{
    pub fn output(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn tensor_name(&mut self, tensor_name: &str) -> Self {
        self.tensor_name = Some(tensor_name.to_string());
        self.clone()
    }

    pub fn debug_ops_spec(&mut self, debug_ops_spec: &[String]) -> Self {
        self.debug_ops_spec = Some(debug_ops_spec.to_vec());
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(input: Edge<T>) -> Self {
        Self {
            phantom_T: PhantomData,
            input,
            tensor_name: None,
            debug_ops_spec: None,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(input: Edge<T>) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            input,
            tensor_name: None,
            debug_ops_spec: None,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<T> GraphOperation for FractionalMaxPoolGrad<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_INT64,
      T: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("FractionalMaxPoolGrad_{}")?
        };
        let mut new_op = graph.new_operation("FractionalMaxPoolGrad", &op_name)?;
        {
            new_op.add_edge(&self.orig_input)?
        }
        {
            new_op.add_edge(&self.orig_output)?
        }
        {
            new_op.add_edge(&self.out_backprop)?
        }
        {
            new_op.add_edge(&self.row_pooling_sequence)?
        }
        {
            new_op.add_edge(&self.col_pooling_sequence)?
        }
        {
            match self.overlapping {
                None => new_op.set_attr_value_proto("overlapping", &vec![40_u8, 0_u8,])?,
                Some(ref value) => (|attr: &bool| {new_op.set_attr_bool("overlapping", *attr)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct FractionalMaxPoolGrad<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_INT64,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    orig_input: Edge<T>,
    orig_output: Edge<T>,
    out_backprop: Edge<T>,
    row_pooling_sequence: Edge<i64>,
    col_pooling_sequence: Edge<i64>,
    overlapping: Option<bool>,
    op_name: Option<String>,
    id_: usize,
}

impl<T> FractionalMaxPoolGrad<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_INT64,
      T: 'static,
{
    pub fn output(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn overlapping(&mut self, overlapping: bool) -> Self {
        self.overlapping = Some(overlapping);
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(orig_input: Edge<T>, orig_output: Edge<T>, out_backprop: Edge<T>, row_pooling_sequence: Edge<i64>, col_pooling_sequence: Edge<i64>) -> Self {
        Self {
            phantom_T: PhantomData,
            orig_input,
            orig_output,
            out_backprop,
            row_pooling_sequence,
            col_pooling_sequence,
            overlapping: None,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(orig_input: Edge<T>, orig_output: Edge<T>, out_backprop: Edge<T>, row_pooling_sequence: Edge<i64>, col_pooling_sequence: Edge<i64>) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            orig_input,
            orig_output,
            out_backprop,
            row_pooling_sequence,
            col_pooling_sequence,
            overlapping: None,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<T, out_type> GraphOperation for UpperBound<T, out_type>
where T: TensorType,
      T: Clone,
      out_type: TensorType,
      T: 'static,
      out_type: con_or_DT_INT32_or_DT_INT64,
      out_type: 'static,
      out_type: Clone,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("UpperBound_{}")?
        };
        let mut new_op = graph.new_operation("UpperBound", &op_name)?;
        {
            new_op.add_edge(&self.sorted_inputs)?
        }
        {
            new_op.add_edge(&self.values)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct UpperBound<T, out_type>
where T: TensorType,
      T: Clone,
      out_type: TensorType,
      T: 'static,
      out_type: con_or_DT_INT32_or_DT_INT64,
      out_type: 'static,
      out_type: Clone,
{
    phantom_T: PhantomData<T>,
    sorted_inputs: Edge<T>,
    values: Edge<T>,
    phantom_out_type: PhantomData<out_type>,
    op_name: Option<String>,
    id_: usize,
}

impl<T, out_type> UpperBound<T, out_type>
where T: TensorType,
      T: Clone,
      out_type: TensorType,
      T: 'static,
      out_type: con_or_DT_INT32_or_DT_INT64,
      out_type: 'static,
      out_type: Clone,
{
    pub fn output(self) -> Edge<out_type> {
        let rc = Rc::new(self);
        {
            Edge::<out_type>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<out_type> {
        let rc = Rc::new(self);
        {
            Edge::<out_type>::new(rc.clone(), 0)
        }
    }

    pub fn build(sorted_inputs: Edge<T>, values: Edge<T>) -> Self {
        Self {
            phantom_T: PhantomData,
            sorted_inputs,
            values,
            phantom_out_type: PhantomData,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(sorted_inputs: Edge<T>, values: Edge<T>) -> Edge<out_type> {
        Self {
            phantom_T: PhantomData,
            sorted_inputs,
            values,
            phantom_out_type: PhantomData,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl GraphOperation for RetrieveTPUEmbeddingADAMParametersGradAccumDebug {
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("RetrieveTPUEmbeddingADAMParametersGradAccumDebug_{}")?
        };
        let mut new_op = graph.new_operation("RetrieveTPUEmbeddingADAMParametersGradAccumDebug", &op_name)?;
        {
            match self.table_id {
                None => new_op.set_attr_value_proto("table_id", &vec![24_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 1_u8,])?,
                Some(ref value) => (|attr: &i64| {new_op.set_attr_int("table_id", *attr)})(&value)?,
            };
        }
        {
            match self.table_name {
                None => new_op.set_attr_value_proto("table_name", &vec![18_u8, 0_u8,])?,
                Some(ref value) => (|attr| {new_op.set_attr_string("table_name", attr)})(&value)?,
            };
        }
        {
            (|attr: &i64| {new_op.set_attr_int("num_shards", *attr)})(&self.num_shards)?
        }
        {
            (|attr: &i64| {new_op.set_attr_int("shard_id", *attr)})(&self.shard_id)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct RetrieveTPUEmbeddingADAMParametersGradAccumDebug {
    table_id: Option<i64>,
    table_name: Option<String>,
    num_shards: i64,
    shard_id: i64,
    op_name: Option<String>,
    id_: usize,
}

impl RetrieveTPUEmbeddingADAMParametersGradAccumDebug {
    pub fn parameters(self) -> Edge<f32> {
        let rc = Rc::new(self);
        {
            Edge::<f32>::new(rc.clone(), 0)
        }
    }

    pub fn momenta(self) -> Edge<f32> {
        let rc = Rc::new(self);
        {
            Edge::<f32>::new(rc.clone(), 1)
        }
    }

    pub fn velocities(self) -> Edge<f32> {
        let rc = Rc::new(self);
        {
            Edge::<f32>::new(rc.clone(), 2)
        }
    }

    pub fn gradient_accumulators(self) -> Edge<f32> {
        let rc = Rc::new(self);
        {
            Edge::<f32>::new(rc.clone(), 3)
        }
    }

    pub fn table_id(&mut self, table_id: i64) -> Self {
        self.table_id = Some(table_id);
        self.clone()
    }

    pub fn table_name(&mut self, table_name: &str) -> Self {
        self.table_name = Some(table_name.to_string());
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> (Edge<f32>, Edge<f32>, Edge<f32>, Edge<f32>) {
        let rc = Rc::new(self);
        (
        {
            Edge::<f32>::new(rc.clone(), 0)
        },
        {
            Edge::<f32>::new(rc.clone(), 1)
        },
        {
            Edge::<f32>::new(rc.clone(), 2)
        },
        {
            Edge::<f32>::new(rc.clone(), 3)
        },
        )
    }

    pub fn build(num_shards: i64, shard_id: i64) -> Self {
        Self {
            table_id: None,
            table_name: None,
            num_shards: num_shards,
            shard_id: shard_id,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(num_shards: i64, shard_id: i64) -> (Edge<f32>, Edge<f32>, Edge<f32>, Edge<f32>) {
        Self {
            table_id: None,
            table_name: None,
            num_shards: num_shards,
            shard_id: shard_id,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<dtype> GraphOperation for _ParallelConcatStart<dtype>
where dtype: TensorType,
      dtype: 'static,
      dtype: Clone,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("_ParallelConcatStart_{}")?
        };
        let mut new_op = graph.new_operation("_ParallelConcatStart", &op_name)?;
        {
            (|attr| {new_op.set_attr_shape("shape", attr)})(&self.shape)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct _ParallelConcatStart<dtype>
where dtype: TensorType,
      dtype: 'static,
      dtype: Clone,
{
    shape: OtherShape,
    phantom_dtype: PhantomData<dtype>,
    op_name: Option<String>,
    id_: usize,
}

impl<dtype> _ParallelConcatStart<dtype>
where dtype: TensorType,
      dtype: 'static,
      dtype: Clone,
{
    pub fn output(self) -> Edge<dtype> {
        let rc = Rc::new(self);
        {
            Edge::<dtype>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<dtype> {
        let rc = Rc::new(self);
        {
            Edge::<dtype>::new(rc.clone(), 0)
        }
    }

    pub fn build(shape: &OtherShape) -> Self {
        Self {
            shape: shape.clone(),
            phantom_dtype: PhantomData,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(shape: &OtherShape) -> Edge<dtype> {
        Self {
            shape: shape.clone(),
            phantom_dtype: PhantomData,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<T, out_type> GraphOperation for LowerBound<T, out_type>
where T: TensorType,
      T: Clone,
      out_type: TensorType,
      T: 'static,
      out_type: con_or_DT_INT32_or_DT_INT64,
      out_type: 'static,
      out_type: Clone,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("LowerBound_{}")?
        };
        let mut new_op = graph.new_operation("LowerBound", &op_name)?;
        {
            new_op.add_edge(&self.sorted_inputs)?
        }
        {
            new_op.add_edge(&self.values)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct LowerBound<T, out_type>
where T: TensorType,
      T: Clone,
      out_type: TensorType,
      T: 'static,
      out_type: con_or_DT_INT32_or_DT_INT64,
      out_type: 'static,
      out_type: Clone,
{
    phantom_T: PhantomData<T>,
    sorted_inputs: Edge<T>,
    values: Edge<T>,
    phantom_out_type: PhantomData<out_type>,
    op_name: Option<String>,
    id_: usize,
}

impl<T, out_type> LowerBound<T, out_type>
where T: TensorType,
      T: Clone,
      out_type: TensorType,
      T: 'static,
      out_type: con_or_DT_INT32_or_DT_INT64,
      out_type: 'static,
      out_type: Clone,
{
    pub fn output(self) -> Edge<out_type> {
        let rc = Rc::new(self);
        {
            Edge::<out_type>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<out_type> {
        let rc = Rc::new(self);
        {
            Edge::<out_type>::new(rc.clone(), 0)
        }
    }

    pub fn build(sorted_inputs: Edge<T>, values: Edge<T>) -> Self {
        Self {
            phantom_T: PhantomData,
            sorted_inputs,
            values,
            phantom_out_type: PhantomData,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(sorted_inputs: Edge<T>, values: Edge<T>) -> Edge<out_type> {
        Self {
            phantom_T: PhantomData,
            sorted_inputs,
            values,
            phantom_out_type: PhantomData,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<T> GraphOperation for CheckNumerics<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
      T: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("CheckNumerics_{}")?
        };
        let mut new_op = graph.new_operation("CheckNumerics", &op_name)?;
        {
            new_op.add_edge(&self.tensor)?
        }
        {
            (|attr| {new_op.set_attr_string("message", attr)})(&self.message)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct CheckNumerics<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    tensor: Edge<T>,
    message: String,
    op_name: Option<String>,
    id_: usize,
}

impl<T> CheckNumerics<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
      T: 'static,
{
    pub fn output(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(tensor: Edge<T>, message: &str) -> Self {
        Self {
            phantom_T: PhantomData,
            tensor,
            message: message.to_string(),
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(tensor: Edge<T>, message: &str) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            tensor,
            message: message.to_string(),
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<T, Taxis, out_idx> GraphOperation for UniqueWithCountsV2<T, Taxis, out_idx>
where T: TensorType,
      T: Clone,
      Taxis: TensorType,
      Taxis: Clone,
      out_idx: TensorType,
      T: 'static,
      Taxis: con_or_DT_INT32_or_DT_INT64,
      Taxis: 'static,
      out_idx: con_or_DT_INT32_or_DT_INT64,
      out_idx: 'static,
      out_idx: Clone,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("UniqueWithCountsV2_{}")?
        };
        let mut new_op = graph.new_operation("UniqueWithCountsV2", &op_name)?;
        {
            new_op.add_edge(&self.x)?
        }
        {
            new_op.add_edge(&self.axis)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct UniqueWithCountsV2<T, Taxis, out_idx>
where T: TensorType,
      T: Clone,
      Taxis: TensorType,
      Taxis: Clone,
      out_idx: TensorType,
      T: 'static,
      Taxis: con_or_DT_INT32_or_DT_INT64,
      Taxis: 'static,
      out_idx: con_or_DT_INT32_or_DT_INT64,
      out_idx: 'static,
      out_idx: Clone,
{
    phantom_T: PhantomData<T>,
    x: Edge<T>,
    phantom_Taxis: PhantomData<Taxis>,
    axis: Edge<Taxis>,
    phantom_out_idx: PhantomData<out_idx>,
    op_name: Option<String>,
    id_: usize,
}

impl<T, Taxis, out_idx> UniqueWithCountsV2<T, Taxis, out_idx>
where T: TensorType,
      T: Clone,
      Taxis: TensorType,
      Taxis: Clone,
      out_idx: TensorType,
      T: 'static,
      Taxis: con_or_DT_INT32_or_DT_INT64,
      Taxis: 'static,
      out_idx: con_or_DT_INT32_or_DT_INT64,
      out_idx: 'static,
      out_idx: Clone,
{
    pub fn y(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn idx(self) -> Edge<out_idx> {
        let rc = Rc::new(self);
        {
            Edge::<out_idx>::new(rc.clone(), 1)
        }
    }

    pub fn count(self) -> Edge<out_idx> {
        let rc = Rc::new(self);
        {
            Edge::<out_idx>::new(rc.clone(), 2)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> (Edge<T>, Edge<out_idx>, Edge<out_idx>) {
        let rc = Rc::new(self);
        (
        {
            Edge::<T>::new(rc.clone(), 0)
        },
        {
            Edge::<out_idx>::new(rc.clone(), 1)
        },
        {
            Edge::<out_idx>::new(rc.clone(), 2)
        },
        )
    }

    pub fn build(x: Edge<T>, axis: Edge<Taxis>) -> Self {
        Self {
            phantom_T: PhantomData,
            x,
            phantom_Taxis: PhantomData,
            axis,
            phantom_out_idx: PhantomData,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(x: Edge<T>, axis: Edge<Taxis>) -> (Edge<T>, Edge<out_idx>, Edge<out_idx>) {
        Self {
            phantom_T: PhantomData,
            x,
            phantom_Taxis: PhantomData,
            axis,
            phantom_out_idx: PhantomData,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl GraphOperation for LookupTableSize {
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("LookupTableSize_{}")?
        };
        let mut new_op = graph.new_operation("LookupTableSize", &op_name)?;
        {
            new_op.add_edge(&self.table_handle)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct LookupTableSize {
    table_handle: Edge<String>,
    op_name: Option<String>,
    id_: usize,
}

impl LookupTableSize {
    pub fn size(self) -> Edge<i64> {
        let rc = Rc::new(self);
        {
            Edge::<i64>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<i64> {
        let rc = Rc::new(self);
        {
            Edge::<i64>::new(rc.clone(), 0)
        }
    }

    pub fn build(table_handle: Edge<String>) -> Self {
        Self {
            table_handle,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(table_handle: Edge<String>) -> Edge<i64> {
        Self {
            table_handle,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<T> GraphOperation for MatrixTriangularSolve<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_COMPLEX64_or_DT_COMPLEX128,
      T: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("MatrixTriangularSolve_{}")?
        };
        let mut new_op = graph.new_operation("MatrixTriangularSolve", &op_name)?;
        {
            new_op.add_edge(&self.matrix)?
        }
        {
            new_op.add_edge(&self.rhs)?
        }
        {
            match self.lower {
                None => new_op.set_attr_value_proto("lower", &vec![40_u8, 1_u8,])?,
                Some(ref value) => (|attr: &bool| {new_op.set_attr_bool("lower", *attr)})(&value)?,
            };
        }
        {
            match self.adjoint {
                None => new_op.set_attr_value_proto("adjoint", &vec![40_u8, 0_u8,])?,
                Some(ref value) => (|attr: &bool| {new_op.set_attr_bool("adjoint", *attr)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct MatrixTriangularSolve<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_COMPLEX64_or_DT_COMPLEX128,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    matrix: Edge<T>,
    rhs: Edge<T>,
    lower: Option<bool>,
    adjoint: Option<bool>,
    op_name: Option<String>,
    id_: usize,
}

impl<T> MatrixTriangularSolve<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_COMPLEX64_or_DT_COMPLEX128,
      T: 'static,
{
    pub fn output(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn lower(&mut self, lower: bool) -> Self {
        self.lower = Some(lower);
        self.clone()
    }

    pub fn adjoint(&mut self, adjoint: bool) -> Self {
        self.adjoint = Some(adjoint);
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(matrix: Edge<T>, rhs: Edge<T>) -> Self {
        Self {
            phantom_T: PhantomData,
            matrix,
            rhs,
            lower: None,
            adjoint: None,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(matrix: Edge<T>, rhs: Edge<T>) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            matrix,
            rhs,
            lower: None,
            adjoint: None,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl GraphOperation for QueueClose {
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("QueueClose_{}")?
        };
        let mut new_op = graph.new_operation("QueueClose", &op_name)?;
        {
            new_op.add_edge(&self.handle)?
        }
        {
            match self.cancel_pending_enqueues {
                None => new_op.set_attr_value_proto("cancel_pending_enqueues", &vec![40_u8, 0_u8,])?,
                Some(ref value) => (|attr: &bool| {new_op.set_attr_bool("cancel_pending_enqueues", *attr)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct QueueClose {
    handle: Edge<String>,
    cancel_pending_enqueues: Option<bool>,
    op_name: Option<String>,
    id_: usize,
}

impl QueueClose {
    pub fn cancel_pending_enqueues(&mut self, cancel_pending_enqueues: bool) -> Self {
        self.cancel_pending_enqueues = Some(cancel_pending_enqueues);
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> () {
        let rc = Rc::new(self);
        (
        )
    }

    pub fn build(handle: Edge<String>) -> Self {
        Self {
            handle,
            cancel_pending_enqueues: None,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(handle: Edge<String>) -> () {
        Self {
            handle,
            cancel_pending_enqueues: None,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<T> GraphOperation for CropAndResizeGradImage<T>
where T: TensorType,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_HALF,
      T: 'static,
      T: Clone,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("CropAndResizeGradImage_{}")?
        };
        let mut new_op = graph.new_operation("CropAndResizeGradImage", &op_name)?;
        {
            new_op.add_edge(&self.grads)?
        }
        {
            new_op.add_edge(&self.boxes)?
        }
        {
            new_op.add_edge(&self.box_ind)?
        }
        {
            new_op.add_edge(&self.image_size)?
        }
        {
            match self.method {
                None => new_op.set_attr_value_proto("method", &vec![18_u8, 8_u8, 98_u8, 105_u8, 108_u8, 105_u8, 110_u8, 101_u8, 97_u8, 114_u8,])?,
                Some(ref value) => (|attr| {new_op.set_attr_string("method", attr)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct CropAndResizeGradImage<T>
where T: TensorType,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_HALF,
      T: 'static,
      T: Clone,
{
    grads: Edge<f32>,
    boxes: Edge<f32>,
    box_ind: Edge<i32>,
    image_size: Edge<i32>,
    phantom_T: PhantomData<T>,
    method: Option<String>,
    op_name: Option<String>,
    id_: usize,
}

impl<T> CropAndResizeGradImage<T>
where T: TensorType,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_HALF,
      T: 'static,
      T: Clone,
{
    pub fn output(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn method(&mut self, method: &str) -> Self {
        self.method = Some(method.to_string());
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(grads: Edge<f32>, boxes: Edge<f32>, box_ind: Edge<i32>, image_size: Edge<i32>) -> Self {
        Self {
            grads,
            boxes,
            box_ind,
            image_size,
            phantom_T: PhantomData,
            method: None,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(grads: Edge<f32>, boxes: Edge<f32>, box_ind: Edge<i32>, image_size: Edge<i32>) -> Edge<T> {
        Self {
            grads,
            boxes,
            box_ind,
            image_size,
            phantom_T: PhantomData,
            method: None,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<T, Tindices> GraphOperation for SegmentSum<T, Tindices>
where T: TensorType,
      T: Clone,
      Tindices: TensorType,
      Tindices: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
      Tindices: con_or_DT_INT32_or_DT_INT64,
      Tindices: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("SegmentSum_{}")?
        };
        let mut new_op = graph.new_operation("SegmentSum", &op_name)?;
        {
            new_op.add_edge(&self.data)?
        }
        {
            new_op.add_edge(&self.segment_ids)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct SegmentSum<T, Tindices>
where T: TensorType,
      T: Clone,
      Tindices: TensorType,
      Tindices: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
      Tindices: con_or_DT_INT32_or_DT_INT64,
      Tindices: 'static,
{
    phantom_T: PhantomData<T>,
    data: Edge<T>,
    phantom_Tindices: PhantomData<Tindices>,
    segment_ids: Edge<Tindices>,
    op_name: Option<String>,
    id_: usize,
}

impl<T, Tindices> SegmentSum<T, Tindices>
where T: TensorType,
      T: Clone,
      Tindices: TensorType,
      Tindices: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
      Tindices: con_or_DT_INT32_or_DT_INT64,
      Tindices: 'static,
{
    pub fn output(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(data: Edge<T>, segment_ids: Edge<Tindices>) -> Self {
        Self {
            phantom_T: PhantomData,
            data,
            phantom_Tindices: PhantomData,
            segment_ids,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(data: Edge<T>, segment_ids: Edge<Tindices>) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            data,
            phantom_Tindices: PhantomData,
            segment_ids,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<T> GraphOperation for BatchMatrixTriangularSolve<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE,
      T: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("BatchMatrixTriangularSolve_{}")?
        };
        let mut new_op = graph.new_operation("BatchMatrixTriangularSolve", &op_name)?;
        {
            new_op.add_edge(&self.matrix)?
        }
        {
            new_op.add_edge(&self.rhs)?
        }
        {
            match self.lower {
                None => new_op.set_attr_value_proto("lower", &vec![40_u8, 1_u8,])?,
                Some(ref value) => (|attr: &bool| {new_op.set_attr_bool("lower", *attr)})(&value)?,
            };
        }
        {
            match self.adjoint {
                None => new_op.set_attr_value_proto("adjoint", &vec![40_u8, 0_u8,])?,
                Some(ref value) => (|attr: &bool| {new_op.set_attr_bool("adjoint", *attr)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct BatchMatrixTriangularSolve<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    matrix: Edge<T>,
    rhs: Edge<T>,
    lower: Option<bool>,
    adjoint: Option<bool>,
    op_name: Option<String>,
    id_: usize,
}

impl<T> BatchMatrixTriangularSolve<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE,
      T: 'static,
{
    pub fn output(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn lower(&mut self, lower: bool) -> Self {
        self.lower = Some(lower);
        self.clone()
    }

    pub fn adjoint(&mut self, adjoint: bool) -> Self {
        self.adjoint = Some(adjoint);
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(matrix: Edge<T>, rhs: Edge<T>) -> Self {
        Self {
            phantom_T: PhantomData,
            matrix,
            rhs,
            lower: None,
            adjoint: None,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(matrix: Edge<T>, rhs: Edge<T>) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            matrix,
            rhs,
            lower: None,
            adjoint: None,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl GraphOperation for ExtractGlimpse {
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("ExtractGlimpse_{}")?
        };
        let mut new_op = graph.new_operation("ExtractGlimpse", &op_name)?;
        {
            new_op.add_edge(&self.input)?
        }
        {
            new_op.add_edge(&self.size)?
        }
        {
            new_op.add_edge(&self.offsets)?
        }
        {
            match self.centered {
                None => new_op.set_attr_value_proto("centered", &vec![40_u8, 1_u8,])?,
                Some(ref value) => (|attr: &bool| {new_op.set_attr_bool("centered", *attr)})(&value)?,
            };
        }
        {
            match self.normalized {
                None => new_op.set_attr_value_proto("normalized", &vec![40_u8, 1_u8,])?,
                Some(ref value) => (|attr: &bool| {new_op.set_attr_bool("normalized", *attr)})(&value)?,
            };
        }
        {
            match self.uniform_noise {
                None => new_op.set_attr_value_proto("uniform_noise", &vec![40_u8, 1_u8,])?,
                Some(ref value) => (|attr: &bool| {new_op.set_attr_bool("uniform_noise", *attr)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct ExtractGlimpse {
    input: Edge<f32>,
    size: Edge<i32>,
    offsets: Edge<f32>,
    centered: Option<bool>,
    normalized: Option<bool>,
    uniform_noise: Option<bool>,
    op_name: Option<String>,
    id_: usize,
}

impl ExtractGlimpse {
    pub fn glimpse(self) -> Edge<f32> {
        let rc = Rc::new(self);
        {
            Edge::<f32>::new(rc.clone(), 0)
        }
    }

    pub fn centered(&mut self, centered: bool) -> Self {
        self.centered = Some(centered);
        self.clone()
    }

    pub fn normalized(&mut self, normalized: bool) -> Self {
        self.normalized = Some(normalized);
        self.clone()
    }

    pub fn uniform_noise(&mut self, uniform_noise: bool) -> Self {
        self.uniform_noise = Some(uniform_noise);
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<f32> {
        let rc = Rc::new(self);
        {
            Edge::<f32>::new(rc.clone(), 0)
        }
    }

    pub fn build(input: Edge<f32>, size: Edge<i32>, offsets: Edge<f32>) -> Self {
        Self {
            input,
            size,
            offsets,
            centered: None,
            normalized: None,
            uniform_noise: None,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(input: Edge<f32>, size: Edge<i32>, offsets: Edge<f32>) -> Edge<f32> {
        Self {
            input,
            size,
            offsets,
            centered: None,
            normalized: None,
            uniform_noise: None,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<T, Tindices> GraphOperation for XlaBroadcastHelper<T, Tindices>
where T: TensorType,
      T: Clone,
      Tindices: TensorType,
      Tindices: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
      Tindices: con_or_DT_INT32_or_DT_INT64,
      Tindices: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("XlaBroadcastHelper_{}")?
        };
        let mut new_op = graph.new_operation("XlaBroadcastHelper", &op_name)?;
        {
            new_op.add_edge(&self.lhs)?
        }
        {
            new_op.add_edge(&self.rhs)?
        }
        {
            new_op.add_edge(&self.broadcast_dims)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct XlaBroadcastHelper<T, Tindices>
where T: TensorType,
      T: Clone,
      Tindices: TensorType,
      Tindices: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
      Tindices: con_or_DT_INT32_or_DT_INT64,
      Tindices: 'static,
{
    phantom_T: PhantomData<T>,
    lhs: Edge<T>,
    rhs: Edge<T>,
    phantom_Tindices: PhantomData<Tindices>,
    broadcast_dims: Edge<Tindices>,
    op_name: Option<String>,
    id_: usize,
}

impl<T, Tindices> XlaBroadcastHelper<T, Tindices>
where T: TensorType,
      T: Clone,
      Tindices: TensorType,
      Tindices: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
      Tindices: con_or_DT_INT32_or_DT_INT64,
      Tindices: 'static,
{
    pub fn lhs_output(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn rhs_output(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 1)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> (Edge<T>, Edge<T>) {
        let rc = Rc::new(self);
        (
        {
            Edge::<T>::new(rc.clone(), 0)
        },
        {
            Edge::<T>::new(rc.clone(), 1)
        },
        )
    }

    pub fn build(lhs: Edge<T>, rhs: Edge<T>, broadcast_dims: Edge<Tindices>) -> Self {
        Self {
            phantom_T: PhantomData,
            lhs,
            rhs,
            phantom_Tindices: PhantomData,
            broadcast_dims,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(lhs: Edge<T>, rhs: Edge<T>, broadcast_dims: Edge<Tindices>) -> (Edge<T>, Edge<T>) {
        Self {
            phantom_T: PhantomData,
            lhs,
            rhs,
            phantom_Tindices: PhantomData,
            broadcast_dims,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<T> GraphOperation for InvGrad<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_COMPLEX64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF,
      T: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("InvGrad_{}")?
        };
        let mut new_op = graph.new_operation("InvGrad", &op_name)?;
        {
            new_op.add_edge(&self.y)?
        }
        {
            new_op.add_edge(&self.dy)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct InvGrad<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_COMPLEX64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    y: Edge<T>,
    dy: Edge<T>,
    op_name: Option<String>,
    id_: usize,
}

impl<T> InvGrad<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_COMPLEX64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF,
      T: 'static,
{
    pub fn z(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(y: Edge<T>, dy: Edge<T>) -> Self {
        Self {
            phantom_T: PhantomData,
            y,
            dy,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(y: Edge<T>, dy: Edge<T>) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            y,
            dy,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<component_types> GraphOperation for RandomShuffleQueue<component_types>
where component_types: 'static,
      component_types: Clone,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("RandomShuffleQueue_{}")?
        };
        let mut new_op = graph.new_operation("RandomShuffleQueue", &op_name)?;
        {
            match self.shapes {
                None => new_op.set_attr_value_proto("shapes", &vec![10_u8, 0_u8,])?,
                Some(ref value) => (|attrs| {new_op.set_attr_shape_list("shapes", attrs)})(&value)?,
            };
        }
        {
            match self.capacity {
                None => new_op.set_attr_value_proto("capacity", &vec![24_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 1_u8,])?,
                Some(ref value) => (|attr: &i64| {new_op.set_attr_int("capacity", *attr)})(&value)?,
            };
        }
        {
            match self.min_after_dequeue {
                None => new_op.set_attr_value_proto("min_after_dequeue", &vec![24_u8, 0_u8,])?,
                Some(ref value) => (|attr: &i64| {new_op.set_attr_int("min_after_dequeue", *attr)})(&value)?,
            };
        }
        {
            match self.seed {
                None => new_op.set_attr_value_proto("seed", &vec![24_u8, 0_u8,])?,
                Some(ref value) => (|attr: &i64| {new_op.set_attr_int("seed", *attr)})(&value)?,
            };
        }
        {
            match self.seed2 {
                None => new_op.set_attr_value_proto("seed2", &vec![24_u8, 0_u8,])?,
                Some(ref value) => (|attr: &i64| {new_op.set_attr_int("seed2", *attr)})(&value)?,
            };
        }
        {
            match self.container {
                None => new_op.set_attr_value_proto("container", &vec![18_u8, 0_u8,])?,
                Some(ref value) => (|attr| {new_op.set_attr_string("container", attr)})(&value)?,
            };
        }
        {
            match self.shared_name {
                None => new_op.set_attr_value_proto("shared_name", &vec![18_u8, 0_u8,])?,
                Some(ref value) => (|attr| {new_op.set_attr_string("shared_name", attr)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct RandomShuffleQueue<component_types>
where component_types: 'static,
      component_types: Clone,
{
    phantom_component_types: PhantomData<component_types>,
    shapes: Option<Vec<OtherShape>>,
    capacity: Option<i64>,
    min_after_dequeue: Option<i64>,
    seed: Option<i64>,
    seed2: Option<i64>,
    container: Option<String>,
    shared_name: Option<String>,
    op_name: Option<String>,
    id_: usize,
}

impl<component_types> RandomShuffleQueue<component_types>
where component_types: 'static,
      component_types: Clone,
{
    pub fn handle(self) -> Edge<String> {
        let rc = Rc::new(self);
        {
            Edge::<String>::new(rc.clone(), 0)
        }
    }

    pub fn shapes(&mut self, shapes: &[OtherShape]) -> Self {
        self.shapes = Some(shapes.to_vec());
        self.clone()
    }

    pub fn capacity(&mut self, capacity: i64) -> Self {
        self.capacity = Some(capacity);
        self.clone()
    }

    pub fn min_after_dequeue(&mut self, min_after_dequeue: i64) -> Self {
        self.min_after_dequeue = Some(min_after_dequeue);
        self.clone()
    }

    pub fn seed(&mut self, seed: i64) -> Self {
        self.seed = Some(seed);
        self.clone()
    }

    pub fn seed2(&mut self, seed2: i64) -> Self {
        self.seed2 = Some(seed2);
        self.clone()
    }

    pub fn container(&mut self, container: &str) -> Self {
        self.container = Some(container.to_string());
        self.clone()
    }

    pub fn shared_name(&mut self, shared_name: &str) -> Self {
        self.shared_name = Some(shared_name.to_string());
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<String> {
        let rc = Rc::new(self);
        {
            Edge::<String>::new(rc.clone(), 0)
        }
    }

    pub fn build() -> Self {
        Self {
            phantom_component_types: PhantomData,
            shapes: None,
            capacity: None,
            min_after_dequeue: None,
            seed: None,
            seed2: None,
            container: None,
            shared_name: None,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new() -> Edge<String> {
        Self {
            phantom_component_types: PhantomData,
            shapes: None,
            capacity: None,
            min_after_dequeue: None,
            seed: None,
            seed2: None,
            container: None,
            shared_name: None,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl GraphOperation for LoadTPUEmbeddingMDLAdagradLightParameters {
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("LoadTPUEmbeddingMDLAdagradLightParameters_{}")?
        };
        let mut new_op = graph.new_operation("LoadTPUEmbeddingMDLAdagradLightParameters", &op_name)?;
        {
            new_op.add_edge(&self.parameters)?
        }
        {
            new_op.add_edge(&self.accumulators)?
        }
        {
            new_op.add_edge(&self.weights)?
        }
        {
            new_op.add_edge(&self.benefits)?
        }
        {
            match self.table_id {
                None => new_op.set_attr_value_proto("table_id", &vec![24_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 1_u8,])?,
                Some(ref value) => (|attr: &i64| {new_op.set_attr_int("table_id", *attr)})(&value)?,
            };
        }
        {
            match self.table_name {
                None => new_op.set_attr_value_proto("table_name", &vec![18_u8, 0_u8,])?,
                Some(ref value) => (|attr| {new_op.set_attr_string("table_name", attr)})(&value)?,
            };
        }
        {
            (|attr: &i64| {new_op.set_attr_int("num_shards", *attr)})(&self.num_shards)?
        }
        {
            (|attr: &i64| {new_op.set_attr_int("shard_id", *attr)})(&self.shard_id)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct LoadTPUEmbeddingMDLAdagradLightParameters {
    parameters: Edge<f32>,
    accumulators: Edge<f32>,
    weights: Edge<f32>,
    benefits: Edge<f32>,
    table_id: Option<i64>,
    table_name: Option<String>,
    num_shards: i64,
    shard_id: i64,
    op_name: Option<String>,
    id_: usize,
}

impl LoadTPUEmbeddingMDLAdagradLightParameters {
    pub fn table_id(&mut self, table_id: i64) -> Self {
        self.table_id = Some(table_id);
        self.clone()
    }

    pub fn table_name(&mut self, table_name: &str) -> Self {
        self.table_name = Some(table_name.to_string());
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> () {
        let rc = Rc::new(self);
        (
        )
    }

    pub fn build(parameters: Edge<f32>, accumulators: Edge<f32>, weights: Edge<f32>, benefits: Edge<f32>, num_shards: i64, shard_id: i64) -> Self {
        Self {
            parameters,
            accumulators,
            weights,
            benefits,
            table_id: None,
            table_name: None,
            num_shards: num_shards,
            shard_id: shard_id,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(parameters: Edge<f32>, accumulators: Edge<f32>, weights: Edge<f32>, benefits: Edge<f32>, num_shards: i64, shard_id: i64) -> () {
        Self {
            parameters,
            accumulators,
            weights,
            benefits,
            table_id: None,
            table_name: None,
            num_shards: num_shards,
            shard_id: shard_id,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

pub trait con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT8_or_DT_HALF {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT8_or_DT_HALF for f32 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT8_or_DT_HALF for f64 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT8_or_DT_HALF for i32 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT8_or_DT_HALF for i8 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT8_or_DT_HALF for u8 {
}

impl<T> GraphOperation for ResizeNearestNeighborGrad<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT8_or_DT_HALF,
      T: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("ResizeNearestNeighborGrad_{}")?
        };
        let mut new_op = graph.new_operation("ResizeNearestNeighborGrad", &op_name)?;
        {
            new_op.add_edge(&self.grads)?
        }
        {
            new_op.add_edge(&self.size)?
        }
        {
            match self.align_corners {
                None => new_op.set_attr_value_proto("align_corners", &vec![40_u8, 0_u8,])?,
                Some(ref value) => (|attr: &bool| {new_op.set_attr_bool("align_corners", *attr)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct ResizeNearestNeighborGrad<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT8_or_DT_HALF,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    grads: Edge<T>,
    size: Edge<i32>,
    align_corners: Option<bool>,
    op_name: Option<String>,
    id_: usize,
}

impl<T> ResizeNearestNeighborGrad<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT8_or_DT_HALF,
      T: 'static,
{
    pub fn output(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn align_corners(&mut self, align_corners: bool) -> Self {
        self.align_corners = Some(align_corners);
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(grads: Edge<T>, size: Edge<i32>) -> Self {
        Self {
            phantom_T: PhantomData,
            grads,
            size,
            align_corners: None,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(grads: Edge<T>, size: Edge<i32>) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            grads,
            size,
            align_corners: None,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl GraphOperation for RetrieveTPUEmbeddingMomentumParametersGradAccumDebug {
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("RetrieveTPUEmbeddingMomentumParametersGradAccumDebug_{}")?
        };
        let mut new_op = graph.new_operation("RetrieveTPUEmbeddingMomentumParametersGradAccumDebug", &op_name)?;
        {
            match self.table_id {
                None => new_op.set_attr_value_proto("table_id", &vec![24_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 1_u8,])?,
                Some(ref value) => (|attr: &i64| {new_op.set_attr_int("table_id", *attr)})(&value)?,
            };
        }
        {
            match self.table_name {
                None => new_op.set_attr_value_proto("table_name", &vec![18_u8, 0_u8,])?,
                Some(ref value) => (|attr| {new_op.set_attr_string("table_name", attr)})(&value)?,
            };
        }
        {
            (|attr: &i64| {new_op.set_attr_int("num_shards", *attr)})(&self.num_shards)?
        }
        {
            (|attr: &i64| {new_op.set_attr_int("shard_id", *attr)})(&self.shard_id)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct RetrieveTPUEmbeddingMomentumParametersGradAccumDebug {
    table_id: Option<i64>,
    table_name: Option<String>,
    num_shards: i64,
    shard_id: i64,
    op_name: Option<String>,
    id_: usize,
}

impl RetrieveTPUEmbeddingMomentumParametersGradAccumDebug {
    pub fn parameters(self) -> Edge<f32> {
        let rc = Rc::new(self);
        {
            Edge::<f32>::new(rc.clone(), 0)
        }
    }

    pub fn momenta(self) -> Edge<f32> {
        let rc = Rc::new(self);
        {
            Edge::<f32>::new(rc.clone(), 1)
        }
    }

    pub fn gradient_accumulators(self) -> Edge<f32> {
        let rc = Rc::new(self);
        {
            Edge::<f32>::new(rc.clone(), 2)
        }
    }

    pub fn table_id(&mut self, table_id: i64) -> Self {
        self.table_id = Some(table_id);
        self.clone()
    }

    pub fn table_name(&mut self, table_name: &str) -> Self {
        self.table_name = Some(table_name.to_string());
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> (Edge<f32>, Edge<f32>, Edge<f32>) {
        let rc = Rc::new(self);
        (
        {
            Edge::<f32>::new(rc.clone(), 0)
        },
        {
            Edge::<f32>::new(rc.clone(), 1)
        },
        {
            Edge::<f32>::new(rc.clone(), 2)
        },
        )
    }

    pub fn build(num_shards: i64, shard_id: i64) -> Self {
        Self {
            table_id: None,
            table_name: None,
            num_shards: num_shards,
            shard_id: shard_id,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(num_shards: i64, shard_id: i64) -> (Edge<f32>, Edge<f32>, Edge<f32>) {
        Self {
            table_id: None,
            table_name: None,
            num_shards: num_shards,
            shard_id: shard_id,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<T> GraphOperation for IsNan<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
      T: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("IsNan_{}")?
        };
        let mut new_op = graph.new_operation("IsNan", &op_name)?;
        {
            new_op.add_edge(&self.x)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct IsNan<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    x: Edge<T>,
    op_name: Option<String>,
    id_: usize,
}

impl<T> IsNan<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
      T: 'static,
{
    pub fn y(self) -> Edge<bool> {
        let rc = Rc::new(self);
        {
            Edge::<bool>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<bool> {
        let rc = Rc::new(self);
        {
            Edge::<bool>::new(rc.clone(), 0)
        }
    }

    pub fn build(x: Edge<T>) -> Self {
        Self {
            phantom_T: PhantomData,
            x,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(x: Edge<T>) -> Edge<bool> {
        Self {
            phantom_T: PhantomData,
            x,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl GraphOperation for AdjustSaturation {
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("AdjustSaturation_{}")?
        };
        let mut new_op = graph.new_operation("AdjustSaturation", &op_name)?;
        {
            new_op.add_edge(&self.images)?
        }
        {
            new_op.add_edge(&self.scale)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct AdjustSaturation {
    images: Edge<f32>,
    scale: Edge<f32>,
    op_name: Option<String>,
    id_: usize,
}

impl AdjustSaturation {
    pub fn output(self) -> Edge<f32> {
        let rc = Rc::new(self);
        {
            Edge::<f32>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<f32> {
        let rc = Rc::new(self);
        {
            Edge::<f32>::new(rc.clone(), 0)
        }
    }

    pub fn build(images: Edge<f32>, scale: Edge<f32>) -> Self {
        Self {
            images,
            scale,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(images: Edge<f32>, scale: Edge<f32>) -> Edge<f32> {
        Self {
            images,
            scale,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<T> GraphOperation for SoftplusGrad<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
      T: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("SoftplusGrad_{}")?
        };
        let mut new_op = graph.new_operation("SoftplusGrad", &op_name)?;
        {
            new_op.add_edge(&self.gradients)?
        }
        {
            new_op.add_edge(&self.features)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct SoftplusGrad<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    gradients: Edge<T>,
    features: Edge<T>,
    op_name: Option<String>,
    id_: usize,
}

impl<T> SoftplusGrad<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
      T: 'static,
{
    pub fn backprops(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(gradients: Edge<T>, features: Edge<T>) -> Self {
        Self {
            phantom_T: PhantomData,
            gradients,
            features,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(gradients: Edge<T>, features: Edge<T>) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            gradients,
            features,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<T> GraphOperation for SelfAdjointEigV2<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_COMPLEX64_or_DT_COMPLEX128,
      T: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("SelfAdjointEigV2_{}")?
        };
        let mut new_op = graph.new_operation("SelfAdjointEigV2", &op_name)?;
        {
            new_op.add_edge(&self.input)?
        }
        {
            match self.compute_v {
                None => new_op.set_attr_value_proto("compute_v", &vec![40_u8, 1_u8,])?,
                Some(ref value) => (|attr: &bool| {new_op.set_attr_bool("compute_v", *attr)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct SelfAdjointEigV2<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_COMPLEX64_or_DT_COMPLEX128,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    input: Edge<T>,
    compute_v: Option<bool>,
    op_name: Option<String>,
    id_: usize,
}

impl<T> SelfAdjointEigV2<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_COMPLEX64_or_DT_COMPLEX128,
      T: 'static,
{
    pub fn e(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn v(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 1)
        }
    }

    pub fn compute_v(&mut self, compute_v: bool) -> Self {
        self.compute_v = Some(compute_v);
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> (Edge<T>, Edge<T>) {
        let rc = Rc::new(self);
        (
        {
            Edge::<T>::new(rc.clone(), 0)
        },
        {
            Edge::<T>::new(rc.clone(), 1)
        },
        )
    }

    pub fn build(input: Edge<T>) -> Self {
        Self {
            phantom_T: PhantomData,
            input,
            compute_v: None,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(input: Edge<T>) -> (Edge<T>, Edge<T>) {
        Self {
            phantom_T: PhantomData,
            input,
            compute_v: None,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<Tcomplex> GraphOperation for FFT<Tcomplex>
where Tcomplex: TensorType,
      Tcomplex: Clone,
      Tcomplex: con_or_DT_COMPLEX64_or_DT_COMPLEX128,
      Tcomplex: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("FFT_{}")?
        };
        let mut new_op = graph.new_operation("FFT", &op_name)?;
        {
            new_op.add_edge(&self.input)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct FFT<Tcomplex>
where Tcomplex: TensorType,
      Tcomplex: Clone,
      Tcomplex: con_or_DT_COMPLEX64_or_DT_COMPLEX128,
      Tcomplex: 'static,
{
    phantom_Tcomplex: PhantomData<Tcomplex>,
    input: Edge<Tcomplex>,
    op_name: Option<String>,
    id_: usize,
}

impl<Tcomplex> FFT<Tcomplex>
where Tcomplex: TensorType,
      Tcomplex: Clone,
      Tcomplex: con_or_DT_COMPLEX64_or_DT_COMPLEX128,
      Tcomplex: 'static,
{
    pub fn output(self) -> Edge<Tcomplex> {
        let rc = Rc::new(self);
        {
            Edge::<Tcomplex>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<Tcomplex> {
        let rc = Rc::new(self);
        {
            Edge::<Tcomplex>::new(rc.clone(), 0)
        }
    }

    pub fn build(input: Edge<Tcomplex>) -> Self {
        Self {
            phantom_Tcomplex: PhantomData,
            input,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(input: Edge<Tcomplex>) -> Edge<Tcomplex> {
        Self {
            phantom_Tcomplex: PhantomData,
            input,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<T, Tindex> GraphOperation for MatrixBandPart<T, Tindex>
where T: TensorType,
      T: Clone,
      Tindex: TensorType,
      Tindex: Clone,
      T: 'static,
      Tindex: con_or_DT_INT32_or_DT_INT64,
      Tindex: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("MatrixBandPart_{}")?
        };
        let mut new_op = graph.new_operation("MatrixBandPart", &op_name)?;
        {
            new_op.add_edge(&self.input)?
        }
        {
            new_op.add_edge(&self.num_lower)?
        }
        {
            new_op.add_edge(&self.num_upper)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct MatrixBandPart<T, Tindex>
where T: TensorType,
      T: Clone,
      Tindex: TensorType,
      Tindex: Clone,
      T: 'static,
      Tindex: con_or_DT_INT32_or_DT_INT64,
      Tindex: 'static,
{
    phantom_T: PhantomData<T>,
    input: Edge<T>,
    phantom_Tindex: PhantomData<Tindex>,
    num_lower: Edge<Tindex>,
    num_upper: Edge<Tindex>,
    op_name: Option<String>,
    id_: usize,
}

impl<T, Tindex> MatrixBandPart<T, Tindex>
where T: TensorType,
      T: Clone,
      Tindex: TensorType,
      Tindex: Clone,
      T: 'static,
      Tindex: con_or_DT_INT32_or_DT_INT64,
      Tindex: 'static,
{
    pub fn band(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(input: Edge<T>, num_lower: Edge<Tindex>, num_upper: Edge<Tindex>) -> Self {
        Self {
            phantom_T: PhantomData,
            input,
            phantom_Tindex: PhantomData,
            num_lower,
            num_upper,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(input: Edge<T>, num_lower: Edge<Tindex>, num_upper: Edge<Tindex>) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            input,
            phantom_Tindex: PhantomData,
            num_lower,
            num_upper,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<T, Tindices> GraphOperation for TensorScatterAdd<T, Tindices>
where T: TensorType,
      T: Clone,
      Tindices: TensorType,
      Tindices: Clone,
      T: 'static,
      Tindices: con_or_DT_INT32_or_DT_INT64,
      Tindices: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("TensorScatterAdd_{}")?
        };
        let mut new_op = graph.new_operation("TensorScatterAdd", &op_name)?;
        {
            new_op.add_edge(&self.tensor)?
        }
        {
            new_op.add_edge(&self.indices)?
        }
        {
            new_op.add_edge(&self.updates)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct TensorScatterAdd<T, Tindices>
where T: TensorType,
      T: Clone,
      Tindices: TensorType,
      Tindices: Clone,
      T: 'static,
      Tindices: con_or_DT_INT32_or_DT_INT64,
      Tindices: 'static,
{
    phantom_T: PhantomData<T>,
    tensor: Edge<T>,
    phantom_Tindices: PhantomData<Tindices>,
    indices: Edge<Tindices>,
    updates: Edge<T>,
    op_name: Option<String>,
    id_: usize,
}

impl<T, Tindices> TensorScatterAdd<T, Tindices>
where T: TensorType,
      T: Clone,
      Tindices: TensorType,
      Tindices: Clone,
      T: 'static,
      Tindices: con_or_DT_INT32_or_DT_INT64,
      Tindices: 'static,
{
    pub fn output(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(tensor: Edge<T>, indices: Edge<Tindices>, updates: Edge<T>) -> Self {
        Self {
            phantom_T: PhantomData,
            tensor,
            phantom_Tindices: PhantomData,
            indices,
            updates,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(tensor: Edge<T>, indices: Edge<Tindices>, updates: Edge<T>) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            tensor,
            phantom_Tindices: PhantomData,
            indices,
            updates,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<T> GraphOperation for LogMatrixDeterminant<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_COMPLEX64_or_DT_COMPLEX128,
      T: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("LogMatrixDeterminant_{}")?
        };
        let mut new_op = graph.new_operation("LogMatrixDeterminant", &op_name)?;
        {
            new_op.add_edge(&self.input)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct LogMatrixDeterminant<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_COMPLEX64_or_DT_COMPLEX128,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    input: Edge<T>,
    op_name: Option<String>,
    id_: usize,
}

impl<T> LogMatrixDeterminant<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_COMPLEX64_or_DT_COMPLEX128,
      T: 'static,
{
    pub fn sign(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn log_abs_determinant(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 1)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> (Edge<T>, Edge<T>) {
        let rc = Rc::new(self);
        (
        {
            Edge::<T>::new(rc.clone(), 0)
        },
        {
            Edge::<T>::new(rc.clone(), 1)
        },
        )
    }

    pub fn build(input: Edge<T>) -> Self {
        Self {
            phantom_T: PhantomData,
            input,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(input: Edge<T>) -> (Edge<T>, Edge<T>) {
        Self {
            phantom_T: PhantomData,
            input,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

pub trait con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF for BFloat16 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF for OtherComplex<f32> {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF for OtherComplex<f64> {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF for f32 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF for f64 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF for i16 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF for i32 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF for i64 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF for i8 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF for u8 {
}

impl<T> GraphOperation for AddV2<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF,
      T: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("AddV2_{}")?
        };
        let mut new_op = graph.new_operation("AddV2", &op_name)?;
        {
            new_op.add_edge(&self.x)?
        }
        {
            new_op.add_edge(&self.y)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct AddV2<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    x: Edge<T>,
    y: Edge<T>,
    op_name: Option<String>,
    id_: usize,
}

impl<T> AddV2<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF,
      T: 'static,
{
    pub fn z(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(x: Edge<T>, y: Edge<T>) -> Self {
        Self {
            phantom_T: PhantomData,
            x,
            y,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(x: Edge<T>, y: Edge<T>) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            x,
            y,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<T> GraphOperation for TensorSummary<T>
where T: TensorType,
      T: Clone,
      T: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("TensorSummary_{}")?
        };
        let mut new_op = graph.new_operation("TensorSummary", &op_name)?;
        {
            new_op.add_edge(&self.tensor)?
        }
        {
            match self.description {
                None => new_op.set_attr_value_proto("description", &vec![18_u8, 0_u8,])?,
                Some(ref value) => (|attr| {new_op.set_attr_string("description", attr)})(&value)?,
            };
        }
        {
            match self.labels {
                None => new_op.set_attr_value_proto("labels", &vec![10_u8, 0_u8,])?,
                Some(ref value) => (|attrs| {new_op.set_attr_string_list("labels", attrs)})(&value)?,
            };
        }
        {
            match self.display_name {
                None => new_op.set_attr_value_proto("display_name", &vec![18_u8, 0_u8,])?,
                Some(ref value) => (|attr| {new_op.set_attr_string("display_name", attr)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct TensorSummary<T>
where T: TensorType,
      T: Clone,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    tensor: Edge<T>,
    description: Option<String>,
    labels: Option<Vec<String>>,
    display_name: Option<String>,
    op_name: Option<String>,
    id_: usize,
}

impl<T> TensorSummary<T>
where T: TensorType,
      T: Clone,
      T: 'static,
{
    pub fn summary(self) -> Edge<String> {
        let rc = Rc::new(self);
        {
            Edge::<String>::new(rc.clone(), 0)
        }
    }

    pub fn description(&mut self, description: &str) -> Self {
        self.description = Some(description.to_string());
        self.clone()
    }

    pub fn labels(&mut self, labels: &[String]) -> Self {
        self.labels = Some(labels.to_vec());
        self.clone()
    }

    pub fn display_name(&mut self, display_name: &str) -> Self {
        self.display_name = Some(display_name.to_string());
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<String> {
        let rc = Rc::new(self);
        {
            Edge::<String>::new(rc.clone(), 0)
        }
    }

    pub fn build(tensor: Edge<T>) -> Self {
        Self {
            phantom_T: PhantomData,
            tensor,
            description: None,
            labels: None,
            display_name: None,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(tensor: Edge<T>) -> Edge<String> {
        Self {
            phantom_T: PhantomData,
            tensor,
            description: None,
            labels: None,
            display_name: None,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<T, Tout> GraphOperation for RandomUniformInt<T, Tout>
where T: TensorType,
      T: Clone,
      Tout: TensorType,
      Tout: Clone,
      Tout: con_or_DT_INT32_or_DT_INT64,
      Tout: 'static,
      T: con_or_DT_INT32_or_DT_INT64,
      T: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("RandomUniformInt_{}")?
        };
        let mut new_op = graph.new_operation("RandomUniformInt", &op_name)?;
        {
            new_op.add_edge(&self.shape)?
        }
        {
            new_op.add_edge(&self.minval)?
        }
        {
            new_op.add_edge(&self.maxval)?
        }
        {
            match self.seed {
                None => new_op.set_attr_value_proto("seed", &vec![24_u8, 0_u8,])?,
                Some(ref value) => (|attr: &i64| {new_op.set_attr_int("seed", *attr)})(&value)?,
            };
        }
        {
            match self.seed2 {
                None => new_op.set_attr_value_proto("seed2", &vec![24_u8, 0_u8,])?,
                Some(ref value) => (|attr: &i64| {new_op.set_attr_int("seed2", *attr)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct RandomUniformInt<T, Tout>
where T: TensorType,
      T: Clone,
      Tout: TensorType,
      Tout: Clone,
      Tout: con_or_DT_INT32_or_DT_INT64,
      Tout: 'static,
      T: con_or_DT_INT32_or_DT_INT64,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    shape: Edge<T>,
    phantom_Tout: PhantomData<Tout>,
    minval: Edge<Tout>,
    maxval: Edge<Tout>,
    seed: Option<i64>,
    seed2: Option<i64>,
    op_name: Option<String>,
    id_: usize,
}

impl<T, Tout> RandomUniformInt<T, Tout>
where T: TensorType,
      T: Clone,
      Tout: TensorType,
      Tout: Clone,
      Tout: con_or_DT_INT32_or_DT_INT64,
      Tout: 'static,
      T: con_or_DT_INT32_or_DT_INT64,
      T: 'static,
{
    pub fn output(self) -> Edge<Tout> {
        let rc = Rc::new(self);
        {
            Edge::<Tout>::new(rc.clone(), 0)
        }
    }

    pub fn seed(&mut self, seed: i64) -> Self {
        self.seed = Some(seed);
        self.clone()
    }

    pub fn seed2(&mut self, seed2: i64) -> Self {
        self.seed2 = Some(seed2);
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<Tout> {
        let rc = Rc::new(self);
        {
            Edge::<Tout>::new(rc.clone(), 0)
        }
    }

    pub fn build(shape: Edge<T>, minval: Edge<Tout>, maxval: Edge<Tout>) -> Self {
        Self {
            phantom_T: PhantomData,
            shape,
            phantom_Tout: PhantomData,
            minval,
            maxval,
            seed: None,
            seed2: None,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(shape: Edge<T>, minval: Edge<Tout>, maxval: Edge<Tout>) -> Edge<Tout> {
        Self {
            phantom_T: PhantomData,
            shape,
            phantom_Tout: PhantomData,
            minval,
            maxval,
            seed: None,
            seed2: None,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<T> GraphOperation for DataFormatDimMap<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_INT32_or_DT_INT64,
      T: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("DataFormatDimMap_{}")?
        };
        let mut new_op = graph.new_operation("DataFormatDimMap", &op_name)?;
        {
            new_op.add_edge(&self.x)?
        }
        {
            match self.src_format {
                None => new_op.set_attr_value_proto("src_format", &vec![18_u8, 4_u8, 78_u8, 72_u8, 87_u8, 67_u8,])?,
                Some(ref value) => (|attr| {new_op.set_attr_string("src_format", attr)})(&value)?,
            };
        }
        {
            match self.dst_format {
                None => new_op.set_attr_value_proto("dst_format", &vec![18_u8, 4_u8, 78_u8, 67_u8, 72_u8, 87_u8,])?,
                Some(ref value) => (|attr| {new_op.set_attr_string("dst_format", attr)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct DataFormatDimMap<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_INT32_or_DT_INT64,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    x: Edge<T>,
    src_format: Option<String>,
    dst_format: Option<String>,
    op_name: Option<String>,
    id_: usize,
}

impl<T> DataFormatDimMap<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_INT32_or_DT_INT64,
      T: 'static,
{
    pub fn y(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn src_format(&mut self, src_format: &str) -> Self {
        self.src_format = Some(src_format.to_string());
        self.clone()
    }

    pub fn dst_format(&mut self, dst_format: &str) -> Self {
        self.dst_format = Some(dst_format.to_string());
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(x: Edge<T>) -> Self {
        Self {
            phantom_T: PhantomData,
            x,
            src_format: None,
            dst_format: None,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(x: Edge<T>) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            x,
            src_format: None,
            dst_format: None,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<T> GraphOperation for BroadcastArgs<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_INT32_or_DT_INT64,
      T: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("BroadcastArgs_{}")?
        };
        let mut new_op = graph.new_operation("BroadcastArgs", &op_name)?;
        {
            new_op.add_edge(&self.s0)?
        }
        {
            new_op.add_edge(&self.s1)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct BroadcastArgs<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_INT32_or_DT_INT64,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    s0: Edge<T>,
    s1: Edge<T>,
    op_name: Option<String>,
    id_: usize,
}

impl<T> BroadcastArgs<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_INT32_or_DT_INT64,
      T: 'static,
{
    pub fn r0(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(s0: Edge<T>, s1: Edge<T>) -> Self {
        Self {
            phantom_T: PhantomData,
            s0,
            s1,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(s0: Edge<T>, s1: Edge<T>) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            s0,
            s1,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<T, Tidx> GraphOperation for Cumsum<T, Tidx>
where T: TensorType,
      T: Clone,
      Tidx: TensorType,
      Tidx: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
      Tidx: con_or_DT_INT32_or_DT_INT64,
      Tidx: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("Cumsum_{}")?
        };
        let mut new_op = graph.new_operation("Cumsum", &op_name)?;
        {
            new_op.add_edge(&self.x)?
        }
        {
            new_op.add_edge(&self.axis)?
        }
        {
            match self.exclusive {
                None => new_op.set_attr_value_proto("exclusive", &vec![40_u8, 0_u8,])?,
                Some(ref value) => (|attr: &bool| {new_op.set_attr_bool("exclusive", *attr)})(&value)?,
            };
        }
        {
            match self.reverse {
                None => new_op.set_attr_value_proto("reverse", &vec![40_u8, 0_u8,])?,
                Some(ref value) => (|attr: &bool| {new_op.set_attr_bool("reverse", *attr)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct Cumsum<T, Tidx>
where T: TensorType,
      T: Clone,
      Tidx: TensorType,
      Tidx: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
      Tidx: con_or_DT_INT32_or_DT_INT64,
      Tidx: 'static,
{
    phantom_T: PhantomData<T>,
    x: Edge<T>,
    phantom_Tidx: PhantomData<Tidx>,
    axis: Edge<Tidx>,
    exclusive: Option<bool>,
    reverse: Option<bool>,
    op_name: Option<String>,
    id_: usize,
}

impl<T, Tidx> Cumsum<T, Tidx>
where T: TensorType,
      T: Clone,
      Tidx: TensorType,
      Tidx: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
      Tidx: con_or_DT_INT32_or_DT_INT64,
      Tidx: 'static,
{
    pub fn out(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn exclusive(&mut self, exclusive: bool) -> Self {
        self.exclusive = Some(exclusive);
        self.clone()
    }

    pub fn reverse(&mut self, reverse: bool) -> Self {
        self.reverse = Some(reverse);
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(x: Edge<T>, axis: Edge<Tidx>) -> Self {
        Self {
            phantom_T: PhantomData,
            x,
            phantom_Tidx: PhantomData,
            axis,
            exclusive: None,
            reverse: None,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(x: Edge<T>, axis: Edge<Tidx>) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            x,
            phantom_Tidx: PhantomData,
            axis,
            exclusive: None,
            reverse: None,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl GraphOperation for SdcaOptimizer {
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("SdcaOptimizer_{}")?
        };
        let mut new_op = graph.new_operation("SdcaOptimizer", &op_name)?;
        {
            new_op.add_edge(&self.sparse_example_indices)?
        }
        {
            new_op.add_edge(&self.sparse_feature_indices)?
        }
        {
            new_op.add_edge(&self.sparse_feature_values)?
        }
        {
            new_op.add_edge(&self.dense_features)?
        }
        {
            new_op.add_edge(&self.example_weights)?
        }
        {
            new_op.add_edge(&self.example_labels)?
        }
        {
            new_op.add_edge(&self.sparse_indices)?
        }
        {
            new_op.add_edge(&self.sparse_weights)?
        }
        {
            new_op.add_edge(&self.dense_weights)?
        }
        {
            new_op.add_edge(&self.example_state_data)?
        }
        {
            (|attr| {new_op.set_attr_string("loss_type", attr)})(&self.loss_type)?
        }
        {
            match self.adaptative {
                None => new_op.set_attr_value_proto("adaptative", &vec![40_u8, 0_u8,])?,
                Some(ref value) => (|attr: &bool| {new_op.set_attr_bool("adaptative", *attr)})(&value)?,
            };
        }
        {
            (|attr: &i64| {new_op.set_attr_int("num_sparse_features", *attr)})(&self.num_sparse_features)?
        }
        {
            (|attr: &i64| {new_op.set_attr_int("num_sparse_features_with_values", *attr)})(&self.num_sparse_features_with_values)?
        }
        {
            (|attr: &i64| {new_op.set_attr_int("num_dense_features", *attr)})(&self.num_dense_features)?
        }
        {
            (|attr: &f32| {new_op.set_attr_float("l1", *attr)})(&self.l1)?
        }
        {
            (|attr: &f32| {new_op.set_attr_float("l2", *attr)})(&self.l2)?
        }
        {
            (|attr: &i64| {new_op.set_attr_int("num_loss_partitions", *attr)})(&self.num_loss_partitions)?
        }
        {
            (|attr: &i64| {new_op.set_attr_int("num_inner_iterations", *attr)})(&self.num_inner_iterations)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct SdcaOptimizer {
    sparse_example_indices: Edge<i64>,
    sparse_feature_indices: Edge<i64>,
    sparse_feature_values: Edge<f32>,
    dense_features: Edge<f32>,
    example_weights: Edge<f32>,
    example_labels: Edge<f32>,
    sparse_indices: Edge<i64>,
    sparse_weights: Edge<f32>,
    dense_weights: Edge<f32>,
    example_state_data: Edge<f32>,
    loss_type: String,
    adaptative: Option<bool>,
    num_sparse_features: i64,
    num_sparse_features_with_values: i64,
    num_dense_features: i64,
    l1: f32,
    l2: f32,
    num_loss_partitions: i64,
    num_inner_iterations: i64,
    op_name: Option<String>,
    id_: usize,
}

impl SdcaOptimizer {
    pub fn out_example_state_data(self) -> Edge<f32> {
        let rc = Rc::new(self);
        {
            Edge::<f32>::new(rc.clone(), 0)
        }
    }

    pub fn out_delta_sparse_weights(self) -> Edge<f32> {
        let rc = Rc::new(self);
        {
            Edge::<f32>::new(rc.clone(), 1)
        }
    }

    pub fn out_delta_dense_weights(self) -> Edge<f32> {
        let rc = Rc::new(self);
        {
            Edge::<f32>::new(rc.clone(), 2)
        }
    }

    pub fn adaptative(&mut self, adaptative: bool) -> Self {
        self.adaptative = Some(adaptative);
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> (Edge<f32>, Edge<f32>, Edge<f32>) {
        let rc = Rc::new(self);
        (
        {
            Edge::<f32>::new(rc.clone(), 0)
        },
        {
            Edge::<f32>::new(rc.clone(), 1)
        },
        {
            Edge::<f32>::new(rc.clone(), 2)
        },
        )
    }

    pub fn build(sparse_example_indices: Edge<i64>, sparse_feature_indices: Edge<i64>, sparse_feature_values: Edge<f32>, dense_features: Edge<f32>, example_weights: Edge<f32>, example_labels: Edge<f32>, sparse_indices: Edge<i64>, sparse_weights: Edge<f32>, dense_weights: Edge<f32>, example_state_data: Edge<f32>, loss_type: &str, num_sparse_features: i64, num_sparse_features_with_values: i64, num_dense_features: i64, l1: f32, l2: f32, num_loss_partitions: i64, num_inner_iterations: i64) -> Self {
        Self {
            sparse_example_indices,
            sparse_feature_indices,
            sparse_feature_values,
            dense_features,
            example_weights,
            example_labels,
            sparse_indices,
            sparse_weights,
            dense_weights,
            example_state_data,
            loss_type: loss_type.to_string(),
            adaptative: None,
            num_sparse_features: num_sparse_features,
            num_sparse_features_with_values: num_sparse_features_with_values,
            num_dense_features: num_dense_features,
            l1: l1,
            l2: l2,
            num_loss_partitions: num_loss_partitions,
            num_inner_iterations: num_inner_iterations,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(sparse_example_indices: Edge<i64>, sparse_feature_indices: Edge<i64>, sparse_feature_values: Edge<f32>, dense_features: Edge<f32>, example_weights: Edge<f32>, example_labels: Edge<f32>, sparse_indices: Edge<i64>, sparse_weights: Edge<f32>, dense_weights: Edge<f32>, example_state_data: Edge<f32>, loss_type: &str, num_sparse_features: i64, num_sparse_features_with_values: i64, num_dense_features: i64, l1: f32, l2: f32, num_loss_partitions: i64, num_inner_iterations: i64) -> (Edge<f32>, Edge<f32>, Edge<f32>) {
        Self {
            sparse_example_indices,
            sparse_feature_indices,
            sparse_feature_values,
            dense_features,
            example_weights,
            example_labels,
            sparse_indices,
            sparse_weights,
            dense_weights,
            example_state_data,
            loss_type: loss_type.to_string(),
            adaptative: None,
            num_sparse_features: num_sparse_features,
            num_sparse_features_with_values: num_sparse_features_with_values,
            num_dense_features: num_dense_features,
            l1: l1,
            l2: l2,
            num_loss_partitions: num_loss_partitions,
            num_inner_iterations: num_inner_iterations,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<T, Tindices> GraphOperation for ScatterAdd<T, Tindices>
where T: TensorType,
      T: Clone,
      Tindices: TensorType,
      Tindices: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
      Tindices: con_or_DT_INT32_or_DT_INT64,
      Tindices: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("ScatterAdd_{}")?
        };
        let mut new_op = graph.new_operation("ScatterAdd", &op_name)?;
        {
            new_op.add_edge(&self.ref_)?
        }
        {
            new_op.add_edge(&self.indices)?
        }
        {
            new_op.add_edge(&self.updates)?
        }
        {
            match self.use_locking {
                None => new_op.set_attr_value_proto("use_locking", &vec![40_u8, 0_u8,])?,
                Some(ref value) => (|attr: &bool| {new_op.set_attr_bool("use_locking", *attr)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct ScatterAdd<T, Tindices>
where T: TensorType,
      T: Clone,
      Tindices: TensorType,
      Tindices: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
      Tindices: con_or_DT_INT32_or_DT_INT64,
      Tindices: 'static,
{
    phantom_T: PhantomData<T>,
    ref_: Edge<T>,
    phantom_Tindices: PhantomData<Tindices>,
    indices: Edge<Tindices>,
    updates: Edge<T>,
    use_locking: Option<bool>,
    op_name: Option<String>,
    id_: usize,
}

impl<T, Tindices> ScatterAdd<T, Tindices>
where T: TensorType,
      T: Clone,
      Tindices: TensorType,
      Tindices: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
      Tindices: con_or_DT_INT32_or_DT_INT64,
      Tindices: 'static,
{
    pub fn output_ref(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn use_locking(&mut self, use_locking: bool) -> Self {
        self.use_locking = Some(use_locking);
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(ref_: Edge<T>, indices: Edge<Tindices>, updates: Edge<T>) -> Self {
        Self {
            phantom_T: PhantomData,
            ref_,
            phantom_Tindices: PhantomData,
            indices,
            updates,
            use_locking: None,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(ref_: Edge<T>, indices: Edge<Tindices>, updates: Edge<T>) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            ref_,
            phantom_Tindices: PhantomData,
            indices,
            updates,
            use_locking: None,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl GraphOperation for TextLineReader {
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("TextLineReader_{}")?
        };
        let mut new_op = graph.new_operation("TextLineReader", &op_name)?;
        {
            match self.skip_header_lines {
                None => new_op.set_attr_value_proto("skip_header_lines", &vec![24_u8, 0_u8,])?,
                Some(ref value) => (|attr: &i64| {new_op.set_attr_int("skip_header_lines", *attr)})(&value)?,
            };
        }
        {
            match self.container {
                None => new_op.set_attr_value_proto("container", &vec![18_u8, 0_u8,])?,
                Some(ref value) => (|attr| {new_op.set_attr_string("container", attr)})(&value)?,
            };
        }
        {
            match self.shared_name {
                None => new_op.set_attr_value_proto("shared_name", &vec![18_u8, 0_u8,])?,
                Some(ref value) => (|attr| {new_op.set_attr_string("shared_name", attr)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct TextLineReader {
    skip_header_lines: Option<i64>,
    container: Option<String>,
    shared_name: Option<String>,
    op_name: Option<String>,
    id_: usize,
}

impl TextLineReader {
    pub fn reader_handle(self) -> Edge<String> {
        let rc = Rc::new(self);
        {
            Edge::<String>::new(rc.clone(), 0)
        }
    }

    pub fn skip_header_lines(&mut self, skip_header_lines: i64) -> Self {
        self.skip_header_lines = Some(skip_header_lines);
        self.clone()
    }

    pub fn container(&mut self, container: &str) -> Self {
        self.container = Some(container.to_string());
        self.clone()
    }

    pub fn shared_name(&mut self, shared_name: &str) -> Self {
        self.shared_name = Some(shared_name.to_string());
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<String> {
        let rc = Rc::new(self);
        {
            Edge::<String>::new(rc.clone(), 0)
        }
    }

    pub fn build() -> Self {
        Self {
            skip_header_lines: None,
            container: None,
            shared_name: None,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new() -> Edge<String> {
        Self {
            skip_header_lines: None,
            container: None,
            shared_name: None,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<T> GraphOperation for Sign<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_COMPLEX64_or_DT_INT64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF,
      T: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("Sign_{}")?
        };
        let mut new_op = graph.new_operation("Sign", &op_name)?;
        {
            new_op.add_edge(&self.x)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct Sign<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_COMPLEX64_or_DT_INT64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    x: Edge<T>,
    op_name: Option<String>,
    id_: usize,
}

impl<T> Sign<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_COMPLEX64_or_DT_INT64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF,
      T: 'static,
{
    pub fn y(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(x: Edge<T>) -> Self {
        Self {
            phantom_T: PhantomData,
            x,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(x: Edge<T>) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            x,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<T, Tidx> GraphOperation for BatchToSpace<T, Tidx>
where T: TensorType,
      T: Clone,
      Tidx: TensorType,
      Tidx: Clone,
      T: 'static,
      Tidx: con_or_DT_INT32_or_DT_INT64,
      Tidx: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("BatchToSpace_{}")?
        };
        let mut new_op = graph.new_operation("BatchToSpace", &op_name)?;
        {
            new_op.add_edge(&self.input)?
        }
        {
            new_op.add_edge(&self.crops)?
        }
        {
            (|attr: &i64| {new_op.set_attr_int("block_size", *attr)})(&self.block_size)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct BatchToSpace<T, Tidx>
where T: TensorType,
      T: Clone,
      Tidx: TensorType,
      Tidx: Clone,
      T: 'static,
      Tidx: con_or_DT_INT32_or_DT_INT64,
      Tidx: 'static,
{
    phantom_T: PhantomData<T>,
    input: Edge<T>,
    phantom_Tidx: PhantomData<Tidx>,
    crops: Edge<Tidx>,
    block_size: i64,
    op_name: Option<String>,
    id_: usize,
}

impl<T, Tidx> BatchToSpace<T, Tidx>
where T: TensorType,
      T: Clone,
      Tidx: TensorType,
      Tidx: Clone,
      T: 'static,
      Tidx: con_or_DT_INT32_or_DT_INT64,
      Tidx: 'static,
{
    pub fn output(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(input: Edge<T>, crops: Edge<Tidx>, block_size: i64) -> Self {
        Self {
            phantom_T: PhantomData,
            input,
            phantom_Tidx: PhantomData,
            crops,
            block_size: block_size,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(input: Edge<T>, crops: Edge<Tidx>, block_size: i64) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            input,
            phantom_Tidx: PhantomData,
            crops,
            block_size: block_size,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<T> GraphOperation for MatrixSolve<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_COMPLEX64_or_DT_COMPLEX128,
      T: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("MatrixSolve_{}")?
        };
        let mut new_op = graph.new_operation("MatrixSolve", &op_name)?;
        {
            new_op.add_edge(&self.matrix)?
        }
        {
            new_op.add_edge(&self.rhs)?
        }
        {
            match self.adjoint {
                None => new_op.set_attr_value_proto("adjoint", &vec![40_u8, 0_u8,])?,
                Some(ref value) => (|attr: &bool| {new_op.set_attr_bool("adjoint", *attr)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct MatrixSolve<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_COMPLEX64_or_DT_COMPLEX128,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    matrix: Edge<T>,
    rhs: Edge<T>,
    adjoint: Option<bool>,
    op_name: Option<String>,
    id_: usize,
}

impl<T> MatrixSolve<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_COMPLEX64_or_DT_COMPLEX128,
      T: 'static,
{
    pub fn output(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn adjoint(&mut self, adjoint: bool) -> Self {
        self.adjoint = Some(adjoint);
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(matrix: Edge<T>, rhs: Edge<T>) -> Self {
        Self {
            phantom_T: PhantomData,
            matrix,
            rhs,
            adjoint: None,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(matrix: Edge<T>, rhs: Edge<T>) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            matrix,
            rhs,
            adjoint: None,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<dtype> GraphOperation for VariableV2<dtype>
where dtype: TensorType,
      dtype: 'static,
      dtype: Clone,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("VariableV2_{}")?
        };
        let mut new_op = graph.new_operation("VariableV2", &op_name)?;
        {
            (|attr| {new_op.set_attr_shape("shape", attr)})(&self.shape)?
        }
        {
            match self.container {
                None => new_op.set_attr_value_proto("container", &vec![18_u8, 0_u8,])?,
                Some(ref value) => (|attr| {new_op.set_attr_string("container", attr)})(&value)?,
            };
        }
        {
            match self.shared_name {
                None => new_op.set_attr_value_proto("shared_name", &vec![18_u8, 0_u8,])?,
                Some(ref value) => (|attr| {new_op.set_attr_string("shared_name", attr)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct VariableV2<dtype>
where dtype: TensorType,
      dtype: 'static,
      dtype: Clone,
{
    shape: OtherShape,
    phantom_dtype: PhantomData<dtype>,
    container: Option<String>,
    shared_name: Option<String>,
    op_name: Option<String>,
    id_: usize,
}

impl<dtype> VariableV2<dtype>
where dtype: TensorType,
      dtype: 'static,
      dtype: Clone,
{
    pub fn ref_(self) -> Edge<dtype> {
        let rc = Rc::new(self);
        {
            Edge::<dtype>::new(rc.clone(), 0)
        }
    }

    pub fn container(&mut self, container: &str) -> Self {
        self.container = Some(container.to_string());
        self.clone()
    }

    pub fn shared_name(&mut self, shared_name: &str) -> Self {
        self.shared_name = Some(shared_name.to_string());
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<dtype> {
        let rc = Rc::new(self);
        {
            Edge::<dtype>::new(rc.clone(), 0)
        }
    }

    pub fn build(shape: &OtherShape) -> Self {
        Self {
            shape: shape.clone(),
            phantom_dtype: PhantomData,
            container: None,
            shared_name: None,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(shape: &OtherShape) -> Edge<dtype> {
        Self {
            shape: shape.clone(),
            phantom_dtype: PhantomData,
            container: None,
            shared_name: None,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<T, Tidx> GraphOperation for Max<T, Tidx>
where T: TensorType,
      T: Clone,
      Tidx: TensorType,
      Tidx: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
      Tidx: con_or_DT_INT32_or_DT_INT64,
      Tidx: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("Max_{}")?
        };
        let mut new_op = graph.new_operation("Max", &op_name)?;
        {
            new_op.add_edge(&self.input)?
        }
        {
            new_op.add_edge(&self.reduction_indices)?
        }
        {
            match self.keep_dims {
                None => new_op.set_attr_value_proto("keep_dims", &vec![40_u8, 0_u8,])?,
                Some(ref value) => (|attr: &bool| {new_op.set_attr_bool("keep_dims", *attr)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct Max<T, Tidx>
where T: TensorType,
      T: Clone,
      Tidx: TensorType,
      Tidx: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
      Tidx: con_or_DT_INT32_or_DT_INT64,
      Tidx: 'static,
{
    phantom_T: PhantomData<T>,
    input: Edge<T>,
    phantom_Tidx: PhantomData<Tidx>,
    reduction_indices: Edge<Tidx>,
    keep_dims: Option<bool>,
    op_name: Option<String>,
    id_: usize,
}

impl<T, Tidx> Max<T, Tidx>
where T: TensorType,
      T: Clone,
      Tidx: TensorType,
      Tidx: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
      Tidx: con_or_DT_INT32_or_DT_INT64,
      Tidx: 'static,
{
    pub fn output(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn keep_dims(&mut self, keep_dims: bool) -> Self {
        self.keep_dims = Some(keep_dims);
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(input: Edge<T>, reduction_indices: Edge<Tidx>) -> Self {
        Self {
            phantom_T: PhantomData,
            input,
            phantom_Tidx: PhantomData,
            reduction_indices,
            keep_dims: None,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(input: Edge<T>, reduction_indices: Edge<Tidx>) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            input,
            phantom_Tidx: PhantomData,
            reduction_indices,
            keep_dims: None,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl GraphOperation for StringSplitV2 {
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("StringSplitV2_{}")?
        };
        let mut new_op = graph.new_operation("StringSplitV2", &op_name)?;
        {
            new_op.add_edge(&self.input)?
        }
        {
            new_op.add_edge(&self.sep)?
        }
        {
            match self.maxsplit {
                None => new_op.set_attr_value_proto("maxsplit", &vec![24_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 1_u8,])?,
                Some(ref value) => (|attr: &i64| {new_op.set_attr_int("maxsplit", *attr)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct StringSplitV2 {
    input: Edge<String>,
    sep: Edge<String>,
    maxsplit: Option<i64>,
    op_name: Option<String>,
    id_: usize,
}

impl StringSplitV2 {
    pub fn indices(self) -> Edge<i64> {
        let rc = Rc::new(self);
        {
            Edge::<i64>::new(rc.clone(), 0)
        }
    }

    pub fn values(self) -> Edge<String> {
        let rc = Rc::new(self);
        {
            Edge::<String>::new(rc.clone(), 1)
        }
    }

    pub fn shape(self) -> Edge<i64> {
        let rc = Rc::new(self);
        {
            Edge::<i64>::new(rc.clone(), 2)
        }
    }

    pub fn maxsplit(&mut self, maxsplit: i64) -> Self {
        self.maxsplit = Some(maxsplit);
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> (Edge<i64>, Edge<String>, Edge<i64>) {
        let rc = Rc::new(self);
        (
        {
            Edge::<i64>::new(rc.clone(), 0)
        },
        {
            Edge::<String>::new(rc.clone(), 1)
        },
        {
            Edge::<i64>::new(rc.clone(), 2)
        },
        )
    }

    pub fn build(input: Edge<String>, sep: Edge<String>) -> Self {
        Self {
            input,
            sep,
            maxsplit: None,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(input: Edge<String>, sep: Edge<String>) -> (Edge<i64>, Edge<String>, Edge<i64>) {
        Self {
            input,
            sep,
            maxsplit: None,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<T> GraphOperation for _ScopedAllocator<T>
where T: TensorType,
      T: 'static,
      T: Clone,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("_ScopedAllocator_{}")?
        };
        let mut new_op = graph.new_operation("_ScopedAllocator", &op_name)?;
        {
            (|attrs| {new_op.set_attr_shape_list("shapes", attrs)})(&self.shapes)?
        }
        {
            (|attr| {new_op.set_attr_shape("shape", attr)})(&self.shape)?
        }
        {
            (|attr| {new_op.set_attr_string("sa_name", attr)})(&self.sa_name)?
        }
        {
            (|attr: &i64| {new_op.set_attr_int("id", *attr)})(&self.id)?
        }
        {
            (|attr: &i64| {new_op.set_attr_int("expected_call_count", *attr)})(&self.expected_call_count)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct _ScopedAllocator<T>
where T: TensorType,
      T: 'static,
      T: Clone,
{
    shapes: Vec<OtherShape>,
    shape: OtherShape,
    phantom_T: PhantomData<T>,
    sa_name: String,
    id: i64,
    expected_call_count: i64,
    op_name: Option<String>,
    id_: usize,
}

impl<T> _ScopedAllocator<T>
where T: TensorType,
      T: 'static,
      T: Clone,
{
    pub fn output(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(shapes: &[OtherShape], shape: &OtherShape, sa_name: &str, id: i64, expected_call_count: i64) -> Self {
        Self {
            shapes: shapes.to_vec(),
            shape: shape.clone(),
            phantom_T: PhantomData,
            sa_name: sa_name.to_string(),
            id: id,
            expected_call_count: expected_call_count,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(shapes: &[OtherShape], shape: &OtherShape, sa_name: &str, id: i64, expected_call_count: i64) -> Edge<T> {
        Self {
            shapes: shapes.to_vec(),
            shape: shape.clone(),
            phantom_T: PhantomData,
            sa_name: sa_name.to_string(),
            id: id,
            expected_call_count: expected_call_count,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<T> GraphOperation for MatrixLogarithm<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_COMPLEX64_or_DT_COMPLEX128,
      T: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("MatrixLogarithm_{}")?
        };
        let mut new_op = graph.new_operation("MatrixLogarithm", &op_name)?;
        {
            new_op.add_edge(&self.input)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct MatrixLogarithm<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_COMPLEX64_or_DT_COMPLEX128,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    input: Edge<T>,
    op_name: Option<String>,
    id_: usize,
}

impl<T> MatrixLogarithm<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_COMPLEX64_or_DT_COMPLEX128,
      T: 'static,
{
    pub fn output(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(input: Edge<T>) -> Self {
        Self {
            phantom_T: PhantomData,
            input,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(input: Edge<T>) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            input,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<dtype> GraphOperation for FakeParam<dtype>
where dtype: TensorType,
      dtype: 'static,
      dtype: Clone,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("FakeParam_{}")?
        };
        let mut new_op = graph.new_operation("FakeParam", &op_name)?;
        {
            (|attr| {new_op.set_attr_shape("shape", attr)})(&self.shape)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct FakeParam<dtype>
where dtype: TensorType,
      dtype: 'static,
      dtype: Clone,
{
    phantom_dtype: PhantomData<dtype>,
    shape: OtherShape,
    op_name: Option<String>,
    id_: usize,
}

impl<dtype> FakeParam<dtype>
where dtype: TensorType,
      dtype: 'static,
      dtype: Clone,
{
    pub fn output(self) -> Edge<dtype> {
        let rc = Rc::new(self);
        {
            Edge::<dtype>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<dtype> {
        let rc = Rc::new(self);
        {
            Edge::<dtype>::new(rc.clone(), 0)
        }
    }

    pub fn build(shape: &OtherShape) -> Self {
        Self {
            phantom_dtype: PhantomData,
            shape: shape.clone(),
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(shape: &OtherShape) -> Edge<dtype> {
        Self {
            phantom_dtype: PhantomData,
            shape: shape.clone(),
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<T> GraphOperation for XlaDot<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("XlaDot_{}")?
        };
        let mut new_op = graph.new_operation("XlaDot", &op_name)?;
        {
            new_op.add_edge(&self.lhs)?
        }
        {
            new_op.add_edge(&self.rhs)?
        }
        {
            (|attr| {new_op.set_attr_string("dimension_numbers", attr)})(&self.dimension_numbers)?
        }
        {
            (|attr| {new_op.set_attr_string("precision_config", attr)})(&self.precision_config)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct XlaDot<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    lhs: Edge<T>,
    rhs: Edge<T>,
    dimension_numbers: String,
    precision_config: String,
    op_name: Option<String>,
    id_: usize,
}

impl<T> XlaDot<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
{
    pub fn output(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(lhs: Edge<T>, rhs: Edge<T>, dimension_numbers: &str, precision_config: &str) -> Self {
        Self {
            phantom_T: PhantomData,
            lhs,
            rhs,
            dimension_numbers: dimension_numbers.to_string(),
            precision_config: precision_config.to_string(),
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(lhs: Edge<T>, rhs: Edge<T>, dimension_numbers: &str, precision_config: &str) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            lhs,
            rhs,
            dimension_numbers: dimension_numbers.to_string(),
            precision_config: precision_config.to_string(),
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<T> GraphOperation for Softsign<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
      T: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("Softsign_{}")?
        };
        let mut new_op = graph.new_operation("Softsign", &op_name)?;
        {
            new_op.add_edge(&self.features)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct Softsign<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    features: Edge<T>,
    op_name: Option<String>,
    id_: usize,
}

impl<T> Softsign<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
      T: 'static,
{
    pub fn activations(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(features: Edge<T>) -> Self {
        Self {
            phantom_T: PhantomData,
            features,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(features: Edge<T>) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            features,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<T> GraphOperation for NonMaxSuppressionV4<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_HALF,
      T: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("NonMaxSuppressionV4_{}")?
        };
        let mut new_op = graph.new_operation("NonMaxSuppressionV4", &op_name)?;
        {
            new_op.add_edge(&self.boxes)?
        }
        {
            new_op.add_edge(&self.scores)?
        }
        {
            new_op.add_edge(&self.max_output_size)?
        }
        {
            new_op.add_edge(&self.iou_threshold)?
        }
        {
            new_op.add_edge(&self.score_threshold)?
        }
        {
            match self.pad_to_max_output_size {
                None => new_op.set_attr_value_proto("pad_to_max_output_size", &vec![40_u8, 0_u8,])?,
                Some(ref value) => (|attr: &bool| {new_op.set_attr_bool("pad_to_max_output_size", *attr)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct NonMaxSuppressionV4<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_HALF,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    boxes: Edge<T>,
    scores: Edge<T>,
    max_output_size: Edge<i32>,
    iou_threshold: Edge<f32>,
    score_threshold: Edge<f32>,
    pad_to_max_output_size: Option<bool>,
    op_name: Option<String>,
    id_: usize,
}

impl<T> NonMaxSuppressionV4<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_HALF,
      T: 'static,
{
    pub fn selected_indices(self) -> Edge<i32> {
        let rc = Rc::new(self);
        {
            Edge::<i32>::new(rc.clone(), 0)
        }
    }

    pub fn valid_outputs(self) -> Edge<i32> {
        let rc = Rc::new(self);
        {
            Edge::<i32>::new(rc.clone(), 1)
        }
    }

    pub fn pad_to_max_output_size(&mut self, pad_to_max_output_size: bool) -> Self {
        self.pad_to_max_output_size = Some(pad_to_max_output_size);
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> (Edge<i32>, Edge<i32>) {
        let rc = Rc::new(self);
        (
        {
            Edge::<i32>::new(rc.clone(), 0)
        },
        {
            Edge::<i32>::new(rc.clone(), 1)
        },
        )
    }

    pub fn build(boxes: Edge<T>, scores: Edge<T>, max_output_size: Edge<i32>, iou_threshold: Edge<f32>, score_threshold: Edge<f32>) -> Self {
        Self {
            phantom_T: PhantomData,
            boxes,
            scores,
            max_output_size,
            iou_threshold,
            score_threshold,
            pad_to_max_output_size: None,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(boxes: Edge<T>, scores: Edge<T>, max_output_size: Edge<i32>, iou_threshold: Edge<f32>, score_threshold: Edge<f32>) -> (Edge<i32>, Edge<i32>) {
        Self {
            phantom_T: PhantomData,
            boxes,
            scores,
            max_output_size,
            iou_threshold,
            score_threshold,
            pad_to_max_output_size: None,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<T> GraphOperation for _Arg<T>
where T: TensorType,
      T: 'static,
      T: Clone,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("_Arg_{}")?
        };
        let mut new_op = graph.new_operation("_Arg", &op_name)?;
        {
            (|attr: &i64| {new_op.set_attr_int("index", *attr)})(&self.index)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct _Arg<T>
where T: TensorType,
      T: 'static,
      T: Clone,
{
    phantom_T: PhantomData<T>,
    index: i64,
    op_name: Option<String>,
    id_: usize,
}

impl<T> _Arg<T>
where T: TensorType,
      T: 'static,
      T: Clone,
{
    pub fn output(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(index: i64) -> Self {
        Self {
            phantom_T: PhantomData,
            index: index,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(index: i64) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            index: index,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<T> GraphOperation for TruncateDiv<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF,
      T: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("TruncateDiv_{}")?
        };
        let mut new_op = graph.new_operation("TruncateDiv", &op_name)?;
        {
            new_op.add_edge(&self.x)?
        }
        {
            new_op.add_edge(&self.y)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct TruncateDiv<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    x: Edge<T>,
    y: Edge<T>,
    op_name: Option<String>,
    id_: usize,
}

impl<T> TruncateDiv<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF,
      T: 'static,
{
    pub fn z(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(x: Edge<T>, y: Edge<T>) -> Self {
        Self {
            phantom_T: PhantomData,
            x,
            y,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(x: Edge<T>, y: Edge<T>) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            x,
            y,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<T> GraphOperation for _DeviceArg<T>
where T: TensorType,
      T: 'static,
      T: Clone,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("_DeviceArg_{}")?
        };
        let mut new_op = graph.new_operation("_DeviceArg", &op_name)?;
        {
            (|attr: &i64| {new_op.set_attr_int("index", *attr)})(&self.index)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct _DeviceArg<T>
where T: TensorType,
      T: 'static,
      T: Clone,
{
    phantom_T: PhantomData<T>,
    index: i64,
    op_name: Option<String>,
    id_: usize,
}

impl<T> _DeviceArg<T>
where T: TensorType,
      T: 'static,
      T: Clone,
{
    pub fn output(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(index: i64) -> Self {
        Self {
            phantom_T: PhantomData,
            index: index,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(index: i64) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            index: index,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl GraphOperation for RFFT3D {
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("RFFT3D_{}")?
        };
        let mut new_op = graph.new_operation("RFFT3D", &op_name)?;
        {
            new_op.add_edge(&self.input)?
        }
        {
            new_op.add_edge(&self.fft_length)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct RFFT3D {
    input: Edge<f32>,
    fft_length: Edge<i32>,
    op_name: Option<String>,
    id_: usize,
}

impl RFFT3D {
    pub fn output(self) -> Edge<OtherComplex<f32>> {
        let rc = Rc::new(self);
        {
            Edge::<OtherComplex::<f32>>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<OtherComplex<f32>> {
        let rc = Rc::new(self);
        {
            Edge::<OtherComplex::<f32>>::new(rc.clone(), 0)
        }
    }

    pub fn build(input: Edge<f32>, fft_length: Edge<i32>) -> Self {
        Self {
            input,
            fft_length,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(input: Edge<f32>, fft_length: Edge<i32>) -> Edge<OtherComplex<f32>> {
        Self {
            input,
            fft_length,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl GraphOperation for LogicalNot {
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("LogicalNot_{}")?
        };
        let mut new_op = graph.new_operation("LogicalNot", &op_name)?;
        {
            new_op.add_edge(&self.x)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct LogicalNot {
    x: Edge<bool>,
    op_name: Option<String>,
    id_: usize,
}

impl LogicalNot {
    pub fn y(self) -> Edge<bool> {
        let rc = Rc::new(self);
        {
            Edge::<bool>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<bool> {
        let rc = Rc::new(self);
        {
            Edge::<bool>::new(rc.clone(), 0)
        }
    }

    pub fn build(x: Edge<bool>) -> Self {
        Self {
            x,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(x: Edge<bool>) -> Edge<bool> {
        Self {
            x,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<T> GraphOperation for ApplyFtrl<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("ApplyFtrl_{}")?
        };
        let mut new_op = graph.new_operation("ApplyFtrl", &op_name)?;
        {
            new_op.add_edge(&self.var)?
        }
        {
            new_op.add_edge(&self.accum)?
        }
        {
            new_op.add_edge(&self.linear)?
        }
        {
            new_op.add_edge(&self.grad)?
        }
        {
            new_op.add_edge(&self.lr)?
        }
        {
            new_op.add_edge(&self.l1)?
        }
        {
            new_op.add_edge(&self.l2)?
        }
        {
            new_op.add_edge(&self.lr_power)?
        }
        {
            match self.use_locking {
                None => new_op.set_attr_value_proto("use_locking", &vec![40_u8, 0_u8,])?,
                Some(ref value) => (|attr: &bool| {new_op.set_attr_bool("use_locking", *attr)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct ApplyFtrl<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    var: Edge<T>,
    accum: Edge<T>,
    linear: Edge<T>,
    grad: Edge<T>,
    lr: Edge<T>,
    l1: Edge<T>,
    l2: Edge<T>,
    lr_power: Edge<T>,
    use_locking: Option<bool>,
    op_name: Option<String>,
    id_: usize,
}

impl<T> ApplyFtrl<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
{
    pub fn out(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn use_locking(&mut self, use_locking: bool) -> Self {
        self.use_locking = Some(use_locking);
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(var: Edge<T>, accum: Edge<T>, linear: Edge<T>, grad: Edge<T>, lr: Edge<T>, l1: Edge<T>, l2: Edge<T>, lr_power: Edge<T>) -> Self {
        Self {
            phantom_T: PhantomData,
            var,
            accum,
            linear,
            grad,
            lr,
            l1,
            l2,
            lr_power,
            use_locking: None,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(var: Edge<T>, accum: Edge<T>, linear: Edge<T>, grad: Edge<T>, lr: Edge<T>, l1: Edge<T>, l2: Edge<T>, lr_power: Edge<T>) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            var,
            accum,
            linear,
            grad,
            lr,
            l1,
            l2,
            lr_power,
            use_locking: None,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<T> GraphOperation for _Retval<T>
where T: TensorType,
      T: Clone,
      T: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("_Retval_{}")?
        };
        let mut new_op = graph.new_operation("_Retval", &op_name)?;
        {
            new_op.add_edge(&self.input)?
        }
        {
            (|attr: &i64| {new_op.set_attr_int("index", *attr)})(&self.index)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct _Retval<T>
where T: TensorType,
      T: Clone,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    input: Edge<T>,
    index: i64,
    op_name: Option<String>,
    id_: usize,
}

impl<T> _Retval<T>
where T: TensorType,
      T: Clone,
      T: 'static,
{
    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> () {
        let rc = Rc::new(self);
        (
        )
    }

    pub fn build(input: Edge<T>, index: i64) -> Self {
        Self {
            phantom_T: PhantomData,
            input,
            index: index,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(input: Edge<T>, index: i64) -> () {
        Self {
            phantom_T: PhantomData,
            input,
            index: index,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<T> GraphOperation for _DeviceRetval<T>
where T: TensorType,
      T: Clone,
      T: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("_DeviceRetval_{}")?
        };
        let mut new_op = graph.new_operation("_DeviceRetval", &op_name)?;
        {
            new_op.add_edge(&self.input)?
        }
        {
            (|attr: &i64| {new_op.set_attr_int("index", *attr)})(&self.index)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct _DeviceRetval<T>
where T: TensorType,
      T: Clone,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    input: Edge<T>,
    index: i64,
    op_name: Option<String>,
    id_: usize,
}

impl<T> _DeviceRetval<T>
where T: TensorType,
      T: Clone,
      T: 'static,
{
    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> () {
        let rc = Rc::new(self);
        (
        )
    }

    pub fn build(input: Edge<T>, index: i64) -> Self {
        Self {
            phantom_T: PhantomData,
            input,
            index: index,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(input: Edge<T>, index: i64) -> () {
        Self {
            phantom_T: PhantomData,
            input,
            index: index,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<T> GraphOperation for Xdivy<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_COMPLEX64_or_DT_COMPLEX128_or_DT_HALF,
      T: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("Xdivy_{}")?
        };
        let mut new_op = graph.new_operation("Xdivy", &op_name)?;
        {
            new_op.add_edge(&self.x)?
        }
        {
            new_op.add_edge(&self.y)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct Xdivy<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_COMPLEX64_or_DT_COMPLEX128_or_DT_HALF,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    x: Edge<T>,
    y: Edge<T>,
    op_name: Option<String>,
    id_: usize,
}

impl<T> Xdivy<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_COMPLEX64_or_DT_COMPLEX128_or_DT_HALF,
      T: 'static,
{
    pub fn z(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(x: Edge<T>, y: Edge<T>) -> Self {
        Self {
            phantom_T: PhantomData,
            x,
            y,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(x: Edge<T>, y: Edge<T>) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            x,
            y,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<T> GraphOperation for Cross<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("Cross_{}")?
        };
        let mut new_op = graph.new_operation("Cross", &op_name)?;
        {
            new_op.add_edge(&self.a)?
        }
        {
            new_op.add_edge(&self.b)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct Cross<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    a: Edge<T>,
    b: Edge<T>,
    op_name: Option<String>,
    id_: usize,
}

impl<T> Cross<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
{
    pub fn product(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(a: Edge<T>, b: Edge<T>) -> Self {
        Self {
            phantom_T: PhantomData,
            a,
            b,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(a: Edge<T>, b: Edge<T>) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            a,
            b,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<dtype> GraphOperation for TensorArrayGather<dtype>
where dtype: TensorType,
      dtype: 'static,
      dtype: Clone,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("TensorArrayGather_{}")?
        };
        let mut new_op = graph.new_operation("TensorArrayGather", &op_name)?;
        {
            new_op.add_edge(&self.handle)?
        }
        {
            new_op.add_edge(&self.indices)?
        }
        {
            new_op.add_edge(&self.flow_in)?
        }
        {
            match self.element_shape {
                None => new_op.set_attr_value_proto("element_shape", &vec![58_u8, 0_u8,])?,
                Some(ref value) => (|attr| {new_op.set_attr_shape("element_shape", attr)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct TensorArrayGather<dtype>
where dtype: TensorType,
      dtype: 'static,
      dtype: Clone,
{
    handle: Edge<String>,
    indices: Edge<i32>,
    flow_in: Edge<f32>,
    phantom_dtype: PhantomData<dtype>,
    element_shape: Option<OtherShape>,
    op_name: Option<String>,
    id_: usize,
}

impl<dtype> TensorArrayGather<dtype>
where dtype: TensorType,
      dtype: 'static,
      dtype: Clone,
{
    pub fn value(self) -> Edge<dtype> {
        let rc = Rc::new(self);
        {
            Edge::<dtype>::new(rc.clone(), 0)
        }
    }

    pub fn element_shape(&mut self, element_shape: &OtherShape) -> Self {
        self.element_shape = Some(element_shape.clone());
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<dtype> {
        let rc = Rc::new(self);
        {
            Edge::<dtype>::new(rc.clone(), 0)
        }
    }

    pub fn build(handle: Edge<String>, indices: Edge<i32>, flow_in: Edge<f32>) -> Self {
        Self {
            handle,
            indices,
            flow_in,
            phantom_dtype: PhantomData,
            element_shape: None,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(handle: Edge<String>, indices: Edge<i32>, flow_in: Edge<f32>) -> Edge<dtype> {
        Self {
            handle,
            indices,
            flow_in,
            phantom_dtype: PhantomData,
            element_shape: None,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<T, Tindices> GraphOperation for SegmentProd<T, Tindices>
where T: TensorType,
      T: Clone,
      Tindices: TensorType,
      Tindices: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
      Tindices: con_or_DT_INT32_or_DT_INT64,
      Tindices: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("SegmentProd_{}")?
        };
        let mut new_op = graph.new_operation("SegmentProd", &op_name)?;
        {
            new_op.add_edge(&self.data)?
        }
        {
            new_op.add_edge(&self.segment_ids)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct SegmentProd<T, Tindices>
where T: TensorType,
      T: Clone,
      Tindices: TensorType,
      Tindices: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
      Tindices: con_or_DT_INT32_or_DT_INT64,
      Tindices: 'static,
{
    phantom_T: PhantomData<T>,
    data: Edge<T>,
    phantom_Tindices: PhantomData<Tindices>,
    segment_ids: Edge<Tindices>,
    op_name: Option<String>,
    id_: usize,
}

impl<T, Tindices> SegmentProd<T, Tindices>
where T: TensorType,
      T: Clone,
      Tindices: TensorType,
      Tindices: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
      Tindices: con_or_DT_INT32_or_DT_INT64,
      Tindices: 'static,
{
    pub fn output(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(data: Edge<T>, segment_ids: Edge<Tindices>) -> Self {
        Self {
            phantom_T: PhantomData,
            data,
            phantom_Tindices: PhantomData,
            segment_ids,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(data: Edge<T>, segment_ids: Edge<Tindices>) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            data,
            phantom_Tindices: PhantomData,
            segment_ids,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<Tin, Tout> GraphOperation for LookupTableInsert<Tin, Tout>
where Tin: TensorType,
      Tin: Clone,
      Tout: TensorType,
      Tout: Clone,
      Tin: 'static,
      Tout: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("LookupTableInsert_{}")?
        };
        let mut new_op = graph.new_operation("LookupTableInsert", &op_name)?;
        {
            new_op.add_edge(&self.table_handle)?
        }
        {
            new_op.add_edge(&self.keys)?
        }
        {
            new_op.add_edge(&self.values)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct LookupTableInsert<Tin, Tout>
where Tin: TensorType,
      Tin: Clone,
      Tout: TensorType,
      Tout: Clone,
      Tin: 'static,
      Tout: 'static,
{
    table_handle: Edge<String>,
    phantom_Tin: PhantomData<Tin>,
    keys: Edge<Tin>,
    phantom_Tout: PhantomData<Tout>,
    values: Edge<Tout>,
    op_name: Option<String>,
    id_: usize,
}

impl<Tin, Tout> LookupTableInsert<Tin, Tout>
where Tin: TensorType,
      Tin: Clone,
      Tout: TensorType,
      Tout: Clone,
      Tin: 'static,
      Tout: 'static,
{
    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> () {
        let rc = Rc::new(self);
        (
        )
    }

    pub fn build(table_handle: Edge<String>, keys: Edge<Tin>, values: Edge<Tout>) -> Self {
        Self {
            table_handle,
            phantom_Tin: PhantomData,
            keys,
            phantom_Tout: PhantomData,
            values,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(table_handle: Edge<String>, keys: Edge<Tin>, values: Edge<Tout>) -> () {
        Self {
            table_handle,
            phantom_Tin: PhantomData,
            keys,
            phantom_Tout: PhantomData,
            values,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<T> GraphOperation for Bucketize<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_INT64,
      T: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("Bucketize_{}")?
        };
        let mut new_op = graph.new_operation("Bucketize", &op_name)?;
        {
            new_op.add_edge(&self.input)?
        }
        {
            (|attrs| {new_op.set_attr_float_list("boundaries", attrs)})(&self.boundaries)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct Bucketize<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_INT64,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    input: Edge<T>,
    boundaries: Vec<f32>,
    op_name: Option<String>,
    id_: usize,
}

impl<T> Bucketize<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_INT64,
      T: 'static,
{
    pub fn output(self) -> Edge<i32> {
        let rc = Rc::new(self);
        {
            Edge::<i32>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<i32> {
        let rc = Rc::new(self);
        {
            Edge::<i32>::new(rc.clone(), 0)
        }
    }

    pub fn build(input: Edge<T>, boundaries: &[f32]) -> Self {
        Self {
            phantom_T: PhantomData,
            input,
            boundaries: boundaries.to_vec(),
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(input: Edge<T>, boundaries: &[f32]) -> Edge<i32> {
        Self {
            phantom_T: PhantomData,
            input,
            boundaries: boundaries.to_vec(),
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<dt> GraphOperation for RestoreSlice<dt>
where dt: TensorType,
      dt: 'static,
      dt: Clone,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("RestoreSlice_{}")?
        };
        let mut new_op = graph.new_operation("RestoreSlice", &op_name)?;
        {
            new_op.add_edge(&self.file_pattern)?
        }
        {
            new_op.add_edge(&self.tensor_name)?
        }
        {
            new_op.add_edge(&self.shape_and_slice)?
        }
        {
            match self.preferred_shard {
                None => new_op.set_attr_value_proto("preferred_shard", &vec![24_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 1_u8,])?,
                Some(ref value) => (|attr: &i64| {new_op.set_attr_int("preferred_shard", *attr)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct RestoreSlice<dt>
where dt: TensorType,
      dt: 'static,
      dt: Clone,
{
    file_pattern: Edge<String>,
    tensor_name: Edge<String>,
    shape_and_slice: Edge<String>,
    phantom_dt: PhantomData<dt>,
    preferred_shard: Option<i64>,
    op_name: Option<String>,
    id_: usize,
}

impl<dt> RestoreSlice<dt>
where dt: TensorType,
      dt: 'static,
      dt: Clone,
{
    pub fn tensor(self) -> Edge<dt> {
        let rc = Rc::new(self);
        {
            Edge::<dt>::new(rc.clone(), 0)
        }
    }

    pub fn preferred_shard(&mut self, preferred_shard: i64) -> Self {
        self.preferred_shard = Some(preferred_shard);
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<dt> {
        let rc = Rc::new(self);
        {
            Edge::<dt>::new(rc.clone(), 0)
        }
    }

    pub fn build(file_pattern: Edge<String>, tensor_name: Edge<String>, shape_and_slice: Edge<String>) -> Self {
        Self {
            file_pattern,
            tensor_name,
            shape_and_slice,
            phantom_dt: PhantomData,
            preferred_shard: None,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(file_pattern: Edge<String>, tensor_name: Edge<String>, shape_and_slice: Edge<String>) -> Edge<dt> {
        Self {
            file_pattern,
            tensor_name,
            shape_and_slice,
            phantom_dt: PhantomData,
            preferred_shard: None,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl GraphOperation for RetrieveTPUEmbeddingStochasticGradientDescentParameters {
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("RetrieveTPUEmbeddingStochasticGradientDescentParameters_{}")?
        };
        let mut new_op = graph.new_operation("RetrieveTPUEmbeddingStochasticGradientDescentParameters", &op_name)?;
        {
            match self.table_id {
                None => new_op.set_attr_value_proto("table_id", &vec![24_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 1_u8,])?,
                Some(ref value) => (|attr: &i64| {new_op.set_attr_int("table_id", *attr)})(&value)?,
            };
        }
        {
            match self.table_name {
                None => new_op.set_attr_value_proto("table_name", &vec![18_u8, 0_u8,])?,
                Some(ref value) => (|attr| {new_op.set_attr_string("table_name", attr)})(&value)?,
            };
        }
        {
            (|attr: &i64| {new_op.set_attr_int("num_shards", *attr)})(&self.num_shards)?
        }
        {
            (|attr: &i64| {new_op.set_attr_int("shard_id", *attr)})(&self.shard_id)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct RetrieveTPUEmbeddingStochasticGradientDescentParameters {
    table_id: Option<i64>,
    table_name: Option<String>,
    num_shards: i64,
    shard_id: i64,
    op_name: Option<String>,
    id_: usize,
}

impl RetrieveTPUEmbeddingStochasticGradientDescentParameters {
    pub fn parameters(self) -> Edge<f32> {
        let rc = Rc::new(self);
        {
            Edge::<f32>::new(rc.clone(), 0)
        }
    }

    pub fn table_id(&mut self, table_id: i64) -> Self {
        self.table_id = Some(table_id);
        self.clone()
    }

    pub fn table_name(&mut self, table_name: &str) -> Self {
        self.table_name = Some(table_name.to_string());
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<f32> {
        let rc = Rc::new(self);
        {
            Edge::<f32>::new(rc.clone(), 0)
        }
    }

    pub fn build(num_shards: i64, shard_id: i64) -> Self {
        Self {
            table_id: None,
            table_name: None,
            num_shards: num_shards,
            shard_id: shard_id,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(num_shards: i64, shard_id: i64) -> Edge<f32> {
        Self {
            table_id: None,
            table_name: None,
            num_shards: num_shards,
            shard_id: shard_id,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<T, Tidx> GraphOperation for Cumprod<T, Tidx>
where T: TensorType,
      T: Clone,
      Tidx: TensorType,
      Tidx: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
      Tidx: con_or_DT_INT32_or_DT_INT64,
      Tidx: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("Cumprod_{}")?
        };
        let mut new_op = graph.new_operation("Cumprod", &op_name)?;
        {
            new_op.add_edge(&self.x)?
        }
        {
            new_op.add_edge(&self.axis)?
        }
        {
            match self.exclusive {
                None => new_op.set_attr_value_proto("exclusive", &vec![40_u8, 0_u8,])?,
                Some(ref value) => (|attr: &bool| {new_op.set_attr_bool("exclusive", *attr)})(&value)?,
            };
        }
        {
            match self.reverse {
                None => new_op.set_attr_value_proto("reverse", &vec![40_u8, 0_u8,])?,
                Some(ref value) => (|attr: &bool| {new_op.set_attr_bool("reverse", *attr)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct Cumprod<T, Tidx>
where T: TensorType,
      T: Clone,
      Tidx: TensorType,
      Tidx: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
      Tidx: con_or_DT_INT32_or_DT_INT64,
      Tidx: 'static,
{
    phantom_T: PhantomData<T>,
    x: Edge<T>,
    phantom_Tidx: PhantomData<Tidx>,
    axis: Edge<Tidx>,
    exclusive: Option<bool>,
    reverse: Option<bool>,
    op_name: Option<String>,
    id_: usize,
}

impl<T, Tidx> Cumprod<T, Tidx>
where T: TensorType,
      T: Clone,
      Tidx: TensorType,
      Tidx: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
      Tidx: con_or_DT_INT32_or_DT_INT64,
      Tidx: 'static,
{
    pub fn out(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn exclusive(&mut self, exclusive: bool) -> Self {
        self.exclusive = Some(exclusive);
        self.clone()
    }

    pub fn reverse(&mut self, reverse: bool) -> Self {
        self.reverse = Some(reverse);
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(x: Edge<T>, axis: Edge<Tidx>) -> Self {
        Self {
            phantom_T: PhantomData,
            x,
            phantom_Tidx: PhantomData,
            axis,
            exclusive: None,
            reverse: None,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(x: Edge<T>, axis: Edge<Tidx>) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            x,
            phantom_Tidx: PhantomData,
            axis,
            exclusive: None,
            reverse: None,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<T> GraphOperation for ResizeBicubic<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_UINT16_or_DT_HALF,
      T: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("ResizeBicubic_{}")?
        };
        let mut new_op = graph.new_operation("ResizeBicubic", &op_name)?;
        {
            new_op.add_edge(&self.images)?
        }
        {
            new_op.add_edge(&self.size)?
        }
        {
            match self.align_corners {
                None => new_op.set_attr_value_proto("align_corners", &vec![40_u8, 0_u8,])?,
                Some(ref value) => (|attr: &bool| {new_op.set_attr_bool("align_corners", *attr)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct ResizeBicubic<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_UINT16_or_DT_HALF,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    images: Edge<T>,
    size: Edge<i32>,
    align_corners: Option<bool>,
    op_name: Option<String>,
    id_: usize,
}

impl<T> ResizeBicubic<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_UINT16_or_DT_HALF,
      T: 'static,
{
    pub fn resized_images(self) -> Edge<f32> {
        let rc = Rc::new(self);
        {
            Edge::<f32>::new(rc.clone(), 0)
        }
    }

    pub fn align_corners(&mut self, align_corners: bool) -> Self {
        self.align_corners = Some(align_corners);
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<f32> {
        let rc = Rc::new(self);
        {
            Edge::<f32>::new(rc.clone(), 0)
        }
    }

    pub fn build(images: Edge<T>, size: Edge<i32>) -> Self {
        Self {
            phantom_T: PhantomData,
            images,
            size,
            align_corners: None,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(images: Edge<T>, size: Edge<i32>) -> Edge<f32> {
        Self {
            phantom_T: PhantomData,
            images,
            size,
            align_corners: None,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<T> GraphOperation for Log1p<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_COMPLEX64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF,
      T: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("Log1p_{}")?
        };
        let mut new_op = graph.new_operation("Log1p", &op_name)?;
        {
            new_op.add_edge(&self.x)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct Log1p<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_COMPLEX64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    x: Edge<T>,
    op_name: Option<String>,
    id_: usize,
}

impl<T> Log1p<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_COMPLEX64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF,
      T: 'static,
{
    pub fn y(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(x: Edge<T>) -> Self {
        Self {
            phantom_T: PhantomData,
            x,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(x: Edge<T>) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            x,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

pub trait con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF for BFloat16 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF for f32 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF for f64 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF for i16 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF for i32 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF for i64 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF for i8 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF for u16 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF for u8 {
}

impl<T> GraphOperation for ResizeBilinear<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF,
      T: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("ResizeBilinear_{}")?
        };
        let mut new_op = graph.new_operation("ResizeBilinear", &op_name)?;
        {
            new_op.add_edge(&self.images)?
        }
        {
            new_op.add_edge(&self.size)?
        }
        {
            match self.align_corners {
                None => new_op.set_attr_value_proto("align_corners", &vec![40_u8, 0_u8,])?,
                Some(ref value) => (|attr: &bool| {new_op.set_attr_bool("align_corners", *attr)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct ResizeBilinear<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    images: Edge<T>,
    size: Edge<i32>,
    align_corners: Option<bool>,
    op_name: Option<String>,
    id_: usize,
}

impl<T> ResizeBilinear<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF,
      T: 'static,
{
    pub fn resized_images(self) -> Edge<f32> {
        let rc = Rc::new(self);
        {
            Edge::<f32>::new(rc.clone(), 0)
        }
    }

    pub fn align_corners(&mut self, align_corners: bool) -> Self {
        self.align_corners = Some(align_corners);
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<f32> {
        let rc = Rc::new(self);
        {
            Edge::<f32>::new(rc.clone(), 0)
        }
    }

    pub fn build(images: Edge<T>, size: Edge<i32>) -> Self {
        Self {
            phantom_T: PhantomData,
            images,
            size,
            align_corners: None,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(images: Edge<T>, size: Edge<i32>) -> Edge<f32> {
        Self {
            phantom_T: PhantomData,
            images,
            size,
            align_corners: None,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<T, Tidx> GraphOperation for Prod<T, Tidx>
where T: TensorType,
      T: Clone,
      Tidx: TensorType,
      Tidx: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
      Tidx: con_or_DT_INT32_or_DT_INT64,
      Tidx: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("Prod_{}")?
        };
        let mut new_op = graph.new_operation("Prod", &op_name)?;
        {
            new_op.add_edge(&self.input)?
        }
        {
            new_op.add_edge(&self.reduction_indices)?
        }
        {
            match self.keep_dims {
                None => new_op.set_attr_value_proto("keep_dims", &vec![40_u8, 0_u8,])?,
                Some(ref value) => (|attr: &bool| {new_op.set_attr_bool("keep_dims", *attr)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct Prod<T, Tidx>
where T: TensorType,
      T: Clone,
      Tidx: TensorType,
      Tidx: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
      Tidx: con_or_DT_INT32_or_DT_INT64,
      Tidx: 'static,
{
    phantom_T: PhantomData<T>,
    input: Edge<T>,
    phantom_Tidx: PhantomData<Tidx>,
    reduction_indices: Edge<Tidx>,
    keep_dims: Option<bool>,
    op_name: Option<String>,
    id_: usize,
}

impl<T, Tidx> Prod<T, Tidx>
where T: TensorType,
      T: Clone,
      Tidx: TensorType,
      Tidx: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
      Tidx: con_or_DT_INT32_or_DT_INT64,
      Tidx: 'static,
{
    pub fn output(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn keep_dims(&mut self, keep_dims: bool) -> Self {
        self.keep_dims = Some(keep_dims);
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(input: Edge<T>, reduction_indices: Edge<Tidx>) -> Self {
        Self {
            phantom_T: PhantomData,
            input,
            phantom_Tidx: PhantomData,
            reduction_indices,
            keep_dims: None,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(input: Edge<T>, reduction_indices: Edge<Tidx>) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            input,
            phantom_Tidx: PhantomData,
            reduction_indices,
            keep_dims: None,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<component_types> GraphOperation for PaddingFIFOQueue<component_types>
where component_types: 'static,
      component_types: Clone,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("PaddingFIFOQueue_{}")?
        };
        let mut new_op = graph.new_operation("PaddingFIFOQueue", &op_name)?;
        {
            match self.shapes {
                None => new_op.set_attr_value_proto("shapes", &vec![10_u8, 0_u8,])?,
                Some(ref value) => (|attrs| {new_op.set_attr_shape_list("shapes", attrs)})(&value)?,
            };
        }
        {
            match self.capacity {
                None => new_op.set_attr_value_proto("capacity", &vec![24_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 1_u8,])?,
                Some(ref value) => (|attr: &i64| {new_op.set_attr_int("capacity", *attr)})(&value)?,
            };
        }
        {
            match self.container {
                None => new_op.set_attr_value_proto("container", &vec![18_u8, 0_u8,])?,
                Some(ref value) => (|attr| {new_op.set_attr_string("container", attr)})(&value)?,
            };
        }
        {
            match self.shared_name {
                None => new_op.set_attr_value_proto("shared_name", &vec![18_u8, 0_u8,])?,
                Some(ref value) => (|attr| {new_op.set_attr_string("shared_name", attr)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct PaddingFIFOQueue<component_types>
where component_types: 'static,
      component_types: Clone,
{
    phantom_component_types: PhantomData<component_types>,
    shapes: Option<Vec<OtherShape>>,
    capacity: Option<i64>,
    container: Option<String>,
    shared_name: Option<String>,
    op_name: Option<String>,
    id_: usize,
}

impl<component_types> PaddingFIFOQueue<component_types>
where component_types: 'static,
      component_types: Clone,
{
    pub fn handle(self) -> Edge<String> {
        let rc = Rc::new(self);
        {
            Edge::<String>::new(rc.clone(), 0)
        }
    }

    pub fn shapes(&mut self, shapes: &[OtherShape]) -> Self {
        self.shapes = Some(shapes.to_vec());
        self.clone()
    }

    pub fn capacity(&mut self, capacity: i64) -> Self {
        self.capacity = Some(capacity);
        self.clone()
    }

    pub fn container(&mut self, container: &str) -> Self {
        self.container = Some(container.to_string());
        self.clone()
    }

    pub fn shared_name(&mut self, shared_name: &str) -> Self {
        self.shared_name = Some(shared_name.to_string());
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<String> {
        let rc = Rc::new(self);
        {
            Edge::<String>::new(rc.clone(), 0)
        }
    }

    pub fn build() -> Self {
        Self {
            phantom_component_types: PhantomData,
            shapes: None,
            capacity: None,
            container: None,
            shared_name: None,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new() -> Edge<String> {
        Self {
            phantom_component_types: PhantomData,
            shapes: None,
            capacity: None,
            container: None,
            shared_name: None,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

pub trait con_or_DT_FLOAT_or_DT_QUINT8_or_DT_QINT32 {
}

impl con_or_DT_FLOAT_or_DT_QUINT8_or_DT_QINT32 for f32 {
}

impl con_or_DT_FLOAT_or_DT_QUINT8_or_DT_QINT32 for i32 {
}

impl con_or_DT_FLOAT_or_DT_QUINT8_or_DT_QINT32 for u8 {
}

impl<T> GraphOperation for QuantizedResizeBilinear<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_QUINT8_or_DT_QINT32,
      T: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("QuantizedResizeBilinear_{}")?
        };
        let mut new_op = graph.new_operation("QuantizedResizeBilinear", &op_name)?;
        {
            new_op.add_edge(&self.images)?
        }
        {
            new_op.add_edge(&self.size)?
        }
        {
            new_op.add_edge(&self.min)?
        }
        {
            new_op.add_edge(&self.max)?
        }
        {
            match self.align_corners {
                None => new_op.set_attr_value_proto("align_corners", &vec![40_u8, 0_u8,])?,
                Some(ref value) => (|attr: &bool| {new_op.set_attr_bool("align_corners", *attr)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct QuantizedResizeBilinear<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_QUINT8_or_DT_QINT32,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    images: Edge<T>,
    size: Edge<i32>,
    min: Edge<f32>,
    max: Edge<f32>,
    align_corners: Option<bool>,
    op_name: Option<String>,
    id_: usize,
}

impl<T> QuantizedResizeBilinear<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_QUINT8_or_DT_QINT32,
      T: 'static,
{
    pub fn resized_images(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn out_min(self) -> Edge<f32> {
        let rc = Rc::new(self);
        {
            Edge::<f32>::new(rc.clone(), 1)
        }
    }

    pub fn out_max(self) -> Edge<f32> {
        let rc = Rc::new(self);
        {
            Edge::<f32>::new(rc.clone(), 2)
        }
    }

    pub fn align_corners(&mut self, align_corners: bool) -> Self {
        self.align_corners = Some(align_corners);
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> (Edge<T>, Edge<f32>, Edge<f32>) {
        let rc = Rc::new(self);
        (
        {
            Edge::<T>::new(rc.clone(), 0)
        },
        {
            Edge::<f32>::new(rc.clone(), 1)
        },
        {
            Edge::<f32>::new(rc.clone(), 2)
        },
        )
    }

    pub fn build(images: Edge<T>, size: Edge<i32>, min: Edge<f32>, max: Edge<f32>) -> Self {
        Self {
            phantom_T: PhantomData,
            images,
            size,
            min,
            max,
            align_corners: None,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(images: Edge<T>, size: Edge<i32>, min: Edge<f32>, max: Edge<f32>) -> (Edge<T>, Edge<f32>, Edge<f32>) {
        Self {
            phantom_T: PhantomData,
            images,
            size,
            min,
            max,
            align_corners: None,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<dt> GraphOperation for Restore<dt>
where dt: TensorType,
      dt: 'static,
      dt: Clone,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("Restore_{}")?
        };
        let mut new_op = graph.new_operation("Restore", &op_name)?;
        {
            new_op.add_edge(&self.file_pattern)?
        }
        {
            new_op.add_edge(&self.tensor_name)?
        }
        {
            match self.preferred_shard {
                None => new_op.set_attr_value_proto("preferred_shard", &vec![24_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 1_u8,])?,
                Some(ref value) => (|attr: &i64| {new_op.set_attr_int("preferred_shard", *attr)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct Restore<dt>
where dt: TensorType,
      dt: 'static,
      dt: Clone,
{
    file_pattern: Edge<String>,
    tensor_name: Edge<String>,
    phantom_dt: PhantomData<dt>,
    preferred_shard: Option<i64>,
    op_name: Option<String>,
    id_: usize,
}

impl<dt> Restore<dt>
where dt: TensorType,
      dt: 'static,
      dt: Clone,
{
    pub fn tensor(self) -> Edge<dt> {
        let rc = Rc::new(self);
        {
            Edge::<dt>::new(rc.clone(), 0)
        }
    }

    pub fn preferred_shard(&mut self, preferred_shard: i64) -> Self {
        self.preferred_shard = Some(preferred_shard);
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<dt> {
        let rc = Rc::new(self);
        {
            Edge::<dt>::new(rc.clone(), 0)
        }
    }

    pub fn build(file_pattern: Edge<String>, tensor_name: Edge<String>) -> Self {
        Self {
            file_pattern,
            tensor_name,
            phantom_dt: PhantomData,
            preferred_shard: None,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(file_pattern: Edge<String>, tensor_name: Edge<String>) -> Edge<dt> {
        Self {
            file_pattern,
            tensor_name,
            phantom_dt: PhantomData,
            preferred_shard: None,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<T> GraphOperation for ResizeBilinearGrad<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
      T: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("ResizeBilinearGrad_{}")?
        };
        let mut new_op = graph.new_operation("ResizeBilinearGrad", &op_name)?;
        {
            new_op.add_edge(&self.grads)?
        }
        {
            new_op.add_edge(&self.original_image)?
        }
        {
            match self.align_corners {
                None => new_op.set_attr_value_proto("align_corners", &vec![40_u8, 0_u8,])?,
                Some(ref value) => (|attr: &bool| {new_op.set_attr_bool("align_corners", *attr)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct ResizeBilinearGrad<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
      T: 'static,
{
    grads: Edge<f32>,
    phantom_T: PhantomData<T>,
    original_image: Edge<T>,
    align_corners: Option<bool>,
    op_name: Option<String>,
    id_: usize,
}

impl<T> ResizeBilinearGrad<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
      T: 'static,
{
    pub fn output(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn align_corners(&mut self, align_corners: bool) -> Self {
        self.align_corners = Some(align_corners);
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(grads: Edge<f32>, original_image: Edge<T>) -> Self {
        Self {
            grads,
            phantom_T: PhantomData,
            original_image,
            align_corners: None,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(grads: Edge<f32>, original_image: Edge<T>) -> Edge<T> {
        Self {
            grads,
            phantom_T: PhantomData,
            original_image,
            align_corners: None,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<T> GraphOperation for Ceil<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
      T: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("Ceil_{}")?
        };
        let mut new_op = graph.new_operation("Ceil", &op_name)?;
        {
            new_op.add_edge(&self.x)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct Ceil<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    x: Edge<T>,
    op_name: Option<String>,
    id_: usize,
}

impl<T> Ceil<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
      T: 'static,
{
    pub fn y(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(x: Edge<T>) -> Self {
        Self {
            phantom_T: PhantomData,
            x,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(x: Edge<T>) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            x,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<T> GraphOperation for ResizeNearestNeighbor<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_UINT16_or_DT_HALF,
      T: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("ResizeNearestNeighbor_{}")?
        };
        let mut new_op = graph.new_operation("ResizeNearestNeighbor", &op_name)?;
        {
            new_op.add_edge(&self.images)?
        }
        {
            new_op.add_edge(&self.size)?
        }
        {
            match self.align_corners {
                None => new_op.set_attr_value_proto("align_corners", &vec![40_u8, 0_u8,])?,
                Some(ref value) => (|attr: &bool| {new_op.set_attr_bool("align_corners", *attr)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct ResizeNearestNeighbor<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_UINT16_or_DT_HALF,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    images: Edge<T>,
    size: Edge<i32>,
    align_corners: Option<bool>,
    op_name: Option<String>,
    id_: usize,
}

impl<T> ResizeNearestNeighbor<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_UINT16_or_DT_HALF,
      T: 'static,
{
    pub fn resized_images(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn align_corners(&mut self, align_corners: bool) -> Self {
        self.align_corners = Some(align_corners);
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(images: Edge<T>, size: Edge<i32>) -> Self {
        Self {
            phantom_T: PhantomData,
            images,
            size,
            align_corners: None,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(images: Edge<T>, size: Edge<i32>) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            images,
            size,
            align_corners: None,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

pub trait con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64 for f32 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64 for f64 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64 for i16 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64 for i32 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64 for i64 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64 for i8 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64 for u8 {
}

impl<T> GraphOperation for RandomCrop<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64,
      T: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("RandomCrop_{}")?
        };
        let mut new_op = graph.new_operation("RandomCrop", &op_name)?;
        {
            new_op.add_edge(&self.image)?
        }
        {
            new_op.add_edge(&self.size)?
        }
        {
            match self.seed {
                None => new_op.set_attr_value_proto("seed", &vec![24_u8, 0_u8,])?,
                Some(ref value) => (|attr: &i64| {new_op.set_attr_int("seed", *attr)})(&value)?,
            };
        }
        {
            match self.seed2 {
                None => new_op.set_attr_value_proto("seed2", &vec![24_u8, 0_u8,])?,
                Some(ref value) => (|attr: &i64| {new_op.set_attr_int("seed2", *attr)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct RandomCrop<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    image: Edge<T>,
    size: Edge<i64>,
    seed: Option<i64>,
    seed2: Option<i64>,
    op_name: Option<String>,
    id_: usize,
}

impl<T> RandomCrop<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64,
      T: 'static,
{
    pub fn output(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn seed(&mut self, seed: i64) -> Self {
        self.seed = Some(seed);
        self.clone()
    }

    pub fn seed2(&mut self, seed2: i64) -> Self {
        self.seed2 = Some(seed2);
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(image: Edge<T>, size: Edge<i64>) -> Self {
        Self {
            phantom_T: PhantomData,
            image,
            size,
            seed: None,
            seed2: None,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(image: Edge<T>, size: Edge<i64>) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            image,
            size,
            seed: None,
            seed2: None,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<T> GraphOperation for SerializeTensor<T>
where T: TensorType,
      T: Clone,
      T: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("SerializeTensor_{}")?
        };
        let mut new_op = graph.new_operation("SerializeTensor", &op_name)?;
        {
            new_op.add_edge(&self.tensor)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct SerializeTensor<T>
where T: TensorType,
      T: Clone,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    tensor: Edge<T>,
    op_name: Option<String>,
    id_: usize,
}

impl<T> SerializeTensor<T>
where T: TensorType,
      T: Clone,
      T: 'static,
{
    pub fn serialized(self) -> Edge<String> {
        let rc = Rc::new(self);
        {
            Edge::<String>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<String> {
        let rc = Rc::new(self);
        {
            Edge::<String>::new(rc.clone(), 0)
        }
    }

    pub fn build(tensor: Edge<T>) -> Self {
        Self {
            phantom_T: PhantomData,
            tensor,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(tensor: Edge<T>) -> Edge<String> {
        Self {
            phantom_T: PhantomData,
            tensor,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<SrcT, DstT> GraphOperation for _HostCast<SrcT, DstT>
where SrcT: TensorType,
      SrcT: Clone,
      DstT: TensorType,
      SrcT: 'static,
      DstT: 'static,
      DstT: Clone,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("_HostCast_{}")?
        };
        let mut new_op = graph.new_operation("_HostCast", &op_name)?;
        {
            new_op.add_edge(&self.x)?
        }
        {
            match self.Truncate {
                None => new_op.set_attr_value_proto("Truncate", &vec![40_u8, 0_u8,])?,
                Some(ref value) => (|attr: &bool| {new_op.set_attr_bool("Truncate", *attr)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct _HostCast<SrcT, DstT>
where SrcT: TensorType,
      SrcT: Clone,
      DstT: TensorType,
      SrcT: 'static,
      DstT: 'static,
      DstT: Clone,
{
    phantom_SrcT: PhantomData<SrcT>,
    x: Edge<SrcT>,
    phantom_DstT: PhantomData<DstT>,
    Truncate: Option<bool>,
    op_name: Option<String>,
    id_: usize,
}

impl<SrcT, DstT> _HostCast<SrcT, DstT>
where SrcT: TensorType,
      SrcT: Clone,
      DstT: TensorType,
      SrcT: 'static,
      DstT: 'static,
      DstT: Clone,
{
    pub fn y(self) -> Edge<DstT> {
        let rc = Rc::new(self);
        {
            Edge::<DstT>::new(rc.clone(), 0)
        }
    }

    pub fn Truncate(&mut self, Truncate: bool) -> Self {
        self.Truncate = Some(Truncate);
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<DstT> {
        let rc = Rc::new(self);
        {
            Edge::<DstT>::new(rc.clone(), 0)
        }
    }

    pub fn build(x: Edge<SrcT>) -> Self {
        Self {
            phantom_SrcT: PhantomData,
            x,
            phantom_DstT: PhantomData,
            Truncate: None,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(x: Edge<SrcT>) -> Edge<DstT> {
        Self {
            phantom_SrcT: PhantomData,
            x,
            phantom_DstT: PhantomData,
            Truncate: None,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<T, output_dtype> GraphOperation for Multinomial<T, output_dtype>
where T: TensorType,
      T: Clone,
      output_dtype: TensorType,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
      output_dtype: con_or_DT_INT32_or_DT_INT64,
      output_dtype: 'static,
      output_dtype: Clone,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("Multinomial_{}")?
        };
        let mut new_op = graph.new_operation("Multinomial", &op_name)?;
        {
            new_op.add_edge(&self.logits)?
        }
        {
            new_op.add_edge(&self.num_samples)?
        }
        {
            match self.seed {
                None => new_op.set_attr_value_proto("seed", &vec![24_u8, 0_u8,])?,
                Some(ref value) => (|attr: &i64| {new_op.set_attr_int("seed", *attr)})(&value)?,
            };
        }
        {
            match self.seed2 {
                None => new_op.set_attr_value_proto("seed2", &vec![24_u8, 0_u8,])?,
                Some(ref value) => (|attr: &i64| {new_op.set_attr_int("seed2", *attr)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct Multinomial<T, output_dtype>
where T: TensorType,
      T: Clone,
      output_dtype: TensorType,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
      output_dtype: con_or_DT_INT32_or_DT_INT64,
      output_dtype: 'static,
      output_dtype: Clone,
{
    phantom_T: PhantomData<T>,
    logits: Edge<T>,
    num_samples: Edge<i32>,
    seed: Option<i64>,
    seed2: Option<i64>,
    phantom_output_dtype: PhantomData<output_dtype>,
    op_name: Option<String>,
    id_: usize,
}

impl<T, output_dtype> Multinomial<T, output_dtype>
where T: TensorType,
      T: Clone,
      output_dtype: TensorType,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
      output_dtype: con_or_DT_INT32_or_DT_INT64,
      output_dtype: 'static,
      output_dtype: Clone,
{
    pub fn output(self) -> Edge<output_dtype> {
        let rc = Rc::new(self);
        {
            Edge::<output_dtype>::new(rc.clone(), 0)
        }
    }

    pub fn seed(&mut self, seed: i64) -> Self {
        self.seed = Some(seed);
        self.clone()
    }

    pub fn seed2(&mut self, seed2: i64) -> Self {
        self.seed2 = Some(seed2);
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<output_dtype> {
        let rc = Rc::new(self);
        {
            Edge::<output_dtype>::new(rc.clone(), 0)
        }
    }

    pub fn build(logits: Edge<T>, num_samples: Edge<i32>) -> Self {
        Self {
            phantom_T: PhantomData,
            logits,
            num_samples,
            seed: None,
            seed2: None,
            phantom_output_dtype: PhantomData,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(logits: Edge<T>, num_samples: Edge<i32>) -> Edge<output_dtype> {
        Self {
            phantom_T: PhantomData,
            logits,
            num_samples,
            seed: None,
            seed2: None,
            phantom_output_dtype: PhantomData,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl GraphOperation for EncodeJpeg {
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("EncodeJpeg_{}")?
        };
        let mut new_op = graph.new_operation("EncodeJpeg", &op_name)?;
        {
            new_op.add_edge(&self.image)?
        }
        {
            match self.format {
                None => new_op.set_attr_value_proto("format", &vec![18_u8, 0_u8,])?,
                Some(ref value) => (|attr| {new_op.set_attr_string("format", attr)})(&value)?,
            };
        }
        {
            match self.quality {
                None => new_op.set_attr_value_proto("quality", &vec![24_u8, 95_u8,])?,
                Some(ref value) => (|attr: &i64| {new_op.set_attr_int("quality", *attr)})(&value)?,
            };
        }
        {
            match self.progressive {
                None => new_op.set_attr_value_proto("progressive", &vec![40_u8, 0_u8,])?,
                Some(ref value) => (|attr: &bool| {new_op.set_attr_bool("progressive", *attr)})(&value)?,
            };
        }
        {
            match self.optimize_size {
                None => new_op.set_attr_value_proto("optimize_size", &vec![40_u8, 0_u8,])?,
                Some(ref value) => (|attr: &bool| {new_op.set_attr_bool("optimize_size", *attr)})(&value)?,
            };
        }
        {
            match self.chroma_downsampling {
                None => new_op.set_attr_value_proto("chroma_downsampling", &vec![40_u8, 1_u8,])?,
                Some(ref value) => (|attr: &bool| {new_op.set_attr_bool("chroma_downsampling", *attr)})(&value)?,
            };
        }
        {
            match self.density_unit {
                None => new_op.set_attr_value_proto("density_unit", &vec![18_u8, 2_u8, 105_u8, 110_u8,])?,
                Some(ref value) => (|attr| {new_op.set_attr_string("density_unit", attr)})(&value)?,
            };
        }
        {
            match self.x_density {
                None => new_op.set_attr_value_proto("x_density", &vec![24_u8, 172_u8, 2_u8,])?,
                Some(ref value) => (|attr: &i64| {new_op.set_attr_int("x_density", *attr)})(&value)?,
            };
        }
        {
            match self.y_density {
                None => new_op.set_attr_value_proto("y_density", &vec![24_u8, 172_u8, 2_u8,])?,
                Some(ref value) => (|attr: &i64| {new_op.set_attr_int("y_density", *attr)})(&value)?,
            };
        }
        {
            match self.xmp_metadata {
                None => new_op.set_attr_value_proto("xmp_metadata", &vec![18_u8, 0_u8,])?,
                Some(ref value) => (|attr| {new_op.set_attr_string("xmp_metadata", attr)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct EncodeJpeg {
    image: Edge<u8>,
    format: Option<String>,
    quality: Option<i64>,
    progressive: Option<bool>,
    optimize_size: Option<bool>,
    chroma_downsampling: Option<bool>,
    density_unit: Option<String>,
    x_density: Option<i64>,
    y_density: Option<i64>,
    xmp_metadata: Option<String>,
    op_name: Option<String>,
    id_: usize,
}

impl EncodeJpeg {
    pub fn contents(self) -> Edge<String> {
        let rc = Rc::new(self);
        {
            Edge::<String>::new(rc.clone(), 0)
        }
    }

    pub fn format(&mut self, format: &str) -> Self {
        self.format = Some(format.to_string());
        self.clone()
    }

    pub fn quality(&mut self, quality: i64) -> Self {
        self.quality = Some(quality);
        self.clone()
    }

    pub fn progressive(&mut self, progressive: bool) -> Self {
        self.progressive = Some(progressive);
        self.clone()
    }

    pub fn optimize_size(&mut self, optimize_size: bool) -> Self {
        self.optimize_size = Some(optimize_size);
        self.clone()
    }

    pub fn chroma_downsampling(&mut self, chroma_downsampling: bool) -> Self {
        self.chroma_downsampling = Some(chroma_downsampling);
        self.clone()
    }

    pub fn density_unit(&mut self, density_unit: &str) -> Self {
        self.density_unit = Some(density_unit.to_string());
        self.clone()
    }

    pub fn x_density(&mut self, x_density: i64) -> Self {
        self.x_density = Some(x_density);
        self.clone()
    }

    pub fn y_density(&mut self, y_density: i64) -> Self {
        self.y_density = Some(y_density);
        self.clone()
    }

    pub fn xmp_metadata(&mut self, xmp_metadata: &str) -> Self {
        self.xmp_metadata = Some(xmp_metadata.to_string());
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<String> {
        let rc = Rc::new(self);
        {
            Edge::<String>::new(rc.clone(), 0)
        }
    }

    pub fn build(image: Edge<u8>) -> Self {
        Self {
            image,
            format: None,
            quality: None,
            progressive: None,
            optimize_size: None,
            chroma_downsampling: None,
            density_unit: None,
            x_density: None,
            y_density: None,
            xmp_metadata: None,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(image: Edge<u8>) -> Edge<String> {
        Self {
            image,
            format: None,
            quality: None,
            progressive: None,
            optimize_size: None,
            chroma_downsampling: None,
            density_unit: None,
            x_density: None,
            y_density: None,
            xmp_metadata: None,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<T> GraphOperation for BatchNormWithGlobalNormalizationGrad<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("BatchNormWithGlobalNormalizationGrad_{}")?
        };
        let mut new_op = graph.new_operation("BatchNormWithGlobalNormalizationGrad", &op_name)?;
        {
            new_op.add_edge(&self.t)?
        }
        {
            new_op.add_edge(&self.m)?
        }
        {
            new_op.add_edge(&self.v)?
        }
        {
            new_op.add_edge(&self.gamma)?
        }
        {
            new_op.add_edge(&self.backprop)?
        }
        {
            (|attr: &f32| {new_op.set_attr_float("variance_epsilon", *attr)})(&self.variance_epsilon)?
        }
        {
            (|attr: &bool| {new_op.set_attr_bool("scale_after_normalization", *attr)})(&self.scale_after_normalization)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct BatchNormWithGlobalNormalizationGrad<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    t: Edge<T>,
    m: Edge<T>,
    v: Edge<T>,
    gamma: Edge<T>,
    backprop: Edge<T>,
    variance_epsilon: f32,
    scale_after_normalization: bool,
    op_name: Option<String>,
    id_: usize,
}

impl<T> BatchNormWithGlobalNormalizationGrad<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
{
    pub fn dx(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn dm(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 1)
        }
    }

    pub fn dv(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 2)
        }
    }

    pub fn db(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 3)
        }
    }

    pub fn dg(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 4)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> (Edge<T>, Edge<T>, Edge<T>, Edge<T>, Edge<T>) {
        let rc = Rc::new(self);
        (
        {
            Edge::<T>::new(rc.clone(), 0)
        },
        {
            Edge::<T>::new(rc.clone(), 1)
        },
        {
            Edge::<T>::new(rc.clone(), 2)
        },
        {
            Edge::<T>::new(rc.clone(), 3)
        },
        {
            Edge::<T>::new(rc.clone(), 4)
        },
        )
    }

    pub fn build(t: Edge<T>, m: Edge<T>, v: Edge<T>, gamma: Edge<T>, backprop: Edge<T>, variance_epsilon: f32, scale_after_normalization: bool) -> Self {
        Self {
            phantom_T: PhantomData,
            t,
            m,
            v,
            gamma,
            backprop,
            variance_epsilon: variance_epsilon,
            scale_after_normalization: scale_after_normalization,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(t: Edge<T>, m: Edge<T>, v: Edge<T>, gamma: Edge<T>, backprop: Edge<T>, variance_epsilon: f32, scale_after_normalization: bool) -> (Edge<T>, Edge<T>, Edge<T>, Edge<T>, Edge<T>) {
        Self {
            phantom_T: PhantomData,
            t,
            m,
            v,
            gamma,
            backprop,
            variance_epsilon: variance_epsilon,
            scale_after_normalization: scale_after_normalization,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl GraphOperation for AdjustContrastv2 {
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("AdjustContrastv2_{}")?
        };
        let mut new_op = graph.new_operation("AdjustContrastv2", &op_name)?;
        {
            new_op.add_edge(&self.images)?
        }
        {
            new_op.add_edge(&self.contrast_factor)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct AdjustContrastv2 {
    images: Edge<f32>,
    contrast_factor: Edge<f32>,
    op_name: Option<String>,
    id_: usize,
}

impl AdjustContrastv2 {
    pub fn output(self) -> Edge<f32> {
        let rc = Rc::new(self);
        {
            Edge::<f32>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<f32> {
        let rc = Rc::new(self);
        {
            Edge::<f32>::new(rc.clone(), 0)
        }
    }

    pub fn build(images: Edge<f32>, contrast_factor: Edge<f32>) -> Self {
        Self {
            images,
            contrast_factor,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(images: Edge<f32>, contrast_factor: Edge<f32>) -> Edge<f32> {
        Self {
            images,
            contrast_factor,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

pub trait con_or_DT_UINT8_or_DT_UINT16 {
}

impl con_or_DT_UINT8_or_DT_UINT16 for u16 {
}

impl con_or_DT_UINT8_or_DT_UINT16 for u8 {
}

impl<dtype> GraphOperation for DecodePng<dtype>
where dtype: TensorType,
      dtype: con_or_DT_UINT8_or_DT_UINT16,
      dtype: 'static,
      dtype: Clone,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("DecodePng_{}")?
        };
        let mut new_op = graph.new_operation("DecodePng", &op_name)?;
        {
            new_op.add_edge(&self.contents)?
        }
        {
            match self.channels {
                None => new_op.set_attr_value_proto("channels", &vec![24_u8, 0_u8,])?,
                Some(ref value) => (|attr: &i64| {new_op.set_attr_int("channels", *attr)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct DecodePng<dtype>
where dtype: TensorType,
      dtype: con_or_DT_UINT8_or_DT_UINT16,
      dtype: 'static,
      dtype: Clone,
{
    contents: Edge<String>,
    channels: Option<i64>,
    phantom_dtype: PhantomData<dtype>,
    op_name: Option<String>,
    id_: usize,
}

impl<dtype> DecodePng<dtype>
where dtype: TensorType,
      dtype: con_or_DT_UINT8_or_DT_UINT16,
      dtype: 'static,
      dtype: Clone,
{
    pub fn image(self) -> Edge<dtype> {
        let rc = Rc::new(self);
        {
            Edge::<dtype>::new(rc.clone(), 0)
        }
    }

    pub fn channels(&mut self, channels: i64) -> Self {
        self.channels = Some(channels);
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<dtype> {
        let rc = Rc::new(self);
        {
            Edge::<dtype>::new(rc.clone(), 0)
        }
    }

    pub fn build(contents: Edge<String>) -> Self {
        Self {
            contents,
            channels: None,
            phantom_dtype: PhantomData,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(contents: Edge<String>) -> Edge<dtype> {
        Self {
            contents,
            channels: None,
            phantom_dtype: PhantomData,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<T> GraphOperation for ApplyProximalAdagrad<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("ApplyProximalAdagrad_{}")?
        };
        let mut new_op = graph.new_operation("ApplyProximalAdagrad", &op_name)?;
        {
            new_op.add_edge(&self.var)?
        }
        {
            new_op.add_edge(&self.accum)?
        }
        {
            new_op.add_edge(&self.lr)?
        }
        {
            new_op.add_edge(&self.l1)?
        }
        {
            new_op.add_edge(&self.l2)?
        }
        {
            new_op.add_edge(&self.grad)?
        }
        {
            match self.use_locking {
                None => new_op.set_attr_value_proto("use_locking", &vec![40_u8, 0_u8,])?,
                Some(ref value) => (|attr: &bool| {new_op.set_attr_bool("use_locking", *attr)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct ApplyProximalAdagrad<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    var: Edge<T>,
    accum: Edge<T>,
    lr: Edge<T>,
    l1: Edge<T>,
    l2: Edge<T>,
    grad: Edge<T>,
    use_locking: Option<bool>,
    op_name: Option<String>,
    id_: usize,
}

impl<T> ApplyProximalAdagrad<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
{
    pub fn out(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn use_locking(&mut self, use_locking: bool) -> Self {
        self.use_locking = Some(use_locking);
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(var: Edge<T>, accum: Edge<T>, lr: Edge<T>, l1: Edge<T>, l2: Edge<T>, grad: Edge<T>) -> Self {
        Self {
            phantom_T: PhantomData,
            var,
            accum,
            lr,
            l1,
            l2,
            grad,
            use_locking: None,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(var: Edge<T>, accum: Edge<T>, lr: Edge<T>, l1: Edge<T>, l2: Edge<T>, grad: Edge<T>) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            var,
            accum,
            lr,
            l1,
            l2,
            grad,
            use_locking: None,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<T> GraphOperation for BitwiseOr<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_UINT16_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("BitwiseOr_{}")?
        };
        let mut new_op = graph.new_operation("BitwiseOr", &op_name)?;
        {
            new_op.add_edge(&self.x)?
        }
        {
            new_op.add_edge(&self.y)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct BitwiseOr<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_UINT16_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    x: Edge<T>,
    y: Edge<T>,
    op_name: Option<String>,
    id_: usize,
}

impl<T> BitwiseOr<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_UINT16_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
{
    pub fn z(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(x: Edge<T>, y: Edge<T>) -> Self {
        Self {
            phantom_T: PhantomData,
            x,
            y,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(x: Edge<T>, y: Edge<T>) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            x,
            y,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<T> GraphOperation for MatrixSolveLs<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_COMPLEX64_or_DT_COMPLEX128,
      T: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("MatrixSolveLs_{}")?
        };
        let mut new_op = graph.new_operation("MatrixSolveLs", &op_name)?;
        {
            new_op.add_edge(&self.matrix)?
        }
        {
            new_op.add_edge(&self.rhs)?
        }
        {
            new_op.add_edge(&self.l2_regularizer)?
        }
        {
            match self.fast {
                None => new_op.set_attr_value_proto("fast", &vec![40_u8, 1_u8,])?,
                Some(ref value) => (|attr: &bool| {new_op.set_attr_bool("fast", *attr)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct MatrixSolveLs<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_COMPLEX64_or_DT_COMPLEX128,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    matrix: Edge<T>,
    rhs: Edge<T>,
    l2_regularizer: Edge<f64>,
    fast: Option<bool>,
    op_name: Option<String>,
    id_: usize,
}

impl<T> MatrixSolveLs<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_COMPLEX64_or_DT_COMPLEX128,
      T: 'static,
{
    pub fn output(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn fast(&mut self, fast: bool) -> Self {
        self.fast = Some(fast);
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(matrix: Edge<T>, rhs: Edge<T>, l2_regularizer: Edge<f64>) -> Self {
        Self {
            phantom_T: PhantomData,
            matrix,
            rhs,
            l2_regularizer,
            fast: None,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(matrix: Edge<T>, rhs: Edge<T>, l2_regularizer: Edge<f64>) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            matrix,
            rhs,
            l2_regularizer,
            fast: None,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

pub trait con_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64 {
}

impl con_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64 for i16 {
}

impl con_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64 for i32 {
}

impl con_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64 for i64 {
}

impl con_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64 for i8 {
}

impl con_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64 for u8 {
}

impl<T> GraphOperation for SampleDistortedBoundingBox<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64,
      T: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("SampleDistortedBoundingBox_{}")?
        };
        let mut new_op = graph.new_operation("SampleDistortedBoundingBox", &op_name)?;
        {
            new_op.add_edge(&self.image_size)?
        }
        {
            new_op.add_edge(&self.bounding_boxes)?
        }
        {
            match self.seed {
                None => new_op.set_attr_value_proto("seed", &vec![24_u8, 0_u8,])?,
                Some(ref value) => (|attr: &i64| {new_op.set_attr_int("seed", *attr)})(&value)?,
            };
        }
        {
            match self.seed2 {
                None => new_op.set_attr_value_proto("seed2", &vec![24_u8, 0_u8,])?,
                Some(ref value) => (|attr: &i64| {new_op.set_attr_int("seed2", *attr)})(&value)?,
            };
        }
        {
            match self.min_object_covered {
                None => new_op.set_attr_value_proto("min_object_covered", &vec![37_u8, 205_u8, 204_u8, 204_u8, 61_u8,])?,
                Some(ref value) => (|attr: &f32| {new_op.set_attr_float("min_object_covered", *attr)})(&value)?,
            };
        }
        {
            match self.aspect_ratio_range {
                None => new_op.set_attr_value_proto("aspect_ratio_range", &vec![10_u8, 0_u8, 34_u8, 8_u8, 0_u8, 0_u8, 64_u8, 63_u8,])?,
                Some(ref value) => (|attrs| {new_op.set_attr_float_list("aspect_ratio_range", attrs)})(&value)?,
            };
        }
        {
            match self.area_range {
                None => new_op.set_attr_value_proto("area_range", &vec![10_u8, 0_u8, 34_u8, 8_u8, 205_u8, 204_u8, 76_u8, 61_u8,])?,
                Some(ref value) => (|attrs| {new_op.set_attr_float_list("area_range", attrs)})(&value)?,
            };
        }
        {
            match self.max_attempts {
                None => new_op.set_attr_value_proto("max_attempts", &vec![24_u8, 100_u8,])?,
                Some(ref value) => (|attr: &i64| {new_op.set_attr_int("max_attempts", *attr)})(&value)?,
            };
        }
        {
            match self.use_image_if_no_bounding_boxes {
                None => new_op.set_attr_value_proto("use_image_if_no_bounding_boxes", &vec![40_u8, 0_u8,])?,
                Some(ref value) => (|attr: &bool| {new_op.set_attr_bool("use_image_if_no_bounding_boxes", *attr)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct SampleDistortedBoundingBox<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    image_size: Edge<T>,
    bounding_boxes: Edge<f32>,
    seed: Option<i64>,
    seed2: Option<i64>,
    min_object_covered: Option<f32>,
    aspect_ratio_range: Option<Vec<f32>>,
    area_range: Option<Vec<f32>>,
    max_attempts: Option<i64>,
    use_image_if_no_bounding_boxes: Option<bool>,
    op_name: Option<String>,
    id_: usize,
}

impl<T> SampleDistortedBoundingBox<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64,
      T: 'static,
{
    pub fn begin(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn size(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 1)
        }
    }

    pub fn bboxes(self) -> Edge<f32> {
        let rc = Rc::new(self);
        {
            Edge::<f32>::new(rc.clone(), 2)
        }
    }

    pub fn seed(&mut self, seed: i64) -> Self {
        self.seed = Some(seed);
        self.clone()
    }

    pub fn seed2(&mut self, seed2: i64) -> Self {
        self.seed2 = Some(seed2);
        self.clone()
    }

    pub fn min_object_covered(&mut self, min_object_covered: f32) -> Self {
        self.min_object_covered = Some(min_object_covered);
        self.clone()
    }

    pub fn aspect_ratio_range(&mut self, aspect_ratio_range: &[f32]) -> Self {
        self.aspect_ratio_range = Some(aspect_ratio_range.to_vec());
        self.clone()
    }

    pub fn area_range(&mut self, area_range: &[f32]) -> Self {
        self.area_range = Some(area_range.to_vec());
        self.clone()
    }

    pub fn max_attempts(&mut self, max_attempts: i64) -> Self {
        self.max_attempts = Some(max_attempts);
        self.clone()
    }

    pub fn use_image_if_no_bounding_boxes(&mut self, use_image_if_no_bounding_boxes: bool) -> Self {
        self.use_image_if_no_bounding_boxes = Some(use_image_if_no_bounding_boxes);
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> (Edge<T>, Edge<T>, Edge<f32>) {
        let rc = Rc::new(self);
        (
        {
            Edge::<T>::new(rc.clone(), 0)
        },
        {
            Edge::<T>::new(rc.clone(), 1)
        },
        {
            Edge::<f32>::new(rc.clone(), 2)
        },
        )
    }

    pub fn build(image_size: Edge<T>, bounding_boxes: Edge<f32>) -> Self {
        Self {
            phantom_T: PhantomData,
            image_size,
            bounding_boxes,
            seed: None,
            seed2: None,
            min_object_covered: None,
            aspect_ratio_range: None,
            area_range: None,
            max_attempts: None,
            use_image_if_no_bounding_boxes: None,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(image_size: Edge<T>, bounding_boxes: Edge<f32>) -> (Edge<T>, Edge<T>, Edge<f32>) {
        Self {
            phantom_T: PhantomData,
            image_size,
            bounding_boxes,
            seed: None,
            seed2: None,
            min_object_covered: None,
            aspect_ratio_range: None,
            area_range: None,
            max_attempts: None,
            use_image_if_no_bounding_boxes: None,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<T> GraphOperation for Greater<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("Greater_{}")?
        };
        let mut new_op = graph.new_operation("Greater", &op_name)?;
        {
            new_op.add_edge(&self.x)?
        }
        {
            new_op.add_edge(&self.y)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct Greater<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    x: Edge<T>,
    y: Edge<T>,
    op_name: Option<String>,
    id_: usize,
}

impl<T> Greater<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
{
    pub fn z(self) -> Edge<bool> {
        let rc = Rc::new(self);
        {
            Edge::<bool>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<bool> {
        let rc = Rc::new(self);
        {
            Edge::<bool>::new(rc.clone(), 0)
        }
    }

    pub fn build(x: Edge<T>, y: Edge<T>) -> Self {
        Self {
            phantom_T: PhantomData,
            x,
            y,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(x: Edge<T>, y: Edge<T>) -> Edge<bool> {
        Self {
            phantom_T: PhantomData,
            x,
            y,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<T> GraphOperation for SampleDistortedBoundingBoxV2<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64,
      T: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("SampleDistortedBoundingBoxV2_{}")?
        };
        let mut new_op = graph.new_operation("SampleDistortedBoundingBoxV2", &op_name)?;
        {
            new_op.add_edge(&self.image_size)?
        }
        {
            new_op.add_edge(&self.bounding_boxes)?
        }
        {
            new_op.add_edge(&self.min_object_covered)?
        }
        {
            match self.seed {
                None => new_op.set_attr_value_proto("seed", &vec![24_u8, 0_u8,])?,
                Some(ref value) => (|attr: &i64| {new_op.set_attr_int("seed", *attr)})(&value)?,
            };
        }
        {
            match self.seed2 {
                None => new_op.set_attr_value_proto("seed2", &vec![24_u8, 0_u8,])?,
                Some(ref value) => (|attr: &i64| {new_op.set_attr_int("seed2", *attr)})(&value)?,
            };
        }
        {
            match self.aspect_ratio_range {
                None => new_op.set_attr_value_proto("aspect_ratio_range", &vec![10_u8, 0_u8, 34_u8, 8_u8, 0_u8, 0_u8, 64_u8, 63_u8,])?,
                Some(ref value) => (|attrs| {new_op.set_attr_float_list("aspect_ratio_range", attrs)})(&value)?,
            };
        }
        {
            match self.area_range {
                None => new_op.set_attr_value_proto("area_range", &vec![10_u8, 0_u8, 34_u8, 8_u8, 205_u8, 204_u8, 76_u8, 61_u8,])?,
                Some(ref value) => (|attrs| {new_op.set_attr_float_list("area_range", attrs)})(&value)?,
            };
        }
        {
            match self.max_attempts {
                None => new_op.set_attr_value_proto("max_attempts", &vec![24_u8, 100_u8,])?,
                Some(ref value) => (|attr: &i64| {new_op.set_attr_int("max_attempts", *attr)})(&value)?,
            };
        }
        {
            match self.use_image_if_no_bounding_boxes {
                None => new_op.set_attr_value_proto("use_image_if_no_bounding_boxes", &vec![40_u8, 0_u8,])?,
                Some(ref value) => (|attr: &bool| {new_op.set_attr_bool("use_image_if_no_bounding_boxes", *attr)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct SampleDistortedBoundingBoxV2<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    image_size: Edge<T>,
    bounding_boxes: Edge<f32>,
    min_object_covered: Edge<f32>,
    seed: Option<i64>,
    seed2: Option<i64>,
    aspect_ratio_range: Option<Vec<f32>>,
    area_range: Option<Vec<f32>>,
    max_attempts: Option<i64>,
    use_image_if_no_bounding_boxes: Option<bool>,
    op_name: Option<String>,
    id_: usize,
}

impl<T> SampleDistortedBoundingBoxV2<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64,
      T: 'static,
{
    pub fn begin(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn size(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 1)
        }
    }

    pub fn bboxes(self) -> Edge<f32> {
        let rc = Rc::new(self);
        {
            Edge::<f32>::new(rc.clone(), 2)
        }
    }

    pub fn seed(&mut self, seed: i64) -> Self {
        self.seed = Some(seed);
        self.clone()
    }

    pub fn seed2(&mut self, seed2: i64) -> Self {
        self.seed2 = Some(seed2);
        self.clone()
    }

    pub fn aspect_ratio_range(&mut self, aspect_ratio_range: &[f32]) -> Self {
        self.aspect_ratio_range = Some(aspect_ratio_range.to_vec());
        self.clone()
    }

    pub fn area_range(&mut self, area_range: &[f32]) -> Self {
        self.area_range = Some(area_range.to_vec());
        self.clone()
    }

    pub fn max_attempts(&mut self, max_attempts: i64) -> Self {
        self.max_attempts = Some(max_attempts);
        self.clone()
    }

    pub fn use_image_if_no_bounding_boxes(&mut self, use_image_if_no_bounding_boxes: bool) -> Self {
        self.use_image_if_no_bounding_boxes = Some(use_image_if_no_bounding_boxes);
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> (Edge<T>, Edge<T>, Edge<f32>) {
        let rc = Rc::new(self);
        (
        {
            Edge::<T>::new(rc.clone(), 0)
        },
        {
            Edge::<T>::new(rc.clone(), 1)
        },
        {
            Edge::<f32>::new(rc.clone(), 2)
        },
        )
    }

    pub fn build(image_size: Edge<T>, bounding_boxes: Edge<f32>, min_object_covered: Edge<f32>) -> Self {
        Self {
            phantom_T: PhantomData,
            image_size,
            bounding_boxes,
            min_object_covered,
            seed: None,
            seed2: None,
            aspect_ratio_range: None,
            area_range: None,
            max_attempts: None,
            use_image_if_no_bounding_boxes: None,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(image_size: Edge<T>, bounding_boxes: Edge<f32>, min_object_covered: Edge<f32>) -> (Edge<T>, Edge<T>, Edge<f32>) {
        Self {
            phantom_T: PhantomData,
            image_size,
            bounding_boxes,
            min_object_covered,
            seed: None,
            seed2: None,
            aspect_ratio_range: None,
            area_range: None,
            max_attempts: None,
            use_image_if_no_bounding_boxes: None,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<T> GraphOperation for CropAndResize<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_UINT16_or_DT_HALF,
      T: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("CropAndResize_{}")?
        };
        let mut new_op = graph.new_operation("CropAndResize", &op_name)?;
        {
            new_op.add_edge(&self.image)?
        }
        {
            new_op.add_edge(&self.boxes)?
        }
        {
            new_op.add_edge(&self.box_ind)?
        }
        {
            new_op.add_edge(&self.crop_size)?
        }
        {
            match self.method {
                None => new_op.set_attr_value_proto("method", &vec![18_u8, 8_u8, 98_u8, 105_u8, 108_u8, 105_u8, 110_u8, 101_u8, 97_u8, 114_u8,])?,
                Some(ref value) => (|attr| {new_op.set_attr_string("method", attr)})(&value)?,
            };
        }
        {
            match self.extrapolation_value {
                None => new_op.set_attr_value_proto("extrapolation_value", &vec![37_u8, 0_u8, 0_u8, 0_u8, 0_u8,])?,
                Some(ref value) => (|attr: &f32| {new_op.set_attr_float("extrapolation_value", *attr)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct CropAndResize<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_UINT16_or_DT_HALF,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    image: Edge<T>,
    boxes: Edge<f32>,
    box_ind: Edge<i32>,
    crop_size: Edge<i32>,
    method: Option<String>,
    extrapolation_value: Option<f32>,
    op_name: Option<String>,
    id_: usize,
}

impl<T> CropAndResize<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_UINT16_or_DT_HALF,
      T: 'static,
{
    pub fn crops(self) -> Edge<f32> {
        let rc = Rc::new(self);
        {
            Edge::<f32>::new(rc.clone(), 0)
        }
    }

    pub fn method(&mut self, method: &str) -> Self {
        self.method = Some(method.to_string());
        self.clone()
    }

    pub fn extrapolation_value(&mut self, extrapolation_value: f32) -> Self {
        self.extrapolation_value = Some(extrapolation_value);
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<f32> {
        let rc = Rc::new(self);
        {
            Edge::<f32>::new(rc.clone(), 0)
        }
    }

    pub fn build(image: Edge<T>, boxes: Edge<f32>, box_ind: Edge<i32>, crop_size: Edge<i32>) -> Self {
        Self {
            phantom_T: PhantomData,
            image,
            boxes,
            box_ind,
            crop_size,
            method: None,
            extrapolation_value: None,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(image: Edge<T>, boxes: Edge<f32>, box_ind: Edge<i32>, crop_size: Edge<i32>) -> Edge<f32> {
        Self {
            phantom_T: PhantomData,
            image,
            boxes,
            box_ind,
            crop_size,
            method: None,
            extrapolation_value: None,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<Tcomplex> GraphOperation for FFT3D<Tcomplex>
where Tcomplex: TensorType,
      Tcomplex: Clone,
      Tcomplex: con_or_DT_COMPLEX64_or_DT_COMPLEX128,
      Tcomplex: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("FFT3D_{}")?
        };
        let mut new_op = graph.new_operation("FFT3D", &op_name)?;
        {
            new_op.add_edge(&self.input)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct FFT3D<Tcomplex>
where Tcomplex: TensorType,
      Tcomplex: Clone,
      Tcomplex: con_or_DT_COMPLEX64_or_DT_COMPLEX128,
      Tcomplex: 'static,
{
    phantom_Tcomplex: PhantomData<Tcomplex>,
    input: Edge<Tcomplex>,
    op_name: Option<String>,
    id_: usize,
}

impl<Tcomplex> FFT3D<Tcomplex>
where Tcomplex: TensorType,
      Tcomplex: Clone,
      Tcomplex: con_or_DT_COMPLEX64_or_DT_COMPLEX128,
      Tcomplex: 'static,
{
    pub fn output(self) -> Edge<Tcomplex> {
        let rc = Rc::new(self);
        {
            Edge::<Tcomplex>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<Tcomplex> {
        let rc = Rc::new(self);
        {
            Edge::<Tcomplex>::new(rc.clone(), 0)
        }
    }

    pub fn build(input: Edge<Tcomplex>) -> Self {
        Self {
            phantom_Tcomplex: PhantomData,
            input,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(input: Edge<Tcomplex>) -> Edge<Tcomplex> {
        Self {
            phantom_Tcomplex: PhantomData,
            input,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<T> GraphOperation for CropAndResizeGradBoxes<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_UINT16_or_DT_HALF,
      T: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("CropAndResizeGradBoxes_{}")?
        };
        let mut new_op = graph.new_operation("CropAndResizeGradBoxes", &op_name)?;
        {
            new_op.add_edge(&self.grads)?
        }
        {
            new_op.add_edge(&self.image)?
        }
        {
            new_op.add_edge(&self.boxes)?
        }
        {
            new_op.add_edge(&self.box_ind)?
        }
        {
            match self.method {
                None => new_op.set_attr_value_proto("method", &vec![18_u8, 8_u8, 98_u8, 105_u8, 108_u8, 105_u8, 110_u8, 101_u8, 97_u8, 114_u8,])?,
                Some(ref value) => (|attr| {new_op.set_attr_string("method", attr)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct CropAndResizeGradBoxes<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_UINT16_or_DT_HALF,
      T: 'static,
{
    grads: Edge<f32>,
    phantom_T: PhantomData<T>,
    image: Edge<T>,
    boxes: Edge<f32>,
    box_ind: Edge<i32>,
    method: Option<String>,
    op_name: Option<String>,
    id_: usize,
}

impl<T> CropAndResizeGradBoxes<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_UINT16_or_DT_HALF,
      T: 'static,
{
    pub fn output(self) -> Edge<f32> {
        let rc = Rc::new(self);
        {
            Edge::<f32>::new(rc.clone(), 0)
        }
    }

    pub fn method(&mut self, method: &str) -> Self {
        self.method = Some(method.to_string());
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<f32> {
        let rc = Rc::new(self);
        {
            Edge::<f32>::new(rc.clone(), 0)
        }
    }

    pub fn build(grads: Edge<f32>, image: Edge<T>, boxes: Edge<f32>, box_ind: Edge<i32>) -> Self {
        Self {
            grads,
            phantom_T: PhantomData,
            image,
            boxes,
            box_ind,
            method: None,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(grads: Edge<f32>, image: Edge<T>, boxes: Edge<f32>, box_ind: Edge<i32>) -> Edge<f32> {
        Self {
            grads,
            phantom_T: PhantomData,
            image,
            boxes,
            box_ind,
            method: None,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<T> GraphOperation for NonMaxSuppressionV3<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_HALF,
      T: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("NonMaxSuppressionV3_{}")?
        };
        let mut new_op = graph.new_operation("NonMaxSuppressionV3", &op_name)?;
        {
            new_op.add_edge(&self.boxes)?
        }
        {
            new_op.add_edge(&self.scores)?
        }
        {
            new_op.add_edge(&self.max_output_size)?
        }
        {
            new_op.add_edge(&self.iou_threshold)?
        }
        {
            new_op.add_edge(&self.score_threshold)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct NonMaxSuppressionV3<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_HALF,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    boxes: Edge<T>,
    scores: Edge<T>,
    max_output_size: Edge<i32>,
    iou_threshold: Edge<f32>,
    score_threshold: Edge<f32>,
    op_name: Option<String>,
    id_: usize,
}

impl<T> NonMaxSuppressionV3<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_HALF,
      T: 'static,
{
    pub fn selected_indices(self) -> Edge<i32> {
        let rc = Rc::new(self);
        {
            Edge::<i32>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<i32> {
        let rc = Rc::new(self);
        {
            Edge::<i32>::new(rc.clone(), 0)
        }
    }

    pub fn build(boxes: Edge<T>, scores: Edge<T>, max_output_size: Edge<i32>, iou_threshold: Edge<f32>, score_threshold: Edge<f32>) -> Self {
        Self {
            phantom_T: PhantomData,
            boxes,
            scores,
            max_output_size,
            iou_threshold,
            score_threshold,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(boxes: Edge<T>, scores: Edge<T>, max_output_size: Edge<i32>, iou_threshold: Edge<f32>, score_threshold: Edge<f32>) -> Edge<i32> {
        Self {
            phantom_T: PhantomData,
            boxes,
            scores,
            max_output_size,
            iou_threshold,
            score_threshold,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl GraphOperation for NoOp {
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("NoOp_{}")?
        };
        let mut new_op = graph.new_operation("NoOp", &op_name)?;
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct NoOp {
    op_name: Option<String>,
    id_: usize,
}

impl NoOp {
    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> () {
        let rc = Rc::new(self);
        (
        )
    }

    pub fn build() -> Self {
        Self {
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new() -> () {
        Self {
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl GraphOperation for MergeV2Checkpoints {
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("MergeV2Checkpoints_{}")?
        };
        let mut new_op = graph.new_operation("MergeV2Checkpoints", &op_name)?;
        {
            new_op.add_edge(&self.checkpoint_prefixes)?
        }
        {
            new_op.add_edge(&self.destination_prefix)?
        }
        {
            match self.delete_old_dirs {
                None => new_op.set_attr_value_proto("delete_old_dirs", &vec![40_u8, 1_u8,])?,
                Some(ref value) => (|attr: &bool| {new_op.set_attr_bool("delete_old_dirs", *attr)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct MergeV2Checkpoints {
    checkpoint_prefixes: Edge<String>,
    destination_prefix: Edge<String>,
    delete_old_dirs: Option<bool>,
    op_name: Option<String>,
    id_: usize,
}

impl MergeV2Checkpoints {
    pub fn delete_old_dirs(&mut self, delete_old_dirs: bool) -> Self {
        self.delete_old_dirs = Some(delete_old_dirs);
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> () {
        let rc = Rc::new(self);
        (
        )
    }

    pub fn build(checkpoint_prefixes: Edge<String>, destination_prefix: Edge<String>) -> Self {
        Self {
            checkpoint_prefixes,
            destination_prefix,
            delete_old_dirs: None,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(checkpoint_prefixes: Edge<String>, destination_prefix: Edge<String>) -> () {
        Self {
            checkpoint_prefixes,
            destination_prefix,
            delete_old_dirs: None,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl GraphOperation for ShardedFilespec {
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("ShardedFilespec_{}")?
        };
        let mut new_op = graph.new_operation("ShardedFilespec", &op_name)?;
        {
            new_op.add_edge(&self.basename)?
        }
        {
            new_op.add_edge(&self.num_shards)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct ShardedFilespec {
    basename: Edge<String>,
    num_shards: Edge<i32>,
    op_name: Option<String>,
    id_: usize,
}

impl ShardedFilespec {
    pub fn filename(self) -> Edge<String> {
        let rc = Rc::new(self);
        {
            Edge::<String>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<String> {
        let rc = Rc::new(self);
        {
            Edge::<String>::new(rc.clone(), 0)
        }
    }

    pub fn build(basename: Edge<String>, num_shards: Edge<i32>) -> Self {
        Self {
            basename,
            num_shards,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(basename: Edge<String>, num_shards: Edge<i32>) -> Edge<String> {
        Self {
            basename,
            num_shards,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl GraphOperation for WholeFileReader {
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("WholeFileReader_{}")?
        };
        let mut new_op = graph.new_operation("WholeFileReader", &op_name)?;
        {
            match self.container {
                None => new_op.set_attr_value_proto("container", &vec![18_u8, 0_u8,])?,
                Some(ref value) => (|attr| {new_op.set_attr_string("container", attr)})(&value)?,
            };
        }
        {
            match self.shared_name {
                None => new_op.set_attr_value_proto("shared_name", &vec![18_u8, 0_u8,])?,
                Some(ref value) => (|attr| {new_op.set_attr_string("shared_name", attr)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct WholeFileReader {
    container: Option<String>,
    shared_name: Option<String>,
    op_name: Option<String>,
    id_: usize,
}

impl WholeFileReader {
    pub fn reader_handle(self) -> Edge<String> {
        let rc = Rc::new(self);
        {
            Edge::<String>::new(rc.clone(), 0)
        }
    }

    pub fn container(&mut self, container: &str) -> Self {
        self.container = Some(container.to_string());
        self.clone()
    }

    pub fn shared_name(&mut self, shared_name: &str) -> Self {
        self.shared_name = Some(shared_name.to_string());
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<String> {
        let rc = Rc::new(self);
        {
            Edge::<String>::new(rc.clone(), 0)
        }
    }

    pub fn build() -> Self {
        Self {
            container: None,
            shared_name: None,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new() -> Edge<String> {
        Self {
            container: None,
            shared_name: None,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl GraphOperation for LoadAndRemapMatrix {
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("LoadAndRemapMatrix_{}")?
        };
        let mut new_op = graph.new_operation("LoadAndRemapMatrix", &op_name)?;
        {
            new_op.add_edge(&self.ckpt_path)?
        }
        {
            new_op.add_edge(&self.old_tensor_name)?
        }
        {
            new_op.add_edge(&self.row_remapping)?
        }
        {
            new_op.add_edge(&self.col_remapping)?
        }
        {
            new_op.add_edge(&self.initializing_values)?
        }
        {
            (|attr: &i64| {new_op.set_attr_int("num_rows", *attr)})(&self.num_rows)?
        }
        {
            (|attr: &i64| {new_op.set_attr_int("num_cols", *attr)})(&self.num_cols)?
        }
        {
            match self.max_rows_in_memory {
                None => new_op.set_attr_value_proto("max_rows_in_memory", &vec![24_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 1_u8,])?,
                Some(ref value) => (|attr: &i64| {new_op.set_attr_int("max_rows_in_memory", *attr)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct LoadAndRemapMatrix {
    ckpt_path: Edge<String>,
    old_tensor_name: Edge<String>,
    row_remapping: Edge<i64>,
    col_remapping: Edge<i64>,
    initializing_values: Edge<f32>,
    num_rows: i64,
    num_cols: i64,
    max_rows_in_memory: Option<i64>,
    op_name: Option<String>,
    id_: usize,
}

impl LoadAndRemapMatrix {
    pub fn output_matrix(self) -> Edge<f32> {
        let rc = Rc::new(self);
        {
            Edge::<f32>::new(rc.clone(), 0)
        }
    }

    pub fn max_rows_in_memory(&mut self, max_rows_in_memory: i64) -> Self {
        self.max_rows_in_memory = Some(max_rows_in_memory);
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<f32> {
        let rc = Rc::new(self);
        {
            Edge::<f32>::new(rc.clone(), 0)
        }
    }

    pub fn build(ckpt_path: Edge<String>, old_tensor_name: Edge<String>, row_remapping: Edge<i64>, col_remapping: Edge<i64>, initializing_values: Edge<f32>, num_rows: i64, num_cols: i64) -> Self {
        Self {
            ckpt_path,
            old_tensor_name,
            row_remapping,
            col_remapping,
            initializing_values,
            num_rows: num_rows,
            num_cols: num_cols,
            max_rows_in_memory: None,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(ckpt_path: Edge<String>, old_tensor_name: Edge<String>, row_remapping: Edge<i64>, col_remapping: Edge<i64>, initializing_values: Edge<f32>, num_rows: i64, num_cols: i64) -> Edge<f32> {
        Self {
            ckpt_path,
            old_tensor_name,
            row_remapping,
            col_remapping,
            initializing_values,
            num_rows: num_rows,
            num_cols: num_cols,
            max_rows_in_memory: None,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl GraphOperation for FixedLengthRecordReader {
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("FixedLengthRecordReader_{}")?
        };
        let mut new_op = graph.new_operation("FixedLengthRecordReader", &op_name)?;
        {
            match self.header_bytes {
                None => new_op.set_attr_value_proto("header_bytes", &vec![24_u8, 0_u8,])?,
                Some(ref value) => (|attr: &i64| {new_op.set_attr_int("header_bytes", *attr)})(&value)?,
            };
        }
        {
            (|attr: &i64| {new_op.set_attr_int("record_bytes", *attr)})(&self.record_bytes)?
        }
        {
            match self.footer_bytes {
                None => new_op.set_attr_value_proto("footer_bytes", &vec![24_u8, 0_u8,])?,
                Some(ref value) => (|attr: &i64| {new_op.set_attr_int("footer_bytes", *attr)})(&value)?,
            };
        }
        {
            match self.hop_bytes {
                None => new_op.set_attr_value_proto("hop_bytes", &vec![24_u8, 0_u8,])?,
                Some(ref value) => (|attr: &i64| {new_op.set_attr_int("hop_bytes", *attr)})(&value)?,
            };
        }
        {
            match self.container {
                None => new_op.set_attr_value_proto("container", &vec![18_u8, 0_u8,])?,
                Some(ref value) => (|attr| {new_op.set_attr_string("container", attr)})(&value)?,
            };
        }
        {
            match self.shared_name {
                None => new_op.set_attr_value_proto("shared_name", &vec![18_u8, 0_u8,])?,
                Some(ref value) => (|attr| {new_op.set_attr_string("shared_name", attr)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct FixedLengthRecordReader {
    header_bytes: Option<i64>,
    record_bytes: i64,
    footer_bytes: Option<i64>,
    hop_bytes: Option<i64>,
    container: Option<String>,
    shared_name: Option<String>,
    op_name: Option<String>,
    id_: usize,
}

impl FixedLengthRecordReader {
    pub fn reader_handle(self) -> Edge<String> {
        let rc = Rc::new(self);
        {
            Edge::<String>::new(rc.clone(), 0)
        }
    }

    pub fn header_bytes(&mut self, header_bytes: i64) -> Self {
        self.header_bytes = Some(header_bytes);
        self.clone()
    }

    pub fn footer_bytes(&mut self, footer_bytes: i64) -> Self {
        self.footer_bytes = Some(footer_bytes);
        self.clone()
    }

    pub fn hop_bytes(&mut self, hop_bytes: i64) -> Self {
        self.hop_bytes = Some(hop_bytes);
        self.clone()
    }

    pub fn container(&mut self, container: &str) -> Self {
        self.container = Some(container.to_string());
        self.clone()
    }

    pub fn shared_name(&mut self, shared_name: &str) -> Self {
        self.shared_name = Some(shared_name.to_string());
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<String> {
        let rc = Rc::new(self);
        {
            Edge::<String>::new(rc.clone(), 0)
        }
    }

    pub fn build(record_bytes: i64) -> Self {
        Self {
            header_bytes: None,
            record_bytes: record_bytes,
            footer_bytes: None,
            hop_bytes: None,
            container: None,
            shared_name: None,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(record_bytes: i64) -> Edge<String> {
        Self {
            header_bytes: None,
            record_bytes: record_bytes,
            footer_bytes: None,
            hop_bytes: None,
            container: None,
            shared_name: None,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<SrcT, DstT> GraphOperation for Cast<SrcT, DstT>
where SrcT: TensorType,
      SrcT: Clone,
      DstT: TensorType,
      SrcT: 'static,
      DstT: 'static,
      DstT: Clone,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("Cast_{}")?
        };
        let mut new_op = graph.new_operation("Cast", &op_name)?;
        {
            new_op.add_edge(&self.x)?
        }
        {
            match self.Truncate {
                None => new_op.set_attr_value_proto("Truncate", &vec![40_u8, 0_u8,])?,
                Some(ref value) => (|attr: &bool| {new_op.set_attr_bool("Truncate", *attr)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct Cast<SrcT, DstT>
where SrcT: TensorType,
      SrcT: Clone,
      DstT: TensorType,
      SrcT: 'static,
      DstT: 'static,
      DstT: Clone,
{
    phantom_SrcT: PhantomData<SrcT>,
    x: Edge<SrcT>,
    phantom_DstT: PhantomData<DstT>,
    Truncate: Option<bool>,
    op_name: Option<String>,
    id_: usize,
}

impl<SrcT, DstT> Cast<SrcT, DstT>
where SrcT: TensorType,
      SrcT: Clone,
      DstT: TensorType,
      SrcT: 'static,
      DstT: 'static,
      DstT: Clone,
{
    pub fn y(self) -> Edge<DstT> {
        let rc = Rc::new(self);
        {
            Edge::<DstT>::new(rc.clone(), 0)
        }
    }

    pub fn Truncate(&mut self, Truncate: bool) -> Self {
        self.Truncate = Some(Truncate);
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<DstT> {
        let rc = Rc::new(self);
        {
            Edge::<DstT>::new(rc.clone(), 0)
        }
    }

    pub fn build(x: Edge<SrcT>) -> Self {
        Self {
            phantom_SrcT: PhantomData,
            x,
            phantom_DstT: PhantomData,
            Truncate: None,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(x: Edge<SrcT>) -> Edge<DstT> {
        Self {
            phantom_SrcT: PhantomData,
            x,
            phantom_DstT: PhantomData,
            Truncate: None,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl GraphOperation for TFRecordReader {
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("TFRecordReader_{}")?
        };
        let mut new_op = graph.new_operation("TFRecordReader", &op_name)?;
        {
            match self.container {
                None => new_op.set_attr_value_proto("container", &vec![18_u8, 0_u8,])?,
                Some(ref value) => (|attr| {new_op.set_attr_string("container", attr)})(&value)?,
            };
        }
        {
            match self.shared_name {
                None => new_op.set_attr_value_proto("shared_name", &vec![18_u8, 0_u8,])?,
                Some(ref value) => (|attr| {new_op.set_attr_string("shared_name", attr)})(&value)?,
            };
        }
        {
            match self.compression_type {
                None => new_op.set_attr_value_proto("compression_type", &vec![18_u8, 0_u8,])?,
                Some(ref value) => (|attr| {new_op.set_attr_string("compression_type", attr)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct TFRecordReader {
    container: Option<String>,
    shared_name: Option<String>,
    compression_type: Option<String>,
    op_name: Option<String>,
    id_: usize,
}

impl TFRecordReader {
    pub fn reader_handle(self) -> Edge<String> {
        let rc = Rc::new(self);
        {
            Edge::<String>::new(rc.clone(), 0)
        }
    }

    pub fn container(&mut self, container: &str) -> Self {
        self.container = Some(container.to_string());
        self.clone()
    }

    pub fn shared_name(&mut self, shared_name: &str) -> Self {
        self.shared_name = Some(shared_name.to_string());
        self.clone()
    }

    pub fn compression_type(&mut self, compression_type: &str) -> Self {
        self.compression_type = Some(compression_type.to_string());
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<String> {
        let rc = Rc::new(self);
        {
            Edge::<String>::new(rc.clone(), 0)
        }
    }

    pub fn build() -> Self {
        Self {
            container: None,
            shared_name: None,
            compression_type: None,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new() -> Edge<String> {
        Self {
            container: None,
            shared_name: None,
            compression_type: None,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<T> GraphOperation for Sinh<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_COMPLEX64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF,
      T: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("Sinh_{}")?
        };
        let mut new_op = graph.new_operation("Sinh", &op_name)?;
        {
            new_op.add_edge(&self.x)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct Sinh<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_COMPLEX64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    x: Edge<T>,
    op_name: Option<String>,
    id_: usize,
}

impl<T> Sinh<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_COMPLEX64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF,
      T: 'static,
{
    pub fn y(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(x: Edge<T>) -> Self {
        Self {
            phantom_T: PhantomData,
            x,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(x: Edge<T>) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            x,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<T, Tidx> GraphOperation for SparseSegmentSum<T, Tidx>
where T: TensorType,
      T: Clone,
      Tidx: TensorType,
      Tidx: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
      Tidx: con_or_DT_INT32_or_DT_INT64,
      Tidx: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("SparseSegmentSum_{}")?
        };
        let mut new_op = graph.new_operation("SparseSegmentSum", &op_name)?;
        {
            new_op.add_edge(&self.data)?
        }
        {
            new_op.add_edge(&self.indices)?
        }
        {
            new_op.add_edge(&self.segment_ids)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct SparseSegmentSum<T, Tidx>
where T: TensorType,
      T: Clone,
      Tidx: TensorType,
      Tidx: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
      Tidx: con_or_DT_INT32_or_DT_INT64,
      Tidx: 'static,
{
    phantom_T: PhantomData<T>,
    data: Edge<T>,
    phantom_Tidx: PhantomData<Tidx>,
    indices: Edge<Tidx>,
    segment_ids: Edge<i32>,
    op_name: Option<String>,
    id_: usize,
}

impl<T, Tidx> SparseSegmentSum<T, Tidx>
where T: TensorType,
      T: Clone,
      Tidx: TensorType,
      Tidx: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
      Tidx: con_or_DT_INT32_or_DT_INT64,
      Tidx: 'static,
{
    pub fn output(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(data: Edge<T>, indices: Edge<Tidx>, segment_ids: Edge<i32>) -> Self {
        Self {
            phantom_T: PhantomData,
            data,
            phantom_Tidx: PhantomData,
            indices,
            segment_ids,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(data: Edge<T>, indices: Edge<Tidx>, segment_ids: Edge<i32>) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            data,
            phantom_Tidx: PhantomData,
            indices,
            segment_ids,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl GraphOperation for LMDBReader {
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("LMDBReader_{}")?
        };
        let mut new_op = graph.new_operation("LMDBReader", &op_name)?;
        {
            match self.container {
                None => new_op.set_attr_value_proto("container", &vec![18_u8, 0_u8,])?,
                Some(ref value) => (|attr| {new_op.set_attr_string("container", attr)})(&value)?,
            };
        }
        {
            match self.shared_name {
                None => new_op.set_attr_value_proto("shared_name", &vec![18_u8, 0_u8,])?,
                Some(ref value) => (|attr| {new_op.set_attr_string("shared_name", attr)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct LMDBReader {
    container: Option<String>,
    shared_name: Option<String>,
    op_name: Option<String>,
    id_: usize,
}

impl LMDBReader {
    pub fn reader_handle(self) -> Edge<String> {
        let rc = Rc::new(self);
        {
            Edge::<String>::new(rc.clone(), 0)
        }
    }

    pub fn container(&mut self, container: &str) -> Self {
        self.container = Some(container.to_string());
        self.clone()
    }

    pub fn shared_name(&mut self, shared_name: &str) -> Self {
        self.shared_name = Some(shared_name.to_string());
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<String> {
        let rc = Rc::new(self);
        {
            Edge::<String>::new(rc.clone(), 0)
        }
    }

    pub fn build() -> Self {
        Self {
            container: None,
            shared_name: None,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new() -> Edge<String> {
        Self {
            container: None,
            shared_name: None,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<S, R, dtype> GraphOperation for RandomPoissonV2<S, R, dtype>
where S: TensorType,
      S: Clone,
      R: TensorType,
      R: Clone,
      dtype: TensorType,
      S: con_or_DT_INT32_or_DT_INT64,
      S: 'static,
      R: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_INT64_or_DT_HALF,
      R: 'static,
      dtype: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_INT64_or_DT_HALF,
      dtype: 'static,
      dtype: Clone,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("RandomPoissonV2_{}")?
        };
        let mut new_op = graph.new_operation("RandomPoissonV2", &op_name)?;
        {
            new_op.add_edge(&self.shape)?
        }
        {
            new_op.add_edge(&self.rate)?
        }
        {
            match self.seed {
                None => new_op.set_attr_value_proto("seed", &vec![24_u8, 0_u8,])?,
                Some(ref value) => (|attr: &i64| {new_op.set_attr_int("seed", *attr)})(&value)?,
            };
        }
        {
            match self.seed2 {
                None => new_op.set_attr_value_proto("seed2", &vec![24_u8, 0_u8,])?,
                Some(ref value) => (|attr: &i64| {new_op.set_attr_int("seed2", *attr)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct RandomPoissonV2<S, R, dtype>
where S: TensorType,
      S: Clone,
      R: TensorType,
      R: Clone,
      dtype: TensorType,
      S: con_or_DT_INT32_or_DT_INT64,
      S: 'static,
      R: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_INT64_or_DT_HALF,
      R: 'static,
      dtype: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_INT64_or_DT_HALF,
      dtype: 'static,
      dtype: Clone,
{
    phantom_S: PhantomData<S>,
    shape: Edge<S>,
    phantom_R: PhantomData<R>,
    rate: Edge<R>,
    seed: Option<i64>,
    seed2: Option<i64>,
    phantom_dtype: PhantomData<dtype>,
    op_name: Option<String>,
    id_: usize,
}

impl<S, R, dtype> RandomPoissonV2<S, R, dtype>
where S: TensorType,
      S: Clone,
      R: TensorType,
      R: Clone,
      dtype: TensorType,
      S: con_or_DT_INT32_or_DT_INT64,
      S: 'static,
      R: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_INT64_or_DT_HALF,
      R: 'static,
      dtype: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_INT64_or_DT_HALF,
      dtype: 'static,
      dtype: Clone,
{
    pub fn output(self) -> Edge<dtype> {
        let rc = Rc::new(self);
        {
            Edge::<dtype>::new(rc.clone(), 0)
        }
    }

    pub fn seed(&mut self, seed: i64) -> Self {
        self.seed = Some(seed);
        self.clone()
    }

    pub fn seed2(&mut self, seed2: i64) -> Self {
        self.seed2 = Some(seed2);
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<dtype> {
        let rc = Rc::new(self);
        {
            Edge::<dtype>::new(rc.clone(), 0)
        }
    }

    pub fn build(shape: Edge<S>, rate: Edge<R>) -> Self {
        Self {
            phantom_S: PhantomData,
            shape,
            phantom_R: PhantomData,
            rate,
            seed: None,
            seed2: None,
            phantom_dtype: PhantomData,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(shape: Edge<S>, rate: Edge<R>) -> Edge<dtype> {
        Self {
            phantom_S: PhantomData,
            shape,
            phantom_R: PhantomData,
            rate,
            seed: None,
            seed2: None,
            phantom_dtype: PhantomData,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl GraphOperation for RetrieveTPUEmbeddingRMSPropParametersGradAccumDebug {
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("RetrieveTPUEmbeddingRMSPropParametersGradAccumDebug_{}")?
        };
        let mut new_op = graph.new_operation("RetrieveTPUEmbeddingRMSPropParametersGradAccumDebug", &op_name)?;
        {
            match self.table_id {
                None => new_op.set_attr_value_proto("table_id", &vec![24_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 1_u8,])?,
                Some(ref value) => (|attr: &i64| {new_op.set_attr_int("table_id", *attr)})(&value)?,
            };
        }
        {
            match self.table_name {
                None => new_op.set_attr_value_proto("table_name", &vec![18_u8, 0_u8,])?,
                Some(ref value) => (|attr| {new_op.set_attr_string("table_name", attr)})(&value)?,
            };
        }
        {
            (|attr: &i64| {new_op.set_attr_int("num_shards", *attr)})(&self.num_shards)?
        }
        {
            (|attr: &i64| {new_op.set_attr_int("shard_id", *attr)})(&self.shard_id)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct RetrieveTPUEmbeddingRMSPropParametersGradAccumDebug {
    table_id: Option<i64>,
    table_name: Option<String>,
    num_shards: i64,
    shard_id: i64,
    op_name: Option<String>,
    id_: usize,
}

impl RetrieveTPUEmbeddingRMSPropParametersGradAccumDebug {
    pub fn parameters(self) -> Edge<f32> {
        let rc = Rc::new(self);
        {
            Edge::<f32>::new(rc.clone(), 0)
        }
    }

    pub fn ms(self) -> Edge<f32> {
        let rc = Rc::new(self);
        {
            Edge::<f32>::new(rc.clone(), 1)
        }
    }

    pub fn mom(self) -> Edge<f32> {
        let rc = Rc::new(self);
        {
            Edge::<f32>::new(rc.clone(), 2)
        }
    }

    pub fn gradient_accumulators(self) -> Edge<f32> {
        let rc = Rc::new(self);
        {
            Edge::<f32>::new(rc.clone(), 3)
        }
    }

    pub fn table_id(&mut self, table_id: i64) -> Self {
        self.table_id = Some(table_id);
        self.clone()
    }

    pub fn table_name(&mut self, table_name: &str) -> Self {
        self.table_name = Some(table_name.to_string());
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> (Edge<f32>, Edge<f32>, Edge<f32>, Edge<f32>) {
        let rc = Rc::new(self);
        (
        {
            Edge::<f32>::new(rc.clone(), 0)
        },
        {
            Edge::<f32>::new(rc.clone(), 1)
        },
        {
            Edge::<f32>::new(rc.clone(), 2)
        },
        {
            Edge::<f32>::new(rc.clone(), 3)
        },
        )
    }

    pub fn build(num_shards: i64, shard_id: i64) -> Self {
        Self {
            table_id: None,
            table_name: None,
            num_shards: num_shards,
            shard_id: shard_id,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(num_shards: i64, shard_id: i64) -> (Edge<f32>, Edge<f32>, Edge<f32>, Edge<f32>) {
        Self {
            table_id: None,
            table_name: None,
            num_shards: num_shards,
            shard_id: shard_id,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl GraphOperation for IdentityReader {
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("IdentityReader_{}")?
        };
        let mut new_op = graph.new_operation("IdentityReader", &op_name)?;
        {
            match self.container {
                None => new_op.set_attr_value_proto("container", &vec![18_u8, 0_u8,])?,
                Some(ref value) => (|attr| {new_op.set_attr_string("container", attr)})(&value)?,
            };
        }
        {
            match self.shared_name {
                None => new_op.set_attr_value_proto("shared_name", &vec![18_u8, 0_u8,])?,
                Some(ref value) => (|attr| {new_op.set_attr_string("shared_name", attr)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct IdentityReader {
    container: Option<String>,
    shared_name: Option<String>,
    op_name: Option<String>,
    id_: usize,
}

impl IdentityReader {
    pub fn reader_handle(self) -> Edge<String> {
        let rc = Rc::new(self);
        {
            Edge::<String>::new(rc.clone(), 0)
        }
    }

    pub fn container(&mut self, container: &str) -> Self {
        self.container = Some(container.to_string());
        self.clone()
    }

    pub fn shared_name(&mut self, shared_name: &str) -> Self {
        self.shared_name = Some(shared_name.to_string());
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<String> {
        let rc = Rc::new(self);
        {
            Edge::<String>::new(rc.clone(), 0)
        }
    }

    pub fn build() -> Self {
        Self {
            container: None,
            shared_name: None,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new() -> Edge<String> {
        Self {
            container: None,
            shared_name: None,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<T> GraphOperation for QuantizeAndDequantizeV3<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
      T: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("QuantizeAndDequantizeV3_{}")?
        };
        let mut new_op = graph.new_operation("QuantizeAndDequantizeV3", &op_name)?;
        {
            new_op.add_edge(&self.input)?
        }
        {
            new_op.add_edge(&self.input_min)?
        }
        {
            new_op.add_edge(&self.input_max)?
        }
        {
            new_op.add_edge(&self.num_bits)?
        }
        {
            match self.signed_input {
                None => new_op.set_attr_value_proto("signed_input", &vec![40_u8, 1_u8,])?,
                Some(ref value) => (|attr: &bool| {new_op.set_attr_bool("signed_input", *attr)})(&value)?,
            };
        }
        {
            match self.range_given {
                None => new_op.set_attr_value_proto("range_given", &vec![40_u8, 1_u8,])?,
                Some(ref value) => (|attr: &bool| {new_op.set_attr_bool("range_given", *attr)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct QuantizeAndDequantizeV3<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    input: Edge<T>,
    input_min: Edge<T>,
    input_max: Edge<T>,
    num_bits: Edge<i32>,
    signed_input: Option<bool>,
    range_given: Option<bool>,
    op_name: Option<String>,
    id_: usize,
}

impl<T> QuantizeAndDequantizeV3<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
      T: 'static,
{
    pub fn output(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn signed_input(&mut self, signed_input: bool) -> Self {
        self.signed_input = Some(signed_input);
        self.clone()
    }

    pub fn range_given(&mut self, range_given: bool) -> Self {
        self.range_given = Some(range_given);
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(input: Edge<T>, input_min: Edge<T>, input_max: Edge<T>, num_bits: Edge<i32>) -> Self {
        Self {
            phantom_T: PhantomData,
            input,
            input_min,
            input_max,
            num_bits,
            signed_input: None,
            range_given: None,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(input: Edge<T>, input_min: Edge<T>, input_max: Edge<T>, num_bits: Edge<i32>) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            input,
            input_min,
            input_max,
            num_bits,
            signed_input: None,
            range_given: None,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl GraphOperation for ReaderRead {
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("ReaderRead_{}")?
        };
        let mut new_op = graph.new_operation("ReaderRead", &op_name)?;
        {
            new_op.add_edge(&self.reader_handle)?
        }
        {
            new_op.add_edge(&self.queue_handle)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct ReaderRead {
    reader_handle: Edge<String>,
    queue_handle: Edge<String>,
    op_name: Option<String>,
    id_: usize,
}

impl ReaderRead {
    pub fn key(self) -> Edge<String> {
        let rc = Rc::new(self);
        {
            Edge::<String>::new(rc.clone(), 0)
        }
    }

    pub fn value(self) -> Edge<String> {
        let rc = Rc::new(self);
        {
            Edge::<String>::new(rc.clone(), 1)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> (Edge<String>, Edge<String>) {
        let rc = Rc::new(self);
        (
        {
            Edge::<String>::new(rc.clone(), 0)
        },
        {
            Edge::<String>::new(rc.clone(), 1)
        },
        )
    }

    pub fn build(reader_handle: Edge<String>, queue_handle: Edge<String>) -> Self {
        Self {
            reader_handle,
            queue_handle,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(reader_handle: Edge<String>, queue_handle: Edge<String>) -> (Edge<String>, Edge<String>) {
        Self {
            reader_handle,
            queue_handle,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl GraphOperation for ReaderNumRecordsProduced {
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("ReaderNumRecordsProduced_{}")?
        };
        let mut new_op = graph.new_operation("ReaderNumRecordsProduced", &op_name)?;
        {
            new_op.add_edge(&self.reader_handle)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct ReaderNumRecordsProduced {
    reader_handle: Edge<String>,
    op_name: Option<String>,
    id_: usize,
}

impl ReaderNumRecordsProduced {
    pub fn records_produced(self) -> Edge<i64> {
        let rc = Rc::new(self);
        {
            Edge::<i64>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<i64> {
        let rc = Rc::new(self);
        {
            Edge::<i64>::new(rc.clone(), 0)
        }
    }

    pub fn build(reader_handle: Edge<String>) -> Self {
        Self {
            reader_handle,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(reader_handle: Edge<String>) -> Edge<i64> {
        Self {
            reader_handle,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<T> GraphOperation for Tan<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_COMPLEX64_or_DT_INT64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF,
      T: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("Tan_{}")?
        };
        let mut new_op = graph.new_operation("Tan", &op_name)?;
        {
            new_op.add_edge(&self.x)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct Tan<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_COMPLEX64_or_DT_INT64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    x: Edge<T>,
    op_name: Option<String>,
    id_: usize,
}

impl<T> Tan<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_COMPLEX64_or_DT_INT64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF,
      T: 'static,
{
    pub fn y(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(x: Edge<T>) -> Self {
        Self {
            phantom_T: PhantomData,
            x,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(x: Edge<T>) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            x,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl GraphOperation for ReaderSerializeState {
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("ReaderSerializeState_{}")?
        };
        let mut new_op = graph.new_operation("ReaderSerializeState", &op_name)?;
        {
            new_op.add_edge(&self.reader_handle)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct ReaderSerializeState {
    reader_handle: Edge<String>,
    op_name: Option<String>,
    id_: usize,
}

impl ReaderSerializeState {
    pub fn state(self) -> Edge<String> {
        let rc = Rc::new(self);
        {
            Edge::<String>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<String> {
        let rc = Rc::new(self);
        {
            Edge::<String>::new(rc.clone(), 0)
        }
    }

    pub fn build(reader_handle: Edge<String>) -> Self {
        Self {
            reader_handle,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(reader_handle: Edge<String>) -> Edge<String> {
        Self {
            reader_handle,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<T> GraphOperation for Exit<T>
where T: TensorType,
      T: Clone,
      T: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("Exit_{}")?
        };
        let mut new_op = graph.new_operation("Exit", &op_name)?;
        {
            new_op.add_edge(&self.data)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct Exit<T>
where T: TensorType,
      T: Clone,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    data: Edge<T>,
    op_name: Option<String>,
    id_: usize,
}

impl<T> Exit<T>
where T: TensorType,
      T: Clone,
      T: 'static,
{
    pub fn output(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(data: Edge<T>) -> Self {
        Self {
            phantom_T: PhantomData,
            data,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(data: Edge<T>) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            data,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl GraphOperation for RetrieveTPUEmbeddingProximalAdagradParameters {
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("RetrieveTPUEmbeddingProximalAdagradParameters_{}")?
        };
        let mut new_op = graph.new_operation("RetrieveTPUEmbeddingProximalAdagradParameters", &op_name)?;
        {
            match self.table_id {
                None => new_op.set_attr_value_proto("table_id", &vec![24_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 1_u8,])?,
                Some(ref value) => (|attr: &i64| {new_op.set_attr_int("table_id", *attr)})(&value)?,
            };
        }
        {
            match self.table_name {
                None => new_op.set_attr_value_proto("table_name", &vec![18_u8, 0_u8,])?,
                Some(ref value) => (|attr| {new_op.set_attr_string("table_name", attr)})(&value)?,
            };
        }
        {
            (|attr: &i64| {new_op.set_attr_int("num_shards", *attr)})(&self.num_shards)?
        }
        {
            (|attr: &i64| {new_op.set_attr_int("shard_id", *attr)})(&self.shard_id)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct RetrieveTPUEmbeddingProximalAdagradParameters {
    table_id: Option<i64>,
    table_name: Option<String>,
    num_shards: i64,
    shard_id: i64,
    op_name: Option<String>,
    id_: usize,
}

impl RetrieveTPUEmbeddingProximalAdagradParameters {
    pub fn parameters(self) -> Edge<f32> {
        let rc = Rc::new(self);
        {
            Edge::<f32>::new(rc.clone(), 0)
        }
    }

    pub fn accumulators(self) -> Edge<f32> {
        let rc = Rc::new(self);
        {
            Edge::<f32>::new(rc.clone(), 1)
        }
    }

    pub fn table_id(&mut self, table_id: i64) -> Self {
        self.table_id = Some(table_id);
        self.clone()
    }

    pub fn table_name(&mut self, table_name: &str) -> Self {
        self.table_name = Some(table_name.to_string());
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> (Edge<f32>, Edge<f32>) {
        let rc = Rc::new(self);
        (
        {
            Edge::<f32>::new(rc.clone(), 0)
        },
        {
            Edge::<f32>::new(rc.clone(), 1)
        },
        )
    }

    pub fn build(num_shards: i64, shard_id: i64) -> Self {
        Self {
            table_id: None,
            table_name: None,
            num_shards: num_shards,
            shard_id: shard_id,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(num_shards: i64, shard_id: i64) -> (Edge<f32>, Edge<f32>) {
        Self {
            table_id: None,
            table_name: None,
            num_shards: num_shards,
            shard_id: shard_id,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<T> GraphOperation for MaxPoolGradV2<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("MaxPoolGradV2_{}")?
        };
        let mut new_op = graph.new_operation("MaxPoolGradV2", &op_name)?;
        {
            new_op.add_edge(&self.orig_input)?
        }
        {
            new_op.add_edge(&self.orig_output)?
        }
        {
            new_op.add_edge(&self.grad)?
        }
        {
            new_op.add_edge(&self.ksize)?
        }
        {
            new_op.add_edge(&self.strides)?
        }
        {
            (|attr| {new_op.set_attr_string("padding", attr)})(&self.padding)?
        }
        {
            match self.data_format {
                None => new_op.set_attr_value_proto("data_format", &vec![18_u8, 4_u8, 78_u8, 72_u8, 87_u8, 67_u8,])?,
                Some(ref value) => (|attr| {new_op.set_attr_string("data_format", attr)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct MaxPoolGradV2<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    orig_input: Edge<T>,
    orig_output: Edge<T>,
    grad: Edge<T>,
    ksize: Edge<i32>,
    strides: Edge<i32>,
    padding: String,
    data_format: Option<String>,
    op_name: Option<String>,
    id_: usize,
}

impl<T> MaxPoolGradV2<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
{
    pub fn output(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn data_format(&mut self, data_format: &str) -> Self {
        self.data_format = Some(data_format.to_string());
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(orig_input: Edge<T>, orig_output: Edge<T>, grad: Edge<T>, ksize: Edge<i32>, strides: Edge<i32>, padding: &str) -> Self {
        Self {
            phantom_T: PhantomData,
            orig_input,
            orig_output,
            grad,
            ksize,
            strides,
            padding: padding.to_string(),
            data_format: None,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(orig_input: Edge<T>, orig_output: Edge<T>, grad: Edge<T>, ksize: Edge<i32>, strides: Edge<i32>, padding: &str) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            orig_input,
            orig_output,
            grad,
            ksize,
            strides,
            padding: padding.to_string(),
            data_format: None,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<dtype> GraphOperation for AccumulatorApplyGradient<dtype>
where dtype: TensorType,
      dtype: Clone,
      dtype: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      dtype: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("AccumulatorApplyGradient_{}")?
        };
        let mut new_op = graph.new_operation("AccumulatorApplyGradient", &op_name)?;
        {
            new_op.add_edge(&self.handle)?
        }
        {
            new_op.add_edge(&self.local_step)?
        }
        {
            new_op.add_edge(&self.gradient)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct AccumulatorApplyGradient<dtype>
where dtype: TensorType,
      dtype: Clone,
      dtype: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      dtype: 'static,
{
    handle: Edge<String>,
    local_step: Edge<i64>,
    phantom_dtype: PhantomData<dtype>,
    gradient: Edge<dtype>,
    op_name: Option<String>,
    id_: usize,
}

impl<dtype> AccumulatorApplyGradient<dtype>
where dtype: TensorType,
      dtype: Clone,
      dtype: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      dtype: 'static,
{
    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> () {
        let rc = Rc::new(self);
        (
        )
    }

    pub fn build(handle: Edge<String>, local_step: Edge<i64>, gradient: Edge<dtype>) -> Self {
        Self {
            handle,
            local_step,
            phantom_dtype: PhantomData,
            gradient,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(handle: Edge<String>, local_step: Edge<i64>, gradient: Edge<dtype>) -> () {
        Self {
            handle,
            local_step,
            phantom_dtype: PhantomData,
            gradient,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<T> GraphOperation for Abs<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_INT64_or_DT_BFLOAT16_or_DT_HALF,
      T: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("Abs_{}")?
        };
        let mut new_op = graph.new_operation("Abs", &op_name)?;
        {
            new_op.add_edge(&self.x)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct Abs<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_INT64_or_DT_BFLOAT16_or_DT_HALF,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    x: Edge<T>,
    op_name: Option<String>,
    id_: usize,
}

impl<T> Abs<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_INT64_or_DT_BFLOAT16_or_DT_HALF,
      T: 'static,
{
    pub fn y(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(x: Edge<T>) -> Self {
        Self {
            phantom_T: PhantomData,
            x,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(x: Edge<T>) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            x,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<T> GraphOperation for Cholesky<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_COMPLEX64_or_DT_COMPLEX128,
      T: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("Cholesky_{}")?
        };
        let mut new_op = graph.new_operation("Cholesky", &op_name)?;
        {
            new_op.add_edge(&self.input)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct Cholesky<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_COMPLEX64_or_DT_COMPLEX128,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    input: Edge<T>,
    op_name: Option<String>,
    id_: usize,
}

impl<T> Cholesky<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_COMPLEX64_or_DT_COMPLEX128,
      T: 'static,
{
    pub fn output(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(input: Edge<T>) -> Self {
        Self {
            phantom_T: PhantomData,
            input,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(input: Edge<T>) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            input,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<T, Tindices> GraphOperation for SparseApplyProximalGradientDescent<T, Tindices>
where T: TensorType,
      T: Clone,
      Tindices: TensorType,
      Tindices: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
      Tindices: con_or_DT_INT32_or_DT_INT64,
      Tindices: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("SparseApplyProximalGradientDescent_{}")?
        };
        let mut new_op = graph.new_operation("SparseApplyProximalGradientDescent", &op_name)?;
        {
            new_op.add_edge(&self.var)?
        }
        {
            new_op.add_edge(&self.alpha)?
        }
        {
            new_op.add_edge(&self.l1)?
        }
        {
            new_op.add_edge(&self.l2)?
        }
        {
            new_op.add_edge(&self.grad)?
        }
        {
            new_op.add_edge(&self.indices)?
        }
        {
            match self.use_locking {
                None => new_op.set_attr_value_proto("use_locking", &vec![40_u8, 0_u8,])?,
                Some(ref value) => (|attr: &bool| {new_op.set_attr_bool("use_locking", *attr)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct SparseApplyProximalGradientDescent<T, Tindices>
where T: TensorType,
      T: Clone,
      Tindices: TensorType,
      Tindices: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
      Tindices: con_or_DT_INT32_or_DT_INT64,
      Tindices: 'static,
{
    phantom_T: PhantomData<T>,
    var: Edge<T>,
    alpha: Edge<T>,
    l1: Edge<T>,
    l2: Edge<T>,
    grad: Edge<T>,
    phantom_Tindices: PhantomData<Tindices>,
    indices: Edge<Tindices>,
    use_locking: Option<bool>,
    op_name: Option<String>,
    id_: usize,
}

impl<T, Tindices> SparseApplyProximalGradientDescent<T, Tindices>
where T: TensorType,
      T: Clone,
      Tindices: TensorType,
      Tindices: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
      Tindices: con_or_DT_INT32_or_DT_INT64,
      Tindices: 'static,
{
    pub fn out(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn use_locking(&mut self, use_locking: bool) -> Self {
        self.use_locking = Some(use_locking);
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(var: Edge<T>, alpha: Edge<T>, l1: Edge<T>, l2: Edge<T>, grad: Edge<T>, indices: Edge<Tindices>) -> Self {
        Self {
            phantom_T: PhantomData,
            var,
            alpha,
            l1,
            l2,
            grad,
            phantom_Tindices: PhantomData,
            indices,
            use_locking: None,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(var: Edge<T>, alpha: Edge<T>, l1: Edge<T>, l2: Edge<T>, grad: Edge<T>, indices: Edge<Tindices>) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            var,
            alpha,
            l1,
            l2,
            grad,
            phantom_Tindices: PhantomData,
            indices,
            use_locking: None,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl GraphOperation for MatchingFiles {
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("MatchingFiles_{}")?
        };
        let mut new_op = graph.new_operation("MatchingFiles", &op_name)?;
        {
            new_op.add_edge(&self.pattern)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct MatchingFiles {
    pattern: Edge<String>,
    op_name: Option<String>,
    id_: usize,
}

impl MatchingFiles {
    pub fn filenames(self) -> Edge<String> {
        let rc = Rc::new(self);
        {
            Edge::<String>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<String> {
        let rc = Rc::new(self);
        {
            Edge::<String>::new(rc.clone(), 0)
        }
    }

    pub fn build(pattern: Edge<String>) -> Self {
        Self {
            pattern,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(pattern: Edge<String>) -> Edge<String> {
        Self {
            pattern,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl GraphOperation for BigQueryReader {
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("BigQueryReader_{}")?
        };
        let mut new_op = graph.new_operation("BigQueryReader", &op_name)?;
        {
            match self.container {
                None => new_op.set_attr_value_proto("container", &vec![18_u8, 0_u8,])?,
                Some(ref value) => (|attr| {new_op.set_attr_string("container", attr)})(&value)?,
            };
        }
        {
            match self.shared_name {
                None => new_op.set_attr_value_proto("shared_name", &vec![18_u8, 0_u8,])?,
                Some(ref value) => (|attr| {new_op.set_attr_string("shared_name", attr)})(&value)?,
            };
        }
        {
            (|attr| {new_op.set_attr_string("project_id", attr)})(&self.project_id)?
        }
        {
            (|attr| {new_op.set_attr_string("dataset_id", attr)})(&self.dataset_id)?
        }
        {
            (|attr| {new_op.set_attr_string("table_id", attr)})(&self.table_id)?
        }
        {
            (|attrs| {new_op.set_attr_string_list("columns", attrs)})(&self.columns)?
        }
        {
            (|attr: &i64| {new_op.set_attr_int("timestamp_millis", *attr)})(&self.timestamp_millis)?
        }
        {
            match self.test_end_point {
                None => new_op.set_attr_value_proto("test_end_point", &vec![18_u8, 0_u8,])?,
                Some(ref value) => (|attr| {new_op.set_attr_string("test_end_point", attr)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct BigQueryReader {
    container: Option<String>,
    shared_name: Option<String>,
    project_id: String,
    dataset_id: String,
    table_id: String,
    columns: Vec<String>,
    timestamp_millis: i64,
    test_end_point: Option<String>,
    op_name: Option<String>,
    id_: usize,
}

impl BigQueryReader {
    pub fn reader_handle(self) -> Edge<String> {
        let rc = Rc::new(self);
        {
            Edge::<String>::new(rc.clone(), 0)
        }
    }

    pub fn container(&mut self, container: &str) -> Self {
        self.container = Some(container.to_string());
        self.clone()
    }

    pub fn shared_name(&mut self, shared_name: &str) -> Self {
        self.shared_name = Some(shared_name.to_string());
        self.clone()
    }

    pub fn test_end_point(&mut self, test_end_point: &str) -> Self {
        self.test_end_point = Some(test_end_point.to_string());
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<String> {
        let rc = Rc::new(self);
        {
            Edge::<String>::new(rc.clone(), 0)
        }
    }

    pub fn build(project_id: &str, dataset_id: &str, table_id: &str, columns: &[String], timestamp_millis: i64) -> Self {
        Self {
            container: None,
            shared_name: None,
            project_id: project_id.to_string(),
            dataset_id: dataset_id.to_string(),
            table_id: table_id.to_string(),
            columns: columns.to_vec(),
            timestamp_millis: timestamp_millis,
            test_end_point: None,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(project_id: &str, dataset_id: &str, table_id: &str, columns: &[String], timestamp_millis: i64) -> Edge<String> {
        Self {
            container: None,
            shared_name: None,
            project_id: project_id.to_string(),
            dataset_id: dataset_id.to_string(),
            table_id: table_id.to_string(),
            columns: columns.to_vec(),
            timestamp_millis: timestamp_millis,
            test_end_point: None,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<T> GraphOperation for MatrixDeterminant<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_COMPLEX64_or_DT_COMPLEX128,
      T: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("MatrixDeterminant_{}")?
        };
        let mut new_op = graph.new_operation("MatrixDeterminant", &op_name)?;
        {
            new_op.add_edge(&self.input)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct MatrixDeterminant<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_COMPLEX64_or_DT_COMPLEX128,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    input: Edge<T>,
    op_name: Option<String>,
    id_: usize,
}

impl<T> MatrixDeterminant<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_COMPLEX64_or_DT_COMPLEX128,
      T: 'static,
{
    pub fn output(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(input: Edge<T>) -> Self {
        Self {
            phantom_T: PhantomData,
            input,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(input: Edge<T>) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            input,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<T> GraphOperation for MatrixInverse<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_COMPLEX64_or_DT_COMPLEX128,
      T: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("MatrixInverse_{}")?
        };
        let mut new_op = graph.new_operation("MatrixInverse", &op_name)?;
        {
            new_op.add_edge(&self.input)?
        }
        {
            match self.adjoint {
                None => new_op.set_attr_value_proto("adjoint", &vec![40_u8, 0_u8,])?,
                Some(ref value) => (|attr: &bool| {new_op.set_attr_bool("adjoint", *attr)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct MatrixInverse<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_COMPLEX64_or_DT_COMPLEX128,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    input: Edge<T>,
    adjoint: Option<bool>,
    op_name: Option<String>,
    id_: usize,
}

impl<T> MatrixInverse<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_COMPLEX64_or_DT_COMPLEX128,
      T: 'static,
{
    pub fn output(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn adjoint(&mut self, adjoint: bool) -> Self {
        self.adjoint = Some(adjoint);
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(input: Edge<T>) -> Self {
        Self {
            phantom_T: PhantomData,
            input,
            adjoint: None,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(input: Edge<T>) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            input,
            adjoint: None,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<dtype> GraphOperation for GetSessionTensor<dtype>
where dtype: TensorType,
      dtype: 'static,
      dtype: Clone,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("GetSessionTensor_{}")?
        };
        let mut new_op = graph.new_operation("GetSessionTensor", &op_name)?;
        {
            new_op.add_edge(&self.handle)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct GetSessionTensor<dtype>
where dtype: TensorType,
      dtype: 'static,
      dtype: Clone,
{
    handle: Edge<String>,
    phantom_dtype: PhantomData<dtype>,
    op_name: Option<String>,
    id_: usize,
}

impl<dtype> GetSessionTensor<dtype>
where dtype: TensorType,
      dtype: 'static,
      dtype: Clone,
{
    pub fn value(self) -> Edge<dtype> {
        let rc = Rc::new(self);
        {
            Edge::<dtype>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<dtype> {
        let rc = Rc::new(self);
        {
            Edge::<dtype>::new(rc.clone(), 0)
        }
    }

    pub fn build(handle: Edge<String>) -> Self {
        Self {
            handle,
            phantom_dtype: PhantomData,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(handle: Edge<String>) -> Edge<dtype> {
        Self {
            handle,
            phantom_dtype: PhantomData,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<T> GraphOperation for SqrtGrad<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_COMPLEX64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF,
      T: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("SqrtGrad_{}")?
        };
        let mut new_op = graph.new_operation("SqrtGrad", &op_name)?;
        {
            new_op.add_edge(&self.y)?
        }
        {
            new_op.add_edge(&self.dy)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct SqrtGrad<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_COMPLEX64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    y: Edge<T>,
    dy: Edge<T>,
    op_name: Option<String>,
    id_: usize,
}

impl<T> SqrtGrad<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_COMPLEX64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF,
      T: 'static,
{
    pub fn z(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(y: Edge<T>, dy: Edge<T>) -> Self {
        Self {
            phantom_T: PhantomData,
            y,
            dy,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(y: Edge<T>, dy: Edge<T>) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            y,
            dy,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

pub trait con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_INT64_or_DT_BFLOAT16 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_INT64_or_DT_BFLOAT16 for BFloat16 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_INT64_or_DT_BFLOAT16 for f32 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_INT64_or_DT_BFLOAT16 for f64 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_INT64_or_DT_BFLOAT16 for i32 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_INT64_or_DT_BFLOAT16 for i64 {
}

impl<T> GraphOperation for RaggedRange<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_INT64_or_DT_BFLOAT16,
      T: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("RaggedRange_{}")?
        };
        let mut new_op = graph.new_operation("RaggedRange", &op_name)?;
        {
            new_op.add_edge(&self.starts)?
        }
        {
            new_op.add_edge(&self.limits)?
        }
        {
            new_op.add_edge(&self.deltas)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct RaggedRange<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_INT64_or_DT_BFLOAT16,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    starts: Edge<T>,
    limits: Edge<T>,
    deltas: Edge<T>,
    op_name: Option<String>,
    id_: usize,
}

impl<T> RaggedRange<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_INT64_or_DT_BFLOAT16,
      T: 'static,
{
    pub fn rt_nested_splits(self) -> Edge<i64> {
        let rc = Rc::new(self);
        {
            Edge::<i64>::new(rc.clone(), 0)
        }
    }

    pub fn rt_dense_values(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 1)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> (Edge<i64>, Edge<T>) {
        let rc = Rc::new(self);
        (
        {
            Edge::<i64>::new(rc.clone(), 0)
        },
        {
            Edge::<T>::new(rc.clone(), 1)
        },
        )
    }

    pub fn build(starts: Edge<T>, limits: Edge<T>, deltas: Edge<T>) -> Self {
        Self {
            phantom_T: PhantomData,
            starts,
            limits,
            deltas,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(starts: Edge<T>, limits: Edge<T>, deltas: Edge<T>) -> (Edge<i64>, Edge<T>) {
        Self {
            phantom_T: PhantomData,
            starts,
            limits,
            deltas,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<T> GraphOperation for MatrixExponential<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_COMPLEX64_or_DT_COMPLEX128,
      T: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("MatrixExponential_{}")?
        };
        let mut new_op = graph.new_operation("MatrixExponential", &op_name)?;
        {
            new_op.add_edge(&self.input)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct MatrixExponential<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_COMPLEX64_or_DT_COMPLEX128,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    input: Edge<T>,
    op_name: Option<String>,
    id_: usize,
}

impl<T> MatrixExponential<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_COMPLEX64_or_DT_COMPLEX128,
      T: 'static,
{
    pub fn output(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(input: Edge<T>) -> Self {
        Self {
            phantom_T: PhantomData,
            input,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(input: Edge<T>) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            input,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<Tidx> GraphOperation for All<Tidx>
where Tidx: TensorType,
      Tidx: Clone,
      Tidx: con_or_DT_INT32_or_DT_INT64,
      Tidx: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("All_{}")?
        };
        let mut new_op = graph.new_operation("All", &op_name)?;
        {
            new_op.add_edge(&self.input)?
        }
        {
            new_op.add_edge(&self.reduction_indices)?
        }
        {
            match self.keep_dims {
                None => new_op.set_attr_value_proto("keep_dims", &vec![40_u8, 0_u8,])?,
                Some(ref value) => (|attr: &bool| {new_op.set_attr_bool("keep_dims", *attr)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct All<Tidx>
where Tidx: TensorType,
      Tidx: Clone,
      Tidx: con_or_DT_INT32_or_DT_INT64,
      Tidx: 'static,
{
    input: Edge<bool>,
    phantom_Tidx: PhantomData<Tidx>,
    reduction_indices: Edge<Tidx>,
    keep_dims: Option<bool>,
    op_name: Option<String>,
    id_: usize,
}

impl<Tidx> All<Tidx>
where Tidx: TensorType,
      Tidx: Clone,
      Tidx: con_or_DT_INT32_or_DT_INT64,
      Tidx: 'static,
{
    pub fn output(self) -> Edge<bool> {
        let rc = Rc::new(self);
        {
            Edge::<bool>::new(rc.clone(), 0)
        }
    }

    pub fn keep_dims(&mut self, keep_dims: bool) -> Self {
        self.keep_dims = Some(keep_dims);
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<bool> {
        let rc = Rc::new(self);
        {
            Edge::<bool>::new(rc.clone(), 0)
        }
    }

    pub fn build(input: Edge<bool>, reduction_indices: Edge<Tidx>) -> Self {
        Self {
            input,
            phantom_Tidx: PhantomData,
            reduction_indices,
            keep_dims: None,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(input: Edge<bool>, reduction_indices: Edge<Tidx>) -> Edge<bool> {
        Self {
            input,
            phantom_Tidx: PhantomData,
            reduction_indices,
            keep_dims: None,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<T> GraphOperation for SelfAdjointEig<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE,
      T: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("SelfAdjointEig_{}")?
        };
        let mut new_op = graph.new_operation("SelfAdjointEig", &op_name)?;
        {
            new_op.add_edge(&self.input)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct SelfAdjointEig<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    input: Edge<T>,
    op_name: Option<String>,
    id_: usize,
}

impl<T> SelfAdjointEig<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE,
      T: 'static,
{
    pub fn output(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(input: Edge<T>) -> Self {
        Self {
            phantom_T: PhantomData,
            input,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(input: Edge<T>) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            input,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<T> GraphOperation for BatchSelfAdjointEigV2<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE,
      T: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("BatchSelfAdjointEigV2_{}")?
        };
        let mut new_op = graph.new_operation("BatchSelfAdjointEigV2", &op_name)?;
        {
            new_op.add_edge(&self.input)?
        }
        {
            match self.compute_v {
                None => new_op.set_attr_value_proto("compute_v", &vec![40_u8, 1_u8,])?,
                Some(ref value) => (|attr: &bool| {new_op.set_attr_bool("compute_v", *attr)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct BatchSelfAdjointEigV2<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    input: Edge<T>,
    compute_v: Option<bool>,
    op_name: Option<String>,
    id_: usize,
}

impl<T> BatchSelfAdjointEigV2<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE,
      T: 'static,
{
    pub fn e(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn v(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 1)
        }
    }

    pub fn compute_v(&mut self, compute_v: bool) -> Self {
        self.compute_v = Some(compute_v);
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> (Edge<T>, Edge<T>) {
        let rc = Rc::new(self);
        (
        {
            Edge::<T>::new(rc.clone(), 0)
        },
        {
            Edge::<T>::new(rc.clone(), 1)
        },
        )
    }

    pub fn build(input: Edge<T>) -> Self {
        Self {
            phantom_T: PhantomData,
            input,
            compute_v: None,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(input: Edge<T>) -> (Edge<T>, Edge<T>) {
        Self {
            phantom_T: PhantomData,
            input,
            compute_v: None,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<T> GraphOperation for Svd<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_COMPLEX64_or_DT_COMPLEX128,
      T: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("Svd_{}")?
        };
        let mut new_op = graph.new_operation("Svd", &op_name)?;
        {
            new_op.add_edge(&self.input)?
        }
        {
            match self.compute_uv {
                None => new_op.set_attr_value_proto("compute_uv", &vec![40_u8, 1_u8,])?,
                Some(ref value) => (|attr: &bool| {new_op.set_attr_bool("compute_uv", *attr)})(&value)?,
            };
        }
        {
            match self.full_matrices {
                None => new_op.set_attr_value_proto("full_matrices", &vec![40_u8, 0_u8,])?,
                Some(ref value) => (|attr: &bool| {new_op.set_attr_bool("full_matrices", *attr)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct Svd<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_COMPLEX64_or_DT_COMPLEX128,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    input: Edge<T>,
    compute_uv: Option<bool>,
    full_matrices: Option<bool>,
    op_name: Option<String>,
    id_: usize,
}

impl<T> Svd<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_COMPLEX64_or_DT_COMPLEX128,
      T: 'static,
{
    pub fn s(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn u(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 1)
        }
    }

    pub fn v(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 2)
        }
    }

    pub fn compute_uv(&mut self, compute_uv: bool) -> Self {
        self.compute_uv = Some(compute_uv);
        self.clone()
    }

    pub fn full_matrices(&mut self, full_matrices: bool) -> Self {
        self.full_matrices = Some(full_matrices);
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> (Edge<T>, Edge<T>, Edge<T>) {
        let rc = Rc::new(self);
        (
        {
            Edge::<T>::new(rc.clone(), 0)
        },
        {
            Edge::<T>::new(rc.clone(), 1)
        },
        {
            Edge::<T>::new(rc.clone(), 2)
        },
        )
    }

    pub fn build(input: Edge<T>) -> Self {
        Self {
            phantom_T: PhantomData,
            input,
            compute_uv: None,
            full_matrices: None,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(input: Edge<T>) -> (Edge<T>, Edge<T>, Edge<T>) {
        Self {
            phantom_T: PhantomData,
            input,
            compute_uv: None,
            full_matrices: None,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<T> GraphOperation for BatchSelfAdjointEig<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE,
      T: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("BatchSelfAdjointEig_{}")?
        };
        let mut new_op = graph.new_operation("BatchSelfAdjointEig", &op_name)?;
        {
            new_op.add_edge(&self.input)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct BatchSelfAdjointEig<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    input: Edge<T>,
    op_name: Option<String>,
    id_: usize,
}

impl<T> BatchSelfAdjointEig<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE,
      T: 'static,
{
    pub fn output(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(input: Edge<T>) -> Self {
        Self {
            phantom_T: PhantomData,
            input,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(input: Edge<T>) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            input,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<T> GraphOperation for BatchMatrixSolve<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE,
      T: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("BatchMatrixSolve_{}")?
        };
        let mut new_op = graph.new_operation("BatchMatrixSolve", &op_name)?;
        {
            new_op.add_edge(&self.matrix)?
        }
        {
            new_op.add_edge(&self.rhs)?
        }
        {
            match self.adjoint {
                None => new_op.set_attr_value_proto("adjoint", &vec![40_u8, 0_u8,])?,
                Some(ref value) => (|attr: &bool| {new_op.set_attr_bool("adjoint", *attr)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct BatchMatrixSolve<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    matrix: Edge<T>,
    rhs: Edge<T>,
    adjoint: Option<bool>,
    op_name: Option<String>,
    id_: usize,
}

impl<T> BatchMatrixSolve<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE,
      T: 'static,
{
    pub fn output(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn adjoint(&mut self, adjoint: bool) -> Self {
        self.adjoint = Some(adjoint);
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(matrix: Edge<T>, rhs: Edge<T>) -> Self {
        Self {
            phantom_T: PhantomData,
            matrix,
            rhs,
            adjoint: None,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(matrix: Edge<T>, rhs: Edge<T>) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            matrix,
            rhs,
            adjoint: None,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<T> GraphOperation for BatchMatrixSolveLs<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE,
      T: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("BatchMatrixSolveLs_{}")?
        };
        let mut new_op = graph.new_operation("BatchMatrixSolveLs", &op_name)?;
        {
            new_op.add_edge(&self.matrix)?
        }
        {
            new_op.add_edge(&self.rhs)?
        }
        {
            new_op.add_edge(&self.l2_regularizer)?
        }
        {
            match self.fast {
                None => new_op.set_attr_value_proto("fast", &vec![40_u8, 1_u8,])?,
                Some(ref value) => (|attr: &bool| {new_op.set_attr_bool("fast", *attr)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct BatchMatrixSolveLs<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    matrix: Edge<T>,
    rhs: Edge<T>,
    l2_regularizer: Edge<f64>,
    fast: Option<bool>,
    op_name: Option<String>,
    id_: usize,
}

impl<T> BatchMatrixSolveLs<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE,
      T: 'static,
{
    pub fn output(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn fast(&mut self, fast: bool) -> Self {
        self.fast = Some(fast);
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(matrix: Edge<T>, rhs: Edge<T>, l2_regularizer: Edge<f64>) -> Self {
        Self {
            phantom_T: PhantomData,
            matrix,
            rhs,
            l2_regularizer,
            fast: None,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(matrix: Edge<T>, rhs: Edge<T>, l2_regularizer: Edge<f64>) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            matrix,
            rhs,
            l2_regularizer,
            fast: None,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<T> GraphOperation for RGBToHSV<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
      T: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("RGBToHSV_{}")?
        };
        let mut new_op = graph.new_operation("RGBToHSV", &op_name)?;
        {
            new_op.add_edge(&self.images)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct RGBToHSV<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    images: Edge<T>,
    op_name: Option<String>,
    id_: usize,
}

impl<T> RGBToHSV<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
      T: 'static,
{
    pub fn output(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(images: Edge<T>) -> Self {
        Self {
            phantom_T: PhantomData,
            images,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(images: Edge<T>) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            images,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<T> GraphOperation for BatchSvd<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_COMPLEX64_or_DT_COMPLEX128,
      T: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("BatchSvd_{}")?
        };
        let mut new_op = graph.new_operation("BatchSvd", &op_name)?;
        {
            new_op.add_edge(&self.input)?
        }
        {
            match self.compute_uv {
                None => new_op.set_attr_value_proto("compute_uv", &vec![40_u8, 1_u8,])?,
                Some(ref value) => (|attr: &bool| {new_op.set_attr_bool("compute_uv", *attr)})(&value)?,
            };
        }
        {
            match self.full_matrices {
                None => new_op.set_attr_value_proto("full_matrices", &vec![40_u8, 0_u8,])?,
                Some(ref value) => (|attr: &bool| {new_op.set_attr_bool("full_matrices", *attr)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct BatchSvd<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_COMPLEX64_or_DT_COMPLEX128,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    input: Edge<T>,
    compute_uv: Option<bool>,
    full_matrices: Option<bool>,
    op_name: Option<String>,
    id_: usize,
}

impl<T> BatchSvd<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_COMPLEX64_or_DT_COMPLEX128,
      T: 'static,
{
    pub fn s(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn u(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 1)
        }
    }

    pub fn v(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 2)
        }
    }

    pub fn compute_uv(&mut self, compute_uv: bool) -> Self {
        self.compute_uv = Some(compute_uv);
        self.clone()
    }

    pub fn full_matrices(&mut self, full_matrices: bool) -> Self {
        self.full_matrices = Some(full_matrices);
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> (Edge<T>, Edge<T>, Edge<T>) {
        let rc = Rc::new(self);
        (
        {
            Edge::<T>::new(rc.clone(), 0)
        },
        {
            Edge::<T>::new(rc.clone(), 1)
        },
        {
            Edge::<T>::new(rc.clone(), 2)
        },
        )
    }

    pub fn build(input: Edge<T>) -> Self {
        Self {
            phantom_T: PhantomData,
            input,
            compute_uv: None,
            full_matrices: None,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(input: Edge<T>) -> (Edge<T>, Edge<T>, Edge<T>) {
        Self {
            phantom_T: PhantomData,
            input,
            compute_uv: None,
            full_matrices: None,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<Tcomplex> GraphOperation for IFFT3D<Tcomplex>
where Tcomplex: TensorType,
      Tcomplex: Clone,
      Tcomplex: con_or_DT_COMPLEX64_or_DT_COMPLEX128,
      Tcomplex: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("IFFT3D_{}")?
        };
        let mut new_op = graph.new_operation("IFFT3D", &op_name)?;
        {
            new_op.add_edge(&self.input)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct IFFT3D<Tcomplex>
where Tcomplex: TensorType,
      Tcomplex: Clone,
      Tcomplex: con_or_DT_COMPLEX64_or_DT_COMPLEX128,
      Tcomplex: 'static,
{
    phantom_Tcomplex: PhantomData<Tcomplex>,
    input: Edge<Tcomplex>,
    op_name: Option<String>,
    id_: usize,
}

impl<Tcomplex> IFFT3D<Tcomplex>
where Tcomplex: TensorType,
      Tcomplex: Clone,
      Tcomplex: con_or_DT_COMPLEX64_or_DT_COMPLEX128,
      Tcomplex: 'static,
{
    pub fn output(self) -> Edge<Tcomplex> {
        let rc = Rc::new(self);
        {
            Edge::<Tcomplex>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<Tcomplex> {
        let rc = Rc::new(self);
        {
            Edge::<Tcomplex>::new(rc.clone(), 0)
        }
    }

    pub fn build(input: Edge<Tcomplex>) -> Self {
        Self {
            phantom_Tcomplex: PhantomData,
            input,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(input: Edge<Tcomplex>) -> Edge<Tcomplex> {
        Self {
            phantom_Tcomplex: PhantomData,
            input,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<T> GraphOperation for Invert<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_UINT16_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("Invert_{}")?
        };
        let mut new_op = graph.new_operation("Invert", &op_name)?;
        {
            new_op.add_edge(&self.x)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct Invert<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_UINT16_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    x: Edge<T>,
    op_name: Option<String>,
    id_: usize,
}

impl<T> Invert<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_UINT16_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
{
    pub fn y(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(x: Edge<T>) -> Self {
        Self {
            phantom_T: PhantomData,
            x,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(x: Edge<T>) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            x,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<T> GraphOperation for Dequantize<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_QINT16_or_DT_QUINT16,
      T: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("Dequantize_{}")?
        };
        let mut new_op = graph.new_operation("Dequantize", &op_name)?;
        {
            new_op.add_edge(&self.input)?
        }
        {
            new_op.add_edge(&self.min_range)?
        }
        {
            new_op.add_edge(&self.max_range)?
        }
        {
            match self.mode {
                None => new_op.set_attr_value_proto("mode", &vec![18_u8, 12_u8, 77_u8, 73_u8, 78_u8, 95_u8, 67_u8, 79_u8, 77_u8, 66_u8, 73_u8, 78_u8, 69_u8, 68_u8,])?,
                Some(ref value) => (|attr| {new_op.set_attr_string("mode", attr)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct Dequantize<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_QINT16_or_DT_QUINT16,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    input: Edge<T>,
    min_range: Edge<f32>,
    max_range: Edge<f32>,
    mode: Option<String>,
    op_name: Option<String>,
    id_: usize,
}

impl<T> Dequantize<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_QINT16_or_DT_QUINT16,
      T: 'static,
{
    pub fn output(self) -> Edge<f32> {
        let rc = Rc::new(self);
        {
            Edge::<f32>::new(rc.clone(), 0)
        }
    }

    pub fn mode(&mut self, mode: &str) -> Self {
        self.mode = Some(mode.to_string());
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<f32> {
        let rc = Rc::new(self);
        {
            Edge::<f32>::new(rc.clone(), 0)
        }
    }

    pub fn build(input: Edge<T>, min_range: Edge<f32>, max_range: Edge<f32>) -> Self {
        Self {
            phantom_T: PhantomData,
            input,
            min_range,
            max_range,
            mode: None,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(input: Edge<T>, min_range: Edge<f32>, max_range: Edge<f32>) -> Edge<f32> {
        Self {
            phantom_T: PhantomData,
            input,
            min_range,
            max_range,
            mode: None,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<key_dtype, value_dtype> GraphOperation for MutableHashTableOfTensors<key_dtype, value_dtype>
where key_dtype: 'static,
      key_dtype: Clone,
      value_dtype: 'static,
      value_dtype: Clone,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("MutableHashTableOfTensors_{}")?
        };
        let mut new_op = graph.new_operation("MutableHashTableOfTensors", &op_name)?;
        {
            match self.container {
                None => new_op.set_attr_value_proto("container", &vec![18_u8, 0_u8,])?,
                Some(ref value) => (|attr| {new_op.set_attr_string("container", attr)})(&value)?,
            };
        }
        {
            match self.shared_name {
                None => new_op.set_attr_value_proto("shared_name", &vec![18_u8, 0_u8,])?,
                Some(ref value) => (|attr| {new_op.set_attr_string("shared_name", attr)})(&value)?,
            };
        }
        {
            match self.use_node_name_sharing {
                None => new_op.set_attr_value_proto("use_node_name_sharing", &vec![40_u8, 0_u8,])?,
                Some(ref value) => (|attr: &bool| {new_op.set_attr_bool("use_node_name_sharing", *attr)})(&value)?,
            };
        }
        {
            match self.value_shape {
                None => new_op.set_attr_value_proto("value_shape", &vec![58_u8, 0_u8,])?,
                Some(ref value) => (|attr| {new_op.set_attr_shape("value_shape", attr)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct MutableHashTableOfTensors<key_dtype, value_dtype>
where key_dtype: 'static,
      key_dtype: Clone,
      value_dtype: 'static,
      value_dtype: Clone,
{
    container: Option<String>,
    shared_name: Option<String>,
    use_node_name_sharing: Option<bool>,
    phantom_key_dtype: PhantomData<key_dtype>,
    phantom_value_dtype: PhantomData<value_dtype>,
    value_shape: Option<OtherShape>,
    op_name: Option<String>,
    id_: usize,
}

impl<key_dtype, value_dtype> MutableHashTableOfTensors<key_dtype, value_dtype>
where key_dtype: 'static,
      key_dtype: Clone,
      value_dtype: 'static,
      value_dtype: Clone,
{
    pub fn table_handle(self) -> Edge<String> {
        let rc = Rc::new(self);
        {
            Edge::<String>::new(rc.clone(), 0)
        }
    }

    pub fn container(&mut self, container: &str) -> Self {
        self.container = Some(container.to_string());
        self.clone()
    }

    pub fn shared_name(&mut self, shared_name: &str) -> Self {
        self.shared_name = Some(shared_name.to_string());
        self.clone()
    }

    pub fn use_node_name_sharing(&mut self, use_node_name_sharing: bool) -> Self {
        self.use_node_name_sharing = Some(use_node_name_sharing);
        self.clone()
    }

    pub fn value_shape(&mut self, value_shape: &OtherShape) -> Self {
        self.value_shape = Some(value_shape.clone());
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<String> {
        let rc = Rc::new(self);
        {
            Edge::<String>::new(rc.clone(), 0)
        }
    }

    pub fn build() -> Self {
        Self {
            container: None,
            shared_name: None,
            use_node_name_sharing: None,
            phantom_key_dtype: PhantomData,
            phantom_value_dtype: PhantomData,
            value_shape: None,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new() -> Edge<String> {
        Self {
            container: None,
            shared_name: None,
            use_node_name_sharing: None,
            phantom_key_dtype: PhantomData,
            phantom_value_dtype: PhantomData,
            value_shape: None,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<T> GraphOperation for MaxPoolGradGrad<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("MaxPoolGradGrad_{}")?
        };
        let mut new_op = graph.new_operation("MaxPoolGradGrad", &op_name)?;
        {
            new_op.add_edge(&self.orig_input)?
        }
        {
            new_op.add_edge(&self.orig_output)?
        }
        {
            new_op.add_edge(&self.grad)?
        }
        {
            (|attrs| {new_op.set_attr_int_list("ksize", attrs)})(&self.ksize)?
        }
        {
            (|attrs| {new_op.set_attr_int_list("strides", attrs)})(&self.strides)?
        }
        {
            (|attr| {new_op.set_attr_string("padding", attr)})(&self.padding)?
        }
        {
            match self.data_format {
                None => new_op.set_attr_value_proto("data_format", &vec![18_u8, 4_u8, 78_u8, 72_u8, 87_u8, 67_u8,])?,
                Some(ref value) => (|attr| {new_op.set_attr_string("data_format", attr)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct MaxPoolGradGrad<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    orig_input: Edge<T>,
    orig_output: Edge<T>,
    grad: Edge<T>,
    ksize: Vec<i64>,
    strides: Vec<i64>,
    padding: String,
    data_format: Option<String>,
    op_name: Option<String>,
    id_: usize,
}

impl<T> MaxPoolGradGrad<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
{
    pub fn output(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn data_format(&mut self, data_format: &str) -> Self {
        self.data_format = Some(data_format.to_string());
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(orig_input: Edge<T>, orig_output: Edge<T>, grad: Edge<T>, ksize: &[i64], strides: &[i64], padding: &str) -> Self {
        Self {
            phantom_T: PhantomData,
            orig_input,
            orig_output,
            grad,
            ksize: ksize.to_vec(),
            strides: strides.to_vec(),
            padding: padding.to_string(),
            data_format: None,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(orig_input: Edge<T>, orig_output: Edge<T>, grad: Edge<T>, ksize: &[i64], strides: &[i64], padding: &str) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            orig_input,
            orig_output,
            grad,
            ksize: ksize.to_vec(),
            strides: strides.to_vec(),
            padding: padding.to_string(),
            data_format: None,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<T> GraphOperation for RightShift<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_UINT16_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("RightShift_{}")?
        };
        let mut new_op = graph.new_operation("RightShift", &op_name)?;
        {
            new_op.add_edge(&self.x)?
        }
        {
            new_op.add_edge(&self.y)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct RightShift<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_UINT16_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    x: Edge<T>,
    y: Edge<T>,
    op_name: Option<String>,
    id_: usize,
}

impl<T> RightShift<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_UINT16_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
{
    pub fn z(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(x: Edge<T>, y: Edge<T>) -> Self {
        Self {
            phantom_T: PhantomData,
            x,
            y,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(x: Edge<T>, y: Edge<T>) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            x,
            y,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<T> GraphOperation for ApplyAdagrad<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("ApplyAdagrad_{}")?
        };
        let mut new_op = graph.new_operation("ApplyAdagrad", &op_name)?;
        {
            new_op.add_edge(&self.var)?
        }
        {
            new_op.add_edge(&self.accum)?
        }
        {
            new_op.add_edge(&self.lr)?
        }
        {
            new_op.add_edge(&self.grad)?
        }
        {
            match self.use_locking {
                None => new_op.set_attr_value_proto("use_locking", &vec![40_u8, 0_u8,])?,
                Some(ref value) => (|attr: &bool| {new_op.set_attr_bool("use_locking", *attr)})(&value)?,
            };
        }
        {
            match self.update_slots {
                None => new_op.set_attr_value_proto("update_slots", &vec![40_u8, 1_u8,])?,
                Some(ref value) => (|attr: &bool| {new_op.set_attr_bool("update_slots", *attr)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct ApplyAdagrad<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    var: Edge<T>,
    accum: Edge<T>,
    lr: Edge<T>,
    grad: Edge<T>,
    use_locking: Option<bool>,
    update_slots: Option<bool>,
    op_name: Option<String>,
    id_: usize,
}

impl<T> ApplyAdagrad<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
{
    pub fn out(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn use_locking(&mut self, use_locking: bool) -> Self {
        self.use_locking = Some(use_locking);
        self.clone()
    }

    pub fn update_slots(&mut self, update_slots: bool) -> Self {
        self.update_slots = Some(update_slots);
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(var: Edge<T>, accum: Edge<T>, lr: Edge<T>, grad: Edge<T>) -> Self {
        Self {
            phantom_T: PhantomData,
            var,
            accum,
            lr,
            grad,
            use_locking: None,
            update_slots: None,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(var: Edge<T>, accum: Edge<T>, lr: Edge<T>, grad: Edge<T>) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            var,
            accum,
            lr,
            grad,
            use_locking: None,
            update_slots: None,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl GraphOperation for AudioSummaryV2 {
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("AudioSummaryV2_{}")?
        };
        let mut new_op = graph.new_operation("AudioSummaryV2", &op_name)?;
        {
            new_op.add_edge(&self.tag)?
        }
        {
            new_op.add_edge(&self.tensor)?
        }
        {
            new_op.add_edge(&self.sample_rate)?
        }
        {
            match self.max_outputs {
                None => new_op.set_attr_value_proto("max_outputs", &vec![24_u8, 3_u8,])?,
                Some(ref value) => (|attr: &i64| {new_op.set_attr_int("max_outputs", *attr)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct AudioSummaryV2 {
    tag: Edge<String>,
    tensor: Edge<f32>,
    sample_rate: Edge<f32>,
    max_outputs: Option<i64>,
    op_name: Option<String>,
    id_: usize,
}

impl AudioSummaryV2 {
    pub fn summary(self) -> Edge<String> {
        let rc = Rc::new(self);
        {
            Edge::<String>::new(rc.clone(), 0)
        }
    }

    pub fn max_outputs(&mut self, max_outputs: i64) -> Self {
        self.max_outputs = Some(max_outputs);
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<String> {
        let rc = Rc::new(self);
        {
            Edge::<String>::new(rc.clone(), 0)
        }
    }

    pub fn build(tag: Edge<String>, tensor: Edge<f32>, sample_rate: Edge<f32>) -> Self {
        Self {
            tag,
            tensor,
            sample_rate,
            max_outputs: None,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(tag: Edge<String>, tensor: Edge<f32>, sample_rate: Edge<f32>) -> Edge<String> {
        Self {
            tag,
            tensor,
            sample_rate,
            max_outputs: None,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<T, dtype> GraphOperation for ParameterizedTruncatedNormal<T, dtype>
where T: TensorType,
      T: Clone,
      dtype: TensorType,
      dtype: Clone,
      dtype: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
      dtype: 'static,
      T: con_or_DT_INT32_or_DT_INT64,
      T: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("ParameterizedTruncatedNormal_{}")?
        };
        let mut new_op = graph.new_operation("ParameterizedTruncatedNormal", &op_name)?;
        {
            new_op.add_edge(&self.shape)?
        }
        {
            new_op.add_edge(&self.means)?
        }
        {
            new_op.add_edge(&self.stdevs)?
        }
        {
            new_op.add_edge(&self.minvals)?
        }
        {
            new_op.add_edge(&self.maxvals)?
        }
        {
            match self.seed {
                None => new_op.set_attr_value_proto("seed", &vec![24_u8, 0_u8,])?,
                Some(ref value) => (|attr: &i64| {new_op.set_attr_int("seed", *attr)})(&value)?,
            };
        }
        {
            match self.seed2 {
                None => new_op.set_attr_value_proto("seed2", &vec![24_u8, 0_u8,])?,
                Some(ref value) => (|attr: &i64| {new_op.set_attr_int("seed2", *attr)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct ParameterizedTruncatedNormal<T, dtype>
where T: TensorType,
      T: Clone,
      dtype: TensorType,
      dtype: Clone,
      dtype: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
      dtype: 'static,
      T: con_or_DT_INT32_or_DT_INT64,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    shape: Edge<T>,
    phantom_dtype: PhantomData<dtype>,
    means: Edge<dtype>,
    stdevs: Edge<dtype>,
    minvals: Edge<dtype>,
    maxvals: Edge<dtype>,
    seed: Option<i64>,
    seed2: Option<i64>,
    op_name: Option<String>,
    id_: usize,
}

impl<T, dtype> ParameterizedTruncatedNormal<T, dtype>
where T: TensorType,
      T: Clone,
      dtype: TensorType,
      dtype: Clone,
      dtype: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
      dtype: 'static,
      T: con_or_DT_INT32_or_DT_INT64,
      T: 'static,
{
    pub fn output(self) -> Edge<dtype> {
        let rc = Rc::new(self);
        {
            Edge::<dtype>::new(rc.clone(), 0)
        }
    }

    pub fn seed(&mut self, seed: i64) -> Self {
        self.seed = Some(seed);
        self.clone()
    }

    pub fn seed2(&mut self, seed2: i64) -> Self {
        self.seed2 = Some(seed2);
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<dtype> {
        let rc = Rc::new(self);
        {
            Edge::<dtype>::new(rc.clone(), 0)
        }
    }

    pub fn build(shape: Edge<T>, means: Edge<dtype>, stdevs: Edge<dtype>, minvals: Edge<dtype>, maxvals: Edge<dtype>) -> Self {
        Self {
            phantom_T: PhantomData,
            shape,
            phantom_dtype: PhantomData,
            means,
            stdevs,
            minvals,
            maxvals,
            seed: None,
            seed2: None,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(shape: Edge<T>, means: Edge<dtype>, stdevs: Edge<dtype>, minvals: Edge<dtype>, maxvals: Edge<dtype>) -> Edge<dtype> {
        Self {
            phantom_T: PhantomData,
            shape,
            phantom_dtype: PhantomData,
            means,
            stdevs,
            minvals,
            maxvals,
            seed: None,
            seed2: None,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<T> GraphOperation for Diag<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_COMPLEX64_or_DT_INT64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF,
      T: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("Diag_{}")?
        };
        let mut new_op = graph.new_operation("Diag", &op_name)?;
        {
            new_op.add_edge(&self.diagonal)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct Diag<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_COMPLEX64_or_DT_INT64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    diagonal: Edge<T>,
    op_name: Option<String>,
    id_: usize,
}

impl<T> Diag<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_COMPLEX64_or_DT_INT64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF,
      T: 'static,
{
    pub fn output(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(diagonal: Edge<T>) -> Self {
        Self {
            phantom_T: PhantomData,
            diagonal,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(diagonal: Edge<T>) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            diagonal,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

pub trait con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_BOOL_or_DT_COMPLEX128 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_BOOL_or_DT_COMPLEX128 for OtherComplex<f32> {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_BOOL_or_DT_COMPLEX128 for OtherComplex<f64> {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_BOOL_or_DT_COMPLEX128 for bool {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_BOOL_or_DT_COMPLEX128 for f32 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_BOOL_or_DT_COMPLEX128 for f64 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_BOOL_or_DT_COMPLEX128 for i16 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_BOOL_or_DT_COMPLEX128 for i32 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_BOOL_or_DT_COMPLEX128 for i64 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_BOOL_or_DT_COMPLEX128 for i8 {
}

impl<T> GraphOperation for AsString<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_BOOL_or_DT_COMPLEX128,
      T: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("AsString_{}")?
        };
        let mut new_op = graph.new_operation("AsString", &op_name)?;
        {
            new_op.add_edge(&self.input)?
        }
        {
            match self.precision {
                None => new_op.set_attr_value_proto("precision", &vec![24_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 1_u8,])?,
                Some(ref value) => (|attr: &i64| {new_op.set_attr_int("precision", *attr)})(&value)?,
            };
        }
        {
            match self.scientific {
                None => new_op.set_attr_value_proto("scientific", &vec![40_u8, 0_u8,])?,
                Some(ref value) => (|attr: &bool| {new_op.set_attr_bool("scientific", *attr)})(&value)?,
            };
        }
        {
            match self.shortest {
                None => new_op.set_attr_value_proto("shortest", &vec![40_u8, 0_u8,])?,
                Some(ref value) => (|attr: &bool| {new_op.set_attr_bool("shortest", *attr)})(&value)?,
            };
        }
        {
            match self.width {
                None => new_op.set_attr_value_proto("width", &vec![24_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 1_u8,])?,
                Some(ref value) => (|attr: &i64| {new_op.set_attr_int("width", *attr)})(&value)?,
            };
        }
        {
            match self.fill {
                None => new_op.set_attr_value_proto("fill", &vec![18_u8, 0_u8,])?,
                Some(ref value) => (|attr| {new_op.set_attr_string("fill", attr)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct AsString<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_BOOL_or_DT_COMPLEX128,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    input: Edge<T>,
    precision: Option<i64>,
    scientific: Option<bool>,
    shortest: Option<bool>,
    width: Option<i64>,
    fill: Option<String>,
    op_name: Option<String>,
    id_: usize,
}

impl<T> AsString<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_BOOL_or_DT_COMPLEX128,
      T: 'static,
{
    pub fn output(self) -> Edge<String> {
        let rc = Rc::new(self);
        {
            Edge::<String>::new(rc.clone(), 0)
        }
    }

    pub fn precision(&mut self, precision: i64) -> Self {
        self.precision = Some(precision);
        self.clone()
    }

    pub fn scientific(&mut self, scientific: bool) -> Self {
        self.scientific = Some(scientific);
        self.clone()
    }

    pub fn shortest(&mut self, shortest: bool) -> Self {
        self.shortest = Some(shortest);
        self.clone()
    }

    pub fn width(&mut self, width: i64) -> Self {
        self.width = Some(width);
        self.clone()
    }

    pub fn fill(&mut self, fill: &str) -> Self {
        self.fill = Some(fill.to_string());
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<String> {
        let rc = Rc::new(self);
        {
            Edge::<String>::new(rc.clone(), 0)
        }
    }

    pub fn build(input: Edge<T>) -> Self {
        Self {
            phantom_T: PhantomData,
            input,
            precision: None,
            scientific: None,
            shortest: None,
            width: None,
            fill: None,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(input: Edge<T>) -> Edge<String> {
        Self {
            phantom_T: PhantomData,
            input,
            precision: None,
            scientific: None,
            shortest: None,
            width: None,
            fill: None,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<T> GraphOperation for TensorArrayScatterV2<T>
where T: TensorType,
      T: Clone,
      T: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("TensorArrayScatterV2_{}")?
        };
        let mut new_op = graph.new_operation("TensorArrayScatterV2", &op_name)?;
        {
            new_op.add_edge(&self.handle)?
        }
        {
            new_op.add_edge(&self.indices)?
        }
        {
            new_op.add_edge(&self.value)?
        }
        {
            new_op.add_edge(&self.flow_in)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct TensorArrayScatterV2<T>
where T: TensorType,
      T: Clone,
      T: 'static,
{
    handle: Edge<String>,
    indices: Edge<i32>,
    phantom_T: PhantomData<T>,
    value: Edge<T>,
    flow_in: Edge<f32>,
    op_name: Option<String>,
    id_: usize,
}

impl<T> TensorArrayScatterV2<T>
where T: TensorType,
      T: Clone,
      T: 'static,
{
    pub fn flow_out(self) -> Edge<f32> {
        let rc = Rc::new(self);
        {
            Edge::<f32>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<f32> {
        let rc = Rc::new(self);
        {
            Edge::<f32>::new(rc.clone(), 0)
        }
    }

    pub fn build(handle: Edge<String>, indices: Edge<i32>, value: Edge<T>, flow_in: Edge<f32>) -> Self {
        Self {
            handle,
            indices,
            phantom_T: PhantomData,
            value,
            flow_in,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(handle: Edge<String>, indices: Edge<i32>, value: Edge<T>, flow_in: Edge<f32>) -> Edge<f32> {
        Self {
            handle,
            indices,
            phantom_T: PhantomData,
            value,
            flow_in,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

pub trait con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_UINT8_or_DT_HALF {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_UINT8_or_DT_HALF for f32 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_UINT8_or_DT_HALF for f64 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_UINT8_or_DT_HALF for u8 {
}

impl<T> GraphOperation for ImageSummary<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_UINT8_or_DT_HALF,
      T: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("ImageSummary_{}")?
        };
        let mut new_op = graph.new_operation("ImageSummary", &op_name)?;
        {
            new_op.add_edge(&self.tag)?
        }
        {
            new_op.add_edge(&self.tensor)?
        }
        {
            match self.max_images {
                None => new_op.set_attr_value_proto("max_images", &vec![24_u8, 3_u8,])?,
                Some(ref value) => (|attr: &i64| {new_op.set_attr_int("max_images", *attr)})(&value)?,
            };
        }
        {
            match self.bad_color {
                None => new_op.set_attr_value_proto("bad_color", &vec![66_u8, 0_u8, 8_u8, 4_u8, 18_u8, 0_u8, 18_u8, 0_u8, 8_u8, 4_u8, 58_u8, 6_u8, 255_u8, 1_u8, 0_u8, 0_u8,])?,
                Some(ref value) => (|attr: &Rc<AnyTensor>| {new_op.set_attr_tensor_owned("bad_color", attr.clone())})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct ImageSummary<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_UINT8_or_DT_HALF,
      T: 'static,
{
    tag: Edge<String>,
    phantom_T: PhantomData<T>,
    tensor: Edge<T>,
    max_images: Option<i64>,
    bad_color: Option<Rc<AnyTensor>>,
    op_name: Option<String>,
    id_: usize,
}

impl<T> ImageSummary<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_UINT8_or_DT_HALF,
      T: 'static,
{
    pub fn summary(self) -> Edge<String> {
        let rc = Rc::new(self);
        {
            Edge::<String>::new(rc.clone(), 0)
        }
    }

    pub fn max_images(&mut self, max_images: i64) -> Self {
        self.max_images = Some(max_images);
        self.clone()
    }

    pub fn bad_color<bad_color_T>(&mut self, bad_color: bad_color_T) -> Self
    where bad_color_T: AnyTensor,
          bad_color_T: 'static,
    {
        self.bad_color = Some(Rc::new(bad_color));
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<String> {
        let rc = Rc::new(self);
        {
            Edge::<String>::new(rc.clone(), 0)
        }
    }

    pub fn build(tag: Edge<String>, tensor: Edge<T>) -> Self {
        Self {
            tag,
            phantom_T: PhantomData,
            tensor,
            max_images: None,
            bad_color: None,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(tag: Edge<String>, tensor: Edge<T>) -> Edge<String> {
        Self {
            tag,
            phantom_T: PhantomData,
            tensor,
            max_images: None,
            bad_color: None,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<T> GraphOperation for AvgPool<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
      T: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("AvgPool_{}")?
        };
        let mut new_op = graph.new_operation("AvgPool", &op_name)?;
        {
            new_op.add_edge(&self.value)?
        }
        {
            (|attrs| {new_op.set_attr_int_list("ksize", attrs)})(&self.ksize)?
        }
        {
            (|attrs| {new_op.set_attr_int_list("strides", attrs)})(&self.strides)?
        }
        {
            (|attr| {new_op.set_attr_string("padding", attr)})(&self.padding)?
        }
        {
            match self.data_format {
                None => new_op.set_attr_value_proto("data_format", &vec![18_u8, 4_u8, 78_u8, 72_u8, 87_u8, 67_u8,])?,
                Some(ref value) => (|attr| {new_op.set_attr_string("data_format", attr)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct AvgPool<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    value: Edge<T>,
    ksize: Vec<i64>,
    strides: Vec<i64>,
    padding: String,
    data_format: Option<String>,
    op_name: Option<String>,
    id_: usize,
}

impl<T> AvgPool<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
      T: 'static,
{
    pub fn output(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn data_format(&mut self, data_format: &str) -> Self {
        self.data_format = Some(data_format.to_string());
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(value: Edge<T>, ksize: &[i64], strides: &[i64], padding: &str) -> Self {
        Self {
            phantom_T: PhantomData,
            value,
            ksize: ksize.to_vec(),
            strides: strides.to_vec(),
            padding: padding.to_string(),
            data_format: None,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(value: Edge<T>, ksize: &[i64], strides: &[i64], padding: &str) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            value,
            ksize: ksize.to_vec(),
            strides: strides.to_vec(),
            padding: padding.to_string(),
            data_format: None,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl GraphOperation for MergeSummary {
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("MergeSummary_{}")?
        };
        let mut new_op = graph.new_operation("MergeSummary", &op_name)?;
        {
            new_op.add_edge(&self.inputs)?
        }
        {
            (|attr: &i64| {new_op.set_attr_int("N", *attr)})(&self.N)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct MergeSummary {
    inputs: Edge<String>,
    N: i64,
    op_name: Option<String>,
    id_: usize,
}

impl MergeSummary {
    pub fn summary(self) -> Edge<String> {
        let rc = Rc::new(self);
        {
            Edge::<String>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<String> {
        let rc = Rc::new(self);
        {
            Edge::<String>::new(rc.clone(), 0)
        }
    }

    pub fn build(inputs: Edge<String>, N: i64) -> Self {
        Self {
            inputs,
            N: N,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(inputs: Edge<String>, N: i64) -> Edge<String> {
        Self {
            inputs,
            N: N,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl GraphOperation for Timestamp {
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("Timestamp_{}")?
        };
        let mut new_op = graph.new_operation("Timestamp", &op_name)?;
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct Timestamp {
    op_name: Option<String>,
    id_: usize,
}

impl Timestamp {
    pub fn ts(self) -> Edge<f64> {
        let rc = Rc::new(self);
        {
            Edge::<f64>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<f64> {
        let rc = Rc::new(self);
        {
            Edge::<f64>::new(rc.clone(), 0)
        }
    }

    pub fn build() -> Self {
        Self {
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new() -> Edge<f64> {
        Self {
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<T> GraphOperation for BatchMatrixDiagPart<T>
where T: TensorType,
      T: Clone,
      T: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("BatchMatrixDiagPart_{}")?
        };
        let mut new_op = graph.new_operation("BatchMatrixDiagPart", &op_name)?;
        {
            new_op.add_edge(&self.input)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct BatchMatrixDiagPart<T>
where T: TensorType,
      T: Clone,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    input: Edge<T>,
    op_name: Option<String>,
    id_: usize,
}

impl<T> BatchMatrixDiagPart<T>
where T: TensorType,
      T: Clone,
      T: 'static,
{
    pub fn diagonal(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(input: Edge<T>) -> Self {
        Self {
            phantom_T: PhantomData,
            input,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(input: Edge<T>) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            input,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<T, Tindices> GraphOperation for SegmentMin<T, Tindices>
where T: TensorType,
      T: Clone,
      Tindices: TensorType,
      Tindices: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
      Tindices: con_or_DT_INT32_or_DT_INT64,
      Tindices: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("SegmentMin_{}")?
        };
        let mut new_op = graph.new_operation("SegmentMin", &op_name)?;
        {
            new_op.add_edge(&self.data)?
        }
        {
            new_op.add_edge(&self.segment_ids)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct SegmentMin<T, Tindices>
where T: TensorType,
      T: Clone,
      Tindices: TensorType,
      Tindices: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
      Tindices: con_or_DT_INT32_or_DT_INT64,
      Tindices: 'static,
{
    phantom_T: PhantomData<T>,
    data: Edge<T>,
    phantom_Tindices: PhantomData<Tindices>,
    segment_ids: Edge<Tindices>,
    op_name: Option<String>,
    id_: usize,
}

impl<T, Tindices> SegmentMin<T, Tindices>
where T: TensorType,
      T: Clone,
      Tindices: TensorType,
      Tindices: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
      Tindices: con_or_DT_INT32_or_DT_INT64,
      Tindices: 'static,
{
    pub fn output(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(data: Edge<T>, segment_ids: Edge<Tindices>) -> Self {
        Self {
            phantom_T: PhantomData,
            data,
            phantom_Tindices: PhantomData,
            segment_ids,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(data: Edge<T>, segment_ids: Edge<Tindices>) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            data,
            phantom_Tindices: PhantomData,
            segment_ids,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<T> GraphOperation for ResizeBicubicGrad<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE,
      T: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("ResizeBicubicGrad_{}")?
        };
        let mut new_op = graph.new_operation("ResizeBicubicGrad", &op_name)?;
        {
            new_op.add_edge(&self.grads)?
        }
        {
            new_op.add_edge(&self.original_image)?
        }
        {
            match self.align_corners {
                None => new_op.set_attr_value_proto("align_corners", &vec![40_u8, 0_u8,])?,
                Some(ref value) => (|attr: &bool| {new_op.set_attr_bool("align_corners", *attr)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct ResizeBicubicGrad<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE,
      T: 'static,
{
    grads: Edge<f32>,
    phantom_T: PhantomData<T>,
    original_image: Edge<T>,
    align_corners: Option<bool>,
    op_name: Option<String>,
    id_: usize,
}

impl<T> ResizeBicubicGrad<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE,
      T: 'static,
{
    pub fn output(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn align_corners(&mut self, align_corners: bool) -> Self {
        self.align_corners = Some(align_corners);
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(grads: Edge<f32>, original_image: Edge<T>) -> Self {
        Self {
            grads,
            phantom_T: PhantomData,
            original_image,
            align_corners: None,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(grads: Edge<f32>, original_image: Edge<T>) -> Edge<T> {
        Self {
            grads,
            phantom_T: PhantomData,
            original_image,
            align_corners: None,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<key_dtype, value_dtype> GraphOperation for HashTable<key_dtype, value_dtype>
where key_dtype: 'static,
      key_dtype: Clone,
      value_dtype: 'static,
      value_dtype: Clone,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("HashTable_{}")?
        };
        let mut new_op = graph.new_operation("HashTable", &op_name)?;
        {
            match self.container {
                None => new_op.set_attr_value_proto("container", &vec![18_u8, 0_u8,])?,
                Some(ref value) => (|attr| {new_op.set_attr_string("container", attr)})(&value)?,
            };
        }
        {
            match self.shared_name {
                None => new_op.set_attr_value_proto("shared_name", &vec![18_u8, 0_u8,])?,
                Some(ref value) => (|attr| {new_op.set_attr_string("shared_name", attr)})(&value)?,
            };
        }
        {
            match self.use_node_name_sharing {
                None => new_op.set_attr_value_proto("use_node_name_sharing", &vec![40_u8, 0_u8,])?,
                Some(ref value) => (|attr: &bool| {new_op.set_attr_bool("use_node_name_sharing", *attr)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct HashTable<key_dtype, value_dtype>
where key_dtype: 'static,
      key_dtype: Clone,
      value_dtype: 'static,
      value_dtype: Clone,
{
    container: Option<String>,
    shared_name: Option<String>,
    use_node_name_sharing: Option<bool>,
    phantom_key_dtype: PhantomData<key_dtype>,
    phantom_value_dtype: PhantomData<value_dtype>,
    op_name: Option<String>,
    id_: usize,
}

impl<key_dtype, value_dtype> HashTable<key_dtype, value_dtype>
where key_dtype: 'static,
      key_dtype: Clone,
      value_dtype: 'static,
      value_dtype: Clone,
{
    pub fn table_handle(self) -> Edge<String> {
        let rc = Rc::new(self);
        {
            Edge::<String>::new(rc.clone(), 0)
        }
    }

    pub fn container(&mut self, container: &str) -> Self {
        self.container = Some(container.to_string());
        self.clone()
    }

    pub fn shared_name(&mut self, shared_name: &str) -> Self {
        self.shared_name = Some(shared_name.to_string());
        self.clone()
    }

    pub fn use_node_name_sharing(&mut self, use_node_name_sharing: bool) -> Self {
        self.use_node_name_sharing = Some(use_node_name_sharing);
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<String> {
        let rc = Rc::new(self);
        {
            Edge::<String>::new(rc.clone(), 0)
        }
    }

    pub fn build() -> Self {
        Self {
            container: None,
            shared_name: None,
            use_node_name_sharing: None,
            phantom_key_dtype: PhantomData,
            phantom_value_dtype: PhantomData,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new() -> Edge<String> {
        Self {
            container: None,
            shared_name: None,
            use_node_name_sharing: None,
            phantom_key_dtype: PhantomData,
            phantom_value_dtype: PhantomData,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<key_dtype, value_dtype> GraphOperation for MutableHashTable<key_dtype, value_dtype>
where key_dtype: 'static,
      key_dtype: Clone,
      value_dtype: 'static,
      value_dtype: Clone,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("MutableHashTable_{}")?
        };
        let mut new_op = graph.new_operation("MutableHashTable", &op_name)?;
        {
            match self.container {
                None => new_op.set_attr_value_proto("container", &vec![18_u8, 0_u8,])?,
                Some(ref value) => (|attr| {new_op.set_attr_string("container", attr)})(&value)?,
            };
        }
        {
            match self.shared_name {
                None => new_op.set_attr_value_proto("shared_name", &vec![18_u8, 0_u8,])?,
                Some(ref value) => (|attr| {new_op.set_attr_string("shared_name", attr)})(&value)?,
            };
        }
        {
            match self.use_node_name_sharing {
                None => new_op.set_attr_value_proto("use_node_name_sharing", &vec![40_u8, 0_u8,])?,
                Some(ref value) => (|attr: &bool| {new_op.set_attr_bool("use_node_name_sharing", *attr)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct MutableHashTable<key_dtype, value_dtype>
where key_dtype: 'static,
      key_dtype: Clone,
      value_dtype: 'static,
      value_dtype: Clone,
{
    container: Option<String>,
    shared_name: Option<String>,
    use_node_name_sharing: Option<bool>,
    phantom_key_dtype: PhantomData<key_dtype>,
    phantom_value_dtype: PhantomData<value_dtype>,
    op_name: Option<String>,
    id_: usize,
}

impl<key_dtype, value_dtype> MutableHashTable<key_dtype, value_dtype>
where key_dtype: 'static,
      key_dtype: Clone,
      value_dtype: 'static,
      value_dtype: Clone,
{
    pub fn table_handle(self) -> Edge<String> {
        let rc = Rc::new(self);
        {
            Edge::<String>::new(rc.clone(), 0)
        }
    }

    pub fn container(&mut self, container: &str) -> Self {
        self.container = Some(container.to_string());
        self.clone()
    }

    pub fn shared_name(&mut self, shared_name: &str) -> Self {
        self.shared_name = Some(shared_name.to_string());
        self.clone()
    }

    pub fn use_node_name_sharing(&mut self, use_node_name_sharing: bool) -> Self {
        self.use_node_name_sharing = Some(use_node_name_sharing);
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<String> {
        let rc = Rc::new(self);
        {
            Edge::<String>::new(rc.clone(), 0)
        }
    }

    pub fn build() -> Self {
        Self {
            container: None,
            shared_name: None,
            use_node_name_sharing: None,
            phantom_key_dtype: PhantomData,
            phantom_value_dtype: PhantomData,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new() -> Edge<String> {
        Self {
            container: None,
            shared_name: None,
            use_node_name_sharing: None,
            phantom_key_dtype: PhantomData,
            phantom_value_dtype: PhantomData,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<Tkey, Tval> GraphOperation for InitializeTable<Tkey, Tval>
where Tkey: TensorType,
      Tkey: Clone,
      Tval: TensorType,
      Tval: Clone,
      Tkey: 'static,
      Tval: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("InitializeTable_{}")?
        };
        let mut new_op = graph.new_operation("InitializeTable", &op_name)?;
        {
            new_op.add_edge(&self.table_handle)?
        }
        {
            new_op.add_edge(&self.keys)?
        }
        {
            new_op.add_edge(&self.values)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct InitializeTable<Tkey, Tval>
where Tkey: TensorType,
      Tkey: Clone,
      Tval: TensorType,
      Tval: Clone,
      Tkey: 'static,
      Tval: 'static,
{
    table_handle: Edge<String>,
    phantom_Tkey: PhantomData<Tkey>,
    keys: Edge<Tkey>,
    phantom_Tval: PhantomData<Tval>,
    values: Edge<Tval>,
    op_name: Option<String>,
    id_: usize,
}

impl<Tkey, Tval> InitializeTable<Tkey, Tval>
where Tkey: TensorType,
      Tkey: Clone,
      Tval: TensorType,
      Tval: Clone,
      Tkey: 'static,
      Tval: 'static,
{
    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> () {
        let rc = Rc::new(self);
        (
        )
    }

    pub fn build(table_handle: Edge<String>, keys: Edge<Tkey>, values: Edge<Tval>) -> Self {
        Self {
            table_handle,
            phantom_Tkey: PhantomData,
            keys,
            phantom_Tval: PhantomData,
            values,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(table_handle: Edge<String>, keys: Edge<Tkey>, values: Edge<Tval>) -> () {
        Self {
            table_handle,
            phantom_Tkey: PhantomData,
            keys,
            phantom_Tval: PhantomData,
            values,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl GraphOperation for ShutdownDistributedTPU {
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("ShutdownDistributedTPU_{}")?
        };
        let mut new_op = graph.new_operation("ShutdownDistributedTPU", &op_name)?;
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct ShutdownDistributedTPU {
    op_name: Option<String>,
    id_: usize,
}

impl ShutdownDistributedTPU {
    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> () {
        let rc = Rc::new(self);
        (
        )
    }

    pub fn build() -> Self {
        Self {
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new() -> () {
        Self {
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<T> GraphOperation for AdjustContrast<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64,
      T: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("AdjustContrast_{}")?
        };
        let mut new_op = graph.new_operation("AdjustContrast", &op_name)?;
        {
            new_op.add_edge(&self.images)?
        }
        {
            new_op.add_edge(&self.contrast_factor)?
        }
        {
            new_op.add_edge(&self.min_value)?
        }
        {
            new_op.add_edge(&self.max_value)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct AdjustContrast<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    images: Edge<T>,
    contrast_factor: Edge<f32>,
    min_value: Edge<f32>,
    max_value: Edge<f32>,
    op_name: Option<String>,
    id_: usize,
}

impl<T> AdjustContrast<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64,
      T: 'static,
{
    pub fn output(self) -> Edge<f32> {
        let rc = Rc::new(self);
        {
            Edge::<f32>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<f32> {
        let rc = Rc::new(self);
        {
            Edge::<f32>::new(rc.clone(), 0)
        }
    }

    pub fn build(images: Edge<T>, contrast_factor: Edge<f32>, min_value: Edge<f32>, max_value: Edge<f32>) -> Self {
        Self {
            phantom_T: PhantomData,
            images,
            contrast_factor,
            min_value,
            max_value,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(images: Edge<T>, contrast_factor: Edge<f32>, min_value: Edge<f32>, max_value: Edge<f32>) -> Edge<f32> {
        Self {
            phantom_T: PhantomData,
            images,
            contrast_factor,
            min_value,
            max_value,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl GraphOperation for TryRpc {
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("TryRpc_{}")?
        };
        let mut new_op = graph.new_operation("TryRpc", &op_name)?;
        {
            new_op.add_edge(&self.address)?
        }
        {
            new_op.add_edge(&self.method)?
        }
        {
            new_op.add_edge(&self.request)?
        }
        {
            match self.protocol {
                None => new_op.set_attr_value_proto("protocol", &vec![18_u8, 0_u8,])?,
                Some(ref value) => (|attr| {new_op.set_attr_string("protocol", attr)})(&value)?,
            };
        }
        {
            match self.fail_fast {
                None => new_op.set_attr_value_proto("fail_fast", &vec![40_u8, 1_u8,])?,
                Some(ref value) => (|attr: &bool| {new_op.set_attr_bool("fail_fast", *attr)})(&value)?,
            };
        }
        {
            match self.timeout_in_ms {
                None => new_op.set_attr_value_proto("timeout_in_ms", &vec![24_u8, 0_u8,])?,
                Some(ref value) => (|attr: &i64| {new_op.set_attr_int("timeout_in_ms", *attr)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct TryRpc {
    address: Edge<String>,
    method: Edge<String>,
    request: Edge<String>,
    protocol: Option<String>,
    fail_fast: Option<bool>,
    timeout_in_ms: Option<i64>,
    op_name: Option<String>,
    id_: usize,
}

impl TryRpc {
    pub fn response(self) -> Edge<String> {
        let rc = Rc::new(self);
        {
            Edge::<String>::new(rc.clone(), 0)
        }
    }

    pub fn status_code(self) -> Edge<i32> {
        let rc = Rc::new(self);
        {
            Edge::<i32>::new(rc.clone(), 1)
        }
    }

    pub fn status_message(self) -> Edge<String> {
        let rc = Rc::new(self);
        {
            Edge::<String>::new(rc.clone(), 2)
        }
    }

    pub fn protocol(&mut self, protocol: &str) -> Self {
        self.protocol = Some(protocol.to_string());
        self.clone()
    }

    pub fn fail_fast(&mut self, fail_fast: bool) -> Self {
        self.fail_fast = Some(fail_fast);
        self.clone()
    }

    pub fn timeout_in_ms(&mut self, timeout_in_ms: i64) -> Self {
        self.timeout_in_ms = Some(timeout_in_ms);
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> (Edge<String>, Edge<i32>, Edge<String>) {
        let rc = Rc::new(self);
        (
        {
            Edge::<String>::new(rc.clone(), 0)
        },
        {
            Edge::<i32>::new(rc.clone(), 1)
        },
        {
            Edge::<String>::new(rc.clone(), 2)
        },
        )
    }

    pub fn build(address: Edge<String>, method: Edge<String>, request: Edge<String>) -> Self {
        Self {
            address,
            method,
            request,
            protocol: None,
            fail_fast: None,
            timeout_in_ms: None,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(address: Edge<String>, method: Edge<String>, request: Edge<String>) -> (Edge<String>, Edge<i32>, Edge<String>) {
        Self {
            address,
            method,
            request,
            protocol: None,
            fail_fast: None,
            timeout_in_ms: None,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<T> GraphOperation for Enter<T>
where T: TensorType,
      T: Clone,
      T: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("Enter_{}")?
        };
        let mut new_op = graph.new_operation("Enter", &op_name)?;
        {
            new_op.add_edge(&self.data)?
        }
        {
            (|attr| {new_op.set_attr_string("frame_name", attr)})(&self.frame_name)?
        }
        {
            match self.is_constant {
                None => new_op.set_attr_value_proto("is_constant", &vec![40_u8, 0_u8,])?,
                Some(ref value) => (|attr: &bool| {new_op.set_attr_bool("is_constant", *attr)})(&value)?,
            };
        }
        {
            match self.parallel_iterations {
                None => new_op.set_attr_value_proto("parallel_iterations", &vec![24_u8, 10_u8,])?,
                Some(ref value) => (|attr: &i64| {new_op.set_attr_int("parallel_iterations", *attr)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct Enter<T>
where T: TensorType,
      T: Clone,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    data: Edge<T>,
    frame_name: String,
    is_constant: Option<bool>,
    parallel_iterations: Option<i64>,
    op_name: Option<String>,
    id_: usize,
}

impl<T> Enter<T>
where T: TensorType,
      T: Clone,
      T: 'static,
{
    pub fn output(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn is_constant(&mut self, is_constant: bool) -> Self {
        self.is_constant = Some(is_constant);
        self.clone()
    }

    pub fn parallel_iterations(&mut self, parallel_iterations: i64) -> Self {
        self.parallel_iterations = Some(parallel_iterations);
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(data: Edge<T>, frame_name: &str) -> Self {
        Self {
            phantom_T: PhantomData,
            data,
            frame_name: frame_name.to_string(),
            is_constant: None,
            parallel_iterations: None,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(data: Edge<T>, frame_name: &str) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            data,
            frame_name: frame_name.to_string(),
            is_constant: None,
            parallel_iterations: None,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<T> GraphOperation for BatchMatrixDeterminant<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_COMPLEX64_or_DT_COMPLEX128,
      T: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("BatchMatrixDeterminant_{}")?
        };
        let mut new_op = graph.new_operation("BatchMatrixDeterminant", &op_name)?;
        {
            new_op.add_edge(&self.input)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct BatchMatrixDeterminant<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_COMPLEX64_or_DT_COMPLEX128,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    input: Edge<T>,
    op_name: Option<String>,
    id_: usize,
}

impl<T> BatchMatrixDeterminant<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_COMPLEX64_or_DT_COMPLEX128,
      T: 'static,
{
    pub fn output(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(input: Edge<T>) -> Self {
        Self {
            phantom_T: PhantomData,
            input,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(input: Edge<T>) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            input,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

pub trait con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_VARIANT_or_DT_UINT32_or_DT_UINT64 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_VARIANT_or_DT_UINT32_or_DT_UINT64 for BFloat16 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_VARIANT_or_DT_UINT32_or_DT_UINT64 for OtherComplex<f32> {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_VARIANT_or_DT_UINT32_or_DT_UINT64 for OtherComplex<f64> {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_VARIANT_or_DT_UINT32_or_DT_UINT64 for f32 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_VARIANT_or_DT_UINT32_or_DT_UINT64 for f64 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_VARIANT_or_DT_UINT32_or_DT_UINT64 for i16 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_VARIANT_or_DT_UINT32_or_DT_UINT64 for i32 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_VARIANT_or_DT_UINT32_or_DT_UINT64 for i64 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_VARIANT_or_DT_UINT32_or_DT_UINT64 for i8 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_VARIANT_or_DT_UINT32_or_DT_UINT64 for u16 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_VARIANT_or_DT_UINT32_or_DT_UINT64 for u32 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_VARIANT_or_DT_UINT32_or_DT_UINT64 for u64 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_VARIANT_or_DT_UINT32_or_DT_UINT64 for u8 {
}

impl<T> GraphOperation for AddN<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_VARIANT_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("AddN_{}")?
        };
        let mut new_op = graph.new_operation("AddN", &op_name)?;
        {
            new_op.add_edge(&self.inputs)?
        }
        {
            (|attr: &i64| {new_op.set_attr_int("N", *attr)})(&self.N)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct AddN<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_VARIANT_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    inputs: Edge<T>,
    N: i64,
    op_name: Option<String>,
    id_: usize,
}

impl<T> AddN<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_VARIANT_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
{
    pub fn sum(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(inputs: Edge<T>, N: i64) -> Self {
        Self {
            phantom_T: PhantomData,
            inputs,
            N: N,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(inputs: Edge<T>, N: i64) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            inputs,
            N: N,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<T> GraphOperation for BatchMatMul<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_COMPLEX64_or_DT_INT64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF,
      T: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("BatchMatMul_{}")?
        };
        let mut new_op = graph.new_operation("BatchMatMul", &op_name)?;
        {
            new_op.add_edge(&self.x)?
        }
        {
            new_op.add_edge(&self.y)?
        }
        {
            match self.adj_x {
                None => new_op.set_attr_value_proto("adj_x", &vec![40_u8, 0_u8,])?,
                Some(ref value) => (|attr: &bool| {new_op.set_attr_bool("adj_x", *attr)})(&value)?,
            };
        }
        {
            match self.adj_y {
                None => new_op.set_attr_value_proto("adj_y", &vec![40_u8, 0_u8,])?,
                Some(ref value) => (|attr: &bool| {new_op.set_attr_bool("adj_y", *attr)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct BatchMatMul<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_COMPLEX64_or_DT_INT64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    x: Edge<T>,
    y: Edge<T>,
    adj_x: Option<bool>,
    adj_y: Option<bool>,
    op_name: Option<String>,
    id_: usize,
}

impl<T> BatchMatMul<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_COMPLEX64_or_DT_INT64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF,
      T: 'static,
{
    pub fn output(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn adj_x(&mut self, adj_x: bool) -> Self {
        self.adj_x = Some(adj_x);
        self.clone()
    }

    pub fn adj_y(&mut self, adj_y: bool) -> Self {
        self.adj_y = Some(adj_y);
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(x: Edge<T>, y: Edge<T>) -> Self {
        Self {
            phantom_T: PhantomData,
            x,
            y,
            adj_x: None,
            adj_y: None,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(x: Edge<T>, y: Edge<T>) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            x,
            y,
            adj_x: None,
            adj_y: None,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<T> GraphOperation for Square<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_COMPLEX64_or_DT_INT64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF,
      T: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("Square_{}")?
        };
        let mut new_op = graph.new_operation("Square", &op_name)?;
        {
            new_op.add_edge(&self.x)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct Square<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_COMPLEX64_or_DT_INT64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    x: Edge<T>,
    op_name: Option<String>,
    id_: usize,
}

impl<T> Square<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_COMPLEX64_or_DT_INT64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF,
      T: 'static,
{
    pub fn y(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(x: Edge<T>) -> Self {
        Self {
            phantom_T: PhantomData,
            x,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(x: Edge<T>) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            x,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<T> GraphOperation for Conv3DBackpropFilter<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_HALF,
      T: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("Conv3DBackpropFilter_{}")?
        };
        let mut new_op = graph.new_operation("Conv3DBackpropFilter", &op_name)?;
        {
            new_op.add_edge(&self.input)?
        }
        {
            new_op.add_edge(&self.filter)?
        }
        {
            new_op.add_edge(&self.out_backprop)?
        }
        {
            (|attrs| {new_op.set_attr_int_list("strides", attrs)})(&self.strides)?
        }
        {
            (|attr| {new_op.set_attr_string("padding", attr)})(&self.padding)?
        }
        {
            match self.dilations {
                None => new_op.set_attr_value_proto("dilations", &vec![10_u8, 0_u8, 26_u8, 5_u8, 1_u8, 1_u8, 1_u8, 1_u8,])?,
                Some(ref value) => (|attrs| {new_op.set_attr_int_list("dilations", attrs)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct Conv3DBackpropFilter<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_HALF,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    input: Edge<T>,
    filter: Edge<T>,
    out_backprop: Edge<T>,
    strides: Vec<i64>,
    padding: String,
    dilations: Option<Vec<i64>>,
    op_name: Option<String>,
    id_: usize,
}

impl<T> Conv3DBackpropFilter<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_HALF,
      T: 'static,
{
    pub fn output(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn dilations(&mut self, dilations: &[i64]) -> Self {
        self.dilations = Some(dilations.to_vec());
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(input: Edge<T>, filter: Edge<T>, out_backprop: Edge<T>, strides: &[i64], padding: &str) -> Self {
        Self {
            phantom_T: PhantomData,
            input,
            filter,
            out_backprop,
            strides: strides.to_vec(),
            padding: padding.to_string(),
            dilations: None,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(input: Edge<T>, filter: Edge<T>, out_backprop: Edge<T>, strides: &[i64], padding: &str) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            input,
            filter,
            out_backprop,
            strides: strides.to_vec(),
            padding: padding.to_string(),
            dilations: None,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<T> GraphOperation for Sqrt<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_COMPLEX64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF,
      T: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("Sqrt_{}")?
        };
        let mut new_op = graph.new_operation("Sqrt", &op_name)?;
        {
            new_op.add_edge(&self.x)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct Sqrt<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_COMPLEX64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    x: Edge<T>,
    op_name: Option<String>,
    id_: usize,
}

impl<T> Sqrt<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_COMPLEX64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF,
      T: 'static,
{
    pub fn y(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(x: Edge<T>) -> Self {
        Self {
            phantom_T: PhantomData,
            x,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(x: Edge<T>) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            x,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<T> GraphOperation for Exp<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_COMPLEX64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF,
      T: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("Exp_{}")?
        };
        let mut new_op = graph.new_operation("Exp", &op_name)?;
        {
            new_op.add_edge(&self.x)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct Exp<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_COMPLEX64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    x: Edge<T>,
    op_name: Option<String>,
    id_: usize,
}

impl<T> Exp<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_COMPLEX64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF,
      T: 'static,
{
    pub fn y(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(x: Edge<T>) -> Self {
        Self {
            phantom_T: PhantomData,
            x,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(x: Edge<T>) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            x,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<T> GraphOperation for NthElement<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("NthElement_{}")?
        };
        let mut new_op = graph.new_operation("NthElement", &op_name)?;
        {
            new_op.add_edge(&self.input)?
        }
        {
            new_op.add_edge(&self.n)?
        }
        {
            match self.reverse {
                None => new_op.set_attr_value_proto("reverse", &vec![40_u8, 0_u8,])?,
                Some(ref value) => (|attr: &bool| {new_op.set_attr_bool("reverse", *attr)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct NthElement<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    input: Edge<T>,
    n: Edge<i32>,
    reverse: Option<bool>,
    op_name: Option<String>,
    id_: usize,
}

impl<T> NthElement<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
{
    pub fn values(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn reverse(&mut self, reverse: bool) -> Self {
        self.reverse = Some(reverse);
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(input: Edge<T>, n: Edge<i32>) -> Self {
        Self {
            phantom_T: PhantomData,
            input,
            n,
            reverse: None,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(input: Edge<T>, n: Edge<i32>) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            input,
            n,
            reverse: None,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<T, Tindices, Tnumsegments> GraphOperation for UnsortedSegmentMax<T, Tindices, Tnumsegments>
where T: TensorType,
      T: Clone,
      Tindices: TensorType,
      Tindices: Clone,
      Tnumsegments: TensorType,
      Tnumsegments: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
      Tindices: con_or_DT_INT32_or_DT_INT64,
      Tindices: 'static,
      Tnumsegments: con_or_DT_INT32_or_DT_INT64,
      Tnumsegments: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("UnsortedSegmentMax_{}")?
        };
        let mut new_op = graph.new_operation("UnsortedSegmentMax", &op_name)?;
        {
            new_op.add_edge(&self.data)?
        }
        {
            new_op.add_edge(&self.segment_ids)?
        }
        {
            new_op.add_edge(&self.num_segments)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct UnsortedSegmentMax<T, Tindices, Tnumsegments>
where T: TensorType,
      T: Clone,
      Tindices: TensorType,
      Tindices: Clone,
      Tnumsegments: TensorType,
      Tnumsegments: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
      Tindices: con_or_DT_INT32_or_DT_INT64,
      Tindices: 'static,
      Tnumsegments: con_or_DT_INT32_or_DT_INT64,
      Tnumsegments: 'static,
{
    phantom_T: PhantomData<T>,
    data: Edge<T>,
    phantom_Tindices: PhantomData<Tindices>,
    segment_ids: Edge<Tindices>,
    phantom_Tnumsegments: PhantomData<Tnumsegments>,
    num_segments: Edge<Tnumsegments>,
    op_name: Option<String>,
    id_: usize,
}

impl<T, Tindices, Tnumsegments> UnsortedSegmentMax<T, Tindices, Tnumsegments>
where T: TensorType,
      T: Clone,
      Tindices: TensorType,
      Tindices: Clone,
      Tnumsegments: TensorType,
      Tnumsegments: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
      Tindices: con_or_DT_INT32_or_DT_INT64,
      Tindices: 'static,
      Tnumsegments: con_or_DT_INT32_or_DT_INT64,
      Tnumsegments: 'static,
{
    pub fn output(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(data: Edge<T>, segment_ids: Edge<Tindices>, num_segments: Edge<Tnumsegments>) -> Self {
        Self {
            phantom_T: PhantomData,
            data,
            phantom_Tindices: PhantomData,
            segment_ids,
            phantom_Tnumsegments: PhantomData,
            num_segments,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(data: Edge<T>, segment_ids: Edge<Tindices>, num_segments: Edge<Tnumsegments>) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            data,
            phantom_Tindices: PhantomData,
            segment_ids,
            phantom_Tnumsegments: PhantomData,
            num_segments,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<T> GraphOperation for Softplus<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
      T: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("Softplus_{}")?
        };
        let mut new_op = graph.new_operation("Softplus", &op_name)?;
        {
            new_op.add_edge(&self.features)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct Softplus<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    features: Edge<T>,
    op_name: Option<String>,
    id_: usize,
}

impl<T> Softplus<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
      T: 'static,
{
    pub fn activations(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(features: Edge<T>) -> Self {
        Self {
            phantom_T: PhantomData,
            features,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(features: Edge<T>) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            features,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<T> GraphOperation for Expm1<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_COMPLEX64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF,
      T: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("Expm1_{}")?
        };
        let mut new_op = graph.new_operation("Expm1", &op_name)?;
        {
            new_op.add_edge(&self.x)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct Expm1<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_COMPLEX64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    x: Edge<T>,
    op_name: Option<String>,
    id_: usize,
}

impl<T> Expm1<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_COMPLEX64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF,
      T: 'static,
{
    pub fn y(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(x: Edge<T>) -> Self {
        Self {
            phantom_T: PhantomData,
            x,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(x: Edge<T>) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            x,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<T> GraphOperation for Log<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_COMPLEX64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF,
      T: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("Log_{}")?
        };
        let mut new_op = graph.new_operation("Log", &op_name)?;
        {
            new_op.add_edge(&self.x)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct Log<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_COMPLEX64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    x: Edge<T>,
    op_name: Option<String>,
    id_: usize,
}

impl<T> Log<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_COMPLEX64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF,
      T: 'static,
{
    pub fn y(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(x: Edge<T>) -> Self {
        Self {
            phantom_T: PhantomData,
            x,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(x: Edge<T>) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            x,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<T, Tidx, Tnumsegments> GraphOperation for SparseSegmentMeanWithNumSegments<T, Tidx, Tnumsegments>
where T: TensorType,
      T: Clone,
      Tidx: TensorType,
      Tidx: Clone,
      Tnumsegments: TensorType,
      Tnumsegments: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE,
      T: 'static,
      Tidx: con_or_DT_INT32_or_DT_INT64,
      Tidx: 'static,
      Tnumsegments: con_or_DT_INT32_or_DT_INT64,
      Tnumsegments: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("SparseSegmentMeanWithNumSegments_{}")?
        };
        let mut new_op = graph.new_operation("SparseSegmentMeanWithNumSegments", &op_name)?;
        {
            new_op.add_edge(&self.data)?
        }
        {
            new_op.add_edge(&self.indices)?
        }
        {
            new_op.add_edge(&self.segment_ids)?
        }
        {
            new_op.add_edge(&self.num_segments)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct SparseSegmentMeanWithNumSegments<T, Tidx, Tnumsegments>
where T: TensorType,
      T: Clone,
      Tidx: TensorType,
      Tidx: Clone,
      Tnumsegments: TensorType,
      Tnumsegments: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE,
      T: 'static,
      Tidx: con_or_DT_INT32_or_DT_INT64,
      Tidx: 'static,
      Tnumsegments: con_or_DT_INT32_or_DT_INT64,
      Tnumsegments: 'static,
{
    phantom_T: PhantomData<T>,
    data: Edge<T>,
    phantom_Tidx: PhantomData<Tidx>,
    indices: Edge<Tidx>,
    segment_ids: Edge<i32>,
    phantom_Tnumsegments: PhantomData<Tnumsegments>,
    num_segments: Edge<Tnumsegments>,
    op_name: Option<String>,
    id_: usize,
}

impl<T, Tidx, Tnumsegments> SparseSegmentMeanWithNumSegments<T, Tidx, Tnumsegments>
where T: TensorType,
      T: Clone,
      Tidx: TensorType,
      Tidx: Clone,
      Tnumsegments: TensorType,
      Tnumsegments: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE,
      T: 'static,
      Tidx: con_or_DT_INT32_or_DT_INT64,
      Tidx: 'static,
      Tnumsegments: con_or_DT_INT32_or_DT_INT64,
      Tnumsegments: 'static,
{
    pub fn output(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(data: Edge<T>, indices: Edge<Tidx>, segment_ids: Edge<i32>, num_segments: Edge<Tnumsegments>) -> Self {
        Self {
            phantom_T: PhantomData,
            data,
            phantom_Tidx: PhantomData,
            indices,
            segment_ids,
            phantom_Tnumsegments: PhantomData,
            num_segments,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(data: Edge<T>, indices: Edge<Tidx>, segment_ids: Edge<i32>, num_segments: Edge<Tnumsegments>) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            data,
            phantom_Tidx: PhantomData,
            indices,
            segment_ids,
            phantom_Tnumsegments: PhantomData,
            num_segments,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<T> GraphOperation for Cosh<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_COMPLEX64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF,
      T: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("Cosh_{}")?
        };
        let mut new_op = graph.new_operation("Cosh", &op_name)?;
        {
            new_op.add_edge(&self.x)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct Cosh<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_COMPLEX64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    x: Edge<T>,
    op_name: Option<String>,
    id_: usize,
}

impl<T> Cosh<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_COMPLEX64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF,
      T: 'static,
{
    pub fn y(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(x: Edge<T>) -> Self {
        Self {
            phantom_T: PhantomData,
            x,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(x: Edge<T>) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            x,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<T, Tindices> GraphOperation for SegmentMax<T, Tindices>
where T: TensorType,
      T: Clone,
      Tindices: TensorType,
      Tindices: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
      Tindices: con_or_DT_INT32_or_DT_INT64,
      Tindices: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("SegmentMax_{}")?
        };
        let mut new_op = graph.new_operation("SegmentMax", &op_name)?;
        {
            new_op.add_edge(&self.data)?
        }
        {
            new_op.add_edge(&self.segment_ids)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct SegmentMax<T, Tindices>
where T: TensorType,
      T: Clone,
      Tindices: TensorType,
      Tindices: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
      Tindices: con_or_DT_INT32_or_DT_INT64,
      Tindices: 'static,
{
    phantom_T: PhantomData<T>,
    data: Edge<T>,
    phantom_Tindices: PhantomData<Tindices>,
    segment_ids: Edge<Tindices>,
    op_name: Option<String>,
    id_: usize,
}

impl<T, Tindices> SegmentMax<T, Tindices>
where T: TensorType,
      T: Clone,
      Tindices: TensorType,
      Tindices: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
      Tindices: con_or_DT_INT32_or_DT_INT64,
      Tindices: 'static,
{
    pub fn output(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(data: Edge<T>, segment_ids: Edge<Tindices>) -> Self {
        Self {
            phantom_T: PhantomData,
            data,
            phantom_Tindices: PhantomData,
            segment_ids,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(data: Edge<T>, segment_ids: Edge<Tindices>) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            data,
            phantom_Tindices: PhantomData,
            segment_ids,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<T> GraphOperation for Tanh<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_COMPLEX64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF,
      T: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("Tanh_{}")?
        };
        let mut new_op = graph.new_operation("Tanh", &op_name)?;
        {
            new_op.add_edge(&self.x)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct Tanh<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_COMPLEX64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    x: Edge<T>,
    op_name: Option<String>,
    id_: usize,
}

impl<T> Tanh<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_COMPLEX64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF,
      T: 'static,
{
    pub fn y(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(x: Edge<T>) -> Self {
        Self {
            phantom_T: PhantomData,
            x,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(x: Edge<T>) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            x,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl GraphOperation for UnicodeTranscode {
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("UnicodeTranscode_{}")?
        };
        let mut new_op = graph.new_operation("UnicodeTranscode", &op_name)?;
        {
            new_op.add_edge(&self.input)?
        }
        {
            (|attr| {new_op.set_attr_string("input_encoding", attr)})(&self.input_encoding)?
        }
        {
            (|attr| {new_op.set_attr_string("output_encoding", attr)})(&self.output_encoding)?
        }
        {
            match self.errors {
                None => new_op.set_attr_value_proto("errors", &vec![18_u8, 7_u8, 114_u8, 101_u8, 112_u8, 108_u8, 97_u8, 99_u8, 101_u8,])?,
                Some(ref value) => (|attr| {new_op.set_attr_string("errors", attr)})(&value)?,
            };
        }
        {
            match self.replacement_char {
                None => new_op.set_attr_value_proto("replacement_char", &vec![24_u8, 253_u8, 255_u8, 3_u8,])?,
                Some(ref value) => (|attr: &i64| {new_op.set_attr_int("replacement_char", *attr)})(&value)?,
            };
        }
        {
            match self.replace_control_characters {
                None => new_op.set_attr_value_proto("replace_control_characters", &vec![40_u8, 0_u8,])?,
                Some(ref value) => (|attr: &bool| {new_op.set_attr_bool("replace_control_characters", *attr)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct UnicodeTranscode {
    input: Edge<String>,
    input_encoding: String,
    output_encoding: String,
    errors: Option<String>,
    replacement_char: Option<i64>,
    replace_control_characters: Option<bool>,
    op_name: Option<String>,
    id_: usize,
}

impl UnicodeTranscode {
    pub fn output(self) -> Edge<String> {
        let rc = Rc::new(self);
        {
            Edge::<String>::new(rc.clone(), 0)
        }
    }

    pub fn errors(&mut self, errors: &str) -> Self {
        self.errors = Some(errors.to_string());
        self.clone()
    }

    pub fn replacement_char(&mut self, replacement_char: i64) -> Self {
        self.replacement_char = Some(replacement_char);
        self.clone()
    }

    pub fn replace_control_characters(&mut self, replace_control_characters: bool) -> Self {
        self.replace_control_characters = Some(replace_control_characters);
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<String> {
        let rc = Rc::new(self);
        {
            Edge::<String>::new(rc.clone(), 0)
        }
    }

    pub fn build(input: Edge<String>, input_encoding: &str, output_encoding: &str) -> Self {
        Self {
            input,
            input_encoding: input_encoding.to_string(),
            output_encoding: output_encoding.to_string(),
            errors: None,
            replacement_char: None,
            replace_control_characters: None,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(input: Edge<String>, input_encoding: &str, output_encoding: &str) -> Edge<String> {
        Self {
            input,
            input_encoding: input_encoding.to_string(),
            output_encoding: output_encoding.to_string(),
            errors: None,
            replacement_char: None,
            replace_control_characters: None,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<T> GraphOperation for Asinh<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_COMPLEX64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF,
      T: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("Asinh_{}")?
        };
        let mut new_op = graph.new_operation("Asinh", &op_name)?;
        {
            new_op.add_edge(&self.x)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct Asinh<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_COMPLEX64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    x: Edge<T>,
    op_name: Option<String>,
    id_: usize,
}

impl<T> Asinh<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_COMPLEX64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF,
      T: 'static,
{
    pub fn y(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(x: Edge<T>) -> Self {
        Self {
            phantom_T: PhantomData,
            x,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(x: Edge<T>) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            x,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<T> GraphOperation for HSVToRGB<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
      T: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("HSVToRGB_{}")?
        };
        let mut new_op = graph.new_operation("HSVToRGB", &op_name)?;
        {
            new_op.add_edge(&self.images)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct HSVToRGB<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    images: Edge<T>,
    op_name: Option<String>,
    id_: usize,
}

impl<T> HSVToRGB<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
      T: 'static,
{
    pub fn output(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(images: Edge<T>) -> Self {
        Self {
            phantom_T: PhantomData,
            images,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(images: Edge<T>) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            images,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<T> GraphOperation for SigmoidGrad<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_COMPLEX64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF,
      T: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("SigmoidGrad_{}")?
        };
        let mut new_op = graph.new_operation("SigmoidGrad", &op_name)?;
        {
            new_op.add_edge(&self.y)?
        }
        {
            new_op.add_edge(&self.dy)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct SigmoidGrad<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_COMPLEX64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    y: Edge<T>,
    dy: Edge<T>,
    op_name: Option<String>,
    id_: usize,
}

impl<T> SigmoidGrad<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_COMPLEX64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF,
      T: 'static,
{
    pub fn z(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(y: Edge<T>, dy: Edge<T>) -> Self {
        Self {
            phantom_T: PhantomData,
            y,
            dy,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(y: Edge<T>, dy: Edge<T>) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            y,
            dy,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<T> GraphOperation for Sin<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_COMPLEX64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF,
      T: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("Sin_{}")?
        };
        let mut new_op = graph.new_operation("Sin", &op_name)?;
        {
            new_op.add_edge(&self.x)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct Sin<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_COMPLEX64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    x: Edge<T>,
    op_name: Option<String>,
    id_: usize,
}

impl<T> Sin<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_COMPLEX64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF,
      T: 'static,
{
    pub fn y(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(x: Edge<T>) -> Self {
        Self {
            phantom_T: PhantomData,
            x,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(x: Edge<T>) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            x,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<T> GraphOperation for Acos<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_COMPLEX64_or_DT_INT64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF,
      T: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("Acos_{}")?
        };
        let mut new_op = graph.new_operation("Acos", &op_name)?;
        {
            new_op.add_edge(&self.x)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct Acos<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_COMPLEX64_or_DT_INT64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    x: Edge<T>,
    op_name: Option<String>,
    id_: usize,
}

impl<T> Acos<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_COMPLEX64_or_DT_INT64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF,
      T: 'static,
{
    pub fn y(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(x: Edge<T>) -> Self {
        Self {
            phantom_T: PhantomData,
            x,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(x: Edge<T>) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            x,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<T> GraphOperation for BesselI0e<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
      T: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("BesselI0e_{}")?
        };
        let mut new_op = graph.new_operation("BesselI0e", &op_name)?;
        {
            new_op.add_edge(&self.x)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct BesselI0e<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    x: Edge<T>,
    op_name: Option<String>,
    id_: usize,
}

impl<T> BesselI0e<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
      T: 'static,
{
    pub fn y(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(x: Edge<T>) -> Self {
        Self {
            phantom_T: PhantomData,
            x,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(x: Edge<T>) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            x,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<T, Tperm> GraphOperation for Transpose<T, Tperm>
where T: TensorType,
      T: Clone,
      Tperm: TensorType,
      Tperm: Clone,
      T: 'static,
      Tperm: con_or_DT_INT32_or_DT_INT64,
      Tperm: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("Transpose_{}")?
        };
        let mut new_op = graph.new_operation("Transpose", &op_name)?;
        {
            new_op.add_edge(&self.x)?
        }
        {
            new_op.add_edge(&self.perm)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct Transpose<T, Tperm>
where T: TensorType,
      T: Clone,
      Tperm: TensorType,
      Tperm: Clone,
      T: 'static,
      Tperm: con_or_DT_INT32_or_DT_INT64,
      Tperm: 'static,
{
    phantom_T: PhantomData<T>,
    x: Edge<T>,
    phantom_Tperm: PhantomData<Tperm>,
    perm: Edge<Tperm>,
    op_name: Option<String>,
    id_: usize,
}

impl<T, Tperm> Transpose<T, Tperm>
where T: TensorType,
      T: Clone,
      Tperm: TensorType,
      Tperm: Clone,
      T: 'static,
      Tperm: con_or_DT_INT32_or_DT_INT64,
      Tperm: 'static,
{
    pub fn y(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(x: Edge<T>, perm: Edge<Tperm>) -> Self {
        Self {
            phantom_T: PhantomData,
            x,
            phantom_Tperm: PhantomData,
            perm,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(x: Edge<T>, perm: Edge<Tperm>) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            x,
            phantom_Tperm: PhantomData,
            perm,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<T, Tidx> GraphOperation for Min<T, Tidx>
where T: TensorType,
      T: Clone,
      Tidx: TensorType,
      Tidx: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
      Tidx: con_or_DT_INT32_or_DT_INT64,
      Tidx: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("Min_{}")?
        };
        let mut new_op = graph.new_operation("Min", &op_name)?;
        {
            new_op.add_edge(&self.input)?
        }
        {
            new_op.add_edge(&self.reduction_indices)?
        }
        {
            match self.keep_dims {
                None => new_op.set_attr_value_proto("keep_dims", &vec![40_u8, 0_u8,])?,
                Some(ref value) => (|attr: &bool| {new_op.set_attr_bool("keep_dims", *attr)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct Min<T, Tidx>
where T: TensorType,
      T: Clone,
      Tidx: TensorType,
      Tidx: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
      Tidx: con_or_DT_INT32_or_DT_INT64,
      Tidx: 'static,
{
    phantom_T: PhantomData<T>,
    input: Edge<T>,
    phantom_Tidx: PhantomData<Tidx>,
    reduction_indices: Edge<Tidx>,
    keep_dims: Option<bool>,
    op_name: Option<String>,
    id_: usize,
}

impl<T, Tidx> Min<T, Tidx>
where T: TensorType,
      T: Clone,
      Tidx: TensorType,
      Tidx: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
      Tidx: con_or_DT_INT32_or_DT_INT64,
      Tidx: 'static,
{
    pub fn output(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn keep_dims(&mut self, keep_dims: bool) -> Self {
        self.keep_dims = Some(keep_dims);
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(input: Edge<T>, reduction_indices: Edge<Tidx>) -> Self {
        Self {
            phantom_T: PhantomData,
            input,
            phantom_Tidx: PhantomData,
            reduction_indices,
            keep_dims: None,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(input: Edge<T>, reduction_indices: Edge<Tidx>) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            input,
            phantom_Tidx: PhantomData,
            reduction_indices,
            keep_dims: None,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<T> GraphOperation for BesselI1e<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
      T: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("BesselI1e_{}")?
        };
        let mut new_op = graph.new_operation("BesselI1e", &op_name)?;
        {
            new_op.add_edge(&self.x)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct BesselI1e<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    x: Edge<T>,
    op_name: Option<String>,
    id_: usize,
}

impl<T> BesselI1e<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
      T: 'static,
{
    pub fn y(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(x: Edge<T>) -> Self {
        Self {
            phantom_T: PhantomData,
            x,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(x: Edge<T>) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            x,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<T> GraphOperation for _UnaryOpsComposition<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_HALF,
      T: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("_UnaryOpsComposition_{}")?
        };
        let mut new_op = graph.new_operation("_UnaryOpsComposition", &op_name)?;
        {
            new_op.add_edge(&self.x)?
        }
        {
            (|attrs| {new_op.set_attr_string_list("op_names", attrs)})(&self.op_names)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct _UnaryOpsComposition<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_HALF,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    x: Edge<T>,
    op_names: Vec<String>,
    op_name: Option<String>,
    id_: usize,
}

impl<T> _UnaryOpsComposition<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_HALF,
      T: 'static,
{
    pub fn y(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(x: Edge<T>, op_names: &[String]) -> Self {
        Self {
            phantom_T: PhantomData,
            x,
            op_names: op_names.to_vec(),
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(x: Edge<T>, op_names: &[String]) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            x,
            op_names: op_names.to_vec(),
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<T> GraphOperation for IsInf<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
      T: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("IsInf_{}")?
        };
        let mut new_op = graph.new_operation("IsInf", &op_name)?;
        {
            new_op.add_edge(&self.x)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct IsInf<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    x: Edge<T>,
    op_name: Option<String>,
    id_: usize,
}

impl<T> IsInf<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
      T: 'static,
{
    pub fn y(self) -> Edge<bool> {
        let rc = Rc::new(self);
        {
            Edge::<bool>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<bool> {
        let rc = Rc::new(self);
        {
            Edge::<bool>::new(rc.clone(), 0)
        }
    }

    pub fn build(x: Edge<T>) -> Self {
        Self {
            phantom_T: PhantomData,
            x,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(x: Edge<T>) -> Edge<bool> {
        Self {
            phantom_T: PhantomData,
            x,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<T> GraphOperation for Rint<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
      T: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("Rint_{}")?
        };
        let mut new_op = graph.new_operation("Rint", &op_name)?;
        {
            new_op.add_edge(&self.x)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct Rint<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    x: Edge<T>,
    op_name: Option<String>,
    id_: usize,
}

impl<T> Rint<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
      T: 'static,
{
    pub fn y(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(x: Edge<T>) -> Self {
        Self {
            phantom_T: PhantomData,
            x,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(x: Edge<T>) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            x,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<T> GraphOperation for Sub<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF,
      T: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("Sub_{}")?
        };
        let mut new_op = graph.new_operation("Sub", &op_name)?;
        {
            new_op.add_edge(&self.x)?
        }
        {
            new_op.add_edge(&self.y)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct Sub<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    x: Edge<T>,
    y: Edge<T>,
    op_name: Option<String>,
    id_: usize,
}

impl<T> Sub<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF,
      T: 'static,
{
    pub fn z(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(x: Edge<T>, y: Edge<T>) -> Self {
        Self {
            phantom_T: PhantomData,
            x,
            y,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(x: Edge<T>, y: Edge<T>) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            x,
            y,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<T> GraphOperation for _MklSub<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_COMPLEX64_or_DT_INT64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF,
      T: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("_MklSub_{}")?
        };
        let mut new_op = graph.new_operation("_MklSub", &op_name)?;
        {
            new_op.add_edge(&self.x)?
        }
        {
            new_op.add_edge(&self.y)?
        }
        {
            new_op.add_edge(&self.mkl_x)?
        }
        {
            new_op.add_edge(&self.mkl_y)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct _MklSub<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_COMPLEX64_or_DT_INT64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    x: Edge<T>,
    y: Edge<T>,
    mkl_x: Edge<u8>,
    mkl_y: Edge<u8>,
    op_name: Option<String>,
    id_: usize,
}

impl<T> _MklSub<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_COMPLEX64_or_DT_INT64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF,
      T: 'static,
{
    pub fn z(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn mkl_z(self) -> Edge<u8> {
        let rc = Rc::new(self);
        {
            Edge::<u8>::new(rc.clone(), 1)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> (Edge<T>, Edge<u8>) {
        let rc = Rc::new(self);
        (
        {
            Edge::<T>::new(rc.clone(), 0)
        },
        {
            Edge::<u8>::new(rc.clone(), 1)
        },
        )
    }

    pub fn build(x: Edge<T>, y: Edge<T>, mkl_x: Edge<u8>, mkl_y: Edge<u8>) -> Self {
        Self {
            phantom_T: PhantomData,
            x,
            y,
            mkl_x,
            mkl_y,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(x: Edge<T>, y: Edge<T>, mkl_x: Edge<u8>, mkl_y: Edge<u8>) -> (Edge<T>, Edge<u8>) {
        Self {
            phantom_T: PhantomData,
            x,
            y,
            mkl_x,
            mkl_y,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl GraphOperation for BoostedTreesCalculateBestGainsPerFeature {
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("BoostedTreesCalculateBestGainsPerFeature_{}")?
        };
        let mut new_op = graph.new_operation("BoostedTreesCalculateBestGainsPerFeature", &op_name)?;
        {
            new_op.add_edge(&self.node_id_range)?
        }
        {
            new_op.add_edge(&self.stats_summary_list)?
        }
        {
            new_op.add_edge(&self.l1)?
        }
        {
            new_op.add_edge(&self.l2)?
        }
        {
            new_op.add_edge(&self.tree_complexity)?
        }
        {
            new_op.add_edge(&self.min_node_weight)?
        }
        {
            (|attr: &i64| {new_op.set_attr_int("max_splits", *attr)})(&self.max_splits)?
        }
        {
            (|attr: &i64| {new_op.set_attr_int("num_features", *attr)})(&self.num_features)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct BoostedTreesCalculateBestGainsPerFeature {
    node_id_range: Edge<i32>,
    stats_summary_list: Edge<f32>,
    l1: Edge<f32>,
    l2: Edge<f32>,
    tree_complexity: Edge<f32>,
    min_node_weight: Edge<f32>,
    max_splits: i64,
    num_features: i64,
    op_name: Option<String>,
    id_: usize,
}

impl BoostedTreesCalculateBestGainsPerFeature {
    pub fn node_ids_list(self) -> Edge<i32> {
        let rc = Rc::new(self);
        {
            Edge::<i32>::new(rc.clone(), 0)
        }
    }

    pub fn gains_list(self) -> Edge<f32> {
        let rc = Rc::new(self);
        {
            Edge::<f32>::new(rc.clone(), 1)
        }
    }

    pub fn thresholds_list(self) -> Edge<i32> {
        let rc = Rc::new(self);
        {
            Edge::<i32>::new(rc.clone(), 2)
        }
    }

    pub fn left_node_contribs_list(self) -> Edge<f32> {
        let rc = Rc::new(self);
        {
            Edge::<f32>::new(rc.clone(), 3)
        }
    }

    pub fn right_node_contribs_list(self) -> Edge<f32> {
        let rc = Rc::new(self);
        {
            Edge::<f32>::new(rc.clone(), 4)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> (Edge<i32>, Edge<f32>, Edge<i32>, Edge<f32>, Edge<f32>) {
        let rc = Rc::new(self);
        (
        {
            Edge::<i32>::new(rc.clone(), 0)
        },
        {
            Edge::<f32>::new(rc.clone(), 1)
        },
        {
            Edge::<i32>::new(rc.clone(), 2)
        },
        {
            Edge::<f32>::new(rc.clone(), 3)
        },
        {
            Edge::<f32>::new(rc.clone(), 4)
        },
        )
    }

    pub fn build(node_id_range: Edge<i32>, stats_summary_list: Edge<f32>, l1: Edge<f32>, l2: Edge<f32>, tree_complexity: Edge<f32>, min_node_weight: Edge<f32>, max_splits: i64, num_features: i64) -> Self {
        Self {
            node_id_range,
            stats_summary_list,
            l1,
            l2,
            tree_complexity,
            min_node_weight,
            max_splits: max_splits,
            num_features: num_features,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(node_id_range: Edge<i32>, stats_summary_list: Edge<f32>, l1: Edge<f32>, l2: Edge<f32>, tree_complexity: Edge<f32>, min_node_weight: Edge<f32>, max_splits: i64, num_features: i64) -> (Edge<i32>, Edge<f32>, Edge<i32>, Edge<f32>, Edge<f32>) {
        Self {
            node_id_range,
            stats_summary_list,
            l1,
            l2,
            tree_complexity,
            min_node_weight,
            max_splits: max_splits,
            num_features: num_features,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<T> GraphOperation for EncodePng<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_UINT8_or_DT_UINT16,
      T: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("EncodePng_{}")?
        };
        let mut new_op = graph.new_operation("EncodePng", &op_name)?;
        {
            new_op.add_edge(&self.image)?
        }
        {
            match self.compression {
                None => new_op.set_attr_value_proto("compression", &vec![24_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 1_u8,])?,
                Some(ref value) => (|attr: &i64| {new_op.set_attr_int("compression", *attr)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct EncodePng<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_UINT8_or_DT_UINT16,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    image: Edge<T>,
    compression: Option<i64>,
    op_name: Option<String>,
    id_: usize,
}

impl<T> EncodePng<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_UINT8_or_DT_UINT16,
      T: 'static,
{
    pub fn contents(self) -> Edge<String> {
        let rc = Rc::new(self);
        {
            Edge::<String>::new(rc.clone(), 0)
        }
    }

    pub fn compression(&mut self, compression: i64) -> Self {
        self.compression = Some(compression);
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<String> {
        let rc = Rc::new(self);
        {
            Edge::<String>::new(rc.clone(), 0)
        }
    }

    pub fn build(image: Edge<T>) -> Self {
        Self {
            phantom_T: PhantomData,
            image,
            compression: None,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(image: Edge<T>) -> Edge<String> {
        Self {
            phantom_T: PhantomData,
            image,
            compression: None,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<T> GraphOperation for _MklMul<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF,
      T: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("_MklMul_{}")?
        };
        let mut new_op = graph.new_operation("_MklMul", &op_name)?;
        {
            new_op.add_edge(&self.x)?
        }
        {
            new_op.add_edge(&self.y)?
        }
        {
            new_op.add_edge(&self.mkl_x)?
        }
        {
            new_op.add_edge(&self.mkl_y)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct _MklMul<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    x: Edge<T>,
    y: Edge<T>,
    mkl_x: Edge<u8>,
    mkl_y: Edge<u8>,
    op_name: Option<String>,
    id_: usize,
}

impl<T> _MklMul<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF,
      T: 'static,
{
    pub fn z(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn mkl_z(self) -> Edge<u8> {
        let rc = Rc::new(self);
        {
            Edge::<u8>::new(rc.clone(), 1)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> (Edge<T>, Edge<u8>) {
        let rc = Rc::new(self);
        (
        {
            Edge::<T>::new(rc.clone(), 0)
        },
        {
            Edge::<u8>::new(rc.clone(), 1)
        },
        )
    }

    pub fn build(x: Edge<T>, y: Edge<T>, mkl_x: Edge<u8>, mkl_y: Edge<u8>) -> Self {
        Self {
            phantom_T: PhantomData,
            x,
            y,
            mkl_x,
            mkl_y,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(x: Edge<T>, y: Edge<T>, mkl_x: Edge<u8>, mkl_y: Edge<u8>) -> (Edge<T>, Edge<u8>) {
        Self {
            phantom_T: PhantomData,
            x,
            y,
            mkl_x,
            mkl_y,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<T> GraphOperation for Div<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF,
      T: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("Div_{}")?
        };
        let mut new_op = graph.new_operation("Div", &op_name)?;
        {
            new_op.add_edge(&self.x)?
        }
        {
            new_op.add_edge(&self.y)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct Div<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    x: Edge<T>,
    y: Edge<T>,
    op_name: Option<String>,
    id_: usize,
}

impl<T> Div<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF,
      T: 'static,
{
    pub fn z(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(x: Edge<T>, y: Edge<T>) -> Self {
        Self {
            phantom_T: PhantomData,
            x,
            y,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(x: Edge<T>, y: Edge<T>) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            x,
            y,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<dtype> GraphOperation for TensorArrayPack<dtype>
where dtype: TensorType,
      dtype: 'static,
      dtype: Clone,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("TensorArrayPack_{}")?
        };
        let mut new_op = graph.new_operation("TensorArrayPack", &op_name)?;
        {
            new_op.add_edge(&self.handle)?
        }
        {
            new_op.add_edge(&self.flow_in)?
        }
        {
            match self.element_shape {
                None => new_op.set_attr_value_proto("element_shape", &vec![58_u8, 0_u8,])?,
                Some(ref value) => (|attr| {new_op.set_attr_shape("element_shape", attr)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct TensorArrayPack<dtype>
where dtype: TensorType,
      dtype: 'static,
      dtype: Clone,
{
    handle: Edge<String>,
    flow_in: Edge<f32>,
    phantom_dtype: PhantomData<dtype>,
    element_shape: Option<OtherShape>,
    op_name: Option<String>,
    id_: usize,
}

impl<dtype> TensorArrayPack<dtype>
where dtype: TensorType,
      dtype: 'static,
      dtype: Clone,
{
    pub fn value(self) -> Edge<dtype> {
        let rc = Rc::new(self);
        {
            Edge::<dtype>::new(rc.clone(), 0)
        }
    }

    pub fn element_shape(&mut self, element_shape: &OtherShape) -> Self {
        self.element_shape = Some(element_shape.clone());
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<dtype> {
        let rc = Rc::new(self);
        {
            Edge::<dtype>::new(rc.clone(), 0)
        }
    }

    pub fn build(handle: Edge<String>, flow_in: Edge<f32>) -> Self {
        Self {
            handle,
            flow_in,
            phantom_dtype: PhantomData,
            element_shape: None,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(handle: Edge<String>, flow_in: Edge<f32>) -> Edge<dtype> {
        Self {
            handle,
            flow_in,
            phantom_dtype: PhantomData,
            element_shape: None,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<T> GraphOperation for Maximum<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_INT64_or_DT_BFLOAT16_or_DT_HALF,
      T: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("Maximum_{}")?
        };
        let mut new_op = graph.new_operation("Maximum", &op_name)?;
        {
            new_op.add_edge(&self.x)?
        }
        {
            new_op.add_edge(&self.y)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct Maximum<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_INT64_or_DT_BFLOAT16_or_DT_HALF,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    x: Edge<T>,
    y: Edge<T>,
    op_name: Option<String>,
    id_: usize,
}

impl<T> Maximum<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_INT64_or_DT_BFLOAT16_or_DT_HALF,
      T: 'static,
{
    pub fn z(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(x: Edge<T>, y: Edge<T>) -> Self {
        Self {
            phantom_T: PhantomData,
            x,
            y,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(x: Edge<T>, y: Edge<T>) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            x,
            y,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl GraphOperation for WriteFile {
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("WriteFile_{}")?
        };
        let mut new_op = graph.new_operation("WriteFile", &op_name)?;
        {
            new_op.add_edge(&self.filename)?
        }
        {
            new_op.add_edge(&self.contents)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct WriteFile {
    filename: Edge<String>,
    contents: Edge<String>,
    op_name: Option<String>,
    id_: usize,
}

impl WriteFile {
    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> () {
        let rc = Rc::new(self);
        (
        )
    }

    pub fn build(filename: Edge<String>, contents: Edge<String>) -> Self {
        Self {
            filename,
            contents,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(filename: Edge<String>, contents: Edge<String>) -> () {
        Self {
            filename,
            contents,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<T> GraphOperation for _MklMaximum<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_INT64_or_DT_HALF,
      T: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("_MklMaximum_{}")?
        };
        let mut new_op = graph.new_operation("_MklMaximum", &op_name)?;
        {
            new_op.add_edge(&self.x)?
        }
        {
            new_op.add_edge(&self.y)?
        }
        {
            new_op.add_edge(&self.mkl_x)?
        }
        {
            new_op.add_edge(&self.mkl_y)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct _MklMaximum<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_INT64_or_DT_HALF,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    x: Edge<T>,
    y: Edge<T>,
    mkl_x: Edge<u8>,
    mkl_y: Edge<u8>,
    op_name: Option<String>,
    id_: usize,
}

impl<T> _MklMaximum<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_INT64_or_DT_HALF,
      T: 'static,
{
    pub fn z(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn mkl_z(self) -> Edge<u8> {
        let rc = Rc::new(self);
        {
            Edge::<u8>::new(rc.clone(), 1)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> (Edge<T>, Edge<u8>) {
        let rc = Rc::new(self);
        (
        {
            Edge::<T>::new(rc.clone(), 0)
        },
        {
            Edge::<u8>::new(rc.clone(), 1)
        },
        )
    }

    pub fn build(x: Edge<T>, y: Edge<T>, mkl_x: Edge<u8>, mkl_y: Edge<u8>) -> Self {
        Self {
            phantom_T: PhantomData,
            x,
            y,
            mkl_x,
            mkl_y,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(x: Edge<T>, y: Edge<T>, mkl_x: Edge<u8>, mkl_y: Edge<u8>) -> (Edge<T>, Edge<u8>) {
        Self {
            phantom_T: PhantomData,
            x,
            y,
            mkl_x,
            mkl_y,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<dtype> GraphOperation for SparseAccumulatorTakeGradient<dtype>
where dtype: TensorType,
      dtype: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      dtype: 'static,
      dtype: Clone,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("SparseAccumulatorTakeGradient_{}")?
        };
        let mut new_op = graph.new_operation("SparseAccumulatorTakeGradient", &op_name)?;
        {
            new_op.add_edge(&self.handle)?
        }
        {
            new_op.add_edge(&self.num_required)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct SparseAccumulatorTakeGradient<dtype>
where dtype: TensorType,
      dtype: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      dtype: 'static,
      dtype: Clone,
{
    handle: Edge<String>,
    num_required: Edge<i32>,
    phantom_dtype: PhantomData<dtype>,
    op_name: Option<String>,
    id_: usize,
}

impl<dtype> SparseAccumulatorTakeGradient<dtype>
where dtype: TensorType,
      dtype: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      dtype: 'static,
      dtype: Clone,
{
    pub fn indices(self) -> Edge<i64> {
        let rc = Rc::new(self);
        {
            Edge::<i64>::new(rc.clone(), 0)
        }
    }

    pub fn values(self) -> Edge<dtype> {
        let rc = Rc::new(self);
        {
            Edge::<dtype>::new(rc.clone(), 1)
        }
    }

    pub fn shape(self) -> Edge<i64> {
        let rc = Rc::new(self);
        {
            Edge::<i64>::new(rc.clone(), 2)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> (Edge<i64>, Edge<dtype>, Edge<i64>) {
        let rc = Rc::new(self);
        (
        {
            Edge::<i64>::new(rc.clone(), 0)
        },
        {
            Edge::<dtype>::new(rc.clone(), 1)
        },
        {
            Edge::<i64>::new(rc.clone(), 2)
        },
        )
    }

    pub fn build(handle: Edge<String>, num_required: Edge<i32>) -> Self {
        Self {
            handle,
            num_required,
            phantom_dtype: PhantomData,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(handle: Edge<String>, num_required: Edge<i32>) -> (Edge<i64>, Edge<dtype>, Edge<i64>) {
        Self {
            handle,
            num_required,
            phantom_dtype: PhantomData,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<T> GraphOperation for FloorMod<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_INT64_or_DT_BFLOAT16_or_DT_HALF,
      T: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("FloorMod_{}")?
        };
        let mut new_op = graph.new_operation("FloorMod", &op_name)?;
        {
            new_op.add_edge(&self.x)?
        }
        {
            new_op.add_edge(&self.y)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct FloorMod<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_INT64_or_DT_BFLOAT16_or_DT_HALF,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    x: Edge<T>,
    y: Edge<T>,
    op_name: Option<String>,
    id_: usize,
}

impl<T> FloorMod<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_INT64_or_DT_BFLOAT16_or_DT_HALF,
      T: 'static,
{
    pub fn z(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(x: Edge<T>, y: Edge<T>) -> Self {
        Self {
            phantom_T: PhantomData,
            x,
            y,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(x: Edge<T>, y: Edge<T>) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            x,
            y,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<T> GraphOperation for TruncateMod<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_INT64_or_DT_BFLOAT16_or_DT_HALF,
      T: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("TruncateMod_{}")?
        };
        let mut new_op = graph.new_operation("TruncateMod", &op_name)?;
        {
            new_op.add_edge(&self.x)?
        }
        {
            new_op.add_edge(&self.y)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct TruncateMod<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_INT64_or_DT_BFLOAT16_or_DT_HALF,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    x: Edge<T>,
    y: Edge<T>,
    op_name: Option<String>,
    id_: usize,
}

impl<T> TruncateMod<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_INT64_or_DT_BFLOAT16_or_DT_HALF,
      T: 'static,
{
    pub fn z(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(x: Edge<T>, y: Edge<T>) -> Self {
        Self {
            phantom_T: PhantomData,
            x,
            y,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(x: Edge<T>, y: Edge<T>) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            x,
            y,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl GraphOperation for LoadTPUEmbeddingRMSPropParametersGradAccumDebug {
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("LoadTPUEmbeddingRMSPropParametersGradAccumDebug_{}")?
        };
        let mut new_op = graph.new_operation("LoadTPUEmbeddingRMSPropParametersGradAccumDebug", &op_name)?;
        {
            new_op.add_edge(&self.parameters)?
        }
        {
            new_op.add_edge(&self.ms)?
        }
        {
            new_op.add_edge(&self.mom)?
        }
        {
            new_op.add_edge(&self.gradient_accumulators)?
        }
        {
            match self.table_id {
                None => new_op.set_attr_value_proto("table_id", &vec![24_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 1_u8,])?,
                Some(ref value) => (|attr: &i64| {new_op.set_attr_int("table_id", *attr)})(&value)?,
            };
        }
        {
            match self.table_name {
                None => new_op.set_attr_value_proto("table_name", &vec![18_u8, 0_u8,])?,
                Some(ref value) => (|attr| {new_op.set_attr_string("table_name", attr)})(&value)?,
            };
        }
        {
            (|attr: &i64| {new_op.set_attr_int("num_shards", *attr)})(&self.num_shards)?
        }
        {
            (|attr: &i64| {new_op.set_attr_int("shard_id", *attr)})(&self.shard_id)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct LoadTPUEmbeddingRMSPropParametersGradAccumDebug {
    parameters: Edge<f32>,
    ms: Edge<f32>,
    mom: Edge<f32>,
    gradient_accumulators: Edge<f32>,
    table_id: Option<i64>,
    table_name: Option<String>,
    num_shards: i64,
    shard_id: i64,
    op_name: Option<String>,
    id_: usize,
}

impl LoadTPUEmbeddingRMSPropParametersGradAccumDebug {
    pub fn table_id(&mut self, table_id: i64) -> Self {
        self.table_id = Some(table_id);
        self.clone()
    }

    pub fn table_name(&mut self, table_name: &str) -> Self {
        self.table_name = Some(table_name.to_string());
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> () {
        let rc = Rc::new(self);
        (
        )
    }

    pub fn build(parameters: Edge<f32>, ms: Edge<f32>, mom: Edge<f32>, gradient_accumulators: Edge<f32>, num_shards: i64, shard_id: i64) -> Self {
        Self {
            parameters,
            ms,
            mom,
            gradient_accumulators,
            table_id: None,
            table_name: None,
            num_shards: num_shards,
            shard_id: shard_id,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(parameters: Edge<f32>, ms: Edge<f32>, mom: Edge<f32>, gradient_accumulators: Edge<f32>, num_shards: i64, shard_id: i64) -> () {
        Self {
            parameters,
            ms,
            mom,
            gradient_accumulators,
            table_id: None,
            table_name: None,
            num_shards: num_shards,
            shard_id: shard_id,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl GraphOperation for ConcatOffset {
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("ConcatOffset_{}")?
        };
        let mut new_op = graph.new_operation("ConcatOffset", &op_name)?;
        {
            new_op.add_edge(&self.concat_dim)?
        }
        {
            new_op.add_edge(&self.shape)?
        }
        {
            (|attr: &i64| {new_op.set_attr_int("N", *attr)})(&self.N)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct ConcatOffset {
    concat_dim: Edge<i32>,
    shape: Edge<i32>,
    N: i64,
    op_name: Option<String>,
    id_: usize,
}

impl ConcatOffset {
    pub fn offset(self) -> Edge<i32> {
        let rc = Rc::new(self);
        {
            Edge::<i32>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<i32> {
        let rc = Rc::new(self);
        {
            Edge::<i32>::new(rc.clone(), 0)
        }
    }

    pub fn build(concat_dim: Edge<i32>, shape: Edge<i32>, N: i64) -> Self {
        Self {
            concat_dim,
            shape,
            N: N,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(concat_dim: Edge<i32>, shape: Edge<i32>, N: i64) -> Edge<i32> {
        Self {
            concat_dim,
            shape,
            N: N,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<T> GraphOperation for Igamma<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE,
      T: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("Igamma_{}")?
        };
        let mut new_op = graph.new_operation("Igamma", &op_name)?;
        {
            new_op.add_edge(&self.a)?
        }
        {
            new_op.add_edge(&self.x)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct Igamma<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    a: Edge<T>,
    x: Edge<T>,
    op_name: Option<String>,
    id_: usize,
}

impl<T> Igamma<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE,
      T: 'static,
{
    pub fn z(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(a: Edge<T>, x: Edge<T>) -> Self {
        Self {
            phantom_T: PhantomData,
            a,
            x,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(a: Edge<T>, x: Edge<T>) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            a,
            x,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<T> GraphOperation for Polygamma<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE,
      T: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("Polygamma_{}")?
        };
        let mut new_op = graph.new_operation("Polygamma", &op_name)?;
        {
            new_op.add_edge(&self.a)?
        }
        {
            new_op.add_edge(&self.x)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct Polygamma<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    a: Edge<T>,
    x: Edge<T>,
    op_name: Option<String>,
    id_: usize,
}

impl<T> Polygamma<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE,
      T: 'static,
{
    pub fn z(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(a: Edge<T>, x: Edge<T>) -> Self {
        Self {
            phantom_T: PhantomData,
            a,
            x,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(a: Edge<T>, x: Edge<T>) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            a,
            x,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<T> GraphOperation for Identity<T>
where T: TensorType,
      T: Clone,
      T: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("Identity_{}")?
        };
        let mut new_op = graph.new_operation("Identity", &op_name)?;
        {
            new_op.add_edge(&self.input)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct Identity<T>
where T: TensorType,
      T: Clone,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    input: Edge<T>,
    op_name: Option<String>,
    id_: usize,
}

impl<T> Identity<T>
where T: TensorType,
      T: Clone,
      T: 'static,
{
    pub fn output(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(input: Edge<T>) -> Self {
        Self {
            phantom_T: PhantomData,
            input,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(input: Edge<T>) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            input,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<T> GraphOperation for Atan2<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
      T: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("Atan2_{}")?
        };
        let mut new_op = graph.new_operation("Atan2", &op_name)?;
        {
            new_op.add_edge(&self.y)?
        }
        {
            new_op.add_edge(&self.x)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct Atan2<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    y: Edge<T>,
    x: Edge<T>,
    op_name: Option<String>,
    id_: usize,
}

impl<T> Atan2<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
      T: 'static,
{
    pub fn z(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(y: Edge<T>, x: Edge<T>) -> Self {
        Self {
            phantom_T: PhantomData,
            y,
            x,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(y: Edge<T>, x: Edge<T>) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            y,
            x,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl GraphOperation for EnqueueTPUEmbeddingIntegerBatch {
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("EnqueueTPUEmbeddingIntegerBatch_{}")?
        };
        let mut new_op = graph.new_operation("EnqueueTPUEmbeddingIntegerBatch", &op_name)?;
        {
            new_op.add_edge(&self.batch)?
        }
        {
            new_op.add_edge(&self.mode_override)?
        }
        {
            (|attr: &i64| {new_op.set_attr_int("N", *attr)})(&self.N)?
        }
        {
            match self.device_ordinal {
                None => new_op.set_attr_value_proto("device_ordinal", &vec![24_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 1_u8,])?,
                Some(ref value) => (|attr: &i64| {new_op.set_attr_int("device_ordinal", *attr)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct EnqueueTPUEmbeddingIntegerBatch {
    batch: Edge<i32>,
    mode_override: Edge<String>,
    N: i64,
    device_ordinal: Option<i64>,
    op_name: Option<String>,
    id_: usize,
}

impl EnqueueTPUEmbeddingIntegerBatch {
    pub fn device_ordinal(&mut self, device_ordinal: i64) -> Self {
        self.device_ordinal = Some(device_ordinal);
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> () {
        let rc = Rc::new(self);
        (
        )
    }

    pub fn build(batch: Edge<i32>, mode_override: Edge<String>, N: i64) -> Self {
        Self {
            batch,
            mode_override,
            N: N,
            device_ordinal: None,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(batch: Edge<i32>, mode_override: Edge<String>, N: i64) -> () {
        Self {
            batch,
            mode_override,
            N: N,
            device_ordinal: None,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<T> GraphOperation for LessEqual<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("LessEqual_{}")?
        };
        let mut new_op = graph.new_operation("LessEqual", &op_name)?;
        {
            new_op.add_edge(&self.x)?
        }
        {
            new_op.add_edge(&self.y)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct LessEqual<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    x: Edge<T>,
    y: Edge<T>,
    op_name: Option<String>,
    id_: usize,
}

impl<T> LessEqual<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
{
    pub fn z(self) -> Edge<bool> {
        let rc = Rc::new(self);
        {
            Edge::<bool>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<bool> {
        let rc = Rc::new(self);
        {
            Edge::<bool>::new(rc.clone(), 0)
        }
    }

    pub fn build(x: Edge<T>, y: Edge<T>) -> Self {
        Self {
            phantom_T: PhantomData,
            x,
            y,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(x: Edge<T>, y: Edge<T>) -> Edge<bool> {
        Self {
            phantom_T: PhantomData,
            x,
            y,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<T> GraphOperation for GreaterEqual<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("GreaterEqual_{}")?
        };
        let mut new_op = graph.new_operation("GreaterEqual", &op_name)?;
        {
            new_op.add_edge(&self.x)?
        }
        {
            new_op.add_edge(&self.y)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct GreaterEqual<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    x: Edge<T>,
    y: Edge<T>,
    op_name: Option<String>,
    id_: usize,
}

impl<T> GreaterEqual<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
{
    pub fn z(self) -> Edge<bool> {
        let rc = Rc::new(self);
        {
            Edge::<bool>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<bool> {
        let rc = Rc::new(self);
        {
            Edge::<bool>::new(rc.clone(), 0)
        }
    }

    pub fn build(x: Edge<T>, y: Edge<T>) -> Self {
        Self {
            phantom_T: PhantomData,
            x,
            y,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(x: Edge<T>, y: Edge<T>) -> Edge<bool> {
        Self {
            phantom_T: PhantomData,
            x,
            y,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<dtype> GraphOperation for TensorArrayGatherV2<dtype>
where dtype: TensorType,
      dtype: 'static,
      dtype: Clone,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("TensorArrayGatherV2_{}")?
        };
        let mut new_op = graph.new_operation("TensorArrayGatherV2", &op_name)?;
        {
            new_op.add_edge(&self.handle)?
        }
        {
            new_op.add_edge(&self.indices)?
        }
        {
            new_op.add_edge(&self.flow_in)?
        }
        {
            match self.element_shape {
                None => new_op.set_attr_value_proto("element_shape", &vec![58_u8, 0_u8,])?,
                Some(ref value) => (|attr| {new_op.set_attr_shape("element_shape", attr)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct TensorArrayGatherV2<dtype>
where dtype: TensorType,
      dtype: 'static,
      dtype: Clone,
{
    handle: Edge<String>,
    indices: Edge<i32>,
    flow_in: Edge<f32>,
    phantom_dtype: PhantomData<dtype>,
    element_shape: Option<OtherShape>,
    op_name: Option<String>,
    id_: usize,
}

impl<dtype> TensorArrayGatherV2<dtype>
where dtype: TensorType,
      dtype: 'static,
      dtype: Clone,
{
    pub fn value(self) -> Edge<dtype> {
        let rc = Rc::new(self);
        {
            Edge::<dtype>::new(rc.clone(), 0)
        }
    }

    pub fn element_shape(&mut self, element_shape: &OtherShape) -> Self {
        self.element_shape = Some(element_shape.clone());
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<dtype> {
        let rc = Rc::new(self);
        {
            Edge::<dtype>::new(rc.clone(), 0)
        }
    }

    pub fn build(handle: Edge<String>, indices: Edge<i32>, flow_in: Edge<f32>) -> Self {
        Self {
            handle,
            indices,
            flow_in,
            phantom_dtype: PhantomData,
            element_shape: None,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(handle: Edge<String>, indices: Edge<i32>, flow_in: Edge<f32>) -> Edge<dtype> {
        Self {
            handle,
            indices,
            flow_in,
            phantom_dtype: PhantomData,
            element_shape: None,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

pub trait con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_STRING_or_DT_COMPLEX64_or_DT_INT64_or_DT_BOOL_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_STRING_or_DT_COMPLEX64_or_DT_INT64_or_DT_BOOL_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF for BFloat16 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_STRING_or_DT_COMPLEX64_or_DT_INT64_or_DT_BOOL_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF for OtherComplex<f32> {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_STRING_or_DT_COMPLEX64_or_DT_INT64_or_DT_BOOL_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF for OtherComplex<f64> {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_STRING_or_DT_COMPLEX64_or_DT_INT64_or_DT_BOOL_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF for String {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_STRING_or_DT_COMPLEX64_or_DT_INT64_or_DT_BOOL_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF for bool {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_STRING_or_DT_COMPLEX64_or_DT_INT64_or_DT_BOOL_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF for f32 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_STRING_or_DT_COMPLEX64_or_DT_INT64_or_DT_BOOL_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF for f64 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_STRING_or_DT_COMPLEX64_or_DT_INT64_or_DT_BOOL_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF for i16 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_STRING_or_DT_COMPLEX64_or_DT_INT64_or_DT_BOOL_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF for i32 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_STRING_or_DT_COMPLEX64_or_DT_INT64_or_DT_BOOL_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF for i64 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_STRING_or_DT_COMPLEX64_or_DT_INT64_or_DT_BOOL_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF for i8 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_STRING_or_DT_COMPLEX64_or_DT_INT64_or_DT_BOOL_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF for u8 {
}

impl<T> GraphOperation for Equal<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_STRING_or_DT_COMPLEX64_or_DT_INT64_or_DT_BOOL_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF,
      T: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("Equal_{}")?
        };
        let mut new_op = graph.new_operation("Equal", &op_name)?;
        {
            new_op.add_edge(&self.x)?
        }
        {
            new_op.add_edge(&self.y)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct Equal<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_STRING_or_DT_COMPLEX64_or_DT_INT64_or_DT_BOOL_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    x: Edge<T>,
    y: Edge<T>,
    op_name: Option<String>,
    id_: usize,
}

impl<T> Equal<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_STRING_or_DT_COMPLEX64_or_DT_INT64_or_DT_BOOL_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF,
      T: 'static,
{
    pub fn z(self) -> Edge<bool> {
        let rc = Rc::new(self);
        {
            Edge::<bool>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<bool> {
        let rc = Rc::new(self);
        {
            Edge::<bool>::new(rc.clone(), 0)
        }
    }

    pub fn build(x: Edge<T>, y: Edge<T>) -> Self {
        Self {
            phantom_T: PhantomData,
            x,
            y,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(x: Edge<T>, y: Edge<T>) -> Edge<bool> {
        Self {
            phantom_T: PhantomData,
            x,
            y,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<T> GraphOperation for NotEqual<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_STRING_or_DT_COMPLEX64_or_DT_INT64_or_DT_BOOL_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF,
      T: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("NotEqual_{}")?
        };
        let mut new_op = graph.new_operation("NotEqual", &op_name)?;
        {
            new_op.add_edge(&self.x)?
        }
        {
            new_op.add_edge(&self.y)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct NotEqual<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_STRING_or_DT_COMPLEX64_or_DT_INT64_or_DT_BOOL_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    x: Edge<T>,
    y: Edge<T>,
    op_name: Option<String>,
    id_: usize,
}

impl<T> NotEqual<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_STRING_or_DT_COMPLEX64_or_DT_INT64_or_DT_BOOL_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF,
      T: 'static,
{
    pub fn z(self) -> Edge<bool> {
        let rc = Rc::new(self);
        {
            Edge::<bool>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<bool> {
        let rc = Rc::new(self);
        {
            Edge::<bool>::new(rc.clone(), 0)
        }
    }

    pub fn build(x: Edge<T>, y: Edge<T>) -> Self {
        Self {
            phantom_T: PhantomData,
            x,
            y,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(x: Edge<T>, y: Edge<T>) -> Edge<bool> {
        Self {
            phantom_T: PhantomData,
            x,
            y,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<T> GraphOperation for ApproximateEqual<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("ApproximateEqual_{}")?
        };
        let mut new_op = graph.new_operation("ApproximateEqual", &op_name)?;
        {
            new_op.add_edge(&self.x)?
        }
        {
            new_op.add_edge(&self.y)?
        }
        {
            match self.tolerance {
                None => new_op.set_attr_value_proto("tolerance", &vec![37_u8, 172_u8, 197_u8, 39_u8, 55_u8,])?,
                Some(ref value) => (|attr: &f32| {new_op.set_attr_float("tolerance", *attr)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct ApproximateEqual<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    x: Edge<T>,
    y: Edge<T>,
    tolerance: Option<f32>,
    op_name: Option<String>,
    id_: usize,
}

impl<T> ApproximateEqual<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
{
    pub fn z(self) -> Edge<bool> {
        let rc = Rc::new(self);
        {
            Edge::<bool>::new(rc.clone(), 0)
        }
    }

    pub fn tolerance(&mut self, tolerance: f32) -> Self {
        self.tolerance = Some(tolerance);
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<bool> {
        let rc = Rc::new(self);
        {
            Edge::<bool>::new(rc.clone(), 0)
        }
    }

    pub fn build(x: Edge<T>, y: Edge<T>) -> Self {
        Self {
            phantom_T: PhantomData,
            x,
            y,
            tolerance: None,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(x: Edge<T>, y: Edge<T>) -> Edge<bool> {
        Self {
            phantom_T: PhantomData,
            x,
            y,
            tolerance: None,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<T> GraphOperation for MatMul<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_COMPLEX64_or_DT_INT64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF,
      T: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("MatMul_{}")?
        };
        let mut new_op = graph.new_operation("MatMul", &op_name)?;
        {
            new_op.add_edge(&self.a)?
        }
        {
            new_op.add_edge(&self.b)?
        }
        {
            match self.transpose_a {
                None => new_op.set_attr_value_proto("transpose_a", &vec![40_u8, 0_u8,])?,
                Some(ref value) => (|attr: &bool| {new_op.set_attr_bool("transpose_a", *attr)})(&value)?,
            };
        }
        {
            match self.transpose_b {
                None => new_op.set_attr_value_proto("transpose_b", &vec![40_u8, 0_u8,])?,
                Some(ref value) => (|attr: &bool| {new_op.set_attr_bool("transpose_b", *attr)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct MatMul<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_COMPLEX64_or_DT_INT64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    a: Edge<T>,
    b: Edge<T>,
    transpose_a: Option<bool>,
    transpose_b: Option<bool>,
    op_name: Option<String>,
    id_: usize,
}

impl<T> MatMul<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_COMPLEX64_or_DT_INT64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF,
      T: 'static,
{
    pub fn product(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn transpose_a(&mut self, transpose_a: bool) -> Self {
        self.transpose_a = Some(transpose_a);
        self.clone()
    }

    pub fn transpose_b(&mut self, transpose_b: bool) -> Self {
        self.transpose_b = Some(transpose_b);
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(a: Edge<T>, b: Edge<T>) -> Self {
        Self {
            phantom_T: PhantomData,
            a,
            b,
            transpose_a: None,
            transpose_b: None,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(a: Edge<T>, b: Edge<T>) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            a,
            b,
            transpose_a: None,
            transpose_b: None,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<T, Tidx> GraphOperation for Mean<T, Tidx>
where T: TensorType,
      T: Clone,
      Tidx: TensorType,
      Tidx: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
      Tidx: con_or_DT_INT32_or_DT_INT64,
      Tidx: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("Mean_{}")?
        };
        let mut new_op = graph.new_operation("Mean", &op_name)?;
        {
            new_op.add_edge(&self.input)?
        }
        {
            new_op.add_edge(&self.reduction_indices)?
        }
        {
            match self.keep_dims {
                None => new_op.set_attr_value_proto("keep_dims", &vec![40_u8, 0_u8,])?,
                Some(ref value) => (|attr: &bool| {new_op.set_attr_bool("keep_dims", *attr)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct Mean<T, Tidx>
where T: TensorType,
      T: Clone,
      Tidx: TensorType,
      Tidx: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
      Tidx: con_or_DT_INT32_or_DT_INT64,
      Tidx: 'static,
{
    phantom_T: PhantomData<T>,
    input: Edge<T>,
    phantom_Tidx: PhantomData<Tidx>,
    reduction_indices: Edge<Tidx>,
    keep_dims: Option<bool>,
    op_name: Option<String>,
    id_: usize,
}

impl<T, Tidx> Mean<T, Tidx>
where T: TensorType,
      T: Clone,
      Tidx: TensorType,
      Tidx: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
      Tidx: con_or_DT_INT32_or_DT_INT64,
      Tidx: 'static,
{
    pub fn output(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn keep_dims(&mut self, keep_dims: bool) -> Self {
        self.keep_dims = Some(keep_dims);
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(input: Edge<T>, reduction_indices: Edge<Tidx>) -> Self {
        Self {
            phantom_T: PhantomData,
            input,
            phantom_Tidx: PhantomData,
            reduction_indices,
            keep_dims: None,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(input: Edge<T>, reduction_indices: Edge<Tidx>) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            input,
            phantom_Tidx: PhantomData,
            reduction_indices,
            keep_dims: None,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<T, Tidx, output_type> GraphOperation for ArgMin<T, Tidx, output_type>
where T: TensorType,
      T: Clone,
      Tidx: TensorType,
      Tidx: Clone,
      output_type: TensorType,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
      Tidx: con_or_DT_INT32_or_DT_INT64,
      Tidx: 'static,
      output_type: con_or_DT_INT32_or_DT_INT64,
      output_type: 'static,
      output_type: Clone,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("ArgMin_{}")?
        };
        let mut new_op = graph.new_operation("ArgMin", &op_name)?;
        {
            new_op.add_edge(&self.input)?
        }
        {
            new_op.add_edge(&self.dimension)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct ArgMin<T, Tidx, output_type>
where T: TensorType,
      T: Clone,
      Tidx: TensorType,
      Tidx: Clone,
      output_type: TensorType,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
      Tidx: con_or_DT_INT32_or_DT_INT64,
      Tidx: 'static,
      output_type: con_or_DT_INT32_or_DT_INT64,
      output_type: 'static,
      output_type: Clone,
{
    phantom_T: PhantomData<T>,
    input: Edge<T>,
    phantom_Tidx: PhantomData<Tidx>,
    dimension: Edge<Tidx>,
    phantom_output_type: PhantomData<output_type>,
    op_name: Option<String>,
    id_: usize,
}

impl<T, Tidx, output_type> ArgMin<T, Tidx, output_type>
where T: TensorType,
      T: Clone,
      Tidx: TensorType,
      Tidx: Clone,
      output_type: TensorType,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
      Tidx: con_or_DT_INT32_or_DT_INT64,
      Tidx: 'static,
      output_type: con_or_DT_INT32_or_DT_INT64,
      output_type: 'static,
      output_type: Clone,
{
    pub fn output(self) -> Edge<output_type> {
        let rc = Rc::new(self);
        {
            Edge::<output_type>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<output_type> {
        let rc = Rc::new(self);
        {
            Edge::<output_type>::new(rc.clone(), 0)
        }
    }

    pub fn build(input: Edge<T>, dimension: Edge<Tidx>) -> Self {
        Self {
            phantom_T: PhantomData,
            input,
            phantom_Tidx: PhantomData,
            dimension,
            phantom_output_type: PhantomData,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(input: Edge<T>, dimension: Edge<Tidx>) -> Edge<output_type> {
        Self {
            phantom_T: PhantomData,
            input,
            phantom_Tidx: PhantomData,
            dimension,
            phantom_output_type: PhantomData,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<Tinput, out_type> GraphOperation for Requantize<Tinput, out_type>
where Tinput: TensorType,
      Tinput: Clone,
      out_type: TensorType,
      Tinput: con_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_QINT16_or_DT_QUINT16,
      Tinput: 'static,
      out_type: con_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_QINT16_or_DT_QUINT16,
      out_type: 'static,
      out_type: Clone,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("Requantize_{}")?
        };
        let mut new_op = graph.new_operation("Requantize", &op_name)?;
        {
            new_op.add_edge(&self.input)?
        }
        {
            new_op.add_edge(&self.input_min)?
        }
        {
            new_op.add_edge(&self.input_max)?
        }
        {
            new_op.add_edge(&self.requested_output_min)?
        }
        {
            new_op.add_edge(&self.requested_output_max)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct Requantize<Tinput, out_type>
where Tinput: TensorType,
      Tinput: Clone,
      out_type: TensorType,
      Tinput: con_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_QINT16_or_DT_QUINT16,
      Tinput: 'static,
      out_type: con_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_QINT16_or_DT_QUINT16,
      out_type: 'static,
      out_type: Clone,
{
    phantom_Tinput: PhantomData<Tinput>,
    input: Edge<Tinput>,
    input_min: Edge<f32>,
    input_max: Edge<f32>,
    requested_output_min: Edge<f32>,
    requested_output_max: Edge<f32>,
    phantom_out_type: PhantomData<out_type>,
    op_name: Option<String>,
    id_: usize,
}

impl<Tinput, out_type> Requantize<Tinput, out_type>
where Tinput: TensorType,
      Tinput: Clone,
      out_type: TensorType,
      Tinput: con_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_QINT16_or_DT_QUINT16,
      Tinput: 'static,
      out_type: con_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_QINT16_or_DT_QUINT16,
      out_type: 'static,
      out_type: Clone,
{
    pub fn output(self) -> Edge<out_type> {
        let rc = Rc::new(self);
        {
            Edge::<out_type>::new(rc.clone(), 0)
        }
    }

    pub fn output_min(self) -> Edge<f32> {
        let rc = Rc::new(self);
        {
            Edge::<f32>::new(rc.clone(), 1)
        }
    }

    pub fn output_max(self) -> Edge<f32> {
        let rc = Rc::new(self);
        {
            Edge::<f32>::new(rc.clone(), 2)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> (Edge<out_type>, Edge<f32>, Edge<f32>) {
        let rc = Rc::new(self);
        (
        {
            Edge::<out_type>::new(rc.clone(), 0)
        },
        {
            Edge::<f32>::new(rc.clone(), 1)
        },
        {
            Edge::<f32>::new(rc.clone(), 2)
        },
        )
    }

    pub fn build(input: Edge<Tinput>, input_min: Edge<f32>, input_max: Edge<f32>, requested_output_min: Edge<f32>, requested_output_max: Edge<f32>) -> Self {
        Self {
            phantom_Tinput: PhantomData,
            input,
            input_min,
            input_max,
            requested_output_min,
            requested_output_max,
            phantom_out_type: PhantomData,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(input: Edge<Tinput>, input_min: Edge<f32>, input_max: Edge<f32>, requested_output_min: Edge<f32>, requested_output_max: Edge<f32>) -> (Edge<out_type>, Edge<f32>, Edge<f32>) {
        Self {
            phantom_Tinput: PhantomData,
            input,
            input_min,
            input_max,
            requested_output_min,
            requested_output_max,
            phantom_out_type: PhantomData,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<T, Tindices, Tnumsegments> GraphOperation for UnsortedSegmentSum<T, Tindices, Tnumsegments>
where T: TensorType,
      T: Clone,
      Tindices: TensorType,
      Tindices: Clone,
      Tnumsegments: TensorType,
      Tnumsegments: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
      Tindices: con_or_DT_INT32_or_DT_INT64,
      Tindices: 'static,
      Tnumsegments: con_or_DT_INT32_or_DT_INT64,
      Tnumsegments: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("UnsortedSegmentSum_{}")?
        };
        let mut new_op = graph.new_operation("UnsortedSegmentSum", &op_name)?;
        {
            new_op.add_edge(&self.data)?
        }
        {
            new_op.add_edge(&self.segment_ids)?
        }
        {
            new_op.add_edge(&self.num_segments)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct UnsortedSegmentSum<T, Tindices, Tnumsegments>
where T: TensorType,
      T: Clone,
      Tindices: TensorType,
      Tindices: Clone,
      Tnumsegments: TensorType,
      Tnumsegments: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
      Tindices: con_or_DT_INT32_or_DT_INT64,
      Tindices: 'static,
      Tnumsegments: con_or_DT_INT32_or_DT_INT64,
      Tnumsegments: 'static,
{
    phantom_T: PhantomData<T>,
    data: Edge<T>,
    phantom_Tindices: PhantomData<Tindices>,
    segment_ids: Edge<Tindices>,
    phantom_Tnumsegments: PhantomData<Tnumsegments>,
    num_segments: Edge<Tnumsegments>,
    op_name: Option<String>,
    id_: usize,
}

impl<T, Tindices, Tnumsegments> UnsortedSegmentSum<T, Tindices, Tnumsegments>
where T: TensorType,
      T: Clone,
      Tindices: TensorType,
      Tindices: Clone,
      Tnumsegments: TensorType,
      Tnumsegments: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
      Tindices: con_or_DT_INT32_or_DT_INT64,
      Tindices: 'static,
      Tnumsegments: con_or_DT_INT32_or_DT_INT64,
      Tnumsegments: 'static,
{
    pub fn output(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(data: Edge<T>, segment_ids: Edge<Tindices>, num_segments: Edge<Tnumsegments>) -> Self {
        Self {
            phantom_T: PhantomData,
            data,
            phantom_Tindices: PhantomData,
            segment_ids,
            phantom_Tnumsegments: PhantomData,
            num_segments,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(data: Edge<T>, segment_ids: Edge<Tindices>, num_segments: Edge<Tnumsegments>) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            data,
            phantom_Tindices: PhantomData,
            segment_ids,
            phantom_Tnumsegments: PhantomData,
            num_segments,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<T, Tindices, Tnumsegments> GraphOperation for UnsortedSegmentMin<T, Tindices, Tnumsegments>
where T: TensorType,
      T: Clone,
      Tindices: TensorType,
      Tindices: Clone,
      Tnumsegments: TensorType,
      Tnumsegments: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
      Tindices: con_or_DT_INT32_or_DT_INT64,
      Tindices: 'static,
      Tnumsegments: con_or_DT_INT32_or_DT_INT64,
      Tnumsegments: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("UnsortedSegmentMin_{}")?
        };
        let mut new_op = graph.new_operation("UnsortedSegmentMin", &op_name)?;
        {
            new_op.add_edge(&self.data)?
        }
        {
            new_op.add_edge(&self.segment_ids)?
        }
        {
            new_op.add_edge(&self.num_segments)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct UnsortedSegmentMin<T, Tindices, Tnumsegments>
where T: TensorType,
      T: Clone,
      Tindices: TensorType,
      Tindices: Clone,
      Tnumsegments: TensorType,
      Tnumsegments: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
      Tindices: con_or_DT_INT32_or_DT_INT64,
      Tindices: 'static,
      Tnumsegments: con_or_DT_INT32_or_DT_INT64,
      Tnumsegments: 'static,
{
    phantom_T: PhantomData<T>,
    data: Edge<T>,
    phantom_Tindices: PhantomData<Tindices>,
    segment_ids: Edge<Tindices>,
    phantom_Tnumsegments: PhantomData<Tnumsegments>,
    num_segments: Edge<Tnumsegments>,
    op_name: Option<String>,
    id_: usize,
}

impl<T, Tindices, Tnumsegments> UnsortedSegmentMin<T, Tindices, Tnumsegments>
where T: TensorType,
      T: Clone,
      Tindices: TensorType,
      Tindices: Clone,
      Tnumsegments: TensorType,
      Tnumsegments: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
      Tindices: con_or_DT_INT32_or_DT_INT64,
      Tindices: 'static,
      Tnumsegments: con_or_DT_INT32_or_DT_INT64,
      Tnumsegments: 'static,
{
    pub fn output(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(data: Edge<T>, segment_ids: Edge<Tindices>, num_segments: Edge<Tnumsegments>) -> Self {
        Self {
            phantom_T: PhantomData,
            data,
            phantom_Tindices: PhantomData,
            segment_ids,
            phantom_Tnumsegments: PhantomData,
            num_segments,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(data: Edge<T>, segment_ids: Edge<Tindices>, num_segments: Edge<Tnumsegments>) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            data,
            phantom_Tindices: PhantomData,
            segment_ids,
            phantom_Tnumsegments: PhantomData,
            num_segments,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<T, Tindices, Tnumsegments> GraphOperation for UnsortedSegmentProd<T, Tindices, Tnumsegments>
where T: TensorType,
      T: Clone,
      Tindices: TensorType,
      Tindices: Clone,
      Tnumsegments: TensorType,
      Tnumsegments: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
      Tindices: con_or_DT_INT32_or_DT_INT64,
      Tindices: 'static,
      Tnumsegments: con_or_DT_INT32_or_DT_INT64,
      Tnumsegments: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("UnsortedSegmentProd_{}")?
        };
        let mut new_op = graph.new_operation("UnsortedSegmentProd", &op_name)?;
        {
            new_op.add_edge(&self.data)?
        }
        {
            new_op.add_edge(&self.segment_ids)?
        }
        {
            new_op.add_edge(&self.num_segments)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct UnsortedSegmentProd<T, Tindices, Tnumsegments>
where T: TensorType,
      T: Clone,
      Tindices: TensorType,
      Tindices: Clone,
      Tnumsegments: TensorType,
      Tnumsegments: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
      Tindices: con_or_DT_INT32_or_DT_INT64,
      Tindices: 'static,
      Tnumsegments: con_or_DT_INT32_or_DT_INT64,
      Tnumsegments: 'static,
{
    phantom_T: PhantomData<T>,
    data: Edge<T>,
    phantom_Tindices: PhantomData<Tindices>,
    segment_ids: Edge<Tindices>,
    phantom_Tnumsegments: PhantomData<Tnumsegments>,
    num_segments: Edge<Tnumsegments>,
    op_name: Option<String>,
    id_: usize,
}

impl<T, Tindices, Tnumsegments> UnsortedSegmentProd<T, Tindices, Tnumsegments>
where T: TensorType,
      T: Clone,
      Tindices: TensorType,
      Tindices: Clone,
      Tnumsegments: TensorType,
      Tnumsegments: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
      Tindices: con_or_DT_INT32_or_DT_INT64,
      Tindices: 'static,
      Tnumsegments: con_or_DT_INT32_or_DT_INT64,
      Tnumsegments: 'static,
{
    pub fn output(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(data: Edge<T>, segment_ids: Edge<Tindices>, num_segments: Edge<Tnumsegments>) -> Self {
        Self {
            phantom_T: PhantomData,
            data,
            phantom_Tindices: PhantomData,
            segment_ids,
            phantom_Tnumsegments: PhantomData,
            num_segments,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(data: Edge<T>, segment_ids: Edge<Tindices>, num_segments: Edge<Tnumsegments>) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            data,
            phantom_Tindices: PhantomData,
            segment_ids,
            phantom_Tnumsegments: PhantomData,
            num_segments,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<S, T> GraphOperation for CudnnRNNParamsSize<S, T>
where S: TensorType,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_HALF,
      T: 'static,
      T: Clone,
      S: con_or_DT_INT32_or_DT_INT64,
      S: 'static,
      S: Clone,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("CudnnRNNParamsSize_{}")?
        };
        let mut new_op = graph.new_operation("CudnnRNNParamsSize", &op_name)?;
        {
            new_op.add_edge(&self.num_layers)?
        }
        {
            new_op.add_edge(&self.num_units)?
        }
        {
            new_op.add_edge(&self.input_size)?
        }
        {
            match self.rnn_mode {
                None => new_op.set_attr_value_proto("rnn_mode", &vec![18_u8, 4_u8, 108_u8, 115_u8, 116_u8, 109_u8,])?,
                Some(ref value) => (|attr| {new_op.set_attr_string("rnn_mode", attr)})(&value)?,
            };
        }
        {
            match self.input_mode {
                None => new_op.set_attr_value_proto("input_mode", &vec![18_u8, 12_u8, 108_u8, 105_u8, 110_u8, 101_u8, 97_u8, 114_u8, 95_u8, 105_u8, 110_u8, 112_u8, 117_u8, 116_u8,])?,
                Some(ref value) => (|attr| {new_op.set_attr_string("input_mode", attr)})(&value)?,
            };
        }
        {
            match self.direction {
                None => new_op.set_attr_value_proto("direction", &vec![18_u8, 14_u8, 117_u8, 110_u8, 105_u8, 100_u8, 105_u8, 114_u8, 101_u8, 99_u8, 116_u8, 105_u8, 111_u8, 110_u8, 97_u8, 108_u8,])?,
                Some(ref value) => (|attr| {new_op.set_attr_string("direction", attr)})(&value)?,
            };
        }
        {
            match self.dropout {
                None => new_op.set_attr_value_proto("dropout", &vec![37_u8, 0_u8, 0_u8, 0_u8, 0_u8,])?,
                Some(ref value) => (|attr: &f32| {new_op.set_attr_float("dropout", *attr)})(&value)?,
            };
        }
        {
            match self.seed {
                None => new_op.set_attr_value_proto("seed", &vec![24_u8, 0_u8,])?,
                Some(ref value) => (|attr: &i64| {new_op.set_attr_int("seed", *attr)})(&value)?,
            };
        }
        {
            match self.seed2 {
                None => new_op.set_attr_value_proto("seed2", &vec![24_u8, 0_u8,])?,
                Some(ref value) => (|attr: &i64| {new_op.set_attr_int("seed2", *attr)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct CudnnRNNParamsSize<S, T>
where S: TensorType,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_HALF,
      T: 'static,
      T: Clone,
      S: con_or_DT_INT32_or_DT_INT64,
      S: 'static,
      S: Clone,
{
    num_layers: Edge<i32>,
    num_units: Edge<i32>,
    input_size: Edge<i32>,
    phantom_T: PhantomData<T>,
    phantom_S: PhantomData<S>,
    rnn_mode: Option<String>,
    input_mode: Option<String>,
    direction: Option<String>,
    dropout: Option<f32>,
    seed: Option<i64>,
    seed2: Option<i64>,
    op_name: Option<String>,
    id_: usize,
}

impl<S, T> CudnnRNNParamsSize<S, T>
where S: TensorType,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_HALF,
      T: 'static,
      T: Clone,
      S: con_or_DT_INT32_or_DT_INT64,
      S: 'static,
      S: Clone,
{
    pub fn params_size(self) -> Edge<S> {
        let rc = Rc::new(self);
        {
            Edge::<S>::new(rc.clone(), 0)
        }
    }

    pub fn rnn_mode(&mut self, rnn_mode: &str) -> Self {
        self.rnn_mode = Some(rnn_mode.to_string());
        self.clone()
    }

    pub fn input_mode(&mut self, input_mode: &str) -> Self {
        self.input_mode = Some(input_mode.to_string());
        self.clone()
    }

    pub fn direction(&mut self, direction: &str) -> Self {
        self.direction = Some(direction.to_string());
        self.clone()
    }

    pub fn dropout(&mut self, dropout: f32) -> Self {
        self.dropout = Some(dropout);
        self.clone()
    }

    pub fn seed(&mut self, seed: i64) -> Self {
        self.seed = Some(seed);
        self.clone()
    }

    pub fn seed2(&mut self, seed2: i64) -> Self {
        self.seed2 = Some(seed2);
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<S> {
        let rc = Rc::new(self);
        {
            Edge::<S>::new(rc.clone(), 0)
        }
    }

    pub fn build(num_layers: Edge<i32>, num_units: Edge<i32>, input_size: Edge<i32>) -> Self {
        Self {
            num_layers,
            num_units,
            input_size,
            phantom_T: PhantomData,
            phantom_S: PhantomData,
            rnn_mode: None,
            input_mode: None,
            direction: None,
            dropout: None,
            seed: None,
            seed2: None,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(num_layers: Edge<i32>, num_units: Edge<i32>, input_size: Edge<i32>) -> Edge<S> {
        Self {
            num_layers,
            num_units,
            input_size,
            phantom_T: PhantomData,
            phantom_S: PhantomData,
            rnn_mode: None,
            input_mode: None,
            direction: None,
            dropout: None,
            seed: None,
            seed2: None,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<T, Tidx> GraphOperation for SparseSegmentMeanGrad<T, Tidx>
where T: TensorType,
      T: Clone,
      Tidx: TensorType,
      Tidx: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE,
      T: 'static,
      Tidx: con_or_DT_INT32_or_DT_INT64,
      Tidx: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("SparseSegmentMeanGrad_{}")?
        };
        let mut new_op = graph.new_operation("SparseSegmentMeanGrad", &op_name)?;
        {
            new_op.add_edge(&self.grad)?
        }
        {
            new_op.add_edge(&self.indices)?
        }
        {
            new_op.add_edge(&self.segment_ids)?
        }
        {
            new_op.add_edge(&self.output_dim0)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct SparseSegmentMeanGrad<T, Tidx>
where T: TensorType,
      T: Clone,
      Tidx: TensorType,
      Tidx: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE,
      T: 'static,
      Tidx: con_or_DT_INT32_or_DT_INT64,
      Tidx: 'static,
{
    phantom_T: PhantomData<T>,
    grad: Edge<T>,
    phantom_Tidx: PhantomData<Tidx>,
    indices: Edge<Tidx>,
    segment_ids: Edge<i32>,
    output_dim0: Edge<i32>,
    op_name: Option<String>,
    id_: usize,
}

impl<T, Tidx> SparseSegmentMeanGrad<T, Tidx>
where T: TensorType,
      T: Clone,
      Tidx: TensorType,
      Tidx: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE,
      T: 'static,
      Tidx: con_or_DT_INT32_or_DT_INT64,
      Tidx: 'static,
{
    pub fn output(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(grad: Edge<T>, indices: Edge<Tidx>, segment_ids: Edge<i32>, output_dim0: Edge<i32>) -> Self {
        Self {
            phantom_T: PhantomData,
            grad,
            phantom_Tidx: PhantomData,
            indices,
            segment_ids,
            output_dim0,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(grad: Edge<T>, indices: Edge<Tidx>, segment_ids: Edge<i32>, output_dim0: Edge<i32>) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            grad,
            phantom_Tidx: PhantomData,
            indices,
            segment_ids,
            output_dim0,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<T, Tidx> GraphOperation for SparseSegmentSqrtN<T, Tidx>
where T: TensorType,
      T: Clone,
      Tidx: TensorType,
      Tidx: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE,
      T: 'static,
      Tidx: con_or_DT_INT32_or_DT_INT64,
      Tidx: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("SparseSegmentSqrtN_{}")?
        };
        let mut new_op = graph.new_operation("SparseSegmentSqrtN", &op_name)?;
        {
            new_op.add_edge(&self.data)?
        }
        {
            new_op.add_edge(&self.indices)?
        }
        {
            new_op.add_edge(&self.segment_ids)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct SparseSegmentSqrtN<T, Tidx>
where T: TensorType,
      T: Clone,
      Tidx: TensorType,
      Tidx: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE,
      T: 'static,
      Tidx: con_or_DT_INT32_or_DT_INT64,
      Tidx: 'static,
{
    phantom_T: PhantomData<T>,
    data: Edge<T>,
    phantom_Tidx: PhantomData<Tidx>,
    indices: Edge<Tidx>,
    segment_ids: Edge<i32>,
    op_name: Option<String>,
    id_: usize,
}

impl<T, Tidx> SparseSegmentSqrtN<T, Tidx>
where T: TensorType,
      T: Clone,
      Tidx: TensorType,
      Tidx: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE,
      T: 'static,
      Tidx: con_or_DT_INT32_or_DT_INT64,
      Tidx: 'static,
{
    pub fn output(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(data: Edge<T>, indices: Edge<Tidx>, segment_ids: Edge<i32>) -> Self {
        Self {
            phantom_T: PhantomData,
            data,
            phantom_Tidx: PhantomData,
            indices,
            segment_ids,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(data: Edge<T>, indices: Edge<Tidx>, segment_ids: Edge<i32>) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            data,
            phantom_Tidx: PhantomData,
            indices,
            segment_ids,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<T> GraphOperation for Igammac<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE,
      T: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("Igammac_{}")?
        };
        let mut new_op = graph.new_operation("Igammac", &op_name)?;
        {
            new_op.add_edge(&self.a)?
        }
        {
            new_op.add_edge(&self.x)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct Igammac<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    a: Edge<T>,
    x: Edge<T>,
    op_name: Option<String>,
    id_: usize,
}

impl<T> Igammac<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE,
      T: 'static,
{
    pub fn z(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(a: Edge<T>, x: Edge<T>) -> Self {
        Self {
            phantom_T: PhantomData,
            a,
            x,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(a: Edge<T>, x: Edge<T>) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            a,
            x,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<T, Tidx, Tnumsegments> GraphOperation for SparseSegmentSqrtNWithNumSegments<T, Tidx, Tnumsegments>
where T: TensorType,
      T: Clone,
      Tidx: TensorType,
      Tidx: Clone,
      Tnumsegments: TensorType,
      Tnumsegments: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE,
      T: 'static,
      Tidx: con_or_DT_INT32_or_DT_INT64,
      Tidx: 'static,
      Tnumsegments: con_or_DT_INT32_or_DT_INT64,
      Tnumsegments: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("SparseSegmentSqrtNWithNumSegments_{}")?
        };
        let mut new_op = graph.new_operation("SparseSegmentSqrtNWithNumSegments", &op_name)?;
        {
            new_op.add_edge(&self.data)?
        }
        {
            new_op.add_edge(&self.indices)?
        }
        {
            new_op.add_edge(&self.segment_ids)?
        }
        {
            new_op.add_edge(&self.num_segments)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct SparseSegmentSqrtNWithNumSegments<T, Tidx, Tnumsegments>
where T: TensorType,
      T: Clone,
      Tidx: TensorType,
      Tidx: Clone,
      Tnumsegments: TensorType,
      Tnumsegments: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE,
      T: 'static,
      Tidx: con_or_DT_INT32_or_DT_INT64,
      Tidx: 'static,
      Tnumsegments: con_or_DT_INT32_or_DT_INT64,
      Tnumsegments: 'static,
{
    phantom_T: PhantomData<T>,
    data: Edge<T>,
    phantom_Tidx: PhantomData<Tidx>,
    indices: Edge<Tidx>,
    segment_ids: Edge<i32>,
    phantom_Tnumsegments: PhantomData<Tnumsegments>,
    num_segments: Edge<Tnumsegments>,
    op_name: Option<String>,
    id_: usize,
}

impl<T, Tidx, Tnumsegments> SparseSegmentSqrtNWithNumSegments<T, Tidx, Tnumsegments>
where T: TensorType,
      T: Clone,
      Tidx: TensorType,
      Tidx: Clone,
      Tnumsegments: TensorType,
      Tnumsegments: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE,
      T: 'static,
      Tidx: con_or_DT_INT32_or_DT_INT64,
      Tidx: 'static,
      Tnumsegments: con_or_DT_INT32_or_DT_INT64,
      Tnumsegments: 'static,
{
    pub fn output(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(data: Edge<T>, indices: Edge<Tidx>, segment_ids: Edge<i32>, num_segments: Edge<Tnumsegments>) -> Self {
        Self {
            phantom_T: PhantomData,
            data,
            phantom_Tidx: PhantomData,
            indices,
            segment_ids,
            phantom_Tnumsegments: PhantomData,
            num_segments,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(data: Edge<T>, indices: Edge<Tidx>, segment_ids: Edge<i32>, num_segments: Edge<Tnumsegments>) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            data,
            phantom_Tidx: PhantomData,
            indices,
            segment_ids,
            phantom_Tnumsegments: PhantomData,
            num_segments,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<T> GraphOperation for LRNGrad<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_BFLOAT16_or_DT_HALF,
      T: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("LRNGrad_{}")?
        };
        let mut new_op = graph.new_operation("LRNGrad", &op_name)?;
        {
            new_op.add_edge(&self.input_grads)?
        }
        {
            new_op.add_edge(&self.input_image)?
        }
        {
            new_op.add_edge(&self.output_image)?
        }
        {
            match self.depth_radius {
                None => new_op.set_attr_value_proto("depth_radius", &vec![24_u8, 5_u8,])?,
                Some(ref value) => (|attr: &i64| {new_op.set_attr_int("depth_radius", *attr)})(&value)?,
            };
        }
        {
            match self.bias {
                None => new_op.set_attr_value_proto("bias", &vec![37_u8, 0_u8, 0_u8, 128_u8, 63_u8,])?,
                Some(ref value) => (|attr: &f32| {new_op.set_attr_float("bias", *attr)})(&value)?,
            };
        }
        {
            match self.alpha {
                None => new_op.set_attr_value_proto("alpha", &vec![37_u8, 0_u8, 0_u8, 128_u8, 63_u8,])?,
                Some(ref value) => (|attr: &f32| {new_op.set_attr_float("alpha", *attr)})(&value)?,
            };
        }
        {
            match self.beta {
                None => new_op.set_attr_value_proto("beta", &vec![37_u8, 0_u8, 0_u8, 0_u8, 63_u8,])?,
                Some(ref value) => (|attr: &f32| {new_op.set_attr_float("beta", *attr)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct LRNGrad<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_BFLOAT16_or_DT_HALF,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    input_grads: Edge<T>,
    input_image: Edge<T>,
    output_image: Edge<T>,
    depth_radius: Option<i64>,
    bias: Option<f32>,
    alpha: Option<f32>,
    beta: Option<f32>,
    op_name: Option<String>,
    id_: usize,
}

impl<T> LRNGrad<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_BFLOAT16_or_DT_HALF,
      T: 'static,
{
    pub fn output(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn depth_radius(&mut self, depth_radius: i64) -> Self {
        self.depth_radius = Some(depth_radius);
        self.clone()
    }

    pub fn bias(&mut self, bias: f32) -> Self {
        self.bias = Some(bias);
        self.clone()
    }

    pub fn alpha(&mut self, alpha: f32) -> Self {
        self.alpha = Some(alpha);
        self.clone()
    }

    pub fn beta(&mut self, beta: f32) -> Self {
        self.beta = Some(beta);
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(input_grads: Edge<T>, input_image: Edge<T>, output_image: Edge<T>) -> Self {
        Self {
            phantom_T: PhantomData,
            input_grads,
            input_image,
            output_image,
            depth_radius: None,
            bias: None,
            alpha: None,
            beta: None,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(input_grads: Edge<T>, input_image: Edge<T>, output_image: Edge<T>) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            input_grads,
            input_image,
            output_image,
            depth_radius: None,
            bias: None,
            alpha: None,
            beta: None,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<Tidx> GraphOperation for Any<Tidx>
where Tidx: TensorType,
      Tidx: Clone,
      Tidx: con_or_DT_INT32_or_DT_INT64,
      Tidx: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("Any_{}")?
        };
        let mut new_op = graph.new_operation("Any", &op_name)?;
        {
            new_op.add_edge(&self.input)?
        }
        {
            new_op.add_edge(&self.reduction_indices)?
        }
        {
            match self.keep_dims {
                None => new_op.set_attr_value_proto("keep_dims", &vec![40_u8, 0_u8,])?,
                Some(ref value) => (|attr: &bool| {new_op.set_attr_bool("keep_dims", *attr)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct Any<Tidx>
where Tidx: TensorType,
      Tidx: Clone,
      Tidx: con_or_DT_INT32_or_DT_INT64,
      Tidx: 'static,
{
    input: Edge<bool>,
    phantom_Tidx: PhantomData<Tidx>,
    reduction_indices: Edge<Tidx>,
    keep_dims: Option<bool>,
    op_name: Option<String>,
    id_: usize,
}

impl<Tidx> Any<Tidx>
where Tidx: TensorType,
      Tidx: Clone,
      Tidx: con_or_DT_INT32_or_DT_INT64,
      Tidx: 'static,
{
    pub fn output(self) -> Edge<bool> {
        let rc = Rc::new(self);
        {
            Edge::<bool>::new(rc.clone(), 0)
        }
    }

    pub fn keep_dims(&mut self, keep_dims: bool) -> Self {
        self.keep_dims = Some(keep_dims);
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<bool> {
        let rc = Rc::new(self);
        {
            Edge::<bool>::new(rc.clone(), 0)
        }
    }

    pub fn build(input: Edge<bool>, reduction_indices: Edge<Tidx>) -> Self {
        Self {
            input,
            phantom_Tidx: PhantomData,
            reduction_indices,
            keep_dims: None,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(input: Edge<bool>, reduction_indices: Edge<Tidx>) -> Edge<bool> {
        Self {
            input,
            phantom_Tidx: PhantomData,
            reduction_indices,
            keep_dims: None,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<Tidx> GraphOperation for Range<Tidx>
where Tidx: TensorType,
      Tidx: Clone,
      Tidx: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_INT64_or_DT_BFLOAT16,
      Tidx: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("Range_{}")?
        };
        let mut new_op = graph.new_operation("Range", &op_name)?;
        {
            new_op.add_edge(&self.start)?
        }
        {
            new_op.add_edge(&self.limit)?
        }
        {
            new_op.add_edge(&self.delta)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct Range<Tidx>
where Tidx: TensorType,
      Tidx: Clone,
      Tidx: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_INT64_or_DT_BFLOAT16,
      Tidx: 'static,
{
    phantom_Tidx: PhantomData<Tidx>,
    start: Edge<Tidx>,
    limit: Edge<Tidx>,
    delta: Edge<Tidx>,
    op_name: Option<String>,
    id_: usize,
}

impl<Tidx> Range<Tidx>
where Tidx: TensorType,
      Tidx: Clone,
      Tidx: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_INT64_or_DT_BFLOAT16,
      Tidx: 'static,
{
    pub fn output(self) -> Edge<Tidx> {
        let rc = Rc::new(self);
        {
            Edge::<Tidx>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<Tidx> {
        let rc = Rc::new(self);
        {
            Edge::<Tidx>::new(rc.clone(), 0)
        }
    }

    pub fn build(start: Edge<Tidx>, limit: Edge<Tidx>, delta: Edge<Tidx>) -> Self {
        Self {
            phantom_Tidx: PhantomData,
            start,
            limit,
            delta,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(start: Edge<Tidx>, limit: Edge<Tidx>, delta: Edge<Tidx>) -> Edge<Tidx> {
        Self {
            phantom_Tidx: PhantomData,
            start,
            limit,
            delta,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

pub trait con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16 for BFloat16 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16 for f32 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16 for f64 {
}

impl<T, Tidx> GraphOperation for LinSpace<T, Tidx>
where T: TensorType,
      T: Clone,
      Tidx: TensorType,
      Tidx: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16,
      T: 'static,
      Tidx: con_or_DT_INT32_or_DT_INT64,
      Tidx: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("LinSpace_{}")?
        };
        let mut new_op = graph.new_operation("LinSpace", &op_name)?;
        {
            new_op.add_edge(&self.start)?
        }
        {
            new_op.add_edge(&self.stop)?
        }
        {
            new_op.add_edge(&self.num)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct LinSpace<T, Tidx>
where T: TensorType,
      T: Clone,
      Tidx: TensorType,
      Tidx: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16,
      T: 'static,
      Tidx: con_or_DT_INT32_or_DT_INT64,
      Tidx: 'static,
{
    phantom_T: PhantomData<T>,
    start: Edge<T>,
    stop: Edge<T>,
    phantom_Tidx: PhantomData<Tidx>,
    num: Edge<Tidx>,
    op_name: Option<String>,
    id_: usize,
}

impl<T, Tidx> LinSpace<T, Tidx>
where T: TensorType,
      T: Clone,
      Tidx: TensorType,
      Tidx: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16,
      T: 'static,
      Tidx: con_or_DT_INT32_or_DT_INT64,
      Tidx: 'static,
{
    pub fn output(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(start: Edge<T>, stop: Edge<T>, num: Edge<Tidx>) -> Self {
        Self {
            phantom_T: PhantomData,
            start,
            stop,
            phantom_Tidx: PhantomData,
            num,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(start: Edge<T>, stop: Edge<T>, num: Edge<Tidx>) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            start,
            stop,
            phantom_Tidx: PhantomData,
            num,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<T, Tout> GraphOperation for Angle<T, Tout>
where T: TensorType,
      T: Clone,
      Tout: TensorType,
      T: con_or_DT_COMPLEX64_or_DT_COMPLEX128,
      T: 'static,
      Tout: con_or_DT_FLOAT_or_DT_DOUBLE,
      Tout: 'static,
      Tout: Clone,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("Angle_{}")?
        };
        let mut new_op = graph.new_operation("Angle", &op_name)?;
        {
            new_op.add_edge(&self.input)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct Angle<T, Tout>
where T: TensorType,
      T: Clone,
      Tout: TensorType,
      T: con_or_DT_COMPLEX64_or_DT_COMPLEX128,
      T: 'static,
      Tout: con_or_DT_FLOAT_or_DT_DOUBLE,
      Tout: 'static,
      Tout: Clone,
{
    phantom_T: PhantomData<T>,
    input: Edge<T>,
    phantom_Tout: PhantomData<Tout>,
    op_name: Option<String>,
    id_: usize,
}

impl<T, Tout> Angle<T, Tout>
where T: TensorType,
      T: Clone,
      Tout: TensorType,
      T: con_or_DT_COMPLEX64_or_DT_COMPLEX128,
      T: 'static,
      Tout: con_or_DT_FLOAT_or_DT_DOUBLE,
      Tout: 'static,
      Tout: Clone,
{
    pub fn output(self) -> Edge<Tout> {
        let rc = Rc::new(self);
        {
            Edge::<Tout>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<Tout> {
        let rc = Rc::new(self);
        {
            Edge::<Tout>::new(rc.clone(), 0)
        }
    }

    pub fn build(input: Edge<T>) -> Self {
        Self {
            phantom_T: PhantomData,
            input,
            phantom_Tout: PhantomData,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(input: Edge<T>) -> Edge<Tout> {
        Self {
            phantom_T: PhantomData,
            input,
            phantom_Tout: PhantomData,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<T> GraphOperation for ClipByValue<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("ClipByValue_{}")?
        };
        let mut new_op = graph.new_operation("ClipByValue", &op_name)?;
        {
            new_op.add_edge(&self.t)?
        }
        {
            new_op.add_edge(&self.clip_value_min)?
        }
        {
            new_op.add_edge(&self.clip_value_max)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct ClipByValue<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    t: Edge<T>,
    clip_value_min: Edge<T>,
    clip_value_max: Edge<T>,
    op_name: Option<String>,
    id_: usize,
}

impl<T> ClipByValue<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
{
    pub fn output(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(t: Edge<T>, clip_value_min: Edge<T>, clip_value_max: Edge<T>) -> Self {
        Self {
            phantom_T: PhantomData,
            t,
            clip_value_min,
            clip_value_max,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(t: Edge<T>, clip_value_min: Edge<T>, clip_value_max: Edge<T>) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            t,
            clip_value_min,
            clip_value_max,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<T, dtype> GraphOperation for HistogramFixedWidth<T, dtype>
where T: TensorType,
      T: Clone,
      dtype: TensorType,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_INT64,
      T: 'static,
      dtype: con_or_DT_INT32_or_DT_INT64,
      dtype: 'static,
      dtype: Clone,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("HistogramFixedWidth_{}")?
        };
        let mut new_op = graph.new_operation("HistogramFixedWidth", &op_name)?;
        {
            new_op.add_edge(&self.values)?
        }
        {
            new_op.add_edge(&self.value_range)?
        }
        {
            new_op.add_edge(&self.nbins)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct HistogramFixedWidth<T, dtype>
where T: TensorType,
      T: Clone,
      dtype: TensorType,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_INT64,
      T: 'static,
      dtype: con_or_DT_INT32_or_DT_INT64,
      dtype: 'static,
      dtype: Clone,
{
    phantom_T: PhantomData<T>,
    values: Edge<T>,
    value_range: Edge<T>,
    nbins: Edge<i32>,
    phantom_dtype: PhantomData<dtype>,
    op_name: Option<String>,
    id_: usize,
}

impl<T, dtype> HistogramFixedWidth<T, dtype>
where T: TensorType,
      T: Clone,
      dtype: TensorType,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_INT64,
      T: 'static,
      dtype: con_or_DT_INT32_or_DT_INT64,
      dtype: 'static,
      dtype: Clone,
{
    pub fn out(self) -> Edge<dtype> {
        let rc = Rc::new(self);
        {
            Edge::<dtype>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<dtype> {
        let rc = Rc::new(self);
        {
            Edge::<dtype>::new(rc.clone(), 0)
        }
    }

    pub fn build(values: Edge<T>, value_range: Edge<T>, nbins: Edge<i32>) -> Self {
        Self {
            phantom_T: PhantomData,
            values,
            value_range,
            nbins,
            phantom_dtype: PhantomData,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(values: Edge<T>, value_range: Edge<T>, nbins: Edge<i32>) -> Edge<dtype> {
        Self {
            phantom_T: PhantomData,
            values,
            value_range,
            nbins,
            phantom_dtype: PhantomData,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<T> GraphOperation for Bincount<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_INT64,
      T: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("Bincount_{}")?
        };
        let mut new_op = graph.new_operation("Bincount", &op_name)?;
        {
            new_op.add_edge(&self.arr)?
        }
        {
            new_op.add_edge(&self.size)?
        }
        {
            new_op.add_edge(&self.weights)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct Bincount<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_INT64,
      T: 'static,
{
    arr: Edge<i32>,
    size: Edge<i32>,
    phantom_T: PhantomData<T>,
    weights: Edge<T>,
    op_name: Option<String>,
    id_: usize,
}

impl<T> Bincount<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_INT64,
      T: 'static,
{
    pub fn bins(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(arr: Edge<i32>, size: Edge<i32>, weights: Edge<T>) -> Self {
        Self {
            arr,
            size,
            phantom_T: PhantomData,
            weights,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(arr: Edge<i32>, size: Edge<i32>, weights: Edge<T>) -> Edge<T> {
        Self {
            arr,
            size,
            phantom_T: PhantomData,
            weights,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<T1, T2, Toutput> GraphOperation for QuantizedMul<T1, T2, Toutput>
where T1: TensorType,
      T1: Clone,
      T2: TensorType,
      T2: Clone,
      Toutput: TensorType,
      T1: con_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_QINT16_or_DT_QUINT16,
      T1: 'static,
      T2: con_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_QINT16_or_DT_QUINT16,
      T2: 'static,
      Toutput: con_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_QINT16_or_DT_QUINT16,
      Toutput: 'static,
      Toutput: Clone,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("QuantizedMul_{}")?
        };
        let mut new_op = graph.new_operation("QuantizedMul", &op_name)?;
        {
            new_op.add_edge(&self.x)?
        }
        {
            new_op.add_edge(&self.y)?
        }
        {
            new_op.add_edge(&self.min_x)?
        }
        {
            new_op.add_edge(&self.max_x)?
        }
        {
            new_op.add_edge(&self.min_y)?
        }
        {
            new_op.add_edge(&self.max_y)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct QuantizedMul<T1, T2, Toutput>
where T1: TensorType,
      T1: Clone,
      T2: TensorType,
      T2: Clone,
      Toutput: TensorType,
      T1: con_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_QINT16_or_DT_QUINT16,
      T1: 'static,
      T2: con_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_QINT16_or_DT_QUINT16,
      T2: 'static,
      Toutput: con_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_QINT16_or_DT_QUINT16,
      Toutput: 'static,
      Toutput: Clone,
{
    phantom_T1: PhantomData<T1>,
    x: Edge<T1>,
    phantom_T2: PhantomData<T2>,
    y: Edge<T2>,
    min_x: Edge<f32>,
    max_x: Edge<f32>,
    min_y: Edge<f32>,
    max_y: Edge<f32>,
    phantom_Toutput: PhantomData<Toutput>,
    op_name: Option<String>,
    id_: usize,
}

impl<T1, T2, Toutput> QuantizedMul<T1, T2, Toutput>
where T1: TensorType,
      T1: Clone,
      T2: TensorType,
      T2: Clone,
      Toutput: TensorType,
      T1: con_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_QINT16_or_DT_QUINT16,
      T1: 'static,
      T2: con_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_QINT16_or_DT_QUINT16,
      T2: 'static,
      Toutput: con_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_QINT16_or_DT_QUINT16,
      Toutput: 'static,
      Toutput: Clone,
{
    pub fn z(self) -> Edge<Toutput> {
        let rc = Rc::new(self);
        {
            Edge::<Toutput>::new(rc.clone(), 0)
        }
    }

    pub fn min_z(self) -> Edge<f32> {
        let rc = Rc::new(self);
        {
            Edge::<f32>::new(rc.clone(), 1)
        }
    }

    pub fn max_z(self) -> Edge<f32> {
        let rc = Rc::new(self);
        {
            Edge::<f32>::new(rc.clone(), 2)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> (Edge<Toutput>, Edge<f32>, Edge<f32>) {
        let rc = Rc::new(self);
        (
        {
            Edge::<Toutput>::new(rc.clone(), 0)
        },
        {
            Edge::<f32>::new(rc.clone(), 1)
        },
        {
            Edge::<f32>::new(rc.clone(), 2)
        },
        )
    }

    pub fn build(x: Edge<T1>, y: Edge<T2>, min_x: Edge<f32>, max_x: Edge<f32>, min_y: Edge<f32>, max_y: Edge<f32>) -> Self {
        Self {
            phantom_T1: PhantomData,
            x,
            phantom_T2: PhantomData,
            y,
            min_x,
            max_x,
            min_y,
            max_y,
            phantom_Toutput: PhantomData,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(x: Edge<T1>, y: Edge<T2>, min_x: Edge<f32>, max_x: Edge<f32>, min_y: Edge<f32>, max_y: Edge<f32>) -> (Edge<Toutput>, Edge<f32>, Edge<f32>) {
        Self {
            phantom_T1: PhantomData,
            x,
            phantom_T2: PhantomData,
            y,
            min_x,
            max_x,
            min_y,
            max_y,
            phantom_Toutput: PhantomData,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<Tinput> GraphOperation for RequantizationRange<Tinput>
where Tinput: TensorType,
      Tinput: Clone,
      Tinput: con_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_QINT16_or_DT_QUINT16,
      Tinput: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("RequantizationRange_{}")?
        };
        let mut new_op = graph.new_operation("RequantizationRange", &op_name)?;
        {
            new_op.add_edge(&self.input)?
        }
        {
            new_op.add_edge(&self.input_min)?
        }
        {
            new_op.add_edge(&self.input_max)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct RequantizationRange<Tinput>
where Tinput: TensorType,
      Tinput: Clone,
      Tinput: con_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_QINT16_or_DT_QUINT16,
      Tinput: 'static,
{
    phantom_Tinput: PhantomData<Tinput>,
    input: Edge<Tinput>,
    input_min: Edge<f32>,
    input_max: Edge<f32>,
    op_name: Option<String>,
    id_: usize,
}

impl<Tinput> RequantizationRange<Tinput>
where Tinput: TensorType,
      Tinput: Clone,
      Tinput: con_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_QINT16_or_DT_QUINT16,
      Tinput: 'static,
{
    pub fn output_min(self) -> Edge<f32> {
        let rc = Rc::new(self);
        {
            Edge::<f32>::new(rc.clone(), 0)
        }
    }

    pub fn output_max(self) -> Edge<f32> {
        let rc = Rc::new(self);
        {
            Edge::<f32>::new(rc.clone(), 1)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> (Edge<f32>, Edge<f32>) {
        let rc = Rc::new(self);
        (
        {
            Edge::<f32>::new(rc.clone(), 0)
        },
        {
            Edge::<f32>::new(rc.clone(), 1)
        },
        )
    }

    pub fn build(input: Edge<Tinput>, input_min: Edge<f32>, input_max: Edge<f32>) -> Self {
        Self {
            phantom_Tinput: PhantomData,
            input,
            input_min,
            input_max,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(input: Edge<Tinput>, input_min: Edge<f32>, input_max: Edge<f32>) -> (Edge<f32>, Edge<f32>) {
        Self {
            phantom_Tinput: PhantomData,
            input,
            input_min,
            input_max,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl GraphOperation for RegexReplace {
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("RegexReplace_{}")?
        };
        let mut new_op = graph.new_operation("RegexReplace", &op_name)?;
        {
            new_op.add_edge(&self.input)?
        }
        {
            new_op.add_edge(&self.pattern)?
        }
        {
            new_op.add_edge(&self.rewrite)?
        }
        {
            match self.replace_global {
                None => new_op.set_attr_value_proto("replace_global", &vec![40_u8, 1_u8,])?,
                Some(ref value) => (|attr: &bool| {new_op.set_attr_bool("replace_global", *attr)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct RegexReplace {
    input: Edge<String>,
    pattern: Edge<String>,
    rewrite: Edge<String>,
    replace_global: Option<bool>,
    op_name: Option<String>,
    id_: usize,
}

impl RegexReplace {
    pub fn output(self) -> Edge<String> {
        let rc = Rc::new(self);
        {
            Edge::<String>::new(rc.clone(), 0)
        }
    }

    pub fn replace_global(&mut self, replace_global: bool) -> Self {
        self.replace_global = Some(replace_global);
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<String> {
        let rc = Rc::new(self);
        {
            Edge::<String>::new(rc.clone(), 0)
        }
    }

    pub fn build(input: Edge<String>, pattern: Edge<String>, rewrite: Edge<String>) -> Self {
        Self {
            input,
            pattern,
            rewrite,
            replace_global: None,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(input: Edge<String>, pattern: Edge<String>, rewrite: Edge<String>) -> Edge<String> {
        Self {
            input,
            pattern,
            rewrite,
            replace_global: None,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<T> GraphOperation for NcclAllReduce<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_INT64_or_DT_HALF,
      T: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("NcclAllReduce_{}")?
        };
        let mut new_op = graph.new_operation("NcclAllReduce", &op_name)?;
        {
            new_op.add_edge(&self.input)?
        }
        {
            (|attr| {new_op.set_attr_string("reduction", attr)})(&self.reduction)?
        }
        {
            (|attr: &i64| {new_op.set_attr_int("num_devices", *attr)})(&self.num_devices)?
        }
        {
            (|attr| {new_op.set_attr_string("shared_name", attr)})(&self.shared_name)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct NcclAllReduce<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_INT64_or_DT_HALF,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    input: Edge<T>,
    reduction: String,
    num_devices: i64,
    shared_name: String,
    op_name: Option<String>,
    id_: usize,
}

impl<T> NcclAllReduce<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_INT64_or_DT_HALF,
      T: 'static,
{
    pub fn data(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(input: Edge<T>, reduction: &str, num_devices: i64, shared_name: &str) -> Self {
        Self {
            phantom_T: PhantomData,
            input,
            reduction: reduction.to_string(),
            num_devices: num_devices,
            shared_name: shared_name.to_string(),
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(input: Edge<T>, reduction: &str, num_devices: i64, shared_name: &str) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            input,
            reduction: reduction.to_string(),
            num_devices: num_devices,
            shared_name: shared_name.to_string(),
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl GraphOperation for QueueSize {
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("QueueSize_{}")?
        };
        let mut new_op = graph.new_operation("QueueSize", &op_name)?;
        {
            new_op.add_edge(&self.handle)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct QueueSize {
    handle: Edge<String>,
    op_name: Option<String>,
    id_: usize,
}

impl QueueSize {
    pub fn size(self) -> Edge<i32> {
        let rc = Rc::new(self);
        {
            Edge::<i32>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<i32> {
        let rc = Rc::new(self);
        {
            Edge::<i32>::new(rc.clone(), 0)
        }
    }

    pub fn build(handle: Edge<String>) -> Self {
        Self {
            handle,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(handle: Edge<String>) -> Edge<i32> {
        Self {
            handle,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<T> GraphOperation for BiasAddGrad<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("BiasAddGrad_{}")?
        };
        let mut new_op = graph.new_operation("BiasAddGrad", &op_name)?;
        {
            new_op.add_edge(&self.out_backprop)?
        }
        {
            match self.data_format {
                None => new_op.set_attr_value_proto("data_format", &vec![18_u8, 4_u8, 78_u8, 72_u8, 87_u8, 67_u8,])?,
                Some(ref value) => (|attr| {new_op.set_attr_string("data_format", attr)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct BiasAddGrad<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    out_backprop: Edge<T>,
    data_format: Option<String>,
    op_name: Option<String>,
    id_: usize,
}

impl<T> BiasAddGrad<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
{
    pub fn output(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn data_format(&mut self, data_format: &str) -> Self {
        self.data_format = Some(data_format.to_string());
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(out_backprop: Edge<T>) -> Self {
        Self {
            phantom_T: PhantomData,
            out_backprop,
            data_format: None,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(out_backprop: Edge<T>) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            out_backprop,
            data_format: None,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<T> GraphOperation for NcclReduce<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_INT64_or_DT_HALF,
      T: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("NcclReduce_{}")?
        };
        let mut new_op = graph.new_operation("NcclReduce", &op_name)?;
        {
            new_op.add_edge(&self.input)?
        }
        {
            (|attr| {new_op.set_attr_string("reduction", attr)})(&self.reduction)?
        }
        {
            (|attr: &i64| {new_op.set_attr_int("num_devices", *attr)})(&self.num_devices)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct NcclReduce<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_INT64_or_DT_HALF,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    input: Edge<T>,
    reduction: String,
    num_devices: i64,
    op_name: Option<String>,
    id_: usize,
}

impl<T> NcclReduce<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_INT64_or_DT_HALF,
      T: 'static,
{
    pub fn data(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(input: Edge<T>, reduction: &str, num_devices: i64) -> Self {
        Self {
            phantom_T: PhantomData,
            input,
            reduction: reduction.to_string(),
            num_devices: num_devices,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(input: Edge<T>, reduction: &str, num_devices: i64) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            input,
            reduction: reduction.to_string(),
            num_devices: num_devices,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<T> GraphOperation for _NcclReduceSend<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_INT64_or_DT_HALF,
      T: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("_NcclReduceSend_{}")?
        };
        let mut new_op = graph.new_operation("_NcclReduceSend", &op_name)?;
        {
            new_op.add_edge(&self.input)?
        }
        {
            (|attr| {new_op.set_attr_string("reduction", attr)})(&self.reduction)?
        }
        {
            (|attr: &i64| {new_op.set_attr_int("num_devices", *attr)})(&self.num_devices)?
        }
        {
            (|attr| {new_op.set_attr_string("shared_name", attr)})(&self.shared_name)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct _NcclReduceSend<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_INT64_or_DT_HALF,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    input: Edge<T>,
    reduction: String,
    num_devices: i64,
    shared_name: String,
    op_name: Option<String>,
    id_: usize,
}

impl<T> _NcclReduceSend<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_INT64_or_DT_HALF,
      T: 'static,
{
    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> () {
        let rc = Rc::new(self);
        (
        )
    }

    pub fn build(input: Edge<T>, reduction: &str, num_devices: i64, shared_name: &str) -> Self {
        Self {
            phantom_T: PhantomData,
            input,
            reduction: reduction.to_string(),
            num_devices: num_devices,
            shared_name: shared_name.to_string(),
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(input: Edge<T>, reduction: &str, num_devices: i64, shared_name: &str) -> () {
        Self {
            phantom_T: PhantomData,
            input,
            reduction: reduction.to_string(),
            num_devices: num_devices,
            shared_name: shared_name.to_string(),
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl GraphOperation for SdcaShrinkL1 {
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("SdcaShrinkL1_{}")?
        };
        let mut new_op = graph.new_operation("SdcaShrinkL1", &op_name)?;
        {
            new_op.add_edge(&self.weights)?
        }
        {
            (|attr: &i64| {new_op.set_attr_int("num_features", *attr)})(&self.num_features)?
        }
        {
            (|attr: &f32| {new_op.set_attr_float("l1", *attr)})(&self.l1)?
        }
        {
            (|attr: &f32| {new_op.set_attr_float("l2", *attr)})(&self.l2)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct SdcaShrinkL1 {
    weights: Edge<f32>,
    num_features: i64,
    l1: f32,
    l2: f32,
    op_name: Option<String>,
    id_: usize,
}

impl SdcaShrinkL1 {
    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> () {
        let rc = Rc::new(self);
        (
        )
    }

    pub fn build(weights: Edge<f32>, num_features: i64, l1: f32, l2: f32) -> Self {
        Self {
            weights,
            num_features: num_features,
            l1: l1,
            l2: l2,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(weights: Edge<f32>, num_features: i64, l1: f32, l2: f32) -> () {
        Self {
            weights,
            num_features: num_features,
            l1: l1,
            l2: l2,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<T> GraphOperation for BitwiseAnd<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_UINT16_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("BitwiseAnd_{}")?
        };
        let mut new_op = graph.new_operation("BitwiseAnd", &op_name)?;
        {
            new_op.add_edge(&self.x)?
        }
        {
            new_op.add_edge(&self.y)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct BitwiseAnd<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_UINT16_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    x: Edge<T>,
    y: Edge<T>,
    op_name: Option<String>,
    id_: usize,
}

impl<T> BitwiseAnd<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_UINT16_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
{
    pub fn z(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(x: Edge<T>, y: Edge<T>) -> Self {
        Self {
            phantom_T: PhantomData,
            x,
            y,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(x: Edge<T>, y: Edge<T>) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            x,
            y,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<T> GraphOperation for _NcclReduceRecv<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_INT64_or_DT_HALF,
      T: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("_NcclReduceRecv_{}")?
        };
        let mut new_op = graph.new_operation("_NcclReduceRecv", &op_name)?;
        {
            new_op.add_edge(&self.input)?
        }
        {
            (|attr| {new_op.set_attr_string("reduction", attr)})(&self.reduction)?
        }
        {
            (|attr: &i64| {new_op.set_attr_int("num_devices", *attr)})(&self.num_devices)?
        }
        {
            (|attr| {new_op.set_attr_string("shared_name", attr)})(&self.shared_name)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct _NcclReduceRecv<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_INT64_or_DT_HALF,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    input: Edge<T>,
    reduction: String,
    num_devices: i64,
    shared_name: String,
    op_name: Option<String>,
    id_: usize,
}

impl<T> _NcclReduceRecv<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_INT64_or_DT_HALF,
      T: 'static,
{
    pub fn data(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(input: Edge<T>, reduction: &str, num_devices: i64, shared_name: &str) -> Self {
        Self {
            phantom_T: PhantomData,
            input,
            reduction: reduction.to_string(),
            num_devices: num_devices,
            shared_name: shared_name.to_string(),
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(input: Edge<T>, reduction: &str, num_devices: i64, shared_name: &str) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            input,
            reduction: reduction.to_string(),
            num_devices: num_devices,
            shared_name: shared_name.to_string(),
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<T> GraphOperation for _NcclBroadcastSend<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_INT64_or_DT_HALF,
      T: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("_NcclBroadcastSend_{}")?
        };
        let mut new_op = graph.new_operation("_NcclBroadcastSend", &op_name)?;
        {
            new_op.add_edge(&self.input)?
        }
        {
            (|attr: &i64| {new_op.set_attr_int("num_devices", *attr)})(&self.num_devices)?
        }
        {
            (|attr| {new_op.set_attr_string("shared_name", attr)})(&self.shared_name)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct _NcclBroadcastSend<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_INT64_or_DT_HALF,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    input: Edge<T>,
    num_devices: i64,
    shared_name: String,
    op_name: Option<String>,
    id_: usize,
}

impl<T> _NcclBroadcastSend<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_INT64_or_DT_HALF,
      T: 'static,
{
    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> () {
        let rc = Rc::new(self);
        (
        )
    }

    pub fn build(input: Edge<T>, num_devices: i64, shared_name: &str) -> Self {
        Self {
            phantom_T: PhantomData,
            input,
            num_devices: num_devices,
            shared_name: shared_name.to_string(),
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(input: Edge<T>, num_devices: i64, shared_name: &str) -> () {
        Self {
            phantom_T: PhantomData,
            input,
            num_devices: num_devices,
            shared_name: shared_name.to_string(),
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<T> GraphOperation for _NcclBroadcastRecv<T>
where T: TensorType,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_INT64_or_DT_HALF,
      T: 'static,
      T: Clone,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("_NcclBroadcastRecv_{}")?
        };
        let mut new_op = graph.new_operation("_NcclBroadcastRecv", &op_name)?;
        {
            new_op.add_edge(&self.shape)?
        }
        {
            (|attr: &i64| {new_op.set_attr_int("num_devices", *attr)})(&self.num_devices)?
        }
        {
            (|attr| {new_op.set_attr_string("shared_name", attr)})(&self.shared_name)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct _NcclBroadcastRecv<T>
where T: TensorType,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_INT64_or_DT_HALF,
      T: 'static,
      T: Clone,
{
    shape: Edge<i32>,
    phantom_T: PhantomData<T>,
    num_devices: i64,
    shared_name: String,
    op_name: Option<String>,
    id_: usize,
}

impl<T> _NcclBroadcastRecv<T>
where T: TensorType,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_INT64_or_DT_HALF,
      T: 'static,
      T: Clone,
{
    pub fn output(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(shape: Edge<i32>, num_devices: i64, shared_name: &str) -> Self {
        Self {
            shape,
            phantom_T: PhantomData,
            num_devices: num_devices,
            shared_name: shared_name.to_string(),
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(shape: Edge<i32>, num_devices: i64, shared_name: &str) -> Edge<T> {
        Self {
            shape,
            phantom_T: PhantomData,
            num_devices: num_devices,
            shared_name: shared_name.to_string(),
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl GraphOperation for ControlTrigger {
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("ControlTrigger_{}")?
        };
        let mut new_op = graph.new_operation("ControlTrigger", &op_name)?;
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct ControlTrigger {
    op_name: Option<String>,
    id_: usize,
}

impl ControlTrigger {
    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> () {
        let rc = Rc::new(self);
        (
        )
    }

    pub fn build() -> Self {
        Self {
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new() -> () {
        Self {
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<dtype> GraphOperation for TensorArrayReadV2<dtype>
where dtype: TensorType,
      dtype: 'static,
      dtype: Clone,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("TensorArrayReadV2_{}")?
        };
        let mut new_op = graph.new_operation("TensorArrayReadV2", &op_name)?;
        {
            new_op.add_edge(&self.handle)?
        }
        {
            new_op.add_edge(&self.index)?
        }
        {
            new_op.add_edge(&self.flow_in)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct TensorArrayReadV2<dtype>
where dtype: TensorType,
      dtype: 'static,
      dtype: Clone,
{
    handle: Edge<String>,
    index: Edge<i32>,
    flow_in: Edge<f32>,
    phantom_dtype: PhantomData<dtype>,
    op_name: Option<String>,
    id_: usize,
}

impl<dtype> TensorArrayReadV2<dtype>
where dtype: TensorType,
      dtype: 'static,
      dtype: Clone,
{
    pub fn value(self) -> Edge<dtype> {
        let rc = Rc::new(self);
        {
            Edge::<dtype>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<dtype> {
        let rc = Rc::new(self);
        {
            Edge::<dtype>::new(rc.clone(), 0)
        }
    }

    pub fn build(handle: Edge<String>, index: Edge<i32>, flow_in: Edge<f32>) -> Self {
        Self {
            handle,
            index,
            flow_in,
            phantom_dtype: PhantomData,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(handle: Edge<String>, index: Edge<i32>, flow_in: Edge<f32>) -> Edge<dtype> {
        Self {
            handle,
            index,
            flow_in,
            phantom_dtype: PhantomData,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<T> GraphOperation for BatchNormWithGlobalNormalization<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("BatchNormWithGlobalNormalization_{}")?
        };
        let mut new_op = graph.new_operation("BatchNormWithGlobalNormalization", &op_name)?;
        {
            new_op.add_edge(&self.t)?
        }
        {
            new_op.add_edge(&self.m)?
        }
        {
            new_op.add_edge(&self.v)?
        }
        {
            new_op.add_edge(&self.beta)?
        }
        {
            new_op.add_edge(&self.gamma)?
        }
        {
            (|attr: &f32| {new_op.set_attr_float("variance_epsilon", *attr)})(&self.variance_epsilon)?
        }
        {
            (|attr: &bool| {new_op.set_attr_bool("scale_after_normalization", *attr)})(&self.scale_after_normalization)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct BatchNormWithGlobalNormalization<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    t: Edge<T>,
    m: Edge<T>,
    v: Edge<T>,
    beta: Edge<T>,
    gamma: Edge<T>,
    variance_epsilon: f32,
    scale_after_normalization: bool,
    op_name: Option<String>,
    id_: usize,
}

impl<T> BatchNormWithGlobalNormalization<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
{
    pub fn result(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(t: Edge<T>, m: Edge<T>, v: Edge<T>, beta: Edge<T>, gamma: Edge<T>, variance_epsilon: f32, scale_after_normalization: bool) -> Self {
        Self {
            phantom_T: PhantomData,
            t,
            m,
            v,
            beta,
            gamma,
            variance_epsilon: variance_epsilon,
            scale_after_normalization: scale_after_normalization,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(t: Edge<T>, m: Edge<T>, v: Edge<T>, beta: Edge<T>, gamma: Edge<T>, variance_epsilon: f32, scale_after_normalization: bool) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            t,
            m,
            v,
            beta,
            gamma,
            variance_epsilon: variance_epsilon,
            scale_after_normalization: scale_after_normalization,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<T> GraphOperation for FusedBatchNorm<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT,
      T: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("FusedBatchNorm_{}")?
        };
        let mut new_op = graph.new_operation("FusedBatchNorm", &op_name)?;
        {
            new_op.add_edge(&self.x)?
        }
        {
            new_op.add_edge(&self.scale)?
        }
        {
            new_op.add_edge(&self.offset)?
        }
        {
            new_op.add_edge(&self.mean)?
        }
        {
            new_op.add_edge(&self.variance)?
        }
        {
            match self.epsilon {
                None => new_op.set_attr_value_proto("epsilon", &vec![37_u8, 23_u8, 183_u8, 209_u8, 56_u8,])?,
                Some(ref value) => (|attr: &f32| {new_op.set_attr_float("epsilon", *attr)})(&value)?,
            };
        }
        {
            match self.data_format {
                None => new_op.set_attr_value_proto("data_format", &vec![18_u8, 4_u8, 78_u8, 72_u8, 87_u8, 67_u8,])?,
                Some(ref value) => (|attr| {new_op.set_attr_string("data_format", attr)})(&value)?,
            };
        }
        {
            match self.is_training {
                None => new_op.set_attr_value_proto("is_training", &vec![40_u8, 1_u8,])?,
                Some(ref value) => (|attr: &bool| {new_op.set_attr_bool("is_training", *attr)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct FusedBatchNorm<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    x: Edge<T>,
    scale: Edge<T>,
    offset: Edge<T>,
    mean: Edge<T>,
    variance: Edge<T>,
    epsilon: Option<f32>,
    data_format: Option<String>,
    is_training: Option<bool>,
    op_name: Option<String>,
    id_: usize,
}

impl<T> FusedBatchNorm<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT,
      T: 'static,
{
    pub fn y(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn batch_mean(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 1)
        }
    }

    pub fn batch_variance(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 2)
        }
    }

    pub fn reserve_space_1(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 3)
        }
    }

    pub fn reserve_space_2(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 4)
        }
    }

    pub fn epsilon(&mut self, epsilon: f32) -> Self {
        self.epsilon = Some(epsilon);
        self.clone()
    }

    pub fn data_format(&mut self, data_format: &str) -> Self {
        self.data_format = Some(data_format.to_string());
        self.clone()
    }

    pub fn is_training(&mut self, is_training: bool) -> Self {
        self.is_training = Some(is_training);
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> (Edge<T>, Edge<T>, Edge<T>, Edge<T>, Edge<T>) {
        let rc = Rc::new(self);
        (
        {
            Edge::<T>::new(rc.clone(), 0)
        },
        {
            Edge::<T>::new(rc.clone(), 1)
        },
        {
            Edge::<T>::new(rc.clone(), 2)
        },
        {
            Edge::<T>::new(rc.clone(), 3)
        },
        {
            Edge::<T>::new(rc.clone(), 4)
        },
        )
    }

    pub fn build(x: Edge<T>, scale: Edge<T>, offset: Edge<T>, mean: Edge<T>, variance: Edge<T>) -> Self {
        Self {
            phantom_T: PhantomData,
            x,
            scale,
            offset,
            mean,
            variance,
            epsilon: None,
            data_format: None,
            is_training: None,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(x: Edge<T>, scale: Edge<T>, offset: Edge<T>, mean: Edge<T>, variance: Edge<T>) -> (Edge<T>, Edge<T>, Edge<T>, Edge<T>, Edge<T>) {
        Self {
            phantom_T: PhantomData,
            x,
            scale,
            offset,
            mean,
            variance,
            epsilon: None,
            data_format: None,
            is_training: None,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<T> GraphOperation for DebugIdentity<T>
where T: TensorType,
      T: Clone,
      T: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("DebugIdentity_{}")?
        };
        let mut new_op = graph.new_operation("DebugIdentity", &op_name)?;
        {
            new_op.add_edge(&self.input)?
        }
        {
            match self.device_name {
                None => new_op.set_attr_value_proto("device_name", &vec![18_u8, 0_u8,])?,
                Some(ref value) => (|attr| {new_op.set_attr_string("device_name", attr)})(&value)?,
            };
        }
        {
            match self.tensor_name {
                None => new_op.set_attr_value_proto("tensor_name", &vec![18_u8, 0_u8,])?,
                Some(ref value) => (|attr| {new_op.set_attr_string("tensor_name", attr)})(&value)?,
            };
        }
        {
            match self.debug_urls {
                None => new_op.set_attr_value_proto("debug_urls", &vec![10_u8, 0_u8,])?,
                Some(ref value) => (|attrs| {new_op.set_attr_string_list("debug_urls", attrs)})(&value)?,
            };
        }
        {
            match self.gated_grpc {
                None => new_op.set_attr_value_proto("gated_grpc", &vec![40_u8, 0_u8,])?,
                Some(ref value) => (|attr: &bool| {new_op.set_attr_bool("gated_grpc", *attr)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct DebugIdentity<T>
where T: TensorType,
      T: Clone,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    input: Edge<T>,
    device_name: Option<String>,
    tensor_name: Option<String>,
    debug_urls: Option<Vec<String>>,
    gated_grpc: Option<bool>,
    op_name: Option<String>,
    id_: usize,
}

impl<T> DebugIdentity<T>
where T: TensorType,
      T: Clone,
      T: 'static,
{
    pub fn output(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn device_name(&mut self, device_name: &str) -> Self {
        self.device_name = Some(device_name.to_string());
        self.clone()
    }

    pub fn tensor_name(&mut self, tensor_name: &str) -> Self {
        self.tensor_name = Some(tensor_name.to_string());
        self.clone()
    }

    pub fn debug_urls(&mut self, debug_urls: &[String]) -> Self {
        self.debug_urls = Some(debug_urls.to_vec());
        self.clone()
    }

    pub fn gated_grpc(&mut self, gated_grpc: bool) -> Self {
        self.gated_grpc = Some(gated_grpc);
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(input: Edge<T>) -> Self {
        Self {
            phantom_T: PhantomData,
            input,
            device_name: None,
            tensor_name: None,
            debug_urls: None,
            gated_grpc: None,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(input: Edge<T>) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            input,
            device_name: None,
            tensor_name: None,
            debug_urls: None,
            gated_grpc: None,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<T, U> GraphOperation for FusedBatchNormV2<T, U>
where T: TensorType,
      T: Clone,
      U: TensorType,
      U: Clone,
      T: con_or_DT_FLOAT_or_DT_BFLOAT16_or_DT_HALF,
      T: 'static,
      U: con_or_DT_FLOAT,
      U: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("FusedBatchNormV2_{}")?
        };
        let mut new_op = graph.new_operation("FusedBatchNormV2", &op_name)?;
        {
            new_op.add_edge(&self.x)?
        }
        {
            new_op.add_edge(&self.scale)?
        }
        {
            new_op.add_edge(&self.offset)?
        }
        {
            new_op.add_edge(&self.mean)?
        }
        {
            new_op.add_edge(&self.variance)?
        }
        {
            match self.epsilon {
                None => new_op.set_attr_value_proto("epsilon", &vec![37_u8, 23_u8, 183_u8, 209_u8, 56_u8,])?,
                Some(ref value) => (|attr: &f32| {new_op.set_attr_float("epsilon", *attr)})(&value)?,
            };
        }
        {
            match self.data_format {
                None => new_op.set_attr_value_proto("data_format", &vec![18_u8, 4_u8, 78_u8, 72_u8, 87_u8, 67_u8,])?,
                Some(ref value) => (|attr| {new_op.set_attr_string("data_format", attr)})(&value)?,
            };
        }
        {
            match self.is_training {
                None => new_op.set_attr_value_proto("is_training", &vec![40_u8, 1_u8,])?,
                Some(ref value) => (|attr: &bool| {new_op.set_attr_bool("is_training", *attr)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct FusedBatchNormV2<T, U>
where T: TensorType,
      T: Clone,
      U: TensorType,
      U: Clone,
      T: con_or_DT_FLOAT_or_DT_BFLOAT16_or_DT_HALF,
      T: 'static,
      U: con_or_DT_FLOAT,
      U: 'static,
{
    phantom_T: PhantomData<T>,
    x: Edge<T>,
    phantom_U: PhantomData<U>,
    scale: Edge<U>,
    offset: Edge<U>,
    mean: Edge<U>,
    variance: Edge<U>,
    epsilon: Option<f32>,
    data_format: Option<String>,
    is_training: Option<bool>,
    op_name: Option<String>,
    id_: usize,
}

impl<T, U> FusedBatchNormV2<T, U>
where T: TensorType,
      T: Clone,
      U: TensorType,
      U: Clone,
      T: con_or_DT_FLOAT_or_DT_BFLOAT16_or_DT_HALF,
      T: 'static,
      U: con_or_DT_FLOAT,
      U: 'static,
{
    pub fn y(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn batch_mean(self) -> Edge<U> {
        let rc = Rc::new(self);
        {
            Edge::<U>::new(rc.clone(), 1)
        }
    }

    pub fn batch_variance(self) -> Edge<U> {
        let rc = Rc::new(self);
        {
            Edge::<U>::new(rc.clone(), 2)
        }
    }

    pub fn reserve_space_1(self) -> Edge<U> {
        let rc = Rc::new(self);
        {
            Edge::<U>::new(rc.clone(), 3)
        }
    }

    pub fn reserve_space_2(self) -> Edge<U> {
        let rc = Rc::new(self);
        {
            Edge::<U>::new(rc.clone(), 4)
        }
    }

    pub fn epsilon(&mut self, epsilon: f32) -> Self {
        self.epsilon = Some(epsilon);
        self.clone()
    }

    pub fn data_format(&mut self, data_format: &str) -> Self {
        self.data_format = Some(data_format.to_string());
        self.clone()
    }

    pub fn is_training(&mut self, is_training: bool) -> Self {
        self.is_training = Some(is_training);
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> (Edge<T>, Edge<U>, Edge<U>, Edge<U>, Edge<U>) {
        let rc = Rc::new(self);
        (
        {
            Edge::<T>::new(rc.clone(), 0)
        },
        {
            Edge::<U>::new(rc.clone(), 1)
        },
        {
            Edge::<U>::new(rc.clone(), 2)
        },
        {
            Edge::<U>::new(rc.clone(), 3)
        },
        {
            Edge::<U>::new(rc.clone(), 4)
        },
        )
    }

    pub fn build(x: Edge<T>, scale: Edge<U>, offset: Edge<U>, mean: Edge<U>, variance: Edge<U>) -> Self {
        Self {
            phantom_T: PhantomData,
            x,
            phantom_U: PhantomData,
            scale,
            offset,
            mean,
            variance,
            epsilon: None,
            data_format: None,
            is_training: None,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(x: Edge<T>, scale: Edge<U>, offset: Edge<U>, mean: Edge<U>, variance: Edge<U>) -> (Edge<T>, Edge<U>, Edge<U>, Edge<U>, Edge<U>) {
        Self {
            phantom_T: PhantomData,
            x,
            phantom_U: PhantomData,
            scale,
            offset,
            mean,
            variance,
            epsilon: None,
            data_format: None,
            is_training: None,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<T> GraphOperation for Cos<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_COMPLEX64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF,
      T: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("Cos_{}")?
        };
        let mut new_op = graph.new_operation("Cos", &op_name)?;
        {
            new_op.add_edge(&self.x)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct Cos<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_COMPLEX64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    x: Edge<T>,
    op_name: Option<String>,
    id_: usize,
}

impl<T> Cos<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_COMPLEX64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF,
      T: 'static,
{
    pub fn y(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(x: Edge<T>) -> Self {
        Self {
            phantom_T: PhantomData,
            x,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(x: Edge<T>) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            x,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<T> GraphOperation for FusedBatchNormGrad<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT,
      T: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("FusedBatchNormGrad_{}")?
        };
        let mut new_op = graph.new_operation("FusedBatchNormGrad", &op_name)?;
        {
            new_op.add_edge(&self.y_backprop)?
        }
        {
            new_op.add_edge(&self.x)?
        }
        {
            new_op.add_edge(&self.scale)?
        }
        {
            new_op.add_edge(&self.reserve_space_1)?
        }
        {
            new_op.add_edge(&self.reserve_space_2)?
        }
        {
            match self.epsilon {
                None => new_op.set_attr_value_proto("epsilon", &vec![37_u8, 23_u8, 183_u8, 209_u8, 56_u8,])?,
                Some(ref value) => (|attr: &f32| {new_op.set_attr_float("epsilon", *attr)})(&value)?,
            };
        }
        {
            match self.data_format {
                None => new_op.set_attr_value_proto("data_format", &vec![18_u8, 4_u8, 78_u8, 72_u8, 87_u8, 67_u8,])?,
                Some(ref value) => (|attr| {new_op.set_attr_string("data_format", attr)})(&value)?,
            };
        }
        {
            match self.is_training {
                None => new_op.set_attr_value_proto("is_training", &vec![40_u8, 1_u8,])?,
                Some(ref value) => (|attr: &bool| {new_op.set_attr_bool("is_training", *attr)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct FusedBatchNormGrad<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    y_backprop: Edge<T>,
    x: Edge<T>,
    scale: Edge<T>,
    reserve_space_1: Edge<T>,
    reserve_space_2: Edge<T>,
    epsilon: Option<f32>,
    data_format: Option<String>,
    is_training: Option<bool>,
    op_name: Option<String>,
    id_: usize,
}

impl<T> FusedBatchNormGrad<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT,
      T: 'static,
{
    pub fn x_backprop(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn scale_backprop(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 1)
        }
    }

    pub fn offset_backprop(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 2)
        }
    }

    pub fn reserve_space_3(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 3)
        }
    }

    pub fn reserve_space_4(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 4)
        }
    }

    pub fn epsilon(&mut self, epsilon: f32) -> Self {
        self.epsilon = Some(epsilon);
        self.clone()
    }

    pub fn data_format(&mut self, data_format: &str) -> Self {
        self.data_format = Some(data_format.to_string());
        self.clone()
    }

    pub fn is_training(&mut self, is_training: bool) -> Self {
        self.is_training = Some(is_training);
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> (Edge<T>, Edge<T>, Edge<T>, Edge<T>, Edge<T>) {
        let rc = Rc::new(self);
        (
        {
            Edge::<T>::new(rc.clone(), 0)
        },
        {
            Edge::<T>::new(rc.clone(), 1)
        },
        {
            Edge::<T>::new(rc.clone(), 2)
        },
        {
            Edge::<T>::new(rc.clone(), 3)
        },
        {
            Edge::<T>::new(rc.clone(), 4)
        },
        )
    }

    pub fn build(y_backprop: Edge<T>, x: Edge<T>, scale: Edge<T>, reserve_space_1: Edge<T>, reserve_space_2: Edge<T>) -> Self {
        Self {
            phantom_T: PhantomData,
            y_backprop,
            x,
            scale,
            reserve_space_1,
            reserve_space_2,
            epsilon: None,
            data_format: None,
            is_training: None,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(y_backprop: Edge<T>, x: Edge<T>, scale: Edge<T>, reserve_space_1: Edge<T>, reserve_space_2: Edge<T>) -> (Edge<T>, Edge<T>, Edge<T>, Edge<T>, Edge<T>) {
        Self {
            phantom_T: PhantomData,
            y_backprop,
            x,
            scale,
            reserve_space_1,
            reserve_space_2,
            epsilon: None,
            data_format: None,
            is_training: None,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

pub trait con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_STRING_or_DT_COMPLEX64_or_DT_INT64_or_DT_BOOL_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_STRING_or_DT_COMPLEX64_or_DT_INT64_or_DT_BOOL_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF for BFloat16 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_STRING_or_DT_COMPLEX64_or_DT_INT64_or_DT_BOOL_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF for OtherComplex<f32> {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_STRING_or_DT_COMPLEX64_or_DT_INT64_or_DT_BOOL_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF for OtherComplex<f64> {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_STRING_or_DT_COMPLEX64_or_DT_INT64_or_DT_BOOL_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF for String {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_STRING_or_DT_COMPLEX64_or_DT_INT64_or_DT_BOOL_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF for bool {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_STRING_or_DT_COMPLEX64_or_DT_INT64_or_DT_BOOL_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF for f32 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_STRING_or_DT_COMPLEX64_or_DT_INT64_or_DT_BOOL_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF for f64 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_STRING_or_DT_COMPLEX64_or_DT_INT64_or_DT_BOOL_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF for i16 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_STRING_or_DT_COMPLEX64_or_DT_INT64_or_DT_BOOL_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF for i32 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_STRING_or_DT_COMPLEX64_or_DT_INT64_or_DT_BOOL_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF for i64 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_STRING_or_DT_COMPLEX64_or_DT_INT64_or_DT_BOOL_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF for i8 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_STRING_or_DT_COMPLEX64_or_DT_INT64_or_DT_BOOL_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF for u16 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_STRING_or_DT_COMPLEX64_or_DT_INT64_or_DT_BOOL_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF for u8 {
}

impl<T, Tidx> GraphOperation for ReverseV2<T, Tidx>
where T: TensorType,
      T: Clone,
      Tidx: TensorType,
      Tidx: Clone,
      Tidx: con_or_DT_INT32_or_DT_INT64,
      Tidx: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_STRING_or_DT_COMPLEX64_or_DT_INT64_or_DT_BOOL_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF,
      T: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("ReverseV2_{}")?
        };
        let mut new_op = graph.new_operation("ReverseV2", &op_name)?;
        {
            new_op.add_edge(&self.tensor)?
        }
        {
            new_op.add_edge(&self.axis)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct ReverseV2<T, Tidx>
where T: TensorType,
      T: Clone,
      Tidx: TensorType,
      Tidx: Clone,
      Tidx: con_or_DT_INT32_or_DT_INT64,
      Tidx: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_STRING_or_DT_COMPLEX64_or_DT_INT64_or_DT_BOOL_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    tensor: Edge<T>,
    phantom_Tidx: PhantomData<Tidx>,
    axis: Edge<Tidx>,
    op_name: Option<String>,
    id_: usize,
}

impl<T, Tidx> ReverseV2<T, Tidx>
where T: TensorType,
      T: Clone,
      Tidx: TensorType,
      Tidx: Clone,
      Tidx: con_or_DT_INT32_or_DT_INT64,
      Tidx: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_STRING_or_DT_COMPLEX64_or_DT_INT64_or_DT_BOOL_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF,
      T: 'static,
{
    pub fn output(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(tensor: Edge<T>, axis: Edge<Tidx>) -> Self {
        Self {
            phantom_T: PhantomData,
            tensor,
            phantom_Tidx: PhantomData,
            axis,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(tensor: Edge<T>, axis: Edge<Tidx>) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            tensor,
            phantom_Tidx: PhantomData,
            axis,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<T> GraphOperation for BiasAddV1<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("BiasAddV1_{}")?
        };
        let mut new_op = graph.new_operation("BiasAddV1", &op_name)?;
        {
            new_op.add_edge(&self.value)?
        }
        {
            new_op.add_edge(&self.bias)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct BiasAddV1<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    value: Edge<T>,
    bias: Edge<T>,
    op_name: Option<String>,
    id_: usize,
}

impl<T> BiasAddV1<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
{
    pub fn output(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(value: Edge<T>, bias: Edge<T>) -> Self {
        Self {
            phantom_T: PhantomData,
            value,
            bias,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(value: Edge<T>, bias: Edge<T>) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            value,
            bias,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<T> GraphOperation for FusedPadConv2D<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_HALF,
      T: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("FusedPadConv2D_{}")?
        };
        let mut new_op = graph.new_operation("FusedPadConv2D", &op_name)?;
        {
            new_op.add_edge(&self.input)?
        }
        {
            new_op.add_edge(&self.paddings)?
        }
        {
            new_op.add_edge(&self.filter)?
        }
        {
            (|attr| {new_op.set_attr_string("mode", attr)})(&self.mode)?
        }
        {
            (|attrs| {new_op.set_attr_int_list("strides", attrs)})(&self.strides)?
        }
        {
            (|attr| {new_op.set_attr_string("padding", attr)})(&self.padding)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct FusedPadConv2D<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_HALF,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    input: Edge<T>,
    paddings: Edge<i32>,
    filter: Edge<T>,
    mode: String,
    strides: Vec<i64>,
    padding: String,
    op_name: Option<String>,
    id_: usize,
}

impl<T> FusedPadConv2D<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_HALF,
      T: 'static,
{
    pub fn output(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(input: Edge<T>, paddings: Edge<i32>, filter: Edge<T>, mode: &str, strides: &[i64], padding: &str) -> Self {
        Self {
            phantom_T: PhantomData,
            input,
            paddings,
            filter,
            mode: mode.to_string(),
            strides: strides.to_vec(),
            padding: padding.to_string(),
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(input: Edge<T>, paddings: Edge<i32>, filter: Edge<T>, mode: &str, strides: &[i64], padding: &str) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            input,
            paddings,
            filter,
            mode: mode.to_string(),
            strides: strides.to_vec(),
            padding: padding.to_string(),
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<T> GraphOperation for DynamicStitch<T>
where T: TensorType,
      T: Clone,
      T: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("DynamicStitch_{}")?
        };
        let mut new_op = graph.new_operation("DynamicStitch", &op_name)?;
        {
            new_op.add_edge(&self.indices)?
        }
        {
            new_op.add_edge(&self.data)?
        }
        {
            (|attr: &i64| {new_op.set_attr_int("N", *attr)})(&self.N)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct DynamicStitch<T>
where T: TensorType,
      T: Clone,
      T: 'static,
{
    indices: Edge<i32>,
    phantom_T: PhantomData<T>,
    data: Edge<T>,
    N: i64,
    op_name: Option<String>,
    id_: usize,
}

impl<T> DynamicStitch<T>
where T: TensorType,
      T: Clone,
      T: 'static,
{
    pub fn merged(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(indices: Edge<i32>, data: Edge<T>, N: i64) -> Self {
        Self {
            indices,
            phantom_T: PhantomData,
            data,
            N: N,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(indices: Edge<i32>, data: Edge<T>, N: i64) -> Edge<T> {
        Self {
            indices,
            phantom_T: PhantomData,
            data,
            N: N,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}

impl<T> GraphOperation for Conv2DBackpropInput<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
      T: 'static,
{
    fn get_id(&self) -> usize {
        self.id_
    }

    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("Conv2DBackpropInput_{}")?
        };
        let mut new_op = graph.new_operation("Conv2DBackpropInput", &op_name)?;
        {
            new_op.add_edge(&self.input_sizes)?
        }
        {
            new_op.add_edge(&self.filter)?
        }
        {
            new_op.add_edge(&self.out_backprop)?
        }
        {
            (|attrs| {new_op.set_attr_int_list("strides", attrs)})(&self.strides)?
        }
        {
            match self.use_cudnn_on_gpu {
                None => new_op.set_attr_value_proto("use_cudnn_on_gpu", &vec![40_u8, 1_u8,])?,
                Some(ref value) => (|attr: &bool| {new_op.set_attr_bool("use_cudnn_on_gpu", *attr)})(&value)?,
            };
        }
        {
            (|attr| {new_op.set_attr_string("padding", attr)})(&self.padding)?
        }
        {
            match self.data_format {
                None => new_op.set_attr_value_proto("data_format", &vec![18_u8, 4_u8, 78_u8, 72_u8, 87_u8, 67_u8,])?,
                Some(ref value) => (|attr| {new_op.set_attr_string("data_format", attr)})(&value)?,
            };
        }
        {
            match self.dilations {
                None => new_op.set_attr_value_proto("dilations", &vec![10_u8, 0_u8, 26_u8, 4_u8,])?,
                Some(ref value) => (|attrs| {new_op.set_attr_int_list("dilations", attrs)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
struct Conv2DBackpropInput<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
      T: 'static,
{
    input_sizes: Edge<i32>,
    phantom_T: PhantomData<T>,
    filter: Edge<T>,
    out_backprop: Edge<T>,
    strides: Vec<i64>,
    use_cudnn_on_gpu: Option<bool>,
    padding: String,
    data_format: Option<String>,
    dilations: Option<Vec<i64>>,
    op_name: Option<String>,
    id_: usize,
}

impl<T> Conv2DBackpropInput<T>
where T: TensorType,
      T: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
      T: 'static,
{
    pub fn output(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn use_cudnn_on_gpu(&mut self, use_cudnn_on_gpu: bool) -> Self {
        self.use_cudnn_on_gpu = Some(use_cudnn_on_gpu);
        self.clone()
    }

    pub fn data_format(&mut self, data_format: &str) -> Self {
        self.data_format = Some(data_format.to_string());
        self.clone()
    }

    pub fn dilations(&mut self, dilations: &[i64]) -> Self {
        self.dilations = Some(dilations.to_vec());
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(input_sizes: Edge<i32>, filter: Edge<T>, out_backprop: Edge<T>, strides: &[i64], padding: &str) -> Self {
        Self {
            input_sizes,
            phantom_T: PhantomData,
            filter,
            out_backprop,
            strides: strides.to_vec(),
            use_cudnn_on_gpu: None,
            padding: padding.to_string(),
            data_format: None,
            dilations: None,
            op_name: None,
            id_: new_id(),
        }
    }

    pub fn new(input_sizes: Edge<i32>, filter: Edge<T>, out_backprop: Edge<T>, strides: &[i64], padding: &str) -> Edge<T> {
        Self {
            input_sizes,
            phantom_T: PhantomData,
            filter,
            out_backprop,
            strides: strides.to_vec(),
            use_cudnn_on_gpu: None,
            padding: padding.to_string(),
            data_format: None,
            dilations: None,
            op_name: None,
            id_: new_id(),
        }.finish()
    }
}