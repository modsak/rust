#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(dead_code)]
#![allow(non_camel_case_types)]
#![allow(missing_debug_implementations)]
#![allow(unused_variables)]
#![allow(unused_mut)]
use super::graph::{Graph, GraphOperation, Operation, Edge, RefEdge, GraphEdge, GraphRefEdge};
use super::{Shape as OtherShape, new_id, TensorType, BFloat16, Tensor, AnyTensor, Result};
use num_complex::Complex as OtherComplex;
use std::rc::Rc;
use std::{f32, f64};
use std::convert::From;
use std::marker::PhantomData;

impl GraphOperation for GenerateBigQueryReaderPartitions {
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("GenerateBigQueryReaderPartitions_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("GenerateBigQueryReaderPartitions", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            (|attr| {new_op.set_attr_string("project_id", attr)})(&self.project_id)?
        }
        {
            (|attr| {new_op.set_attr_string("dataset_id", attr)})(&self.dataset_id)?
        }
        {
            (|attr| {new_op.set_attr_string("table_id", attr)})(&self.table_id)?
        }
        {
            (|attrs| {new_op.set_attr_string_list("columns", attrs)})(&self.columns)?
        }
        {
            (|attr: &i64| {new_op.set_attr_int("timestamp_millis", *attr)})(&self.timestamp_millis)?
        }
        {
            (|attr: &i64| {new_op.set_attr_int("num_partitions", *attr)})(&self.num_partitions)?
        }
        {
            match self.test_end_point {
                None => new_op.set_attr_value_proto("test_end_point", &vec![18_u8, 0_u8,])?,
                Some(ref value) => (|attr| {new_op.set_attr_string("test_end_point", attr)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct GenerateBigQueryReaderPartitions {
    project_id: String,
    dataset_id: String,
    table_id: String,
    columns: Vec<String>,
    timestamp_millis: i64,
    num_partitions: i64,
    test_end_point: Option<String>,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl GenerateBigQueryReaderPartitions {
    pub fn partitions(self) -> Edge<String> {
        let rc = Rc::new(self);
        {
            Edge::<String>::new(rc.clone(), 0)
        }
    }

    pub fn test_end_point(&mut self, test_end_point: &str) -> Self {
        self.test_end_point = Some(test_end_point.to_string());
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<String> {
        let rc = Rc::new(self);
        {
            Edge::<String>::new(rc.clone(), 0)
        }
    }

    pub fn build(project_id: &str, dataset_id: &str, table_id: &str, columns: &[String], timestamp_millis: i64, num_partitions: i64) -> Self {
        Self {
            project_id: project_id.to_string(),
            dataset_id: dataset_id.to_string(),
            table_id: table_id.to_string(),
            columns: columns.to_vec(),
            timestamp_millis: timestamp_millis,
            num_partitions: num_partitions,
            test_end_point: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(project_id: &str, dataset_id: &str, table_id: &str, columns: &[String], timestamp_millis: i64, num_partitions: i64) -> Edge<String> {
        Self {
            project_id: project_id.to_string(),
            dataset_id: dataset_id.to_string(),
            table_id: table_id.to_string(),
            columns: columns.to_vec(),
            timestamp_millis: timestamp_millis,
            num_partitions: num_partitions,
            test_end_point: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl GraphOperation for Skipgram {
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("Skipgram_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("Skipgram", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            (|attr| {new_op.set_attr_string("filename", attr)})(&self.filename)?
        }
        {
            (|attr: &i64| {new_op.set_attr_int("batch_size", *attr)})(&self.batch_size)?
        }
        {
            match self.window_size {
                None => new_op.set_attr_value_proto("window_size", &vec![24_u8, 5_u8,])?,
                Some(ref value) => (|attr: &i64| {new_op.set_attr_int("window_size", *attr)})(&value)?,
            };
        }
        {
            match self.min_count {
                None => new_op.set_attr_value_proto("min_count", &vec![24_u8, 5_u8,])?,
                Some(ref value) => (|attr: &i64| {new_op.set_attr_int("min_count", *attr)})(&value)?,
            };
        }
        {
            match self.subsample {
                None => new_op.set_attr_value_proto("subsample", &vec![37_u8, 111_u8, 18_u8, 131_u8, 58_u8,])?,
                Some(ref value) => (|attr: &f32| {new_op.set_attr_float("subsample", *attr)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct Skipgram {
    filename: String,
    batch_size: i64,
    window_size: Option<i64>,
    min_count: Option<i64>,
    subsample: Option<f32>,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl Skipgram {
    pub fn vocab_word(self) -> Edge<String> {
        let rc = Rc::new(self);
        {
            Edge::<String>::new(rc.clone(), 0)
        }
    }

    pub fn vocab_freq(self) -> Edge<i32> {
        let rc = Rc::new(self);
        {
            Edge::<i32>::new(rc.clone(), 1)
        }
    }

    pub fn words_per_epoch(self) -> Edge<i64> {
        let rc = Rc::new(self);
        {
            Edge::<i64>::new(rc.clone(), 2)
        }
    }

    pub fn current_epoch(self) -> Edge<i32> {
        let rc = Rc::new(self);
        {
            Edge::<i32>::new(rc.clone(), 3)
        }
    }

    pub fn total_words_processed(self) -> Edge<i64> {
        let rc = Rc::new(self);
        {
            Edge::<i64>::new(rc.clone(), 4)
        }
    }

    pub fn examples(self) -> Edge<i32> {
        let rc = Rc::new(self);
        {
            Edge::<i32>::new(rc.clone(), 5)
        }
    }

    pub fn labels(self) -> Edge<i32> {
        let rc = Rc::new(self);
        {
            Edge::<i32>::new(rc.clone(), 6)
        }
    }

    pub fn window_size(&mut self, window_size: i64) -> Self {
        self.window_size = Some(window_size);
        self.clone()
    }

    pub fn min_count(&mut self, min_count: i64) -> Self {
        self.min_count = Some(min_count);
        self.clone()
    }

    pub fn subsample(&mut self, subsample: f32) -> Self {
        self.subsample = Some(subsample);
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> (Edge<String>, Edge<i32>, Edge<i64>, Edge<i32>, Edge<i64>, Edge<i32>, Edge<i32>) {
        let rc = Rc::new(self);
        (
        {
            Edge::<String>::new(rc.clone(), 0)
        },
        {
            Edge::<i32>::new(rc.clone(), 1)
        },
        {
            Edge::<i64>::new(rc.clone(), 2)
        },
        {
            Edge::<i32>::new(rc.clone(), 3)
        },
        {
            Edge::<i64>::new(rc.clone(), 4)
        },
        {
            Edge::<i32>::new(rc.clone(), 5)
        },
        {
            Edge::<i32>::new(rc.clone(), 6)
        },
        )
    }

    pub fn build(filename: &str, batch_size: i64) -> Self {
        Self {
            filename: filename.to_string(),
            batch_size: batch_size,
            window_size: None,
            min_count: None,
            subsample: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(filename: &str, batch_size: i64) -> (Edge<String>, Edge<i32>, Edge<i64>, Edge<i32>, Edge<i64>, Edge<i32>, Edge<i32>) {
        Self {
            filename: filename.to_string(),
            batch_size: batch_size,
            window_size: None,
            min_count: None,
            subsample: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

pub trait con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64 for BFloat16 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64 for OtherComplex<f32> {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64 for OtherComplex<f64> {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64 for f32 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64 for f64 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64 for i16 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64 for i32 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64 for i64 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64 for i8 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64 for u16 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64 for u32 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64 for u64 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64 for u8 {
}

impl<T, var_Arg, m_Arg, lr_Arg, logbase_Arg, sign_decay_Arg, beta_Arg, grad_Arg> GraphOperation for ApplyPowerSign<T, var_Arg, m_Arg, lr_Arg, logbase_Arg, sign_decay_Arg, beta_Arg, grad_Arg>
where T: TensorType,
      T: Clone,
      var_Arg: Clone,
      var_Arg: GraphRefEdge<T>,
      var_Arg: 'static,
      m_Arg: Clone,
      m_Arg: GraphRefEdge<T>,
      m_Arg: 'static,
      lr_Arg: Clone,
      lr_Arg: GraphEdge<T>,
      lr_Arg: 'static,
      logbase_Arg: Clone,
      logbase_Arg: GraphEdge<T>,
      logbase_Arg: 'static,
      sign_decay_Arg: Clone,
      sign_decay_Arg: GraphEdge<T>,
      sign_decay_Arg: 'static,
      beta_Arg: Clone,
      beta_Arg: GraphEdge<T>,
      beta_Arg: 'static,
      grad_Arg: Clone,
      grad_Arg: GraphEdge<T>,
      grad_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("ApplyPowerSign_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("ApplyPowerSign", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.var)?
        }
        {
            new_op.add_edge(&self.m)?
        }
        {
            new_op.add_edge(&self.lr)?
        }
        {
            new_op.add_edge(&self.logbase)?
        }
        {
            new_op.add_edge(&self.sign_decay)?
        }
        {
            new_op.add_edge(&self.beta)?
        }
        {
            new_op.add_edge(&self.grad)?
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        {
            match self.use_locking {
                None => new_op.set_attr_value_proto("use_locking", &vec![40_u8, 0_u8,])?,
                Some(ref value) => (|attr: &bool| {new_op.set_attr_bool("use_locking", *attr)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct ApplyPowerSign<T, var_Arg, m_Arg, lr_Arg, logbase_Arg, sign_decay_Arg, beta_Arg, grad_Arg>
where T: TensorType,
      T: Clone,
      var_Arg: Clone,
      var_Arg: GraphRefEdge<T>,
      var_Arg: 'static,
      m_Arg: Clone,
      m_Arg: GraphRefEdge<T>,
      m_Arg: 'static,
      lr_Arg: Clone,
      lr_Arg: GraphEdge<T>,
      lr_Arg: 'static,
      logbase_Arg: Clone,
      logbase_Arg: GraphEdge<T>,
      logbase_Arg: 'static,
      sign_decay_Arg: Clone,
      sign_decay_Arg: GraphEdge<T>,
      sign_decay_Arg: 'static,
      beta_Arg: Clone,
      beta_Arg: GraphEdge<T>,
      beta_Arg: 'static,
      grad_Arg: Clone,
      grad_Arg: GraphEdge<T>,
      grad_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    var: var_Arg,
    m: m_Arg,
    lr: lr_Arg,
    logbase: logbase_Arg,
    sign_decay: sign_decay_Arg,
    beta: beta_Arg,
    grad: grad_Arg,
    use_locking: Option<bool>,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<T, var_Arg, m_Arg, lr_Arg, logbase_Arg, sign_decay_Arg, beta_Arg, grad_Arg> ApplyPowerSign<T, var_Arg, m_Arg, lr_Arg, logbase_Arg, sign_decay_Arg, beta_Arg, grad_Arg>
where T: TensorType,
      T: Clone,
      var_Arg: Clone,
      var_Arg: GraphRefEdge<T>,
      var_Arg: 'static,
      m_Arg: Clone,
      m_Arg: GraphRefEdge<T>,
      m_Arg: 'static,
      lr_Arg: Clone,
      lr_Arg: GraphEdge<T>,
      lr_Arg: 'static,
      logbase_Arg: Clone,
      logbase_Arg: GraphEdge<T>,
      logbase_Arg: 'static,
      sign_decay_Arg: Clone,
      sign_decay_Arg: GraphEdge<T>,
      sign_decay_Arg: 'static,
      beta_Arg: Clone,
      beta_Arg: GraphEdge<T>,
      beta_Arg: 'static,
      grad_Arg: Clone,
      grad_Arg: GraphEdge<T>,
      grad_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
{
    pub fn out(self) -> RefEdge<T> {
        let rc = Rc::new(self);
        {
            RefEdge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn use_locking(&mut self, use_locking: bool) -> Self {
        self.use_locking = Some(use_locking);
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> RefEdge<T> {
        let rc = Rc::new(self);
        {
            RefEdge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(var: var_Arg, m: m_Arg, lr: lr_Arg, logbase: logbase_Arg, sign_decay: sign_decay_Arg, beta: beta_Arg, grad: grad_Arg) -> Self {
        Self {
            phantom_T: PhantomData,
            var,
            m,
            lr,
            logbase,
            sign_decay,
            beta,
            grad,
            use_locking: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(var: var_Arg, m: m_Arg, lr: lr_Arg, logbase: logbase_Arg, sign_decay: sign_decay_Arg, beta: beta_Arg, grad: grad_Arg) -> RefEdge<T> {
        Self {
            phantom_T: PhantomData,
            var,
            m,
            lr,
            logbase,
            sign_decay,
            beta,
            grad,
            use_locking: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<T, var_Arg, m_Arg, lr_Arg, alpha_Arg, sign_decay_Arg, beta_Arg, grad_Arg> GraphOperation for ApplyAddSign<T, var_Arg, m_Arg, lr_Arg, alpha_Arg, sign_decay_Arg, beta_Arg, grad_Arg>
where T: TensorType,
      T: Clone,
      var_Arg: Clone,
      var_Arg: GraphRefEdge<T>,
      var_Arg: 'static,
      m_Arg: Clone,
      m_Arg: GraphRefEdge<T>,
      m_Arg: 'static,
      lr_Arg: Clone,
      lr_Arg: GraphEdge<T>,
      lr_Arg: 'static,
      alpha_Arg: Clone,
      alpha_Arg: GraphEdge<T>,
      alpha_Arg: 'static,
      sign_decay_Arg: Clone,
      sign_decay_Arg: GraphEdge<T>,
      sign_decay_Arg: 'static,
      beta_Arg: Clone,
      beta_Arg: GraphEdge<T>,
      beta_Arg: 'static,
      grad_Arg: Clone,
      grad_Arg: GraphEdge<T>,
      grad_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("ApplyAddSign_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("ApplyAddSign", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.var)?
        }
        {
            new_op.add_edge(&self.m)?
        }
        {
            new_op.add_edge(&self.lr)?
        }
        {
            new_op.add_edge(&self.alpha)?
        }
        {
            new_op.add_edge(&self.sign_decay)?
        }
        {
            new_op.add_edge(&self.beta)?
        }
        {
            new_op.add_edge(&self.grad)?
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        {
            match self.use_locking {
                None => new_op.set_attr_value_proto("use_locking", &vec![40_u8, 0_u8,])?,
                Some(ref value) => (|attr: &bool| {new_op.set_attr_bool("use_locking", *attr)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct ApplyAddSign<T, var_Arg, m_Arg, lr_Arg, alpha_Arg, sign_decay_Arg, beta_Arg, grad_Arg>
where T: TensorType,
      T: Clone,
      var_Arg: Clone,
      var_Arg: GraphRefEdge<T>,
      var_Arg: 'static,
      m_Arg: Clone,
      m_Arg: GraphRefEdge<T>,
      m_Arg: 'static,
      lr_Arg: Clone,
      lr_Arg: GraphEdge<T>,
      lr_Arg: 'static,
      alpha_Arg: Clone,
      alpha_Arg: GraphEdge<T>,
      alpha_Arg: 'static,
      sign_decay_Arg: Clone,
      sign_decay_Arg: GraphEdge<T>,
      sign_decay_Arg: 'static,
      beta_Arg: Clone,
      beta_Arg: GraphEdge<T>,
      beta_Arg: 'static,
      grad_Arg: Clone,
      grad_Arg: GraphEdge<T>,
      grad_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    var: var_Arg,
    m: m_Arg,
    lr: lr_Arg,
    alpha: alpha_Arg,
    sign_decay: sign_decay_Arg,
    beta: beta_Arg,
    grad: grad_Arg,
    use_locking: Option<bool>,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<T, var_Arg, m_Arg, lr_Arg, alpha_Arg, sign_decay_Arg, beta_Arg, grad_Arg> ApplyAddSign<T, var_Arg, m_Arg, lr_Arg, alpha_Arg, sign_decay_Arg, beta_Arg, grad_Arg>
where T: TensorType,
      T: Clone,
      var_Arg: Clone,
      var_Arg: GraphRefEdge<T>,
      var_Arg: 'static,
      m_Arg: Clone,
      m_Arg: GraphRefEdge<T>,
      m_Arg: 'static,
      lr_Arg: Clone,
      lr_Arg: GraphEdge<T>,
      lr_Arg: 'static,
      alpha_Arg: Clone,
      alpha_Arg: GraphEdge<T>,
      alpha_Arg: 'static,
      sign_decay_Arg: Clone,
      sign_decay_Arg: GraphEdge<T>,
      sign_decay_Arg: 'static,
      beta_Arg: Clone,
      beta_Arg: GraphEdge<T>,
      beta_Arg: 'static,
      grad_Arg: Clone,
      grad_Arg: GraphEdge<T>,
      grad_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
{
    pub fn out(self) -> RefEdge<T> {
        let rc = Rc::new(self);
        {
            RefEdge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn use_locking(&mut self, use_locking: bool) -> Self {
        self.use_locking = Some(use_locking);
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> RefEdge<T> {
        let rc = Rc::new(self);
        {
            RefEdge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(var: var_Arg, m: m_Arg, lr: lr_Arg, alpha: alpha_Arg, sign_decay: sign_decay_Arg, beta: beta_Arg, grad: grad_Arg) -> Self {
        Self {
            phantom_T: PhantomData,
            var,
            m,
            lr,
            alpha,
            sign_decay,
            beta,
            grad,
            use_locking: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(var: var_Arg, m: m_Arg, lr: lr_Arg, alpha: alpha_Arg, sign_decay: sign_decay_Arg, beta: beta_Arg, grad: grad_Arg) -> RefEdge<T> {
        Self {
            phantom_T: PhantomData,
            var,
            m,
            lr,
            alpha,
            sign_decay,
            beta,
            grad,
            use_locking: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

pub trait con_or_DT_INT32_or_DT_INT64 {
}

impl con_or_DT_INT32_or_DT_INT64 for i32 {
}

impl con_or_DT_INT32_or_DT_INT64 for i64 {
}

impl<T, var_Arg, ms_Arg, mom_Arg, lr_Arg, rho_Arg, momentum_Arg, epsilon_Arg, grad_Arg, Tindices, indices_Arg> GraphOperation for SparseApplyRMSProp<T, var_Arg, ms_Arg, mom_Arg, lr_Arg, rho_Arg, momentum_Arg, epsilon_Arg, grad_Arg, Tindices, indices_Arg>
where T: TensorType,
      T: Clone,
      var_Arg: Clone,
      var_Arg: GraphRefEdge<T>,
      var_Arg: 'static,
      ms_Arg: Clone,
      ms_Arg: GraphRefEdge<T>,
      ms_Arg: 'static,
      mom_Arg: Clone,
      mom_Arg: GraphRefEdge<T>,
      mom_Arg: 'static,
      lr_Arg: Clone,
      lr_Arg: GraphEdge<T>,
      lr_Arg: 'static,
      rho_Arg: Clone,
      rho_Arg: GraphEdge<T>,
      rho_Arg: 'static,
      momentum_Arg: Clone,
      momentum_Arg: GraphEdge<T>,
      momentum_Arg: 'static,
      epsilon_Arg: Clone,
      epsilon_Arg: GraphEdge<T>,
      epsilon_Arg: 'static,
      grad_Arg: Clone,
      grad_Arg: GraphEdge<T>,
      grad_Arg: 'static,
      Tindices: TensorType,
      Tindices: Clone,
      indices_Arg: Clone,
      indices_Arg: GraphEdge<Tindices>,
      indices_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
      Tindices: con_or_DT_INT32_or_DT_INT64,
      Tindices: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("SparseApplyRMSProp_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("SparseApplyRMSProp", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.var)?
        }
        {
            new_op.add_edge(&self.ms)?
        }
        {
            new_op.add_edge(&self.mom)?
        }
        {
            new_op.add_edge(&self.lr)?
        }
        {
            new_op.add_edge(&self.rho)?
        }
        {
            new_op.add_edge(&self.momentum)?
        }
        {
            new_op.add_edge(&self.epsilon)?
        }
        {
            new_op.add_edge(&self.grad)?
        }
        {
            new_op.add_edge(&self.indices)?
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        {
            new_op.set_attr_type("Tindices", Tindices::data_type())?;
        }
        {
            match self.use_locking {
                None => new_op.set_attr_value_proto("use_locking", &vec![40_u8, 0_u8,])?,
                Some(ref value) => (|attr: &bool| {new_op.set_attr_bool("use_locking", *attr)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct SparseApplyRMSProp<T, var_Arg, ms_Arg, mom_Arg, lr_Arg, rho_Arg, momentum_Arg, epsilon_Arg, grad_Arg, Tindices, indices_Arg>
where T: TensorType,
      T: Clone,
      var_Arg: Clone,
      var_Arg: GraphRefEdge<T>,
      var_Arg: 'static,
      ms_Arg: Clone,
      ms_Arg: GraphRefEdge<T>,
      ms_Arg: 'static,
      mom_Arg: Clone,
      mom_Arg: GraphRefEdge<T>,
      mom_Arg: 'static,
      lr_Arg: Clone,
      lr_Arg: GraphEdge<T>,
      lr_Arg: 'static,
      rho_Arg: Clone,
      rho_Arg: GraphEdge<T>,
      rho_Arg: 'static,
      momentum_Arg: Clone,
      momentum_Arg: GraphEdge<T>,
      momentum_Arg: 'static,
      epsilon_Arg: Clone,
      epsilon_Arg: GraphEdge<T>,
      epsilon_Arg: 'static,
      grad_Arg: Clone,
      grad_Arg: GraphEdge<T>,
      grad_Arg: 'static,
      Tindices: TensorType,
      Tindices: Clone,
      indices_Arg: Clone,
      indices_Arg: GraphEdge<Tindices>,
      indices_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
      Tindices: con_or_DT_INT32_or_DT_INT64,
      Tindices: 'static,
{
    phantom_T: PhantomData<T>,
    var: var_Arg,
    ms: ms_Arg,
    mom: mom_Arg,
    lr: lr_Arg,
    rho: rho_Arg,
    momentum: momentum_Arg,
    epsilon: epsilon_Arg,
    grad: grad_Arg,
    phantom_Tindices: PhantomData<Tindices>,
    indices: indices_Arg,
    use_locking: Option<bool>,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<T, var_Arg, ms_Arg, mom_Arg, lr_Arg, rho_Arg, momentum_Arg, epsilon_Arg, grad_Arg, Tindices, indices_Arg> SparseApplyRMSProp<T, var_Arg, ms_Arg, mom_Arg, lr_Arg, rho_Arg, momentum_Arg, epsilon_Arg, grad_Arg, Tindices, indices_Arg>
where T: TensorType,
      T: Clone,
      var_Arg: Clone,
      var_Arg: GraphRefEdge<T>,
      var_Arg: 'static,
      ms_Arg: Clone,
      ms_Arg: GraphRefEdge<T>,
      ms_Arg: 'static,
      mom_Arg: Clone,
      mom_Arg: GraphRefEdge<T>,
      mom_Arg: 'static,
      lr_Arg: Clone,
      lr_Arg: GraphEdge<T>,
      lr_Arg: 'static,
      rho_Arg: Clone,
      rho_Arg: GraphEdge<T>,
      rho_Arg: 'static,
      momentum_Arg: Clone,
      momentum_Arg: GraphEdge<T>,
      momentum_Arg: 'static,
      epsilon_Arg: Clone,
      epsilon_Arg: GraphEdge<T>,
      epsilon_Arg: 'static,
      grad_Arg: Clone,
      grad_Arg: GraphEdge<T>,
      grad_Arg: 'static,
      Tindices: TensorType,
      Tindices: Clone,
      indices_Arg: Clone,
      indices_Arg: GraphEdge<Tindices>,
      indices_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
      Tindices: con_or_DT_INT32_or_DT_INT64,
      Tindices: 'static,
{
    pub fn out(self) -> RefEdge<T> {
        let rc = Rc::new(self);
        {
            RefEdge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn use_locking(&mut self, use_locking: bool) -> Self {
        self.use_locking = Some(use_locking);
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> RefEdge<T> {
        let rc = Rc::new(self);
        {
            RefEdge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(var: var_Arg, ms: ms_Arg, mom: mom_Arg, lr: lr_Arg, rho: rho_Arg, momentum: momentum_Arg, epsilon: epsilon_Arg, grad: grad_Arg, indices: indices_Arg) -> Self {
        Self {
            phantom_T: PhantomData,
            var,
            ms,
            mom,
            lr,
            rho,
            momentum,
            epsilon,
            grad,
            phantom_Tindices: PhantomData,
            indices,
            use_locking: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(var: var_Arg, ms: ms_Arg, mom: mom_Arg, lr: lr_Arg, rho: rho_Arg, momentum: momentum_Arg, epsilon: epsilon_Arg, grad: grad_Arg, indices: indices_Arg) -> RefEdge<T> {
        Self {
            phantom_T: PhantomData,
            var,
            ms,
            mom,
            lr,
            rho,
            momentum,
            epsilon,
            grad,
            phantom_Tindices: PhantomData,
            indices,
            use_locking: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<T, var_Arg, mg_Arg, ms_Arg, mom_Arg, lr_Arg, rho_Arg, momentum_Arg, epsilon_Arg, grad_Arg> GraphOperation for ApplyCenteredRMSProp<T, var_Arg, mg_Arg, ms_Arg, mom_Arg, lr_Arg, rho_Arg, momentum_Arg, epsilon_Arg, grad_Arg>
where T: TensorType,
      T: Clone,
      var_Arg: Clone,
      var_Arg: GraphRefEdge<T>,
      var_Arg: 'static,
      mg_Arg: Clone,
      mg_Arg: GraphRefEdge<T>,
      mg_Arg: 'static,
      ms_Arg: Clone,
      ms_Arg: GraphRefEdge<T>,
      ms_Arg: 'static,
      mom_Arg: Clone,
      mom_Arg: GraphRefEdge<T>,
      mom_Arg: 'static,
      lr_Arg: Clone,
      lr_Arg: GraphEdge<T>,
      lr_Arg: 'static,
      rho_Arg: Clone,
      rho_Arg: GraphEdge<T>,
      rho_Arg: 'static,
      momentum_Arg: Clone,
      momentum_Arg: GraphEdge<T>,
      momentum_Arg: 'static,
      epsilon_Arg: Clone,
      epsilon_Arg: GraphEdge<T>,
      epsilon_Arg: 'static,
      grad_Arg: Clone,
      grad_Arg: GraphEdge<T>,
      grad_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("ApplyCenteredRMSProp_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("ApplyCenteredRMSProp", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.var)?
        }
        {
            new_op.add_edge(&self.mg)?
        }
        {
            new_op.add_edge(&self.ms)?
        }
        {
            new_op.add_edge(&self.mom)?
        }
        {
            new_op.add_edge(&self.lr)?
        }
        {
            new_op.add_edge(&self.rho)?
        }
        {
            new_op.add_edge(&self.momentum)?
        }
        {
            new_op.add_edge(&self.epsilon)?
        }
        {
            new_op.add_edge(&self.grad)?
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        {
            match self.use_locking {
                None => new_op.set_attr_value_proto("use_locking", &vec![40_u8, 0_u8,])?,
                Some(ref value) => (|attr: &bool| {new_op.set_attr_bool("use_locking", *attr)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct ApplyCenteredRMSProp<T, var_Arg, mg_Arg, ms_Arg, mom_Arg, lr_Arg, rho_Arg, momentum_Arg, epsilon_Arg, grad_Arg>
where T: TensorType,
      T: Clone,
      var_Arg: Clone,
      var_Arg: GraphRefEdge<T>,
      var_Arg: 'static,
      mg_Arg: Clone,
      mg_Arg: GraphRefEdge<T>,
      mg_Arg: 'static,
      ms_Arg: Clone,
      ms_Arg: GraphRefEdge<T>,
      ms_Arg: 'static,
      mom_Arg: Clone,
      mom_Arg: GraphRefEdge<T>,
      mom_Arg: 'static,
      lr_Arg: Clone,
      lr_Arg: GraphEdge<T>,
      lr_Arg: 'static,
      rho_Arg: Clone,
      rho_Arg: GraphEdge<T>,
      rho_Arg: 'static,
      momentum_Arg: Clone,
      momentum_Arg: GraphEdge<T>,
      momentum_Arg: 'static,
      epsilon_Arg: Clone,
      epsilon_Arg: GraphEdge<T>,
      epsilon_Arg: 'static,
      grad_Arg: Clone,
      grad_Arg: GraphEdge<T>,
      grad_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    var: var_Arg,
    mg: mg_Arg,
    ms: ms_Arg,
    mom: mom_Arg,
    lr: lr_Arg,
    rho: rho_Arg,
    momentum: momentum_Arg,
    epsilon: epsilon_Arg,
    grad: grad_Arg,
    use_locking: Option<bool>,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<T, var_Arg, mg_Arg, ms_Arg, mom_Arg, lr_Arg, rho_Arg, momentum_Arg, epsilon_Arg, grad_Arg> ApplyCenteredRMSProp<T, var_Arg, mg_Arg, ms_Arg, mom_Arg, lr_Arg, rho_Arg, momentum_Arg, epsilon_Arg, grad_Arg>
where T: TensorType,
      T: Clone,
      var_Arg: Clone,
      var_Arg: GraphRefEdge<T>,
      var_Arg: 'static,
      mg_Arg: Clone,
      mg_Arg: GraphRefEdge<T>,
      mg_Arg: 'static,
      ms_Arg: Clone,
      ms_Arg: GraphRefEdge<T>,
      ms_Arg: 'static,
      mom_Arg: Clone,
      mom_Arg: GraphRefEdge<T>,
      mom_Arg: 'static,
      lr_Arg: Clone,
      lr_Arg: GraphEdge<T>,
      lr_Arg: 'static,
      rho_Arg: Clone,
      rho_Arg: GraphEdge<T>,
      rho_Arg: 'static,
      momentum_Arg: Clone,
      momentum_Arg: GraphEdge<T>,
      momentum_Arg: 'static,
      epsilon_Arg: Clone,
      epsilon_Arg: GraphEdge<T>,
      epsilon_Arg: 'static,
      grad_Arg: Clone,
      grad_Arg: GraphEdge<T>,
      grad_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
{
    pub fn out(self) -> RefEdge<T> {
        let rc = Rc::new(self);
        {
            RefEdge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn use_locking(&mut self, use_locking: bool) -> Self {
        self.use_locking = Some(use_locking);
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> RefEdge<T> {
        let rc = Rc::new(self);
        {
            RefEdge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(var: var_Arg, mg: mg_Arg, ms: ms_Arg, mom: mom_Arg, lr: lr_Arg, rho: rho_Arg, momentum: momentum_Arg, epsilon: epsilon_Arg, grad: grad_Arg) -> Self {
        Self {
            phantom_T: PhantomData,
            var,
            mg,
            ms,
            mom,
            lr,
            rho,
            momentum,
            epsilon,
            grad,
            use_locking: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(var: var_Arg, mg: mg_Arg, ms: ms_Arg, mom: mom_Arg, lr: lr_Arg, rho: rho_Arg, momentum: momentum_Arg, epsilon: epsilon_Arg, grad: grad_Arg) -> RefEdge<T> {
        Self {
            phantom_T: PhantomData,
            var,
            mg,
            ms,
            mom,
            lr,
            rho,
            momentum,
            epsilon,
            grad,
            use_locking: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<T, var_Arg, accum_Arg, lr_Arg, grad_Arg, Tindices, indices_Arg, momentum_Arg> GraphOperation for SparseApplyMomentum<T, var_Arg, accum_Arg, lr_Arg, grad_Arg, Tindices, indices_Arg, momentum_Arg>
where T: TensorType,
      T: Clone,
      var_Arg: Clone,
      var_Arg: GraphRefEdge<T>,
      var_Arg: 'static,
      accum_Arg: Clone,
      accum_Arg: GraphRefEdge<T>,
      accum_Arg: 'static,
      lr_Arg: Clone,
      lr_Arg: GraphEdge<T>,
      lr_Arg: 'static,
      grad_Arg: Clone,
      grad_Arg: GraphEdge<T>,
      grad_Arg: 'static,
      Tindices: TensorType,
      Tindices: Clone,
      indices_Arg: Clone,
      indices_Arg: GraphEdge<Tindices>,
      indices_Arg: 'static,
      momentum_Arg: Clone,
      momentum_Arg: GraphEdge<T>,
      momentum_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
      Tindices: con_or_DT_INT32_or_DT_INT64,
      Tindices: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("SparseApplyMomentum_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("SparseApplyMomentum", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.var)?
        }
        {
            new_op.add_edge(&self.accum)?
        }
        {
            new_op.add_edge(&self.lr)?
        }
        {
            new_op.add_edge(&self.grad)?
        }
        {
            new_op.add_edge(&self.indices)?
        }
        {
            new_op.add_edge(&self.momentum)?
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        {
            new_op.set_attr_type("Tindices", Tindices::data_type())?;
        }
        {
            match self.use_locking {
                None => new_op.set_attr_value_proto("use_locking", &vec![40_u8, 0_u8,])?,
                Some(ref value) => (|attr: &bool| {new_op.set_attr_bool("use_locking", *attr)})(&value)?,
            };
        }
        {
            match self.use_nesterov {
                None => new_op.set_attr_value_proto("use_nesterov", &vec![40_u8, 0_u8,])?,
                Some(ref value) => (|attr: &bool| {new_op.set_attr_bool("use_nesterov", *attr)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct SparseApplyMomentum<T, var_Arg, accum_Arg, lr_Arg, grad_Arg, Tindices, indices_Arg, momentum_Arg>
where T: TensorType,
      T: Clone,
      var_Arg: Clone,
      var_Arg: GraphRefEdge<T>,
      var_Arg: 'static,
      accum_Arg: Clone,
      accum_Arg: GraphRefEdge<T>,
      accum_Arg: 'static,
      lr_Arg: Clone,
      lr_Arg: GraphEdge<T>,
      lr_Arg: 'static,
      grad_Arg: Clone,
      grad_Arg: GraphEdge<T>,
      grad_Arg: 'static,
      Tindices: TensorType,
      Tindices: Clone,
      indices_Arg: Clone,
      indices_Arg: GraphEdge<Tindices>,
      indices_Arg: 'static,
      momentum_Arg: Clone,
      momentum_Arg: GraphEdge<T>,
      momentum_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
      Tindices: con_or_DT_INT32_or_DT_INT64,
      Tindices: 'static,
{
    phantom_T: PhantomData<T>,
    var: var_Arg,
    accum: accum_Arg,
    lr: lr_Arg,
    grad: grad_Arg,
    phantom_Tindices: PhantomData<Tindices>,
    indices: indices_Arg,
    momentum: momentum_Arg,
    use_locking: Option<bool>,
    use_nesterov: Option<bool>,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<T, var_Arg, accum_Arg, lr_Arg, grad_Arg, Tindices, indices_Arg, momentum_Arg> SparseApplyMomentum<T, var_Arg, accum_Arg, lr_Arg, grad_Arg, Tindices, indices_Arg, momentum_Arg>
where T: TensorType,
      T: Clone,
      var_Arg: Clone,
      var_Arg: GraphRefEdge<T>,
      var_Arg: 'static,
      accum_Arg: Clone,
      accum_Arg: GraphRefEdge<T>,
      accum_Arg: 'static,
      lr_Arg: Clone,
      lr_Arg: GraphEdge<T>,
      lr_Arg: 'static,
      grad_Arg: Clone,
      grad_Arg: GraphEdge<T>,
      grad_Arg: 'static,
      Tindices: TensorType,
      Tindices: Clone,
      indices_Arg: Clone,
      indices_Arg: GraphEdge<Tindices>,
      indices_Arg: 'static,
      momentum_Arg: Clone,
      momentum_Arg: GraphEdge<T>,
      momentum_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
      Tindices: con_or_DT_INT32_or_DT_INT64,
      Tindices: 'static,
{
    pub fn out(self) -> RefEdge<T> {
        let rc = Rc::new(self);
        {
            RefEdge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn use_locking(&mut self, use_locking: bool) -> Self {
        self.use_locking = Some(use_locking);
        self.clone()
    }

    pub fn use_nesterov(&mut self, use_nesterov: bool) -> Self {
        self.use_nesterov = Some(use_nesterov);
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> RefEdge<T> {
        let rc = Rc::new(self);
        {
            RefEdge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(var: var_Arg, accum: accum_Arg, lr: lr_Arg, grad: grad_Arg, indices: indices_Arg, momentum: momentum_Arg) -> Self {
        Self {
            phantom_T: PhantomData,
            var,
            accum,
            lr,
            grad,
            phantom_Tindices: PhantomData,
            indices,
            momentum,
            use_locking: None,
            use_nesterov: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(var: var_Arg, accum: accum_Arg, lr: lr_Arg, grad: grad_Arg, indices: indices_Arg, momentum: momentum_Arg) -> RefEdge<T> {
        Self {
            phantom_T: PhantomData,
            var,
            accum,
            lr,
            grad,
            phantom_Tindices: PhantomData,
            indices,
            momentum,
            use_locking: None,
            use_nesterov: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<T, var_Arg, accum_Arg, linear_Arg, grad_Arg, Tindices, indices_Arg, lr_Arg, l1_Arg, l2_Arg, l2_shrinkage_Arg, lr_power_Arg> GraphOperation for SparseApplyFtrlV2<T, var_Arg, accum_Arg, linear_Arg, grad_Arg, Tindices, indices_Arg, lr_Arg, l1_Arg, l2_Arg, l2_shrinkage_Arg, lr_power_Arg>
where T: TensorType,
      T: Clone,
      var_Arg: Clone,
      var_Arg: GraphRefEdge<T>,
      var_Arg: 'static,
      accum_Arg: Clone,
      accum_Arg: GraphRefEdge<T>,
      accum_Arg: 'static,
      linear_Arg: Clone,
      linear_Arg: GraphRefEdge<T>,
      linear_Arg: 'static,
      grad_Arg: Clone,
      grad_Arg: GraphEdge<T>,
      grad_Arg: 'static,
      Tindices: TensorType,
      Tindices: Clone,
      indices_Arg: Clone,
      indices_Arg: GraphEdge<Tindices>,
      indices_Arg: 'static,
      lr_Arg: Clone,
      lr_Arg: GraphEdge<T>,
      lr_Arg: 'static,
      l1_Arg: Clone,
      l1_Arg: GraphEdge<T>,
      l1_Arg: 'static,
      l2_Arg: Clone,
      l2_Arg: GraphEdge<T>,
      l2_Arg: 'static,
      l2_shrinkage_Arg: Clone,
      l2_shrinkage_Arg: GraphEdge<T>,
      l2_shrinkage_Arg: 'static,
      lr_power_Arg: Clone,
      lr_power_Arg: GraphEdge<T>,
      lr_power_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
      Tindices: con_or_DT_INT32_or_DT_INT64,
      Tindices: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("SparseApplyFtrlV2_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("SparseApplyFtrlV2", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.var)?
        }
        {
            new_op.add_edge(&self.accum)?
        }
        {
            new_op.add_edge(&self.linear)?
        }
        {
            new_op.add_edge(&self.grad)?
        }
        {
            new_op.add_edge(&self.indices)?
        }
        {
            new_op.add_edge(&self.lr)?
        }
        {
            new_op.add_edge(&self.l1)?
        }
        {
            new_op.add_edge(&self.l2)?
        }
        {
            new_op.add_edge(&self.l2_shrinkage)?
        }
        {
            new_op.add_edge(&self.lr_power)?
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        {
            new_op.set_attr_type("Tindices", Tindices::data_type())?;
        }
        {
            match self.use_locking {
                None => new_op.set_attr_value_proto("use_locking", &vec![40_u8, 0_u8,])?,
                Some(ref value) => (|attr: &bool| {new_op.set_attr_bool("use_locking", *attr)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct SparseApplyFtrlV2<T, var_Arg, accum_Arg, linear_Arg, grad_Arg, Tindices, indices_Arg, lr_Arg, l1_Arg, l2_Arg, l2_shrinkage_Arg, lr_power_Arg>
where T: TensorType,
      T: Clone,
      var_Arg: Clone,
      var_Arg: GraphRefEdge<T>,
      var_Arg: 'static,
      accum_Arg: Clone,
      accum_Arg: GraphRefEdge<T>,
      accum_Arg: 'static,
      linear_Arg: Clone,
      linear_Arg: GraphRefEdge<T>,
      linear_Arg: 'static,
      grad_Arg: Clone,
      grad_Arg: GraphEdge<T>,
      grad_Arg: 'static,
      Tindices: TensorType,
      Tindices: Clone,
      indices_Arg: Clone,
      indices_Arg: GraphEdge<Tindices>,
      indices_Arg: 'static,
      lr_Arg: Clone,
      lr_Arg: GraphEdge<T>,
      lr_Arg: 'static,
      l1_Arg: Clone,
      l1_Arg: GraphEdge<T>,
      l1_Arg: 'static,
      l2_Arg: Clone,
      l2_Arg: GraphEdge<T>,
      l2_Arg: 'static,
      l2_shrinkage_Arg: Clone,
      l2_shrinkage_Arg: GraphEdge<T>,
      l2_shrinkage_Arg: 'static,
      lr_power_Arg: Clone,
      lr_power_Arg: GraphEdge<T>,
      lr_power_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
      Tindices: con_or_DT_INT32_or_DT_INT64,
      Tindices: 'static,
{
    phantom_T: PhantomData<T>,
    var: var_Arg,
    accum: accum_Arg,
    linear: linear_Arg,
    grad: grad_Arg,
    phantom_Tindices: PhantomData<Tindices>,
    indices: indices_Arg,
    lr: lr_Arg,
    l1: l1_Arg,
    l2: l2_Arg,
    l2_shrinkage: l2_shrinkage_Arg,
    lr_power: lr_power_Arg,
    use_locking: Option<bool>,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<T, var_Arg, accum_Arg, linear_Arg, grad_Arg, Tindices, indices_Arg, lr_Arg, l1_Arg, l2_Arg, l2_shrinkage_Arg, lr_power_Arg> SparseApplyFtrlV2<T, var_Arg, accum_Arg, linear_Arg, grad_Arg, Tindices, indices_Arg, lr_Arg, l1_Arg, l2_Arg, l2_shrinkage_Arg, lr_power_Arg>
where T: TensorType,
      T: Clone,
      var_Arg: Clone,
      var_Arg: GraphRefEdge<T>,
      var_Arg: 'static,
      accum_Arg: Clone,
      accum_Arg: GraphRefEdge<T>,
      accum_Arg: 'static,
      linear_Arg: Clone,
      linear_Arg: GraphRefEdge<T>,
      linear_Arg: 'static,
      grad_Arg: Clone,
      grad_Arg: GraphEdge<T>,
      grad_Arg: 'static,
      Tindices: TensorType,
      Tindices: Clone,
      indices_Arg: Clone,
      indices_Arg: GraphEdge<Tindices>,
      indices_Arg: 'static,
      lr_Arg: Clone,
      lr_Arg: GraphEdge<T>,
      lr_Arg: 'static,
      l1_Arg: Clone,
      l1_Arg: GraphEdge<T>,
      l1_Arg: 'static,
      l2_Arg: Clone,
      l2_Arg: GraphEdge<T>,
      l2_Arg: 'static,
      l2_shrinkage_Arg: Clone,
      l2_shrinkage_Arg: GraphEdge<T>,
      l2_shrinkage_Arg: 'static,
      lr_power_Arg: Clone,
      lr_power_Arg: GraphEdge<T>,
      lr_power_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
      Tindices: con_or_DT_INT32_or_DT_INT64,
      Tindices: 'static,
{
    pub fn out(self) -> RefEdge<T> {
        let rc = Rc::new(self);
        {
            RefEdge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn use_locking(&mut self, use_locking: bool) -> Self {
        self.use_locking = Some(use_locking);
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> RefEdge<T> {
        let rc = Rc::new(self);
        {
            RefEdge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(var: var_Arg, accum: accum_Arg, linear: linear_Arg, grad: grad_Arg, indices: indices_Arg, lr: lr_Arg, l1: l1_Arg, l2: l2_Arg, l2_shrinkage: l2_shrinkage_Arg, lr_power: lr_power_Arg) -> Self {
        Self {
            phantom_T: PhantomData,
            var,
            accum,
            linear,
            grad,
            phantom_Tindices: PhantomData,
            indices,
            lr,
            l1,
            l2,
            l2_shrinkage,
            lr_power,
            use_locking: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(var: var_Arg, accum: accum_Arg, linear: linear_Arg, grad: grad_Arg, indices: indices_Arg, lr: lr_Arg, l1: l1_Arg, l2: l2_Arg, l2_shrinkage: l2_shrinkage_Arg, lr_power: lr_power_Arg) -> RefEdge<T> {
        Self {
            phantom_T: PhantomData,
            var,
            accum,
            linear,
            grad,
            phantom_Tindices: PhantomData,
            indices,
            lr,
            l1,
            l2,
            l2_shrinkage,
            lr_power,
            use_locking: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<T, var_Arg, accum_Arg, linear_Arg, grad_Arg, lr_Arg, l1_Arg, l2_Arg, l2_shrinkage_Arg, lr_power_Arg> GraphOperation for ApplyFtrlV2<T, var_Arg, accum_Arg, linear_Arg, grad_Arg, lr_Arg, l1_Arg, l2_Arg, l2_shrinkage_Arg, lr_power_Arg>
where T: TensorType,
      T: Clone,
      var_Arg: Clone,
      var_Arg: GraphRefEdge<T>,
      var_Arg: 'static,
      accum_Arg: Clone,
      accum_Arg: GraphRefEdge<T>,
      accum_Arg: 'static,
      linear_Arg: Clone,
      linear_Arg: GraphRefEdge<T>,
      linear_Arg: 'static,
      grad_Arg: Clone,
      grad_Arg: GraphEdge<T>,
      grad_Arg: 'static,
      lr_Arg: Clone,
      lr_Arg: GraphEdge<T>,
      lr_Arg: 'static,
      l1_Arg: Clone,
      l1_Arg: GraphEdge<T>,
      l1_Arg: 'static,
      l2_Arg: Clone,
      l2_Arg: GraphEdge<T>,
      l2_Arg: 'static,
      l2_shrinkage_Arg: Clone,
      l2_shrinkage_Arg: GraphEdge<T>,
      l2_shrinkage_Arg: 'static,
      lr_power_Arg: Clone,
      lr_power_Arg: GraphEdge<T>,
      lr_power_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("ApplyFtrlV2_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("ApplyFtrlV2", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.var)?
        }
        {
            new_op.add_edge(&self.accum)?
        }
        {
            new_op.add_edge(&self.linear)?
        }
        {
            new_op.add_edge(&self.grad)?
        }
        {
            new_op.add_edge(&self.lr)?
        }
        {
            new_op.add_edge(&self.l1)?
        }
        {
            new_op.add_edge(&self.l2)?
        }
        {
            new_op.add_edge(&self.l2_shrinkage)?
        }
        {
            new_op.add_edge(&self.lr_power)?
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        {
            match self.use_locking {
                None => new_op.set_attr_value_proto("use_locking", &vec![40_u8, 0_u8,])?,
                Some(ref value) => (|attr: &bool| {new_op.set_attr_bool("use_locking", *attr)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct ApplyFtrlV2<T, var_Arg, accum_Arg, linear_Arg, grad_Arg, lr_Arg, l1_Arg, l2_Arg, l2_shrinkage_Arg, lr_power_Arg>
where T: TensorType,
      T: Clone,
      var_Arg: Clone,
      var_Arg: GraphRefEdge<T>,
      var_Arg: 'static,
      accum_Arg: Clone,
      accum_Arg: GraphRefEdge<T>,
      accum_Arg: 'static,
      linear_Arg: Clone,
      linear_Arg: GraphRefEdge<T>,
      linear_Arg: 'static,
      grad_Arg: Clone,
      grad_Arg: GraphEdge<T>,
      grad_Arg: 'static,
      lr_Arg: Clone,
      lr_Arg: GraphEdge<T>,
      lr_Arg: 'static,
      l1_Arg: Clone,
      l1_Arg: GraphEdge<T>,
      l1_Arg: 'static,
      l2_Arg: Clone,
      l2_Arg: GraphEdge<T>,
      l2_Arg: 'static,
      l2_shrinkage_Arg: Clone,
      l2_shrinkage_Arg: GraphEdge<T>,
      l2_shrinkage_Arg: 'static,
      lr_power_Arg: Clone,
      lr_power_Arg: GraphEdge<T>,
      lr_power_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    var: var_Arg,
    accum: accum_Arg,
    linear: linear_Arg,
    grad: grad_Arg,
    lr: lr_Arg,
    l1: l1_Arg,
    l2: l2_Arg,
    l2_shrinkage: l2_shrinkage_Arg,
    lr_power: lr_power_Arg,
    use_locking: Option<bool>,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<T, var_Arg, accum_Arg, linear_Arg, grad_Arg, lr_Arg, l1_Arg, l2_Arg, l2_shrinkage_Arg, lr_power_Arg> ApplyFtrlV2<T, var_Arg, accum_Arg, linear_Arg, grad_Arg, lr_Arg, l1_Arg, l2_Arg, l2_shrinkage_Arg, lr_power_Arg>
where T: TensorType,
      T: Clone,
      var_Arg: Clone,
      var_Arg: GraphRefEdge<T>,
      var_Arg: 'static,
      accum_Arg: Clone,
      accum_Arg: GraphRefEdge<T>,
      accum_Arg: 'static,
      linear_Arg: Clone,
      linear_Arg: GraphRefEdge<T>,
      linear_Arg: 'static,
      grad_Arg: Clone,
      grad_Arg: GraphEdge<T>,
      grad_Arg: 'static,
      lr_Arg: Clone,
      lr_Arg: GraphEdge<T>,
      lr_Arg: 'static,
      l1_Arg: Clone,
      l1_Arg: GraphEdge<T>,
      l1_Arg: 'static,
      l2_Arg: Clone,
      l2_Arg: GraphEdge<T>,
      l2_Arg: 'static,
      l2_shrinkage_Arg: Clone,
      l2_shrinkage_Arg: GraphEdge<T>,
      l2_shrinkage_Arg: 'static,
      lr_power_Arg: Clone,
      lr_power_Arg: GraphEdge<T>,
      lr_power_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
{
    pub fn out(self) -> RefEdge<T> {
        let rc = Rc::new(self);
        {
            RefEdge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn use_locking(&mut self, use_locking: bool) -> Self {
        self.use_locking = Some(use_locking);
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> RefEdge<T> {
        let rc = Rc::new(self);
        {
            RefEdge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(var: var_Arg, accum: accum_Arg, linear: linear_Arg, grad: grad_Arg, lr: lr_Arg, l1: l1_Arg, l2: l2_Arg, l2_shrinkage: l2_shrinkage_Arg, lr_power: lr_power_Arg) -> Self {
        Self {
            phantom_T: PhantomData,
            var,
            accum,
            linear,
            grad,
            lr,
            l1,
            l2,
            l2_shrinkage,
            lr_power,
            use_locking: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(var: var_Arg, accum: accum_Arg, linear: linear_Arg, grad: grad_Arg, lr: lr_Arg, l1: l1_Arg, l2: l2_Arg, l2_shrinkage: l2_shrinkage_Arg, lr_power: lr_power_Arg) -> RefEdge<T> {
        Self {
            phantom_T: PhantomData,
            var,
            accum,
            linear,
            grad,
            lr,
            l1,
            l2,
            l2_shrinkage,
            lr_power,
            use_locking: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<T, var_Arg, accum_Arg, lr_Arg, grad_Arg, Tindices, indices_Arg> GraphOperation for SparseApplyAdagrad<T, var_Arg, accum_Arg, lr_Arg, grad_Arg, Tindices, indices_Arg>
where T: TensorType,
      T: Clone,
      var_Arg: Clone,
      var_Arg: GraphRefEdge<T>,
      var_Arg: 'static,
      accum_Arg: Clone,
      accum_Arg: GraphRefEdge<T>,
      accum_Arg: 'static,
      lr_Arg: Clone,
      lr_Arg: GraphEdge<T>,
      lr_Arg: 'static,
      grad_Arg: Clone,
      grad_Arg: GraphEdge<T>,
      grad_Arg: 'static,
      Tindices: TensorType,
      Tindices: Clone,
      indices_Arg: Clone,
      indices_Arg: GraphEdge<Tindices>,
      indices_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
      Tindices: con_or_DT_INT32_or_DT_INT64,
      Tindices: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("SparseApplyAdagrad_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("SparseApplyAdagrad", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.var)?
        }
        {
            new_op.add_edge(&self.accum)?
        }
        {
            new_op.add_edge(&self.lr)?
        }
        {
            new_op.add_edge(&self.grad)?
        }
        {
            new_op.add_edge(&self.indices)?
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        {
            new_op.set_attr_type("Tindices", Tindices::data_type())?;
        }
        {
            match self.use_locking {
                None => new_op.set_attr_value_proto("use_locking", &vec![40_u8, 0_u8,])?,
                Some(ref value) => (|attr: &bool| {new_op.set_attr_bool("use_locking", *attr)})(&value)?,
            };
        }
        {
            match self.update_slots {
                None => new_op.set_attr_value_proto("update_slots", &vec![40_u8, 1_u8,])?,
                Some(ref value) => (|attr: &bool| {new_op.set_attr_bool("update_slots", *attr)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct SparseApplyAdagrad<T, var_Arg, accum_Arg, lr_Arg, grad_Arg, Tindices, indices_Arg>
where T: TensorType,
      T: Clone,
      var_Arg: Clone,
      var_Arg: GraphRefEdge<T>,
      var_Arg: 'static,
      accum_Arg: Clone,
      accum_Arg: GraphRefEdge<T>,
      accum_Arg: 'static,
      lr_Arg: Clone,
      lr_Arg: GraphEdge<T>,
      lr_Arg: 'static,
      grad_Arg: Clone,
      grad_Arg: GraphEdge<T>,
      grad_Arg: 'static,
      Tindices: TensorType,
      Tindices: Clone,
      indices_Arg: Clone,
      indices_Arg: GraphEdge<Tindices>,
      indices_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
      Tindices: con_or_DT_INT32_or_DT_INT64,
      Tindices: 'static,
{
    phantom_T: PhantomData<T>,
    var: var_Arg,
    accum: accum_Arg,
    lr: lr_Arg,
    grad: grad_Arg,
    phantom_Tindices: PhantomData<Tindices>,
    indices: indices_Arg,
    use_locking: Option<bool>,
    update_slots: Option<bool>,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<T, var_Arg, accum_Arg, lr_Arg, grad_Arg, Tindices, indices_Arg> SparseApplyAdagrad<T, var_Arg, accum_Arg, lr_Arg, grad_Arg, Tindices, indices_Arg>
where T: TensorType,
      T: Clone,
      var_Arg: Clone,
      var_Arg: GraphRefEdge<T>,
      var_Arg: 'static,
      accum_Arg: Clone,
      accum_Arg: GraphRefEdge<T>,
      accum_Arg: 'static,
      lr_Arg: Clone,
      lr_Arg: GraphEdge<T>,
      lr_Arg: 'static,
      grad_Arg: Clone,
      grad_Arg: GraphEdge<T>,
      grad_Arg: 'static,
      Tindices: TensorType,
      Tindices: Clone,
      indices_Arg: Clone,
      indices_Arg: GraphEdge<Tindices>,
      indices_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
      Tindices: con_or_DT_INT32_or_DT_INT64,
      Tindices: 'static,
{
    pub fn out(self) -> RefEdge<T> {
        let rc = Rc::new(self);
        {
            RefEdge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn use_locking(&mut self, use_locking: bool) -> Self {
        self.use_locking = Some(use_locking);
        self.clone()
    }

    pub fn update_slots(&mut self, update_slots: bool) -> Self {
        self.update_slots = Some(update_slots);
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> RefEdge<T> {
        let rc = Rc::new(self);
        {
            RefEdge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(var: var_Arg, accum: accum_Arg, lr: lr_Arg, grad: grad_Arg, indices: indices_Arg) -> Self {
        Self {
            phantom_T: PhantomData,
            var,
            accum,
            lr,
            grad,
            phantom_Tindices: PhantomData,
            indices,
            use_locking: None,
            update_slots: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(var: var_Arg, accum: accum_Arg, lr: lr_Arg, grad: grad_Arg, indices: indices_Arg) -> RefEdge<T> {
        Self {
            phantom_T: PhantomData,
            var,
            accum,
            lr,
            grad,
            phantom_Tindices: PhantomData,
            indices,
            use_locking: None,
            update_slots: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<T, var_Arg, accum_Arg, accum_update_Arg, lr_Arg, rho_Arg, epsilon_Arg, grad_Arg, Tindices, indices_Arg> GraphOperation for SparseApplyAdadelta<T, var_Arg, accum_Arg, accum_update_Arg, lr_Arg, rho_Arg, epsilon_Arg, grad_Arg, Tindices, indices_Arg>
where T: TensorType,
      T: Clone,
      var_Arg: Clone,
      var_Arg: GraphRefEdge<T>,
      var_Arg: 'static,
      accum_Arg: Clone,
      accum_Arg: GraphRefEdge<T>,
      accum_Arg: 'static,
      accum_update_Arg: Clone,
      accum_update_Arg: GraphRefEdge<T>,
      accum_update_Arg: 'static,
      lr_Arg: Clone,
      lr_Arg: GraphEdge<T>,
      lr_Arg: 'static,
      rho_Arg: Clone,
      rho_Arg: GraphEdge<T>,
      rho_Arg: 'static,
      epsilon_Arg: Clone,
      epsilon_Arg: GraphEdge<T>,
      epsilon_Arg: 'static,
      grad_Arg: Clone,
      grad_Arg: GraphEdge<T>,
      grad_Arg: 'static,
      Tindices: TensorType,
      Tindices: Clone,
      indices_Arg: Clone,
      indices_Arg: GraphEdge<Tindices>,
      indices_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
      Tindices: con_or_DT_INT32_or_DT_INT64,
      Tindices: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("SparseApplyAdadelta_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("SparseApplyAdadelta", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.var)?
        }
        {
            new_op.add_edge(&self.accum)?
        }
        {
            new_op.add_edge(&self.accum_update)?
        }
        {
            new_op.add_edge(&self.lr)?
        }
        {
            new_op.add_edge(&self.rho)?
        }
        {
            new_op.add_edge(&self.epsilon)?
        }
        {
            new_op.add_edge(&self.grad)?
        }
        {
            new_op.add_edge(&self.indices)?
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        {
            new_op.set_attr_type("Tindices", Tindices::data_type())?;
        }
        {
            match self.use_locking {
                None => new_op.set_attr_value_proto("use_locking", &vec![40_u8, 0_u8,])?,
                Some(ref value) => (|attr: &bool| {new_op.set_attr_bool("use_locking", *attr)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct SparseApplyAdadelta<T, var_Arg, accum_Arg, accum_update_Arg, lr_Arg, rho_Arg, epsilon_Arg, grad_Arg, Tindices, indices_Arg>
where T: TensorType,
      T: Clone,
      var_Arg: Clone,
      var_Arg: GraphRefEdge<T>,
      var_Arg: 'static,
      accum_Arg: Clone,
      accum_Arg: GraphRefEdge<T>,
      accum_Arg: 'static,
      accum_update_Arg: Clone,
      accum_update_Arg: GraphRefEdge<T>,
      accum_update_Arg: 'static,
      lr_Arg: Clone,
      lr_Arg: GraphEdge<T>,
      lr_Arg: 'static,
      rho_Arg: Clone,
      rho_Arg: GraphEdge<T>,
      rho_Arg: 'static,
      epsilon_Arg: Clone,
      epsilon_Arg: GraphEdge<T>,
      epsilon_Arg: 'static,
      grad_Arg: Clone,
      grad_Arg: GraphEdge<T>,
      grad_Arg: 'static,
      Tindices: TensorType,
      Tindices: Clone,
      indices_Arg: Clone,
      indices_Arg: GraphEdge<Tindices>,
      indices_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
      Tindices: con_or_DT_INT32_or_DT_INT64,
      Tindices: 'static,
{
    phantom_T: PhantomData<T>,
    var: var_Arg,
    accum: accum_Arg,
    accum_update: accum_update_Arg,
    lr: lr_Arg,
    rho: rho_Arg,
    epsilon: epsilon_Arg,
    grad: grad_Arg,
    phantom_Tindices: PhantomData<Tindices>,
    indices: indices_Arg,
    use_locking: Option<bool>,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<T, var_Arg, accum_Arg, accum_update_Arg, lr_Arg, rho_Arg, epsilon_Arg, grad_Arg, Tindices, indices_Arg> SparseApplyAdadelta<T, var_Arg, accum_Arg, accum_update_Arg, lr_Arg, rho_Arg, epsilon_Arg, grad_Arg, Tindices, indices_Arg>
where T: TensorType,
      T: Clone,
      var_Arg: Clone,
      var_Arg: GraphRefEdge<T>,
      var_Arg: 'static,
      accum_Arg: Clone,
      accum_Arg: GraphRefEdge<T>,
      accum_Arg: 'static,
      accum_update_Arg: Clone,
      accum_update_Arg: GraphRefEdge<T>,
      accum_update_Arg: 'static,
      lr_Arg: Clone,
      lr_Arg: GraphEdge<T>,
      lr_Arg: 'static,
      rho_Arg: Clone,
      rho_Arg: GraphEdge<T>,
      rho_Arg: 'static,
      epsilon_Arg: Clone,
      epsilon_Arg: GraphEdge<T>,
      epsilon_Arg: 'static,
      grad_Arg: Clone,
      grad_Arg: GraphEdge<T>,
      grad_Arg: 'static,
      Tindices: TensorType,
      Tindices: Clone,
      indices_Arg: Clone,
      indices_Arg: GraphEdge<Tindices>,
      indices_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
      Tindices: con_or_DT_INT32_or_DT_INT64,
      Tindices: 'static,
{
    pub fn out(self) -> RefEdge<T> {
        let rc = Rc::new(self);
        {
            RefEdge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn use_locking(&mut self, use_locking: bool) -> Self {
        self.use_locking = Some(use_locking);
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> RefEdge<T> {
        let rc = Rc::new(self);
        {
            RefEdge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(var: var_Arg, accum: accum_Arg, accum_update: accum_update_Arg, lr: lr_Arg, rho: rho_Arg, epsilon: epsilon_Arg, grad: grad_Arg, indices: indices_Arg) -> Self {
        Self {
            phantom_T: PhantomData,
            var,
            accum,
            accum_update,
            lr,
            rho,
            epsilon,
            grad,
            phantom_Tindices: PhantomData,
            indices,
            use_locking: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(var: var_Arg, accum: accum_Arg, accum_update: accum_update_Arg, lr: lr_Arg, rho: rho_Arg, epsilon: epsilon_Arg, grad: grad_Arg, indices: indices_Arg) -> RefEdge<T> {
        Self {
            phantom_T: PhantomData,
            var,
            accum,
            accum_update,
            lr,
            rho,
            epsilon,
            grad,
            phantom_Tindices: PhantomData,
            indices,
            use_locking: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<T, var_Arg, accum_Arg, accum_update_Arg, lr_Arg, rho_Arg, epsilon_Arg, grad_Arg> GraphOperation for ApplyAdadelta<T, var_Arg, accum_Arg, accum_update_Arg, lr_Arg, rho_Arg, epsilon_Arg, grad_Arg>
where T: TensorType,
      T: Clone,
      var_Arg: Clone,
      var_Arg: GraphRefEdge<T>,
      var_Arg: 'static,
      accum_Arg: Clone,
      accum_Arg: GraphRefEdge<T>,
      accum_Arg: 'static,
      accum_update_Arg: Clone,
      accum_update_Arg: GraphRefEdge<T>,
      accum_update_Arg: 'static,
      lr_Arg: Clone,
      lr_Arg: GraphEdge<T>,
      lr_Arg: 'static,
      rho_Arg: Clone,
      rho_Arg: GraphEdge<T>,
      rho_Arg: 'static,
      epsilon_Arg: Clone,
      epsilon_Arg: GraphEdge<T>,
      epsilon_Arg: 'static,
      grad_Arg: Clone,
      grad_Arg: GraphEdge<T>,
      grad_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("ApplyAdadelta_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("ApplyAdadelta", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.var)?
        }
        {
            new_op.add_edge(&self.accum)?
        }
        {
            new_op.add_edge(&self.accum_update)?
        }
        {
            new_op.add_edge(&self.lr)?
        }
        {
            new_op.add_edge(&self.rho)?
        }
        {
            new_op.add_edge(&self.epsilon)?
        }
        {
            new_op.add_edge(&self.grad)?
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        {
            match self.use_locking {
                None => new_op.set_attr_value_proto("use_locking", &vec![40_u8, 0_u8,])?,
                Some(ref value) => (|attr: &bool| {new_op.set_attr_bool("use_locking", *attr)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct ApplyAdadelta<T, var_Arg, accum_Arg, accum_update_Arg, lr_Arg, rho_Arg, epsilon_Arg, grad_Arg>
where T: TensorType,
      T: Clone,
      var_Arg: Clone,
      var_Arg: GraphRefEdge<T>,
      var_Arg: 'static,
      accum_Arg: Clone,
      accum_Arg: GraphRefEdge<T>,
      accum_Arg: 'static,
      accum_update_Arg: Clone,
      accum_update_Arg: GraphRefEdge<T>,
      accum_update_Arg: 'static,
      lr_Arg: Clone,
      lr_Arg: GraphEdge<T>,
      lr_Arg: 'static,
      rho_Arg: Clone,
      rho_Arg: GraphEdge<T>,
      rho_Arg: 'static,
      epsilon_Arg: Clone,
      epsilon_Arg: GraphEdge<T>,
      epsilon_Arg: 'static,
      grad_Arg: Clone,
      grad_Arg: GraphEdge<T>,
      grad_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    var: var_Arg,
    accum: accum_Arg,
    accum_update: accum_update_Arg,
    lr: lr_Arg,
    rho: rho_Arg,
    epsilon: epsilon_Arg,
    grad: grad_Arg,
    use_locking: Option<bool>,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<T, var_Arg, accum_Arg, accum_update_Arg, lr_Arg, rho_Arg, epsilon_Arg, grad_Arg> ApplyAdadelta<T, var_Arg, accum_Arg, accum_update_Arg, lr_Arg, rho_Arg, epsilon_Arg, grad_Arg>
where T: TensorType,
      T: Clone,
      var_Arg: Clone,
      var_Arg: GraphRefEdge<T>,
      var_Arg: 'static,
      accum_Arg: Clone,
      accum_Arg: GraphRefEdge<T>,
      accum_Arg: 'static,
      accum_update_Arg: Clone,
      accum_update_Arg: GraphRefEdge<T>,
      accum_update_Arg: 'static,
      lr_Arg: Clone,
      lr_Arg: GraphEdge<T>,
      lr_Arg: 'static,
      rho_Arg: Clone,
      rho_Arg: GraphEdge<T>,
      rho_Arg: 'static,
      epsilon_Arg: Clone,
      epsilon_Arg: GraphEdge<T>,
      epsilon_Arg: 'static,
      grad_Arg: Clone,
      grad_Arg: GraphEdge<T>,
      grad_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
{
    pub fn out(self) -> RefEdge<T> {
        let rc = Rc::new(self);
        {
            RefEdge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn use_locking(&mut self, use_locking: bool) -> Self {
        self.use_locking = Some(use_locking);
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> RefEdge<T> {
        let rc = Rc::new(self);
        {
            RefEdge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(var: var_Arg, accum: accum_Arg, accum_update: accum_update_Arg, lr: lr_Arg, rho: rho_Arg, epsilon: epsilon_Arg, grad: grad_Arg) -> Self {
        Self {
            phantom_T: PhantomData,
            var,
            accum,
            accum_update,
            lr,
            rho,
            epsilon,
            grad,
            use_locking: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(var: var_Arg, accum: accum_Arg, accum_update: accum_update_Arg, lr: lr_Arg, rho: rho_Arg, epsilon: epsilon_Arg, grad: grad_Arg) -> RefEdge<T> {
        Self {
            phantom_T: PhantomData,
            var,
            accum,
            accum_update,
            lr,
            rho,
            epsilon,
            grad,
            use_locking: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<T, var_Arg, accum_Arg, linear_Arg, grad_Arg, Tindices, indices_Arg, lr_Arg, l1_Arg, l2_Arg, lr_power_Arg> GraphOperation for SparseApplyFtrl<T, var_Arg, accum_Arg, linear_Arg, grad_Arg, Tindices, indices_Arg, lr_Arg, l1_Arg, l2_Arg, lr_power_Arg>
where T: TensorType,
      T: Clone,
      var_Arg: Clone,
      var_Arg: GraphRefEdge<T>,
      var_Arg: 'static,
      accum_Arg: Clone,
      accum_Arg: GraphRefEdge<T>,
      accum_Arg: 'static,
      linear_Arg: Clone,
      linear_Arg: GraphRefEdge<T>,
      linear_Arg: 'static,
      grad_Arg: Clone,
      grad_Arg: GraphEdge<T>,
      grad_Arg: 'static,
      Tindices: TensorType,
      Tindices: Clone,
      indices_Arg: Clone,
      indices_Arg: GraphEdge<Tindices>,
      indices_Arg: 'static,
      lr_Arg: Clone,
      lr_Arg: GraphEdge<T>,
      lr_Arg: 'static,
      l1_Arg: Clone,
      l1_Arg: GraphEdge<T>,
      l1_Arg: 'static,
      l2_Arg: Clone,
      l2_Arg: GraphEdge<T>,
      l2_Arg: 'static,
      lr_power_Arg: Clone,
      lr_power_Arg: GraphEdge<T>,
      lr_power_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
      Tindices: con_or_DT_INT32_or_DT_INT64,
      Tindices: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("SparseApplyFtrl_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("SparseApplyFtrl", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.var)?
        }
        {
            new_op.add_edge(&self.accum)?
        }
        {
            new_op.add_edge(&self.linear)?
        }
        {
            new_op.add_edge(&self.grad)?
        }
        {
            new_op.add_edge(&self.indices)?
        }
        {
            new_op.add_edge(&self.lr)?
        }
        {
            new_op.add_edge(&self.l1)?
        }
        {
            new_op.add_edge(&self.l2)?
        }
        {
            new_op.add_edge(&self.lr_power)?
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        {
            new_op.set_attr_type("Tindices", Tindices::data_type())?;
        }
        {
            match self.use_locking {
                None => new_op.set_attr_value_proto("use_locking", &vec![40_u8, 0_u8,])?,
                Some(ref value) => (|attr: &bool| {new_op.set_attr_bool("use_locking", *attr)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct SparseApplyFtrl<T, var_Arg, accum_Arg, linear_Arg, grad_Arg, Tindices, indices_Arg, lr_Arg, l1_Arg, l2_Arg, lr_power_Arg>
where T: TensorType,
      T: Clone,
      var_Arg: Clone,
      var_Arg: GraphRefEdge<T>,
      var_Arg: 'static,
      accum_Arg: Clone,
      accum_Arg: GraphRefEdge<T>,
      accum_Arg: 'static,
      linear_Arg: Clone,
      linear_Arg: GraphRefEdge<T>,
      linear_Arg: 'static,
      grad_Arg: Clone,
      grad_Arg: GraphEdge<T>,
      grad_Arg: 'static,
      Tindices: TensorType,
      Tindices: Clone,
      indices_Arg: Clone,
      indices_Arg: GraphEdge<Tindices>,
      indices_Arg: 'static,
      lr_Arg: Clone,
      lr_Arg: GraphEdge<T>,
      lr_Arg: 'static,
      l1_Arg: Clone,
      l1_Arg: GraphEdge<T>,
      l1_Arg: 'static,
      l2_Arg: Clone,
      l2_Arg: GraphEdge<T>,
      l2_Arg: 'static,
      lr_power_Arg: Clone,
      lr_power_Arg: GraphEdge<T>,
      lr_power_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
      Tindices: con_or_DT_INT32_or_DT_INT64,
      Tindices: 'static,
{
    phantom_T: PhantomData<T>,
    var: var_Arg,
    accum: accum_Arg,
    linear: linear_Arg,
    grad: grad_Arg,
    phantom_Tindices: PhantomData<Tindices>,
    indices: indices_Arg,
    lr: lr_Arg,
    l1: l1_Arg,
    l2: l2_Arg,
    lr_power: lr_power_Arg,
    use_locking: Option<bool>,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<T, var_Arg, accum_Arg, linear_Arg, grad_Arg, Tindices, indices_Arg, lr_Arg, l1_Arg, l2_Arg, lr_power_Arg> SparseApplyFtrl<T, var_Arg, accum_Arg, linear_Arg, grad_Arg, Tindices, indices_Arg, lr_Arg, l1_Arg, l2_Arg, lr_power_Arg>
where T: TensorType,
      T: Clone,
      var_Arg: Clone,
      var_Arg: GraphRefEdge<T>,
      var_Arg: 'static,
      accum_Arg: Clone,
      accum_Arg: GraphRefEdge<T>,
      accum_Arg: 'static,
      linear_Arg: Clone,
      linear_Arg: GraphRefEdge<T>,
      linear_Arg: 'static,
      grad_Arg: Clone,
      grad_Arg: GraphEdge<T>,
      grad_Arg: 'static,
      Tindices: TensorType,
      Tindices: Clone,
      indices_Arg: Clone,
      indices_Arg: GraphEdge<Tindices>,
      indices_Arg: 'static,
      lr_Arg: Clone,
      lr_Arg: GraphEdge<T>,
      lr_Arg: 'static,
      l1_Arg: Clone,
      l1_Arg: GraphEdge<T>,
      l1_Arg: 'static,
      l2_Arg: Clone,
      l2_Arg: GraphEdge<T>,
      l2_Arg: 'static,
      lr_power_Arg: Clone,
      lr_power_Arg: GraphEdge<T>,
      lr_power_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
      Tindices: con_or_DT_INT32_or_DT_INT64,
      Tindices: 'static,
{
    pub fn out(self) -> RefEdge<T> {
        let rc = Rc::new(self);
        {
            RefEdge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn use_locking(&mut self, use_locking: bool) -> Self {
        self.use_locking = Some(use_locking);
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> RefEdge<T> {
        let rc = Rc::new(self);
        {
            RefEdge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(var: var_Arg, accum: accum_Arg, linear: linear_Arg, grad: grad_Arg, indices: indices_Arg, lr: lr_Arg, l1: l1_Arg, l2: l2_Arg, lr_power: lr_power_Arg) -> Self {
        Self {
            phantom_T: PhantomData,
            var,
            accum,
            linear,
            grad,
            phantom_Tindices: PhantomData,
            indices,
            lr,
            l1,
            l2,
            lr_power,
            use_locking: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(var: var_Arg, accum: accum_Arg, linear: linear_Arg, grad: grad_Arg, indices: indices_Arg, lr: lr_Arg, l1: l1_Arg, l2: l2_Arg, lr_power: lr_power_Arg) -> RefEdge<T> {
        Self {
            phantom_T: PhantomData,
            var,
            accum,
            linear,
            grad,
            phantom_Tindices: PhantomData,
            indices,
            lr,
            l1,
            l2,
            lr_power,
            use_locking: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<input_Arg> GraphOperation for UnicodeDecodeWithOffsets<input_Arg>
where input_Arg: Clone,
      input_Arg: GraphEdge<String>,
      input_Arg: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("UnicodeDecodeWithOffsets_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("UnicodeDecodeWithOffsets", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.input)?
        }
        {
            (|attr| {new_op.set_attr_string("input_encoding", attr)})(&self.input_encoding)?
        }
        {
            match self.errors {
                None => new_op.set_attr_value_proto("errors", &vec![18_u8, 7_u8, 114_u8, 101_u8, 112_u8, 108_u8, 97_u8, 99_u8, 101_u8,])?,
                Some(ref value) => (|attr| {new_op.set_attr_string("errors", attr)})(&value)?,
            };
        }
        {
            match self.replacement_char {
                None => new_op.set_attr_value_proto("replacement_char", &vec![24_u8, 253_u8, 255_u8, 3_u8,])?,
                Some(ref value) => (|attr: &i64| {new_op.set_attr_int("replacement_char", *attr)})(&value)?,
            };
        }
        {
            match self.replace_control_characters {
                None => new_op.set_attr_value_proto("replace_control_characters", &vec![40_u8, 0_u8,])?,
                Some(ref value) => (|attr: &bool| {new_op.set_attr_bool("replace_control_characters", *attr)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct UnicodeDecodeWithOffsets<input_Arg>
where input_Arg: Clone,
      input_Arg: GraphEdge<String>,
      input_Arg: 'static,
{
    input: input_Arg,
    input_encoding: String,
    errors: Option<String>,
    replacement_char: Option<i64>,
    replace_control_characters: Option<bool>,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<input_Arg> UnicodeDecodeWithOffsets<input_Arg>
where input_Arg: Clone,
      input_Arg: GraphEdge<String>,
      input_Arg: 'static,
{
    pub fn row_splits(self) -> Edge<i64> {
        let rc = Rc::new(self);
        {
            Edge::<i64>::new(rc.clone(), 0)
        }
    }

    pub fn char_values(self) -> Edge<i32> {
        let rc = Rc::new(self);
        {
            Edge::<i32>::new(rc.clone(), 1)
        }
    }

    pub fn char_to_byte_starts(self) -> Edge<i64> {
        let rc = Rc::new(self);
        {
            Edge::<i64>::new(rc.clone(), 2)
        }
    }

    pub fn errors(&mut self, errors: &str) -> Self {
        self.errors = Some(errors.to_string());
        self.clone()
    }

    pub fn replacement_char(&mut self, replacement_char: i64) -> Self {
        self.replacement_char = Some(replacement_char);
        self.clone()
    }

    pub fn replace_control_characters(&mut self, replace_control_characters: bool) -> Self {
        self.replace_control_characters = Some(replace_control_characters);
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> (Edge<i64>, Edge<i32>, Edge<i64>) {
        let rc = Rc::new(self);
        (
        {
            Edge::<i64>::new(rc.clone(), 0)
        },
        {
            Edge::<i32>::new(rc.clone(), 1)
        },
        {
            Edge::<i64>::new(rc.clone(), 2)
        },
        )
    }

    pub fn build(input: input_Arg, input_encoding: &str) -> Self {
        Self {
            input,
            input_encoding: input_encoding.to_string(),
            errors: None,
            replacement_char: None,
            replace_control_characters: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(input: input_Arg, input_encoding: &str) -> (Edge<i64>, Edge<i32>, Edge<i64>) {
        Self {
            input,
            input_encoding: input_encoding.to_string(),
            errors: None,
            replacement_char: None,
            replace_control_characters: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<input_Arg> GraphOperation for UnicodeDecode<input_Arg>
where input_Arg: Clone,
      input_Arg: GraphEdge<String>,
      input_Arg: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("UnicodeDecode_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("UnicodeDecode", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.input)?
        }
        {
            (|attr| {new_op.set_attr_string("input_encoding", attr)})(&self.input_encoding)?
        }
        {
            match self.errors {
                None => new_op.set_attr_value_proto("errors", &vec![18_u8, 7_u8, 114_u8, 101_u8, 112_u8, 108_u8, 97_u8, 99_u8, 101_u8,])?,
                Some(ref value) => (|attr| {new_op.set_attr_string("errors", attr)})(&value)?,
            };
        }
        {
            match self.replacement_char {
                None => new_op.set_attr_value_proto("replacement_char", &vec![24_u8, 253_u8, 255_u8, 3_u8,])?,
                Some(ref value) => (|attr: &i64| {new_op.set_attr_int("replacement_char", *attr)})(&value)?,
            };
        }
        {
            match self.replace_control_characters {
                None => new_op.set_attr_value_proto("replace_control_characters", &vec![40_u8, 0_u8,])?,
                Some(ref value) => (|attr: &bool| {new_op.set_attr_bool("replace_control_characters", *attr)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct UnicodeDecode<input_Arg>
where input_Arg: Clone,
      input_Arg: GraphEdge<String>,
      input_Arg: 'static,
{
    input: input_Arg,
    input_encoding: String,
    errors: Option<String>,
    replacement_char: Option<i64>,
    replace_control_characters: Option<bool>,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<input_Arg> UnicodeDecode<input_Arg>
where input_Arg: Clone,
      input_Arg: GraphEdge<String>,
      input_Arg: 'static,
{
    pub fn row_splits(self) -> Edge<i64> {
        let rc = Rc::new(self);
        {
            Edge::<i64>::new(rc.clone(), 0)
        }
    }

    pub fn char_values(self) -> Edge<i32> {
        let rc = Rc::new(self);
        {
            Edge::<i32>::new(rc.clone(), 1)
        }
    }

    pub fn errors(&mut self, errors: &str) -> Self {
        self.errors = Some(errors.to_string());
        self.clone()
    }

    pub fn replacement_char(&mut self, replacement_char: i64) -> Self {
        self.replacement_char = Some(replacement_char);
        self.clone()
    }

    pub fn replace_control_characters(&mut self, replace_control_characters: bool) -> Self {
        self.replace_control_characters = Some(replace_control_characters);
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> (Edge<i64>, Edge<i32>) {
        let rc = Rc::new(self);
        (
        {
            Edge::<i64>::new(rc.clone(), 0)
        },
        {
            Edge::<i32>::new(rc.clone(), 1)
        },
        )
    }

    pub fn build(input: input_Arg, input_encoding: &str) -> Self {
        Self {
            input,
            input_encoding: input_encoding.to_string(),
            errors: None,
            replacement_char: None,
            replace_control_characters: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(input: input_Arg, input_encoding: &str) -> (Edge<i64>, Edge<i32>) {
        Self {
            input,
            input_encoding: input_encoding.to_string(),
            errors: None,
            replacement_char: None,
            replace_control_characters: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<input_Arg> GraphOperation for UnicodeScript<input_Arg>
where input_Arg: Clone,
      input_Arg: GraphEdge<i32>,
      input_Arg: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("UnicodeScript_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("UnicodeScript", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.input)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct UnicodeScript<input_Arg>
where input_Arg: Clone,
      input_Arg: GraphEdge<i32>,
      input_Arg: 'static,
{
    input: input_Arg,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<input_Arg> UnicodeScript<input_Arg>
where input_Arg: Clone,
      input_Arg: GraphEdge<i32>,
      input_Arg: 'static,
{
    pub fn output(self) -> Edge<i32> {
        let rc = Rc::new(self);
        {
            Edge::<i32>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<i32> {
        let rc = Rc::new(self);
        {
            Edge::<i32>::new(rc.clone(), 0)
        }
    }

    pub fn build(input: input_Arg) -> Self {
        Self {
            input,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(input: input_Arg) -> Edge<i32> {
        Self {
            input,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<input_Arg, T, pos_Arg, len_Arg> GraphOperation for Substr<input_Arg, T, pos_Arg, len_Arg>
where input_Arg: Clone,
      input_Arg: GraphEdge<String>,
      input_Arg: 'static,
      T: TensorType,
      T: Clone,
      pos_Arg: Clone,
      pos_Arg: GraphEdge<T>,
      pos_Arg: 'static,
      len_Arg: Clone,
      len_Arg: GraphEdge<T>,
      len_Arg: 'static,
      T: con_or_DT_INT32_or_DT_INT64,
      T: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("Substr_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("Substr", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.input)?
        }
        {
            new_op.add_edge(&self.pos)?
        }
        {
            new_op.add_edge(&self.len)?
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        {
            match self.unit {
                None => new_op.set_attr_value_proto("unit", &vec![18_u8, 4_u8, 66_u8, 89_u8, 84_u8, 69_u8,])?,
                Some(ref value) => (|attr| {new_op.set_attr_string("unit", attr)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct Substr<input_Arg, T, pos_Arg, len_Arg>
where input_Arg: Clone,
      input_Arg: GraphEdge<String>,
      input_Arg: 'static,
      T: TensorType,
      T: Clone,
      pos_Arg: Clone,
      pos_Arg: GraphEdge<T>,
      pos_Arg: 'static,
      len_Arg: Clone,
      len_Arg: GraphEdge<T>,
      len_Arg: 'static,
      T: con_or_DT_INT32_or_DT_INT64,
      T: 'static,
{
    input: input_Arg,
    phantom_T: PhantomData<T>,
    pos: pos_Arg,
    len: len_Arg,
    unit: Option<String>,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<input_Arg, T, pos_Arg, len_Arg> Substr<input_Arg, T, pos_Arg, len_Arg>
where input_Arg: Clone,
      input_Arg: GraphEdge<String>,
      input_Arg: 'static,
      T: TensorType,
      T: Clone,
      pos_Arg: Clone,
      pos_Arg: GraphEdge<T>,
      pos_Arg: 'static,
      len_Arg: Clone,
      len_Arg: GraphEdge<T>,
      len_Arg: 'static,
      T: con_or_DT_INT32_or_DT_INT64,
      T: 'static,
{
    pub fn output(self) -> Edge<String> {
        let rc = Rc::new(self);
        {
            Edge::<String>::new(rc.clone(), 0)
        }
    }

    pub fn unit(&mut self, unit: &str) -> Self {
        self.unit = Some(unit.to_string());
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<String> {
        let rc = Rc::new(self);
        {
            Edge::<String>::new(rc.clone(), 0)
        }
    }

    pub fn build(input: input_Arg, pos: pos_Arg, len: len_Arg) -> Self {
        Self {
            input,
            phantom_T: PhantomData,
            pos,
            len,
            unit: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(input: input_Arg, pos: pos_Arg, len: len_Arg) -> Edge<String> {
        Self {
            input,
            phantom_T: PhantomData,
            pos,
            len,
            unit: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<input_Arg> GraphOperation for StringStrip<input_Arg>
where input_Arg: Clone,
      input_Arg: GraphEdge<String>,
      input_Arg: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("StringStrip_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("StringStrip", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.input)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct StringStrip<input_Arg>
where input_Arg: Clone,
      input_Arg: GraphEdge<String>,
      input_Arg: 'static,
{
    input: input_Arg,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<input_Arg> StringStrip<input_Arg>
where input_Arg: Clone,
      input_Arg: GraphEdge<String>,
      input_Arg: 'static,
{
    pub fn output(self) -> Edge<String> {
        let rc = Rc::new(self);
        {
            Edge::<String>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<String> {
        let rc = Rc::new(self);
        {
            Edge::<String>::new(rc.clone(), 0)
        }
    }

    pub fn build(input: input_Arg) -> Self {
        Self {
            input,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(input: input_Arg) -> Edge<String> {
        Self {
            input,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<input_Arg, delimiter_Arg> GraphOperation for StringSplit<input_Arg, delimiter_Arg>
where input_Arg: Clone,
      input_Arg: GraphEdge<String>,
      input_Arg: 'static,
      delimiter_Arg: Clone,
      delimiter_Arg: GraphEdge<String>,
      delimiter_Arg: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("StringSplit_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("StringSplit", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.input)?
        }
        {
            new_op.add_edge(&self.delimiter)?
        }
        {
            match self.skip_empty {
                None => new_op.set_attr_value_proto("skip_empty", &vec![40_u8, 1_u8,])?,
                Some(ref value) => (|attr: &bool| {new_op.set_attr_bool("skip_empty", *attr)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct StringSplit<input_Arg, delimiter_Arg>
where input_Arg: Clone,
      input_Arg: GraphEdge<String>,
      input_Arg: 'static,
      delimiter_Arg: Clone,
      delimiter_Arg: GraphEdge<String>,
      delimiter_Arg: 'static,
{
    input: input_Arg,
    delimiter: delimiter_Arg,
    skip_empty: Option<bool>,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<input_Arg, delimiter_Arg> StringSplit<input_Arg, delimiter_Arg>
where input_Arg: Clone,
      input_Arg: GraphEdge<String>,
      input_Arg: 'static,
      delimiter_Arg: Clone,
      delimiter_Arg: GraphEdge<String>,
      delimiter_Arg: 'static,
{
    pub fn indices(self) -> Edge<i64> {
        let rc = Rc::new(self);
        {
            Edge::<i64>::new(rc.clone(), 0)
        }
    }

    pub fn values(self) -> Edge<String> {
        let rc = Rc::new(self);
        {
            Edge::<String>::new(rc.clone(), 1)
        }
    }

    pub fn shape(self) -> Edge<i64> {
        let rc = Rc::new(self);
        {
            Edge::<i64>::new(rc.clone(), 2)
        }
    }

    pub fn skip_empty(&mut self, skip_empty: bool) -> Self {
        self.skip_empty = Some(skip_empty);
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> (Edge<i64>, Edge<String>, Edge<i64>) {
        let rc = Rc::new(self);
        (
        {
            Edge::<i64>::new(rc.clone(), 0)
        },
        {
            Edge::<String>::new(rc.clone(), 1)
        },
        {
            Edge::<i64>::new(rc.clone(), 2)
        },
        )
    }

    pub fn build(input: input_Arg, delimiter: delimiter_Arg) -> Self {
        Self {
            input,
            delimiter,
            skip_empty: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(input: input_Arg, delimiter: delimiter_Arg) -> (Edge<i64>, Edge<String>, Edge<i64>) {
        Self {
            input,
            delimiter,
            skip_empty: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<string_tensor_Arg> GraphOperation for StringToHashBucket<string_tensor_Arg>
where string_tensor_Arg: Clone,
      string_tensor_Arg: GraphEdge<String>,
      string_tensor_Arg: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("StringToHashBucket_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("StringToHashBucket", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.string_tensor)?
        }
        {
            (|attr: &i64| {new_op.set_attr_int("num_buckets", *attr)})(&self.num_buckets)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct StringToHashBucket<string_tensor_Arg>
where string_tensor_Arg: Clone,
      string_tensor_Arg: GraphEdge<String>,
      string_tensor_Arg: 'static,
{
    string_tensor: string_tensor_Arg,
    num_buckets: i64,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<string_tensor_Arg> StringToHashBucket<string_tensor_Arg>
where string_tensor_Arg: Clone,
      string_tensor_Arg: GraphEdge<String>,
      string_tensor_Arg: 'static,
{
    pub fn output(self) -> Edge<i64> {
        let rc = Rc::new(self);
        {
            Edge::<i64>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<i64> {
        let rc = Rc::new(self);
        {
            Edge::<i64>::new(rc.clone(), 0)
        }
    }

    pub fn build(string_tensor: string_tensor_Arg, num_buckets: i64) -> Self {
        Self {
            string_tensor,
            num_buckets: num_buckets,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(string_tensor: string_tensor_Arg, num_buckets: i64) -> Edge<i64> {
        Self {
            string_tensor,
            num_buckets: num_buckets,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<input_Arg> GraphOperation for StringLength<input_Arg>
where input_Arg: Clone,
      input_Arg: GraphEdge<String>,
      input_Arg: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("StringLength_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("StringLength", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.input)?
        }
        {
            match self.unit {
                None => new_op.set_attr_value_proto("unit", &vec![18_u8, 4_u8, 66_u8, 89_u8, 84_u8, 69_u8,])?,
                Some(ref value) => (|attr| {new_op.set_attr_string("unit", attr)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct StringLength<input_Arg>
where input_Arg: Clone,
      input_Arg: GraphEdge<String>,
      input_Arg: 'static,
{
    input: input_Arg,
    unit: Option<String>,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<input_Arg> StringLength<input_Arg>
where input_Arg: Clone,
      input_Arg: GraphEdge<String>,
      input_Arg: 'static,
{
    pub fn output(self) -> Edge<i32> {
        let rc = Rc::new(self);
        {
            Edge::<i32>::new(rc.clone(), 0)
        }
    }

    pub fn unit(&mut self, unit: &str) -> Self {
        self.unit = Some(unit.to_string());
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<i32> {
        let rc = Rc::new(self);
        {
            Edge::<i32>::new(rc.clone(), 0)
        }
    }

    pub fn build(input: input_Arg) -> Self {
        Self {
            input,
            unit: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(input: input_Arg) -> Edge<i32> {
        Self {
            input,
            unit: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<input_Arg> GraphOperation for StringToHashBucketStrong<input_Arg>
where input_Arg: Clone,
      input_Arg: GraphEdge<String>,
      input_Arg: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("StringToHashBucketStrong_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("StringToHashBucketStrong", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.input)?
        }
        {
            (|attr: &i64| {new_op.set_attr_int("num_buckets", *attr)})(&self.num_buckets)?
        }
        {
            (|attrs| {new_op.set_attr_int_list("key", attrs)})(&self.key)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct StringToHashBucketStrong<input_Arg>
where input_Arg: Clone,
      input_Arg: GraphEdge<String>,
      input_Arg: 'static,
{
    input: input_Arg,
    num_buckets: i64,
    key: Vec<i64>,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<input_Arg> StringToHashBucketStrong<input_Arg>
where input_Arg: Clone,
      input_Arg: GraphEdge<String>,
      input_Arg: 'static,
{
    pub fn output(self) -> Edge<i64> {
        let rc = Rc::new(self);
        {
            Edge::<i64>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<i64> {
        let rc = Rc::new(self);
        {
            Edge::<i64>::new(rc.clone(), 0)
        }
    }

    pub fn build(input: input_Arg, num_buckets: i64, key: &[i64]) -> Self {
        Self {
            input,
            num_buckets: num_buckets,
            key: key.to_vec(),
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(input: input_Arg, num_buckets: i64, key: &[i64]) -> Edge<i64> {
        Self {
            input,
            num_buckets: num_buckets,
            key: key.to_vec(),
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<input_Arg> GraphOperation for StringToHashBucketFast<input_Arg>
where input_Arg: Clone,
      input_Arg: GraphEdge<String>,
      input_Arg: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("StringToHashBucketFast_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("StringToHashBucketFast", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.input)?
        }
        {
            (|attr: &i64| {new_op.set_attr_int("num_buckets", *attr)})(&self.num_buckets)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct StringToHashBucketFast<input_Arg>
where input_Arg: Clone,
      input_Arg: GraphEdge<String>,
      input_Arg: 'static,
{
    input: input_Arg,
    num_buckets: i64,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<input_Arg> StringToHashBucketFast<input_Arg>
where input_Arg: Clone,
      input_Arg: GraphEdge<String>,
      input_Arg: 'static,
{
    pub fn output(self) -> Edge<i64> {
        let rc = Rc::new(self);
        {
            Edge::<i64>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<i64> {
        let rc = Rc::new(self);
        {
            Edge::<i64>::new(rc.clone(), 0)
        }
    }

    pub fn build(input: input_Arg, num_buckets: i64) -> Self {
        Self {
            input,
            num_buckets: num_buckets,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(input: input_Arg, num_buckets: i64) -> Edge<i64> {
        Self {
            input,
            num_buckets: num_buckets,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<input_Arg> GraphOperation for StaticRegexFullMatch<input_Arg>
where input_Arg: Clone,
      input_Arg: GraphEdge<String>,
      input_Arg: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("StaticRegexFullMatch_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("StaticRegexFullMatch", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.input)?
        }
        {
            (|attr| {new_op.set_attr_string("pattern", attr)})(&self.pattern)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct StaticRegexFullMatch<input_Arg>
where input_Arg: Clone,
      input_Arg: GraphEdge<String>,
      input_Arg: 'static,
{
    input: input_Arg,
    pattern: String,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<input_Arg> StaticRegexFullMatch<input_Arg>
where input_Arg: Clone,
      input_Arg: GraphEdge<String>,
      input_Arg: 'static,
{
    pub fn output(self) -> Edge<bool> {
        let rc = Rc::new(self);
        {
            Edge::<bool>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<bool> {
        let rc = Rc::new(self);
        {
            Edge::<bool>::new(rc.clone(), 0)
        }
    }

    pub fn build(input: input_Arg, pattern: &str) -> Self {
        Self {
            input,
            pattern: pattern.to_string(),
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(input: input_Arg, pattern: &str) -> Edge<bool> {
        Self {
            input,
            pattern: pattern.to_string(),
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<input_Arg, pattern_Arg> GraphOperation for RegexFullMatch<input_Arg, pattern_Arg>
where input_Arg: Clone,
      input_Arg: GraphEdge<String>,
      input_Arg: 'static,
      pattern_Arg: Clone,
      pattern_Arg: GraphEdge<String>,
      pattern_Arg: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("RegexFullMatch_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("RegexFullMatch", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.input)?
        }
        {
            new_op.add_edge(&self.pattern)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct RegexFullMatch<input_Arg, pattern_Arg>
where input_Arg: Clone,
      input_Arg: GraphEdge<String>,
      input_Arg: 'static,
      pattern_Arg: Clone,
      pattern_Arg: GraphEdge<String>,
      pattern_Arg: 'static,
{
    input: input_Arg,
    pattern: pattern_Arg,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<input_Arg, pattern_Arg> RegexFullMatch<input_Arg, pattern_Arg>
where input_Arg: Clone,
      input_Arg: GraphEdge<String>,
      input_Arg: 'static,
      pattern_Arg: Clone,
      pattern_Arg: GraphEdge<String>,
      pattern_Arg: 'static,
{
    pub fn output(self) -> Edge<bool> {
        let rc = Rc::new(self);
        {
            Edge::<bool>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<bool> {
        let rc = Rc::new(self);
        {
            Edge::<bool>::new(rc.clone(), 0)
        }
    }

    pub fn build(input: input_Arg, pattern: pattern_Arg) -> Self {
        Self {
            input,
            pattern,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(input: input_Arg, pattern: pattern_Arg) -> Edge<bool> {
        Self {
            input,
            pattern,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

pub trait con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64 for BFloat16 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64 for f32 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64 for f64 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64 for i16 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64 for i32 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64 for i64 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64 for i8 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64 for u16 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64 for u32 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64 for u64 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64 for u8 {
}

impl<T, logits_Arg, num_samples_Arg, Tseed, seed_Arg, output_dtype> GraphOperation for StatelessMultinomial<T, logits_Arg, num_samples_Arg, Tseed, seed_Arg, output_dtype>
where T: TensorType,
      T: Clone,
      logits_Arg: Clone,
      logits_Arg: GraphEdge<T>,
      logits_Arg: 'static,
      num_samples_Arg: Clone,
      num_samples_Arg: GraphEdge<i32>,
      num_samples_Arg: 'static,
      Tseed: TensorType,
      Tseed: Clone,
      seed_Arg: Clone,
      seed_Arg: GraphEdge<Tseed>,
      seed_Arg: 'static,
      output_dtype: TensorType,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
      Tseed: con_or_DT_INT32_or_DT_INT64,
      Tseed: 'static,
      output_dtype: con_or_DT_INT32_or_DT_INT64,
      output_dtype: 'static,
      output_dtype: Clone,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("StatelessMultinomial_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("StatelessMultinomial", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.logits)?
        }
        {
            new_op.add_edge(&self.num_samples)?
        }
        {
            new_op.add_edge(&self.seed)?
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        {
            new_op.set_attr_type("Tseed", Tseed::data_type())?;
        }
        {
            new_op.set_attr_type("output_dtype", output_dtype::data_type())?;
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct StatelessMultinomial<T, logits_Arg, num_samples_Arg, Tseed, seed_Arg, output_dtype>
where T: TensorType,
      T: Clone,
      logits_Arg: Clone,
      logits_Arg: GraphEdge<T>,
      logits_Arg: 'static,
      num_samples_Arg: Clone,
      num_samples_Arg: GraphEdge<i32>,
      num_samples_Arg: 'static,
      Tseed: TensorType,
      Tseed: Clone,
      seed_Arg: Clone,
      seed_Arg: GraphEdge<Tseed>,
      seed_Arg: 'static,
      output_dtype: TensorType,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
      Tseed: con_or_DT_INT32_or_DT_INT64,
      Tseed: 'static,
      output_dtype: con_or_DT_INT32_or_DT_INT64,
      output_dtype: 'static,
      output_dtype: Clone,
{
    phantom_T: PhantomData<T>,
    logits: logits_Arg,
    num_samples: num_samples_Arg,
    phantom_Tseed: PhantomData<Tseed>,
    seed: seed_Arg,
    phantom_output_dtype: PhantomData<output_dtype>,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<T, logits_Arg, num_samples_Arg, Tseed, seed_Arg, output_dtype> StatelessMultinomial<T, logits_Arg, num_samples_Arg, Tseed, seed_Arg, output_dtype>
where T: TensorType,
      T: Clone,
      logits_Arg: Clone,
      logits_Arg: GraphEdge<T>,
      logits_Arg: 'static,
      num_samples_Arg: Clone,
      num_samples_Arg: GraphEdge<i32>,
      num_samples_Arg: 'static,
      Tseed: TensorType,
      Tseed: Clone,
      seed_Arg: Clone,
      seed_Arg: GraphEdge<Tseed>,
      seed_Arg: 'static,
      output_dtype: TensorType,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
      Tseed: con_or_DT_INT32_or_DT_INT64,
      Tseed: 'static,
      output_dtype: con_or_DT_INT32_or_DT_INT64,
      output_dtype: 'static,
      output_dtype: Clone,
{
    pub fn output(self) -> Edge<output_dtype> {
        let rc = Rc::new(self);
        {
            Edge::<output_dtype>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<output_dtype> {
        let rc = Rc::new(self);
        {
            Edge::<output_dtype>::new(rc.clone(), 0)
        }
    }

    pub fn build(logits: logits_Arg, num_samples: num_samples_Arg, seed: seed_Arg) -> Self {
        Self {
            phantom_T: PhantomData,
            logits,
            num_samples,
            phantom_Tseed: PhantomData,
            seed,
            phantom_output_dtype: PhantomData,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(logits: logits_Arg, num_samples: num_samples_Arg, seed: seed_Arg) -> Edge<output_dtype> {
        Self {
            phantom_T: PhantomData,
            logits,
            num_samples,
            phantom_Tseed: PhantomData,
            seed,
            phantom_output_dtype: PhantomData,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<T, shape_Arg, Tseed, seed_Arg, dtype, minval_Arg, maxval_Arg> GraphOperation for StatelessRandomUniformInt<T, shape_Arg, Tseed, seed_Arg, dtype, minval_Arg, maxval_Arg>
where T: TensorType,
      T: Clone,
      shape_Arg: Clone,
      shape_Arg: GraphEdge<T>,
      shape_Arg: 'static,
      Tseed: TensorType,
      Tseed: Clone,
      seed_Arg: Clone,
      seed_Arg: GraphEdge<Tseed>,
      seed_Arg: 'static,
      dtype: TensorType,
      dtype: Clone,
      minval_Arg: Clone,
      minval_Arg: GraphEdge<dtype>,
      minval_Arg: 'static,
      maxval_Arg: Clone,
      maxval_Arg: GraphEdge<dtype>,
      maxval_Arg: 'static,
      dtype: con_or_DT_INT32_or_DT_INT64,
      dtype: 'static,
      T: con_or_DT_INT32_or_DT_INT64,
      T: 'static,
      Tseed: con_or_DT_INT32_or_DT_INT64,
      Tseed: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("StatelessRandomUniformInt_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("StatelessRandomUniformInt", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.shape)?
        }
        {
            new_op.add_edge(&self.seed)?
        }
        {
            new_op.add_edge(&self.minval)?
        }
        {
            new_op.add_edge(&self.maxval)?
        }
        {
            new_op.set_attr_type("dtype", dtype::data_type())?;
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        {
            new_op.set_attr_type("Tseed", Tseed::data_type())?;
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct StatelessRandomUniformInt<T, shape_Arg, Tseed, seed_Arg, dtype, minval_Arg, maxval_Arg>
where T: TensorType,
      T: Clone,
      shape_Arg: Clone,
      shape_Arg: GraphEdge<T>,
      shape_Arg: 'static,
      Tseed: TensorType,
      Tseed: Clone,
      seed_Arg: Clone,
      seed_Arg: GraphEdge<Tseed>,
      seed_Arg: 'static,
      dtype: TensorType,
      dtype: Clone,
      minval_Arg: Clone,
      minval_Arg: GraphEdge<dtype>,
      minval_Arg: 'static,
      maxval_Arg: Clone,
      maxval_Arg: GraphEdge<dtype>,
      maxval_Arg: 'static,
      dtype: con_or_DT_INT32_or_DT_INT64,
      dtype: 'static,
      T: con_or_DT_INT32_or_DT_INT64,
      T: 'static,
      Tseed: con_or_DT_INT32_or_DT_INT64,
      Tseed: 'static,
{
    phantom_T: PhantomData<T>,
    shape: shape_Arg,
    phantom_Tseed: PhantomData<Tseed>,
    seed: seed_Arg,
    phantom_dtype: PhantomData<dtype>,
    minval: minval_Arg,
    maxval: maxval_Arg,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<T, shape_Arg, Tseed, seed_Arg, dtype, minval_Arg, maxval_Arg> StatelessRandomUniformInt<T, shape_Arg, Tseed, seed_Arg, dtype, minval_Arg, maxval_Arg>
where T: TensorType,
      T: Clone,
      shape_Arg: Clone,
      shape_Arg: GraphEdge<T>,
      shape_Arg: 'static,
      Tseed: TensorType,
      Tseed: Clone,
      seed_Arg: Clone,
      seed_Arg: GraphEdge<Tseed>,
      seed_Arg: 'static,
      dtype: TensorType,
      dtype: Clone,
      minval_Arg: Clone,
      minval_Arg: GraphEdge<dtype>,
      minval_Arg: 'static,
      maxval_Arg: Clone,
      maxval_Arg: GraphEdge<dtype>,
      maxval_Arg: 'static,
      dtype: con_or_DT_INT32_or_DT_INT64,
      dtype: 'static,
      T: con_or_DT_INT32_or_DT_INT64,
      T: 'static,
      Tseed: con_or_DT_INT32_or_DT_INT64,
      Tseed: 'static,
{
    pub fn output(self) -> Edge<dtype> {
        let rc = Rc::new(self);
        {
            Edge::<dtype>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<dtype> {
        let rc = Rc::new(self);
        {
            Edge::<dtype>::new(rc.clone(), 0)
        }
    }

    pub fn build(shape: shape_Arg, seed: seed_Arg, minval: minval_Arg, maxval: maxval_Arg) -> Self {
        Self {
            phantom_T: PhantomData,
            shape,
            phantom_Tseed: PhantomData,
            seed,
            phantom_dtype: PhantomData,
            minval,
            maxval,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(shape: shape_Arg, seed: seed_Arg, minval: minval_Arg, maxval: maxval_Arg) -> Edge<dtype> {
        Self {
            phantom_T: PhantomData,
            shape,
            phantom_Tseed: PhantomData,
            seed,
            phantom_dtype: PhantomData,
            minval,
            maxval,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

pub trait con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF for BFloat16 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF for f32 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF for f64 {
}

impl<T, shape_Arg, Tseed, seed_Arg, dtype> GraphOperation for StatelessTruncatedNormal<T, shape_Arg, Tseed, seed_Arg, dtype>
where T: TensorType,
      T: Clone,
      shape_Arg: Clone,
      shape_Arg: GraphEdge<T>,
      shape_Arg: 'static,
      Tseed: TensorType,
      Tseed: Clone,
      seed_Arg: Clone,
      seed_Arg: GraphEdge<Tseed>,
      seed_Arg: 'static,
      dtype: TensorType,
      dtype: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
      dtype: 'static,
      dtype: Clone,
      T: con_or_DT_INT32_or_DT_INT64,
      T: 'static,
      Tseed: con_or_DT_INT32_or_DT_INT64,
      Tseed: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("StatelessTruncatedNormal_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("StatelessTruncatedNormal", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.shape)?
        }
        {
            new_op.add_edge(&self.seed)?
        }
        {
            new_op.set_attr_type("dtype", dtype::data_type())?;
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        {
            new_op.set_attr_type("Tseed", Tseed::data_type())?;
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct StatelessTruncatedNormal<T, shape_Arg, Tseed, seed_Arg, dtype>
where T: TensorType,
      T: Clone,
      shape_Arg: Clone,
      shape_Arg: GraphEdge<T>,
      shape_Arg: 'static,
      Tseed: TensorType,
      Tseed: Clone,
      seed_Arg: Clone,
      seed_Arg: GraphEdge<Tseed>,
      seed_Arg: 'static,
      dtype: TensorType,
      dtype: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
      dtype: 'static,
      dtype: Clone,
      T: con_or_DT_INT32_or_DT_INT64,
      T: 'static,
      Tseed: con_or_DT_INT32_or_DT_INT64,
      Tseed: 'static,
{
    phantom_T: PhantomData<T>,
    shape: shape_Arg,
    phantom_Tseed: PhantomData<Tseed>,
    seed: seed_Arg,
    phantom_dtype: PhantomData<dtype>,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<T, shape_Arg, Tseed, seed_Arg, dtype> StatelessTruncatedNormal<T, shape_Arg, Tseed, seed_Arg, dtype>
where T: TensorType,
      T: Clone,
      shape_Arg: Clone,
      shape_Arg: GraphEdge<T>,
      shape_Arg: 'static,
      Tseed: TensorType,
      Tseed: Clone,
      seed_Arg: Clone,
      seed_Arg: GraphEdge<Tseed>,
      seed_Arg: 'static,
      dtype: TensorType,
      dtype: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
      dtype: 'static,
      dtype: Clone,
      T: con_or_DT_INT32_or_DT_INT64,
      T: 'static,
      Tseed: con_or_DT_INT32_or_DT_INT64,
      Tseed: 'static,
{
    pub fn output(self) -> Edge<dtype> {
        let rc = Rc::new(self);
        {
            Edge::<dtype>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<dtype> {
        let rc = Rc::new(self);
        {
            Edge::<dtype>::new(rc.clone(), 0)
        }
    }

    pub fn build(shape: shape_Arg, seed: seed_Arg) -> Self {
        Self {
            phantom_T: PhantomData,
            shape,
            phantom_Tseed: PhantomData,
            seed,
            phantom_dtype: PhantomData,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(shape: shape_Arg, seed: seed_Arg) -> Edge<dtype> {
        Self {
            phantom_T: PhantomData,
            shape,
            phantom_Tseed: PhantomData,
            seed,
            phantom_dtype: PhantomData,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<T, shape_Arg, Tseed, seed_Arg, dtype> GraphOperation for StatelessRandomNormal<T, shape_Arg, Tseed, seed_Arg, dtype>
where T: TensorType,
      T: Clone,
      shape_Arg: Clone,
      shape_Arg: GraphEdge<T>,
      shape_Arg: 'static,
      Tseed: TensorType,
      Tseed: Clone,
      seed_Arg: Clone,
      seed_Arg: GraphEdge<Tseed>,
      seed_Arg: 'static,
      dtype: TensorType,
      dtype: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
      dtype: 'static,
      dtype: Clone,
      T: con_or_DT_INT32_or_DT_INT64,
      T: 'static,
      Tseed: con_or_DT_INT32_or_DT_INT64,
      Tseed: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("StatelessRandomNormal_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("StatelessRandomNormal", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.shape)?
        }
        {
            new_op.add_edge(&self.seed)?
        }
        {
            new_op.set_attr_type("dtype", dtype::data_type())?;
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        {
            new_op.set_attr_type("Tseed", Tseed::data_type())?;
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct StatelessRandomNormal<T, shape_Arg, Tseed, seed_Arg, dtype>
where T: TensorType,
      T: Clone,
      shape_Arg: Clone,
      shape_Arg: GraphEdge<T>,
      shape_Arg: 'static,
      Tseed: TensorType,
      Tseed: Clone,
      seed_Arg: Clone,
      seed_Arg: GraphEdge<Tseed>,
      seed_Arg: 'static,
      dtype: TensorType,
      dtype: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
      dtype: 'static,
      dtype: Clone,
      T: con_or_DT_INT32_or_DT_INT64,
      T: 'static,
      Tseed: con_or_DT_INT32_or_DT_INT64,
      Tseed: 'static,
{
    phantom_T: PhantomData<T>,
    shape: shape_Arg,
    phantom_Tseed: PhantomData<Tseed>,
    seed: seed_Arg,
    phantom_dtype: PhantomData<dtype>,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<T, shape_Arg, Tseed, seed_Arg, dtype> StatelessRandomNormal<T, shape_Arg, Tseed, seed_Arg, dtype>
where T: TensorType,
      T: Clone,
      shape_Arg: Clone,
      shape_Arg: GraphEdge<T>,
      shape_Arg: 'static,
      Tseed: TensorType,
      Tseed: Clone,
      seed_Arg: Clone,
      seed_Arg: GraphEdge<Tseed>,
      seed_Arg: 'static,
      dtype: TensorType,
      dtype: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
      dtype: 'static,
      dtype: Clone,
      T: con_or_DT_INT32_or_DT_INT64,
      T: 'static,
      Tseed: con_or_DT_INT32_or_DT_INT64,
      Tseed: 'static,
{
    pub fn output(self) -> Edge<dtype> {
        let rc = Rc::new(self);
        {
            Edge::<dtype>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<dtype> {
        let rc = Rc::new(self);
        {
            Edge::<dtype>::new(rc.clone(), 0)
        }
    }

    pub fn build(shape: shape_Arg, seed: seed_Arg) -> Self {
        Self {
            phantom_T: PhantomData,
            shape,
            phantom_Tseed: PhantomData,
            seed,
            phantom_dtype: PhantomData,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(shape: shape_Arg, seed: seed_Arg) -> Edge<dtype> {
        Self {
            phantom_T: PhantomData,
            shape,
            phantom_Tseed: PhantomData,
            seed,
            phantom_dtype: PhantomData,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<T, ref__Arg, Tindices, indices_Arg, updates_Arg> GraphOperation for ScatterNdSub<T, ref__Arg, Tindices, indices_Arg, updates_Arg>
where T: TensorType,
      T: Clone,
      ref__Arg: Clone,
      ref__Arg: GraphRefEdge<T>,
      ref__Arg: 'static,
      Tindices: TensorType,
      Tindices: Clone,
      indices_Arg: Clone,
      indices_Arg: GraphEdge<Tindices>,
      indices_Arg: 'static,
      updates_Arg: Clone,
      updates_Arg: GraphEdge<T>,
      updates_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
      Tindices: con_or_DT_INT32_or_DT_INT64,
      Tindices: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("ScatterNdSub_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("ScatterNdSub", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.ref_)?
        }
        {
            new_op.add_edge(&self.indices)?
        }
        {
            new_op.add_edge(&self.updates)?
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        {
            new_op.set_attr_type("Tindices", Tindices::data_type())?;
        }
        {
            match self.use_locking {
                None => new_op.set_attr_value_proto("use_locking", &vec![40_u8, 0_u8,])?,
                Some(ref value) => (|attr: &bool| {new_op.set_attr_bool("use_locking", *attr)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct ScatterNdSub<T, ref__Arg, Tindices, indices_Arg, updates_Arg>
where T: TensorType,
      T: Clone,
      ref__Arg: Clone,
      ref__Arg: GraphRefEdge<T>,
      ref__Arg: 'static,
      Tindices: TensorType,
      Tindices: Clone,
      indices_Arg: Clone,
      indices_Arg: GraphEdge<Tindices>,
      indices_Arg: 'static,
      updates_Arg: Clone,
      updates_Arg: GraphEdge<T>,
      updates_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
      Tindices: con_or_DT_INT32_or_DT_INT64,
      Tindices: 'static,
{
    phantom_T: PhantomData<T>,
    ref_: ref__Arg,
    phantom_Tindices: PhantomData<Tindices>,
    indices: indices_Arg,
    updates: updates_Arg,
    use_locking: Option<bool>,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<T, ref__Arg, Tindices, indices_Arg, updates_Arg> ScatterNdSub<T, ref__Arg, Tindices, indices_Arg, updates_Arg>
where T: TensorType,
      T: Clone,
      ref__Arg: Clone,
      ref__Arg: GraphRefEdge<T>,
      ref__Arg: 'static,
      Tindices: TensorType,
      Tindices: Clone,
      indices_Arg: Clone,
      indices_Arg: GraphEdge<Tindices>,
      indices_Arg: 'static,
      updates_Arg: Clone,
      updates_Arg: GraphEdge<T>,
      updates_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
      Tindices: con_or_DT_INT32_or_DT_INT64,
      Tindices: 'static,
{
    pub fn output_ref(self) -> RefEdge<T> {
        let rc = Rc::new(self);
        {
            RefEdge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn use_locking(&mut self, use_locking: bool) -> Self {
        self.use_locking = Some(use_locking);
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> RefEdge<T> {
        let rc = Rc::new(self);
        {
            RefEdge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(ref_: ref__Arg, indices: indices_Arg, updates: updates_Arg) -> Self {
        Self {
            phantom_T: PhantomData,
            ref_,
            phantom_Tindices: PhantomData,
            indices,
            updates,
            use_locking: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(ref_: ref__Arg, indices: indices_Arg, updates: updates_Arg) -> RefEdge<T> {
        Self {
            phantom_T: PhantomData,
            ref_,
            phantom_Tindices: PhantomData,
            indices,
            updates,
            use_locking: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<T, ref__Arg, Tindices, indices_Arg, updates_Arg> GraphOperation for ScatterNdUpdate<T, ref__Arg, Tindices, indices_Arg, updates_Arg>
where T: TensorType,
      T: Clone,
      ref__Arg: Clone,
      ref__Arg: GraphRefEdge<T>,
      ref__Arg: 'static,
      Tindices: TensorType,
      Tindices: Clone,
      indices_Arg: Clone,
      indices_Arg: GraphEdge<Tindices>,
      indices_Arg: 'static,
      updates_Arg: Clone,
      updates_Arg: GraphEdge<T>,
      updates_Arg: 'static,
      T: 'static,
      Tindices: con_or_DT_INT32_or_DT_INT64,
      Tindices: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("ScatterNdUpdate_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("ScatterNdUpdate", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.ref_)?
        }
        {
            new_op.add_edge(&self.indices)?
        }
        {
            new_op.add_edge(&self.updates)?
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        {
            new_op.set_attr_type("Tindices", Tindices::data_type())?;
        }
        {
            match self.use_locking {
                None => new_op.set_attr_value_proto("use_locking", &vec![40_u8, 1_u8,])?,
                Some(ref value) => (|attr: &bool| {new_op.set_attr_bool("use_locking", *attr)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct ScatterNdUpdate<T, ref__Arg, Tindices, indices_Arg, updates_Arg>
where T: TensorType,
      T: Clone,
      ref__Arg: Clone,
      ref__Arg: GraphRefEdge<T>,
      ref__Arg: 'static,
      Tindices: TensorType,
      Tindices: Clone,
      indices_Arg: Clone,
      indices_Arg: GraphEdge<Tindices>,
      indices_Arg: 'static,
      updates_Arg: Clone,
      updates_Arg: GraphEdge<T>,
      updates_Arg: 'static,
      T: 'static,
      Tindices: con_or_DT_INT32_or_DT_INT64,
      Tindices: 'static,
{
    phantom_T: PhantomData<T>,
    ref_: ref__Arg,
    phantom_Tindices: PhantomData<Tindices>,
    indices: indices_Arg,
    updates: updates_Arg,
    use_locking: Option<bool>,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<T, ref__Arg, Tindices, indices_Arg, updates_Arg> ScatterNdUpdate<T, ref__Arg, Tindices, indices_Arg, updates_Arg>
where T: TensorType,
      T: Clone,
      ref__Arg: Clone,
      ref__Arg: GraphRefEdge<T>,
      ref__Arg: 'static,
      Tindices: TensorType,
      Tindices: Clone,
      indices_Arg: Clone,
      indices_Arg: GraphEdge<Tindices>,
      indices_Arg: 'static,
      updates_Arg: Clone,
      updates_Arg: GraphEdge<T>,
      updates_Arg: 'static,
      T: 'static,
      Tindices: con_or_DT_INT32_or_DT_INT64,
      Tindices: 'static,
{
    pub fn output_ref(self) -> RefEdge<T> {
        let rc = Rc::new(self);
        {
            RefEdge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn use_locking(&mut self, use_locking: bool) -> Self {
        self.use_locking = Some(use_locking);
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> RefEdge<T> {
        let rc = Rc::new(self);
        {
            RefEdge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(ref_: ref__Arg, indices: indices_Arg, updates: updates_Arg) -> Self {
        Self {
            phantom_T: PhantomData,
            ref_,
            phantom_Tindices: PhantomData,
            indices,
            updates,
            use_locking: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(ref_: ref__Arg, indices: indices_Arg, updates: updates_Arg) -> RefEdge<T> {
        Self {
            phantom_T: PhantomData,
            ref_,
            phantom_Tindices: PhantomData,
            indices,
            updates,
            use_locking: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

pub trait con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_INT64_or_DT_BFLOAT16_or_DT_HALF {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_INT64_or_DT_BFLOAT16_or_DT_HALF for BFloat16 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_INT64_or_DT_BFLOAT16_or_DT_HALF for f32 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_INT64_or_DT_BFLOAT16_or_DT_HALF for f64 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_INT64_or_DT_BFLOAT16_or_DT_HALF for i32 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_INT64_or_DT_BFLOAT16_or_DT_HALF for i64 {
}

impl<T, ref__Arg, Tindices, indices_Arg, updates_Arg> GraphOperation for ScatterMax<T, ref__Arg, Tindices, indices_Arg, updates_Arg>
where T: TensorType,
      T: Clone,
      ref__Arg: Clone,
      ref__Arg: GraphRefEdge<T>,
      ref__Arg: 'static,
      Tindices: TensorType,
      Tindices: Clone,
      indices_Arg: Clone,
      indices_Arg: GraphEdge<Tindices>,
      indices_Arg: 'static,
      updates_Arg: Clone,
      updates_Arg: GraphEdge<T>,
      updates_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_INT64_or_DT_BFLOAT16_or_DT_HALF,
      T: 'static,
      Tindices: con_or_DT_INT32_or_DT_INT64,
      Tindices: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("ScatterMax_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("ScatterMax", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.ref_)?
        }
        {
            new_op.add_edge(&self.indices)?
        }
        {
            new_op.add_edge(&self.updates)?
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        {
            new_op.set_attr_type("Tindices", Tindices::data_type())?;
        }
        {
            match self.use_locking {
                None => new_op.set_attr_value_proto("use_locking", &vec![40_u8, 0_u8,])?,
                Some(ref value) => (|attr: &bool| {new_op.set_attr_bool("use_locking", *attr)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct ScatterMax<T, ref__Arg, Tindices, indices_Arg, updates_Arg>
where T: TensorType,
      T: Clone,
      ref__Arg: Clone,
      ref__Arg: GraphRefEdge<T>,
      ref__Arg: 'static,
      Tindices: TensorType,
      Tindices: Clone,
      indices_Arg: Clone,
      indices_Arg: GraphEdge<Tindices>,
      indices_Arg: 'static,
      updates_Arg: Clone,
      updates_Arg: GraphEdge<T>,
      updates_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_INT64_or_DT_BFLOAT16_or_DT_HALF,
      T: 'static,
      Tindices: con_or_DT_INT32_or_DT_INT64,
      Tindices: 'static,
{
    phantom_T: PhantomData<T>,
    ref_: ref__Arg,
    phantom_Tindices: PhantomData<Tindices>,
    indices: indices_Arg,
    updates: updates_Arg,
    use_locking: Option<bool>,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<T, ref__Arg, Tindices, indices_Arg, updates_Arg> ScatterMax<T, ref__Arg, Tindices, indices_Arg, updates_Arg>
where T: TensorType,
      T: Clone,
      ref__Arg: Clone,
      ref__Arg: GraphRefEdge<T>,
      ref__Arg: 'static,
      Tindices: TensorType,
      Tindices: Clone,
      indices_Arg: Clone,
      indices_Arg: GraphEdge<Tindices>,
      indices_Arg: 'static,
      updates_Arg: Clone,
      updates_Arg: GraphEdge<T>,
      updates_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_INT64_or_DT_BFLOAT16_or_DT_HALF,
      T: 'static,
      Tindices: con_or_DT_INT32_or_DT_INT64,
      Tindices: 'static,
{
    pub fn output_ref(self) -> RefEdge<T> {
        let rc = Rc::new(self);
        {
            RefEdge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn use_locking(&mut self, use_locking: bool) -> Self {
        self.use_locking = Some(use_locking);
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> RefEdge<T> {
        let rc = Rc::new(self);
        {
            RefEdge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(ref_: ref__Arg, indices: indices_Arg, updates: updates_Arg) -> Self {
        Self {
            phantom_T: PhantomData,
            ref_,
            phantom_Tindices: PhantomData,
            indices,
            updates,
            use_locking: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(ref_: ref__Arg, indices: indices_Arg, updates: updates_Arg) -> RefEdge<T> {
        Self {
            phantom_T: PhantomData,
            ref_,
            phantom_Tindices: PhantomData,
            indices,
            updates,
            use_locking: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<T, ref__Arg, Tindices, indices_Arg, updates_Arg> GraphOperation for ScatterMin<T, ref__Arg, Tindices, indices_Arg, updates_Arg>
where T: TensorType,
      T: Clone,
      ref__Arg: Clone,
      ref__Arg: GraphRefEdge<T>,
      ref__Arg: 'static,
      Tindices: TensorType,
      Tindices: Clone,
      indices_Arg: Clone,
      indices_Arg: GraphEdge<Tindices>,
      indices_Arg: 'static,
      updates_Arg: Clone,
      updates_Arg: GraphEdge<T>,
      updates_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_INT64_or_DT_BFLOAT16_or_DT_HALF,
      T: 'static,
      Tindices: con_or_DT_INT32_or_DT_INT64,
      Tindices: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("ScatterMin_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("ScatterMin", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.ref_)?
        }
        {
            new_op.add_edge(&self.indices)?
        }
        {
            new_op.add_edge(&self.updates)?
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        {
            new_op.set_attr_type("Tindices", Tindices::data_type())?;
        }
        {
            match self.use_locking {
                None => new_op.set_attr_value_proto("use_locking", &vec![40_u8, 0_u8,])?,
                Some(ref value) => (|attr: &bool| {new_op.set_attr_bool("use_locking", *attr)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct ScatterMin<T, ref__Arg, Tindices, indices_Arg, updates_Arg>
where T: TensorType,
      T: Clone,
      ref__Arg: Clone,
      ref__Arg: GraphRefEdge<T>,
      ref__Arg: 'static,
      Tindices: TensorType,
      Tindices: Clone,
      indices_Arg: Clone,
      indices_Arg: GraphEdge<Tindices>,
      indices_Arg: 'static,
      updates_Arg: Clone,
      updates_Arg: GraphEdge<T>,
      updates_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_INT64_or_DT_BFLOAT16_or_DT_HALF,
      T: 'static,
      Tindices: con_or_DT_INT32_or_DT_INT64,
      Tindices: 'static,
{
    phantom_T: PhantomData<T>,
    ref_: ref__Arg,
    phantom_Tindices: PhantomData<Tindices>,
    indices: indices_Arg,
    updates: updates_Arg,
    use_locking: Option<bool>,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<T, ref__Arg, Tindices, indices_Arg, updates_Arg> ScatterMin<T, ref__Arg, Tindices, indices_Arg, updates_Arg>
where T: TensorType,
      T: Clone,
      ref__Arg: Clone,
      ref__Arg: GraphRefEdge<T>,
      ref__Arg: 'static,
      Tindices: TensorType,
      Tindices: Clone,
      indices_Arg: Clone,
      indices_Arg: GraphEdge<Tindices>,
      indices_Arg: 'static,
      updates_Arg: Clone,
      updates_Arg: GraphEdge<T>,
      updates_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_INT64_or_DT_BFLOAT16_or_DT_HALF,
      T: 'static,
      Tindices: con_or_DT_INT32_or_DT_INT64,
      Tindices: 'static,
{
    pub fn output_ref(self) -> RefEdge<T> {
        let rc = Rc::new(self);
        {
            RefEdge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn use_locking(&mut self, use_locking: bool) -> Self {
        self.use_locking = Some(use_locking);
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> RefEdge<T> {
        let rc = Rc::new(self);
        {
            RefEdge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(ref_: ref__Arg, indices: indices_Arg, updates: updates_Arg) -> Self {
        Self {
            phantom_T: PhantomData,
            ref_,
            phantom_Tindices: PhantomData,
            indices,
            updates,
            use_locking: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(ref_: ref__Arg, indices: indices_Arg, updates: updates_Arg) -> RefEdge<T> {
        Self {
            phantom_T: PhantomData,
            ref_,
            phantom_Tindices: PhantomData,
            indices,
            updates,
            use_locking: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<T, ref__Arg, Tindices, indices_Arg, updates_Arg> GraphOperation for ScatterMul<T, ref__Arg, Tindices, indices_Arg, updates_Arg>
where T: TensorType,
      T: Clone,
      ref__Arg: Clone,
      ref__Arg: GraphRefEdge<T>,
      ref__Arg: 'static,
      Tindices: TensorType,
      Tindices: Clone,
      indices_Arg: Clone,
      indices_Arg: GraphEdge<Tindices>,
      indices_Arg: 'static,
      updates_Arg: Clone,
      updates_Arg: GraphEdge<T>,
      updates_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
      Tindices: con_or_DT_INT32_or_DT_INT64,
      Tindices: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("ScatterMul_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("ScatterMul", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.ref_)?
        }
        {
            new_op.add_edge(&self.indices)?
        }
        {
            new_op.add_edge(&self.updates)?
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        {
            new_op.set_attr_type("Tindices", Tindices::data_type())?;
        }
        {
            match self.use_locking {
                None => new_op.set_attr_value_proto("use_locking", &vec![40_u8, 0_u8,])?,
                Some(ref value) => (|attr: &bool| {new_op.set_attr_bool("use_locking", *attr)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct ScatterMul<T, ref__Arg, Tindices, indices_Arg, updates_Arg>
where T: TensorType,
      T: Clone,
      ref__Arg: Clone,
      ref__Arg: GraphRefEdge<T>,
      ref__Arg: 'static,
      Tindices: TensorType,
      Tindices: Clone,
      indices_Arg: Clone,
      indices_Arg: GraphEdge<Tindices>,
      indices_Arg: 'static,
      updates_Arg: Clone,
      updates_Arg: GraphEdge<T>,
      updates_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
      Tindices: con_or_DT_INT32_or_DT_INT64,
      Tindices: 'static,
{
    phantom_T: PhantomData<T>,
    ref_: ref__Arg,
    phantom_Tindices: PhantomData<Tindices>,
    indices: indices_Arg,
    updates: updates_Arg,
    use_locking: Option<bool>,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<T, ref__Arg, Tindices, indices_Arg, updates_Arg> ScatterMul<T, ref__Arg, Tindices, indices_Arg, updates_Arg>
where T: TensorType,
      T: Clone,
      ref__Arg: Clone,
      ref__Arg: GraphRefEdge<T>,
      ref__Arg: 'static,
      Tindices: TensorType,
      Tindices: Clone,
      indices_Arg: Clone,
      indices_Arg: GraphEdge<Tindices>,
      indices_Arg: 'static,
      updates_Arg: Clone,
      updates_Arg: GraphEdge<T>,
      updates_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
      Tindices: con_or_DT_INT32_or_DT_INT64,
      Tindices: 'static,
{
    pub fn output_ref(self) -> RefEdge<T> {
        let rc = Rc::new(self);
        {
            RefEdge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn use_locking(&mut self, use_locking: bool) -> Self {
        self.use_locking = Some(use_locking);
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> RefEdge<T> {
        let rc = Rc::new(self);
        {
            RefEdge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(ref_: ref__Arg, indices: indices_Arg, updates: updates_Arg) -> Self {
        Self {
            phantom_T: PhantomData,
            ref_,
            phantom_Tindices: PhantomData,
            indices,
            updates,
            use_locking: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(ref_: ref__Arg, indices: indices_Arg, updates: updates_Arg) -> RefEdge<T> {
        Self {
            phantom_T: PhantomData,
            ref_,
            phantom_Tindices: PhantomData,
            indices,
            updates,
            use_locking: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<T, ref__Arg, value_Arg> GraphOperation for AssignSub<T, ref__Arg, value_Arg>
where T: TensorType,
      T: Clone,
      ref__Arg: Clone,
      ref__Arg: GraphRefEdge<T>,
      ref__Arg: 'static,
      value_Arg: Clone,
      value_Arg: GraphEdge<T>,
      value_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("AssignSub_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("AssignSub", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.ref_)?
        }
        {
            new_op.add_edge(&self.value)?
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        {
            match self.use_locking {
                None => new_op.set_attr_value_proto("use_locking", &vec![40_u8, 0_u8,])?,
                Some(ref value) => (|attr: &bool| {new_op.set_attr_bool("use_locking", *attr)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct AssignSub<T, ref__Arg, value_Arg>
where T: TensorType,
      T: Clone,
      ref__Arg: Clone,
      ref__Arg: GraphRefEdge<T>,
      ref__Arg: 'static,
      value_Arg: Clone,
      value_Arg: GraphEdge<T>,
      value_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    ref_: ref__Arg,
    value: value_Arg,
    use_locking: Option<bool>,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<T, ref__Arg, value_Arg> AssignSub<T, ref__Arg, value_Arg>
where T: TensorType,
      T: Clone,
      ref__Arg: Clone,
      ref__Arg: GraphRefEdge<T>,
      ref__Arg: 'static,
      value_Arg: Clone,
      value_Arg: GraphEdge<T>,
      value_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
{
    pub fn output_ref(self) -> RefEdge<T> {
        let rc = Rc::new(self);
        {
            RefEdge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn use_locking(&mut self, use_locking: bool) -> Self {
        self.use_locking = Some(use_locking);
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> RefEdge<T> {
        let rc = Rc::new(self);
        {
            RefEdge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(ref_: ref__Arg, value: value_Arg) -> Self {
        Self {
            phantom_T: PhantomData,
            ref_,
            value,
            use_locking: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(ref_: ref__Arg, value: value_Arg) -> RefEdge<T> {
        Self {
            phantom_T: PhantomData,
            ref_,
            value,
            use_locking: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<T, ref__Arg> GraphOperation for DestroyTemporaryVariable<T, ref__Arg>
where T: TensorType,
      T: Clone,
      ref__Arg: Clone,
      ref__Arg: GraphRefEdge<T>,
      ref__Arg: 'static,
      T: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("DestroyTemporaryVariable_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("DestroyTemporaryVariable", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.ref_)?
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        {
            (|attr| {new_op.set_attr_string("var_name", attr)})(&self.var_name)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct DestroyTemporaryVariable<T, ref__Arg>
where T: TensorType,
      T: Clone,
      ref__Arg: Clone,
      ref__Arg: GraphRefEdge<T>,
      ref__Arg: 'static,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    ref_: ref__Arg,
    var_name: String,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<T, ref__Arg> DestroyTemporaryVariable<T, ref__Arg>
where T: TensorType,
      T: Clone,
      ref__Arg: Clone,
      ref__Arg: GraphRefEdge<T>,
      ref__Arg: 'static,
      T: 'static,
{
    pub fn value(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(ref_: ref__Arg, var_name: &str) -> Self {
        Self {
            phantom_T: PhantomData,
            ref_,
            var_name: var_name.to_string(),
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(ref_: ref__Arg, var_name: &str) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            ref_,
            var_name: var_name.to_string(),
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<input_Arg> GraphOperation for BatchIFFT3D<input_Arg>
where input_Arg: Clone,
      input_Arg: GraphEdge<OtherComplex<f32>>,
      input_Arg: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("BatchIFFT3D_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("BatchIFFT3D", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.input)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct BatchIFFT3D<input_Arg>
where input_Arg: Clone,
      input_Arg: GraphEdge<OtherComplex<f32>>,
      input_Arg: 'static,
{
    input: input_Arg,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<input_Arg> BatchIFFT3D<input_Arg>
where input_Arg: Clone,
      input_Arg: GraphEdge<OtherComplex<f32>>,
      input_Arg: 'static,
{
    pub fn output(self) -> Edge<OtherComplex<f32>> {
        let rc = Rc::new(self);
        {
            Edge::<OtherComplex::<f32>>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<OtherComplex<f32>> {
        let rc = Rc::new(self);
        {
            Edge::<OtherComplex::<f32>>::new(rc.clone(), 0)
        }
    }

    pub fn build(input: input_Arg) -> Self {
        Self {
            input,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(input: input_Arg) -> Edge<OtherComplex<f32>> {
        Self {
            input,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<input_Arg> GraphOperation for BatchFFT3D<input_Arg>
where input_Arg: Clone,
      input_Arg: GraphEdge<OtherComplex<f32>>,
      input_Arg: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("BatchFFT3D_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("BatchFFT3D", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.input)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct BatchFFT3D<input_Arg>
where input_Arg: Clone,
      input_Arg: GraphEdge<OtherComplex<f32>>,
      input_Arg: 'static,
{
    input: input_Arg,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<input_Arg> BatchFFT3D<input_Arg>
where input_Arg: Clone,
      input_Arg: GraphEdge<OtherComplex<f32>>,
      input_Arg: 'static,
{
    pub fn output(self) -> Edge<OtherComplex<f32>> {
        let rc = Rc::new(self);
        {
            Edge::<OtherComplex::<f32>>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<OtherComplex<f32>> {
        let rc = Rc::new(self);
        {
            Edge::<OtherComplex::<f32>>::new(rc.clone(), 0)
        }
    }

    pub fn build(input: input_Arg) -> Self {
        Self {
            input,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(input: input_Arg) -> Edge<OtherComplex<f32>> {
        Self {
            input,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<input_Arg> GraphOperation for BatchIFFT2D<input_Arg>
where input_Arg: Clone,
      input_Arg: GraphEdge<OtherComplex<f32>>,
      input_Arg: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("BatchIFFT2D_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("BatchIFFT2D", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.input)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct BatchIFFT2D<input_Arg>
where input_Arg: Clone,
      input_Arg: GraphEdge<OtherComplex<f32>>,
      input_Arg: 'static,
{
    input: input_Arg,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<input_Arg> BatchIFFT2D<input_Arg>
where input_Arg: Clone,
      input_Arg: GraphEdge<OtherComplex<f32>>,
      input_Arg: 'static,
{
    pub fn output(self) -> Edge<OtherComplex<f32>> {
        let rc = Rc::new(self);
        {
            Edge::<OtherComplex::<f32>>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<OtherComplex<f32>> {
        let rc = Rc::new(self);
        {
            Edge::<OtherComplex::<f32>>::new(rc.clone(), 0)
        }
    }

    pub fn build(input: input_Arg) -> Self {
        Self {
            input,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(input: input_Arg) -> Edge<OtherComplex<f32>> {
        Self {
            input,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<input_Arg> GraphOperation for BatchFFT2D<input_Arg>
where input_Arg: Clone,
      input_Arg: GraphEdge<OtherComplex<f32>>,
      input_Arg: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("BatchFFT2D_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("BatchFFT2D", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.input)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct BatchFFT2D<input_Arg>
where input_Arg: Clone,
      input_Arg: GraphEdge<OtherComplex<f32>>,
      input_Arg: 'static,
{
    input: input_Arg,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<input_Arg> BatchFFT2D<input_Arg>
where input_Arg: Clone,
      input_Arg: GraphEdge<OtherComplex<f32>>,
      input_Arg: 'static,
{
    pub fn output(self) -> Edge<OtherComplex<f32>> {
        let rc = Rc::new(self);
        {
            Edge::<OtherComplex::<f32>>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<OtherComplex<f32>> {
        let rc = Rc::new(self);
        {
            Edge::<OtherComplex::<f32>>::new(rc.clone(), 0)
        }
    }

    pub fn build(input: input_Arg) -> Self {
        Self {
            input,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(input: input_Arg) -> Edge<OtherComplex<f32>> {
        Self {
            input,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<input_Arg> GraphOperation for BatchIFFT<input_Arg>
where input_Arg: Clone,
      input_Arg: GraphEdge<OtherComplex<f32>>,
      input_Arg: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("BatchIFFT_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("BatchIFFT", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.input)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct BatchIFFT<input_Arg>
where input_Arg: Clone,
      input_Arg: GraphEdge<OtherComplex<f32>>,
      input_Arg: 'static,
{
    input: input_Arg,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<input_Arg> BatchIFFT<input_Arg>
where input_Arg: Clone,
      input_Arg: GraphEdge<OtherComplex<f32>>,
      input_Arg: 'static,
{
    pub fn output(self) -> Edge<OtherComplex<f32>> {
        let rc = Rc::new(self);
        {
            Edge::<OtherComplex::<f32>>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<OtherComplex<f32>> {
        let rc = Rc::new(self);
        {
            Edge::<OtherComplex::<f32>>::new(rc.clone(), 0)
        }
    }

    pub fn build(input: input_Arg) -> Self {
        Self {
            input,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(input: input_Arg) -> Edge<OtherComplex<f32>> {
        Self {
            input,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<input_Arg, fft_length_Arg> GraphOperation for IRFFT3D<input_Arg, fft_length_Arg>
where input_Arg: Clone,
      input_Arg: GraphEdge<OtherComplex<f32>>,
      input_Arg: 'static,
      fft_length_Arg: Clone,
      fft_length_Arg: GraphEdge<i32>,
      fft_length_Arg: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("IRFFT3D_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("IRFFT3D", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.input)?
        }
        {
            new_op.add_edge(&self.fft_length)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct IRFFT3D<input_Arg, fft_length_Arg>
where input_Arg: Clone,
      input_Arg: GraphEdge<OtherComplex<f32>>,
      input_Arg: 'static,
      fft_length_Arg: Clone,
      fft_length_Arg: GraphEdge<i32>,
      fft_length_Arg: 'static,
{
    input: input_Arg,
    fft_length: fft_length_Arg,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<input_Arg, fft_length_Arg> IRFFT3D<input_Arg, fft_length_Arg>
where input_Arg: Clone,
      input_Arg: GraphEdge<OtherComplex<f32>>,
      input_Arg: 'static,
      fft_length_Arg: Clone,
      fft_length_Arg: GraphEdge<i32>,
      fft_length_Arg: 'static,
{
    pub fn output(self) -> Edge<f32> {
        let rc = Rc::new(self);
        {
            Edge::<f32>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<f32> {
        let rc = Rc::new(self);
        {
            Edge::<f32>::new(rc.clone(), 0)
        }
    }

    pub fn build(input: input_Arg, fft_length: fft_length_Arg) -> Self {
        Self {
            input,
            fft_length,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(input: input_Arg, fft_length: fft_length_Arg) -> Edge<f32> {
        Self {
            input,
            fft_length,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<input_Arg, fft_length_Arg> GraphOperation for IRFFT2D<input_Arg, fft_length_Arg>
where input_Arg: Clone,
      input_Arg: GraphEdge<OtherComplex<f32>>,
      input_Arg: 'static,
      fft_length_Arg: Clone,
      fft_length_Arg: GraphEdge<i32>,
      fft_length_Arg: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("IRFFT2D_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("IRFFT2D", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.input)?
        }
        {
            new_op.add_edge(&self.fft_length)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct IRFFT2D<input_Arg, fft_length_Arg>
where input_Arg: Clone,
      input_Arg: GraphEdge<OtherComplex<f32>>,
      input_Arg: 'static,
      fft_length_Arg: Clone,
      fft_length_Arg: GraphEdge<i32>,
      fft_length_Arg: 'static,
{
    input: input_Arg,
    fft_length: fft_length_Arg,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<input_Arg, fft_length_Arg> IRFFT2D<input_Arg, fft_length_Arg>
where input_Arg: Clone,
      input_Arg: GraphEdge<OtherComplex<f32>>,
      input_Arg: 'static,
      fft_length_Arg: Clone,
      fft_length_Arg: GraphEdge<i32>,
      fft_length_Arg: 'static,
{
    pub fn output(self) -> Edge<f32> {
        let rc = Rc::new(self);
        {
            Edge::<f32>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<f32> {
        let rc = Rc::new(self);
        {
            Edge::<f32>::new(rc.clone(), 0)
        }
    }

    pub fn build(input: input_Arg, fft_length: fft_length_Arg) -> Self {
        Self {
            input,
            fft_length,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(input: input_Arg, fft_length: fft_length_Arg) -> Edge<f32> {
        Self {
            input,
            fft_length,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<input_Arg, fft_length_Arg> GraphOperation for RFFT2D<input_Arg, fft_length_Arg>
where input_Arg: Clone,
      input_Arg: GraphEdge<f32>,
      input_Arg: 'static,
      fft_length_Arg: Clone,
      fft_length_Arg: GraphEdge<i32>,
      fft_length_Arg: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("RFFT2D_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("RFFT2D", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.input)?
        }
        {
            new_op.add_edge(&self.fft_length)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct RFFT2D<input_Arg, fft_length_Arg>
where input_Arg: Clone,
      input_Arg: GraphEdge<f32>,
      input_Arg: 'static,
      fft_length_Arg: Clone,
      fft_length_Arg: GraphEdge<i32>,
      fft_length_Arg: 'static,
{
    input: input_Arg,
    fft_length: fft_length_Arg,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<input_Arg, fft_length_Arg> RFFT2D<input_Arg, fft_length_Arg>
where input_Arg: Clone,
      input_Arg: GraphEdge<f32>,
      input_Arg: 'static,
      fft_length_Arg: Clone,
      fft_length_Arg: GraphEdge<i32>,
      fft_length_Arg: 'static,
{
    pub fn output(self) -> Edge<OtherComplex<f32>> {
        let rc = Rc::new(self);
        {
            Edge::<OtherComplex::<f32>>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<OtherComplex<f32>> {
        let rc = Rc::new(self);
        {
            Edge::<OtherComplex::<f32>>::new(rc.clone(), 0)
        }
    }

    pub fn build(input: input_Arg, fft_length: fft_length_Arg) -> Self {
        Self {
            input,
            fft_length,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(input: input_Arg, fft_length: fft_length_Arg) -> Edge<OtherComplex<f32>> {
        Self {
            input,
            fft_length,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<input_Arg, fft_length_Arg> GraphOperation for RFFT<input_Arg, fft_length_Arg>
where input_Arg: Clone,
      input_Arg: GraphEdge<f32>,
      input_Arg: 'static,
      fft_length_Arg: Clone,
      fft_length_Arg: GraphEdge<i32>,
      fft_length_Arg: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("RFFT_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("RFFT", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.input)?
        }
        {
            new_op.add_edge(&self.fft_length)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct RFFT<input_Arg, fft_length_Arg>
where input_Arg: Clone,
      input_Arg: GraphEdge<f32>,
      input_Arg: 'static,
      fft_length_Arg: Clone,
      fft_length_Arg: GraphEdge<i32>,
      fft_length_Arg: 'static,
{
    input: input_Arg,
    fft_length: fft_length_Arg,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<input_Arg, fft_length_Arg> RFFT<input_Arg, fft_length_Arg>
where input_Arg: Clone,
      input_Arg: GraphEdge<f32>,
      input_Arg: 'static,
      fft_length_Arg: Clone,
      fft_length_Arg: GraphEdge<i32>,
      fft_length_Arg: 'static,
{
    pub fn output(self) -> Edge<OtherComplex<f32>> {
        let rc = Rc::new(self);
        {
            Edge::<OtherComplex::<f32>>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<OtherComplex<f32>> {
        let rc = Rc::new(self);
        {
            Edge::<OtherComplex::<f32>>::new(rc.clone(), 0)
        }
    }

    pub fn build(input: input_Arg, fft_length: fft_length_Arg) -> Self {
        Self {
            input,
            fft_length,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(input: input_Arg, fft_length: fft_length_Arg) -> Edge<OtherComplex<f32>> {
        Self {
            input,
            fft_length,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

pub trait con_or_DT_COMPLEX64_or_DT_COMPLEX128 {
}

impl con_or_DT_COMPLEX64_or_DT_COMPLEX128 for OtherComplex<f32> {
}

impl con_or_DT_COMPLEX64_or_DT_COMPLEX128 for OtherComplex<f64> {
}

impl<Tcomplex, input_Arg> GraphOperation for IFFT2D<Tcomplex, input_Arg>
where Tcomplex: TensorType,
      Tcomplex: Clone,
      input_Arg: Clone,
      input_Arg: GraphEdge<Tcomplex>,
      input_Arg: 'static,
      Tcomplex: con_or_DT_COMPLEX64_or_DT_COMPLEX128,
      Tcomplex: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("IFFT2D_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("IFFT2D", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.input)?
        }
        {
            new_op.set_attr_type("Tcomplex", Tcomplex::data_type())?;
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct IFFT2D<Tcomplex, input_Arg>
where Tcomplex: TensorType,
      Tcomplex: Clone,
      input_Arg: Clone,
      input_Arg: GraphEdge<Tcomplex>,
      input_Arg: 'static,
      Tcomplex: con_or_DT_COMPLEX64_or_DT_COMPLEX128,
      Tcomplex: 'static,
{
    phantom_Tcomplex: PhantomData<Tcomplex>,
    input: input_Arg,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<Tcomplex, input_Arg> IFFT2D<Tcomplex, input_Arg>
where Tcomplex: TensorType,
      Tcomplex: Clone,
      input_Arg: Clone,
      input_Arg: GraphEdge<Tcomplex>,
      input_Arg: 'static,
      Tcomplex: con_or_DT_COMPLEX64_or_DT_COMPLEX128,
      Tcomplex: 'static,
{
    pub fn output(self) -> Edge<Tcomplex> {
        let rc = Rc::new(self);
        {
            Edge::<Tcomplex>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<Tcomplex> {
        let rc = Rc::new(self);
        {
            Edge::<Tcomplex>::new(rc.clone(), 0)
        }
    }

    pub fn build(input: input_Arg) -> Self {
        Self {
            phantom_Tcomplex: PhantomData,
            input,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(input: input_Arg) -> Edge<Tcomplex> {
        Self {
            phantom_Tcomplex: PhantomData,
            input,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<Tcomplex, input_Arg> GraphOperation for FFT2D<Tcomplex, input_Arg>
where Tcomplex: TensorType,
      Tcomplex: Clone,
      input_Arg: Clone,
      input_Arg: GraphEdge<Tcomplex>,
      input_Arg: 'static,
      Tcomplex: con_or_DT_COMPLEX64_or_DT_COMPLEX128,
      Tcomplex: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("FFT2D_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("FFT2D", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.input)?
        }
        {
            new_op.set_attr_type("Tcomplex", Tcomplex::data_type())?;
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct FFT2D<Tcomplex, input_Arg>
where Tcomplex: TensorType,
      Tcomplex: Clone,
      input_Arg: Clone,
      input_Arg: GraphEdge<Tcomplex>,
      input_Arg: 'static,
      Tcomplex: con_or_DT_COMPLEX64_or_DT_COMPLEX128,
      Tcomplex: 'static,
{
    phantom_Tcomplex: PhantomData<Tcomplex>,
    input: input_Arg,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<Tcomplex, input_Arg> FFT2D<Tcomplex, input_Arg>
where Tcomplex: TensorType,
      Tcomplex: Clone,
      input_Arg: Clone,
      input_Arg: GraphEdge<Tcomplex>,
      input_Arg: 'static,
      Tcomplex: con_or_DT_COMPLEX64_or_DT_COMPLEX128,
      Tcomplex: 'static,
{
    pub fn output(self) -> Edge<Tcomplex> {
        let rc = Rc::new(self);
        {
            Edge::<Tcomplex>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<Tcomplex> {
        let rc = Rc::new(self);
        {
            Edge::<Tcomplex>::new(rc.clone(), 0)
        }
    }

    pub fn build(input: input_Arg) -> Self {
        Self {
            phantom_Tcomplex: PhantomData,
            input,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(input: input_Arg) -> Edge<Tcomplex> {
        Self {
            phantom_Tcomplex: PhantomData,
            input,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<Tcomplex, input_Arg> GraphOperation for IFFT<Tcomplex, input_Arg>
where Tcomplex: TensorType,
      Tcomplex: Clone,
      input_Arg: Clone,
      input_Arg: GraphEdge<Tcomplex>,
      input_Arg: 'static,
      Tcomplex: con_or_DT_COMPLEX64_or_DT_COMPLEX128,
      Tcomplex: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("IFFT_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("IFFT", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.input)?
        }
        {
            new_op.set_attr_type("Tcomplex", Tcomplex::data_type())?;
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct IFFT<Tcomplex, input_Arg>
where Tcomplex: TensorType,
      Tcomplex: Clone,
      input_Arg: Clone,
      input_Arg: GraphEdge<Tcomplex>,
      input_Arg: 'static,
      Tcomplex: con_or_DT_COMPLEX64_or_DT_COMPLEX128,
      Tcomplex: 'static,
{
    phantom_Tcomplex: PhantomData<Tcomplex>,
    input: input_Arg,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<Tcomplex, input_Arg> IFFT<Tcomplex, input_Arg>
where Tcomplex: TensorType,
      Tcomplex: Clone,
      input_Arg: Clone,
      input_Arg: GraphEdge<Tcomplex>,
      input_Arg: 'static,
      Tcomplex: con_or_DT_COMPLEX64_or_DT_COMPLEX128,
      Tcomplex: 'static,
{
    pub fn output(self) -> Edge<Tcomplex> {
        let rc = Rc::new(self);
        {
            Edge::<Tcomplex>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<Tcomplex> {
        let rc = Rc::new(self);
        {
            Edge::<Tcomplex>::new(rc.clone(), 0)
        }
    }

    pub fn build(input: input_Arg) -> Self {
        Self {
            phantom_Tcomplex: PhantomData,
            input,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(input: input_Arg) -> Edge<Tcomplex> {
        Self {
            phantom_Tcomplex: PhantomData,
            input,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<indices_Arg, T, values_Arg, dense_shape_Arg, default_value_Arg> GraphOperation for SparseFillEmptyRows<indices_Arg, T, values_Arg, dense_shape_Arg, default_value_Arg>
where indices_Arg: Clone,
      indices_Arg: GraphEdge<i64>,
      indices_Arg: 'static,
      T: TensorType,
      T: Clone,
      values_Arg: Clone,
      values_Arg: GraphEdge<T>,
      values_Arg: 'static,
      dense_shape_Arg: Clone,
      dense_shape_Arg: GraphEdge<i64>,
      dense_shape_Arg: 'static,
      default_value_Arg: Clone,
      default_value_Arg: GraphEdge<T>,
      default_value_Arg: 'static,
      T: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("SparseFillEmptyRows_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("SparseFillEmptyRows", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.indices)?
        }
        {
            new_op.add_edge(&self.values)?
        }
        {
            new_op.add_edge(&self.dense_shape)?
        }
        {
            new_op.add_edge(&self.default_value)?
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct SparseFillEmptyRows<indices_Arg, T, values_Arg, dense_shape_Arg, default_value_Arg>
where indices_Arg: Clone,
      indices_Arg: GraphEdge<i64>,
      indices_Arg: 'static,
      T: TensorType,
      T: Clone,
      values_Arg: Clone,
      values_Arg: GraphEdge<T>,
      values_Arg: 'static,
      dense_shape_Arg: Clone,
      dense_shape_Arg: GraphEdge<i64>,
      dense_shape_Arg: 'static,
      default_value_Arg: Clone,
      default_value_Arg: GraphEdge<T>,
      default_value_Arg: 'static,
      T: 'static,
{
    indices: indices_Arg,
    phantom_T: PhantomData<T>,
    values: values_Arg,
    dense_shape: dense_shape_Arg,
    default_value: default_value_Arg,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<indices_Arg, T, values_Arg, dense_shape_Arg, default_value_Arg> SparseFillEmptyRows<indices_Arg, T, values_Arg, dense_shape_Arg, default_value_Arg>
where indices_Arg: Clone,
      indices_Arg: GraphEdge<i64>,
      indices_Arg: 'static,
      T: TensorType,
      T: Clone,
      values_Arg: Clone,
      values_Arg: GraphEdge<T>,
      values_Arg: 'static,
      dense_shape_Arg: Clone,
      dense_shape_Arg: GraphEdge<i64>,
      dense_shape_Arg: 'static,
      default_value_Arg: Clone,
      default_value_Arg: GraphEdge<T>,
      default_value_Arg: 'static,
      T: 'static,
{
    pub fn output_indices(self) -> Edge<i64> {
        let rc = Rc::new(self);
        {
            Edge::<i64>::new(rc.clone(), 0)
        }
    }

    pub fn output_values(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 1)
        }
    }

    pub fn empty_row_indicator(self) -> Edge<bool> {
        let rc = Rc::new(self);
        {
            Edge::<bool>::new(rc.clone(), 2)
        }
    }

    pub fn reverse_index_map(self) -> Edge<i64> {
        let rc = Rc::new(self);
        {
            Edge::<i64>::new(rc.clone(), 3)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> (Edge<i64>, Edge<T>, Edge<bool>, Edge<i64>) {
        let rc = Rc::new(self);
        (
        {
            Edge::<i64>::new(rc.clone(), 0)
        },
        {
            Edge::<T>::new(rc.clone(), 1)
        },
        {
            Edge::<bool>::new(rc.clone(), 2)
        },
        {
            Edge::<i64>::new(rc.clone(), 3)
        },
        )
    }

    pub fn build(indices: indices_Arg, values: values_Arg, dense_shape: dense_shape_Arg, default_value: default_value_Arg) -> Self {
        Self {
            indices,
            phantom_T: PhantomData,
            values,
            dense_shape,
            default_value,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(indices: indices_Arg, values: values_Arg, dense_shape: dense_shape_Arg, default_value: default_value_Arg) -> (Edge<i64>, Edge<T>, Edge<bool>, Edge<i64>) {
        Self {
            indices,
            phantom_T: PhantomData,
            values,
            dense_shape,
            default_value,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<a_indices_Arg, T, a_values_Arg, a_shape_Arg, b_indices_Arg, b_values_Arg, b_shape_Arg> GraphOperation for SparseSparseMinimum<a_indices_Arg, T, a_values_Arg, a_shape_Arg, b_indices_Arg, b_values_Arg, b_shape_Arg>
where a_indices_Arg: Clone,
      a_indices_Arg: GraphEdge<i64>,
      a_indices_Arg: 'static,
      T: TensorType,
      T: Clone,
      a_values_Arg: Clone,
      a_values_Arg: GraphEdge<T>,
      a_values_Arg: 'static,
      a_shape_Arg: Clone,
      a_shape_Arg: GraphEdge<i64>,
      a_shape_Arg: 'static,
      b_indices_Arg: Clone,
      b_indices_Arg: GraphEdge<i64>,
      b_indices_Arg: 'static,
      b_values_Arg: Clone,
      b_values_Arg: GraphEdge<T>,
      b_values_Arg: 'static,
      b_shape_Arg: Clone,
      b_shape_Arg: GraphEdge<i64>,
      b_shape_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("SparseSparseMinimum_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("SparseSparseMinimum", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.a_indices)?
        }
        {
            new_op.add_edge(&self.a_values)?
        }
        {
            new_op.add_edge(&self.a_shape)?
        }
        {
            new_op.add_edge(&self.b_indices)?
        }
        {
            new_op.add_edge(&self.b_values)?
        }
        {
            new_op.add_edge(&self.b_shape)?
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct SparseSparseMinimum<a_indices_Arg, T, a_values_Arg, a_shape_Arg, b_indices_Arg, b_values_Arg, b_shape_Arg>
where a_indices_Arg: Clone,
      a_indices_Arg: GraphEdge<i64>,
      a_indices_Arg: 'static,
      T: TensorType,
      T: Clone,
      a_values_Arg: Clone,
      a_values_Arg: GraphEdge<T>,
      a_values_Arg: 'static,
      a_shape_Arg: Clone,
      a_shape_Arg: GraphEdge<i64>,
      a_shape_Arg: 'static,
      b_indices_Arg: Clone,
      b_indices_Arg: GraphEdge<i64>,
      b_indices_Arg: 'static,
      b_values_Arg: Clone,
      b_values_Arg: GraphEdge<T>,
      b_values_Arg: 'static,
      b_shape_Arg: Clone,
      b_shape_Arg: GraphEdge<i64>,
      b_shape_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
{
    a_indices: a_indices_Arg,
    phantom_T: PhantomData<T>,
    a_values: a_values_Arg,
    a_shape: a_shape_Arg,
    b_indices: b_indices_Arg,
    b_values: b_values_Arg,
    b_shape: b_shape_Arg,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<a_indices_Arg, T, a_values_Arg, a_shape_Arg, b_indices_Arg, b_values_Arg, b_shape_Arg> SparseSparseMinimum<a_indices_Arg, T, a_values_Arg, a_shape_Arg, b_indices_Arg, b_values_Arg, b_shape_Arg>
where a_indices_Arg: Clone,
      a_indices_Arg: GraphEdge<i64>,
      a_indices_Arg: 'static,
      T: TensorType,
      T: Clone,
      a_values_Arg: Clone,
      a_values_Arg: GraphEdge<T>,
      a_values_Arg: 'static,
      a_shape_Arg: Clone,
      a_shape_Arg: GraphEdge<i64>,
      a_shape_Arg: 'static,
      b_indices_Arg: Clone,
      b_indices_Arg: GraphEdge<i64>,
      b_indices_Arg: 'static,
      b_values_Arg: Clone,
      b_values_Arg: GraphEdge<T>,
      b_values_Arg: 'static,
      b_shape_Arg: Clone,
      b_shape_Arg: GraphEdge<i64>,
      b_shape_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
{
    pub fn output_indices(self) -> Edge<i64> {
        let rc = Rc::new(self);
        {
            Edge::<i64>::new(rc.clone(), 0)
        }
    }

    pub fn output_values(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 1)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> (Edge<i64>, Edge<T>) {
        let rc = Rc::new(self);
        (
        {
            Edge::<i64>::new(rc.clone(), 0)
        },
        {
            Edge::<T>::new(rc.clone(), 1)
        },
        )
    }

    pub fn build(a_indices: a_indices_Arg, a_values: a_values_Arg, a_shape: a_shape_Arg, b_indices: b_indices_Arg, b_values: b_values_Arg, b_shape: b_shape_Arg) -> Self {
        Self {
            a_indices,
            phantom_T: PhantomData,
            a_values,
            a_shape,
            b_indices,
            b_values,
            b_shape,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(a_indices: a_indices_Arg, a_values: a_values_Arg, a_shape: a_shape_Arg, b_indices: b_indices_Arg, b_values: b_values_Arg, b_shape: b_shape_Arg) -> (Edge<i64>, Edge<T>) {
        Self {
            a_indices,
            phantom_T: PhantomData,
            a_values,
            a_shape,
            b_indices,
            b_values,
            b_shape,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

pub trait con_or_DT_FLOAT_or_DT_DOUBLE {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE for f32 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE for f64 {
}

impl<sp_indices_Arg, T, sp_values_Arg, sp_shape_Arg> GraphOperation for SparseSoftmax<sp_indices_Arg, T, sp_values_Arg, sp_shape_Arg>
where sp_indices_Arg: Clone,
      sp_indices_Arg: GraphEdge<i64>,
      sp_indices_Arg: 'static,
      T: TensorType,
      T: Clone,
      sp_values_Arg: Clone,
      sp_values_Arg: GraphEdge<T>,
      sp_values_Arg: 'static,
      sp_shape_Arg: Clone,
      sp_shape_Arg: GraphEdge<i64>,
      sp_shape_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE,
      T: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("SparseSoftmax_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("SparseSoftmax", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.sp_indices)?
        }
        {
            new_op.add_edge(&self.sp_values)?
        }
        {
            new_op.add_edge(&self.sp_shape)?
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct SparseSoftmax<sp_indices_Arg, T, sp_values_Arg, sp_shape_Arg>
where sp_indices_Arg: Clone,
      sp_indices_Arg: GraphEdge<i64>,
      sp_indices_Arg: 'static,
      T: TensorType,
      T: Clone,
      sp_values_Arg: Clone,
      sp_values_Arg: GraphEdge<T>,
      sp_values_Arg: 'static,
      sp_shape_Arg: Clone,
      sp_shape_Arg: GraphEdge<i64>,
      sp_shape_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE,
      T: 'static,
{
    sp_indices: sp_indices_Arg,
    phantom_T: PhantomData<T>,
    sp_values: sp_values_Arg,
    sp_shape: sp_shape_Arg,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<sp_indices_Arg, T, sp_values_Arg, sp_shape_Arg> SparseSoftmax<sp_indices_Arg, T, sp_values_Arg, sp_shape_Arg>
where sp_indices_Arg: Clone,
      sp_indices_Arg: GraphEdge<i64>,
      sp_indices_Arg: 'static,
      T: TensorType,
      T: Clone,
      sp_values_Arg: Clone,
      sp_values_Arg: GraphEdge<T>,
      sp_values_Arg: 'static,
      sp_shape_Arg: Clone,
      sp_shape_Arg: GraphEdge<i64>,
      sp_shape_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE,
      T: 'static,
{
    pub fn output(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(sp_indices: sp_indices_Arg, sp_values: sp_values_Arg, sp_shape: sp_shape_Arg) -> Self {
        Self {
            sp_indices,
            phantom_T: PhantomData,
            sp_values,
            sp_shape,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(sp_indices: sp_indices_Arg, sp_values: sp_values_Arg, sp_shape: sp_shape_Arg) -> Edge<T> {
        Self {
            sp_indices,
            phantom_T: PhantomData,
            sp_values,
            sp_shape,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<sp_indices_Arg, T, sp_values_Arg, sp_shape_Arg, dense_Arg> GraphOperation for SparseDenseCwiseAdd<sp_indices_Arg, T, sp_values_Arg, sp_shape_Arg, dense_Arg>
where sp_indices_Arg: Clone,
      sp_indices_Arg: GraphEdge<i64>,
      sp_indices_Arg: 'static,
      T: TensorType,
      T: Clone,
      sp_values_Arg: Clone,
      sp_values_Arg: GraphEdge<T>,
      sp_values_Arg: 'static,
      sp_shape_Arg: Clone,
      sp_shape_Arg: GraphEdge<i64>,
      sp_shape_Arg: 'static,
      dense_Arg: Clone,
      dense_Arg: GraphEdge<T>,
      dense_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("SparseDenseCwiseAdd_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("SparseDenseCwiseAdd", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.sp_indices)?
        }
        {
            new_op.add_edge(&self.sp_values)?
        }
        {
            new_op.add_edge(&self.sp_shape)?
        }
        {
            new_op.add_edge(&self.dense)?
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct SparseDenseCwiseAdd<sp_indices_Arg, T, sp_values_Arg, sp_shape_Arg, dense_Arg>
where sp_indices_Arg: Clone,
      sp_indices_Arg: GraphEdge<i64>,
      sp_indices_Arg: 'static,
      T: TensorType,
      T: Clone,
      sp_values_Arg: Clone,
      sp_values_Arg: GraphEdge<T>,
      sp_values_Arg: 'static,
      sp_shape_Arg: Clone,
      sp_shape_Arg: GraphEdge<i64>,
      sp_shape_Arg: 'static,
      dense_Arg: Clone,
      dense_Arg: GraphEdge<T>,
      dense_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
{
    sp_indices: sp_indices_Arg,
    phantom_T: PhantomData<T>,
    sp_values: sp_values_Arg,
    sp_shape: sp_shape_Arg,
    dense: dense_Arg,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<sp_indices_Arg, T, sp_values_Arg, sp_shape_Arg, dense_Arg> SparseDenseCwiseAdd<sp_indices_Arg, T, sp_values_Arg, sp_shape_Arg, dense_Arg>
where sp_indices_Arg: Clone,
      sp_indices_Arg: GraphEdge<i64>,
      sp_indices_Arg: 'static,
      T: TensorType,
      T: Clone,
      sp_values_Arg: Clone,
      sp_values_Arg: GraphEdge<T>,
      sp_values_Arg: 'static,
      sp_shape_Arg: Clone,
      sp_shape_Arg: GraphEdge<i64>,
      sp_shape_Arg: 'static,
      dense_Arg: Clone,
      dense_Arg: GraphEdge<T>,
      dense_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
{
    pub fn output(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(sp_indices: sp_indices_Arg, sp_values: sp_values_Arg, sp_shape: sp_shape_Arg, dense: dense_Arg) -> Self {
        Self {
            sp_indices,
            phantom_T: PhantomData,
            sp_values,
            sp_shape,
            dense,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(sp_indices: sp_indices_Arg, sp_values: sp_values_Arg, sp_shape: sp_shape_Arg, dense: dense_Arg) -> Edge<T> {
        Self {
            sp_indices,
            phantom_T: PhantomData,
            sp_values,
            sp_shape,
            dense,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<T, var_Arg, accum_Arg, lr_Arg, grad_Arg, momentum_Arg> GraphOperation for ApplyMomentum<T, var_Arg, accum_Arg, lr_Arg, grad_Arg, momentum_Arg>
where T: TensorType,
      T: Clone,
      var_Arg: Clone,
      var_Arg: GraphRefEdge<T>,
      var_Arg: 'static,
      accum_Arg: Clone,
      accum_Arg: GraphRefEdge<T>,
      accum_Arg: 'static,
      lr_Arg: Clone,
      lr_Arg: GraphEdge<T>,
      lr_Arg: 'static,
      grad_Arg: Clone,
      grad_Arg: GraphEdge<T>,
      grad_Arg: 'static,
      momentum_Arg: Clone,
      momentum_Arg: GraphEdge<T>,
      momentum_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("ApplyMomentum_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("ApplyMomentum", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.var)?
        }
        {
            new_op.add_edge(&self.accum)?
        }
        {
            new_op.add_edge(&self.lr)?
        }
        {
            new_op.add_edge(&self.grad)?
        }
        {
            new_op.add_edge(&self.momentum)?
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        {
            match self.use_locking {
                None => new_op.set_attr_value_proto("use_locking", &vec![40_u8, 0_u8,])?,
                Some(ref value) => (|attr: &bool| {new_op.set_attr_bool("use_locking", *attr)})(&value)?,
            };
        }
        {
            match self.use_nesterov {
                None => new_op.set_attr_value_proto("use_nesterov", &vec![40_u8, 0_u8,])?,
                Some(ref value) => (|attr: &bool| {new_op.set_attr_bool("use_nesterov", *attr)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct ApplyMomentum<T, var_Arg, accum_Arg, lr_Arg, grad_Arg, momentum_Arg>
where T: TensorType,
      T: Clone,
      var_Arg: Clone,
      var_Arg: GraphRefEdge<T>,
      var_Arg: 'static,
      accum_Arg: Clone,
      accum_Arg: GraphRefEdge<T>,
      accum_Arg: 'static,
      lr_Arg: Clone,
      lr_Arg: GraphEdge<T>,
      lr_Arg: 'static,
      grad_Arg: Clone,
      grad_Arg: GraphEdge<T>,
      grad_Arg: 'static,
      momentum_Arg: Clone,
      momentum_Arg: GraphEdge<T>,
      momentum_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    var: var_Arg,
    accum: accum_Arg,
    lr: lr_Arg,
    grad: grad_Arg,
    momentum: momentum_Arg,
    use_locking: Option<bool>,
    use_nesterov: Option<bool>,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<T, var_Arg, accum_Arg, lr_Arg, grad_Arg, momentum_Arg> ApplyMomentum<T, var_Arg, accum_Arg, lr_Arg, grad_Arg, momentum_Arg>
where T: TensorType,
      T: Clone,
      var_Arg: Clone,
      var_Arg: GraphRefEdge<T>,
      var_Arg: 'static,
      accum_Arg: Clone,
      accum_Arg: GraphRefEdge<T>,
      accum_Arg: 'static,
      lr_Arg: Clone,
      lr_Arg: GraphEdge<T>,
      lr_Arg: 'static,
      grad_Arg: Clone,
      grad_Arg: GraphEdge<T>,
      grad_Arg: 'static,
      momentum_Arg: Clone,
      momentum_Arg: GraphEdge<T>,
      momentum_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
{
    pub fn out(self) -> RefEdge<T> {
        let rc = Rc::new(self);
        {
            RefEdge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn use_locking(&mut self, use_locking: bool) -> Self {
        self.use_locking = Some(use_locking);
        self.clone()
    }

    pub fn use_nesterov(&mut self, use_nesterov: bool) -> Self {
        self.use_nesterov = Some(use_nesterov);
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> RefEdge<T> {
        let rc = Rc::new(self);
        {
            RefEdge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(var: var_Arg, accum: accum_Arg, lr: lr_Arg, grad: grad_Arg, momentum: momentum_Arg) -> Self {
        Self {
            phantom_T: PhantomData,
            var,
            accum,
            lr,
            grad,
            momentum,
            use_locking: None,
            use_nesterov: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(var: var_Arg, accum: accum_Arg, lr: lr_Arg, grad: grad_Arg, momentum: momentum_Arg) -> RefEdge<T> {
        Self {
            phantom_T: PhantomData,
            var,
            accum,
            lr,
            grad,
            momentum,
            use_locking: None,
            use_nesterov: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<sp_indices_Arg, T, sp_values_Arg, sp_shape_Arg, dense_Arg> GraphOperation for SparseDenseCwiseDiv<sp_indices_Arg, T, sp_values_Arg, sp_shape_Arg, dense_Arg>
where sp_indices_Arg: Clone,
      sp_indices_Arg: GraphEdge<i64>,
      sp_indices_Arg: 'static,
      T: TensorType,
      T: Clone,
      sp_values_Arg: Clone,
      sp_values_Arg: GraphEdge<T>,
      sp_values_Arg: 'static,
      sp_shape_Arg: Clone,
      sp_shape_Arg: GraphEdge<i64>,
      sp_shape_Arg: 'static,
      dense_Arg: Clone,
      dense_Arg: GraphEdge<T>,
      dense_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("SparseDenseCwiseDiv_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("SparseDenseCwiseDiv", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.sp_indices)?
        }
        {
            new_op.add_edge(&self.sp_values)?
        }
        {
            new_op.add_edge(&self.sp_shape)?
        }
        {
            new_op.add_edge(&self.dense)?
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct SparseDenseCwiseDiv<sp_indices_Arg, T, sp_values_Arg, sp_shape_Arg, dense_Arg>
where sp_indices_Arg: Clone,
      sp_indices_Arg: GraphEdge<i64>,
      sp_indices_Arg: 'static,
      T: TensorType,
      T: Clone,
      sp_values_Arg: Clone,
      sp_values_Arg: GraphEdge<T>,
      sp_values_Arg: 'static,
      sp_shape_Arg: Clone,
      sp_shape_Arg: GraphEdge<i64>,
      sp_shape_Arg: 'static,
      dense_Arg: Clone,
      dense_Arg: GraphEdge<T>,
      dense_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
{
    sp_indices: sp_indices_Arg,
    phantom_T: PhantomData<T>,
    sp_values: sp_values_Arg,
    sp_shape: sp_shape_Arg,
    dense: dense_Arg,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<sp_indices_Arg, T, sp_values_Arg, sp_shape_Arg, dense_Arg> SparseDenseCwiseDiv<sp_indices_Arg, T, sp_values_Arg, sp_shape_Arg, dense_Arg>
where sp_indices_Arg: Clone,
      sp_indices_Arg: GraphEdge<i64>,
      sp_indices_Arg: 'static,
      T: TensorType,
      T: Clone,
      sp_values_Arg: Clone,
      sp_values_Arg: GraphEdge<T>,
      sp_values_Arg: 'static,
      sp_shape_Arg: Clone,
      sp_shape_Arg: GraphEdge<i64>,
      sp_shape_Arg: 'static,
      dense_Arg: Clone,
      dense_Arg: GraphEdge<T>,
      dense_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
{
    pub fn output(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(sp_indices: sp_indices_Arg, sp_values: sp_values_Arg, sp_shape: sp_shape_Arg, dense: dense_Arg) -> Self {
        Self {
            sp_indices,
            phantom_T: PhantomData,
            sp_values,
            sp_shape,
            dense,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(sp_indices: sp_indices_Arg, sp_values: sp_values_Arg, sp_shape: sp_shape_Arg, dense: dense_Arg) -> Edge<T> {
        Self {
            sp_indices,
            phantom_T: PhantomData,
            sp_values,
            sp_shape,
            dense,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<sp_indices_Arg, T, sp_values_Arg, sp_shape_Arg, dense_Arg> GraphOperation for SparseDenseCwiseMul<sp_indices_Arg, T, sp_values_Arg, sp_shape_Arg, dense_Arg>
where sp_indices_Arg: Clone,
      sp_indices_Arg: GraphEdge<i64>,
      sp_indices_Arg: 'static,
      T: TensorType,
      T: Clone,
      sp_values_Arg: Clone,
      sp_values_Arg: GraphEdge<T>,
      sp_values_Arg: 'static,
      sp_shape_Arg: Clone,
      sp_shape_Arg: GraphEdge<i64>,
      sp_shape_Arg: 'static,
      dense_Arg: Clone,
      dense_Arg: GraphEdge<T>,
      dense_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("SparseDenseCwiseMul_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("SparseDenseCwiseMul", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.sp_indices)?
        }
        {
            new_op.add_edge(&self.sp_values)?
        }
        {
            new_op.add_edge(&self.sp_shape)?
        }
        {
            new_op.add_edge(&self.dense)?
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct SparseDenseCwiseMul<sp_indices_Arg, T, sp_values_Arg, sp_shape_Arg, dense_Arg>
where sp_indices_Arg: Clone,
      sp_indices_Arg: GraphEdge<i64>,
      sp_indices_Arg: 'static,
      T: TensorType,
      T: Clone,
      sp_values_Arg: Clone,
      sp_values_Arg: GraphEdge<T>,
      sp_values_Arg: 'static,
      sp_shape_Arg: Clone,
      sp_shape_Arg: GraphEdge<i64>,
      sp_shape_Arg: 'static,
      dense_Arg: Clone,
      dense_Arg: GraphEdge<T>,
      dense_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
{
    sp_indices: sp_indices_Arg,
    phantom_T: PhantomData<T>,
    sp_values: sp_values_Arg,
    sp_shape: sp_shape_Arg,
    dense: dense_Arg,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<sp_indices_Arg, T, sp_values_Arg, sp_shape_Arg, dense_Arg> SparseDenseCwiseMul<sp_indices_Arg, T, sp_values_Arg, sp_shape_Arg, dense_Arg>
where sp_indices_Arg: Clone,
      sp_indices_Arg: GraphEdge<i64>,
      sp_indices_Arg: 'static,
      T: TensorType,
      T: Clone,
      sp_values_Arg: Clone,
      sp_values_Arg: GraphEdge<T>,
      sp_values_Arg: 'static,
      sp_shape_Arg: Clone,
      sp_shape_Arg: GraphEdge<i64>,
      sp_shape_Arg: 'static,
      dense_Arg: Clone,
      dense_Arg: GraphEdge<T>,
      dense_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
{
    pub fn output(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(sp_indices: sp_indices_Arg, sp_values: sp_values_Arg, sp_shape: sp_shape_Arg, dense: dense_Arg) -> Self {
        Self {
            sp_indices,
            phantom_T: PhantomData,
            sp_values,
            sp_shape,
            dense,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(sp_indices: sp_indices_Arg, sp_values: sp_values_Arg, sp_shape: sp_shape_Arg, dense: dense_Arg) -> Edge<T> {
        Self {
            sp_indices,
            phantom_T: PhantomData,
            sp_values,
            sp_shape,
            dense,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<input_indices_Arg, T, input_values_Arg, input_shape_Arg, reduction_axes_Arg> GraphOperation for SparseReduceSumSparse<input_indices_Arg, T, input_values_Arg, input_shape_Arg, reduction_axes_Arg>
where input_indices_Arg: Clone,
      input_indices_Arg: GraphEdge<i64>,
      input_indices_Arg: 'static,
      T: TensorType,
      T: Clone,
      input_values_Arg: Clone,
      input_values_Arg: GraphEdge<T>,
      input_values_Arg: 'static,
      input_shape_Arg: Clone,
      input_shape_Arg: GraphEdge<i64>,
      input_shape_Arg: 'static,
      reduction_axes_Arg: Clone,
      reduction_axes_Arg: GraphEdge<i32>,
      reduction_axes_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("SparseReduceSumSparse_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("SparseReduceSumSparse", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.input_indices)?
        }
        {
            new_op.add_edge(&self.input_values)?
        }
        {
            new_op.add_edge(&self.input_shape)?
        }
        {
            new_op.add_edge(&self.reduction_axes)?
        }
        {
            match self.keep_dims {
                None => new_op.set_attr_value_proto("keep_dims", &vec![40_u8, 0_u8,])?,
                Some(ref value) => (|attr: &bool| {new_op.set_attr_bool("keep_dims", *attr)})(&value)?,
            };
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct SparseReduceSumSparse<input_indices_Arg, T, input_values_Arg, input_shape_Arg, reduction_axes_Arg>
where input_indices_Arg: Clone,
      input_indices_Arg: GraphEdge<i64>,
      input_indices_Arg: 'static,
      T: TensorType,
      T: Clone,
      input_values_Arg: Clone,
      input_values_Arg: GraphEdge<T>,
      input_values_Arg: 'static,
      input_shape_Arg: Clone,
      input_shape_Arg: GraphEdge<i64>,
      input_shape_Arg: 'static,
      reduction_axes_Arg: Clone,
      reduction_axes_Arg: GraphEdge<i32>,
      reduction_axes_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
{
    input_indices: input_indices_Arg,
    phantom_T: PhantomData<T>,
    input_values: input_values_Arg,
    input_shape: input_shape_Arg,
    reduction_axes: reduction_axes_Arg,
    keep_dims: Option<bool>,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<input_indices_Arg, T, input_values_Arg, input_shape_Arg, reduction_axes_Arg> SparseReduceSumSparse<input_indices_Arg, T, input_values_Arg, input_shape_Arg, reduction_axes_Arg>
where input_indices_Arg: Clone,
      input_indices_Arg: GraphEdge<i64>,
      input_indices_Arg: 'static,
      T: TensorType,
      T: Clone,
      input_values_Arg: Clone,
      input_values_Arg: GraphEdge<T>,
      input_values_Arg: 'static,
      input_shape_Arg: Clone,
      input_shape_Arg: GraphEdge<i64>,
      input_shape_Arg: 'static,
      reduction_axes_Arg: Clone,
      reduction_axes_Arg: GraphEdge<i32>,
      reduction_axes_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
{
    pub fn output_indices(self) -> Edge<i64> {
        let rc = Rc::new(self);
        {
            Edge::<i64>::new(rc.clone(), 0)
        }
    }

    pub fn output_values(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 1)
        }
    }

    pub fn output_shape(self) -> Edge<i64> {
        let rc = Rc::new(self);
        {
            Edge::<i64>::new(rc.clone(), 2)
        }
    }

    pub fn keep_dims(&mut self, keep_dims: bool) -> Self {
        self.keep_dims = Some(keep_dims);
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> (Edge<i64>, Edge<T>, Edge<i64>) {
        let rc = Rc::new(self);
        (
        {
            Edge::<i64>::new(rc.clone(), 0)
        },
        {
            Edge::<T>::new(rc.clone(), 1)
        },
        {
            Edge::<i64>::new(rc.clone(), 2)
        },
        )
    }

    pub fn build(input_indices: input_indices_Arg, input_values: input_values_Arg, input_shape: input_shape_Arg, reduction_axes: reduction_axes_Arg) -> Self {
        Self {
            input_indices,
            phantom_T: PhantomData,
            input_values,
            input_shape,
            reduction_axes,
            keep_dims: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(input_indices: input_indices_Arg, input_values: input_values_Arg, input_shape: input_shape_Arg, reduction_axes: reduction_axes_Arg) -> (Edge<i64>, Edge<T>, Edge<i64>) {
        Self {
            input_indices,
            phantom_T: PhantomData,
            input_values,
            input_shape,
            reduction_axes,
            keep_dims: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<input_indices_Arg, T, input_values_Arg, input_shape_Arg, reduction_axes_Arg> GraphOperation for SparseReduceSum<input_indices_Arg, T, input_values_Arg, input_shape_Arg, reduction_axes_Arg>
where input_indices_Arg: Clone,
      input_indices_Arg: GraphEdge<i64>,
      input_indices_Arg: 'static,
      T: TensorType,
      T: Clone,
      input_values_Arg: Clone,
      input_values_Arg: GraphEdge<T>,
      input_values_Arg: 'static,
      input_shape_Arg: Clone,
      input_shape_Arg: GraphEdge<i64>,
      input_shape_Arg: 'static,
      reduction_axes_Arg: Clone,
      reduction_axes_Arg: GraphEdge<i32>,
      reduction_axes_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("SparseReduceSum_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("SparseReduceSum", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.input_indices)?
        }
        {
            new_op.add_edge(&self.input_values)?
        }
        {
            new_op.add_edge(&self.input_shape)?
        }
        {
            new_op.add_edge(&self.reduction_axes)?
        }
        {
            match self.keep_dims {
                None => new_op.set_attr_value_proto("keep_dims", &vec![40_u8, 0_u8,])?,
                Some(ref value) => (|attr: &bool| {new_op.set_attr_bool("keep_dims", *attr)})(&value)?,
            };
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct SparseReduceSum<input_indices_Arg, T, input_values_Arg, input_shape_Arg, reduction_axes_Arg>
where input_indices_Arg: Clone,
      input_indices_Arg: GraphEdge<i64>,
      input_indices_Arg: 'static,
      T: TensorType,
      T: Clone,
      input_values_Arg: Clone,
      input_values_Arg: GraphEdge<T>,
      input_values_Arg: 'static,
      input_shape_Arg: Clone,
      input_shape_Arg: GraphEdge<i64>,
      input_shape_Arg: 'static,
      reduction_axes_Arg: Clone,
      reduction_axes_Arg: GraphEdge<i32>,
      reduction_axes_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
{
    input_indices: input_indices_Arg,
    phantom_T: PhantomData<T>,
    input_values: input_values_Arg,
    input_shape: input_shape_Arg,
    reduction_axes: reduction_axes_Arg,
    keep_dims: Option<bool>,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<input_indices_Arg, T, input_values_Arg, input_shape_Arg, reduction_axes_Arg> SparseReduceSum<input_indices_Arg, T, input_values_Arg, input_shape_Arg, reduction_axes_Arg>
where input_indices_Arg: Clone,
      input_indices_Arg: GraphEdge<i64>,
      input_indices_Arg: 'static,
      T: TensorType,
      T: Clone,
      input_values_Arg: Clone,
      input_values_Arg: GraphEdge<T>,
      input_values_Arg: 'static,
      input_shape_Arg: Clone,
      input_shape_Arg: GraphEdge<i64>,
      input_shape_Arg: 'static,
      reduction_axes_Arg: Clone,
      reduction_axes_Arg: GraphEdge<i32>,
      reduction_axes_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
{
    pub fn output(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn keep_dims(&mut self, keep_dims: bool) -> Self {
        self.keep_dims = Some(keep_dims);
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(input_indices: input_indices_Arg, input_values: input_values_Arg, input_shape: input_shape_Arg, reduction_axes: reduction_axes_Arg) -> Self {
        Self {
            input_indices,
            phantom_T: PhantomData,
            input_values,
            input_shape,
            reduction_axes,
            keep_dims: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(input_indices: input_indices_Arg, input_values: input_values_Arg, input_shape: input_shape_Arg, reduction_axes: reduction_axes_Arg) -> Edge<T> {
        Self {
            input_indices,
            phantom_T: PhantomData,
            input_values,
            input_shape,
            reduction_axes,
            keep_dims: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<input_indices_Arg, T, input_values_Arg, input_shape_Arg, reduction_axes_Arg> GraphOperation for SparseReduceMaxSparse<input_indices_Arg, T, input_values_Arg, input_shape_Arg, reduction_axes_Arg>
where input_indices_Arg: Clone,
      input_indices_Arg: GraphEdge<i64>,
      input_indices_Arg: 'static,
      T: TensorType,
      T: Clone,
      input_values_Arg: Clone,
      input_values_Arg: GraphEdge<T>,
      input_values_Arg: 'static,
      input_shape_Arg: Clone,
      input_shape_Arg: GraphEdge<i64>,
      input_shape_Arg: 'static,
      reduction_axes_Arg: Clone,
      reduction_axes_Arg: GraphEdge<i32>,
      reduction_axes_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("SparseReduceMaxSparse_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("SparseReduceMaxSparse", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.input_indices)?
        }
        {
            new_op.add_edge(&self.input_values)?
        }
        {
            new_op.add_edge(&self.input_shape)?
        }
        {
            new_op.add_edge(&self.reduction_axes)?
        }
        {
            match self.keep_dims {
                None => new_op.set_attr_value_proto("keep_dims", &vec![40_u8, 0_u8,])?,
                Some(ref value) => (|attr: &bool| {new_op.set_attr_bool("keep_dims", *attr)})(&value)?,
            };
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct SparseReduceMaxSparse<input_indices_Arg, T, input_values_Arg, input_shape_Arg, reduction_axes_Arg>
where input_indices_Arg: Clone,
      input_indices_Arg: GraphEdge<i64>,
      input_indices_Arg: 'static,
      T: TensorType,
      T: Clone,
      input_values_Arg: Clone,
      input_values_Arg: GraphEdge<T>,
      input_values_Arg: 'static,
      input_shape_Arg: Clone,
      input_shape_Arg: GraphEdge<i64>,
      input_shape_Arg: 'static,
      reduction_axes_Arg: Clone,
      reduction_axes_Arg: GraphEdge<i32>,
      reduction_axes_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
{
    input_indices: input_indices_Arg,
    phantom_T: PhantomData<T>,
    input_values: input_values_Arg,
    input_shape: input_shape_Arg,
    reduction_axes: reduction_axes_Arg,
    keep_dims: Option<bool>,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<input_indices_Arg, T, input_values_Arg, input_shape_Arg, reduction_axes_Arg> SparseReduceMaxSparse<input_indices_Arg, T, input_values_Arg, input_shape_Arg, reduction_axes_Arg>
where input_indices_Arg: Clone,
      input_indices_Arg: GraphEdge<i64>,
      input_indices_Arg: 'static,
      T: TensorType,
      T: Clone,
      input_values_Arg: Clone,
      input_values_Arg: GraphEdge<T>,
      input_values_Arg: 'static,
      input_shape_Arg: Clone,
      input_shape_Arg: GraphEdge<i64>,
      input_shape_Arg: 'static,
      reduction_axes_Arg: Clone,
      reduction_axes_Arg: GraphEdge<i32>,
      reduction_axes_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
{
    pub fn output_indices(self) -> Edge<i64> {
        let rc = Rc::new(self);
        {
            Edge::<i64>::new(rc.clone(), 0)
        }
    }

    pub fn output_values(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 1)
        }
    }

    pub fn output_shape(self) -> Edge<i64> {
        let rc = Rc::new(self);
        {
            Edge::<i64>::new(rc.clone(), 2)
        }
    }

    pub fn keep_dims(&mut self, keep_dims: bool) -> Self {
        self.keep_dims = Some(keep_dims);
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> (Edge<i64>, Edge<T>, Edge<i64>) {
        let rc = Rc::new(self);
        (
        {
            Edge::<i64>::new(rc.clone(), 0)
        },
        {
            Edge::<T>::new(rc.clone(), 1)
        },
        {
            Edge::<i64>::new(rc.clone(), 2)
        },
        )
    }

    pub fn build(input_indices: input_indices_Arg, input_values: input_values_Arg, input_shape: input_shape_Arg, reduction_axes: reduction_axes_Arg) -> Self {
        Self {
            input_indices,
            phantom_T: PhantomData,
            input_values,
            input_shape,
            reduction_axes,
            keep_dims: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(input_indices: input_indices_Arg, input_values: input_values_Arg, input_shape: input_shape_Arg, reduction_axes: reduction_axes_Arg) -> (Edge<i64>, Edge<T>, Edge<i64>) {
        Self {
            input_indices,
            phantom_T: PhantomData,
            input_values,
            input_shape,
            reduction_axes,
            keep_dims: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<Tindices, a_indices_Arg, T, a_values_Arg, a_shape_Arg, b_Arg> GraphOperation for SparseTensorDenseAdd<Tindices, a_indices_Arg, T, a_values_Arg, a_shape_Arg, b_Arg>
where Tindices: TensorType,
      Tindices: Clone,
      a_indices_Arg: Clone,
      a_indices_Arg: GraphEdge<Tindices>,
      a_indices_Arg: 'static,
      T: TensorType,
      T: Clone,
      a_values_Arg: Clone,
      a_values_Arg: GraphEdge<T>,
      a_values_Arg: 'static,
      a_shape_Arg: Clone,
      a_shape_Arg: GraphEdge<Tindices>,
      a_shape_Arg: 'static,
      b_Arg: Clone,
      b_Arg: GraphEdge<T>,
      b_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
      Tindices: con_or_DT_INT32_or_DT_INT64,
      Tindices: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("SparseTensorDenseAdd_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("SparseTensorDenseAdd", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.a_indices)?
        }
        {
            new_op.add_edge(&self.a_values)?
        }
        {
            new_op.add_edge(&self.a_shape)?
        }
        {
            new_op.add_edge(&self.b)?
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        {
            new_op.set_attr_type("Tindices", Tindices::data_type())?;
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct SparseTensorDenseAdd<Tindices, a_indices_Arg, T, a_values_Arg, a_shape_Arg, b_Arg>
where Tindices: TensorType,
      Tindices: Clone,
      a_indices_Arg: Clone,
      a_indices_Arg: GraphEdge<Tindices>,
      a_indices_Arg: 'static,
      T: TensorType,
      T: Clone,
      a_values_Arg: Clone,
      a_values_Arg: GraphEdge<T>,
      a_values_Arg: 'static,
      a_shape_Arg: Clone,
      a_shape_Arg: GraphEdge<Tindices>,
      a_shape_Arg: 'static,
      b_Arg: Clone,
      b_Arg: GraphEdge<T>,
      b_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
      Tindices: con_or_DT_INT32_or_DT_INT64,
      Tindices: 'static,
{
    phantom_Tindices: PhantomData<Tindices>,
    a_indices: a_indices_Arg,
    phantom_T: PhantomData<T>,
    a_values: a_values_Arg,
    a_shape: a_shape_Arg,
    b: b_Arg,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<Tindices, a_indices_Arg, T, a_values_Arg, a_shape_Arg, b_Arg> SparseTensorDenseAdd<Tindices, a_indices_Arg, T, a_values_Arg, a_shape_Arg, b_Arg>
where Tindices: TensorType,
      Tindices: Clone,
      a_indices_Arg: Clone,
      a_indices_Arg: GraphEdge<Tindices>,
      a_indices_Arg: 'static,
      T: TensorType,
      T: Clone,
      a_values_Arg: Clone,
      a_values_Arg: GraphEdge<T>,
      a_values_Arg: 'static,
      a_shape_Arg: Clone,
      a_shape_Arg: GraphEdge<Tindices>,
      a_shape_Arg: 'static,
      b_Arg: Clone,
      b_Arg: GraphEdge<T>,
      b_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
      Tindices: con_or_DT_INT32_or_DT_INT64,
      Tindices: 'static,
{
    pub fn output(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(a_indices: a_indices_Arg, a_values: a_values_Arg, a_shape: a_shape_Arg, b: b_Arg) -> Self {
        Self {
            phantom_Tindices: PhantomData,
            a_indices,
            phantom_T: PhantomData,
            a_values,
            a_shape,
            b,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(a_indices: a_indices_Arg, a_values: a_values_Arg, a_shape: a_shape_Arg, b: b_Arg) -> Edge<T> {
        Self {
            phantom_Tindices: PhantomData,
            a_indices,
            phantom_T: PhantomData,
            a_values,
            a_shape,
            b,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<input_indices_Arg, T, input_values_Arg, input_shape_Arg> GraphOperation for SparseReorder<input_indices_Arg, T, input_values_Arg, input_shape_Arg>
where input_indices_Arg: Clone,
      input_indices_Arg: GraphEdge<i64>,
      input_indices_Arg: 'static,
      T: TensorType,
      T: Clone,
      input_values_Arg: Clone,
      input_values_Arg: GraphEdge<T>,
      input_values_Arg: 'static,
      input_shape_Arg: Clone,
      input_shape_Arg: GraphEdge<i64>,
      input_shape_Arg: 'static,
      T: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("SparseReorder_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("SparseReorder", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.input_indices)?
        }
        {
            new_op.add_edge(&self.input_values)?
        }
        {
            new_op.add_edge(&self.input_shape)?
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct SparseReorder<input_indices_Arg, T, input_values_Arg, input_shape_Arg>
where input_indices_Arg: Clone,
      input_indices_Arg: GraphEdge<i64>,
      input_indices_Arg: 'static,
      T: TensorType,
      T: Clone,
      input_values_Arg: Clone,
      input_values_Arg: GraphEdge<T>,
      input_values_Arg: 'static,
      input_shape_Arg: Clone,
      input_shape_Arg: GraphEdge<i64>,
      input_shape_Arg: 'static,
      T: 'static,
{
    input_indices: input_indices_Arg,
    phantom_T: PhantomData<T>,
    input_values: input_values_Arg,
    input_shape: input_shape_Arg,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<input_indices_Arg, T, input_values_Arg, input_shape_Arg> SparseReorder<input_indices_Arg, T, input_values_Arg, input_shape_Arg>
where input_indices_Arg: Clone,
      input_indices_Arg: GraphEdge<i64>,
      input_indices_Arg: 'static,
      T: TensorType,
      T: Clone,
      input_values_Arg: Clone,
      input_values_Arg: GraphEdge<T>,
      input_values_Arg: 'static,
      input_shape_Arg: Clone,
      input_shape_Arg: GraphEdge<i64>,
      input_shape_Arg: 'static,
      T: 'static,
{
    pub fn output_indices(self) -> Edge<i64> {
        let rc = Rc::new(self);
        {
            Edge::<i64>::new(rc.clone(), 0)
        }
    }

    pub fn output_values(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 1)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> (Edge<i64>, Edge<T>) {
        let rc = Rc::new(self);
        (
        {
            Edge::<i64>::new(rc.clone(), 0)
        },
        {
            Edge::<T>::new(rc.clone(), 1)
        },
        )
    }

    pub fn build(input_indices: input_indices_Arg, input_values: input_values_Arg, input_shape: input_shape_Arg) -> Self {
        Self {
            input_indices,
            phantom_T: PhantomData,
            input_values,
            input_shape,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(input_indices: input_indices_Arg, input_values: input_values_Arg, input_shape: input_shape_Arg) -> (Edge<i64>, Edge<T>) {
        Self {
            input_indices,
            phantom_T: PhantomData,
            input_values,
            input_shape,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<T, backprop_val_grad_Arg, input_indices_Arg, input_start_Arg, output_indices_Arg> GraphOperation for SparseSliceGrad<T, backprop_val_grad_Arg, input_indices_Arg, input_start_Arg, output_indices_Arg>
where T: TensorType,
      T: Clone,
      backprop_val_grad_Arg: Clone,
      backprop_val_grad_Arg: GraphEdge<T>,
      backprop_val_grad_Arg: 'static,
      input_indices_Arg: Clone,
      input_indices_Arg: GraphEdge<i64>,
      input_indices_Arg: 'static,
      input_start_Arg: Clone,
      input_start_Arg: GraphEdge<i64>,
      input_start_Arg: 'static,
      output_indices_Arg: Clone,
      output_indices_Arg: GraphEdge<i64>,
      output_indices_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("SparseSliceGrad_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("SparseSliceGrad", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.backprop_val_grad)?
        }
        {
            new_op.add_edge(&self.input_indices)?
        }
        {
            new_op.add_edge(&self.input_start)?
        }
        {
            new_op.add_edge(&self.output_indices)?
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct SparseSliceGrad<T, backprop_val_grad_Arg, input_indices_Arg, input_start_Arg, output_indices_Arg>
where T: TensorType,
      T: Clone,
      backprop_val_grad_Arg: Clone,
      backprop_val_grad_Arg: GraphEdge<T>,
      backprop_val_grad_Arg: 'static,
      input_indices_Arg: Clone,
      input_indices_Arg: GraphEdge<i64>,
      input_indices_Arg: 'static,
      input_start_Arg: Clone,
      input_start_Arg: GraphEdge<i64>,
      input_start_Arg: 'static,
      output_indices_Arg: Clone,
      output_indices_Arg: GraphEdge<i64>,
      output_indices_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    backprop_val_grad: backprop_val_grad_Arg,
    input_indices: input_indices_Arg,
    input_start: input_start_Arg,
    output_indices: output_indices_Arg,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<T, backprop_val_grad_Arg, input_indices_Arg, input_start_Arg, output_indices_Arg> SparseSliceGrad<T, backprop_val_grad_Arg, input_indices_Arg, input_start_Arg, output_indices_Arg>
where T: TensorType,
      T: Clone,
      backprop_val_grad_Arg: Clone,
      backprop_val_grad_Arg: GraphEdge<T>,
      backprop_val_grad_Arg: 'static,
      input_indices_Arg: Clone,
      input_indices_Arg: GraphEdge<i64>,
      input_indices_Arg: 'static,
      input_start_Arg: Clone,
      input_start_Arg: GraphEdge<i64>,
      input_start_Arg: 'static,
      output_indices_Arg: Clone,
      output_indices_Arg: GraphEdge<i64>,
      output_indices_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
{
    pub fn val_grad(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(backprop_val_grad: backprop_val_grad_Arg, input_indices: input_indices_Arg, input_start: input_start_Arg, output_indices: output_indices_Arg) -> Self {
        Self {
            phantom_T: PhantomData,
            backprop_val_grad,
            input_indices,
            input_start,
            output_indices,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(backprop_val_grad: backprop_val_grad_Arg, input_indices: input_indices_Arg, input_start: input_start_Arg, output_indices: output_indices_Arg) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            backprop_val_grad,
            input_indices,
            input_start,
            output_indices,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<split_dim_Arg, indices_Arg, T, values_Arg, shape_Arg> GraphOperation for SparseSplit<split_dim_Arg, indices_Arg, T, values_Arg, shape_Arg>
where split_dim_Arg: Clone,
      split_dim_Arg: GraphEdge<i64>,
      split_dim_Arg: 'static,
      indices_Arg: Clone,
      indices_Arg: GraphEdge<i64>,
      indices_Arg: 'static,
      T: TensorType,
      T: Clone,
      values_Arg: Clone,
      values_Arg: GraphEdge<T>,
      values_Arg: 'static,
      shape_Arg: Clone,
      shape_Arg: GraphEdge<i64>,
      shape_Arg: 'static,
      T: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("SparseSplit_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("SparseSplit", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.split_dim)?
        }
        {
            new_op.add_edge(&self.indices)?
        }
        {
            new_op.add_edge(&self.values)?
        }
        {
            new_op.add_edge(&self.shape)?
        }
        {
            (|attr: &i64| {new_op.set_attr_int("num_split", *attr)})(&self.num_split)?
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct SparseSplit<split_dim_Arg, indices_Arg, T, values_Arg, shape_Arg>
where split_dim_Arg: Clone,
      split_dim_Arg: GraphEdge<i64>,
      split_dim_Arg: 'static,
      indices_Arg: Clone,
      indices_Arg: GraphEdge<i64>,
      indices_Arg: 'static,
      T: TensorType,
      T: Clone,
      values_Arg: Clone,
      values_Arg: GraphEdge<T>,
      values_Arg: 'static,
      shape_Arg: Clone,
      shape_Arg: GraphEdge<i64>,
      shape_Arg: 'static,
      T: 'static,
{
    split_dim: split_dim_Arg,
    indices: indices_Arg,
    phantom_T: PhantomData<T>,
    values: values_Arg,
    shape: shape_Arg,
    num_split: i64,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<split_dim_Arg, indices_Arg, T, values_Arg, shape_Arg> SparseSplit<split_dim_Arg, indices_Arg, T, values_Arg, shape_Arg>
where split_dim_Arg: Clone,
      split_dim_Arg: GraphEdge<i64>,
      split_dim_Arg: 'static,
      indices_Arg: Clone,
      indices_Arg: GraphEdge<i64>,
      indices_Arg: 'static,
      T: TensorType,
      T: Clone,
      values_Arg: Clone,
      values_Arg: GraphEdge<T>,
      values_Arg: 'static,
      shape_Arg: Clone,
      shape_Arg: GraphEdge<i64>,
      shape_Arg: 'static,
      T: 'static,
{
    pub fn output_indices(self) -> Edge<i64> {
        let rc = Rc::new(self);
        {
            Edge::<i64>::new(rc.clone(), 0)
        }
    }

    pub fn output_values(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 1)
        }
    }

    pub fn output_shape(self) -> Edge<i64> {
        let rc = Rc::new(self);
        {
            Edge::<i64>::new(rc.clone(), 2)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> (Edge<i64>, Edge<T>, Edge<i64>) {
        let rc = Rc::new(self);
        (
        {
            Edge::<i64>::new(rc.clone(), 0)
        },
        {
            Edge::<T>::new(rc.clone(), 1)
        },
        {
            Edge::<i64>::new(rc.clone(), 2)
        },
        )
    }

    pub fn build(split_dim: split_dim_Arg, indices: indices_Arg, values: values_Arg, shape: shape_Arg, num_split: i64) -> Self {
        Self {
            split_dim,
            indices,
            phantom_T: PhantomData,
            values,
            shape,
            num_split: num_split,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(split_dim: split_dim_Arg, indices: indices_Arg, values: values_Arg, shape: shape_Arg, num_split: i64) -> (Edge<i64>, Edge<T>, Edge<i64>) {
        Self {
            split_dim,
            indices,
            phantom_T: PhantomData,
            values,
            shape,
            num_split: num_split,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<input_Arg, fft_length_Arg> GraphOperation for IRFFT<input_Arg, fft_length_Arg>
where input_Arg: Clone,
      input_Arg: GraphEdge<OtherComplex<f32>>,
      input_Arg: 'static,
      fft_length_Arg: Clone,
      fft_length_Arg: GraphEdge<i32>,
      fft_length_Arg: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("IRFFT_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("IRFFT", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.input)?
        }
        {
            new_op.add_edge(&self.fft_length)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct IRFFT<input_Arg, fft_length_Arg>
where input_Arg: Clone,
      input_Arg: GraphEdge<OtherComplex<f32>>,
      input_Arg: 'static,
      fft_length_Arg: Clone,
      fft_length_Arg: GraphEdge<i32>,
      fft_length_Arg: 'static,
{
    input: input_Arg,
    fft_length: fft_length_Arg,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<input_Arg, fft_length_Arg> IRFFT<input_Arg, fft_length_Arg>
where input_Arg: Clone,
      input_Arg: GraphEdge<OtherComplex<f32>>,
      input_Arg: 'static,
      fft_length_Arg: Clone,
      fft_length_Arg: GraphEdge<i32>,
      fft_length_Arg: 'static,
{
    pub fn output(self) -> Edge<f32> {
        let rc = Rc::new(self);
        {
            Edge::<f32>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<f32> {
        let rc = Rc::new(self);
        {
            Edge::<f32>::new(rc.clone(), 0)
        }
    }

    pub fn build(input: input_Arg, fft_length: fft_length_Arg) -> Self {
        Self {
            input,
            fft_length,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(input: input_Arg, fft_length: fft_length_Arg) -> Edge<f32> {
        Self {
            input,
            fft_length,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<indices_Arg, T, values_Arg, shapes_Arg> GraphOperation for SparseConcat<indices_Arg, T, values_Arg, shapes_Arg>
where indices_Arg: Clone,
      indices_Arg: GraphEdge<i64>,
      indices_Arg: 'static,
      T: TensorType,
      T: Clone,
      values_Arg: Clone,
      values_Arg: GraphEdge<T>,
      values_Arg: 'static,
      shapes_Arg: Clone,
      shapes_Arg: GraphEdge<i64>,
      shapes_Arg: 'static,
      T: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("SparseConcat_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("SparseConcat", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.indices)?
        }
        {
            new_op.add_edge(&self.values)?
        }
        {
            new_op.add_edge(&self.shapes)?
        }
        {
            (|attr: &i64| {new_op.set_attr_int("concat_dim", *attr)})(&self.concat_dim)?
        }
        {
            (|attr: &i64| {new_op.set_attr_int("N", *attr)})(&self.N)?
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct SparseConcat<indices_Arg, T, values_Arg, shapes_Arg>
where indices_Arg: Clone,
      indices_Arg: GraphEdge<i64>,
      indices_Arg: 'static,
      T: TensorType,
      T: Clone,
      values_Arg: Clone,
      values_Arg: GraphEdge<T>,
      values_Arg: 'static,
      shapes_Arg: Clone,
      shapes_Arg: GraphEdge<i64>,
      shapes_Arg: 'static,
      T: 'static,
{
    indices: indices_Arg,
    phantom_T: PhantomData<T>,
    values: values_Arg,
    shapes: shapes_Arg,
    concat_dim: i64,
    N: i64,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<indices_Arg, T, values_Arg, shapes_Arg> SparseConcat<indices_Arg, T, values_Arg, shapes_Arg>
where indices_Arg: Clone,
      indices_Arg: GraphEdge<i64>,
      indices_Arg: 'static,
      T: TensorType,
      T: Clone,
      values_Arg: Clone,
      values_Arg: GraphEdge<T>,
      values_Arg: 'static,
      shapes_Arg: Clone,
      shapes_Arg: GraphEdge<i64>,
      shapes_Arg: 'static,
      T: 'static,
{
    pub fn output_indices(self) -> Edge<i64> {
        let rc = Rc::new(self);
        {
            Edge::<i64>::new(rc.clone(), 0)
        }
    }

    pub fn output_values(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 1)
        }
    }

    pub fn output_shape(self) -> Edge<i64> {
        let rc = Rc::new(self);
        {
            Edge::<i64>::new(rc.clone(), 2)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> (Edge<i64>, Edge<T>, Edge<i64>) {
        let rc = Rc::new(self);
        (
        {
            Edge::<i64>::new(rc.clone(), 0)
        },
        {
            Edge::<T>::new(rc.clone(), 1)
        },
        {
            Edge::<i64>::new(rc.clone(), 2)
        },
        )
    }

    pub fn build(indices: indices_Arg, values: values_Arg, shapes: shapes_Arg, concat_dim: i64, N: i64) -> Self {
        Self {
            indices,
            phantom_T: PhantomData,
            values,
            shapes,
            concat_dim: concat_dim,
            N: N,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(indices: indices_Arg, values: values_Arg, shapes: shapes_Arg, concat_dim: i64, N: i64) -> (Edge<i64>, Edge<T>, Edge<i64>) {
        Self {
            indices,
            phantom_T: PhantomData,
            values,
            shapes,
            concat_dim: concat_dim,
            N: N,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<Tindices, sparse_indices_Arg, output_shape_Arg, T, sparse_values_Arg, default_value_Arg> GraphOperation for SparseToDense<Tindices, sparse_indices_Arg, output_shape_Arg, T, sparse_values_Arg, default_value_Arg>
where Tindices: TensorType,
      Tindices: Clone,
      sparse_indices_Arg: Clone,
      sparse_indices_Arg: GraphEdge<Tindices>,
      sparse_indices_Arg: 'static,
      output_shape_Arg: Clone,
      output_shape_Arg: GraphEdge<Tindices>,
      output_shape_Arg: 'static,
      T: TensorType,
      T: Clone,
      sparse_values_Arg: Clone,
      sparse_values_Arg: GraphEdge<T>,
      sparse_values_Arg: 'static,
      default_value_Arg: Clone,
      default_value_Arg: GraphEdge<T>,
      default_value_Arg: 'static,
      T: 'static,
      Tindices: con_or_DT_INT32_or_DT_INT64,
      Tindices: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("SparseToDense_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("SparseToDense", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.sparse_indices)?
        }
        {
            new_op.add_edge(&self.output_shape)?
        }
        {
            new_op.add_edge(&self.sparse_values)?
        }
        {
            new_op.add_edge(&self.default_value)?
        }
        {
            match self.validate_indices {
                None => new_op.set_attr_value_proto("validate_indices", &vec![40_u8, 1_u8,])?,
                Some(ref value) => (|attr: &bool| {new_op.set_attr_bool("validate_indices", *attr)})(&value)?,
            };
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        {
            new_op.set_attr_type("Tindices", Tindices::data_type())?;
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct SparseToDense<Tindices, sparse_indices_Arg, output_shape_Arg, T, sparse_values_Arg, default_value_Arg>
where Tindices: TensorType,
      Tindices: Clone,
      sparse_indices_Arg: Clone,
      sparse_indices_Arg: GraphEdge<Tindices>,
      sparse_indices_Arg: 'static,
      output_shape_Arg: Clone,
      output_shape_Arg: GraphEdge<Tindices>,
      output_shape_Arg: 'static,
      T: TensorType,
      T: Clone,
      sparse_values_Arg: Clone,
      sparse_values_Arg: GraphEdge<T>,
      sparse_values_Arg: 'static,
      default_value_Arg: Clone,
      default_value_Arg: GraphEdge<T>,
      default_value_Arg: 'static,
      T: 'static,
      Tindices: con_or_DT_INT32_or_DT_INT64,
      Tindices: 'static,
{
    phantom_Tindices: PhantomData<Tindices>,
    sparse_indices: sparse_indices_Arg,
    output_shape: output_shape_Arg,
    phantom_T: PhantomData<T>,
    sparse_values: sparse_values_Arg,
    default_value: default_value_Arg,
    validate_indices: Option<bool>,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<Tindices, sparse_indices_Arg, output_shape_Arg, T, sparse_values_Arg, default_value_Arg> SparseToDense<Tindices, sparse_indices_Arg, output_shape_Arg, T, sparse_values_Arg, default_value_Arg>
where Tindices: TensorType,
      Tindices: Clone,
      sparse_indices_Arg: Clone,
      sparse_indices_Arg: GraphEdge<Tindices>,
      sparse_indices_Arg: 'static,
      output_shape_Arg: Clone,
      output_shape_Arg: GraphEdge<Tindices>,
      output_shape_Arg: 'static,
      T: TensorType,
      T: Clone,
      sparse_values_Arg: Clone,
      sparse_values_Arg: GraphEdge<T>,
      sparse_values_Arg: 'static,
      default_value_Arg: Clone,
      default_value_Arg: GraphEdge<T>,
      default_value_Arg: 'static,
      T: 'static,
      Tindices: con_or_DT_INT32_or_DT_INT64,
      Tindices: 'static,
{
    pub fn dense(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn validate_indices(&mut self, validate_indices: bool) -> Self {
        self.validate_indices = Some(validate_indices);
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(sparse_indices: sparse_indices_Arg, output_shape: output_shape_Arg, sparse_values: sparse_values_Arg, default_value: default_value_Arg) -> Self {
        Self {
            phantom_Tindices: PhantomData,
            sparse_indices,
            output_shape,
            phantom_T: PhantomData,
            sparse_values,
            default_value,
            validate_indices: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(sparse_indices: sparse_indices_Arg, output_shape: output_shape_Arg, sparse_values: sparse_values_Arg, default_value: default_value_Arg) -> Edge<T> {
        Self {
            phantom_Tindices: PhantomData,
            sparse_indices,
            output_shape,
            phantom_T: PhantomData,
            sparse_values,
            default_value,
            validate_indices: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<serialized_sparse_Arg, dtype> GraphOperation for DeserializeManySparse<serialized_sparse_Arg, dtype>
where serialized_sparse_Arg: Clone,
      serialized_sparse_Arg: GraphEdge<String>,
      serialized_sparse_Arg: 'static,
      dtype: TensorType,
      dtype: 'static,
      dtype: Clone,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("DeserializeManySparse_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("DeserializeManySparse", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.serialized_sparse)?
        }
        {
            new_op.set_attr_type("dtype", dtype::data_type())?;
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct DeserializeManySparse<serialized_sparse_Arg, dtype>
where serialized_sparse_Arg: Clone,
      serialized_sparse_Arg: GraphEdge<String>,
      serialized_sparse_Arg: 'static,
      dtype: TensorType,
      dtype: 'static,
      dtype: Clone,
{
    serialized_sparse: serialized_sparse_Arg,
    phantom_dtype: PhantomData<dtype>,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<serialized_sparse_Arg, dtype> DeserializeManySparse<serialized_sparse_Arg, dtype>
where serialized_sparse_Arg: Clone,
      serialized_sparse_Arg: GraphEdge<String>,
      serialized_sparse_Arg: 'static,
      dtype: TensorType,
      dtype: 'static,
      dtype: Clone,
{
    pub fn sparse_indices(self) -> Edge<i64> {
        let rc = Rc::new(self);
        {
            Edge::<i64>::new(rc.clone(), 0)
        }
    }

    pub fn sparse_values(self) -> Edge<dtype> {
        let rc = Rc::new(self);
        {
            Edge::<dtype>::new(rc.clone(), 1)
        }
    }

    pub fn sparse_shape(self) -> Edge<i64> {
        let rc = Rc::new(self);
        {
            Edge::<i64>::new(rc.clone(), 2)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> (Edge<i64>, Edge<dtype>, Edge<i64>) {
        let rc = Rc::new(self);
        (
        {
            Edge::<i64>::new(rc.clone(), 0)
        },
        {
            Edge::<dtype>::new(rc.clone(), 1)
        },
        {
            Edge::<i64>::new(rc.clone(), 2)
        },
        )
    }

    pub fn build(serialized_sparse: serialized_sparse_Arg) -> Self {
        Self {
            serialized_sparse,
            phantom_dtype: PhantomData,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(serialized_sparse: serialized_sparse_Arg) -> (Edge<i64>, Edge<dtype>, Edge<i64>) {
        Self {
            serialized_sparse,
            phantom_dtype: PhantomData,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

pub trait con_or_DT_STRING_or_DT_VARIANT {
}

impl con_or_DT_STRING_or_DT_VARIANT for String {
}

impl<Tserialized, serialized_sparse_Arg, dtype> GraphOperation for DeserializeSparse<Tserialized, serialized_sparse_Arg, dtype>
where Tserialized: TensorType,
      Tserialized: Clone,
      serialized_sparse_Arg: Clone,
      serialized_sparse_Arg: GraphEdge<Tserialized>,
      serialized_sparse_Arg: 'static,
      dtype: TensorType,
      dtype: 'static,
      dtype: Clone,
      Tserialized: con_or_DT_STRING_or_DT_VARIANT,
      Tserialized: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("DeserializeSparse_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("DeserializeSparse", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.serialized_sparse)?
        }
        {
            new_op.set_attr_type("dtype", dtype::data_type())?;
        }
        {
            new_op.set_attr_type("Tserialized", Tserialized::data_type())?;
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct DeserializeSparse<Tserialized, serialized_sparse_Arg, dtype>
where Tserialized: TensorType,
      Tserialized: Clone,
      serialized_sparse_Arg: Clone,
      serialized_sparse_Arg: GraphEdge<Tserialized>,
      serialized_sparse_Arg: 'static,
      dtype: TensorType,
      dtype: 'static,
      dtype: Clone,
      Tserialized: con_or_DT_STRING_or_DT_VARIANT,
      Tserialized: 'static,
{
    phantom_Tserialized: PhantomData<Tserialized>,
    serialized_sparse: serialized_sparse_Arg,
    phantom_dtype: PhantomData<dtype>,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<Tserialized, serialized_sparse_Arg, dtype> DeserializeSparse<Tserialized, serialized_sparse_Arg, dtype>
where Tserialized: TensorType,
      Tserialized: Clone,
      serialized_sparse_Arg: Clone,
      serialized_sparse_Arg: GraphEdge<Tserialized>,
      serialized_sparse_Arg: 'static,
      dtype: TensorType,
      dtype: 'static,
      dtype: Clone,
      Tserialized: con_or_DT_STRING_or_DT_VARIANT,
      Tserialized: 'static,
{
    pub fn sparse_indices(self) -> Edge<i64> {
        let rc = Rc::new(self);
        {
            Edge::<i64>::new(rc.clone(), 0)
        }
    }

    pub fn sparse_values(self) -> Edge<dtype> {
        let rc = Rc::new(self);
        {
            Edge::<dtype>::new(rc.clone(), 1)
        }
    }

    pub fn sparse_shape(self) -> Edge<i64> {
        let rc = Rc::new(self);
        {
            Edge::<i64>::new(rc.clone(), 2)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> (Edge<i64>, Edge<dtype>, Edge<i64>) {
        let rc = Rc::new(self);
        (
        {
            Edge::<i64>::new(rc.clone(), 0)
        },
        {
            Edge::<dtype>::new(rc.clone(), 1)
        },
        {
            Edge::<i64>::new(rc.clone(), 2)
        },
        )
    }

    pub fn build(serialized_sparse: serialized_sparse_Arg) -> Self {
        Self {
            phantom_Tserialized: PhantomData,
            serialized_sparse,
            phantom_dtype: PhantomData,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(serialized_sparse: serialized_sparse_Arg) -> (Edge<i64>, Edge<dtype>, Edge<i64>) {
        Self {
            phantom_Tserialized: PhantomData,
            serialized_sparse,
            phantom_dtype: PhantomData,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<sparse_indices_Arg, T, sparse_values_Arg, sparse_shape_Arg, out_type> GraphOperation for SerializeManySparse<sparse_indices_Arg, T, sparse_values_Arg, sparse_shape_Arg, out_type>
where sparse_indices_Arg: Clone,
      sparse_indices_Arg: GraphEdge<i64>,
      sparse_indices_Arg: 'static,
      T: TensorType,
      T: Clone,
      sparse_values_Arg: Clone,
      sparse_values_Arg: GraphEdge<T>,
      sparse_values_Arg: 'static,
      sparse_shape_Arg: Clone,
      sparse_shape_Arg: GraphEdge<i64>,
      sparse_shape_Arg: 'static,
      out_type: TensorType,
      T: 'static,
      out_type: con_or_DT_STRING_or_DT_VARIANT,
      out_type: 'static,
      out_type: Clone,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("SerializeManySparse_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("SerializeManySparse", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.sparse_indices)?
        }
        {
            new_op.add_edge(&self.sparse_values)?
        }
        {
            new_op.add_edge(&self.sparse_shape)?
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        {
            new_op.set_attr_type("out_type", out_type::data_type())?;
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct SerializeManySparse<sparse_indices_Arg, T, sparse_values_Arg, sparse_shape_Arg, out_type>
where sparse_indices_Arg: Clone,
      sparse_indices_Arg: GraphEdge<i64>,
      sparse_indices_Arg: 'static,
      T: TensorType,
      T: Clone,
      sparse_values_Arg: Clone,
      sparse_values_Arg: GraphEdge<T>,
      sparse_values_Arg: 'static,
      sparse_shape_Arg: Clone,
      sparse_shape_Arg: GraphEdge<i64>,
      sparse_shape_Arg: 'static,
      out_type: TensorType,
      T: 'static,
      out_type: con_or_DT_STRING_or_DT_VARIANT,
      out_type: 'static,
      out_type: Clone,
{
    sparse_indices: sparse_indices_Arg,
    phantom_T: PhantomData<T>,
    sparse_values: sparse_values_Arg,
    sparse_shape: sparse_shape_Arg,
    phantom_out_type: PhantomData<out_type>,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<sparse_indices_Arg, T, sparse_values_Arg, sparse_shape_Arg, out_type> SerializeManySparse<sparse_indices_Arg, T, sparse_values_Arg, sparse_shape_Arg, out_type>
where sparse_indices_Arg: Clone,
      sparse_indices_Arg: GraphEdge<i64>,
      sparse_indices_Arg: 'static,
      T: TensorType,
      T: Clone,
      sparse_values_Arg: Clone,
      sparse_values_Arg: GraphEdge<T>,
      sparse_values_Arg: 'static,
      sparse_shape_Arg: Clone,
      sparse_shape_Arg: GraphEdge<i64>,
      sparse_shape_Arg: 'static,
      out_type: TensorType,
      T: 'static,
      out_type: con_or_DT_STRING_or_DT_VARIANT,
      out_type: 'static,
      out_type: Clone,
{
    pub fn serialized_sparse(self) -> Edge<out_type> {
        let rc = Rc::new(self);
        {
            Edge::<out_type>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<out_type> {
        let rc = Rc::new(self);
        {
            Edge::<out_type>::new(rc.clone(), 0)
        }
    }

    pub fn build(sparse_indices: sparse_indices_Arg, sparse_values: sparse_values_Arg, sparse_shape: sparse_shape_Arg) -> Self {
        Self {
            sparse_indices,
            phantom_T: PhantomData,
            sparse_values,
            sparse_shape,
            phantom_out_type: PhantomData,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(sparse_indices: sparse_indices_Arg, sparse_values: sparse_values_Arg, sparse_shape: sparse_shape_Arg) -> Edge<out_type> {
        Self {
            sparse_indices,
            phantom_T: PhantomData,
            sparse_values,
            sparse_shape,
            phantom_out_type: PhantomData,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<Tindices, a_indices_Arg, T, a_values_Arg, a_shape_Arg, b_Arg> GraphOperation for SparseTensorDenseMatMul<Tindices, a_indices_Arg, T, a_values_Arg, a_shape_Arg, b_Arg>
where Tindices: TensorType,
      Tindices: Clone,
      a_indices_Arg: Clone,
      a_indices_Arg: GraphEdge<Tindices>,
      a_indices_Arg: 'static,
      T: TensorType,
      T: Clone,
      a_values_Arg: Clone,
      a_values_Arg: GraphEdge<T>,
      a_values_Arg: 'static,
      a_shape_Arg: Clone,
      a_shape_Arg: GraphEdge<i64>,
      a_shape_Arg: 'static,
      b_Arg: Clone,
      b_Arg: GraphEdge<T>,
      b_Arg: 'static,
      T: 'static,
      Tindices: con_or_DT_INT32_or_DT_INT64,
      Tindices: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("SparseTensorDenseMatMul_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("SparseTensorDenseMatMul", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.a_indices)?
        }
        {
            new_op.add_edge(&self.a_values)?
        }
        {
            new_op.add_edge(&self.a_shape)?
        }
        {
            new_op.add_edge(&self.b)?
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        {
            new_op.set_attr_type("Tindices", Tindices::data_type())?;
        }
        {
            match self.adjoint_a {
                None => new_op.set_attr_value_proto("adjoint_a", &vec![40_u8, 0_u8,])?,
                Some(ref value) => (|attr: &bool| {new_op.set_attr_bool("adjoint_a", *attr)})(&value)?,
            };
        }
        {
            match self.adjoint_b {
                None => new_op.set_attr_value_proto("adjoint_b", &vec![40_u8, 0_u8,])?,
                Some(ref value) => (|attr: &bool| {new_op.set_attr_bool("adjoint_b", *attr)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct SparseTensorDenseMatMul<Tindices, a_indices_Arg, T, a_values_Arg, a_shape_Arg, b_Arg>
where Tindices: TensorType,
      Tindices: Clone,
      a_indices_Arg: Clone,
      a_indices_Arg: GraphEdge<Tindices>,
      a_indices_Arg: 'static,
      T: TensorType,
      T: Clone,
      a_values_Arg: Clone,
      a_values_Arg: GraphEdge<T>,
      a_values_Arg: 'static,
      a_shape_Arg: Clone,
      a_shape_Arg: GraphEdge<i64>,
      a_shape_Arg: 'static,
      b_Arg: Clone,
      b_Arg: GraphEdge<T>,
      b_Arg: 'static,
      T: 'static,
      Tindices: con_or_DT_INT32_or_DT_INT64,
      Tindices: 'static,
{
    phantom_Tindices: PhantomData<Tindices>,
    a_indices: a_indices_Arg,
    phantom_T: PhantomData<T>,
    a_values: a_values_Arg,
    a_shape: a_shape_Arg,
    b: b_Arg,
    adjoint_a: Option<bool>,
    adjoint_b: Option<bool>,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<Tindices, a_indices_Arg, T, a_values_Arg, a_shape_Arg, b_Arg> SparseTensorDenseMatMul<Tindices, a_indices_Arg, T, a_values_Arg, a_shape_Arg, b_Arg>
where Tindices: TensorType,
      Tindices: Clone,
      a_indices_Arg: Clone,
      a_indices_Arg: GraphEdge<Tindices>,
      a_indices_Arg: 'static,
      T: TensorType,
      T: Clone,
      a_values_Arg: Clone,
      a_values_Arg: GraphEdge<T>,
      a_values_Arg: 'static,
      a_shape_Arg: Clone,
      a_shape_Arg: GraphEdge<i64>,
      a_shape_Arg: 'static,
      b_Arg: Clone,
      b_Arg: GraphEdge<T>,
      b_Arg: 'static,
      T: 'static,
      Tindices: con_or_DT_INT32_or_DT_INT64,
      Tindices: 'static,
{
    pub fn product(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn adjoint_a(&mut self, adjoint_a: bool) -> Self {
        self.adjoint_a = Some(adjoint_a);
        self.clone()
    }

    pub fn adjoint_b(&mut self, adjoint_b: bool) -> Self {
        self.adjoint_b = Some(adjoint_b);
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(a_indices: a_indices_Arg, a_values: a_values_Arg, a_shape: a_shape_Arg, b: b_Arg) -> Self {
        Self {
            phantom_Tindices: PhantomData,
            a_indices,
            phantom_T: PhantomData,
            a_values,
            a_shape,
            b,
            adjoint_a: None,
            adjoint_b: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(a_indices: a_indices_Arg, a_values: a_values_Arg, a_shape: a_shape_Arg, b: b_Arg) -> Edge<T> {
        Self {
            phantom_Tindices: PhantomData,
            a_indices,
            phantom_T: PhantomData,
            a_values,
            a_shape,
            b,
            adjoint_a: None,
            adjoint_b: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<a_indices_Arg, T, a_values_Arg, a_shape_Arg, b_indices_Arg, b_values_Arg, b_shape_Arg, Treal, thresh_Arg> GraphOperation for SparseAdd<a_indices_Arg, T, a_values_Arg, a_shape_Arg, b_indices_Arg, b_values_Arg, b_shape_Arg, Treal, thresh_Arg>
where a_indices_Arg: Clone,
      a_indices_Arg: GraphEdge<i64>,
      a_indices_Arg: 'static,
      T: TensorType,
      T: Clone,
      a_values_Arg: Clone,
      a_values_Arg: GraphEdge<T>,
      a_values_Arg: 'static,
      a_shape_Arg: Clone,
      a_shape_Arg: GraphEdge<i64>,
      a_shape_Arg: 'static,
      b_indices_Arg: Clone,
      b_indices_Arg: GraphEdge<i64>,
      b_indices_Arg: 'static,
      b_values_Arg: Clone,
      b_values_Arg: GraphEdge<T>,
      b_values_Arg: 'static,
      b_shape_Arg: Clone,
      b_shape_Arg: GraphEdge<i64>,
      b_shape_Arg: 'static,
      Treal: TensorType,
      Treal: Clone,
      thresh_Arg: Clone,
      thresh_Arg: GraphEdge<Treal>,
      thresh_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
      Treal: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      Treal: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("SparseAdd_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("SparseAdd", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.a_indices)?
        }
        {
            new_op.add_edge(&self.a_values)?
        }
        {
            new_op.add_edge(&self.a_shape)?
        }
        {
            new_op.add_edge(&self.b_indices)?
        }
        {
            new_op.add_edge(&self.b_values)?
        }
        {
            new_op.add_edge(&self.b_shape)?
        }
        {
            new_op.add_edge(&self.thresh)?
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        {
            new_op.set_attr_type("Treal", Treal::data_type())?;
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct SparseAdd<a_indices_Arg, T, a_values_Arg, a_shape_Arg, b_indices_Arg, b_values_Arg, b_shape_Arg, Treal, thresh_Arg>
where a_indices_Arg: Clone,
      a_indices_Arg: GraphEdge<i64>,
      a_indices_Arg: 'static,
      T: TensorType,
      T: Clone,
      a_values_Arg: Clone,
      a_values_Arg: GraphEdge<T>,
      a_values_Arg: 'static,
      a_shape_Arg: Clone,
      a_shape_Arg: GraphEdge<i64>,
      a_shape_Arg: 'static,
      b_indices_Arg: Clone,
      b_indices_Arg: GraphEdge<i64>,
      b_indices_Arg: 'static,
      b_values_Arg: Clone,
      b_values_Arg: GraphEdge<T>,
      b_values_Arg: 'static,
      b_shape_Arg: Clone,
      b_shape_Arg: GraphEdge<i64>,
      b_shape_Arg: 'static,
      Treal: TensorType,
      Treal: Clone,
      thresh_Arg: Clone,
      thresh_Arg: GraphEdge<Treal>,
      thresh_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
      Treal: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      Treal: 'static,
{
    a_indices: a_indices_Arg,
    phantom_T: PhantomData<T>,
    a_values: a_values_Arg,
    a_shape: a_shape_Arg,
    b_indices: b_indices_Arg,
    b_values: b_values_Arg,
    b_shape: b_shape_Arg,
    phantom_Treal: PhantomData<Treal>,
    thresh: thresh_Arg,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<a_indices_Arg, T, a_values_Arg, a_shape_Arg, b_indices_Arg, b_values_Arg, b_shape_Arg, Treal, thresh_Arg> SparseAdd<a_indices_Arg, T, a_values_Arg, a_shape_Arg, b_indices_Arg, b_values_Arg, b_shape_Arg, Treal, thresh_Arg>
where a_indices_Arg: Clone,
      a_indices_Arg: GraphEdge<i64>,
      a_indices_Arg: 'static,
      T: TensorType,
      T: Clone,
      a_values_Arg: Clone,
      a_values_Arg: GraphEdge<T>,
      a_values_Arg: 'static,
      a_shape_Arg: Clone,
      a_shape_Arg: GraphEdge<i64>,
      a_shape_Arg: 'static,
      b_indices_Arg: Clone,
      b_indices_Arg: GraphEdge<i64>,
      b_indices_Arg: 'static,
      b_values_Arg: Clone,
      b_values_Arg: GraphEdge<T>,
      b_values_Arg: 'static,
      b_shape_Arg: Clone,
      b_shape_Arg: GraphEdge<i64>,
      b_shape_Arg: 'static,
      Treal: TensorType,
      Treal: Clone,
      thresh_Arg: Clone,
      thresh_Arg: GraphEdge<Treal>,
      thresh_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
      Treal: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      Treal: 'static,
{
    pub fn sum_indices(self) -> Edge<i64> {
        let rc = Rc::new(self);
        {
            Edge::<i64>::new(rc.clone(), 0)
        }
    }

    pub fn sum_values(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 1)
        }
    }

    pub fn sum_shape(self) -> Edge<i64> {
        let rc = Rc::new(self);
        {
            Edge::<i64>::new(rc.clone(), 2)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> (Edge<i64>, Edge<T>, Edge<i64>) {
        let rc = Rc::new(self);
        (
        {
            Edge::<i64>::new(rc.clone(), 0)
        },
        {
            Edge::<T>::new(rc.clone(), 1)
        },
        {
            Edge::<i64>::new(rc.clone(), 2)
        },
        )
    }

    pub fn build(a_indices: a_indices_Arg, a_values: a_values_Arg, a_shape: a_shape_Arg, b_indices: b_indices_Arg, b_values: b_values_Arg, b_shape: b_shape_Arg, thresh: thresh_Arg) -> Self {
        Self {
            a_indices,
            phantom_T: PhantomData,
            a_values,
            a_shape,
            b_indices,
            b_values,
            b_shape,
            phantom_Treal: PhantomData,
            thresh,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(a_indices: a_indices_Arg, a_values: a_values_Arg, a_shape: a_shape_Arg, b_indices: b_indices_Arg, b_values: b_values_Arg, b_shape: b_shape_Arg, thresh: thresh_Arg) -> (Edge<i64>, Edge<T>, Edge<i64>) {
        Self {
            a_indices,
            phantom_T: PhantomData,
            a_values,
            a_shape,
            b_indices,
            b_values,
            b_shape,
            phantom_Treal: PhantomData,
            thresh,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<T, backprop_val_grad_Arg, a_indices_Arg, b_indices_Arg, sum_indices_Arg> GraphOperation for SparseAddGrad<T, backprop_val_grad_Arg, a_indices_Arg, b_indices_Arg, sum_indices_Arg>
where T: TensorType,
      T: Clone,
      backprop_val_grad_Arg: Clone,
      backprop_val_grad_Arg: GraphEdge<T>,
      backprop_val_grad_Arg: 'static,
      a_indices_Arg: Clone,
      a_indices_Arg: GraphEdge<i64>,
      a_indices_Arg: 'static,
      b_indices_Arg: Clone,
      b_indices_Arg: GraphEdge<i64>,
      b_indices_Arg: 'static,
      sum_indices_Arg: Clone,
      sum_indices_Arg: GraphEdge<i64>,
      sum_indices_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("SparseAddGrad_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("SparseAddGrad", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.backprop_val_grad)?
        }
        {
            new_op.add_edge(&self.a_indices)?
        }
        {
            new_op.add_edge(&self.b_indices)?
        }
        {
            new_op.add_edge(&self.sum_indices)?
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct SparseAddGrad<T, backprop_val_grad_Arg, a_indices_Arg, b_indices_Arg, sum_indices_Arg>
where T: TensorType,
      T: Clone,
      backprop_val_grad_Arg: Clone,
      backprop_val_grad_Arg: GraphEdge<T>,
      backprop_val_grad_Arg: 'static,
      a_indices_Arg: Clone,
      a_indices_Arg: GraphEdge<i64>,
      a_indices_Arg: 'static,
      b_indices_Arg: Clone,
      b_indices_Arg: GraphEdge<i64>,
      b_indices_Arg: 'static,
      sum_indices_Arg: Clone,
      sum_indices_Arg: GraphEdge<i64>,
      sum_indices_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    backprop_val_grad: backprop_val_grad_Arg,
    a_indices: a_indices_Arg,
    b_indices: b_indices_Arg,
    sum_indices: sum_indices_Arg,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<T, backprop_val_grad_Arg, a_indices_Arg, b_indices_Arg, sum_indices_Arg> SparseAddGrad<T, backprop_val_grad_Arg, a_indices_Arg, b_indices_Arg, sum_indices_Arg>
where T: TensorType,
      T: Clone,
      backprop_val_grad_Arg: Clone,
      backprop_val_grad_Arg: GraphEdge<T>,
      backprop_val_grad_Arg: 'static,
      a_indices_Arg: Clone,
      a_indices_Arg: GraphEdge<i64>,
      a_indices_Arg: 'static,
      b_indices_Arg: Clone,
      b_indices_Arg: GraphEdge<i64>,
      b_indices_Arg: 'static,
      sum_indices_Arg: Clone,
      sum_indices_Arg: GraphEdge<i64>,
      sum_indices_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
{
    pub fn a_val_grad(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn b_val_grad(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 1)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> (Edge<T>, Edge<T>) {
        let rc = Rc::new(self);
        (
        {
            Edge::<T>::new(rc.clone(), 0)
        },
        {
            Edge::<T>::new(rc.clone(), 1)
        },
        )
    }

    pub fn build(backprop_val_grad: backprop_val_grad_Arg, a_indices: a_indices_Arg, b_indices: b_indices_Arg, sum_indices: sum_indices_Arg) -> Self {
        Self {
            phantom_T: PhantomData,
            backprop_val_grad,
            a_indices,
            b_indices,
            sum_indices,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(backprop_val_grad: backprop_val_grad_Arg, a_indices: a_indices_Arg, b_indices: b_indices_Arg, sum_indices: sum_indices_Arg) -> (Edge<T>, Edge<T>) {
        Self {
            phantom_T: PhantomData,
            backprop_val_grad,
            a_indices,
            b_indices,
            sum_indices,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

pub trait con_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_STRING_or_DT_INT64_or_DT_UINT16 {
}

impl con_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_STRING_or_DT_INT64_or_DT_UINT16 for String {
}

impl con_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_STRING_or_DT_INT64_or_DT_UINT16 for i16 {
}

impl con_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_STRING_or_DT_INT64_or_DT_UINT16 for i32 {
}

impl con_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_STRING_or_DT_INT64_or_DT_UINT16 for i64 {
}

impl con_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_STRING_or_DT_INT64_or_DT_UINT16 for i8 {
}

impl con_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_STRING_or_DT_INT64_or_DT_UINT16 for u16 {
}

impl con_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_STRING_or_DT_INT64_or_DT_UINT16 for u8 {
}

impl<set1_indices_Arg, T, set1_values_Arg, set1_shape_Arg, set2_indices_Arg, set2_values_Arg, set2_shape_Arg> GraphOperation for SparseToSparseSetOperation<set1_indices_Arg, T, set1_values_Arg, set1_shape_Arg, set2_indices_Arg, set2_values_Arg, set2_shape_Arg>
where set1_indices_Arg: Clone,
      set1_indices_Arg: GraphEdge<i64>,
      set1_indices_Arg: 'static,
      T: TensorType,
      T: Clone,
      set1_values_Arg: Clone,
      set1_values_Arg: GraphEdge<T>,
      set1_values_Arg: 'static,
      set1_shape_Arg: Clone,
      set1_shape_Arg: GraphEdge<i64>,
      set1_shape_Arg: 'static,
      set2_indices_Arg: Clone,
      set2_indices_Arg: GraphEdge<i64>,
      set2_indices_Arg: 'static,
      set2_values_Arg: Clone,
      set2_values_Arg: GraphEdge<T>,
      set2_values_Arg: 'static,
      set2_shape_Arg: Clone,
      set2_shape_Arg: GraphEdge<i64>,
      set2_shape_Arg: 'static,
      T: con_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_STRING_or_DT_INT64_or_DT_UINT16,
      T: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("SparseToSparseSetOperation_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("SparseToSparseSetOperation", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.set1_indices)?
        }
        {
            new_op.add_edge(&self.set1_values)?
        }
        {
            new_op.add_edge(&self.set1_shape)?
        }
        {
            new_op.add_edge(&self.set2_indices)?
        }
        {
            new_op.add_edge(&self.set2_values)?
        }
        {
            new_op.add_edge(&self.set2_shape)?
        }
        {
            (|attr| {new_op.set_attr_string("set_operation", attr)})(&self.set_operation)?
        }
        {
            match self.validate_indices {
                None => new_op.set_attr_value_proto("validate_indices", &vec![40_u8, 1_u8,])?,
                Some(ref value) => (|attr: &bool| {new_op.set_attr_bool("validate_indices", *attr)})(&value)?,
            };
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct SparseToSparseSetOperation<set1_indices_Arg, T, set1_values_Arg, set1_shape_Arg, set2_indices_Arg, set2_values_Arg, set2_shape_Arg>
where set1_indices_Arg: Clone,
      set1_indices_Arg: GraphEdge<i64>,
      set1_indices_Arg: 'static,
      T: TensorType,
      T: Clone,
      set1_values_Arg: Clone,
      set1_values_Arg: GraphEdge<T>,
      set1_values_Arg: 'static,
      set1_shape_Arg: Clone,
      set1_shape_Arg: GraphEdge<i64>,
      set1_shape_Arg: 'static,
      set2_indices_Arg: Clone,
      set2_indices_Arg: GraphEdge<i64>,
      set2_indices_Arg: 'static,
      set2_values_Arg: Clone,
      set2_values_Arg: GraphEdge<T>,
      set2_values_Arg: 'static,
      set2_shape_Arg: Clone,
      set2_shape_Arg: GraphEdge<i64>,
      set2_shape_Arg: 'static,
      T: con_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_STRING_or_DT_INT64_or_DT_UINT16,
      T: 'static,
{
    set1_indices: set1_indices_Arg,
    phantom_T: PhantomData<T>,
    set1_values: set1_values_Arg,
    set1_shape: set1_shape_Arg,
    set2_indices: set2_indices_Arg,
    set2_values: set2_values_Arg,
    set2_shape: set2_shape_Arg,
    set_operation: String,
    validate_indices: Option<bool>,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<set1_indices_Arg, T, set1_values_Arg, set1_shape_Arg, set2_indices_Arg, set2_values_Arg, set2_shape_Arg> SparseToSparseSetOperation<set1_indices_Arg, T, set1_values_Arg, set1_shape_Arg, set2_indices_Arg, set2_values_Arg, set2_shape_Arg>
where set1_indices_Arg: Clone,
      set1_indices_Arg: GraphEdge<i64>,
      set1_indices_Arg: 'static,
      T: TensorType,
      T: Clone,
      set1_values_Arg: Clone,
      set1_values_Arg: GraphEdge<T>,
      set1_values_Arg: 'static,
      set1_shape_Arg: Clone,
      set1_shape_Arg: GraphEdge<i64>,
      set1_shape_Arg: 'static,
      set2_indices_Arg: Clone,
      set2_indices_Arg: GraphEdge<i64>,
      set2_indices_Arg: 'static,
      set2_values_Arg: Clone,
      set2_values_Arg: GraphEdge<T>,
      set2_values_Arg: 'static,
      set2_shape_Arg: Clone,
      set2_shape_Arg: GraphEdge<i64>,
      set2_shape_Arg: 'static,
      T: con_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_STRING_or_DT_INT64_or_DT_UINT16,
      T: 'static,
{
    pub fn result_indices(self) -> Edge<i64> {
        let rc = Rc::new(self);
        {
            Edge::<i64>::new(rc.clone(), 0)
        }
    }

    pub fn result_values(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 1)
        }
    }

    pub fn result_shape(self) -> Edge<i64> {
        let rc = Rc::new(self);
        {
            Edge::<i64>::new(rc.clone(), 2)
        }
    }

    pub fn validate_indices(&mut self, validate_indices: bool) -> Self {
        self.validate_indices = Some(validate_indices);
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> (Edge<i64>, Edge<T>, Edge<i64>) {
        let rc = Rc::new(self);
        (
        {
            Edge::<i64>::new(rc.clone(), 0)
        },
        {
            Edge::<T>::new(rc.clone(), 1)
        },
        {
            Edge::<i64>::new(rc.clone(), 2)
        },
        )
    }

    pub fn build(set1_indices: set1_indices_Arg, set1_values: set1_values_Arg, set1_shape: set1_shape_Arg, set2_indices: set2_indices_Arg, set2_values: set2_values_Arg, set2_shape: set2_shape_Arg, set_operation: &str) -> Self {
        Self {
            set1_indices,
            phantom_T: PhantomData,
            set1_values,
            set1_shape,
            set2_indices,
            set2_values,
            set2_shape,
            set_operation: set_operation.to_string(),
            validate_indices: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(set1_indices: set1_indices_Arg, set1_values: set1_values_Arg, set1_shape: set1_shape_Arg, set2_indices: set2_indices_Arg, set2_values: set2_values_Arg, set2_shape: set2_shape_Arg, set_operation: &str) -> (Edge<i64>, Edge<T>, Edge<i64>) {
        Self {
            set1_indices,
            phantom_T: PhantomData,
            set1_values,
            set1_shape,
            set2_indices,
            set2_values,
            set2_shape,
            set_operation: set_operation.to_string(),
            validate_indices: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<tensor_type> GraphOperation for _HostRecv<tensor_type>
where tensor_type: TensorType,
      tensor_type: 'static,
      tensor_type: Clone,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("_HostRecv_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("_HostRecv", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.set_attr_type("tensor_type", tensor_type::data_type())?;
        }
        {
            (|attr| {new_op.set_attr_string("tensor_name", attr)})(&self.tensor_name)?
        }
        {
            (|attr| {new_op.set_attr_string("send_device", attr)})(&self.send_device)?
        }
        {
            (|attr: &i64| {new_op.set_attr_int("send_device_incarnation", *attr)})(&self.send_device_incarnation)?
        }
        {
            (|attr| {new_op.set_attr_string("recv_device", attr)})(&self.recv_device)?
        }
        {
            match self.client_terminated {
                None => new_op.set_attr_value_proto("client_terminated", &vec![40_u8, 0_u8,])?,
                Some(ref value) => (|attr: &bool| {new_op.set_attr_bool("client_terminated", *attr)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct _HostRecv<tensor_type>
where tensor_type: TensorType,
      tensor_type: 'static,
      tensor_type: Clone,
{
    phantom_tensor_type: PhantomData<tensor_type>,
    tensor_name: String,
    send_device: String,
    send_device_incarnation: i64,
    recv_device: String,
    client_terminated: Option<bool>,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<tensor_type> _HostRecv<tensor_type>
where tensor_type: TensorType,
      tensor_type: 'static,
      tensor_type: Clone,
{
    pub fn tensor(self) -> Edge<tensor_type> {
        let rc = Rc::new(self);
        {
            Edge::<tensor_type>::new(rc.clone(), 0)
        }
    }

    pub fn client_terminated(&mut self, client_terminated: bool) -> Self {
        self.client_terminated = Some(client_terminated);
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<tensor_type> {
        let rc = Rc::new(self);
        {
            Edge::<tensor_type>::new(rc.clone(), 0)
        }
    }

    pub fn build(tensor_name: &str, send_device: &str, send_device_incarnation: i64, recv_device: &str) -> Self {
        Self {
            phantom_tensor_type: PhantomData,
            tensor_name: tensor_name.to_string(),
            send_device: send_device.to_string(),
            send_device_incarnation: send_device_incarnation,
            recv_device: recv_device.to_string(),
            client_terminated: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(tensor_name: &str, send_device: &str, send_device_incarnation: i64, recv_device: &str) -> Edge<tensor_type> {
        Self {
            phantom_tensor_type: PhantomData,
            tensor_name: tensor_name.to_string(),
            send_device: send_device.to_string(),
            send_device_incarnation: send_device_incarnation,
            recv_device: recv_device.to_string(),
            client_terminated: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<T, tensor_Arg> GraphOperation for _HostSend<T, tensor_Arg>
where T: TensorType,
      T: Clone,
      tensor_Arg: Clone,
      tensor_Arg: GraphEdge<T>,
      tensor_Arg: 'static,
      T: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("_HostSend_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("_HostSend", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.tensor)?
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        {
            (|attr| {new_op.set_attr_string("tensor_name", attr)})(&self.tensor_name)?
        }
        {
            (|attr| {new_op.set_attr_string("send_device", attr)})(&self.send_device)?
        }
        {
            (|attr: &i64| {new_op.set_attr_int("send_device_incarnation", *attr)})(&self.send_device_incarnation)?
        }
        {
            (|attr| {new_op.set_attr_string("recv_device", attr)})(&self.recv_device)?
        }
        {
            match self.client_terminated {
                None => new_op.set_attr_value_proto("client_terminated", &vec![40_u8, 0_u8,])?,
                Some(ref value) => (|attr: &bool| {new_op.set_attr_bool("client_terminated", *attr)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct _HostSend<T, tensor_Arg>
where T: TensorType,
      T: Clone,
      tensor_Arg: Clone,
      tensor_Arg: GraphEdge<T>,
      tensor_Arg: 'static,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    tensor: tensor_Arg,
    tensor_name: String,
    send_device: String,
    send_device_incarnation: i64,
    recv_device: String,
    client_terminated: Option<bool>,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<T, tensor_Arg> _HostSend<T, tensor_Arg>
where T: TensorType,
      T: Clone,
      tensor_Arg: Clone,
      tensor_Arg: GraphEdge<T>,
      tensor_Arg: 'static,
      T: 'static,
{
    pub fn client_terminated(&mut self, client_terminated: bool) -> Self {
        self.client_terminated = Some(client_terminated);
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> () {
        let rc = Rc::new(self);
        (
        )
    }

    pub fn build(tensor: tensor_Arg, tensor_name: &str, send_device: &str, send_device_incarnation: i64, recv_device: &str) -> Self {
        Self {
            phantom_T: PhantomData,
            tensor,
            tensor_name: tensor_name.to_string(),
            send_device: send_device.to_string(),
            send_device_incarnation: send_device_incarnation,
            recv_device: recv_device.to_string(),
            client_terminated: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(tensor: tensor_Arg, tensor_name: &str, send_device: &str, send_device_incarnation: i64, recv_device: &str) -> () {
        Self {
            phantom_T: PhantomData,
            tensor,
            tensor_name: tensor_name.to_string(),
            send_device: send_device.to_string(),
            send_device_incarnation: send_device_incarnation,
            recv_device: recv_device.to_string(),
            client_terminated: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<T, concat_Arg, split_Arg> GraphOperation for _ScopedAllocatorSplit<T, concat_Arg, split_Arg>
where T: TensorType,
      T: Clone,
      concat_Arg: Clone,
      concat_Arg: GraphEdge<T>,
      concat_Arg: 'static,
      split_Arg: Clone,
      split_Arg: GraphEdge<T>,
      split_Arg: 'static,
      T: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("_ScopedAllocatorSplit_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("_ScopedAllocatorSplit", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.concat)?
        }
        {
            new_op.add_edge(&self.split)?
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        {
            (|attr| {new_op.set_attr_string("sa_name", attr)})(&self.sa_name)?
        }
        {
            (|attr: &i64| {new_op.set_attr_int("id", *attr)})(&self.id)?
        }
        {
            (|attr: &i64| {new_op.set_attr_int("N", *attr)})(&self.N)?
        }
        {
            (|attrs| {new_op.set_attr_shape_list("shapes", attrs)})(&self.shapes)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct _ScopedAllocatorSplit<T, concat_Arg, split_Arg>
where T: TensorType,
      T: Clone,
      concat_Arg: Clone,
      concat_Arg: GraphEdge<T>,
      concat_Arg: 'static,
      split_Arg: Clone,
      split_Arg: GraphEdge<T>,
      split_Arg: 'static,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    concat: concat_Arg,
    split: split_Arg,
    sa_name: String,
    id: i64,
    N: i64,
    shapes: Vec<OtherShape>,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<T, concat_Arg, split_Arg> _ScopedAllocatorSplit<T, concat_Arg, split_Arg>
where T: TensorType,
      T: Clone,
      concat_Arg: Clone,
      concat_Arg: GraphEdge<T>,
      concat_Arg: 'static,
      split_Arg: Clone,
      split_Arg: GraphEdge<T>,
      split_Arg: 'static,
      T: 'static,
{
    pub fn output(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(concat: concat_Arg, split: split_Arg, sa_name: &str, id: i64, N: i64, shapes: &[OtherShape]) -> Self {
        Self {
            phantom_T: PhantomData,
            concat,
            split,
            sa_name: sa_name.to_string(),
            id: id,
            N: N,
            shapes: shapes.to_vec(),
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(concat: concat_Arg, split: split_Arg, sa_name: &str, id: i64, N: i64, shapes: &[OtherShape]) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            concat,
            split,
            sa_name: sa_name.to_string(),
            id: id,
            N: N,
            shapes: shapes.to_vec(),
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<T, backing_Arg, inputs_Arg> GraphOperation for _ScopedAllocatorConcat<T, backing_Arg, inputs_Arg>
where T: TensorType,
      T: Clone,
      backing_Arg: Clone,
      backing_Arg: GraphEdge<T>,
      backing_Arg: 'static,
      inputs_Arg: Clone,
      inputs_Arg: GraphEdge<T>,
      inputs_Arg: 'static,
      T: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("_ScopedAllocatorConcat_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("_ScopedAllocatorConcat", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.backing)?
        }
        {
            new_op.add_edge(&self.inputs)?
        }
        {
            (|attr| {new_op.set_attr_shape("shape", attr)})(&self.shape)?
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        {
            match self.reshape {
                None => new_op.set_attr_value_proto("reshape", &vec![40_u8, 0_u8,])?,
                Some(ref value) => (|attr: &bool| {new_op.set_attr_bool("reshape", *attr)})(&value)?,
            };
        }
        {
            (|attr| {new_op.set_attr_string("sa_name", attr)})(&self.sa_name)?
        }
        {
            (|attr: &i64| {new_op.set_attr_int("id", *attr)})(&self.id)?
        }
        {
            (|attr: &i64| {new_op.set_attr_int("N", *attr)})(&self.N)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct _ScopedAllocatorConcat<T, backing_Arg, inputs_Arg>
where T: TensorType,
      T: Clone,
      backing_Arg: Clone,
      backing_Arg: GraphEdge<T>,
      backing_Arg: 'static,
      inputs_Arg: Clone,
      inputs_Arg: GraphEdge<T>,
      inputs_Arg: 'static,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    backing: backing_Arg,
    inputs: inputs_Arg,
    shape: OtherShape,
    reshape: Option<bool>,
    sa_name: String,
    id: i64,
    N: i64,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<T, backing_Arg, inputs_Arg> _ScopedAllocatorConcat<T, backing_Arg, inputs_Arg>
where T: TensorType,
      T: Clone,
      backing_Arg: Clone,
      backing_Arg: GraphEdge<T>,
      backing_Arg: 'static,
      inputs_Arg: Clone,
      inputs_Arg: GraphEdge<T>,
      inputs_Arg: 'static,
      T: 'static,
{
    pub fn output(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn reshape(&mut self, reshape: bool) -> Self {
        self.reshape = Some(reshape);
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(backing: backing_Arg, inputs: inputs_Arg, shape: &OtherShape, sa_name: &str, id: i64, N: i64) -> Self {
        Self {
            phantom_T: PhantomData,
            backing,
            inputs,
            shape: shape.clone(),
            reshape: None,
            sa_name: sa_name.to_string(),
            id: id,
            N: N,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(backing: backing_Arg, inputs: inputs_Arg, shape: &OtherShape, sa_name: &str, id: i64, N: i64) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            backing,
            inputs,
            shape: shape.clone(),
            reshape: None,
            sa_name: sa_name.to_string(),
            id: id,
            N: N,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<T, ref__Arg, value_Arg> GraphOperation for Assign<T, ref__Arg, value_Arg>
where T: TensorType,
      T: Clone,
      ref__Arg: Clone,
      ref__Arg: GraphRefEdge<T>,
      ref__Arg: 'static,
      value_Arg: Clone,
      value_Arg: GraphEdge<T>,
      value_Arg: 'static,
      T: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("Assign_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("Assign", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.ref_)?
        }
        {
            new_op.add_edge(&self.value)?
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        {
            match self.validate_shape {
                None => new_op.set_attr_value_proto("validate_shape", &vec![40_u8, 1_u8,])?,
                Some(ref value) => (|attr: &bool| {new_op.set_attr_bool("validate_shape", *attr)})(&value)?,
            };
        }
        {
            match self.use_locking {
                None => new_op.set_attr_value_proto("use_locking", &vec![40_u8, 1_u8,])?,
                Some(ref value) => (|attr: &bool| {new_op.set_attr_bool("use_locking", *attr)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct Assign<T, ref__Arg, value_Arg>
where T: TensorType,
      T: Clone,
      ref__Arg: Clone,
      ref__Arg: GraphRefEdge<T>,
      ref__Arg: 'static,
      value_Arg: Clone,
      value_Arg: GraphEdge<T>,
      value_Arg: 'static,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    ref_: ref__Arg,
    value: value_Arg,
    validate_shape: Option<bool>,
    use_locking: Option<bool>,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<T, ref__Arg, value_Arg> Assign<T, ref__Arg, value_Arg>
where T: TensorType,
      T: Clone,
      ref__Arg: Clone,
      ref__Arg: GraphRefEdge<T>,
      ref__Arg: 'static,
      value_Arg: Clone,
      value_Arg: GraphEdge<T>,
      value_Arg: 'static,
      T: 'static,
{
    pub fn output_ref(self) -> RefEdge<T> {
        let rc = Rc::new(self);
        {
            RefEdge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn validate_shape(&mut self, validate_shape: bool) -> Self {
        self.validate_shape = Some(validate_shape);
        self.clone()
    }

    pub fn use_locking(&mut self, use_locking: bool) -> Self {
        self.use_locking = Some(use_locking);
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> RefEdge<T> {
        let rc = Rc::new(self);
        {
            RefEdge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(ref_: ref__Arg, value: value_Arg) -> Self {
        Self {
            phantom_T: PhantomData,
            ref_,
            value,
            validate_shape: None,
            use_locking: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(ref_: ref__Arg, value: value_Arg) -> RefEdge<T> {
        Self {
            phantom_T: PhantomData,
            ref_,
            value,
            validate_shape: None,
            use_locking: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<T, value_Arg> GraphOperation for RandomShuffle<T, value_Arg>
where T: TensorType,
      T: Clone,
      value_Arg: Clone,
      value_Arg: GraphEdge<T>,
      value_Arg: 'static,
      T: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("RandomShuffle_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("RandomShuffle", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.value)?
        }
        {
            match self.seed {
                None => new_op.set_attr_value_proto("seed", &vec![24_u8, 0_u8,])?,
                Some(ref value) => (|attr: &i64| {new_op.set_attr_int("seed", *attr)})(&value)?,
            };
        }
        {
            match self.seed2 {
                None => new_op.set_attr_value_proto("seed2", &vec![24_u8, 0_u8,])?,
                Some(ref value) => (|attr: &i64| {new_op.set_attr_int("seed2", *attr)})(&value)?,
            };
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct RandomShuffle<T, value_Arg>
where T: TensorType,
      T: Clone,
      value_Arg: Clone,
      value_Arg: GraphEdge<T>,
      value_Arg: 'static,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    value: value_Arg,
    seed: Option<i64>,
    seed2: Option<i64>,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<T, value_Arg> RandomShuffle<T, value_Arg>
where T: TensorType,
      T: Clone,
      value_Arg: Clone,
      value_Arg: GraphEdge<T>,
      value_Arg: 'static,
      T: 'static,
{
    pub fn output(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn seed(&mut self, seed: i64) -> Self {
        self.seed = Some(seed);
        self.clone()
    }

    pub fn seed2(&mut self, seed2: i64) -> Self {
        self.seed2 = Some(seed2);
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(value: value_Arg) -> Self {
        Self {
            phantom_T: PhantomData,
            value,
            seed: None,
            seed2: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(value: value_Arg) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            value,
            seed: None,
            seed2: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<T, shape_Arg, dtype> GraphOperation for TruncatedNormal<T, shape_Arg, dtype>
where T: TensorType,
      T: Clone,
      shape_Arg: Clone,
      shape_Arg: GraphEdge<T>,
      shape_Arg: 'static,
      dtype: TensorType,
      dtype: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
      dtype: 'static,
      dtype: Clone,
      T: con_or_DT_INT32_or_DT_INT64,
      T: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("TruncatedNormal_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("TruncatedNormal", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.shape)?
        }
        {
            match self.seed {
                None => new_op.set_attr_value_proto("seed", &vec![24_u8, 0_u8,])?,
                Some(ref value) => (|attr: &i64| {new_op.set_attr_int("seed", *attr)})(&value)?,
            };
        }
        {
            match self.seed2 {
                None => new_op.set_attr_value_proto("seed2", &vec![24_u8, 0_u8,])?,
                Some(ref value) => (|attr: &i64| {new_op.set_attr_int("seed2", *attr)})(&value)?,
            };
        }
        {
            new_op.set_attr_type("dtype", dtype::data_type())?;
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct TruncatedNormal<T, shape_Arg, dtype>
where T: TensorType,
      T: Clone,
      shape_Arg: Clone,
      shape_Arg: GraphEdge<T>,
      shape_Arg: 'static,
      dtype: TensorType,
      dtype: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
      dtype: 'static,
      dtype: Clone,
      T: con_or_DT_INT32_or_DT_INT64,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    shape: shape_Arg,
    seed: Option<i64>,
    seed2: Option<i64>,
    phantom_dtype: PhantomData<dtype>,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<T, shape_Arg, dtype> TruncatedNormal<T, shape_Arg, dtype>
where T: TensorType,
      T: Clone,
      shape_Arg: Clone,
      shape_Arg: GraphEdge<T>,
      shape_Arg: 'static,
      dtype: TensorType,
      dtype: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
      dtype: 'static,
      dtype: Clone,
      T: con_or_DT_INT32_or_DT_INT64,
      T: 'static,
{
    pub fn output(self) -> Edge<dtype> {
        let rc = Rc::new(self);
        {
            Edge::<dtype>::new(rc.clone(), 0)
        }
    }

    pub fn seed(&mut self, seed: i64) -> Self {
        self.seed = Some(seed);
        self.clone()
    }

    pub fn seed2(&mut self, seed2: i64) -> Self {
        self.seed2 = Some(seed2);
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<dtype> {
        let rc = Rc::new(self);
        {
            Edge::<dtype>::new(rc.clone(), 0)
        }
    }

    pub fn build(shape: shape_Arg) -> Self {
        Self {
            phantom_T: PhantomData,
            shape,
            seed: None,
            seed2: None,
            phantom_dtype: PhantomData,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(shape: shape_Arg) -> Edge<dtype> {
        Self {
            phantom_T: PhantomData,
            shape,
            seed: None,
            seed2: None,
            phantom_dtype: PhantomData,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<T, shape_Arg, dtype> GraphOperation for RandomStandardNormal<T, shape_Arg, dtype>
where T: TensorType,
      T: Clone,
      shape_Arg: Clone,
      shape_Arg: GraphEdge<T>,
      shape_Arg: 'static,
      dtype: TensorType,
      dtype: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
      dtype: 'static,
      dtype: Clone,
      T: con_or_DT_INT32_or_DT_INT64,
      T: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("RandomStandardNormal_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("RandomStandardNormal", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.shape)?
        }
        {
            match self.seed {
                None => new_op.set_attr_value_proto("seed", &vec![24_u8, 0_u8,])?,
                Some(ref value) => (|attr: &i64| {new_op.set_attr_int("seed", *attr)})(&value)?,
            };
        }
        {
            match self.seed2 {
                None => new_op.set_attr_value_proto("seed2", &vec![24_u8, 0_u8,])?,
                Some(ref value) => (|attr: &i64| {new_op.set_attr_int("seed2", *attr)})(&value)?,
            };
        }
        {
            new_op.set_attr_type("dtype", dtype::data_type())?;
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct RandomStandardNormal<T, shape_Arg, dtype>
where T: TensorType,
      T: Clone,
      shape_Arg: Clone,
      shape_Arg: GraphEdge<T>,
      shape_Arg: 'static,
      dtype: TensorType,
      dtype: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
      dtype: 'static,
      dtype: Clone,
      T: con_or_DT_INT32_or_DT_INT64,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    shape: shape_Arg,
    seed: Option<i64>,
    seed2: Option<i64>,
    phantom_dtype: PhantomData<dtype>,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<T, shape_Arg, dtype> RandomStandardNormal<T, shape_Arg, dtype>
where T: TensorType,
      T: Clone,
      shape_Arg: Clone,
      shape_Arg: GraphEdge<T>,
      shape_Arg: 'static,
      dtype: TensorType,
      dtype: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
      dtype: 'static,
      dtype: Clone,
      T: con_or_DT_INT32_or_DT_INT64,
      T: 'static,
{
    pub fn output(self) -> Edge<dtype> {
        let rc = Rc::new(self);
        {
            Edge::<dtype>::new(rc.clone(), 0)
        }
    }

    pub fn seed(&mut self, seed: i64) -> Self {
        self.seed = Some(seed);
        self.clone()
    }

    pub fn seed2(&mut self, seed2: i64) -> Self {
        self.seed2 = Some(seed2);
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<dtype> {
        let rc = Rc::new(self);
        {
            Edge::<dtype>::new(rc.clone(), 0)
        }
    }

    pub fn build(shape: shape_Arg) -> Self {
        Self {
            phantom_T: PhantomData,
            shape,
            seed: None,
            seed2: None,
            phantom_dtype: PhantomData,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(shape: shape_Arg) -> Edge<dtype> {
        Self {
            phantom_T: PhantomData,
            shape,
            seed: None,
            seed2: None,
            phantom_dtype: PhantomData,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<T, shape_Arg, dtype> GraphOperation for RandomUniform<T, shape_Arg, dtype>
where T: TensorType,
      T: Clone,
      shape_Arg: Clone,
      shape_Arg: GraphEdge<T>,
      shape_Arg: 'static,
      dtype: TensorType,
      dtype: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
      dtype: 'static,
      dtype: Clone,
      T: con_or_DT_INT32_or_DT_INT64,
      T: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("RandomUniform_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("RandomUniform", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.shape)?
        }
        {
            match self.seed {
                None => new_op.set_attr_value_proto("seed", &vec![24_u8, 0_u8,])?,
                Some(ref value) => (|attr: &i64| {new_op.set_attr_int("seed", *attr)})(&value)?,
            };
        }
        {
            match self.seed2 {
                None => new_op.set_attr_value_proto("seed2", &vec![24_u8, 0_u8,])?,
                Some(ref value) => (|attr: &i64| {new_op.set_attr_int("seed2", *attr)})(&value)?,
            };
        }
        {
            new_op.set_attr_type("dtype", dtype::data_type())?;
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct RandomUniform<T, shape_Arg, dtype>
where T: TensorType,
      T: Clone,
      shape_Arg: Clone,
      shape_Arg: GraphEdge<T>,
      shape_Arg: 'static,
      dtype: TensorType,
      dtype: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
      dtype: 'static,
      dtype: Clone,
      T: con_or_DT_INT32_or_DT_INT64,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    shape: shape_Arg,
    seed: Option<i64>,
    seed2: Option<i64>,
    phantom_dtype: PhantomData<dtype>,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<T, shape_Arg, dtype> RandomUniform<T, shape_Arg, dtype>
where T: TensorType,
      T: Clone,
      shape_Arg: Clone,
      shape_Arg: GraphEdge<T>,
      shape_Arg: 'static,
      dtype: TensorType,
      dtype: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
      dtype: 'static,
      dtype: Clone,
      T: con_or_DT_INT32_or_DT_INT64,
      T: 'static,
{
    pub fn output(self) -> Edge<dtype> {
        let rc = Rc::new(self);
        {
            Edge::<dtype>::new(rc.clone(), 0)
        }
    }

    pub fn seed(&mut self, seed: i64) -> Self {
        self.seed = Some(seed);
        self.clone()
    }

    pub fn seed2(&mut self, seed2: i64) -> Self {
        self.seed2 = Some(seed2);
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<dtype> {
        let rc = Rc::new(self);
        {
            Edge::<dtype>::new(rc.clone(), 0)
        }
    }

    pub fn build(shape: shape_Arg) -> Self {
        Self {
            phantom_T: PhantomData,
            shape,
            seed: None,
            seed2: None,
            phantom_dtype: PhantomData,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(shape: shape_Arg) -> Edge<dtype> {
        Self {
            phantom_T: PhantomData,
            shape,
            seed: None,
            seed2: None,
            phantom_dtype: PhantomData,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<rt_nested_splits_Arg, T, rt_dense_values_Arg> GraphOperation for RaggedTensorToSparse<rt_nested_splits_Arg, T, rt_dense_values_Arg>
where rt_nested_splits_Arg: Clone,
      rt_nested_splits_Arg: GraphEdge<i64>,
      rt_nested_splits_Arg: 'static,
      T: TensorType,
      T: Clone,
      rt_dense_values_Arg: Clone,
      rt_dense_values_Arg: GraphEdge<T>,
      rt_dense_values_Arg: 'static,
      T: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("RaggedTensorToSparse_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("RaggedTensorToSparse", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.rt_nested_splits)?
        }
        {
            new_op.add_edge(&self.rt_dense_values)?
        }
        {
            (|attr: &i64| {new_op.set_attr_int("RAGGED_RANK", *attr)})(&self.RAGGED_RANK)?
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct RaggedTensorToSparse<rt_nested_splits_Arg, T, rt_dense_values_Arg>
where rt_nested_splits_Arg: Clone,
      rt_nested_splits_Arg: GraphEdge<i64>,
      rt_nested_splits_Arg: 'static,
      T: TensorType,
      T: Clone,
      rt_dense_values_Arg: Clone,
      rt_dense_values_Arg: GraphEdge<T>,
      rt_dense_values_Arg: 'static,
      T: 'static,
{
    rt_nested_splits: rt_nested_splits_Arg,
    phantom_T: PhantomData<T>,
    rt_dense_values: rt_dense_values_Arg,
    RAGGED_RANK: i64,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<rt_nested_splits_Arg, T, rt_dense_values_Arg> RaggedTensorToSparse<rt_nested_splits_Arg, T, rt_dense_values_Arg>
where rt_nested_splits_Arg: Clone,
      rt_nested_splits_Arg: GraphEdge<i64>,
      rt_nested_splits_Arg: 'static,
      T: TensorType,
      T: Clone,
      rt_dense_values_Arg: Clone,
      rt_dense_values_Arg: GraphEdge<T>,
      rt_dense_values_Arg: 'static,
      T: 'static,
{
    pub fn sparse_indices(self) -> Edge<i64> {
        let rc = Rc::new(self);
        {
            Edge::<i64>::new(rc.clone(), 0)
        }
    }

    pub fn sparse_values(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 1)
        }
    }

    pub fn sparse_dense_shape(self) -> Edge<i64> {
        let rc = Rc::new(self);
        {
            Edge::<i64>::new(rc.clone(), 2)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> (Edge<i64>, Edge<T>, Edge<i64>) {
        let rc = Rc::new(self);
        (
        {
            Edge::<i64>::new(rc.clone(), 0)
        },
        {
            Edge::<T>::new(rc.clone(), 1)
        },
        {
            Edge::<i64>::new(rc.clone(), 2)
        },
        )
    }

    pub fn build(rt_nested_splits: rt_nested_splits_Arg, rt_dense_values: rt_dense_values_Arg, RAGGED_RANK: i64) -> Self {
        Self {
            rt_nested_splits,
            phantom_T: PhantomData,
            rt_dense_values,
            RAGGED_RANK: RAGGED_RANK,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(rt_nested_splits: rt_nested_splits_Arg, rt_dense_values: rt_dense_values_Arg, RAGGED_RANK: i64) -> (Edge<i64>, Edge<T>, Edge<i64>) {
        Self {
            rt_nested_splits,
            phantom_T: PhantomData,
            rt_dense_values,
            RAGGED_RANK: RAGGED_RANK,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<params_nested_splits_Arg, Tvalues, params_dense_values_Arg, Tindices, indices_Arg> GraphOperation for RaggedGather<params_nested_splits_Arg, Tvalues, params_dense_values_Arg, Tindices, indices_Arg>
where params_nested_splits_Arg: Clone,
      params_nested_splits_Arg: GraphEdge<i64>,
      params_nested_splits_Arg: 'static,
      Tvalues: TensorType,
      Tvalues: Clone,
      params_dense_values_Arg: Clone,
      params_dense_values_Arg: GraphEdge<Tvalues>,
      params_dense_values_Arg: 'static,
      Tindices: TensorType,
      Tindices: Clone,
      indices_Arg: Clone,
      indices_Arg: GraphEdge<Tindices>,
      indices_Arg: 'static,
      Tvalues: 'static,
      Tindices: con_or_DT_INT32_or_DT_INT64,
      Tindices: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("RaggedGather_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("RaggedGather", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.params_nested_splits)?
        }
        {
            new_op.add_edge(&self.params_dense_values)?
        }
        {
            new_op.add_edge(&self.indices)?
        }
        {
            new_op.set_attr_type("Tvalues", Tvalues::data_type())?;
        }
        {
            new_op.set_attr_type("Tindices", Tindices::data_type())?;
        }
        {
            (|attr: &i64| {new_op.set_attr_int("PARAMS_RAGGED_RANK", *attr)})(&self.PARAMS_RAGGED_RANK)?
        }
        {
            (|attr: &i64| {new_op.set_attr_int("OUTPUT_RAGGED_RANK", *attr)})(&self.OUTPUT_RAGGED_RANK)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct RaggedGather<params_nested_splits_Arg, Tvalues, params_dense_values_Arg, Tindices, indices_Arg>
where params_nested_splits_Arg: Clone,
      params_nested_splits_Arg: GraphEdge<i64>,
      params_nested_splits_Arg: 'static,
      Tvalues: TensorType,
      Tvalues: Clone,
      params_dense_values_Arg: Clone,
      params_dense_values_Arg: GraphEdge<Tvalues>,
      params_dense_values_Arg: 'static,
      Tindices: TensorType,
      Tindices: Clone,
      indices_Arg: Clone,
      indices_Arg: GraphEdge<Tindices>,
      indices_Arg: 'static,
      Tvalues: 'static,
      Tindices: con_or_DT_INT32_or_DT_INT64,
      Tindices: 'static,
{
    params_nested_splits: params_nested_splits_Arg,
    phantom_Tvalues: PhantomData<Tvalues>,
    params_dense_values: params_dense_values_Arg,
    phantom_Tindices: PhantomData<Tindices>,
    indices: indices_Arg,
    PARAMS_RAGGED_RANK: i64,
    OUTPUT_RAGGED_RANK: i64,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<params_nested_splits_Arg, Tvalues, params_dense_values_Arg, Tindices, indices_Arg> RaggedGather<params_nested_splits_Arg, Tvalues, params_dense_values_Arg, Tindices, indices_Arg>
where params_nested_splits_Arg: Clone,
      params_nested_splits_Arg: GraphEdge<i64>,
      params_nested_splits_Arg: 'static,
      Tvalues: TensorType,
      Tvalues: Clone,
      params_dense_values_Arg: Clone,
      params_dense_values_Arg: GraphEdge<Tvalues>,
      params_dense_values_Arg: 'static,
      Tindices: TensorType,
      Tindices: Clone,
      indices_Arg: Clone,
      indices_Arg: GraphEdge<Tindices>,
      indices_Arg: 'static,
      Tvalues: 'static,
      Tindices: con_or_DT_INT32_or_DT_INT64,
      Tindices: 'static,
{
    pub fn output_nested_splits(self) -> Edge<i64> {
        let rc = Rc::new(self);
        {
            Edge::<i64>::new(rc.clone(), 0)
        }
    }

    pub fn output_dense_values(self) -> Edge<Tvalues> {
        let rc = Rc::new(self);
        {
            Edge::<Tvalues>::new(rc.clone(), 1)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> (Edge<i64>, Edge<Tvalues>) {
        let rc = Rc::new(self);
        (
        {
            Edge::<i64>::new(rc.clone(), 0)
        },
        {
            Edge::<Tvalues>::new(rc.clone(), 1)
        },
        )
    }

    pub fn build(params_nested_splits: params_nested_splits_Arg, params_dense_values: params_dense_values_Arg, indices: indices_Arg, PARAMS_RAGGED_RANK: i64, OUTPUT_RAGGED_RANK: i64) -> Self {
        Self {
            params_nested_splits,
            phantom_Tvalues: PhantomData,
            params_dense_values,
            phantom_Tindices: PhantomData,
            indices,
            PARAMS_RAGGED_RANK: PARAMS_RAGGED_RANK,
            OUTPUT_RAGGED_RANK: OUTPUT_RAGGED_RANK,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(params_nested_splits: params_nested_splits_Arg, params_dense_values: params_dense_values_Arg, indices: indices_Arg, PARAMS_RAGGED_RANK: i64, OUTPUT_RAGGED_RANK: i64) -> (Edge<i64>, Edge<Tvalues>) {
        Self {
            params_nested_splits,
            phantom_Tvalues: PhantomData,
            params_dense_values,
            phantom_Tindices: PhantomData,
            indices,
            PARAMS_RAGGED_RANK: PARAMS_RAGGED_RANK,
            OUTPUT_RAGGED_RANK: OUTPUT_RAGGED_RANK,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

pub trait con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_INT64 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_INT64 for f32 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_INT64 for f64 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_INT64 for i32 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_INT64 for i64 {
}

impl<string_tensor_Arg, out_type> GraphOperation for StringToNumber<string_tensor_Arg, out_type>
where string_tensor_Arg: Clone,
      string_tensor_Arg: GraphEdge<String>,
      string_tensor_Arg: 'static,
      out_type: TensorType,
      out_type: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_INT64,
      out_type: 'static,
      out_type: Clone,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("StringToNumber_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("StringToNumber", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.string_tensor)?
        }
        {
            new_op.set_attr_type("out_type", out_type::data_type())?;
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct StringToNumber<string_tensor_Arg, out_type>
where string_tensor_Arg: Clone,
      string_tensor_Arg: GraphEdge<String>,
      string_tensor_Arg: 'static,
      out_type: TensorType,
      out_type: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_INT64,
      out_type: 'static,
      out_type: Clone,
{
    string_tensor: string_tensor_Arg,
    phantom_out_type: PhantomData<out_type>,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<string_tensor_Arg, out_type> StringToNumber<string_tensor_Arg, out_type>
where string_tensor_Arg: Clone,
      string_tensor_Arg: GraphEdge<String>,
      string_tensor_Arg: 'static,
      out_type: TensorType,
      out_type: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_INT64,
      out_type: 'static,
      out_type: Clone,
{
    pub fn output(self) -> Edge<out_type> {
        let rc = Rc::new(self);
        {
            Edge::<out_type>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<out_type> {
        let rc = Rc::new(self);
        {
            Edge::<out_type>::new(rc.clone(), 0)
        }
    }

    pub fn build(string_tensor: string_tensor_Arg) -> Self {
        Self {
            string_tensor,
            phantom_out_type: PhantomData,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(string_tensor: string_tensor_Arg) -> Edge<out_type> {
        Self {
            string_tensor,
            phantom_out_type: PhantomData,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<json_examples_Arg> GraphOperation for DecodeJSONExample<json_examples_Arg>
where json_examples_Arg: Clone,
      json_examples_Arg: GraphEdge<String>,
      json_examples_Arg: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("DecodeJSONExample_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("DecodeJSONExample", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.json_examples)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct DecodeJSONExample<json_examples_Arg>
where json_examples_Arg: Clone,
      json_examples_Arg: GraphEdge<String>,
      json_examples_Arg: 'static,
{
    json_examples: json_examples_Arg,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<json_examples_Arg> DecodeJSONExample<json_examples_Arg>
where json_examples_Arg: Clone,
      json_examples_Arg: GraphEdge<String>,
      json_examples_Arg: 'static,
{
    pub fn binary_examples(self) -> Edge<String> {
        let rc = Rc::new(self);
        {
            Edge::<String>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<String> {
        let rc = Rc::new(self);
        {
            Edge::<String>::new(rc.clone(), 0)
        }
    }

    pub fn build(json_examples: json_examples_Arg) -> Self {
        Self {
            json_examples,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(json_examples: json_examples_Arg) -> Edge<String> {
        Self {
            json_examples,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

pub trait con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_UINT16_or_DT_HALF {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_UINT16_or_DT_HALF for f32 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_UINT16_or_DT_HALF for f64 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_UINT16_or_DT_HALF for i16 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_UINT16_or_DT_HALF for i32 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_UINT16_or_DT_HALF for i64 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_UINT16_or_DT_HALF for i8 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_UINT16_or_DT_HALF for u16 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_UINT16_or_DT_HALF for u8 {
}

impl<bytes_Arg, out_type> GraphOperation for DecodeRaw<bytes_Arg, out_type>
where bytes_Arg: Clone,
      bytes_Arg: GraphEdge<String>,
      bytes_Arg: 'static,
      out_type: TensorType,
      out_type: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_UINT16_or_DT_HALF,
      out_type: 'static,
      out_type: Clone,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("DecodeRaw_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("DecodeRaw", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.bytes)?
        }
        {
            new_op.set_attr_type("out_type", out_type::data_type())?;
        }
        {
            match self.little_endian {
                None => new_op.set_attr_value_proto("little_endian", &vec![40_u8, 1_u8,])?,
                Some(ref value) => (|attr: &bool| {new_op.set_attr_bool("little_endian", *attr)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct DecodeRaw<bytes_Arg, out_type>
where bytes_Arg: Clone,
      bytes_Arg: GraphEdge<String>,
      bytes_Arg: 'static,
      out_type: TensorType,
      out_type: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_UINT16_or_DT_HALF,
      out_type: 'static,
      out_type: Clone,
{
    bytes: bytes_Arg,
    phantom_out_type: PhantomData<out_type>,
    little_endian: Option<bool>,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<bytes_Arg, out_type> DecodeRaw<bytes_Arg, out_type>
where bytes_Arg: Clone,
      bytes_Arg: GraphEdge<String>,
      bytes_Arg: 'static,
      out_type: TensorType,
      out_type: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_UINT16_or_DT_HALF,
      out_type: 'static,
      out_type: Clone,
{
    pub fn output(self) -> Edge<out_type> {
        let rc = Rc::new(self);
        {
            Edge::<out_type>::new(rc.clone(), 0)
        }
    }

    pub fn little_endian(&mut self, little_endian: bool) -> Self {
        self.little_endian = Some(little_endian);
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<out_type> {
        let rc = Rc::new(self);
        {
            Edge::<out_type>::new(rc.clone(), 0)
        }
    }

    pub fn build(bytes: bytes_Arg) -> Self {
        Self {
            bytes,
            phantom_out_type: PhantomData,
            little_endian: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(bytes: bytes_Arg) -> Edge<out_type> {
        Self {
            bytes,
            phantom_out_type: PhantomData,
            little_endian: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

pub trait con_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_QINT16_or_DT_QUINT16 {
}

impl con_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_QINT16_or_DT_QUINT16 for i16 {
}

impl con_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_QINT16_or_DT_QUINT16 for i32 {
}

impl con_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_QINT16_or_DT_QUINT16 for i8 {
}

impl con_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_QINT16_or_DT_QUINT16 for u16 {
}

impl con_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_QINT16_or_DT_QUINT16 for u8 {
}

impl<Tinput, t_Arg, t_min_Arg, t_max_Arg, m_Arg, m_min_Arg, m_max_Arg, v_Arg, v_min_Arg, v_max_Arg, beta_Arg, beta_min_Arg, beta_max_Arg, gamma_Arg, gamma_min_Arg, gamma_max_Arg, out_type> GraphOperation for QuantizedBatchNormWithGlobalNormalization<Tinput, t_Arg, t_min_Arg, t_max_Arg, m_Arg, m_min_Arg, m_max_Arg, v_Arg, v_min_Arg, v_max_Arg, beta_Arg, beta_min_Arg, beta_max_Arg, gamma_Arg, gamma_min_Arg, gamma_max_Arg, out_type>
where Tinput: TensorType,
      Tinput: Clone,
      t_Arg: Clone,
      t_Arg: GraphEdge<Tinput>,
      t_Arg: 'static,
      t_min_Arg: Clone,
      t_min_Arg: GraphEdge<f32>,
      t_min_Arg: 'static,
      t_max_Arg: Clone,
      t_max_Arg: GraphEdge<f32>,
      t_max_Arg: 'static,
      m_Arg: Clone,
      m_Arg: GraphEdge<Tinput>,
      m_Arg: 'static,
      m_min_Arg: Clone,
      m_min_Arg: GraphEdge<f32>,
      m_min_Arg: 'static,
      m_max_Arg: Clone,
      m_max_Arg: GraphEdge<f32>,
      m_max_Arg: 'static,
      v_Arg: Clone,
      v_Arg: GraphEdge<Tinput>,
      v_Arg: 'static,
      v_min_Arg: Clone,
      v_min_Arg: GraphEdge<f32>,
      v_min_Arg: 'static,
      v_max_Arg: Clone,
      v_max_Arg: GraphEdge<f32>,
      v_max_Arg: 'static,
      beta_Arg: Clone,
      beta_Arg: GraphEdge<Tinput>,
      beta_Arg: 'static,
      beta_min_Arg: Clone,
      beta_min_Arg: GraphEdge<f32>,
      beta_min_Arg: 'static,
      beta_max_Arg: Clone,
      beta_max_Arg: GraphEdge<f32>,
      beta_max_Arg: 'static,
      gamma_Arg: Clone,
      gamma_Arg: GraphEdge<Tinput>,
      gamma_Arg: 'static,
      gamma_min_Arg: Clone,
      gamma_min_Arg: GraphEdge<f32>,
      gamma_min_Arg: 'static,
      gamma_max_Arg: Clone,
      gamma_max_Arg: GraphEdge<f32>,
      gamma_max_Arg: 'static,
      out_type: TensorType,
      Tinput: con_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_QINT16_or_DT_QUINT16,
      Tinput: 'static,
      out_type: con_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_QINT16_or_DT_QUINT16,
      out_type: 'static,
      out_type: Clone,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("QuantizedBatchNormWithGlobalNormalization_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("QuantizedBatchNormWithGlobalNormalization", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.t)?
        }
        {
            new_op.add_edge(&self.t_min)?
        }
        {
            new_op.add_edge(&self.t_max)?
        }
        {
            new_op.add_edge(&self.m)?
        }
        {
            new_op.add_edge(&self.m_min)?
        }
        {
            new_op.add_edge(&self.m_max)?
        }
        {
            new_op.add_edge(&self.v)?
        }
        {
            new_op.add_edge(&self.v_min)?
        }
        {
            new_op.add_edge(&self.v_max)?
        }
        {
            new_op.add_edge(&self.beta)?
        }
        {
            new_op.add_edge(&self.beta_min)?
        }
        {
            new_op.add_edge(&self.beta_max)?
        }
        {
            new_op.add_edge(&self.gamma)?
        }
        {
            new_op.add_edge(&self.gamma_min)?
        }
        {
            new_op.add_edge(&self.gamma_max)?
        }
        {
            new_op.set_attr_type("Tinput", Tinput::data_type())?;
        }
        {
            new_op.set_attr_type("out_type", out_type::data_type())?;
        }
        {
            (|attr: &f32| {new_op.set_attr_float("variance_epsilon", *attr)})(&self.variance_epsilon)?
        }
        {
            (|attr: &bool| {new_op.set_attr_bool("scale_after_normalization", *attr)})(&self.scale_after_normalization)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct QuantizedBatchNormWithGlobalNormalization<Tinput, t_Arg, t_min_Arg, t_max_Arg, m_Arg, m_min_Arg, m_max_Arg, v_Arg, v_min_Arg, v_max_Arg, beta_Arg, beta_min_Arg, beta_max_Arg, gamma_Arg, gamma_min_Arg, gamma_max_Arg, out_type>
where Tinput: TensorType,
      Tinput: Clone,
      t_Arg: Clone,
      t_Arg: GraphEdge<Tinput>,
      t_Arg: 'static,
      t_min_Arg: Clone,
      t_min_Arg: GraphEdge<f32>,
      t_min_Arg: 'static,
      t_max_Arg: Clone,
      t_max_Arg: GraphEdge<f32>,
      t_max_Arg: 'static,
      m_Arg: Clone,
      m_Arg: GraphEdge<Tinput>,
      m_Arg: 'static,
      m_min_Arg: Clone,
      m_min_Arg: GraphEdge<f32>,
      m_min_Arg: 'static,
      m_max_Arg: Clone,
      m_max_Arg: GraphEdge<f32>,
      m_max_Arg: 'static,
      v_Arg: Clone,
      v_Arg: GraphEdge<Tinput>,
      v_Arg: 'static,
      v_min_Arg: Clone,
      v_min_Arg: GraphEdge<f32>,
      v_min_Arg: 'static,
      v_max_Arg: Clone,
      v_max_Arg: GraphEdge<f32>,
      v_max_Arg: 'static,
      beta_Arg: Clone,
      beta_Arg: GraphEdge<Tinput>,
      beta_Arg: 'static,
      beta_min_Arg: Clone,
      beta_min_Arg: GraphEdge<f32>,
      beta_min_Arg: 'static,
      beta_max_Arg: Clone,
      beta_max_Arg: GraphEdge<f32>,
      beta_max_Arg: 'static,
      gamma_Arg: Clone,
      gamma_Arg: GraphEdge<Tinput>,
      gamma_Arg: 'static,
      gamma_min_Arg: Clone,
      gamma_min_Arg: GraphEdge<f32>,
      gamma_min_Arg: 'static,
      gamma_max_Arg: Clone,
      gamma_max_Arg: GraphEdge<f32>,
      gamma_max_Arg: 'static,
      out_type: TensorType,
      Tinput: con_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_QINT16_or_DT_QUINT16,
      Tinput: 'static,
      out_type: con_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_QINT16_or_DT_QUINT16,
      out_type: 'static,
      out_type: Clone,
{
    phantom_Tinput: PhantomData<Tinput>,
    t: t_Arg,
    t_min: t_min_Arg,
    t_max: t_max_Arg,
    m: m_Arg,
    m_min: m_min_Arg,
    m_max: m_max_Arg,
    v: v_Arg,
    v_min: v_min_Arg,
    v_max: v_max_Arg,
    beta: beta_Arg,
    beta_min: beta_min_Arg,
    beta_max: beta_max_Arg,
    gamma: gamma_Arg,
    gamma_min: gamma_min_Arg,
    gamma_max: gamma_max_Arg,
    phantom_out_type: PhantomData<out_type>,
    variance_epsilon: f32,
    scale_after_normalization: bool,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<Tinput, t_Arg, t_min_Arg, t_max_Arg, m_Arg, m_min_Arg, m_max_Arg, v_Arg, v_min_Arg, v_max_Arg, beta_Arg, beta_min_Arg, beta_max_Arg, gamma_Arg, gamma_min_Arg, gamma_max_Arg, out_type> QuantizedBatchNormWithGlobalNormalization<Tinput, t_Arg, t_min_Arg, t_max_Arg, m_Arg, m_min_Arg, m_max_Arg, v_Arg, v_min_Arg, v_max_Arg, beta_Arg, beta_min_Arg, beta_max_Arg, gamma_Arg, gamma_min_Arg, gamma_max_Arg, out_type>
where Tinput: TensorType,
      Tinput: Clone,
      t_Arg: Clone,
      t_Arg: GraphEdge<Tinput>,
      t_Arg: 'static,
      t_min_Arg: Clone,
      t_min_Arg: GraphEdge<f32>,
      t_min_Arg: 'static,
      t_max_Arg: Clone,
      t_max_Arg: GraphEdge<f32>,
      t_max_Arg: 'static,
      m_Arg: Clone,
      m_Arg: GraphEdge<Tinput>,
      m_Arg: 'static,
      m_min_Arg: Clone,
      m_min_Arg: GraphEdge<f32>,
      m_min_Arg: 'static,
      m_max_Arg: Clone,
      m_max_Arg: GraphEdge<f32>,
      m_max_Arg: 'static,
      v_Arg: Clone,
      v_Arg: GraphEdge<Tinput>,
      v_Arg: 'static,
      v_min_Arg: Clone,
      v_min_Arg: GraphEdge<f32>,
      v_min_Arg: 'static,
      v_max_Arg: Clone,
      v_max_Arg: GraphEdge<f32>,
      v_max_Arg: 'static,
      beta_Arg: Clone,
      beta_Arg: GraphEdge<Tinput>,
      beta_Arg: 'static,
      beta_min_Arg: Clone,
      beta_min_Arg: GraphEdge<f32>,
      beta_min_Arg: 'static,
      beta_max_Arg: Clone,
      beta_max_Arg: GraphEdge<f32>,
      beta_max_Arg: 'static,
      gamma_Arg: Clone,
      gamma_Arg: GraphEdge<Tinput>,
      gamma_Arg: 'static,
      gamma_min_Arg: Clone,
      gamma_min_Arg: GraphEdge<f32>,
      gamma_min_Arg: 'static,
      gamma_max_Arg: Clone,
      gamma_max_Arg: GraphEdge<f32>,
      gamma_max_Arg: 'static,
      out_type: TensorType,
      Tinput: con_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_QINT16_or_DT_QUINT16,
      Tinput: 'static,
      out_type: con_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_QINT16_or_DT_QUINT16,
      out_type: 'static,
      out_type: Clone,
{
    pub fn result(self) -> Edge<out_type> {
        let rc = Rc::new(self);
        {
            Edge::<out_type>::new(rc.clone(), 0)
        }
    }

    pub fn result_min(self) -> Edge<f32> {
        let rc = Rc::new(self);
        {
            Edge::<f32>::new(rc.clone(), 1)
        }
    }

    pub fn result_max(self) -> Edge<f32> {
        let rc = Rc::new(self);
        {
            Edge::<f32>::new(rc.clone(), 2)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> (Edge<out_type>, Edge<f32>, Edge<f32>) {
        let rc = Rc::new(self);
        (
        {
            Edge::<out_type>::new(rc.clone(), 0)
        },
        {
            Edge::<f32>::new(rc.clone(), 1)
        },
        {
            Edge::<f32>::new(rc.clone(), 2)
        },
        )
    }

    pub fn build(t: t_Arg, t_min: t_min_Arg, t_max: t_max_Arg, m: m_Arg, m_min: m_min_Arg, m_max: m_max_Arg, v: v_Arg, v_min: v_min_Arg, v_max: v_max_Arg, beta: beta_Arg, beta_min: beta_min_Arg, beta_max: beta_max_Arg, gamma: gamma_Arg, gamma_min: gamma_min_Arg, gamma_max: gamma_max_Arg, variance_epsilon: f32, scale_after_normalization: bool) -> Self {
        Self {
            phantom_Tinput: PhantomData,
            t,
            t_min,
            t_max,
            m,
            m_min,
            m_max,
            v,
            v_min,
            v_max,
            beta,
            beta_min,
            beta_max,
            gamma,
            gamma_min,
            gamma_max,
            phantom_out_type: PhantomData,
            variance_epsilon: variance_epsilon,
            scale_after_normalization: scale_after_normalization,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(t: t_Arg, t_min: t_min_Arg, t_max: t_max_Arg, m: m_Arg, m_min: m_min_Arg, m_max: m_max_Arg, v: v_Arg, v_min: v_min_Arg, v_max: v_max_Arg, beta: beta_Arg, beta_min: beta_min_Arg, beta_max: beta_max_Arg, gamma: gamma_Arg, gamma_min: gamma_min_Arg, gamma_max: gamma_max_Arg, variance_epsilon: f32, scale_after_normalization: bool) -> (Edge<out_type>, Edge<f32>, Edge<f32>) {
        Self {
            phantom_Tinput: PhantomData,
            t,
            t_min,
            t_max,
            m,
            m_min,
            m_max,
            v,
            v_min,
            v_max,
            beta,
            beta_min,
            beta_max,
            gamma,
            gamma_min,
            gamma_max,
            phantom_out_type: PhantomData,
            variance_epsilon: variance_epsilon,
            scale_after_normalization: scale_after_normalization,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<Tinput, features_Arg, min_features_Arg, max_features_Arg, out_type> GraphOperation for QuantizedRelu6<Tinput, features_Arg, min_features_Arg, max_features_Arg, out_type>
where Tinput: TensorType,
      Tinput: Clone,
      features_Arg: Clone,
      features_Arg: GraphEdge<Tinput>,
      features_Arg: 'static,
      min_features_Arg: Clone,
      min_features_Arg: GraphEdge<f32>,
      min_features_Arg: 'static,
      max_features_Arg: Clone,
      max_features_Arg: GraphEdge<f32>,
      max_features_Arg: 'static,
      out_type: TensorType,
      Tinput: con_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_QINT16_or_DT_QUINT16,
      Tinput: 'static,
      out_type: con_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_QINT16_or_DT_QUINT16,
      out_type: 'static,
      out_type: Clone,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("QuantizedRelu6_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("QuantizedRelu6", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.features)?
        }
        {
            new_op.add_edge(&self.min_features)?
        }
        {
            new_op.add_edge(&self.max_features)?
        }
        {
            new_op.set_attr_type("Tinput", Tinput::data_type())?;
        }
        {
            new_op.set_attr_type("out_type", out_type::data_type())?;
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct QuantizedRelu6<Tinput, features_Arg, min_features_Arg, max_features_Arg, out_type>
where Tinput: TensorType,
      Tinput: Clone,
      features_Arg: Clone,
      features_Arg: GraphEdge<Tinput>,
      features_Arg: 'static,
      min_features_Arg: Clone,
      min_features_Arg: GraphEdge<f32>,
      min_features_Arg: 'static,
      max_features_Arg: Clone,
      max_features_Arg: GraphEdge<f32>,
      max_features_Arg: 'static,
      out_type: TensorType,
      Tinput: con_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_QINT16_or_DT_QUINT16,
      Tinput: 'static,
      out_type: con_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_QINT16_or_DT_QUINT16,
      out_type: 'static,
      out_type: Clone,
{
    phantom_Tinput: PhantomData<Tinput>,
    features: features_Arg,
    min_features: min_features_Arg,
    max_features: max_features_Arg,
    phantom_out_type: PhantomData<out_type>,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<Tinput, features_Arg, min_features_Arg, max_features_Arg, out_type> QuantizedRelu6<Tinput, features_Arg, min_features_Arg, max_features_Arg, out_type>
where Tinput: TensorType,
      Tinput: Clone,
      features_Arg: Clone,
      features_Arg: GraphEdge<Tinput>,
      features_Arg: 'static,
      min_features_Arg: Clone,
      min_features_Arg: GraphEdge<f32>,
      min_features_Arg: 'static,
      max_features_Arg: Clone,
      max_features_Arg: GraphEdge<f32>,
      max_features_Arg: 'static,
      out_type: TensorType,
      Tinput: con_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_QINT16_or_DT_QUINT16,
      Tinput: 'static,
      out_type: con_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_QINT16_or_DT_QUINT16,
      out_type: 'static,
      out_type: Clone,
{
    pub fn activations(self) -> Edge<out_type> {
        let rc = Rc::new(self);
        {
            Edge::<out_type>::new(rc.clone(), 0)
        }
    }

    pub fn min_activations(self) -> Edge<f32> {
        let rc = Rc::new(self);
        {
            Edge::<f32>::new(rc.clone(), 1)
        }
    }

    pub fn max_activations(self) -> Edge<f32> {
        let rc = Rc::new(self);
        {
            Edge::<f32>::new(rc.clone(), 2)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> (Edge<out_type>, Edge<f32>, Edge<f32>) {
        let rc = Rc::new(self);
        (
        {
            Edge::<out_type>::new(rc.clone(), 0)
        },
        {
            Edge::<f32>::new(rc.clone(), 1)
        },
        {
            Edge::<f32>::new(rc.clone(), 2)
        },
        )
    }

    pub fn build(features: features_Arg, min_features: min_features_Arg, max_features: max_features_Arg) -> Self {
        Self {
            phantom_Tinput: PhantomData,
            features,
            min_features,
            max_features,
            phantom_out_type: PhantomData,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(features: features_Arg, min_features: min_features_Arg, max_features: max_features_Arg) -> (Edge<out_type>, Edge<f32>, Edge<f32>) {
        Self {
            phantom_Tinput: PhantomData,
            features,
            min_features,
            max_features,
            phantom_out_type: PhantomData,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<Tinput, features_Arg, min_features_Arg, max_features_Arg, out_type> GraphOperation for QuantizedRelu<Tinput, features_Arg, min_features_Arg, max_features_Arg, out_type>
where Tinput: TensorType,
      Tinput: Clone,
      features_Arg: Clone,
      features_Arg: GraphEdge<Tinput>,
      features_Arg: 'static,
      min_features_Arg: Clone,
      min_features_Arg: GraphEdge<f32>,
      min_features_Arg: 'static,
      max_features_Arg: Clone,
      max_features_Arg: GraphEdge<f32>,
      max_features_Arg: 'static,
      out_type: TensorType,
      Tinput: con_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_QINT16_or_DT_QUINT16,
      Tinput: 'static,
      out_type: con_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_QINT16_or_DT_QUINT16,
      out_type: 'static,
      out_type: Clone,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("QuantizedRelu_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("QuantizedRelu", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.features)?
        }
        {
            new_op.add_edge(&self.min_features)?
        }
        {
            new_op.add_edge(&self.max_features)?
        }
        {
            new_op.set_attr_type("Tinput", Tinput::data_type())?;
        }
        {
            new_op.set_attr_type("out_type", out_type::data_type())?;
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct QuantizedRelu<Tinput, features_Arg, min_features_Arg, max_features_Arg, out_type>
where Tinput: TensorType,
      Tinput: Clone,
      features_Arg: Clone,
      features_Arg: GraphEdge<Tinput>,
      features_Arg: 'static,
      min_features_Arg: Clone,
      min_features_Arg: GraphEdge<f32>,
      min_features_Arg: 'static,
      max_features_Arg: Clone,
      max_features_Arg: GraphEdge<f32>,
      max_features_Arg: 'static,
      out_type: TensorType,
      Tinput: con_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_QINT16_or_DT_QUINT16,
      Tinput: 'static,
      out_type: con_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_QINT16_or_DT_QUINT16,
      out_type: 'static,
      out_type: Clone,
{
    phantom_Tinput: PhantomData<Tinput>,
    features: features_Arg,
    min_features: min_features_Arg,
    max_features: max_features_Arg,
    phantom_out_type: PhantomData<out_type>,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<Tinput, features_Arg, min_features_Arg, max_features_Arg, out_type> QuantizedRelu<Tinput, features_Arg, min_features_Arg, max_features_Arg, out_type>
where Tinput: TensorType,
      Tinput: Clone,
      features_Arg: Clone,
      features_Arg: GraphEdge<Tinput>,
      features_Arg: 'static,
      min_features_Arg: Clone,
      min_features_Arg: GraphEdge<f32>,
      min_features_Arg: 'static,
      max_features_Arg: Clone,
      max_features_Arg: GraphEdge<f32>,
      max_features_Arg: 'static,
      out_type: TensorType,
      Tinput: con_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_QINT16_or_DT_QUINT16,
      Tinput: 'static,
      out_type: con_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_QINT16_or_DT_QUINT16,
      out_type: 'static,
      out_type: Clone,
{
    pub fn activations(self) -> Edge<out_type> {
        let rc = Rc::new(self);
        {
            Edge::<out_type>::new(rc.clone(), 0)
        }
    }

    pub fn min_activations(self) -> Edge<f32> {
        let rc = Rc::new(self);
        {
            Edge::<f32>::new(rc.clone(), 1)
        }
    }

    pub fn max_activations(self) -> Edge<f32> {
        let rc = Rc::new(self);
        {
            Edge::<f32>::new(rc.clone(), 2)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> (Edge<out_type>, Edge<f32>, Edge<f32>) {
        let rc = Rc::new(self);
        (
        {
            Edge::<out_type>::new(rc.clone(), 0)
        },
        {
            Edge::<f32>::new(rc.clone(), 1)
        },
        {
            Edge::<f32>::new(rc.clone(), 2)
        },
        )
    }

    pub fn build(features: features_Arg, min_features: min_features_Arg, max_features: max_features_Arg) -> Self {
        Self {
            phantom_Tinput: PhantomData,
            features,
            min_features,
            max_features,
            phantom_out_type: PhantomData,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(features: features_Arg, min_features: min_features_Arg, max_features: max_features_Arg) -> (Edge<out_type>, Edge<f32>, Edge<f32>) {
        Self {
            phantom_Tinput: PhantomData,
            features,
            min_features,
            max_features,
            phantom_out_type: PhantomData,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<T, ref__Arg, Tindices, indices_Arg, updates_Arg> GraphOperation for ScatterUpdate<T, ref__Arg, Tindices, indices_Arg, updates_Arg>
where T: TensorType,
      T: Clone,
      ref__Arg: Clone,
      ref__Arg: GraphRefEdge<T>,
      ref__Arg: 'static,
      Tindices: TensorType,
      Tindices: Clone,
      indices_Arg: Clone,
      indices_Arg: GraphEdge<Tindices>,
      indices_Arg: 'static,
      updates_Arg: Clone,
      updates_Arg: GraphEdge<T>,
      updates_Arg: 'static,
      T: 'static,
      Tindices: con_or_DT_INT32_or_DT_INT64,
      Tindices: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("ScatterUpdate_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("ScatterUpdate", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.ref_)?
        }
        {
            new_op.add_edge(&self.indices)?
        }
        {
            new_op.add_edge(&self.updates)?
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        {
            new_op.set_attr_type("Tindices", Tindices::data_type())?;
        }
        {
            match self.use_locking {
                None => new_op.set_attr_value_proto("use_locking", &vec![40_u8, 1_u8,])?,
                Some(ref value) => (|attr: &bool| {new_op.set_attr_bool("use_locking", *attr)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct ScatterUpdate<T, ref__Arg, Tindices, indices_Arg, updates_Arg>
where T: TensorType,
      T: Clone,
      ref__Arg: Clone,
      ref__Arg: GraphRefEdge<T>,
      ref__Arg: 'static,
      Tindices: TensorType,
      Tindices: Clone,
      indices_Arg: Clone,
      indices_Arg: GraphEdge<Tindices>,
      indices_Arg: 'static,
      updates_Arg: Clone,
      updates_Arg: GraphEdge<T>,
      updates_Arg: 'static,
      T: 'static,
      Tindices: con_or_DT_INT32_or_DT_INT64,
      Tindices: 'static,
{
    phantom_T: PhantomData<T>,
    ref_: ref__Arg,
    phantom_Tindices: PhantomData<Tindices>,
    indices: indices_Arg,
    updates: updates_Arg,
    use_locking: Option<bool>,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<T, ref__Arg, Tindices, indices_Arg, updates_Arg> ScatterUpdate<T, ref__Arg, Tindices, indices_Arg, updates_Arg>
where T: TensorType,
      T: Clone,
      ref__Arg: Clone,
      ref__Arg: GraphRefEdge<T>,
      ref__Arg: 'static,
      Tindices: TensorType,
      Tindices: Clone,
      indices_Arg: Clone,
      indices_Arg: GraphEdge<Tindices>,
      indices_Arg: 'static,
      updates_Arg: Clone,
      updates_Arg: GraphEdge<T>,
      updates_Arg: 'static,
      T: 'static,
      Tindices: con_or_DT_INT32_or_DT_INT64,
      Tindices: 'static,
{
    pub fn output_ref(self) -> RefEdge<T> {
        let rc = Rc::new(self);
        {
            RefEdge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn use_locking(&mut self, use_locking: bool) -> Self {
        self.use_locking = Some(use_locking);
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> RefEdge<T> {
        let rc = Rc::new(self);
        {
            RefEdge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(ref_: ref__Arg, indices: indices_Arg, updates: updates_Arg) -> Self {
        Self {
            phantom_T: PhantomData,
            ref_,
            phantom_Tindices: PhantomData,
            indices,
            updates,
            use_locking: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(ref_: ref__Arg, indices: indices_Arg, updates: updates_Arg) -> RefEdge<T> {
        Self {
            phantom_T: PhantomData,
            ref_,
            phantom_Tindices: PhantomData,
            indices,
            updates,
            use_locking: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<T, input_Arg, min_input_Arg, max_input_Arg> GraphOperation for QuantizedMaxPool<T, input_Arg, min_input_Arg, max_input_Arg>
where T: TensorType,
      T: Clone,
      input_Arg: Clone,
      input_Arg: GraphEdge<T>,
      input_Arg: 'static,
      min_input_Arg: Clone,
      min_input_Arg: GraphEdge<f32>,
      min_input_Arg: 'static,
      max_input_Arg: Clone,
      max_input_Arg: GraphEdge<f32>,
      max_input_Arg: 'static,
      T: con_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_QINT16_or_DT_QUINT16,
      T: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("QuantizedMaxPool_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("QuantizedMaxPool", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.input)?
        }
        {
            new_op.add_edge(&self.min_input)?
        }
        {
            new_op.add_edge(&self.max_input)?
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        {
            (|attrs| {new_op.set_attr_int_list("ksize", attrs)})(&self.ksize)?
        }
        {
            (|attrs| {new_op.set_attr_int_list("strides", attrs)})(&self.strides)?
        }
        {
            (|attr| {new_op.set_attr_string("padding", attr)})(&self.padding)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct QuantizedMaxPool<T, input_Arg, min_input_Arg, max_input_Arg>
where T: TensorType,
      T: Clone,
      input_Arg: Clone,
      input_Arg: GraphEdge<T>,
      input_Arg: 'static,
      min_input_Arg: Clone,
      min_input_Arg: GraphEdge<f32>,
      min_input_Arg: 'static,
      max_input_Arg: Clone,
      max_input_Arg: GraphEdge<f32>,
      max_input_Arg: 'static,
      T: con_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_QINT16_or_DT_QUINT16,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    input: input_Arg,
    min_input: min_input_Arg,
    max_input: max_input_Arg,
    ksize: Vec<i64>,
    strides: Vec<i64>,
    padding: String,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<T, input_Arg, min_input_Arg, max_input_Arg> QuantizedMaxPool<T, input_Arg, min_input_Arg, max_input_Arg>
where T: TensorType,
      T: Clone,
      input_Arg: Clone,
      input_Arg: GraphEdge<T>,
      input_Arg: 'static,
      min_input_Arg: Clone,
      min_input_Arg: GraphEdge<f32>,
      min_input_Arg: 'static,
      max_input_Arg: Clone,
      max_input_Arg: GraphEdge<f32>,
      max_input_Arg: 'static,
      T: con_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_QINT16_or_DT_QUINT16,
      T: 'static,
{
    pub fn output(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn min_output(self) -> Edge<f32> {
        let rc = Rc::new(self);
        {
            Edge::<f32>::new(rc.clone(), 1)
        }
    }

    pub fn max_output(self) -> Edge<f32> {
        let rc = Rc::new(self);
        {
            Edge::<f32>::new(rc.clone(), 2)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> (Edge<T>, Edge<f32>, Edge<f32>) {
        let rc = Rc::new(self);
        (
        {
            Edge::<T>::new(rc.clone(), 0)
        },
        {
            Edge::<f32>::new(rc.clone(), 1)
        },
        {
            Edge::<f32>::new(rc.clone(), 2)
        },
        )
    }

    pub fn build(input: input_Arg, min_input: min_input_Arg, max_input: max_input_Arg, ksize: &[i64], strides: &[i64], padding: &str) -> Self {
        Self {
            phantom_T: PhantomData,
            input,
            min_input,
            max_input,
            ksize: ksize.to_vec(),
            strides: strides.to_vec(),
            padding: padding.to_string(),
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(input: input_Arg, min_input: min_input_Arg, max_input: max_input_Arg, ksize: &[i64], strides: &[i64], padding: &str) -> (Edge<T>, Edge<f32>, Edge<f32>) {
        Self {
            phantom_T: PhantomData,
            input,
            min_input,
            max_input,
            ksize: ksize.to_vec(),
            strides: strides.to_vec(),
            padding: padding.to_string(),
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<Tinput, input_Arg, Tfilter, filter_Arg, min_input_Arg, max_input_Arg, min_filter_Arg, max_filter_Arg, out_type> GraphOperation for QuantizedConv2D<Tinput, input_Arg, Tfilter, filter_Arg, min_input_Arg, max_input_Arg, min_filter_Arg, max_filter_Arg, out_type>
where Tinput: TensorType,
      Tinput: Clone,
      input_Arg: Clone,
      input_Arg: GraphEdge<Tinput>,
      input_Arg: 'static,
      Tfilter: TensorType,
      Tfilter: Clone,
      filter_Arg: Clone,
      filter_Arg: GraphEdge<Tfilter>,
      filter_Arg: 'static,
      min_input_Arg: Clone,
      min_input_Arg: GraphEdge<f32>,
      min_input_Arg: 'static,
      max_input_Arg: Clone,
      max_input_Arg: GraphEdge<f32>,
      max_input_Arg: 'static,
      min_filter_Arg: Clone,
      min_filter_Arg: GraphEdge<f32>,
      min_filter_Arg: 'static,
      max_filter_Arg: Clone,
      max_filter_Arg: GraphEdge<f32>,
      max_filter_Arg: 'static,
      out_type: TensorType,
      Tinput: con_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_QINT16_or_DT_QUINT16,
      Tinput: 'static,
      Tfilter: con_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_QINT16_or_DT_QUINT16,
      Tfilter: 'static,
      out_type: con_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_QINT16_or_DT_QUINT16,
      out_type: 'static,
      out_type: Clone,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("QuantizedConv2D_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("QuantizedConv2D", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.input)?
        }
        {
            new_op.add_edge(&self.filter)?
        }
        {
            new_op.add_edge(&self.min_input)?
        }
        {
            new_op.add_edge(&self.max_input)?
        }
        {
            new_op.add_edge(&self.min_filter)?
        }
        {
            new_op.add_edge(&self.max_filter)?
        }
        {
            new_op.set_attr_type("Tinput", Tinput::data_type())?;
        }
        {
            new_op.set_attr_type("Tfilter", Tfilter::data_type())?;
        }
        {
            new_op.set_attr_type("out_type", out_type::data_type())?;
        }
        {
            (|attrs| {new_op.set_attr_int_list("strides", attrs)})(&self.strides)?
        }
        {
            (|attr| {new_op.set_attr_string("padding", attr)})(&self.padding)?
        }
        {
            match self.dilations {
                None => new_op.set_attr_value_proto("dilations", &vec![10_u8, 0_u8, 26_u8, 4_u8,])?,
                Some(ref value) => (|attrs| {new_op.set_attr_int_list("dilations", attrs)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct QuantizedConv2D<Tinput, input_Arg, Tfilter, filter_Arg, min_input_Arg, max_input_Arg, min_filter_Arg, max_filter_Arg, out_type>
where Tinput: TensorType,
      Tinput: Clone,
      input_Arg: Clone,
      input_Arg: GraphEdge<Tinput>,
      input_Arg: 'static,
      Tfilter: TensorType,
      Tfilter: Clone,
      filter_Arg: Clone,
      filter_Arg: GraphEdge<Tfilter>,
      filter_Arg: 'static,
      min_input_Arg: Clone,
      min_input_Arg: GraphEdge<f32>,
      min_input_Arg: 'static,
      max_input_Arg: Clone,
      max_input_Arg: GraphEdge<f32>,
      max_input_Arg: 'static,
      min_filter_Arg: Clone,
      min_filter_Arg: GraphEdge<f32>,
      min_filter_Arg: 'static,
      max_filter_Arg: Clone,
      max_filter_Arg: GraphEdge<f32>,
      max_filter_Arg: 'static,
      out_type: TensorType,
      Tinput: con_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_QINT16_or_DT_QUINT16,
      Tinput: 'static,
      Tfilter: con_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_QINT16_or_DT_QUINT16,
      Tfilter: 'static,
      out_type: con_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_QINT16_or_DT_QUINT16,
      out_type: 'static,
      out_type: Clone,
{
    phantom_Tinput: PhantomData<Tinput>,
    input: input_Arg,
    phantom_Tfilter: PhantomData<Tfilter>,
    filter: filter_Arg,
    min_input: min_input_Arg,
    max_input: max_input_Arg,
    min_filter: min_filter_Arg,
    max_filter: max_filter_Arg,
    phantom_out_type: PhantomData<out_type>,
    strides: Vec<i64>,
    padding: String,
    dilations: Option<Vec<i64>>,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<Tinput, input_Arg, Tfilter, filter_Arg, min_input_Arg, max_input_Arg, min_filter_Arg, max_filter_Arg, out_type> QuantizedConv2D<Tinput, input_Arg, Tfilter, filter_Arg, min_input_Arg, max_input_Arg, min_filter_Arg, max_filter_Arg, out_type>
where Tinput: TensorType,
      Tinput: Clone,
      input_Arg: Clone,
      input_Arg: GraphEdge<Tinput>,
      input_Arg: 'static,
      Tfilter: TensorType,
      Tfilter: Clone,
      filter_Arg: Clone,
      filter_Arg: GraphEdge<Tfilter>,
      filter_Arg: 'static,
      min_input_Arg: Clone,
      min_input_Arg: GraphEdge<f32>,
      min_input_Arg: 'static,
      max_input_Arg: Clone,
      max_input_Arg: GraphEdge<f32>,
      max_input_Arg: 'static,
      min_filter_Arg: Clone,
      min_filter_Arg: GraphEdge<f32>,
      min_filter_Arg: 'static,
      max_filter_Arg: Clone,
      max_filter_Arg: GraphEdge<f32>,
      max_filter_Arg: 'static,
      out_type: TensorType,
      Tinput: con_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_QINT16_or_DT_QUINT16,
      Tinput: 'static,
      Tfilter: con_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_QINT16_or_DT_QUINT16,
      Tfilter: 'static,
      out_type: con_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_QINT16_or_DT_QUINT16,
      out_type: 'static,
      out_type: Clone,
{
    pub fn output(self) -> Edge<out_type> {
        let rc = Rc::new(self);
        {
            Edge::<out_type>::new(rc.clone(), 0)
        }
    }

    pub fn min_output(self) -> Edge<f32> {
        let rc = Rc::new(self);
        {
            Edge::<f32>::new(rc.clone(), 1)
        }
    }

    pub fn max_output(self) -> Edge<f32> {
        let rc = Rc::new(self);
        {
            Edge::<f32>::new(rc.clone(), 2)
        }
    }

    pub fn dilations(&mut self, dilations: &[i64]) -> Self {
        self.dilations = Some(dilations.to_vec());
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> (Edge<out_type>, Edge<f32>, Edge<f32>) {
        let rc = Rc::new(self);
        (
        {
            Edge::<out_type>::new(rc.clone(), 0)
        },
        {
            Edge::<f32>::new(rc.clone(), 1)
        },
        {
            Edge::<f32>::new(rc.clone(), 2)
        },
        )
    }

    pub fn build(input: input_Arg, filter: filter_Arg, min_input: min_input_Arg, max_input: max_input_Arg, min_filter: min_filter_Arg, max_filter: max_filter_Arg, strides: &[i64], padding: &str) -> Self {
        Self {
            phantom_Tinput: PhantomData,
            input,
            phantom_Tfilter: PhantomData,
            filter,
            min_input,
            max_input,
            min_filter,
            max_filter,
            phantom_out_type: PhantomData,
            strides: strides.to_vec(),
            padding: padding.to_string(),
            dilations: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(input: input_Arg, filter: filter_Arg, min_input: min_input_Arg, max_input: max_input_Arg, min_filter: min_filter_Arg, max_filter: max_filter_Arg, strides: &[i64], padding: &str) -> (Edge<out_type>, Edge<f32>, Edge<f32>) {
        Self {
            phantom_Tinput: PhantomData,
            input,
            phantom_Tfilter: PhantomData,
            filter,
            min_input,
            max_input,
            min_filter,
            max_filter,
            phantom_out_type: PhantomData,
            strides: strides.to_vec(),
            padding: padding.to_string(),
            dilations: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<T1, input_Arg, T2, bias_Arg, min_input_Arg, max_input_Arg, min_bias_Arg, max_bias_Arg, out_type> GraphOperation for QuantizedBiasAdd<T1, input_Arg, T2, bias_Arg, min_input_Arg, max_input_Arg, min_bias_Arg, max_bias_Arg, out_type>
where T1: TensorType,
      T1: Clone,
      input_Arg: Clone,
      input_Arg: GraphEdge<T1>,
      input_Arg: 'static,
      T2: TensorType,
      T2: Clone,
      bias_Arg: Clone,
      bias_Arg: GraphEdge<T2>,
      bias_Arg: 'static,
      min_input_Arg: Clone,
      min_input_Arg: GraphEdge<f32>,
      min_input_Arg: 'static,
      max_input_Arg: Clone,
      max_input_Arg: GraphEdge<f32>,
      max_input_Arg: 'static,
      min_bias_Arg: Clone,
      min_bias_Arg: GraphEdge<f32>,
      min_bias_Arg: 'static,
      max_bias_Arg: Clone,
      max_bias_Arg: GraphEdge<f32>,
      max_bias_Arg: 'static,
      out_type: TensorType,
      T1: con_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_QINT16_or_DT_QUINT16,
      T1: 'static,
      T2: con_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_QINT16_or_DT_QUINT16,
      T2: 'static,
      out_type: con_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_QINT16_or_DT_QUINT16,
      out_type: 'static,
      out_type: Clone,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("QuantizedBiasAdd_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("QuantizedBiasAdd", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.input)?
        }
        {
            new_op.add_edge(&self.bias)?
        }
        {
            new_op.add_edge(&self.min_input)?
        }
        {
            new_op.add_edge(&self.max_input)?
        }
        {
            new_op.add_edge(&self.min_bias)?
        }
        {
            new_op.add_edge(&self.max_bias)?
        }
        {
            new_op.set_attr_type("T1", T1::data_type())?;
        }
        {
            new_op.set_attr_type("T2", T2::data_type())?;
        }
        {
            new_op.set_attr_type("out_type", out_type::data_type())?;
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct QuantizedBiasAdd<T1, input_Arg, T2, bias_Arg, min_input_Arg, max_input_Arg, min_bias_Arg, max_bias_Arg, out_type>
where T1: TensorType,
      T1: Clone,
      input_Arg: Clone,
      input_Arg: GraphEdge<T1>,
      input_Arg: 'static,
      T2: TensorType,
      T2: Clone,
      bias_Arg: Clone,
      bias_Arg: GraphEdge<T2>,
      bias_Arg: 'static,
      min_input_Arg: Clone,
      min_input_Arg: GraphEdge<f32>,
      min_input_Arg: 'static,
      max_input_Arg: Clone,
      max_input_Arg: GraphEdge<f32>,
      max_input_Arg: 'static,
      min_bias_Arg: Clone,
      min_bias_Arg: GraphEdge<f32>,
      min_bias_Arg: 'static,
      max_bias_Arg: Clone,
      max_bias_Arg: GraphEdge<f32>,
      max_bias_Arg: 'static,
      out_type: TensorType,
      T1: con_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_QINT16_or_DT_QUINT16,
      T1: 'static,
      T2: con_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_QINT16_or_DT_QUINT16,
      T2: 'static,
      out_type: con_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_QINT16_or_DT_QUINT16,
      out_type: 'static,
      out_type: Clone,
{
    phantom_T1: PhantomData<T1>,
    input: input_Arg,
    phantom_T2: PhantomData<T2>,
    bias: bias_Arg,
    min_input: min_input_Arg,
    max_input: max_input_Arg,
    min_bias: min_bias_Arg,
    max_bias: max_bias_Arg,
    phantom_out_type: PhantomData<out_type>,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<T1, input_Arg, T2, bias_Arg, min_input_Arg, max_input_Arg, min_bias_Arg, max_bias_Arg, out_type> QuantizedBiasAdd<T1, input_Arg, T2, bias_Arg, min_input_Arg, max_input_Arg, min_bias_Arg, max_bias_Arg, out_type>
where T1: TensorType,
      T1: Clone,
      input_Arg: Clone,
      input_Arg: GraphEdge<T1>,
      input_Arg: 'static,
      T2: TensorType,
      T2: Clone,
      bias_Arg: Clone,
      bias_Arg: GraphEdge<T2>,
      bias_Arg: 'static,
      min_input_Arg: Clone,
      min_input_Arg: GraphEdge<f32>,
      min_input_Arg: 'static,
      max_input_Arg: Clone,
      max_input_Arg: GraphEdge<f32>,
      max_input_Arg: 'static,
      min_bias_Arg: Clone,
      min_bias_Arg: GraphEdge<f32>,
      min_bias_Arg: 'static,
      max_bias_Arg: Clone,
      max_bias_Arg: GraphEdge<f32>,
      max_bias_Arg: 'static,
      out_type: TensorType,
      T1: con_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_QINT16_or_DT_QUINT16,
      T1: 'static,
      T2: con_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_QINT16_or_DT_QUINT16,
      T2: 'static,
      out_type: con_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_QINT16_or_DT_QUINT16,
      out_type: 'static,
      out_type: Clone,
{
    pub fn output(self) -> Edge<out_type> {
        let rc = Rc::new(self);
        {
            Edge::<out_type>::new(rc.clone(), 0)
        }
    }

    pub fn min_out(self) -> Edge<f32> {
        let rc = Rc::new(self);
        {
            Edge::<f32>::new(rc.clone(), 1)
        }
    }

    pub fn max_out(self) -> Edge<f32> {
        let rc = Rc::new(self);
        {
            Edge::<f32>::new(rc.clone(), 2)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> (Edge<out_type>, Edge<f32>, Edge<f32>) {
        let rc = Rc::new(self);
        (
        {
            Edge::<out_type>::new(rc.clone(), 0)
        },
        {
            Edge::<f32>::new(rc.clone(), 1)
        },
        {
            Edge::<f32>::new(rc.clone(), 2)
        },
        )
    }

    pub fn build(input: input_Arg, bias: bias_Arg, min_input: min_input_Arg, max_input: max_input_Arg, min_bias: min_bias_Arg, max_bias: max_bias_Arg) -> Self {
        Self {
            phantom_T1: PhantomData,
            input,
            phantom_T2: PhantomData,
            bias,
            min_input,
            max_input,
            min_bias,
            max_bias,
            phantom_out_type: PhantomData,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(input: input_Arg, bias: bias_Arg, min_input: min_input_Arg, max_input: max_input_Arg, min_bias: min_bias_Arg, max_bias: max_bias_Arg) -> (Edge<out_type>, Edge<f32>, Edge<f32>) {
        Self {
            phantom_T1: PhantomData,
            input,
            phantom_T2: PhantomData,
            bias,
            min_input,
            max_input,
            min_bias,
            max_bias,
            phantom_out_type: PhantomData,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<T, input_Arg, min_input_Arg, max_input_Arg> GraphOperation for QuantizedAvgPool<T, input_Arg, min_input_Arg, max_input_Arg>
where T: TensorType,
      T: Clone,
      input_Arg: Clone,
      input_Arg: GraphEdge<T>,
      input_Arg: 'static,
      min_input_Arg: Clone,
      min_input_Arg: GraphEdge<f32>,
      min_input_Arg: 'static,
      max_input_Arg: Clone,
      max_input_Arg: GraphEdge<f32>,
      max_input_Arg: 'static,
      T: con_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_QINT16_or_DT_QUINT16,
      T: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("QuantizedAvgPool_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("QuantizedAvgPool", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.input)?
        }
        {
            new_op.add_edge(&self.min_input)?
        }
        {
            new_op.add_edge(&self.max_input)?
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        {
            (|attrs| {new_op.set_attr_int_list("ksize", attrs)})(&self.ksize)?
        }
        {
            (|attrs| {new_op.set_attr_int_list("strides", attrs)})(&self.strides)?
        }
        {
            (|attr| {new_op.set_attr_string("padding", attr)})(&self.padding)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct QuantizedAvgPool<T, input_Arg, min_input_Arg, max_input_Arg>
where T: TensorType,
      T: Clone,
      input_Arg: Clone,
      input_Arg: GraphEdge<T>,
      input_Arg: 'static,
      min_input_Arg: Clone,
      min_input_Arg: GraphEdge<f32>,
      min_input_Arg: 'static,
      max_input_Arg: Clone,
      max_input_Arg: GraphEdge<f32>,
      max_input_Arg: 'static,
      T: con_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_QINT16_or_DT_QUINT16,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    input: input_Arg,
    min_input: min_input_Arg,
    max_input: max_input_Arg,
    ksize: Vec<i64>,
    strides: Vec<i64>,
    padding: String,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<T, input_Arg, min_input_Arg, max_input_Arg> QuantizedAvgPool<T, input_Arg, min_input_Arg, max_input_Arg>
where T: TensorType,
      T: Clone,
      input_Arg: Clone,
      input_Arg: GraphEdge<T>,
      input_Arg: 'static,
      min_input_Arg: Clone,
      min_input_Arg: GraphEdge<f32>,
      min_input_Arg: 'static,
      max_input_Arg: Clone,
      max_input_Arg: GraphEdge<f32>,
      max_input_Arg: 'static,
      T: con_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_QINT16_or_DT_QUINT16,
      T: 'static,
{
    pub fn output(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn min_output(self) -> Edge<f32> {
        let rc = Rc::new(self);
        {
            Edge::<f32>::new(rc.clone(), 1)
        }
    }

    pub fn max_output(self) -> Edge<f32> {
        let rc = Rc::new(self);
        {
            Edge::<f32>::new(rc.clone(), 2)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> (Edge<T>, Edge<f32>, Edge<f32>) {
        let rc = Rc::new(self);
        (
        {
            Edge::<T>::new(rc.clone(), 0)
        },
        {
            Edge::<f32>::new(rc.clone(), 1)
        },
        {
            Edge::<f32>::new(rc.clone(), 2)
        },
        )
    }

    pub fn build(input: input_Arg, min_input: min_input_Arg, max_input: max_input_Arg, ksize: &[i64], strides: &[i64], padding: &str) -> Self {
        Self {
            phantom_T: PhantomData,
            input,
            min_input,
            max_input,
            ksize: ksize.to_vec(),
            strides: strides.to_vec(),
            padding: padding.to_string(),
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(input: input_Arg, min_input: min_input_Arg, max_input: max_input_Arg, ksize: &[i64], strides: &[i64], padding: &str) -> (Edge<T>, Edge<f32>, Edge<f32>) {
        Self {
            phantom_T: PhantomData,
            input,
            min_input,
            max_input,
            ksize: ksize.to_vec(),
            strides: strides.to_vec(),
            padding: padding.to_string(),
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<orig_input_tensor_shape_Arg, T, out_backprop_Arg, row_pooling_sequence_Arg, col_pooling_sequence_Arg> GraphOperation for FractionalAvgPoolGrad<orig_input_tensor_shape_Arg, T, out_backprop_Arg, row_pooling_sequence_Arg, col_pooling_sequence_Arg>
where orig_input_tensor_shape_Arg: Clone,
      orig_input_tensor_shape_Arg: GraphEdge<i64>,
      orig_input_tensor_shape_Arg: 'static,
      T: TensorType,
      T: Clone,
      out_backprop_Arg: Clone,
      out_backprop_Arg: GraphEdge<T>,
      out_backprop_Arg: 'static,
      row_pooling_sequence_Arg: Clone,
      row_pooling_sequence_Arg: GraphEdge<i64>,
      row_pooling_sequence_Arg: 'static,
      col_pooling_sequence_Arg: Clone,
      col_pooling_sequence_Arg: GraphEdge<i64>,
      col_pooling_sequence_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_INT64,
      T: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("FractionalAvgPoolGrad_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("FractionalAvgPoolGrad", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.orig_input_tensor_shape)?
        }
        {
            new_op.add_edge(&self.out_backprop)?
        }
        {
            new_op.add_edge(&self.row_pooling_sequence)?
        }
        {
            new_op.add_edge(&self.col_pooling_sequence)?
        }
        {
            match self.overlapping {
                None => new_op.set_attr_value_proto("overlapping", &vec![40_u8, 0_u8,])?,
                Some(ref value) => (|attr: &bool| {new_op.set_attr_bool("overlapping", *attr)})(&value)?,
            };
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct FractionalAvgPoolGrad<orig_input_tensor_shape_Arg, T, out_backprop_Arg, row_pooling_sequence_Arg, col_pooling_sequence_Arg>
where orig_input_tensor_shape_Arg: Clone,
      orig_input_tensor_shape_Arg: GraphEdge<i64>,
      orig_input_tensor_shape_Arg: 'static,
      T: TensorType,
      T: Clone,
      out_backprop_Arg: Clone,
      out_backprop_Arg: GraphEdge<T>,
      out_backprop_Arg: 'static,
      row_pooling_sequence_Arg: Clone,
      row_pooling_sequence_Arg: GraphEdge<i64>,
      row_pooling_sequence_Arg: 'static,
      col_pooling_sequence_Arg: Clone,
      col_pooling_sequence_Arg: GraphEdge<i64>,
      col_pooling_sequence_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_INT64,
      T: 'static,
{
    orig_input_tensor_shape: orig_input_tensor_shape_Arg,
    phantom_T: PhantomData<T>,
    out_backprop: out_backprop_Arg,
    row_pooling_sequence: row_pooling_sequence_Arg,
    col_pooling_sequence: col_pooling_sequence_Arg,
    overlapping: Option<bool>,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<orig_input_tensor_shape_Arg, T, out_backprop_Arg, row_pooling_sequence_Arg, col_pooling_sequence_Arg> FractionalAvgPoolGrad<orig_input_tensor_shape_Arg, T, out_backprop_Arg, row_pooling_sequence_Arg, col_pooling_sequence_Arg>
where orig_input_tensor_shape_Arg: Clone,
      orig_input_tensor_shape_Arg: GraphEdge<i64>,
      orig_input_tensor_shape_Arg: 'static,
      T: TensorType,
      T: Clone,
      out_backprop_Arg: Clone,
      out_backprop_Arg: GraphEdge<T>,
      out_backprop_Arg: 'static,
      row_pooling_sequence_Arg: Clone,
      row_pooling_sequence_Arg: GraphEdge<i64>,
      row_pooling_sequence_Arg: 'static,
      col_pooling_sequence_Arg: Clone,
      col_pooling_sequence_Arg: GraphEdge<i64>,
      col_pooling_sequence_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_INT64,
      T: 'static,
{
    pub fn output(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn overlapping(&mut self, overlapping: bool) -> Self {
        self.overlapping = Some(overlapping);
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(orig_input_tensor_shape: orig_input_tensor_shape_Arg, out_backprop: out_backprop_Arg, row_pooling_sequence: row_pooling_sequence_Arg, col_pooling_sequence: col_pooling_sequence_Arg) -> Self {
        Self {
            orig_input_tensor_shape,
            phantom_T: PhantomData,
            out_backprop,
            row_pooling_sequence,
            col_pooling_sequence,
            overlapping: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(orig_input_tensor_shape: orig_input_tensor_shape_Arg, out_backprop: out_backprop_Arg, row_pooling_sequence: row_pooling_sequence_Arg, col_pooling_sequence: col_pooling_sequence_Arg) -> Edge<T> {
        Self {
            orig_input_tensor_shape,
            phantom_T: PhantomData,
            out_backprop,
            row_pooling_sequence,
            col_pooling_sequence,
            overlapping: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<T, input_Arg, k_Arg> GraphOperation for TopKV2<T, input_Arg, k_Arg>
where T: TensorType,
      T: Clone,
      input_Arg: Clone,
      input_Arg: GraphEdge<T>,
      input_Arg: 'static,
      k_Arg: Clone,
      k_Arg: GraphEdge<i32>,
      k_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("TopKV2_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("TopKV2", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.input)?
        }
        {
            new_op.add_edge(&self.k)?
        }
        {
            match self.sorted {
                None => new_op.set_attr_value_proto("sorted", &vec![40_u8, 1_u8,])?,
                Some(ref value) => (|attr: &bool| {new_op.set_attr_bool("sorted", *attr)})(&value)?,
            };
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct TopKV2<T, input_Arg, k_Arg>
where T: TensorType,
      T: Clone,
      input_Arg: Clone,
      input_Arg: GraphEdge<T>,
      input_Arg: 'static,
      k_Arg: Clone,
      k_Arg: GraphEdge<i32>,
      k_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    input: input_Arg,
    k: k_Arg,
    sorted: Option<bool>,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<T, input_Arg, k_Arg> TopKV2<T, input_Arg, k_Arg>
where T: TensorType,
      T: Clone,
      input_Arg: Clone,
      input_Arg: GraphEdge<T>,
      input_Arg: 'static,
      k_Arg: Clone,
      k_Arg: GraphEdge<i32>,
      k_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
{
    pub fn values(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn indices(self) -> Edge<i32> {
        let rc = Rc::new(self);
        {
            Edge::<i32>::new(rc.clone(), 1)
        }
    }

    pub fn sorted(&mut self, sorted: bool) -> Self {
        self.sorted = Some(sorted);
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> (Edge<T>, Edge<i32>) {
        let rc = Rc::new(self);
        (
        {
            Edge::<T>::new(rc.clone(), 0)
        },
        {
            Edge::<i32>::new(rc.clone(), 1)
        },
        )
    }

    pub fn build(input: input_Arg, k: k_Arg) -> Self {
        Self {
            phantom_T: PhantomData,
            input,
            k,
            sorted: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(input: input_Arg, k: k_Arg) -> (Edge<T>, Edge<i32>) {
        Self {
            phantom_T: PhantomData,
            input,
            k,
            sorted: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<T, var_Arg, alpha_Arg, l1_Arg, l2_Arg, delta_Arg> GraphOperation for ApplyProximalGradientDescent<T, var_Arg, alpha_Arg, l1_Arg, l2_Arg, delta_Arg>
where T: TensorType,
      T: Clone,
      var_Arg: Clone,
      var_Arg: GraphRefEdge<T>,
      var_Arg: 'static,
      alpha_Arg: Clone,
      alpha_Arg: GraphEdge<T>,
      alpha_Arg: 'static,
      l1_Arg: Clone,
      l1_Arg: GraphEdge<T>,
      l1_Arg: 'static,
      l2_Arg: Clone,
      l2_Arg: GraphEdge<T>,
      l2_Arg: 'static,
      delta_Arg: Clone,
      delta_Arg: GraphEdge<T>,
      delta_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("ApplyProximalGradientDescent_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("ApplyProximalGradientDescent", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.var)?
        }
        {
            new_op.add_edge(&self.alpha)?
        }
        {
            new_op.add_edge(&self.l1)?
        }
        {
            new_op.add_edge(&self.l2)?
        }
        {
            new_op.add_edge(&self.delta)?
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        {
            match self.use_locking {
                None => new_op.set_attr_value_proto("use_locking", &vec![40_u8, 0_u8,])?,
                Some(ref value) => (|attr: &bool| {new_op.set_attr_bool("use_locking", *attr)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct ApplyProximalGradientDescent<T, var_Arg, alpha_Arg, l1_Arg, l2_Arg, delta_Arg>
where T: TensorType,
      T: Clone,
      var_Arg: Clone,
      var_Arg: GraphRefEdge<T>,
      var_Arg: 'static,
      alpha_Arg: Clone,
      alpha_Arg: GraphEdge<T>,
      alpha_Arg: 'static,
      l1_Arg: Clone,
      l1_Arg: GraphEdge<T>,
      l1_Arg: 'static,
      l2_Arg: Clone,
      l2_Arg: GraphEdge<T>,
      l2_Arg: 'static,
      delta_Arg: Clone,
      delta_Arg: GraphEdge<T>,
      delta_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    var: var_Arg,
    alpha: alpha_Arg,
    l1: l1_Arg,
    l2: l2_Arg,
    delta: delta_Arg,
    use_locking: Option<bool>,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<T, var_Arg, alpha_Arg, l1_Arg, l2_Arg, delta_Arg> ApplyProximalGradientDescent<T, var_Arg, alpha_Arg, l1_Arg, l2_Arg, delta_Arg>
where T: TensorType,
      T: Clone,
      var_Arg: Clone,
      var_Arg: GraphRefEdge<T>,
      var_Arg: 'static,
      alpha_Arg: Clone,
      alpha_Arg: GraphEdge<T>,
      alpha_Arg: 'static,
      l1_Arg: Clone,
      l1_Arg: GraphEdge<T>,
      l1_Arg: 'static,
      l2_Arg: Clone,
      l2_Arg: GraphEdge<T>,
      l2_Arg: 'static,
      delta_Arg: Clone,
      delta_Arg: GraphEdge<T>,
      delta_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
{
    pub fn out(self) -> RefEdge<T> {
        let rc = Rc::new(self);
        {
            RefEdge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn use_locking(&mut self, use_locking: bool) -> Self {
        self.use_locking = Some(use_locking);
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> RefEdge<T> {
        let rc = Rc::new(self);
        {
            RefEdge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(var: var_Arg, alpha: alpha_Arg, l1: l1_Arg, l2: l2_Arg, delta: delta_Arg) -> Self {
        Self {
            phantom_T: PhantomData,
            var,
            alpha,
            l1,
            l2,
            delta,
            use_locking: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(var: var_Arg, alpha: alpha_Arg, l1: l1_Arg, l2: l2_Arg, delta: delta_Arg) -> RefEdge<T> {
        Self {
            phantom_T: PhantomData,
            var,
            alpha,
            l1,
            l2,
            delta,
            use_locking: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<T, input_Arg> GraphOperation for TopK<T, input_Arg>
where T: TensorType,
      T: Clone,
      input_Arg: Clone,
      input_Arg: GraphEdge<T>,
      input_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("TopK_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("TopK", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.input)?
        }
        {
            (|attr: &i64| {new_op.set_attr_int("k", *attr)})(&self.k)?
        }
        {
            match self.sorted {
                None => new_op.set_attr_value_proto("sorted", &vec![40_u8, 1_u8,])?,
                Some(ref value) => (|attr: &bool| {new_op.set_attr_bool("sorted", *attr)})(&value)?,
            };
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct TopK<T, input_Arg>
where T: TensorType,
      T: Clone,
      input_Arg: Clone,
      input_Arg: GraphEdge<T>,
      input_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    input: input_Arg,
    k: i64,
    sorted: Option<bool>,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<T, input_Arg> TopK<T, input_Arg>
where T: TensorType,
      T: Clone,
      input_Arg: Clone,
      input_Arg: GraphEdge<T>,
      input_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
{
    pub fn values(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn indices(self) -> Edge<i32> {
        let rc = Rc::new(self);
        {
            Edge::<i32>::new(rc.clone(), 1)
        }
    }

    pub fn sorted(&mut self, sorted: bool) -> Self {
        self.sorted = Some(sorted);
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> (Edge<T>, Edge<i32>) {
        let rc = Rc::new(self);
        (
        {
            Edge::<T>::new(rc.clone(), 0)
        },
        {
            Edge::<i32>::new(rc.clone(), 1)
        },
        )
    }

    pub fn build(input: input_Arg, k: i64) -> Self {
        Self {
            phantom_T: PhantomData,
            input,
            k: k,
            sorted: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(input: input_Arg, k: i64) -> (Edge<T>, Edge<i32>) {
        Self {
            phantom_T: PhantomData,
            input,
            k: k,
            sorted: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<predictions_Arg, T, targets_Arg, k_Arg> GraphOperation for InTopKV2<predictions_Arg, T, targets_Arg, k_Arg>
where predictions_Arg: Clone,
      predictions_Arg: GraphEdge<f32>,
      predictions_Arg: 'static,
      T: TensorType,
      T: Clone,
      targets_Arg: Clone,
      targets_Arg: GraphEdge<T>,
      targets_Arg: 'static,
      k_Arg: Clone,
      k_Arg: GraphEdge<T>,
      k_Arg: 'static,
      T: con_or_DT_INT32_or_DT_INT64,
      T: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("InTopKV2_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("InTopKV2", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.predictions)?
        }
        {
            new_op.add_edge(&self.targets)?
        }
        {
            new_op.add_edge(&self.k)?
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct InTopKV2<predictions_Arg, T, targets_Arg, k_Arg>
where predictions_Arg: Clone,
      predictions_Arg: GraphEdge<f32>,
      predictions_Arg: 'static,
      T: TensorType,
      T: Clone,
      targets_Arg: Clone,
      targets_Arg: GraphEdge<T>,
      targets_Arg: 'static,
      k_Arg: Clone,
      k_Arg: GraphEdge<T>,
      k_Arg: 'static,
      T: con_or_DT_INT32_or_DT_INT64,
      T: 'static,
{
    predictions: predictions_Arg,
    phantom_T: PhantomData<T>,
    targets: targets_Arg,
    k: k_Arg,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<predictions_Arg, T, targets_Arg, k_Arg> InTopKV2<predictions_Arg, T, targets_Arg, k_Arg>
where predictions_Arg: Clone,
      predictions_Arg: GraphEdge<f32>,
      predictions_Arg: 'static,
      T: TensorType,
      T: Clone,
      targets_Arg: Clone,
      targets_Arg: GraphEdge<T>,
      targets_Arg: 'static,
      k_Arg: Clone,
      k_Arg: GraphEdge<T>,
      k_Arg: 'static,
      T: con_or_DT_INT32_or_DT_INT64,
      T: 'static,
{
    pub fn precision(self) -> Edge<bool> {
        let rc = Rc::new(self);
        {
            Edge::<bool>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<bool> {
        let rc = Rc::new(self);
        {
            Edge::<bool>::new(rc.clone(), 0)
        }
    }

    pub fn build(predictions: predictions_Arg, targets: targets_Arg, k: k_Arg) -> Self {
        Self {
            predictions,
            phantom_T: PhantomData,
            targets,
            k,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(predictions: predictions_Arg, targets: targets_Arg, k: k_Arg) -> Edge<bool> {
        Self {
            predictions,
            phantom_T: PhantomData,
            targets,
            k,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<predictions_Arg, T, targets_Arg> GraphOperation for InTopK<predictions_Arg, T, targets_Arg>
where predictions_Arg: Clone,
      predictions_Arg: GraphEdge<f32>,
      predictions_Arg: 'static,
      T: TensorType,
      T: Clone,
      targets_Arg: Clone,
      targets_Arg: GraphEdge<T>,
      targets_Arg: 'static,
      T: con_or_DT_INT32_or_DT_INT64,
      T: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("InTopK_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("InTopK", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.predictions)?
        }
        {
            new_op.add_edge(&self.targets)?
        }
        {
            (|attr: &i64| {new_op.set_attr_int("k", *attr)})(&self.k)?
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct InTopK<predictions_Arg, T, targets_Arg>
where predictions_Arg: Clone,
      predictions_Arg: GraphEdge<f32>,
      predictions_Arg: 'static,
      T: TensorType,
      T: Clone,
      targets_Arg: Clone,
      targets_Arg: GraphEdge<T>,
      targets_Arg: 'static,
      T: con_or_DT_INT32_or_DT_INT64,
      T: 'static,
{
    predictions: predictions_Arg,
    phantom_T: PhantomData<T>,
    targets: targets_Arg,
    k: i64,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<predictions_Arg, T, targets_Arg> InTopK<predictions_Arg, T, targets_Arg>
where predictions_Arg: Clone,
      predictions_Arg: GraphEdge<f32>,
      predictions_Arg: 'static,
      T: TensorType,
      T: Clone,
      targets_Arg: Clone,
      targets_Arg: GraphEdge<T>,
      targets_Arg: 'static,
      T: con_or_DT_INT32_or_DT_INT64,
      T: 'static,
{
    pub fn precision(self) -> Edge<bool> {
        let rc = Rc::new(self);
        {
            Edge::<bool>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<bool> {
        let rc = Rc::new(self);
        {
            Edge::<bool>::new(rc.clone(), 0)
        }
    }

    pub fn build(predictions: predictions_Arg, targets: targets_Arg, k: i64) -> Self {
        Self {
            predictions,
            phantom_T: PhantomData,
            targets,
            k: k,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(predictions: predictions_Arg, targets: targets_Arg, k: i64) -> Edge<bool> {
        Self {
            predictions,
            phantom_T: PhantomData,
            targets,
            k: k,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<T, features_Arg, Tlabels, labels_Arg> GraphOperation for SparseSoftmaxCrossEntropyWithLogits<T, features_Arg, Tlabels, labels_Arg>
where T: TensorType,
      T: Clone,
      features_Arg: Clone,
      features_Arg: GraphEdge<T>,
      features_Arg: 'static,
      Tlabels: TensorType,
      Tlabels: Clone,
      labels_Arg: Clone,
      labels_Arg: GraphEdge<Tlabels>,
      labels_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
      T: 'static,
      Tlabels: con_or_DT_INT32_or_DT_INT64,
      Tlabels: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("SparseSoftmaxCrossEntropyWithLogits_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("SparseSoftmaxCrossEntropyWithLogits", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.features)?
        }
        {
            new_op.add_edge(&self.labels)?
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        {
            new_op.set_attr_type("Tlabels", Tlabels::data_type())?;
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct SparseSoftmaxCrossEntropyWithLogits<T, features_Arg, Tlabels, labels_Arg>
where T: TensorType,
      T: Clone,
      features_Arg: Clone,
      features_Arg: GraphEdge<T>,
      features_Arg: 'static,
      Tlabels: TensorType,
      Tlabels: Clone,
      labels_Arg: Clone,
      labels_Arg: GraphEdge<Tlabels>,
      labels_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
      T: 'static,
      Tlabels: con_or_DT_INT32_or_DT_INT64,
      Tlabels: 'static,
{
    phantom_T: PhantomData<T>,
    features: features_Arg,
    phantom_Tlabels: PhantomData<Tlabels>,
    labels: labels_Arg,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<T, features_Arg, Tlabels, labels_Arg> SparseSoftmaxCrossEntropyWithLogits<T, features_Arg, Tlabels, labels_Arg>
where T: TensorType,
      T: Clone,
      features_Arg: Clone,
      features_Arg: GraphEdge<T>,
      features_Arg: 'static,
      Tlabels: TensorType,
      Tlabels: Clone,
      labels_Arg: Clone,
      labels_Arg: GraphEdge<Tlabels>,
      labels_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
      T: 'static,
      Tlabels: con_or_DT_INT32_or_DT_INT64,
      Tlabels: 'static,
{
    pub fn loss(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn backprop(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 1)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> (Edge<T>, Edge<T>) {
        let rc = Rc::new(self);
        (
        {
            Edge::<T>::new(rc.clone(), 0)
        },
        {
            Edge::<T>::new(rc.clone(), 1)
        },
        )
    }

    pub fn build(features: features_Arg, labels: labels_Arg) -> Self {
        Self {
            phantom_T: PhantomData,
            features,
            phantom_Tlabels: PhantomData,
            labels,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(features: features_Arg, labels: labels_Arg) -> (Edge<T>, Edge<T>) {
        Self {
            phantom_T: PhantomData,
            features,
            phantom_Tlabels: PhantomData,
            labels,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<T, features_Arg, labels_Arg> GraphOperation for SoftmaxCrossEntropyWithLogits<T, features_Arg, labels_Arg>
where T: TensorType,
      T: Clone,
      features_Arg: Clone,
      features_Arg: GraphEdge<T>,
      features_Arg: 'static,
      labels_Arg: Clone,
      labels_Arg: GraphEdge<T>,
      labels_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
      T: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("SoftmaxCrossEntropyWithLogits_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("SoftmaxCrossEntropyWithLogits", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.features)?
        }
        {
            new_op.add_edge(&self.labels)?
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct SoftmaxCrossEntropyWithLogits<T, features_Arg, labels_Arg>
where T: TensorType,
      T: Clone,
      features_Arg: Clone,
      features_Arg: GraphEdge<T>,
      features_Arg: 'static,
      labels_Arg: Clone,
      labels_Arg: GraphEdge<T>,
      labels_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    features: features_Arg,
    labels: labels_Arg,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<T, features_Arg, labels_Arg> SoftmaxCrossEntropyWithLogits<T, features_Arg, labels_Arg>
where T: TensorType,
      T: Clone,
      features_Arg: Clone,
      features_Arg: GraphEdge<T>,
      features_Arg: 'static,
      labels_Arg: Clone,
      labels_Arg: GraphEdge<T>,
      labels_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
      T: 'static,
{
    pub fn loss(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn backprop(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 1)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> (Edge<T>, Edge<T>) {
        let rc = Rc::new(self);
        (
        {
            Edge::<T>::new(rc.clone(), 0)
        },
        {
            Edge::<T>::new(rc.clone(), 1)
        },
        )
    }

    pub fn build(features: features_Arg, labels: labels_Arg) -> Self {
        Self {
            phantom_T: PhantomData,
            features,
            labels,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(features: features_Arg, labels: labels_Arg) -> (Edge<T>, Edge<T>) {
        Self {
            phantom_T: PhantomData,
            features,
            labels,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<T, logits_Arg> GraphOperation for Softmax<T, logits_Arg>
where T: TensorType,
      T: Clone,
      logits_Arg: Clone,
      logits_Arg: GraphEdge<T>,
      logits_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
      T: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("Softmax_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("Softmax", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.logits)?
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct Softmax<T, logits_Arg>
where T: TensorType,
      T: Clone,
      logits_Arg: Clone,
      logits_Arg: GraphEdge<T>,
      logits_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    logits: logits_Arg,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<T, logits_Arg> Softmax<T, logits_Arg>
where T: TensorType,
      T: Clone,
      logits_Arg: Clone,
      logits_Arg: GraphEdge<T>,
      logits_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
      T: 'static,
{
    pub fn softmax(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(logits: logits_Arg) -> Self {
        Self {
            phantom_T: PhantomData,
            logits,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(logits: logits_Arg) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            logits,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<T, gradients_Arg, features_Arg> GraphOperation for SoftsignGrad<T, gradients_Arg, features_Arg>
where T: TensorType,
      T: Clone,
      gradients_Arg: Clone,
      gradients_Arg: GraphEdge<T>,
      gradients_Arg: 'static,
      features_Arg: Clone,
      features_Arg: GraphEdge<T>,
      features_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
      T: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("SoftsignGrad_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("SoftsignGrad", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.gradients)?
        }
        {
            new_op.add_edge(&self.features)?
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct SoftsignGrad<T, gradients_Arg, features_Arg>
where T: TensorType,
      T: Clone,
      gradients_Arg: Clone,
      gradients_Arg: GraphEdge<T>,
      gradients_Arg: 'static,
      features_Arg: Clone,
      features_Arg: GraphEdge<T>,
      features_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    gradients: gradients_Arg,
    features: features_Arg,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<T, gradients_Arg, features_Arg> SoftsignGrad<T, gradients_Arg, features_Arg>
where T: TensorType,
      T: Clone,
      gradients_Arg: Clone,
      gradients_Arg: GraphEdge<T>,
      gradients_Arg: 'static,
      features_Arg: Clone,
      features_Arg: GraphEdge<T>,
      features_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
      T: 'static,
{
    pub fn backprops(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(gradients: gradients_Arg, features: features_Arg) -> Self {
        Self {
            phantom_T: PhantomData,
            gradients,
            features,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(gradients: gradients_Arg, features: features_Arg) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            gradients,
            features,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<set_indices_Arg, T, set_values_Arg, set_shape_Arg> GraphOperation for SetSize<set_indices_Arg, T, set_values_Arg, set_shape_Arg>
where set_indices_Arg: Clone,
      set_indices_Arg: GraphEdge<i64>,
      set_indices_Arg: 'static,
      T: TensorType,
      T: Clone,
      set_values_Arg: Clone,
      set_values_Arg: GraphEdge<T>,
      set_values_Arg: 'static,
      set_shape_Arg: Clone,
      set_shape_Arg: GraphEdge<i64>,
      set_shape_Arg: 'static,
      T: con_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_STRING_or_DT_INT64_or_DT_UINT16,
      T: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("SetSize_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("SetSize", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.set_indices)?
        }
        {
            new_op.add_edge(&self.set_values)?
        }
        {
            new_op.add_edge(&self.set_shape)?
        }
        {
            match self.validate_indices {
                None => new_op.set_attr_value_proto("validate_indices", &vec![40_u8, 1_u8,])?,
                Some(ref value) => (|attr: &bool| {new_op.set_attr_bool("validate_indices", *attr)})(&value)?,
            };
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct SetSize<set_indices_Arg, T, set_values_Arg, set_shape_Arg>
where set_indices_Arg: Clone,
      set_indices_Arg: GraphEdge<i64>,
      set_indices_Arg: 'static,
      T: TensorType,
      T: Clone,
      set_values_Arg: Clone,
      set_values_Arg: GraphEdge<T>,
      set_values_Arg: 'static,
      set_shape_Arg: Clone,
      set_shape_Arg: GraphEdge<i64>,
      set_shape_Arg: 'static,
      T: con_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_STRING_or_DT_INT64_or_DT_UINT16,
      T: 'static,
{
    set_indices: set_indices_Arg,
    phantom_T: PhantomData<T>,
    set_values: set_values_Arg,
    set_shape: set_shape_Arg,
    validate_indices: Option<bool>,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<set_indices_Arg, T, set_values_Arg, set_shape_Arg> SetSize<set_indices_Arg, T, set_values_Arg, set_shape_Arg>
where set_indices_Arg: Clone,
      set_indices_Arg: GraphEdge<i64>,
      set_indices_Arg: 'static,
      T: TensorType,
      T: Clone,
      set_values_Arg: Clone,
      set_values_Arg: GraphEdge<T>,
      set_values_Arg: 'static,
      set_shape_Arg: Clone,
      set_shape_Arg: GraphEdge<i64>,
      set_shape_Arg: 'static,
      T: con_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_STRING_or_DT_INT64_or_DT_UINT16,
      T: 'static,
{
    pub fn size(self) -> Edge<i32> {
        let rc = Rc::new(self);
        {
            Edge::<i32>::new(rc.clone(), 0)
        }
    }

    pub fn validate_indices(&mut self, validate_indices: bool) -> Self {
        self.validate_indices = Some(validate_indices);
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<i32> {
        let rc = Rc::new(self);
        {
            Edge::<i32>::new(rc.clone(), 0)
        }
    }

    pub fn build(set_indices: set_indices_Arg, set_values: set_values_Arg, set_shape: set_shape_Arg) -> Self {
        Self {
            set_indices,
            phantom_T: PhantomData,
            set_values,
            set_shape,
            validate_indices: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(set_indices: set_indices_Arg, set_values: set_values_Arg, set_shape: set_shape_Arg) -> Edge<i32> {
        Self {
            set_indices,
            phantom_T: PhantomData,
            set_values,
            set_shape,
            validate_indices: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<T, features_Arg> GraphOperation for Selu<T, features_Arg>
where T: TensorType,
      T: Clone,
      features_Arg: Clone,
      features_Arg: GraphEdge<T>,
      features_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
      T: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("Selu_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("Selu", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.features)?
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct Selu<T, features_Arg>
where T: TensorType,
      T: Clone,
      features_Arg: Clone,
      features_Arg: GraphEdge<T>,
      features_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    features: features_Arg,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<T, features_Arg> Selu<T, features_Arg>
where T: TensorType,
      T: Clone,
      features_Arg: Clone,
      features_Arg: GraphEdge<T>,
      features_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
      T: 'static,
{
    pub fn activations(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(features: features_Arg) -> Self {
        Self {
            phantom_T: PhantomData,
            features,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(features: features_Arg) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            features,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<input_Arg> GraphOperation for StaticRegexReplace<input_Arg>
where input_Arg: Clone,
      input_Arg: GraphEdge<String>,
      input_Arg: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("StaticRegexReplace_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("StaticRegexReplace", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.input)?
        }
        {
            (|attr| {new_op.set_attr_string("pattern", attr)})(&self.pattern)?
        }
        {
            (|attr| {new_op.set_attr_string("rewrite", attr)})(&self.rewrite)?
        }
        {
            match self.replace_global {
                None => new_op.set_attr_value_proto("replace_global", &vec![40_u8, 1_u8,])?,
                Some(ref value) => (|attr: &bool| {new_op.set_attr_bool("replace_global", *attr)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct StaticRegexReplace<input_Arg>
where input_Arg: Clone,
      input_Arg: GraphEdge<String>,
      input_Arg: 'static,
{
    input: input_Arg,
    pattern: String,
    rewrite: String,
    replace_global: Option<bool>,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<input_Arg> StaticRegexReplace<input_Arg>
where input_Arg: Clone,
      input_Arg: GraphEdge<String>,
      input_Arg: 'static,
{
    pub fn output(self) -> Edge<String> {
        let rc = Rc::new(self);
        {
            Edge::<String>::new(rc.clone(), 0)
        }
    }

    pub fn replace_global(&mut self, replace_global: bool) -> Self {
        self.replace_global = Some(replace_global);
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<String> {
        let rc = Rc::new(self);
        {
            Edge::<String>::new(rc.clone(), 0)
        }
    }

    pub fn build(input: input_Arg, pattern: &str, rewrite: &str) -> Self {
        Self {
            input,
            pattern: pattern.to_string(),
            rewrite: rewrite.to_string(),
            replace_global: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(input: input_Arg, pattern: &str, rewrite: &str) -> Edge<String> {
        Self {
            input,
            pattern: pattern.to_string(),
            rewrite: rewrite.to_string(),
            replace_global: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<T, gradients_Arg, outputs_Arg> GraphOperation for EluGrad<T, gradients_Arg, outputs_Arg>
where T: TensorType,
      T: Clone,
      gradients_Arg: Clone,
      gradients_Arg: GraphEdge<T>,
      gradients_Arg: 'static,
      outputs_Arg: Clone,
      outputs_Arg: GraphEdge<T>,
      outputs_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
      T: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("EluGrad_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("EluGrad", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.gradients)?
        }
        {
            new_op.add_edge(&self.outputs)?
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct EluGrad<T, gradients_Arg, outputs_Arg>
where T: TensorType,
      T: Clone,
      gradients_Arg: Clone,
      gradients_Arg: GraphEdge<T>,
      gradients_Arg: 'static,
      outputs_Arg: Clone,
      outputs_Arg: GraphEdge<T>,
      outputs_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    gradients: gradients_Arg,
    outputs: outputs_Arg,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<T, gradients_Arg, outputs_Arg> EluGrad<T, gradients_Arg, outputs_Arg>
where T: TensorType,
      T: Clone,
      gradients_Arg: Clone,
      gradients_Arg: GraphEdge<T>,
      gradients_Arg: 'static,
      outputs_Arg: Clone,
      outputs_Arg: GraphEdge<T>,
      outputs_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
      T: 'static,
{
    pub fn backprops(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(gradients: gradients_Arg, outputs: outputs_Arg) -> Self {
        Self {
            phantom_T: PhantomData,
            gradients,
            outputs,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(gradients: gradients_Arg, outputs: outputs_Arg) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            gradients,
            outputs,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<T, features_Arg> GraphOperation for Elu<T, features_Arg>
where T: TensorType,
      T: Clone,
      features_Arg: Clone,
      features_Arg: GraphEdge<T>,
      features_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
      T: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("Elu_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("Elu", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.features)?
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct Elu<T, features_Arg>
where T: TensorType,
      T: Clone,
      features_Arg: Clone,
      features_Arg: GraphEdge<T>,
      features_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    features: features_Arg,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<T, features_Arg> Elu<T, features_Arg>
where T: TensorType,
      T: Clone,
      features_Arg: Clone,
      features_Arg: GraphEdge<T>,
      features_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
      T: 'static,
{
    pub fn activations(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(features: features_Arg) -> Self {
        Self {
            phantom_T: PhantomData,
            features,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(features: features_Arg) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            features,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<T, gradients_Arg, features_Arg> GraphOperation for LeakyReluGrad<T, gradients_Arg, features_Arg>
where T: TensorType,
      T: Clone,
      gradients_Arg: Clone,
      gradients_Arg: GraphEdge<T>,
      gradients_Arg: 'static,
      features_Arg: Clone,
      features_Arg: GraphEdge<T>,
      features_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
      T: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("LeakyReluGrad_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("LeakyReluGrad", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.gradients)?
        }
        {
            new_op.add_edge(&self.features)?
        }
        {
            match self.alpha {
                None => new_op.set_attr_value_proto("alpha", &vec![37_u8, 205_u8, 204_u8, 76_u8, 62_u8,])?,
                Some(ref value) => (|attr: &f32| {new_op.set_attr_float("alpha", *attr)})(&value)?,
            };
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct LeakyReluGrad<T, gradients_Arg, features_Arg>
where T: TensorType,
      T: Clone,
      gradients_Arg: Clone,
      gradients_Arg: GraphEdge<T>,
      gradients_Arg: 'static,
      features_Arg: Clone,
      features_Arg: GraphEdge<T>,
      features_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    gradients: gradients_Arg,
    features: features_Arg,
    alpha: Option<f32>,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<T, gradients_Arg, features_Arg> LeakyReluGrad<T, gradients_Arg, features_Arg>
where T: TensorType,
      T: Clone,
      gradients_Arg: Clone,
      gradients_Arg: GraphEdge<T>,
      gradients_Arg: 'static,
      features_Arg: Clone,
      features_Arg: GraphEdge<T>,
      features_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
      T: 'static,
{
    pub fn backprops(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn alpha(&mut self, alpha: f32) -> Self {
        self.alpha = Some(alpha);
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(gradients: gradients_Arg, features: features_Arg) -> Self {
        Self {
            phantom_T: PhantomData,
            gradients,
            features,
            alpha: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(gradients: gradients_Arg, features: features_Arg) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            gradients,
            features,
            alpha: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<T, features_Arg> GraphOperation for LeakyRelu<T, features_Arg>
where T: TensorType,
      T: Clone,
      features_Arg: Clone,
      features_Arg: GraphEdge<T>,
      features_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
      T: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("LeakyRelu_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("LeakyRelu", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.features)?
        }
        {
            match self.alpha {
                None => new_op.set_attr_value_proto("alpha", &vec![37_u8, 205_u8, 204_u8, 76_u8, 62_u8,])?,
                Some(ref value) => (|attr: &f32| {new_op.set_attr_float("alpha", *attr)})(&value)?,
            };
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct LeakyRelu<T, features_Arg>
where T: TensorType,
      T: Clone,
      features_Arg: Clone,
      features_Arg: GraphEdge<T>,
      features_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    features: features_Arg,
    alpha: Option<f32>,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<T, features_Arg> LeakyRelu<T, features_Arg>
where T: TensorType,
      T: Clone,
      features_Arg: Clone,
      features_Arg: GraphEdge<T>,
      features_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
      T: 'static,
{
    pub fn activations(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn alpha(&mut self, alpha: f32) -> Self {
        self.alpha = Some(alpha);
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(features: features_Arg) -> Self {
        Self {
            phantom_T: PhantomData,
            features,
            alpha: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(features: features_Arg) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            features,
            alpha: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<T, gradients_Arg, features_Arg> GraphOperation for Relu6Grad<T, gradients_Arg, features_Arg>
where T: TensorType,
      T: Clone,
      gradients_Arg: Clone,
      gradients_Arg: GraphEdge<T>,
      gradients_Arg: 'static,
      features_Arg: Clone,
      features_Arg: GraphEdge<T>,
      features_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("Relu6Grad_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("Relu6Grad", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.gradients)?
        }
        {
            new_op.add_edge(&self.features)?
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct Relu6Grad<T, gradients_Arg, features_Arg>
where T: TensorType,
      T: Clone,
      gradients_Arg: Clone,
      gradients_Arg: GraphEdge<T>,
      gradients_Arg: 'static,
      features_Arg: Clone,
      features_Arg: GraphEdge<T>,
      features_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    gradients: gradients_Arg,
    features: features_Arg,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<T, gradients_Arg, features_Arg> Relu6Grad<T, gradients_Arg, features_Arg>
where T: TensorType,
      T: Clone,
      gradients_Arg: Clone,
      gradients_Arg: GraphEdge<T>,
      gradients_Arg: 'static,
      features_Arg: Clone,
      features_Arg: GraphEdge<T>,
      features_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
{
    pub fn backprops(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(gradients: gradients_Arg, features: features_Arg) -> Self {
        Self {
            phantom_T: PhantomData,
            gradients,
            features,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(gradients: gradients_Arg, features: features_Arg) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            gradients,
            features,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<T, features_Arg> GraphOperation for Relu6<T, features_Arg>
where T: TensorType,
      T: Clone,
      features_Arg: Clone,
      features_Arg: GraphEdge<T>,
      features_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("Relu6_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("Relu6", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.features)?
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct Relu6<T, features_Arg>
where T: TensorType,
      T: Clone,
      features_Arg: Clone,
      features_Arg: GraphEdge<T>,
      features_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    features: features_Arg,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<T, features_Arg> Relu6<T, features_Arg>
where T: TensorType,
      T: Clone,
      features_Arg: Clone,
      features_Arg: GraphEdge<T>,
      features_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
{
    pub fn activations(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(features: features_Arg) -> Self {
        Self {
            phantom_T: PhantomData,
            features,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(features: features_Arg) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            features,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<T, gradients_Arg, features_Arg> GraphOperation for ReluGrad<T, gradients_Arg, features_Arg>
where T: TensorType,
      T: Clone,
      gradients_Arg: Clone,
      gradients_Arg: GraphEdge<T>,
      gradients_Arg: 'static,
      features_Arg: Clone,
      features_Arg: GraphEdge<T>,
      features_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("ReluGrad_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("ReluGrad", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.gradients)?
        }
        {
            new_op.add_edge(&self.features)?
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct ReluGrad<T, gradients_Arg, features_Arg>
where T: TensorType,
      T: Clone,
      gradients_Arg: Clone,
      gradients_Arg: GraphEdge<T>,
      gradients_Arg: 'static,
      features_Arg: Clone,
      features_Arg: GraphEdge<T>,
      features_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    gradients: gradients_Arg,
    features: features_Arg,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<T, gradients_Arg, features_Arg> ReluGrad<T, gradients_Arg, features_Arg>
where T: TensorType,
      T: Clone,
      gradients_Arg: Clone,
      gradients_Arg: GraphEdge<T>,
      gradients_Arg: 'static,
      features_Arg: Clone,
      features_Arg: GraphEdge<T>,
      features_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
{
    pub fn backprops(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(gradients: gradients_Arg, features: features_Arg) -> Self {
        Self {
            phantom_T: PhantomData,
            gradients,
            features,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(gradients: gradients_Arg, features: features_Arg) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            gradients,
            features,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

pub trait con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_QINT8_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_QINT8_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64 for BFloat16 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_QINT8_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64 for f32 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_QINT8_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64 for f64 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_QINT8_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64 for i16 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_QINT8_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64 for i32 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_QINT8_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64 for i64 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_QINT8_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64 for i8 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_QINT8_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64 for u16 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_QINT8_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64 for u32 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_QINT8_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64 for u64 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_QINT8_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64 for u8 {
}

impl<T, features_Arg> GraphOperation for Relu<T, features_Arg>
where T: TensorType,
      T: Clone,
      features_Arg: Clone,
      features_Arg: GraphEdge<T>,
      features_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_QINT8_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("Relu_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("Relu", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.features)?
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct Relu<T, features_Arg>
where T: TensorType,
      T: Clone,
      features_Arg: Clone,
      features_Arg: GraphEdge<T>,
      features_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_QINT8_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    features: features_Arg,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<T, features_Arg> Relu<T, features_Arg>
where T: TensorType,
      T: Clone,
      features_Arg: Clone,
      features_Arg: GraphEdge<T>,
      features_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_QINT8_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
{
    pub fn activations(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(features: features_Arg) -> Self {
        Self {
            phantom_T: PhantomData,
            features,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(features: features_Arg) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            features,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<T, input_Arg, filter_Arg, out_backprop_Arg> GraphOperation for Dilation2DBackpropInput<T, input_Arg, filter_Arg, out_backprop_Arg>
where T: TensorType,
      T: Clone,
      input_Arg: Clone,
      input_Arg: GraphEdge<T>,
      input_Arg: 'static,
      filter_Arg: Clone,
      filter_Arg: GraphEdge<T>,
      filter_Arg: 'static,
      out_backprop_Arg: Clone,
      out_backprop_Arg: GraphEdge<T>,
      out_backprop_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("Dilation2DBackpropInput_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("Dilation2DBackpropInput", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.input)?
        }
        {
            new_op.add_edge(&self.filter)?
        }
        {
            new_op.add_edge(&self.out_backprop)?
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        {
            (|attrs| {new_op.set_attr_int_list("strides", attrs)})(&self.strides)?
        }
        {
            (|attrs| {new_op.set_attr_int_list("rates", attrs)})(&self.rates)?
        }
        {
            (|attr| {new_op.set_attr_string("padding", attr)})(&self.padding)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct Dilation2DBackpropInput<T, input_Arg, filter_Arg, out_backprop_Arg>
where T: TensorType,
      T: Clone,
      input_Arg: Clone,
      input_Arg: GraphEdge<T>,
      input_Arg: 'static,
      filter_Arg: Clone,
      filter_Arg: GraphEdge<T>,
      filter_Arg: 'static,
      out_backprop_Arg: Clone,
      out_backprop_Arg: GraphEdge<T>,
      out_backprop_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    input: input_Arg,
    filter: filter_Arg,
    out_backprop: out_backprop_Arg,
    strides: Vec<i64>,
    rates: Vec<i64>,
    padding: String,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<T, input_Arg, filter_Arg, out_backprop_Arg> Dilation2DBackpropInput<T, input_Arg, filter_Arg, out_backprop_Arg>
where T: TensorType,
      T: Clone,
      input_Arg: Clone,
      input_Arg: GraphEdge<T>,
      input_Arg: 'static,
      filter_Arg: Clone,
      filter_Arg: GraphEdge<T>,
      filter_Arg: 'static,
      out_backprop_Arg: Clone,
      out_backprop_Arg: GraphEdge<T>,
      out_backprop_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
{
    pub fn in_backprop(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(input: input_Arg, filter: filter_Arg, out_backprop: out_backprop_Arg, strides: &[i64], rates: &[i64], padding: &str) -> Self {
        Self {
            phantom_T: PhantomData,
            input,
            filter,
            out_backprop,
            strides: strides.to_vec(),
            rates: rates.to_vec(),
            padding: padding.to_string(),
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(input: input_Arg, filter: filter_Arg, out_backprop: out_backprop_Arg, strides: &[i64], rates: &[i64], padding: &str) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            input,
            filter,
            out_backprop,
            strides: strides.to_vec(),
            rates: rates.to_vec(),
            padding: padding.to_string(),
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<T, input_Arg, grad_Arg, Targmax, argmax_Arg> GraphOperation for MaxPoolGradGradWithArgmax<T, input_Arg, grad_Arg, Targmax, argmax_Arg>
where T: TensorType,
      T: Clone,
      input_Arg: Clone,
      input_Arg: GraphEdge<T>,
      input_Arg: 'static,
      grad_Arg: Clone,
      grad_Arg: GraphEdge<T>,
      grad_Arg: 'static,
      Targmax: TensorType,
      Targmax: Clone,
      argmax_Arg: Clone,
      argmax_Arg: GraphEdge<Targmax>,
      argmax_Arg: 'static,
      Targmax: con_or_DT_INT32_or_DT_INT64,
      Targmax: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("MaxPoolGradGradWithArgmax_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("MaxPoolGradGradWithArgmax", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.input)?
        }
        {
            new_op.add_edge(&self.grad)?
        }
        {
            new_op.add_edge(&self.argmax)?
        }
        {
            (|attrs| {new_op.set_attr_int_list("ksize", attrs)})(&self.ksize)?
        }
        {
            (|attrs| {new_op.set_attr_int_list("strides", attrs)})(&self.strides)?
        }
        {
            (|attr| {new_op.set_attr_string("padding", attr)})(&self.padding)?
        }
        {
            new_op.set_attr_type("Targmax", Targmax::data_type())?;
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct MaxPoolGradGradWithArgmax<T, input_Arg, grad_Arg, Targmax, argmax_Arg>
where T: TensorType,
      T: Clone,
      input_Arg: Clone,
      input_Arg: GraphEdge<T>,
      input_Arg: 'static,
      grad_Arg: Clone,
      grad_Arg: GraphEdge<T>,
      grad_Arg: 'static,
      Targmax: TensorType,
      Targmax: Clone,
      argmax_Arg: Clone,
      argmax_Arg: GraphEdge<Targmax>,
      argmax_Arg: 'static,
      Targmax: con_or_DT_INT32_or_DT_INT64,
      Targmax: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    input: input_Arg,
    grad: grad_Arg,
    phantom_Targmax: PhantomData<Targmax>,
    argmax: argmax_Arg,
    ksize: Vec<i64>,
    strides: Vec<i64>,
    padding: String,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<T, input_Arg, grad_Arg, Targmax, argmax_Arg> MaxPoolGradGradWithArgmax<T, input_Arg, grad_Arg, Targmax, argmax_Arg>
where T: TensorType,
      T: Clone,
      input_Arg: Clone,
      input_Arg: GraphEdge<T>,
      input_Arg: 'static,
      grad_Arg: Clone,
      grad_Arg: GraphEdge<T>,
      grad_Arg: 'static,
      Targmax: TensorType,
      Targmax: Clone,
      argmax_Arg: Clone,
      argmax_Arg: GraphEdge<Targmax>,
      argmax_Arg: 'static,
      Targmax: con_or_DT_INT32_or_DT_INT64,
      Targmax: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
{
    pub fn output(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(input: input_Arg, grad: grad_Arg, argmax: argmax_Arg, ksize: &[i64], strides: &[i64], padding: &str) -> Self {
        Self {
            phantom_T: PhantomData,
            input,
            grad,
            phantom_Targmax: PhantomData,
            argmax,
            ksize: ksize.to_vec(),
            strides: strides.to_vec(),
            padding: padding.to_string(),
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(input: input_Arg, grad: grad_Arg, argmax: argmax_Arg, ksize: &[i64], strides: &[i64], padding: &str) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            input,
            grad,
            phantom_Targmax: PhantomData,
            argmax,
            ksize: ksize.to_vec(),
            strides: strides.to_vec(),
            padding: padding.to_string(),
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<T, input_Arg, grad_Arg, Targmax, argmax_Arg> GraphOperation for MaxPoolGradWithArgmax<T, input_Arg, grad_Arg, Targmax, argmax_Arg>
where T: TensorType,
      T: Clone,
      input_Arg: Clone,
      input_Arg: GraphEdge<T>,
      input_Arg: 'static,
      grad_Arg: Clone,
      grad_Arg: GraphEdge<T>,
      grad_Arg: 'static,
      Targmax: TensorType,
      Targmax: Clone,
      argmax_Arg: Clone,
      argmax_Arg: GraphEdge<Targmax>,
      argmax_Arg: 'static,
      Targmax: con_or_DT_INT32_or_DT_INT64,
      Targmax: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("MaxPoolGradWithArgmax_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("MaxPoolGradWithArgmax", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.input)?
        }
        {
            new_op.add_edge(&self.grad)?
        }
        {
            new_op.add_edge(&self.argmax)?
        }
        {
            (|attrs| {new_op.set_attr_int_list("ksize", attrs)})(&self.ksize)?
        }
        {
            (|attrs| {new_op.set_attr_int_list("strides", attrs)})(&self.strides)?
        }
        {
            (|attr| {new_op.set_attr_string("padding", attr)})(&self.padding)?
        }
        {
            new_op.set_attr_type("Targmax", Targmax::data_type())?;
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct MaxPoolGradWithArgmax<T, input_Arg, grad_Arg, Targmax, argmax_Arg>
where T: TensorType,
      T: Clone,
      input_Arg: Clone,
      input_Arg: GraphEdge<T>,
      input_Arg: 'static,
      grad_Arg: Clone,
      grad_Arg: GraphEdge<T>,
      grad_Arg: 'static,
      Targmax: TensorType,
      Targmax: Clone,
      argmax_Arg: Clone,
      argmax_Arg: GraphEdge<Targmax>,
      argmax_Arg: 'static,
      Targmax: con_or_DT_INT32_or_DT_INT64,
      Targmax: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    input: input_Arg,
    grad: grad_Arg,
    phantom_Targmax: PhantomData<Targmax>,
    argmax: argmax_Arg,
    ksize: Vec<i64>,
    strides: Vec<i64>,
    padding: String,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<T, input_Arg, grad_Arg, Targmax, argmax_Arg> MaxPoolGradWithArgmax<T, input_Arg, grad_Arg, Targmax, argmax_Arg>
where T: TensorType,
      T: Clone,
      input_Arg: Clone,
      input_Arg: GraphEdge<T>,
      input_Arg: 'static,
      grad_Arg: Clone,
      grad_Arg: GraphEdge<T>,
      grad_Arg: 'static,
      Targmax: TensorType,
      Targmax: Clone,
      argmax_Arg: Clone,
      argmax_Arg: GraphEdge<Targmax>,
      argmax_Arg: 'static,
      Targmax: con_or_DT_INT32_or_DT_INT64,
      Targmax: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
{
    pub fn output(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(input: input_Arg, grad: grad_Arg, argmax: argmax_Arg, ksize: &[i64], strides: &[i64], padding: &str) -> Self {
        Self {
            phantom_T: PhantomData,
            input,
            grad,
            phantom_Targmax: PhantomData,
            argmax,
            ksize: ksize.to_vec(),
            strides: strides.to_vec(),
            padding: padding.to_string(),
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(input: input_Arg, grad: grad_Arg, argmax: argmax_Arg, ksize: &[i64], strides: &[i64], padding: &str) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            input,
            grad,
            phantom_Targmax: PhantomData,
            argmax,
            ksize: ksize.to_vec(),
            strides: strides.to_vec(),
            padding: padding.to_string(),
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<serialized_Arg, out_type> GraphOperation for ParseTensor<serialized_Arg, out_type>
where serialized_Arg: Clone,
      serialized_Arg: GraphEdge<String>,
      serialized_Arg: 'static,
      out_type: TensorType,
      out_type: 'static,
      out_type: Clone,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("ParseTensor_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("ParseTensor", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.serialized)?
        }
        {
            new_op.set_attr_type("out_type", out_type::data_type())?;
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct ParseTensor<serialized_Arg, out_type>
where serialized_Arg: Clone,
      serialized_Arg: GraphEdge<String>,
      serialized_Arg: 'static,
      out_type: TensorType,
      out_type: 'static,
      out_type: Clone,
{
    serialized: serialized_Arg,
    phantom_out_type: PhantomData<out_type>,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<serialized_Arg, out_type> ParseTensor<serialized_Arg, out_type>
where serialized_Arg: Clone,
      serialized_Arg: GraphEdge<String>,
      serialized_Arg: 'static,
      out_type: TensorType,
      out_type: 'static,
      out_type: Clone,
{
    pub fn output(self) -> Edge<out_type> {
        let rc = Rc::new(self);
        {
            Edge::<out_type>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<out_type> {
        let rc = Rc::new(self);
        {
            Edge::<out_type>::new(rc.clone(), 0)
        }
    }

    pub fn build(serialized: serialized_Arg) -> Self {
        Self {
            serialized,
            phantom_out_type: PhantomData,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(serialized: serialized_Arg) -> Edge<out_type> {
        Self {
            serialized,
            phantom_out_type: PhantomData,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<T, input_Arg, Targmax> GraphOperation for MaxPoolWithArgmax<T, input_Arg, Targmax>
where T: TensorType,
      T: Clone,
      input_Arg: Clone,
      input_Arg: GraphEdge<T>,
      input_Arg: 'static,
      Targmax: TensorType,
      Targmax: con_or_DT_INT32_or_DT_INT64,
      Targmax: 'static,
      Targmax: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("MaxPoolWithArgmax_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("MaxPoolWithArgmax", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.input)?
        }
        {
            (|attrs| {new_op.set_attr_int_list("ksize", attrs)})(&self.ksize)?
        }
        {
            (|attrs| {new_op.set_attr_int_list("strides", attrs)})(&self.strides)?
        }
        {
            new_op.set_attr_type("Targmax", Targmax::data_type())?;
        }
        {
            (|attr| {new_op.set_attr_string("padding", attr)})(&self.padding)?
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct MaxPoolWithArgmax<T, input_Arg, Targmax>
where T: TensorType,
      T: Clone,
      input_Arg: Clone,
      input_Arg: GraphEdge<T>,
      input_Arg: 'static,
      Targmax: TensorType,
      Targmax: con_or_DT_INT32_or_DT_INT64,
      Targmax: 'static,
      Targmax: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    input: input_Arg,
    ksize: Vec<i64>,
    strides: Vec<i64>,
    phantom_Targmax: PhantomData<Targmax>,
    padding: String,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<T, input_Arg, Targmax> MaxPoolWithArgmax<T, input_Arg, Targmax>
where T: TensorType,
      T: Clone,
      input_Arg: Clone,
      input_Arg: GraphEdge<T>,
      input_Arg: 'static,
      Targmax: TensorType,
      Targmax: con_or_DT_INT32_or_DT_INT64,
      Targmax: 'static,
      Targmax: Clone,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
{
    pub fn output(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn argmax(self) -> Edge<Targmax> {
        let rc = Rc::new(self);
        {
            Edge::<Targmax>::new(rc.clone(), 1)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> (Edge<T>, Edge<Targmax>) {
        let rc = Rc::new(self);
        (
        {
            Edge::<T>::new(rc.clone(), 0)
        },
        {
            Edge::<Targmax>::new(rc.clone(), 1)
        },
        )
    }

    pub fn build(input: input_Arg, ksize: &[i64], strides: &[i64], padding: &str) -> Self {
        Self {
            phantom_T: PhantomData,
            input,
            ksize: ksize.to_vec(),
            strides: strides.to_vec(),
            phantom_Targmax: PhantomData,
            padding: padding.to_string(),
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(input: input_Arg, ksize: &[i64], strides: &[i64], padding: &str) -> (Edge<T>, Edge<Targmax>) {
        Self {
            phantom_T: PhantomData,
            input,
            ksize: ksize.to_vec(),
            strides: strides.to_vec(),
            phantom_Targmax: PhantomData,
            padding: padding.to_string(),
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<T, orig_input_Arg, orig_output_Arg, grad_Arg, ksize_Arg, strides_Arg> GraphOperation for MaxPoolGradGradV2<T, orig_input_Arg, orig_output_Arg, grad_Arg, ksize_Arg, strides_Arg>
where T: TensorType,
      T: Clone,
      orig_input_Arg: Clone,
      orig_input_Arg: GraphEdge<T>,
      orig_input_Arg: 'static,
      orig_output_Arg: Clone,
      orig_output_Arg: GraphEdge<T>,
      orig_output_Arg: 'static,
      grad_Arg: Clone,
      grad_Arg: GraphEdge<T>,
      grad_Arg: 'static,
      ksize_Arg: Clone,
      ksize_Arg: GraphEdge<i32>,
      ksize_Arg: 'static,
      strides_Arg: Clone,
      strides_Arg: GraphEdge<i32>,
      strides_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("MaxPoolGradGradV2_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("MaxPoolGradGradV2", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.orig_input)?
        }
        {
            new_op.add_edge(&self.orig_output)?
        }
        {
            new_op.add_edge(&self.grad)?
        }
        {
            new_op.add_edge(&self.ksize)?
        }
        {
            new_op.add_edge(&self.strides)?
        }
        {
            (|attr| {new_op.set_attr_string("padding", attr)})(&self.padding)?
        }
        {
            match self.data_format {
                None => new_op.set_attr_value_proto("data_format", &vec![18_u8, 4_u8, 78_u8, 72_u8, 87_u8, 67_u8,])?,
                Some(ref value) => (|attr| {new_op.set_attr_string("data_format", attr)})(&value)?,
            };
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct MaxPoolGradGradV2<T, orig_input_Arg, orig_output_Arg, grad_Arg, ksize_Arg, strides_Arg>
where T: TensorType,
      T: Clone,
      orig_input_Arg: Clone,
      orig_input_Arg: GraphEdge<T>,
      orig_input_Arg: 'static,
      orig_output_Arg: Clone,
      orig_output_Arg: GraphEdge<T>,
      orig_output_Arg: 'static,
      grad_Arg: Clone,
      grad_Arg: GraphEdge<T>,
      grad_Arg: 'static,
      ksize_Arg: Clone,
      ksize_Arg: GraphEdge<i32>,
      ksize_Arg: 'static,
      strides_Arg: Clone,
      strides_Arg: GraphEdge<i32>,
      strides_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    orig_input: orig_input_Arg,
    orig_output: orig_output_Arg,
    grad: grad_Arg,
    ksize: ksize_Arg,
    strides: strides_Arg,
    padding: String,
    data_format: Option<String>,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<T, orig_input_Arg, orig_output_Arg, grad_Arg, ksize_Arg, strides_Arg> MaxPoolGradGradV2<T, orig_input_Arg, orig_output_Arg, grad_Arg, ksize_Arg, strides_Arg>
where T: TensorType,
      T: Clone,
      orig_input_Arg: Clone,
      orig_input_Arg: GraphEdge<T>,
      orig_input_Arg: 'static,
      orig_output_Arg: Clone,
      orig_output_Arg: GraphEdge<T>,
      orig_output_Arg: 'static,
      grad_Arg: Clone,
      grad_Arg: GraphEdge<T>,
      grad_Arg: 'static,
      ksize_Arg: Clone,
      ksize_Arg: GraphEdge<i32>,
      ksize_Arg: 'static,
      strides_Arg: Clone,
      strides_Arg: GraphEdge<i32>,
      strides_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
{
    pub fn output(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn data_format(&mut self, data_format: &str) -> Self {
        self.data_format = Some(data_format.to_string());
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(orig_input: orig_input_Arg, orig_output: orig_output_Arg, grad: grad_Arg, ksize: ksize_Arg, strides: strides_Arg, padding: &str) -> Self {
        Self {
            phantom_T: PhantomData,
            orig_input,
            orig_output,
            grad,
            ksize,
            strides,
            padding: padding.to_string(),
            data_format: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(orig_input: orig_input_Arg, orig_output: orig_output_Arg, grad: grad_Arg, ksize: ksize_Arg, strides: strides_Arg, padding: &str) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            orig_input,
            orig_output,
            grad,
            ksize,
            strides,
            padding: padding.to_string(),
            data_format: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<T, orig_input_Arg, orig_output_Arg, grad_Arg> GraphOperation for MaxPoolGrad<T, orig_input_Arg, orig_output_Arg, grad_Arg>
where T: TensorType,
      T: Clone,
      orig_input_Arg: Clone,
      orig_input_Arg: GraphEdge<T>,
      orig_input_Arg: 'static,
      orig_output_Arg: Clone,
      orig_output_Arg: GraphEdge<T>,
      orig_output_Arg: 'static,
      grad_Arg: Clone,
      grad_Arg: GraphEdge<T>,
      grad_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("MaxPoolGrad_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("MaxPoolGrad", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.orig_input)?
        }
        {
            new_op.add_edge(&self.orig_output)?
        }
        {
            new_op.add_edge(&self.grad)?
        }
        {
            (|attrs| {new_op.set_attr_int_list("ksize", attrs)})(&self.ksize)?
        }
        {
            (|attrs| {new_op.set_attr_int_list("strides", attrs)})(&self.strides)?
        }
        {
            (|attr| {new_op.set_attr_string("padding", attr)})(&self.padding)?
        }
        {
            match self.data_format {
                None => new_op.set_attr_value_proto("data_format", &vec![18_u8, 4_u8, 78_u8, 72_u8, 87_u8, 67_u8,])?,
                Some(ref value) => (|attr| {new_op.set_attr_string("data_format", attr)})(&value)?,
            };
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct MaxPoolGrad<T, orig_input_Arg, orig_output_Arg, grad_Arg>
where T: TensorType,
      T: Clone,
      orig_input_Arg: Clone,
      orig_input_Arg: GraphEdge<T>,
      orig_input_Arg: 'static,
      orig_output_Arg: Clone,
      orig_output_Arg: GraphEdge<T>,
      orig_output_Arg: 'static,
      grad_Arg: Clone,
      grad_Arg: GraphEdge<T>,
      grad_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    orig_input: orig_input_Arg,
    orig_output: orig_output_Arg,
    grad: grad_Arg,
    ksize: Vec<i64>,
    strides: Vec<i64>,
    padding: String,
    data_format: Option<String>,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<T, orig_input_Arg, orig_output_Arg, grad_Arg> MaxPoolGrad<T, orig_input_Arg, orig_output_Arg, grad_Arg>
where T: TensorType,
      T: Clone,
      orig_input_Arg: Clone,
      orig_input_Arg: GraphEdge<T>,
      orig_input_Arg: 'static,
      orig_output_Arg: Clone,
      orig_output_Arg: GraphEdge<T>,
      orig_output_Arg: 'static,
      grad_Arg: Clone,
      grad_Arg: GraphEdge<T>,
      grad_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
{
    pub fn output(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn data_format(&mut self, data_format: &str) -> Self {
        self.data_format = Some(data_format.to_string());
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(orig_input: orig_input_Arg, orig_output: orig_output_Arg, grad: grad_Arg, ksize: &[i64], strides: &[i64], padding: &str) -> Self {
        Self {
            phantom_T: PhantomData,
            orig_input,
            orig_output,
            grad,
            ksize: ksize.to_vec(),
            strides: strides.to_vec(),
            padding: padding.to_string(),
            data_format: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(orig_input: orig_input_Arg, orig_output: orig_output_Arg, grad: grad_Arg, ksize: &[i64], strides: &[i64], padding: &str) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            orig_input,
            orig_output,
            grad,
            ksize: ksize.to_vec(),
            strides: strides.to_vec(),
            padding: padding.to_string(),
            data_format: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

pub trait con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_QINT8_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_QINT8_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF for BFloat16 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_QINT8_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF for f32 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_QINT8_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF for f64 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_QINT8_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF for i16 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_QINT8_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF for i32 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_QINT8_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF for i64 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_QINT8_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF for i8 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_QINT8_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF for u16 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_QINT8_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF for u8 {
}

impl<T, input_Arg> GraphOperation for MaxPool<T, input_Arg>
where T: TensorType,
      T: Clone,
      input_Arg: Clone,
      input_Arg: GraphEdge<T>,
      input_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_QINT8_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF,
      T: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("MaxPool_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("MaxPool", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.input)?
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        {
            (|attrs| {new_op.set_attr_int_list("ksize", attrs)})(&self.ksize)?
        }
        {
            (|attrs| {new_op.set_attr_int_list("strides", attrs)})(&self.strides)?
        }
        {
            (|attr| {new_op.set_attr_string("padding", attr)})(&self.padding)?
        }
        {
            match self.data_format {
                None => new_op.set_attr_value_proto("data_format", &vec![18_u8, 4_u8, 78_u8, 72_u8, 87_u8, 67_u8,])?,
                Some(ref value) => (|attr| {new_op.set_attr_string("data_format", attr)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct MaxPool<T, input_Arg>
where T: TensorType,
      T: Clone,
      input_Arg: Clone,
      input_Arg: GraphEdge<T>,
      input_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_QINT8_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    input: input_Arg,
    ksize: Vec<i64>,
    strides: Vec<i64>,
    padding: String,
    data_format: Option<String>,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<T, input_Arg> MaxPool<T, input_Arg>
where T: TensorType,
      T: Clone,
      input_Arg: Clone,
      input_Arg: GraphEdge<T>,
      input_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_QINT8_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF,
      T: 'static,
{
    pub fn output(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn data_format(&mut self, data_format: &str) -> Self {
        self.data_format = Some(data_format.to_string());
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(input: input_Arg, ksize: &[i64], strides: &[i64], padding: &str) -> Self {
        Self {
            phantom_T: PhantomData,
            input,
            ksize: ksize.to_vec(),
            strides: strides.to_vec(),
            padding: padding.to_string(),
            data_format: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(input: input_Arg, ksize: &[i64], strides: &[i64], padding: &str) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            input,
            ksize: ksize.to_vec(),
            strides: strides.to_vec(),
            padding: padding.to_string(),
            data_format: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

pub trait con_or_DT_FLOAT_or_DT_BFLOAT16_or_DT_HALF {
}

impl con_or_DT_FLOAT_or_DT_BFLOAT16_or_DT_HALF for BFloat16 {
}

impl con_or_DT_FLOAT_or_DT_BFLOAT16_or_DT_HALF for f32 {
}

impl<T, input_Arg> GraphOperation for LRN<T, input_Arg>
where T: TensorType,
      T: Clone,
      input_Arg: Clone,
      input_Arg: GraphEdge<T>,
      input_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_BFLOAT16_or_DT_HALF,
      T: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("LRN_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("LRN", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.input)?
        }
        {
            match self.depth_radius {
                None => new_op.set_attr_value_proto("depth_radius", &vec![24_u8, 5_u8,])?,
                Some(ref value) => (|attr: &i64| {new_op.set_attr_int("depth_radius", *attr)})(&value)?,
            };
        }
        {
            match self.bias {
                None => new_op.set_attr_value_proto("bias", &vec![37_u8, 0_u8, 0_u8, 128_u8, 63_u8,])?,
                Some(ref value) => (|attr: &f32| {new_op.set_attr_float("bias", *attr)})(&value)?,
            };
        }
        {
            match self.alpha {
                None => new_op.set_attr_value_proto("alpha", &vec![37_u8, 0_u8, 0_u8, 128_u8, 63_u8,])?,
                Some(ref value) => (|attr: &f32| {new_op.set_attr_float("alpha", *attr)})(&value)?,
            };
        }
        {
            match self.beta {
                None => new_op.set_attr_value_proto("beta", &vec![37_u8, 0_u8, 0_u8, 0_u8, 63_u8,])?,
                Some(ref value) => (|attr: &f32| {new_op.set_attr_float("beta", *attr)})(&value)?,
            };
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct LRN<T, input_Arg>
where T: TensorType,
      T: Clone,
      input_Arg: Clone,
      input_Arg: GraphEdge<T>,
      input_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_BFLOAT16_or_DT_HALF,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    input: input_Arg,
    depth_radius: Option<i64>,
    bias: Option<f32>,
    alpha: Option<f32>,
    beta: Option<f32>,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<T, input_Arg> LRN<T, input_Arg>
where T: TensorType,
      T: Clone,
      input_Arg: Clone,
      input_Arg: GraphEdge<T>,
      input_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_BFLOAT16_or_DT_HALF,
      T: 'static,
{
    pub fn output(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn depth_radius(&mut self, depth_radius: i64) -> Self {
        self.depth_radius = Some(depth_radius);
        self.clone()
    }

    pub fn bias(&mut self, bias: f32) -> Self {
        self.bias = Some(bias);
        self.clone()
    }

    pub fn alpha(&mut self, alpha: f32) -> Self {
        self.alpha = Some(alpha);
        self.clone()
    }

    pub fn beta(&mut self, beta: f32) -> Self {
        self.beta = Some(beta);
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(input: input_Arg) -> Self {
        Self {
            phantom_T: PhantomData,
            input,
            depth_radius: None,
            bias: None,
            alpha: None,
            beta: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(input: input_Arg) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            input,
            depth_radius: None,
            bias: None,
            alpha: None,
            beta: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<T, set1_Arg, set2_indices_Arg, set2_values_Arg, set2_shape_Arg> GraphOperation for DenseToSparseSetOperation<T, set1_Arg, set2_indices_Arg, set2_values_Arg, set2_shape_Arg>
where T: TensorType,
      T: Clone,
      set1_Arg: Clone,
      set1_Arg: GraphEdge<T>,
      set1_Arg: 'static,
      set2_indices_Arg: Clone,
      set2_indices_Arg: GraphEdge<i64>,
      set2_indices_Arg: 'static,
      set2_values_Arg: Clone,
      set2_values_Arg: GraphEdge<T>,
      set2_values_Arg: 'static,
      set2_shape_Arg: Clone,
      set2_shape_Arg: GraphEdge<i64>,
      set2_shape_Arg: 'static,
      T: con_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_STRING_or_DT_INT64_or_DT_UINT16,
      T: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("DenseToSparseSetOperation_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("DenseToSparseSetOperation", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.set1)?
        }
        {
            new_op.add_edge(&self.set2_indices)?
        }
        {
            new_op.add_edge(&self.set2_values)?
        }
        {
            new_op.add_edge(&self.set2_shape)?
        }
        {
            (|attr| {new_op.set_attr_string("set_operation", attr)})(&self.set_operation)?
        }
        {
            match self.validate_indices {
                None => new_op.set_attr_value_proto("validate_indices", &vec![40_u8, 1_u8,])?,
                Some(ref value) => (|attr: &bool| {new_op.set_attr_bool("validate_indices", *attr)})(&value)?,
            };
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct DenseToSparseSetOperation<T, set1_Arg, set2_indices_Arg, set2_values_Arg, set2_shape_Arg>
where T: TensorType,
      T: Clone,
      set1_Arg: Clone,
      set1_Arg: GraphEdge<T>,
      set1_Arg: 'static,
      set2_indices_Arg: Clone,
      set2_indices_Arg: GraphEdge<i64>,
      set2_indices_Arg: 'static,
      set2_values_Arg: Clone,
      set2_values_Arg: GraphEdge<T>,
      set2_values_Arg: 'static,
      set2_shape_Arg: Clone,
      set2_shape_Arg: GraphEdge<i64>,
      set2_shape_Arg: 'static,
      T: con_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_STRING_or_DT_INT64_or_DT_UINT16,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    set1: set1_Arg,
    set2_indices: set2_indices_Arg,
    set2_values: set2_values_Arg,
    set2_shape: set2_shape_Arg,
    set_operation: String,
    validate_indices: Option<bool>,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<T, set1_Arg, set2_indices_Arg, set2_values_Arg, set2_shape_Arg> DenseToSparseSetOperation<T, set1_Arg, set2_indices_Arg, set2_values_Arg, set2_shape_Arg>
where T: TensorType,
      T: Clone,
      set1_Arg: Clone,
      set1_Arg: GraphEdge<T>,
      set1_Arg: 'static,
      set2_indices_Arg: Clone,
      set2_indices_Arg: GraphEdge<i64>,
      set2_indices_Arg: 'static,
      set2_values_Arg: Clone,
      set2_values_Arg: GraphEdge<T>,
      set2_values_Arg: 'static,
      set2_shape_Arg: Clone,
      set2_shape_Arg: GraphEdge<i64>,
      set2_shape_Arg: 'static,
      T: con_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_STRING_or_DT_INT64_or_DT_UINT16,
      T: 'static,
{
    pub fn result_indices(self) -> Edge<i64> {
        let rc = Rc::new(self);
        {
            Edge::<i64>::new(rc.clone(), 0)
        }
    }

    pub fn result_values(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 1)
        }
    }

    pub fn result_shape(self) -> Edge<i64> {
        let rc = Rc::new(self);
        {
            Edge::<i64>::new(rc.clone(), 2)
        }
    }

    pub fn validate_indices(&mut self, validate_indices: bool) -> Self {
        self.validate_indices = Some(validate_indices);
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> (Edge<i64>, Edge<T>, Edge<i64>) {
        let rc = Rc::new(self);
        (
        {
            Edge::<i64>::new(rc.clone(), 0)
        },
        {
            Edge::<T>::new(rc.clone(), 1)
        },
        {
            Edge::<i64>::new(rc.clone(), 2)
        },
        )
    }

    pub fn build(set1: set1_Arg, set2_indices: set2_indices_Arg, set2_values: set2_values_Arg, set2_shape: set2_shape_Arg, set_operation: &str) -> Self {
        Self {
            phantom_T: PhantomData,
            set1,
            set2_indices,
            set2_values,
            set2_shape,
            set_operation: set_operation.to_string(),
            validate_indices: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(set1: set1_Arg, set2_indices: set2_indices_Arg, set2_values: set2_values_Arg, set2_shape: set2_shape_Arg, set_operation: &str) -> (Edge<i64>, Edge<T>, Edge<i64>) {
        Self {
            phantom_T: PhantomData,
            set1,
            set2_indices,
            set2_values,
            set2_shape,
            set_operation: set_operation.to_string(),
            validate_indices: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<T, t_Arg> GraphOperation for L2Loss<T, t_Arg>
where T: TensorType,
      T: Clone,
      t_Arg: Clone,
      t_Arg: GraphEdge<T>,
      t_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
      T: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("L2Loss_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("L2Loss", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.t)?
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct L2Loss<T, t_Arg>
where T: TensorType,
      T: Clone,
      t_Arg: Clone,
      t_Arg: GraphEdge<T>,
      t_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    t: t_Arg,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<T, t_Arg> L2Loss<T, t_Arg>
where T: TensorType,
      T: Clone,
      t_Arg: Clone,
      t_Arg: GraphEdge<T>,
      t_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
      T: 'static,
{
    pub fn output(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(t: t_Arg) -> Self {
        Self {
            phantom_T: PhantomData,
            t,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(t: t_Arg) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            t,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<TInput, orig_input_Arg, orig_output_Arg, T, grad_Arg> GraphOperation for MaxPool3DGrad<TInput, orig_input_Arg, orig_output_Arg, T, grad_Arg>
where TInput: TensorType,
      TInput: Clone,
      orig_input_Arg: Clone,
      orig_input_Arg: GraphEdge<TInput>,
      orig_input_Arg: 'static,
      orig_output_Arg: Clone,
      orig_output_Arg: GraphEdge<TInput>,
      orig_output_Arg: 'static,
      T: TensorType,
      T: Clone,
      grad_Arg: Clone,
      grad_Arg: GraphEdge<T>,
      grad_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_BFLOAT16_or_DT_HALF,
      T: 'static,
      TInput: con_or_DT_FLOAT_or_DT_BFLOAT16_or_DT_HALF,
      TInput: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("MaxPool3DGrad_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("MaxPool3DGrad", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.orig_input)?
        }
        {
            new_op.add_edge(&self.orig_output)?
        }
        {
            new_op.add_edge(&self.grad)?
        }
        {
            (|attrs| {new_op.set_attr_int_list("ksize", attrs)})(&self.ksize)?
        }
        {
            (|attrs| {new_op.set_attr_int_list("strides", attrs)})(&self.strides)?
        }
        {
            (|attr| {new_op.set_attr_string("padding", attr)})(&self.padding)?
        }
        {
            match self.data_format {
                None => new_op.set_attr_value_proto("data_format", &vec![18_u8, 5_u8, 78_u8, 68_u8, 72_u8, 87_u8, 67_u8,])?,
                Some(ref value) => (|attr| {new_op.set_attr_string("data_format", attr)})(&value)?,
            };
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        {
            new_op.set_attr_type("TInput", TInput::data_type())?;
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct MaxPool3DGrad<TInput, orig_input_Arg, orig_output_Arg, T, grad_Arg>
where TInput: TensorType,
      TInput: Clone,
      orig_input_Arg: Clone,
      orig_input_Arg: GraphEdge<TInput>,
      orig_input_Arg: 'static,
      orig_output_Arg: Clone,
      orig_output_Arg: GraphEdge<TInput>,
      orig_output_Arg: 'static,
      T: TensorType,
      T: Clone,
      grad_Arg: Clone,
      grad_Arg: GraphEdge<T>,
      grad_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_BFLOAT16_or_DT_HALF,
      T: 'static,
      TInput: con_or_DT_FLOAT_or_DT_BFLOAT16_or_DT_HALF,
      TInput: 'static,
{
    phantom_TInput: PhantomData<TInput>,
    orig_input: orig_input_Arg,
    orig_output: orig_output_Arg,
    phantom_T: PhantomData<T>,
    grad: grad_Arg,
    ksize: Vec<i64>,
    strides: Vec<i64>,
    padding: String,
    data_format: Option<String>,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<TInput, orig_input_Arg, orig_output_Arg, T, grad_Arg> MaxPool3DGrad<TInput, orig_input_Arg, orig_output_Arg, T, grad_Arg>
where TInput: TensorType,
      TInput: Clone,
      orig_input_Arg: Clone,
      orig_input_Arg: GraphEdge<TInput>,
      orig_input_Arg: 'static,
      orig_output_Arg: Clone,
      orig_output_Arg: GraphEdge<TInput>,
      orig_output_Arg: 'static,
      T: TensorType,
      T: Clone,
      grad_Arg: Clone,
      grad_Arg: GraphEdge<T>,
      grad_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_BFLOAT16_or_DT_HALF,
      T: 'static,
      TInput: con_or_DT_FLOAT_or_DT_BFLOAT16_or_DT_HALF,
      TInput: 'static,
{
    pub fn output(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn data_format(&mut self, data_format: &str) -> Self {
        self.data_format = Some(data_format.to_string());
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(orig_input: orig_input_Arg, orig_output: orig_output_Arg, grad: grad_Arg, ksize: &[i64], strides: &[i64], padding: &str) -> Self {
        Self {
            phantom_TInput: PhantomData,
            orig_input,
            orig_output,
            phantom_T: PhantomData,
            grad,
            ksize: ksize.to_vec(),
            strides: strides.to_vec(),
            padding: padding.to_string(),
            data_format: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(orig_input: orig_input_Arg, orig_output: orig_output_Arg, grad: grad_Arg, ksize: &[i64], strides: &[i64], padding: &str) -> Edge<T> {
        Self {
            phantom_TInput: PhantomData,
            orig_input,
            orig_output,
            phantom_T: PhantomData,
            grad,
            ksize: ksize.to_vec(),
            strides: strides.to_vec(),
            padding: padding.to_string(),
            data_format: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<T, var_Arg, alpha_Arg, delta_Arg> GraphOperation for ApplyGradientDescent<T, var_Arg, alpha_Arg, delta_Arg>
where T: TensorType,
      T: Clone,
      var_Arg: Clone,
      var_Arg: GraphRefEdge<T>,
      var_Arg: 'static,
      alpha_Arg: Clone,
      alpha_Arg: GraphEdge<T>,
      alpha_Arg: 'static,
      delta_Arg: Clone,
      delta_Arg: GraphEdge<T>,
      delta_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("ApplyGradientDescent_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("ApplyGradientDescent", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.var)?
        }
        {
            new_op.add_edge(&self.alpha)?
        }
        {
            new_op.add_edge(&self.delta)?
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        {
            match self.use_locking {
                None => new_op.set_attr_value_proto("use_locking", &vec![40_u8, 0_u8,])?,
                Some(ref value) => (|attr: &bool| {new_op.set_attr_bool("use_locking", *attr)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct ApplyGradientDescent<T, var_Arg, alpha_Arg, delta_Arg>
where T: TensorType,
      T: Clone,
      var_Arg: Clone,
      var_Arg: GraphRefEdge<T>,
      var_Arg: 'static,
      alpha_Arg: Clone,
      alpha_Arg: GraphEdge<T>,
      alpha_Arg: 'static,
      delta_Arg: Clone,
      delta_Arg: GraphEdge<T>,
      delta_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    var: var_Arg,
    alpha: alpha_Arg,
    delta: delta_Arg,
    use_locking: Option<bool>,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<T, var_Arg, alpha_Arg, delta_Arg> ApplyGradientDescent<T, var_Arg, alpha_Arg, delta_Arg>
where T: TensorType,
      T: Clone,
      var_Arg: Clone,
      var_Arg: GraphRefEdge<T>,
      var_Arg: 'static,
      alpha_Arg: Clone,
      alpha_Arg: GraphEdge<T>,
      alpha_Arg: 'static,
      delta_Arg: Clone,
      delta_Arg: GraphEdge<T>,
      delta_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
{
    pub fn out(self) -> RefEdge<T> {
        let rc = Rc::new(self);
        {
            RefEdge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn use_locking(&mut self, use_locking: bool) -> Self {
        self.use_locking = Some(use_locking);
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> RefEdge<T> {
        let rc = Rc::new(self);
        {
            RefEdge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(var: var_Arg, alpha: alpha_Arg, delta: delta_Arg) -> Self {
        Self {
            phantom_T: PhantomData,
            var,
            alpha,
            delta,
            use_locking: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(var: var_Arg, alpha: alpha_Arg, delta: delta_Arg) -> RefEdge<T> {
        Self {
            phantom_T: PhantomData,
            var,
            alpha,
            delta,
            use_locking: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<T, input_Arg> GraphOperation for MaxPool3D<T, input_Arg>
where T: TensorType,
      T: Clone,
      input_Arg: Clone,
      input_Arg: GraphEdge<T>,
      input_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_BFLOAT16_or_DT_HALF,
      T: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("MaxPool3D_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("MaxPool3D", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.input)?
        }
        {
            (|attrs| {new_op.set_attr_int_list("ksize", attrs)})(&self.ksize)?
        }
        {
            (|attrs| {new_op.set_attr_int_list("strides", attrs)})(&self.strides)?
        }
        {
            (|attr| {new_op.set_attr_string("padding", attr)})(&self.padding)?
        }
        {
            match self.data_format {
                None => new_op.set_attr_value_proto("data_format", &vec![18_u8, 5_u8, 78_u8, 68_u8, 72_u8, 87_u8, 67_u8,])?,
                Some(ref value) => (|attr| {new_op.set_attr_string("data_format", attr)})(&value)?,
            };
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct MaxPool3D<T, input_Arg>
where T: TensorType,
      T: Clone,
      input_Arg: Clone,
      input_Arg: GraphEdge<T>,
      input_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_BFLOAT16_or_DT_HALF,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    input: input_Arg,
    ksize: Vec<i64>,
    strides: Vec<i64>,
    padding: String,
    data_format: Option<String>,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<T, input_Arg> MaxPool3D<T, input_Arg>
where T: TensorType,
      T: Clone,
      input_Arg: Clone,
      input_Arg: GraphEdge<T>,
      input_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_BFLOAT16_or_DT_HALF,
      T: 'static,
{
    pub fn output(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn data_format(&mut self, data_format: &str) -> Self {
        self.data_format = Some(data_format.to_string());
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(input: input_Arg, ksize: &[i64], strides: &[i64], padding: &str) -> Self {
        Self {
            phantom_T: PhantomData,
            input,
            ksize: ksize.to_vec(),
            strides: strides.to_vec(),
            padding: padding.to_string(),
            data_format: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(input: input_Arg, ksize: &[i64], strides: &[i64], padding: &str) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            input,
            ksize: ksize.to_vec(),
            strides: strides.to_vec(),
            padding: padding.to_string(),
            data_format: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<T, input_Arg> GraphOperation for AvgPool3D<T, input_Arg>
where T: TensorType,
      T: Clone,
      input_Arg: Clone,
      input_Arg: GraphEdge<T>,
      input_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
      T: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("AvgPool3D_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("AvgPool3D", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.input)?
        }
        {
            (|attrs| {new_op.set_attr_int_list("ksize", attrs)})(&self.ksize)?
        }
        {
            (|attrs| {new_op.set_attr_int_list("strides", attrs)})(&self.strides)?
        }
        {
            (|attr| {new_op.set_attr_string("padding", attr)})(&self.padding)?
        }
        {
            match self.data_format {
                None => new_op.set_attr_value_proto("data_format", &vec![18_u8, 5_u8, 78_u8, 68_u8, 72_u8, 87_u8, 67_u8,])?,
                Some(ref value) => (|attr| {new_op.set_attr_string("data_format", attr)})(&value)?,
            };
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct AvgPool3D<T, input_Arg>
where T: TensorType,
      T: Clone,
      input_Arg: Clone,
      input_Arg: GraphEdge<T>,
      input_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    input: input_Arg,
    ksize: Vec<i64>,
    strides: Vec<i64>,
    padding: String,
    data_format: Option<String>,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<T, input_Arg> AvgPool3D<T, input_Arg>
where T: TensorType,
      T: Clone,
      input_Arg: Clone,
      input_Arg: GraphEdge<T>,
      input_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
      T: 'static,
{
    pub fn output(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn data_format(&mut self, data_format: &str) -> Self {
        self.data_format = Some(data_format.to_string());
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(input: input_Arg, ksize: &[i64], strides: &[i64], padding: &str) -> Self {
        Self {
            phantom_T: PhantomData,
            input,
            ksize: ksize.to_vec(),
            strides: strides.to_vec(),
            padding: padding.to_string(),
            data_format: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(input: input_Arg, ksize: &[i64], strides: &[i64], padding: &str) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            input,
            ksize: ksize.to_vec(),
            strides: strides.to_vec(),
            padding: padding.to_string(),
            data_format: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<T, orig_input_Arg, orig_output_Arg, grad_Arg> GraphOperation for MaxPool3DGradGrad<T, orig_input_Arg, orig_output_Arg, grad_Arg>
where T: TensorType,
      T: Clone,
      orig_input_Arg: Clone,
      orig_input_Arg: GraphEdge<T>,
      orig_input_Arg: 'static,
      orig_output_Arg: Clone,
      orig_output_Arg: GraphEdge<T>,
      orig_output_Arg: 'static,
      grad_Arg: Clone,
      grad_Arg: GraphEdge<T>,
      grad_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("MaxPool3DGradGrad_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("MaxPool3DGradGrad", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.orig_input)?
        }
        {
            new_op.add_edge(&self.orig_output)?
        }
        {
            new_op.add_edge(&self.grad)?
        }
        {
            (|attrs| {new_op.set_attr_int_list("ksize", attrs)})(&self.ksize)?
        }
        {
            (|attrs| {new_op.set_attr_int_list("strides", attrs)})(&self.strides)?
        }
        {
            (|attr| {new_op.set_attr_string("padding", attr)})(&self.padding)?
        }
        {
            match self.data_format {
                None => new_op.set_attr_value_proto("data_format", &vec![18_u8, 5_u8, 78_u8, 68_u8, 72_u8, 87_u8, 67_u8,])?,
                Some(ref value) => (|attr| {new_op.set_attr_string("data_format", attr)})(&value)?,
            };
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct MaxPool3DGradGrad<T, orig_input_Arg, orig_output_Arg, grad_Arg>
where T: TensorType,
      T: Clone,
      orig_input_Arg: Clone,
      orig_input_Arg: GraphEdge<T>,
      orig_input_Arg: 'static,
      orig_output_Arg: Clone,
      orig_output_Arg: GraphEdge<T>,
      orig_output_Arg: 'static,
      grad_Arg: Clone,
      grad_Arg: GraphEdge<T>,
      grad_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    orig_input: orig_input_Arg,
    orig_output: orig_output_Arg,
    grad: grad_Arg,
    ksize: Vec<i64>,
    strides: Vec<i64>,
    padding: String,
    data_format: Option<String>,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<T, orig_input_Arg, orig_output_Arg, grad_Arg> MaxPool3DGradGrad<T, orig_input_Arg, orig_output_Arg, grad_Arg>
where T: TensorType,
      T: Clone,
      orig_input_Arg: Clone,
      orig_input_Arg: GraphEdge<T>,
      orig_input_Arg: 'static,
      orig_output_Arg: Clone,
      orig_output_Arg: GraphEdge<T>,
      orig_output_Arg: 'static,
      grad_Arg: Clone,
      grad_Arg: GraphEdge<T>,
      grad_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
{
    pub fn output(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn data_format(&mut self, data_format: &str) -> Self {
        self.data_format = Some(data_format.to_string());
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(orig_input: orig_input_Arg, orig_output: orig_output_Arg, grad: grad_Arg, ksize: &[i64], strides: &[i64], padding: &str) -> Self {
        Self {
            phantom_T: PhantomData,
            orig_input,
            orig_output,
            grad,
            ksize: ksize.to_vec(),
            strides: strides.to_vec(),
            padding: padding.to_string(),
            data_format: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(orig_input: orig_input_Arg, orig_output: orig_output_Arg, grad: grad_Arg, ksize: &[i64], strides: &[i64], padding: &str) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            orig_input,
            orig_output,
            grad,
            ksize: ksize.to_vec(),
            strides: strides.to_vec(),
            padding: padding.to_string(),
            data_format: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<T, input_Arg, filter_sizes_Arg, out_backprop_Arg> GraphOperation for Conv3DBackpropFilterV2<T, input_Arg, filter_sizes_Arg, out_backprop_Arg>
where T: TensorType,
      T: Clone,
      input_Arg: Clone,
      input_Arg: GraphEdge<T>,
      input_Arg: 'static,
      filter_sizes_Arg: Clone,
      filter_sizes_Arg: GraphEdge<i32>,
      filter_sizes_Arg: 'static,
      out_backprop_Arg: Clone,
      out_backprop_Arg: GraphEdge<T>,
      out_backprop_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
      T: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("Conv3DBackpropFilterV2_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("Conv3DBackpropFilterV2", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.input)?
        }
        {
            new_op.add_edge(&self.filter_sizes)?
        }
        {
            new_op.add_edge(&self.out_backprop)?
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        {
            (|attrs| {new_op.set_attr_int_list("strides", attrs)})(&self.strides)?
        }
        {
            (|attr| {new_op.set_attr_string("padding", attr)})(&self.padding)?
        }
        {
            match self.data_format {
                None => new_op.set_attr_value_proto("data_format", &vec![18_u8, 5_u8, 78_u8, 68_u8, 72_u8, 87_u8, 67_u8,])?,
                Some(ref value) => (|attr| {new_op.set_attr_string("data_format", attr)})(&value)?,
            };
        }
        {
            match self.dilations {
                None => new_op.set_attr_value_proto("dilations", &vec![10_u8, 0_u8, 26_u8, 5_u8, 1_u8, 1_u8, 1_u8, 1_u8,])?,
                Some(ref value) => (|attrs| {new_op.set_attr_int_list("dilations", attrs)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct Conv3DBackpropFilterV2<T, input_Arg, filter_sizes_Arg, out_backprop_Arg>
where T: TensorType,
      T: Clone,
      input_Arg: Clone,
      input_Arg: GraphEdge<T>,
      input_Arg: 'static,
      filter_sizes_Arg: Clone,
      filter_sizes_Arg: GraphEdge<i32>,
      filter_sizes_Arg: 'static,
      out_backprop_Arg: Clone,
      out_backprop_Arg: GraphEdge<T>,
      out_backprop_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    input: input_Arg,
    filter_sizes: filter_sizes_Arg,
    out_backprop: out_backprop_Arg,
    strides: Vec<i64>,
    padding: String,
    data_format: Option<String>,
    dilations: Option<Vec<i64>>,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<T, input_Arg, filter_sizes_Arg, out_backprop_Arg> Conv3DBackpropFilterV2<T, input_Arg, filter_sizes_Arg, out_backprop_Arg>
where T: TensorType,
      T: Clone,
      input_Arg: Clone,
      input_Arg: GraphEdge<T>,
      input_Arg: 'static,
      filter_sizes_Arg: Clone,
      filter_sizes_Arg: GraphEdge<i32>,
      filter_sizes_Arg: 'static,
      out_backprop_Arg: Clone,
      out_backprop_Arg: GraphEdge<T>,
      out_backprop_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
      T: 'static,
{
    pub fn output(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn data_format(&mut self, data_format: &str) -> Self {
        self.data_format = Some(data_format.to_string());
        self.clone()
    }

    pub fn dilations(&mut self, dilations: &[i64]) -> Self {
        self.dilations = Some(dilations.to_vec());
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(input: input_Arg, filter_sizes: filter_sizes_Arg, out_backprop: out_backprop_Arg, strides: &[i64], padding: &str) -> Self {
        Self {
            phantom_T: PhantomData,
            input,
            filter_sizes,
            out_backprop,
            strides: strides.to_vec(),
            padding: padding.to_string(),
            data_format: None,
            dilations: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(input: input_Arg, filter_sizes: filter_sizes_Arg, out_backprop: out_backprop_Arg, strides: &[i64], padding: &str) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            input,
            filter_sizes,
            out_backprop,
            strides: strides.to_vec(),
            padding: padding.to_string(),
            data_format: None,
            dilations: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<T, input_Arg, filter_Arg> GraphOperation for Conv3D<T, input_Arg, filter_Arg>
where T: TensorType,
      T: Clone,
      input_Arg: Clone,
      input_Arg: GraphEdge<T>,
      input_Arg: 'static,
      filter_Arg: Clone,
      filter_Arg: GraphEdge<T>,
      filter_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
      T: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("Conv3D_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("Conv3D", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.input)?
        }
        {
            new_op.add_edge(&self.filter)?
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        {
            (|attrs| {new_op.set_attr_int_list("strides", attrs)})(&self.strides)?
        }
        {
            (|attr| {new_op.set_attr_string("padding", attr)})(&self.padding)?
        }
        {
            match self.data_format {
                None => new_op.set_attr_value_proto("data_format", &vec![18_u8, 5_u8, 78_u8, 68_u8, 72_u8, 87_u8, 67_u8,])?,
                Some(ref value) => (|attr| {new_op.set_attr_string("data_format", attr)})(&value)?,
            };
        }
        {
            match self.dilations {
                None => new_op.set_attr_value_proto("dilations", &vec![10_u8, 0_u8, 26_u8, 5_u8, 1_u8, 1_u8, 1_u8, 1_u8,])?,
                Some(ref value) => (|attrs| {new_op.set_attr_int_list("dilations", attrs)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct Conv3D<T, input_Arg, filter_Arg>
where T: TensorType,
      T: Clone,
      input_Arg: Clone,
      input_Arg: GraphEdge<T>,
      input_Arg: 'static,
      filter_Arg: Clone,
      filter_Arg: GraphEdge<T>,
      filter_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    input: input_Arg,
    filter: filter_Arg,
    strides: Vec<i64>,
    padding: String,
    data_format: Option<String>,
    dilations: Option<Vec<i64>>,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<T, input_Arg, filter_Arg> Conv3D<T, input_Arg, filter_Arg>
where T: TensorType,
      T: Clone,
      input_Arg: Clone,
      input_Arg: GraphEdge<T>,
      input_Arg: 'static,
      filter_Arg: Clone,
      filter_Arg: GraphEdge<T>,
      filter_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
      T: 'static,
{
    pub fn output(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn data_format(&mut self, data_format: &str) -> Self {
        self.data_format = Some(data_format.to_string());
        self.clone()
    }

    pub fn dilations(&mut self, dilations: &[i64]) -> Self {
        self.dilations = Some(dilations.to_vec());
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(input: input_Arg, filter: filter_Arg, strides: &[i64], padding: &str) -> Self {
        Self {
            phantom_T: PhantomData,
            input,
            filter,
            strides: strides.to_vec(),
            padding: padding.to_string(),
            data_format: None,
            dilations: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(input: input_Arg, filter: filter_Arg, strides: &[i64], padding: &str) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            input,
            filter,
            strides: strides.to_vec(),
            padding: padding.to_string(),
            data_format: None,
            dilations: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<T, input_Arg, filter_sizes_Arg, out_backprop_Arg> GraphOperation for DepthwiseConv2dNativeBackpropFilter<T, input_Arg, filter_sizes_Arg, out_backprop_Arg>
where T: TensorType,
      T: Clone,
      input_Arg: Clone,
      input_Arg: GraphEdge<T>,
      input_Arg: 'static,
      filter_sizes_Arg: Clone,
      filter_sizes_Arg: GraphEdge<i32>,
      filter_sizes_Arg: 'static,
      out_backprop_Arg: Clone,
      out_backprop_Arg: GraphEdge<T>,
      out_backprop_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
      T: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("DepthwiseConv2dNativeBackpropFilter_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("DepthwiseConv2dNativeBackpropFilter", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.input)?
        }
        {
            new_op.add_edge(&self.filter_sizes)?
        }
        {
            new_op.add_edge(&self.out_backprop)?
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        {
            (|attrs| {new_op.set_attr_int_list("strides", attrs)})(&self.strides)?
        }
        {
            (|attr| {new_op.set_attr_string("padding", attr)})(&self.padding)?
        }
        {
            match self.data_format {
                None => new_op.set_attr_value_proto("data_format", &vec![18_u8, 4_u8, 78_u8, 72_u8, 87_u8, 67_u8,])?,
                Some(ref value) => (|attr| {new_op.set_attr_string("data_format", attr)})(&value)?,
            };
        }
        {
            match self.dilations {
                None => new_op.set_attr_value_proto("dilations", &vec![10_u8, 0_u8, 26_u8, 4_u8,])?,
                Some(ref value) => (|attrs| {new_op.set_attr_int_list("dilations", attrs)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct DepthwiseConv2dNativeBackpropFilter<T, input_Arg, filter_sizes_Arg, out_backprop_Arg>
where T: TensorType,
      T: Clone,
      input_Arg: Clone,
      input_Arg: GraphEdge<T>,
      input_Arg: 'static,
      filter_sizes_Arg: Clone,
      filter_sizes_Arg: GraphEdge<i32>,
      filter_sizes_Arg: 'static,
      out_backprop_Arg: Clone,
      out_backprop_Arg: GraphEdge<T>,
      out_backprop_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    input: input_Arg,
    filter_sizes: filter_sizes_Arg,
    out_backprop: out_backprop_Arg,
    strides: Vec<i64>,
    padding: String,
    data_format: Option<String>,
    dilations: Option<Vec<i64>>,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<T, input_Arg, filter_sizes_Arg, out_backprop_Arg> DepthwiseConv2dNativeBackpropFilter<T, input_Arg, filter_sizes_Arg, out_backprop_Arg>
where T: TensorType,
      T: Clone,
      input_Arg: Clone,
      input_Arg: GraphEdge<T>,
      input_Arg: 'static,
      filter_sizes_Arg: Clone,
      filter_sizes_Arg: GraphEdge<i32>,
      filter_sizes_Arg: 'static,
      out_backprop_Arg: Clone,
      out_backprop_Arg: GraphEdge<T>,
      out_backprop_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
      T: 'static,
{
    pub fn output(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn data_format(&mut self, data_format: &str) -> Self {
        self.data_format = Some(data_format.to_string());
        self.clone()
    }

    pub fn dilations(&mut self, dilations: &[i64]) -> Self {
        self.dilations = Some(dilations.to_vec());
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(input: input_Arg, filter_sizes: filter_sizes_Arg, out_backprop: out_backprop_Arg, strides: &[i64], padding: &str) -> Self {
        Self {
            phantom_T: PhantomData,
            input,
            filter_sizes,
            out_backprop,
            strides: strides.to_vec(),
            padding: padding.to_string(),
            data_format: None,
            dilations: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(input: input_Arg, filter_sizes: filter_sizes_Arg, out_backprop: out_backprop_Arg, strides: &[i64], padding: &str) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            input,
            filter_sizes,
            out_backprop,
            strides: strides.to_vec(),
            padding: padding.to_string(),
            data_format: None,
            dilations: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<input_sizes_Arg, T, filter_Arg, out_backprop_Arg> GraphOperation for DepthwiseConv2dNativeBackpropInput<input_sizes_Arg, T, filter_Arg, out_backprop_Arg>
where input_sizes_Arg: Clone,
      input_sizes_Arg: GraphEdge<i32>,
      input_sizes_Arg: 'static,
      T: TensorType,
      T: Clone,
      filter_Arg: Clone,
      filter_Arg: GraphEdge<T>,
      filter_Arg: 'static,
      out_backprop_Arg: Clone,
      out_backprop_Arg: GraphEdge<T>,
      out_backprop_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
      T: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("DepthwiseConv2dNativeBackpropInput_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("DepthwiseConv2dNativeBackpropInput", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.input_sizes)?
        }
        {
            new_op.add_edge(&self.filter)?
        }
        {
            new_op.add_edge(&self.out_backprop)?
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        {
            (|attrs| {new_op.set_attr_int_list("strides", attrs)})(&self.strides)?
        }
        {
            (|attr| {new_op.set_attr_string("padding", attr)})(&self.padding)?
        }
        {
            match self.data_format {
                None => new_op.set_attr_value_proto("data_format", &vec![18_u8, 4_u8, 78_u8, 72_u8, 87_u8, 67_u8,])?,
                Some(ref value) => (|attr| {new_op.set_attr_string("data_format", attr)})(&value)?,
            };
        }
        {
            match self.dilations {
                None => new_op.set_attr_value_proto("dilations", &vec![10_u8, 0_u8, 26_u8, 4_u8,])?,
                Some(ref value) => (|attrs| {new_op.set_attr_int_list("dilations", attrs)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct DepthwiseConv2dNativeBackpropInput<input_sizes_Arg, T, filter_Arg, out_backprop_Arg>
where input_sizes_Arg: Clone,
      input_sizes_Arg: GraphEdge<i32>,
      input_sizes_Arg: 'static,
      T: TensorType,
      T: Clone,
      filter_Arg: Clone,
      filter_Arg: GraphEdge<T>,
      filter_Arg: 'static,
      out_backprop_Arg: Clone,
      out_backprop_Arg: GraphEdge<T>,
      out_backprop_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
      T: 'static,
{
    input_sizes: input_sizes_Arg,
    phantom_T: PhantomData<T>,
    filter: filter_Arg,
    out_backprop: out_backprop_Arg,
    strides: Vec<i64>,
    padding: String,
    data_format: Option<String>,
    dilations: Option<Vec<i64>>,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<input_sizes_Arg, T, filter_Arg, out_backprop_Arg> DepthwiseConv2dNativeBackpropInput<input_sizes_Arg, T, filter_Arg, out_backprop_Arg>
where input_sizes_Arg: Clone,
      input_sizes_Arg: GraphEdge<i32>,
      input_sizes_Arg: 'static,
      T: TensorType,
      T: Clone,
      filter_Arg: Clone,
      filter_Arg: GraphEdge<T>,
      filter_Arg: 'static,
      out_backprop_Arg: Clone,
      out_backprop_Arg: GraphEdge<T>,
      out_backprop_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
      T: 'static,
{
    pub fn output(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn data_format(&mut self, data_format: &str) -> Self {
        self.data_format = Some(data_format.to_string());
        self.clone()
    }

    pub fn dilations(&mut self, dilations: &[i64]) -> Self {
        self.dilations = Some(dilations.to_vec());
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(input_sizes: input_sizes_Arg, filter: filter_Arg, out_backprop: out_backprop_Arg, strides: &[i64], padding: &str) -> Self {
        Self {
            input_sizes,
            phantom_T: PhantomData,
            filter,
            out_backprop,
            strides: strides.to_vec(),
            padding: padding.to_string(),
            data_format: None,
            dilations: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(input_sizes: input_sizes_Arg, filter: filter_Arg, out_backprop: out_backprop_Arg, strides: &[i64], padding: &str) -> Edge<T> {
        Self {
            input_sizes,
            phantom_T: PhantomData,
            filter,
            out_backprop,
            strides: strides.to_vec(),
            padding: padding.to_string(),
            data_format: None,
            dilations: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<T, input_Arg, filter_Arg> GraphOperation for DepthwiseConv2dNative<T, input_Arg, filter_Arg>
where T: TensorType,
      T: Clone,
      input_Arg: Clone,
      input_Arg: GraphEdge<T>,
      input_Arg: 'static,
      filter_Arg: Clone,
      filter_Arg: GraphEdge<T>,
      filter_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
      T: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("DepthwiseConv2dNative_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("DepthwiseConv2dNative", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.input)?
        }
        {
            new_op.add_edge(&self.filter)?
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        {
            (|attrs| {new_op.set_attr_int_list("strides", attrs)})(&self.strides)?
        }
        {
            (|attr| {new_op.set_attr_string("padding", attr)})(&self.padding)?
        }
        {
            match self.data_format {
                None => new_op.set_attr_value_proto("data_format", &vec![18_u8, 4_u8, 78_u8, 72_u8, 87_u8, 67_u8,])?,
                Some(ref value) => (|attr| {new_op.set_attr_string("data_format", attr)})(&value)?,
            };
        }
        {
            match self.dilations {
                None => new_op.set_attr_value_proto("dilations", &vec![10_u8, 0_u8, 26_u8, 4_u8,])?,
                Some(ref value) => (|attrs| {new_op.set_attr_int_list("dilations", attrs)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct DepthwiseConv2dNative<T, input_Arg, filter_Arg>
where T: TensorType,
      T: Clone,
      input_Arg: Clone,
      input_Arg: GraphEdge<T>,
      input_Arg: 'static,
      filter_Arg: Clone,
      filter_Arg: GraphEdge<T>,
      filter_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    input: input_Arg,
    filter: filter_Arg,
    strides: Vec<i64>,
    padding: String,
    data_format: Option<String>,
    dilations: Option<Vec<i64>>,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<T, input_Arg, filter_Arg> DepthwiseConv2dNative<T, input_Arg, filter_Arg>
where T: TensorType,
      T: Clone,
      input_Arg: Clone,
      input_Arg: GraphEdge<T>,
      input_Arg: 'static,
      filter_Arg: Clone,
      filter_Arg: GraphEdge<T>,
      filter_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
      T: 'static,
{
    pub fn output(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn data_format(&mut self, data_format: &str) -> Self {
        self.data_format = Some(data_format.to_string());
        self.clone()
    }

    pub fn dilations(&mut self, dilations: &[i64]) -> Self {
        self.dilations = Some(dilations.to_vec());
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(input: input_Arg, filter: filter_Arg, strides: &[i64], padding: &str) -> Self {
        Self {
            phantom_T: PhantomData,
            input,
            filter,
            strides: strides.to_vec(),
            padding: padding.to_string(),
            data_format: None,
            dilations: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(input: input_Arg, filter: filter_Arg, strides: &[i64], padding: &str) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            input,
            filter,
            strides: strides.to_vec(),
            padding: padding.to_string(),
            data_format: None,
            dilations: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

pub trait con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_HALF {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_HALF for f32 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_HALF for f64 {
}

impl<T, input_Arg, size_Arg, paddings_Arg, filter_Arg> GraphOperation for FusedResizeAndPadConv2D<T, input_Arg, size_Arg, paddings_Arg, filter_Arg>
where T: TensorType,
      T: Clone,
      input_Arg: Clone,
      input_Arg: GraphEdge<T>,
      input_Arg: 'static,
      size_Arg: Clone,
      size_Arg: GraphEdge<i32>,
      size_Arg: 'static,
      paddings_Arg: Clone,
      paddings_Arg: GraphEdge<i32>,
      paddings_Arg: 'static,
      filter_Arg: Clone,
      filter_Arg: GraphEdge<T>,
      filter_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_HALF,
      T: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("FusedResizeAndPadConv2D_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("FusedResizeAndPadConv2D", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.input)?
        }
        {
            new_op.add_edge(&self.size)?
        }
        {
            new_op.add_edge(&self.paddings)?
        }
        {
            new_op.add_edge(&self.filter)?
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        {
            match self.resize_align_corners {
                None => new_op.set_attr_value_proto("resize_align_corners", &vec![40_u8, 0_u8,])?,
                Some(ref value) => (|attr: &bool| {new_op.set_attr_bool("resize_align_corners", *attr)})(&value)?,
            };
        }
        {
            (|attr| {new_op.set_attr_string("mode", attr)})(&self.mode)?
        }
        {
            (|attrs| {new_op.set_attr_int_list("strides", attrs)})(&self.strides)?
        }
        {
            (|attr| {new_op.set_attr_string("padding", attr)})(&self.padding)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct FusedResizeAndPadConv2D<T, input_Arg, size_Arg, paddings_Arg, filter_Arg>
where T: TensorType,
      T: Clone,
      input_Arg: Clone,
      input_Arg: GraphEdge<T>,
      input_Arg: 'static,
      size_Arg: Clone,
      size_Arg: GraphEdge<i32>,
      size_Arg: 'static,
      paddings_Arg: Clone,
      paddings_Arg: GraphEdge<i32>,
      paddings_Arg: 'static,
      filter_Arg: Clone,
      filter_Arg: GraphEdge<T>,
      filter_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_HALF,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    input: input_Arg,
    size: size_Arg,
    paddings: paddings_Arg,
    filter: filter_Arg,
    resize_align_corners: Option<bool>,
    mode: String,
    strides: Vec<i64>,
    padding: String,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<T, input_Arg, size_Arg, paddings_Arg, filter_Arg> FusedResizeAndPadConv2D<T, input_Arg, size_Arg, paddings_Arg, filter_Arg>
where T: TensorType,
      T: Clone,
      input_Arg: Clone,
      input_Arg: GraphEdge<T>,
      input_Arg: 'static,
      size_Arg: Clone,
      size_Arg: GraphEdge<i32>,
      size_Arg: 'static,
      paddings_Arg: Clone,
      paddings_Arg: GraphEdge<i32>,
      paddings_Arg: 'static,
      filter_Arg: Clone,
      filter_Arg: GraphEdge<T>,
      filter_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_HALF,
      T: 'static,
{
    pub fn output(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn resize_align_corners(&mut self, resize_align_corners: bool) -> Self {
        self.resize_align_corners = Some(resize_align_corners);
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(input: input_Arg, size: size_Arg, paddings: paddings_Arg, filter: filter_Arg, mode: &str, strides: &[i64], padding: &str) -> Self {
        Self {
            phantom_T: PhantomData,
            input,
            size,
            paddings,
            filter,
            resize_align_corners: None,
            mode: mode.to_string(),
            strides: strides.to_vec(),
            padding: padding.to_string(),
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(input: input_Arg, size: size_Arg, paddings: paddings_Arg, filter: filter_Arg, mode: &str, strides: &[i64], padding: &str) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            input,
            size,
            paddings,
            filter,
            resize_align_corners: None,
            mode: mode.to_string(),
            strides: strides.to_vec(),
            padding: padding.to_string(),
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<T, x_Arg> GraphOperation for DataFormatVecPermute<T, x_Arg>
where T: TensorType,
      T: Clone,
      x_Arg: Clone,
      x_Arg: GraphEdge<T>,
      x_Arg: 'static,
      T: con_or_DT_INT32_or_DT_INT64,
      T: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("DataFormatVecPermute_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("DataFormatVecPermute", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.x)?
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        {
            match self.src_format {
                None => new_op.set_attr_value_proto("src_format", &vec![18_u8, 4_u8, 78_u8, 72_u8, 87_u8, 67_u8,])?,
                Some(ref value) => (|attr| {new_op.set_attr_string("src_format", attr)})(&value)?,
            };
        }
        {
            match self.dst_format {
                None => new_op.set_attr_value_proto("dst_format", &vec![18_u8, 4_u8, 78_u8, 67_u8, 72_u8, 87_u8,])?,
                Some(ref value) => (|attr| {new_op.set_attr_string("dst_format", attr)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct DataFormatVecPermute<T, x_Arg>
where T: TensorType,
      T: Clone,
      x_Arg: Clone,
      x_Arg: GraphEdge<T>,
      x_Arg: 'static,
      T: con_or_DT_INT32_or_DT_INT64,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    x: x_Arg,
    src_format: Option<String>,
    dst_format: Option<String>,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<T, x_Arg> DataFormatVecPermute<T, x_Arg>
where T: TensorType,
      T: Clone,
      x_Arg: Clone,
      x_Arg: GraphEdge<T>,
      x_Arg: 'static,
      T: con_or_DT_INT32_or_DT_INT64,
      T: 'static,
{
    pub fn y(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn src_format(&mut self, src_format: &str) -> Self {
        self.src_format = Some(src_format.to_string());
        self.clone()
    }

    pub fn dst_format(&mut self, dst_format: &str) -> Self {
        self.dst_format = Some(dst_format.to_string());
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(x: x_Arg) -> Self {
        Self {
            phantom_T: PhantomData,
            x,
            src_format: None,
            dst_format: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(x: x_Arg) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            x,
            src_format: None,
            dst_format: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<T, input_Arg, filter_Arg, args_Arg> GraphOperation for _FusedConv2D<T, input_Arg, filter_Arg, args_Arg>
where T: TensorType,
      T: Clone,
      input_Arg: Clone,
      input_Arg: GraphEdge<T>,
      input_Arg: 'static,
      filter_Arg: Clone,
      filter_Arg: GraphEdge<T>,
      filter_Arg: 'static,
      args_Arg: Clone,
      args_Arg: GraphEdge<T>,
      args_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE,
      T: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("_FusedConv2D_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("_FusedConv2D", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.input)?
        }
        {
            new_op.add_edge(&self.filter)?
        }
        {
            new_op.add_edge(&self.args)?
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        {
            (|attr: &i64| {new_op.set_attr_int("num_args", *attr)})(&self.num_args)?
        }
        {
            (|attrs| {new_op.set_attr_int_list("strides", attrs)})(&self.strides)?
        }
        {
            (|attr| {new_op.set_attr_string("padding", attr)})(&self.padding)?
        }
        {
            match self.data_format {
                None => new_op.set_attr_value_proto("data_format", &vec![18_u8, 4_u8, 78_u8, 72_u8, 87_u8, 67_u8,])?,
                Some(ref value) => (|attr| {new_op.set_attr_string("data_format", attr)})(&value)?,
            };
        }
        {
            match self.dilations {
                None => new_op.set_attr_value_proto("dilations", &vec![10_u8, 0_u8, 26_u8, 4_u8,])?,
                Some(ref value) => (|attrs| {new_op.set_attr_int_list("dilations", attrs)})(&value)?,
            };
        }
        {
            match self.fused_ops {
                None => new_op.set_attr_value_proto("fused_ops", &vec![10_u8, 0_u8,])?,
                Some(ref value) => (|attrs| {new_op.set_attr_string_list("fused_ops", attrs)})(&value)?,
            };
        }
        {
            match self.epsilon {
                None => new_op.set_attr_value_proto("epsilon", &vec![37_u8, 23_u8, 183_u8, 209_u8, 56_u8,])?,
                Some(ref value) => (|attr: &f32| {new_op.set_attr_float("epsilon", *attr)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct _FusedConv2D<T, input_Arg, filter_Arg, args_Arg>
where T: TensorType,
      T: Clone,
      input_Arg: Clone,
      input_Arg: GraphEdge<T>,
      input_Arg: 'static,
      filter_Arg: Clone,
      filter_Arg: GraphEdge<T>,
      filter_Arg: 'static,
      args_Arg: Clone,
      args_Arg: GraphEdge<T>,
      args_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    input: input_Arg,
    filter: filter_Arg,
    args: args_Arg,
    num_args: i64,
    strides: Vec<i64>,
    padding: String,
    data_format: Option<String>,
    dilations: Option<Vec<i64>>,
    fused_ops: Option<Vec<String>>,
    epsilon: Option<f32>,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<T, input_Arg, filter_Arg, args_Arg> _FusedConv2D<T, input_Arg, filter_Arg, args_Arg>
where T: TensorType,
      T: Clone,
      input_Arg: Clone,
      input_Arg: GraphEdge<T>,
      input_Arg: 'static,
      filter_Arg: Clone,
      filter_Arg: GraphEdge<T>,
      filter_Arg: 'static,
      args_Arg: Clone,
      args_Arg: GraphEdge<T>,
      args_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE,
      T: 'static,
{
    pub fn output(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn data_format(&mut self, data_format: &str) -> Self {
        self.data_format = Some(data_format.to_string());
        self.clone()
    }

    pub fn dilations(&mut self, dilations: &[i64]) -> Self {
        self.dilations = Some(dilations.to_vec());
        self.clone()
    }

    pub fn fused_ops(&mut self, fused_ops: &[String]) -> Self {
        self.fused_ops = Some(fused_ops.to_vec());
        self.clone()
    }

    pub fn epsilon(&mut self, epsilon: f32) -> Self {
        self.epsilon = Some(epsilon);
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(input: input_Arg, filter: filter_Arg, args: args_Arg, num_args: i64, strides: &[i64], padding: &str) -> Self {
        Self {
            phantom_T: PhantomData,
            input,
            filter,
            args,
            num_args: num_args,
            strides: strides.to_vec(),
            padding: padding.to_string(),
            data_format: None,
            dilations: None,
            fused_ops: None,
            epsilon: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(input: input_Arg, filter: filter_Arg, args: args_Arg, num_args: i64, strides: &[i64], padding: &str) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            input,
            filter,
            args,
            num_args: num_args,
            strides: strides.to_vec(),
            padding: padding.to_string(),
            data_format: None,
            dilations: None,
            fused_ops: None,
            epsilon: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<T, input_Arg, filter_Arg> GraphOperation for Dilation2D<T, input_Arg, filter_Arg>
where T: TensorType,
      T: Clone,
      input_Arg: Clone,
      input_Arg: GraphEdge<T>,
      input_Arg: 'static,
      filter_Arg: Clone,
      filter_Arg: GraphEdge<T>,
      filter_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("Dilation2D_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("Dilation2D", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.input)?
        }
        {
            new_op.add_edge(&self.filter)?
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        {
            (|attrs| {new_op.set_attr_int_list("strides", attrs)})(&self.strides)?
        }
        {
            (|attrs| {new_op.set_attr_int_list("rates", attrs)})(&self.rates)?
        }
        {
            (|attr| {new_op.set_attr_string("padding", attr)})(&self.padding)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct Dilation2D<T, input_Arg, filter_Arg>
where T: TensorType,
      T: Clone,
      input_Arg: Clone,
      input_Arg: GraphEdge<T>,
      input_Arg: 'static,
      filter_Arg: Clone,
      filter_Arg: GraphEdge<T>,
      filter_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    input: input_Arg,
    filter: filter_Arg,
    strides: Vec<i64>,
    rates: Vec<i64>,
    padding: String,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<T, input_Arg, filter_Arg> Dilation2D<T, input_Arg, filter_Arg>
where T: TensorType,
      T: Clone,
      input_Arg: Clone,
      input_Arg: GraphEdge<T>,
      input_Arg: 'static,
      filter_Arg: Clone,
      filter_Arg: GraphEdge<T>,
      filter_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
{
    pub fn output(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(input: input_Arg, filter: filter_Arg, strides: &[i64], rates: &[i64], padding: &str) -> Self {
        Self {
            phantom_T: PhantomData,
            input,
            filter,
            strides: strides.to_vec(),
            rates: rates.to_vec(),
            padding: padding.to_string(),
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(input: input_Arg, filter: filter_Arg, strides: &[i64], rates: &[i64], padding: &str) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            input,
            filter,
            strides: strides.to_vec(),
            rates: rates.to_vec(),
            padding: padding.to_string(),
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<dtype> GraphOperation for ConditionalAccumulator<dtype>
where dtype: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      dtype: TensorType,
      dtype: 'static,
      dtype: Clone,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("ConditionalAccumulator_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("ConditionalAccumulator", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.set_attr_type("dtype", dtype::data_type())?;
        }
        {
            (|attr| {new_op.set_attr_shape("shape", attr)})(&self.shape)?
        }
        {
            match self.container {
                None => new_op.set_attr_value_proto("container", &vec![18_u8, 0_u8,])?,
                Some(ref value) => (|attr| {new_op.set_attr_string("container", attr)})(&value)?,
            };
        }
        {
            match self.shared_name {
                None => new_op.set_attr_value_proto("shared_name", &vec![18_u8, 0_u8,])?,
                Some(ref value) => (|attr| {new_op.set_attr_string("shared_name", attr)})(&value)?,
            };
        }
        {
            match self.reduction_type {
                None => new_op.set_attr_value_proto("reduction_type", &vec![18_u8, 4_u8, 77_u8, 69_u8, 65_u8, 78_u8,])?,
                Some(ref value) => (|attr| {new_op.set_attr_string("reduction_type", attr)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct ConditionalAccumulator<dtype>
where dtype: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      dtype: TensorType,
      dtype: 'static,
      dtype: Clone,
{
    phantom_dtype: PhantomData<dtype>,
    shape: OtherShape,
    container: Option<String>,
    shared_name: Option<String>,
    reduction_type: Option<String>,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<dtype> ConditionalAccumulator<dtype>
where dtype: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      dtype: TensorType,
      dtype: 'static,
      dtype: Clone,
{
    pub fn handle(self) -> RefEdge<String> {
        let rc = Rc::new(self);
        {
            RefEdge::<String>::new(rc.clone(), 0)
        }
    }

    pub fn container(&mut self, container: &str) -> Self {
        self.container = Some(container.to_string());
        self.clone()
    }

    pub fn shared_name(&mut self, shared_name: &str) -> Self {
        self.shared_name = Some(shared_name.to_string());
        self.clone()
    }

    pub fn reduction_type(&mut self, reduction_type: &str) -> Self {
        self.reduction_type = Some(reduction_type.to_string());
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> RefEdge<String> {
        let rc = Rc::new(self);
        {
            RefEdge::<String>::new(rc.clone(), 0)
        }
    }

    pub fn build(shape: &OtherShape) -> Self {
        Self {
            phantom_dtype: PhantomData,
            shape: shape.clone(),
            container: None,
            shared_name: None,
            reduction_type: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(shape: &OtherShape) -> RefEdge<String> {
        Self {
            phantom_dtype: PhantomData,
            shape: shape.clone(),
            container: None,
            shared_name: None,
            reduction_type: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<handle_Arg, flow_in_Arg, dtype> GraphOperation for TensorArrayConcatV2<handle_Arg, flow_in_Arg, dtype>
where handle_Arg: Clone,
      handle_Arg: GraphEdge<String>,
      handle_Arg: 'static,
      flow_in_Arg: Clone,
      flow_in_Arg: GraphEdge<f32>,
      flow_in_Arg: 'static,
      dtype: TensorType,
      dtype: 'static,
      dtype: Clone,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("TensorArrayConcatV2_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("TensorArrayConcatV2", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.handle)?
        }
        {
            new_op.add_edge(&self.flow_in)?
        }
        {
            new_op.set_attr_type("dtype", dtype::data_type())?;
        }
        {
            match self.element_shape_except0 {
                None => new_op.set_attr_value_proto("element_shape_except0", &vec![58_u8, 0_u8,])?,
                Some(ref value) => (|attr| {new_op.set_attr_shape("element_shape_except0", attr)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct TensorArrayConcatV2<handle_Arg, flow_in_Arg, dtype>
where handle_Arg: Clone,
      handle_Arg: GraphEdge<String>,
      handle_Arg: 'static,
      flow_in_Arg: Clone,
      flow_in_Arg: GraphEdge<f32>,
      flow_in_Arg: 'static,
      dtype: TensorType,
      dtype: 'static,
      dtype: Clone,
{
    handle: handle_Arg,
    flow_in: flow_in_Arg,
    phantom_dtype: PhantomData<dtype>,
    element_shape_except0: Option<OtherShape>,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<handle_Arg, flow_in_Arg, dtype> TensorArrayConcatV2<handle_Arg, flow_in_Arg, dtype>
where handle_Arg: Clone,
      handle_Arg: GraphEdge<String>,
      handle_Arg: 'static,
      flow_in_Arg: Clone,
      flow_in_Arg: GraphEdge<f32>,
      flow_in_Arg: 'static,
      dtype: TensorType,
      dtype: 'static,
      dtype: Clone,
{
    pub fn value(self) -> Edge<dtype> {
        let rc = Rc::new(self);
        {
            Edge::<dtype>::new(rc.clone(), 0)
        }
    }

    pub fn lengths(self) -> Edge<i64> {
        let rc = Rc::new(self);
        {
            Edge::<i64>::new(rc.clone(), 1)
        }
    }

    pub fn element_shape_except0(&mut self, element_shape_except0: &OtherShape) -> Self {
        self.element_shape_except0 = Some(element_shape_except0.clone());
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> (Edge<dtype>, Edge<i64>) {
        let rc = Rc::new(self);
        (
        {
            Edge::<dtype>::new(rc.clone(), 0)
        },
        {
            Edge::<i64>::new(rc.clone(), 1)
        },
        )
    }

    pub fn build(handle: handle_Arg, flow_in: flow_in_Arg) -> Self {
        Self {
            handle,
            flow_in,
            phantom_dtype: PhantomData,
            element_shape_except0: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(handle: handle_Arg, flow_in: flow_in_Arg) -> (Edge<dtype>, Edge<i64>) {
        Self {
            handle,
            flow_in,
            phantom_dtype: PhantomData,
            element_shape_except0: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<tag_Arg, T, tensor_Arg, serialized_summary_metadata_Arg> GraphOperation for TensorSummaryV2<tag_Arg, T, tensor_Arg, serialized_summary_metadata_Arg>
where tag_Arg: Clone,
      tag_Arg: GraphEdge<String>,
      tag_Arg: 'static,
      T: TensorType,
      T: Clone,
      tensor_Arg: Clone,
      tensor_Arg: GraphEdge<T>,
      tensor_Arg: 'static,
      serialized_summary_metadata_Arg: Clone,
      serialized_summary_metadata_Arg: GraphEdge<String>,
      serialized_summary_metadata_Arg: 'static,
      T: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("TensorSummaryV2_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("TensorSummaryV2", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.tag)?
        }
        {
            new_op.add_edge(&self.tensor)?
        }
        {
            new_op.add_edge(&self.serialized_summary_metadata)?
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct TensorSummaryV2<tag_Arg, T, tensor_Arg, serialized_summary_metadata_Arg>
where tag_Arg: Clone,
      tag_Arg: GraphEdge<String>,
      tag_Arg: 'static,
      T: TensorType,
      T: Clone,
      tensor_Arg: Clone,
      tensor_Arg: GraphEdge<T>,
      tensor_Arg: 'static,
      serialized_summary_metadata_Arg: Clone,
      serialized_summary_metadata_Arg: GraphEdge<String>,
      serialized_summary_metadata_Arg: 'static,
      T: 'static,
{
    tag: tag_Arg,
    phantom_T: PhantomData<T>,
    tensor: tensor_Arg,
    serialized_summary_metadata: serialized_summary_metadata_Arg,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<tag_Arg, T, tensor_Arg, serialized_summary_metadata_Arg> TensorSummaryV2<tag_Arg, T, tensor_Arg, serialized_summary_metadata_Arg>
where tag_Arg: Clone,
      tag_Arg: GraphEdge<String>,
      tag_Arg: 'static,
      T: TensorType,
      T: Clone,
      tensor_Arg: Clone,
      tensor_Arg: GraphEdge<T>,
      tensor_Arg: 'static,
      serialized_summary_metadata_Arg: Clone,
      serialized_summary_metadata_Arg: GraphEdge<String>,
      serialized_summary_metadata_Arg: 'static,
      T: 'static,
{
    pub fn summary(self) -> Edge<String> {
        let rc = Rc::new(self);
        {
            Edge::<String>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<String> {
        let rc = Rc::new(self);
        {
            Edge::<String>::new(rc.clone(), 0)
        }
    }

    pub fn build(tag: tag_Arg, tensor: tensor_Arg, serialized_summary_metadata: serialized_summary_metadata_Arg) -> Self {
        Self {
            tag,
            phantom_T: PhantomData,
            tensor,
            serialized_summary_metadata,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(tag: tag_Arg, tensor: tensor_Arg, serialized_summary_metadata: serialized_summary_metadata_Arg) -> Edge<String> {
        Self {
            tag,
            phantom_T: PhantomData,
            tensor,
            serialized_summary_metadata,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl GraphOperation for RetrieveTPUEmbeddingProximalAdagradParametersGradAccumDebug {
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("RetrieveTPUEmbeddingProximalAdagradParametersGradAccumDebug_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("RetrieveTPUEmbeddingProximalAdagradParametersGradAccumDebug", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            match self.table_id {
                None => new_op.set_attr_value_proto("table_id", &vec![24_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 1_u8,])?,
                Some(ref value) => (|attr: &i64| {new_op.set_attr_int("table_id", *attr)})(&value)?,
            };
        }
        {
            match self.table_name {
                None => new_op.set_attr_value_proto("table_name", &vec![18_u8, 0_u8,])?,
                Some(ref value) => (|attr| {new_op.set_attr_string("table_name", attr)})(&value)?,
            };
        }
        {
            (|attr: &i64| {new_op.set_attr_int("num_shards", *attr)})(&self.num_shards)?
        }
        {
            (|attr: &i64| {new_op.set_attr_int("shard_id", *attr)})(&self.shard_id)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct RetrieveTPUEmbeddingProximalAdagradParametersGradAccumDebug {
    table_id: Option<i64>,
    table_name: Option<String>,
    num_shards: i64,
    shard_id: i64,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl RetrieveTPUEmbeddingProximalAdagradParametersGradAccumDebug {
    pub fn parameters(self) -> Edge<f32> {
        let rc = Rc::new(self);
        {
            Edge::<f32>::new(rc.clone(), 0)
        }
    }

    pub fn accumulators(self) -> Edge<f32> {
        let rc = Rc::new(self);
        {
            Edge::<f32>::new(rc.clone(), 1)
        }
    }

    pub fn gradient_accumulators(self) -> Edge<f32> {
        let rc = Rc::new(self);
        {
            Edge::<f32>::new(rc.clone(), 2)
        }
    }

    pub fn table_id(&mut self, table_id: i64) -> Self {
        self.table_id = Some(table_id);
        self.clone()
    }

    pub fn table_name(&mut self, table_name: &str) -> Self {
        self.table_name = Some(table_name.to_string());
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> (Edge<f32>, Edge<f32>, Edge<f32>) {
        let rc = Rc::new(self);
        (
        {
            Edge::<f32>::new(rc.clone(), 0)
        },
        {
            Edge::<f32>::new(rc.clone(), 1)
        },
        {
            Edge::<f32>::new(rc.clone(), 2)
        },
        )
    }

    pub fn build(num_shards: i64, shard_id: i64) -> Self {
        Self {
            table_id: None,
            table_name: None,
            num_shards: num_shards,
            shard_id: shard_id,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(num_shards: i64, shard_id: i64) -> (Edge<f32>, Edge<f32>, Edge<f32>) {
        Self {
            table_id: None,
            table_name: None,
            num_shards: num_shards,
            shard_id: shard_id,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<T, var_Arg, mg_Arg, ms_Arg, mom_Arg, lr_Arg, rho_Arg, momentum_Arg, epsilon_Arg, grad_Arg, Tindices, indices_Arg> GraphOperation for SparseApplyCenteredRMSProp<T, var_Arg, mg_Arg, ms_Arg, mom_Arg, lr_Arg, rho_Arg, momentum_Arg, epsilon_Arg, grad_Arg, Tindices, indices_Arg>
where T: TensorType,
      T: Clone,
      var_Arg: Clone,
      var_Arg: GraphRefEdge<T>,
      var_Arg: 'static,
      mg_Arg: Clone,
      mg_Arg: GraphRefEdge<T>,
      mg_Arg: 'static,
      ms_Arg: Clone,
      ms_Arg: GraphRefEdge<T>,
      ms_Arg: 'static,
      mom_Arg: Clone,
      mom_Arg: GraphRefEdge<T>,
      mom_Arg: 'static,
      lr_Arg: Clone,
      lr_Arg: GraphEdge<T>,
      lr_Arg: 'static,
      rho_Arg: Clone,
      rho_Arg: GraphEdge<T>,
      rho_Arg: 'static,
      momentum_Arg: Clone,
      momentum_Arg: GraphEdge<T>,
      momentum_Arg: 'static,
      epsilon_Arg: Clone,
      epsilon_Arg: GraphEdge<T>,
      epsilon_Arg: 'static,
      grad_Arg: Clone,
      grad_Arg: GraphEdge<T>,
      grad_Arg: 'static,
      Tindices: TensorType,
      Tindices: Clone,
      indices_Arg: Clone,
      indices_Arg: GraphEdge<Tindices>,
      indices_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
      Tindices: con_or_DT_INT32_or_DT_INT64,
      Tindices: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("SparseApplyCenteredRMSProp_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("SparseApplyCenteredRMSProp", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.var)?
        }
        {
            new_op.add_edge(&self.mg)?
        }
        {
            new_op.add_edge(&self.ms)?
        }
        {
            new_op.add_edge(&self.mom)?
        }
        {
            new_op.add_edge(&self.lr)?
        }
        {
            new_op.add_edge(&self.rho)?
        }
        {
            new_op.add_edge(&self.momentum)?
        }
        {
            new_op.add_edge(&self.epsilon)?
        }
        {
            new_op.add_edge(&self.grad)?
        }
        {
            new_op.add_edge(&self.indices)?
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        {
            new_op.set_attr_type("Tindices", Tindices::data_type())?;
        }
        {
            match self.use_locking {
                None => new_op.set_attr_value_proto("use_locking", &vec![40_u8, 0_u8,])?,
                Some(ref value) => (|attr: &bool| {new_op.set_attr_bool("use_locking", *attr)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct SparseApplyCenteredRMSProp<T, var_Arg, mg_Arg, ms_Arg, mom_Arg, lr_Arg, rho_Arg, momentum_Arg, epsilon_Arg, grad_Arg, Tindices, indices_Arg>
where T: TensorType,
      T: Clone,
      var_Arg: Clone,
      var_Arg: GraphRefEdge<T>,
      var_Arg: 'static,
      mg_Arg: Clone,
      mg_Arg: GraphRefEdge<T>,
      mg_Arg: 'static,
      ms_Arg: Clone,
      ms_Arg: GraphRefEdge<T>,
      ms_Arg: 'static,
      mom_Arg: Clone,
      mom_Arg: GraphRefEdge<T>,
      mom_Arg: 'static,
      lr_Arg: Clone,
      lr_Arg: GraphEdge<T>,
      lr_Arg: 'static,
      rho_Arg: Clone,
      rho_Arg: GraphEdge<T>,
      rho_Arg: 'static,
      momentum_Arg: Clone,
      momentum_Arg: GraphEdge<T>,
      momentum_Arg: 'static,
      epsilon_Arg: Clone,
      epsilon_Arg: GraphEdge<T>,
      epsilon_Arg: 'static,
      grad_Arg: Clone,
      grad_Arg: GraphEdge<T>,
      grad_Arg: 'static,
      Tindices: TensorType,
      Tindices: Clone,
      indices_Arg: Clone,
      indices_Arg: GraphEdge<Tindices>,
      indices_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
      Tindices: con_or_DT_INT32_or_DT_INT64,
      Tindices: 'static,
{
    phantom_T: PhantomData<T>,
    var: var_Arg,
    mg: mg_Arg,
    ms: ms_Arg,
    mom: mom_Arg,
    lr: lr_Arg,
    rho: rho_Arg,
    momentum: momentum_Arg,
    epsilon: epsilon_Arg,
    grad: grad_Arg,
    phantom_Tindices: PhantomData<Tindices>,
    indices: indices_Arg,
    use_locking: Option<bool>,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<T, var_Arg, mg_Arg, ms_Arg, mom_Arg, lr_Arg, rho_Arg, momentum_Arg, epsilon_Arg, grad_Arg, Tindices, indices_Arg> SparseApplyCenteredRMSProp<T, var_Arg, mg_Arg, ms_Arg, mom_Arg, lr_Arg, rho_Arg, momentum_Arg, epsilon_Arg, grad_Arg, Tindices, indices_Arg>
where T: TensorType,
      T: Clone,
      var_Arg: Clone,
      var_Arg: GraphRefEdge<T>,
      var_Arg: 'static,
      mg_Arg: Clone,
      mg_Arg: GraphRefEdge<T>,
      mg_Arg: 'static,
      ms_Arg: Clone,
      ms_Arg: GraphRefEdge<T>,
      ms_Arg: 'static,
      mom_Arg: Clone,
      mom_Arg: GraphRefEdge<T>,
      mom_Arg: 'static,
      lr_Arg: Clone,
      lr_Arg: GraphEdge<T>,
      lr_Arg: 'static,
      rho_Arg: Clone,
      rho_Arg: GraphEdge<T>,
      rho_Arg: 'static,
      momentum_Arg: Clone,
      momentum_Arg: GraphEdge<T>,
      momentum_Arg: 'static,
      epsilon_Arg: Clone,
      epsilon_Arg: GraphEdge<T>,
      epsilon_Arg: 'static,
      grad_Arg: Clone,
      grad_Arg: GraphEdge<T>,
      grad_Arg: 'static,
      Tindices: TensorType,
      Tindices: Clone,
      indices_Arg: Clone,
      indices_Arg: GraphEdge<Tindices>,
      indices_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
      Tindices: con_or_DT_INT32_or_DT_INT64,
      Tindices: 'static,
{
    pub fn out(self) -> RefEdge<T> {
        let rc = Rc::new(self);
        {
            RefEdge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn use_locking(&mut self, use_locking: bool) -> Self {
        self.use_locking = Some(use_locking);
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> RefEdge<T> {
        let rc = Rc::new(self);
        {
            RefEdge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(var: var_Arg, mg: mg_Arg, ms: ms_Arg, mom: mom_Arg, lr: lr_Arg, rho: rho_Arg, momentum: momentum_Arg, epsilon: epsilon_Arg, grad: grad_Arg, indices: indices_Arg) -> Self {
        Self {
            phantom_T: PhantomData,
            var,
            mg,
            ms,
            mom,
            lr,
            rho,
            momentum,
            epsilon,
            grad,
            phantom_Tindices: PhantomData,
            indices,
            use_locking: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(var: var_Arg, mg: mg_Arg, ms: ms_Arg, mom: mom_Arg, lr: lr_Arg, rho: rho_Arg, momentum: momentum_Arg, epsilon: epsilon_Arg, grad: grad_Arg, indices: indices_Arg) -> RefEdge<T> {
        Self {
            phantom_T: PhantomData,
            var,
            mg,
            ms,
            mom,
            lr,
            rho,
            momentum,
            epsilon,
            grad,
            phantom_Tindices: PhantomData,
            indices,
            use_locking: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl GraphOperation for RecordInput {
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("RecordInput_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("RecordInput", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            (|attr| {new_op.set_attr_string("file_pattern", attr)})(&self.file_pattern)?
        }
        {
            match self.file_random_seed {
                None => new_op.set_attr_value_proto("file_random_seed", &vec![24_u8, 173_u8, 2_u8,])?,
                Some(ref value) => (|attr: &i64| {new_op.set_attr_int("file_random_seed", *attr)})(&value)?,
            };
        }
        {
            match self.file_shuffle_shift_ratio {
                None => new_op.set_attr_value_proto("file_shuffle_shift_ratio", &vec![37_u8, 0_u8, 0_u8, 0_u8, 0_u8,])?,
                Some(ref value) => (|attr: &f32| {new_op.set_attr_float("file_shuffle_shift_ratio", *attr)})(&value)?,
            };
        }
        {
            match self.file_buffer_size {
                None => new_op.set_attr_value_proto("file_buffer_size", &vec![24_u8, 144_u8, 78_u8,])?,
                Some(ref value) => (|attr: &i64| {new_op.set_attr_int("file_buffer_size", *attr)})(&value)?,
            };
        }
        {
            match self.file_parallelism {
                None => new_op.set_attr_value_proto("file_parallelism", &vec![24_u8, 16_u8,])?,
                Some(ref value) => (|attr: &i64| {new_op.set_attr_int("file_parallelism", *attr)})(&value)?,
            };
        }
        {
            match self.batch_size {
                None => new_op.set_attr_value_proto("batch_size", &vec![24_u8, 32_u8,])?,
                Some(ref value) => (|attr: &i64| {new_op.set_attr_int("batch_size", *attr)})(&value)?,
            };
        }
        {
            match self.compression_type {
                None => new_op.set_attr_value_proto("compression_type", &vec![18_u8, 0_u8,])?,
                Some(ref value) => (|attr| {new_op.set_attr_string("compression_type", attr)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct RecordInput {
    file_pattern: String,
    file_random_seed: Option<i64>,
    file_shuffle_shift_ratio: Option<f32>,
    file_buffer_size: Option<i64>,
    file_parallelism: Option<i64>,
    batch_size: Option<i64>,
    compression_type: Option<String>,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl RecordInput {
    pub fn records(self) -> Edge<String> {
        let rc = Rc::new(self);
        {
            Edge::<String>::new(rc.clone(), 0)
        }
    }

    pub fn file_random_seed(&mut self, file_random_seed: i64) -> Self {
        self.file_random_seed = Some(file_random_seed);
        self.clone()
    }

    pub fn file_shuffle_shift_ratio(&mut self, file_shuffle_shift_ratio: f32) -> Self {
        self.file_shuffle_shift_ratio = Some(file_shuffle_shift_ratio);
        self.clone()
    }

    pub fn file_buffer_size(&mut self, file_buffer_size: i64) -> Self {
        self.file_buffer_size = Some(file_buffer_size);
        self.clone()
    }

    pub fn file_parallelism(&mut self, file_parallelism: i64) -> Self {
        self.file_parallelism = Some(file_parallelism);
        self.clone()
    }

    pub fn batch_size(&mut self, batch_size: i64) -> Self {
        self.batch_size = Some(batch_size);
        self.clone()
    }

    pub fn compression_type(&mut self, compression_type: &str) -> Self {
        self.compression_type = Some(compression_type.to_string());
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<String> {
        let rc = Rc::new(self);
        {
            Edge::<String>::new(rc.clone(), 0)
        }
    }

    pub fn build(file_pattern: &str) -> Self {
        Self {
            file_pattern: file_pattern.to_string(),
            file_random_seed: None,
            file_shuffle_shift_ratio: None,
            file_buffer_size: None,
            file_parallelism: None,
            batch_size: None,
            compression_type: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(file_pattern: &str) -> Edge<String> {
        Self {
            file_pattern: file_pattern.to_string(),
            file_random_seed: None,
            file_shuffle_shift_ratio: None,
            file_buffer_size: None,
            file_parallelism: None,
            batch_size: None,
            compression_type: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

pub trait con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_COMPLEX64_or_DT_INT64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_COMPLEX64_or_DT_INT64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF for BFloat16 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_COMPLEX64_or_DT_INT64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF for OtherComplex<f32> {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_COMPLEX64_or_DT_INT64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF for OtherComplex<f64> {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_COMPLEX64_or_DT_INT64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF for f32 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_COMPLEX64_or_DT_INT64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF for f64 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_COMPLEX64_or_DT_INT64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF for i32 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_COMPLEX64_or_DT_INT64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF for i64 {
}

impl<T, x_Arg> GraphOperation for Round<T, x_Arg>
where T: TensorType,
      T: Clone,
      x_Arg: Clone,
      x_Arg: GraphEdge<T>,
      x_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_COMPLEX64_or_DT_INT64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF,
      T: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("Round_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("Round", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.x)?
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct Round<T, x_Arg>
where T: TensorType,
      T: Clone,
      x_Arg: Clone,
      x_Arg: GraphEdge<T>,
      x_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_COMPLEX64_or_DT_INT64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    x: x_Arg,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<T, x_Arg> Round<T, x_Arg>
where T: TensorType,
      T: Clone,
      x_Arg: Clone,
      x_Arg: GraphEdge<T>,
      x_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_COMPLEX64_or_DT_INT64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF,
      T: 'static,
{
    pub fn y(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(x: x_Arg) -> Self {
        Self {
            phantom_T: PhantomData,
            x,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(x: x_Arg) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            x,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<dtypes> GraphOperation for OrderedMapClear<dtypes>
where dtypes: TensorType,
      dtypes: 'static,
      dtypes: Clone,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("OrderedMapClear_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("OrderedMapClear", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            match self.capacity {
                None => new_op.set_attr_value_proto("capacity", &vec![24_u8, 0_u8,])?,
                Some(ref value) => (|attr: &i64| {new_op.set_attr_int("capacity", *attr)})(&value)?,
            };
        }
        {
            match self.memory_limit {
                None => new_op.set_attr_value_proto("memory_limit", &vec![24_u8, 0_u8,])?,
                Some(ref value) => (|attr: &i64| {new_op.set_attr_int("memory_limit", *attr)})(&value)?,
            };
        }
        {
            new_op.set_attr_type("dtypes", dtypes::data_type())?;
        }
        {
            match self.container {
                None => new_op.set_attr_value_proto("container", &vec![18_u8, 0_u8,])?,
                Some(ref value) => (|attr| {new_op.set_attr_string("container", attr)})(&value)?,
            };
        }
        {
            match self.shared_name {
                None => new_op.set_attr_value_proto("shared_name", &vec![18_u8, 0_u8,])?,
                Some(ref value) => (|attr| {new_op.set_attr_string("shared_name", attr)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct OrderedMapClear<dtypes>
where dtypes: TensorType,
      dtypes: 'static,
      dtypes: Clone,
{
    capacity: Option<i64>,
    memory_limit: Option<i64>,
    phantom_dtypes: PhantomData<dtypes>,
    container: Option<String>,
    shared_name: Option<String>,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<dtypes> OrderedMapClear<dtypes>
where dtypes: TensorType,
      dtypes: 'static,
      dtypes: Clone,
{
    pub fn capacity(&mut self, capacity: i64) -> Self {
        self.capacity = Some(capacity);
        self.clone()
    }

    pub fn memory_limit(&mut self, memory_limit: i64) -> Self {
        self.memory_limit = Some(memory_limit);
        self.clone()
    }

    pub fn container(&mut self, container: &str) -> Self {
        self.container = Some(container.to_string());
        self.clone()
    }

    pub fn shared_name(&mut self, shared_name: &str) -> Self {
        self.shared_name = Some(shared_name.to_string());
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> () {
        let rc = Rc::new(self);
        (
        )
    }

    pub fn build() -> Self {
        Self {
            capacity: None,
            memory_limit: None,
            phantom_dtypes: PhantomData,
            container: None,
            shared_name: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new() -> () {
        Self {
            capacity: None,
            memory_limit: None,
            phantom_dtypes: PhantomData,
            container: None,
            shared_name: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<dtypes> GraphOperation for MapClear<dtypes>
where dtypes: TensorType,
      dtypes: 'static,
      dtypes: Clone,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("MapClear_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("MapClear", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            match self.capacity {
                None => new_op.set_attr_value_proto("capacity", &vec![24_u8, 0_u8,])?,
                Some(ref value) => (|attr: &i64| {new_op.set_attr_int("capacity", *attr)})(&value)?,
            };
        }
        {
            match self.memory_limit {
                None => new_op.set_attr_value_proto("memory_limit", &vec![24_u8, 0_u8,])?,
                Some(ref value) => (|attr: &i64| {new_op.set_attr_int("memory_limit", *attr)})(&value)?,
            };
        }
        {
            new_op.set_attr_type("dtypes", dtypes::data_type())?;
        }
        {
            match self.container {
                None => new_op.set_attr_value_proto("container", &vec![18_u8, 0_u8,])?,
                Some(ref value) => (|attr| {new_op.set_attr_string("container", attr)})(&value)?,
            };
        }
        {
            match self.shared_name {
                None => new_op.set_attr_value_proto("shared_name", &vec![18_u8, 0_u8,])?,
                Some(ref value) => (|attr| {new_op.set_attr_string("shared_name", attr)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct MapClear<dtypes>
where dtypes: TensorType,
      dtypes: 'static,
      dtypes: Clone,
{
    capacity: Option<i64>,
    memory_limit: Option<i64>,
    phantom_dtypes: PhantomData<dtypes>,
    container: Option<String>,
    shared_name: Option<String>,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<dtypes> MapClear<dtypes>
where dtypes: TensorType,
      dtypes: 'static,
      dtypes: Clone,
{
    pub fn capacity(&mut self, capacity: i64) -> Self {
        self.capacity = Some(capacity);
        self.clone()
    }

    pub fn memory_limit(&mut self, memory_limit: i64) -> Self {
        self.memory_limit = Some(memory_limit);
        self.clone()
    }

    pub fn container(&mut self, container: &str) -> Self {
        self.container = Some(container.to_string());
        self.clone()
    }

    pub fn shared_name(&mut self, shared_name: &str) -> Self {
        self.shared_name = Some(shared_name.to_string());
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> () {
        let rc = Rc::new(self);
        (
        )
    }

    pub fn build() -> Self {
        Self {
            capacity: None,
            memory_limit: None,
            phantom_dtypes: PhantomData,
            container: None,
            shared_name: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new() -> () {
        Self {
            capacity: None,
            memory_limit: None,
            phantom_dtypes: PhantomData,
            container: None,
            shared_name: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<size_Arg, dtype> GraphOperation for TensorArrayV2<size_Arg, dtype>
where size_Arg: Clone,
      size_Arg: GraphEdge<i32>,
      size_Arg: 'static,
      dtype: TensorType,
      dtype: 'static,
      dtype: Clone,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("TensorArrayV2_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("TensorArrayV2", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.size)?
        }
        {
            new_op.set_attr_type("dtype", dtype::data_type())?;
        }
        {
            match self.element_shape {
                None => new_op.set_attr_value_proto("element_shape", &vec![58_u8, 0_u8,])?,
                Some(ref value) => (|attr| {new_op.set_attr_shape("element_shape", attr)})(&value)?,
            };
        }
        {
            match self.dynamic_size {
                None => new_op.set_attr_value_proto("dynamic_size", &vec![40_u8, 0_u8,])?,
                Some(ref value) => (|attr: &bool| {new_op.set_attr_bool("dynamic_size", *attr)})(&value)?,
            };
        }
        {
            match self.clear_after_read {
                None => new_op.set_attr_value_proto("clear_after_read", &vec![40_u8, 1_u8,])?,
                Some(ref value) => (|attr: &bool| {new_op.set_attr_bool("clear_after_read", *attr)})(&value)?,
            };
        }
        {
            match self.tensor_array_name {
                None => new_op.set_attr_value_proto("tensor_array_name", &vec![18_u8, 0_u8,])?,
                Some(ref value) => (|attr| {new_op.set_attr_string("tensor_array_name", attr)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct TensorArrayV2<size_Arg, dtype>
where size_Arg: Clone,
      size_Arg: GraphEdge<i32>,
      size_Arg: 'static,
      dtype: TensorType,
      dtype: 'static,
      dtype: Clone,
{
    size: size_Arg,
    phantom_dtype: PhantomData<dtype>,
    element_shape: Option<OtherShape>,
    dynamic_size: Option<bool>,
    clear_after_read: Option<bool>,
    tensor_array_name: Option<String>,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<size_Arg, dtype> TensorArrayV2<size_Arg, dtype>
where size_Arg: Clone,
      size_Arg: GraphEdge<i32>,
      size_Arg: 'static,
      dtype: TensorType,
      dtype: 'static,
      dtype: Clone,
{
    pub fn handle(self) -> Edge<String> {
        let rc = Rc::new(self);
        {
            Edge::<String>::new(rc.clone(), 0)
        }
    }

    pub fn element_shape(&mut self, element_shape: &OtherShape) -> Self {
        self.element_shape = Some(element_shape.clone());
        self.clone()
    }

    pub fn dynamic_size(&mut self, dynamic_size: bool) -> Self {
        self.dynamic_size = Some(dynamic_size);
        self.clone()
    }

    pub fn clear_after_read(&mut self, clear_after_read: bool) -> Self {
        self.clear_after_read = Some(clear_after_read);
        self.clone()
    }

    pub fn tensor_array_name(&mut self, tensor_array_name: &str) -> Self {
        self.tensor_array_name = Some(tensor_array_name.to_string());
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<String> {
        let rc = Rc::new(self);
        {
            Edge::<String>::new(rc.clone(), 0)
        }
    }

    pub fn build(size: size_Arg) -> Self {
        Self {
            size,
            phantom_dtype: PhantomData,
            element_shape: None,
            dynamic_size: None,
            clear_after_read: None,
            tensor_array_name: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(size: size_Arg) -> Edge<String> {
        Self {
            size,
            phantom_dtype: PhantomData,
            element_shape: None,
            dynamic_size: None,
            clear_after_read: None,
            tensor_array_name: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

pub trait con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_COMPLEX64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_COMPLEX64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF for BFloat16 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_COMPLEX64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF for OtherComplex<f32> {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_COMPLEX64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF for OtherComplex<f64> {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_COMPLEX64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF for f32 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_COMPLEX64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF for f64 {
}

impl<T, x_Arg> GraphOperation for Acosh<T, x_Arg>
where T: TensorType,
      T: Clone,
      x_Arg: Clone,
      x_Arg: GraphEdge<T>,
      x_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_COMPLEX64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF,
      T: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("Acosh_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("Acosh", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.x)?
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct Acosh<T, x_Arg>
where T: TensorType,
      T: Clone,
      x_Arg: Clone,
      x_Arg: GraphEdge<T>,
      x_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_COMPLEX64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    x: x_Arg,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<T, x_Arg> Acosh<T, x_Arg>
where T: TensorType,
      T: Clone,
      x_Arg: Clone,
      x_Arg: GraphEdge<T>,
      x_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_COMPLEX64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF,
      T: 'static,
{
    pub fn y(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(x: x_Arg) -> Self {
        Self {
            phantom_T: PhantomData,
            x,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(x: x_Arg) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            x,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<dtypes> GraphOperation for MapSize<dtypes>
where dtypes: TensorType,
      dtypes: 'static,
      dtypes: Clone,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("MapSize_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("MapSize", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            match self.capacity {
                None => new_op.set_attr_value_proto("capacity", &vec![24_u8, 0_u8,])?,
                Some(ref value) => (|attr: &i64| {new_op.set_attr_int("capacity", *attr)})(&value)?,
            };
        }
        {
            match self.memory_limit {
                None => new_op.set_attr_value_proto("memory_limit", &vec![24_u8, 0_u8,])?,
                Some(ref value) => (|attr: &i64| {new_op.set_attr_int("memory_limit", *attr)})(&value)?,
            };
        }
        {
            new_op.set_attr_type("dtypes", dtypes::data_type())?;
        }
        {
            match self.container {
                None => new_op.set_attr_value_proto("container", &vec![18_u8, 0_u8,])?,
                Some(ref value) => (|attr| {new_op.set_attr_string("container", attr)})(&value)?,
            };
        }
        {
            match self.shared_name {
                None => new_op.set_attr_value_proto("shared_name", &vec![18_u8, 0_u8,])?,
                Some(ref value) => (|attr| {new_op.set_attr_string("shared_name", attr)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct MapSize<dtypes>
where dtypes: TensorType,
      dtypes: 'static,
      dtypes: Clone,
{
    capacity: Option<i64>,
    memory_limit: Option<i64>,
    phantom_dtypes: PhantomData<dtypes>,
    container: Option<String>,
    shared_name: Option<String>,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<dtypes> MapSize<dtypes>
where dtypes: TensorType,
      dtypes: 'static,
      dtypes: Clone,
{
    pub fn size(self) -> Edge<i32> {
        let rc = Rc::new(self);
        {
            Edge::<i32>::new(rc.clone(), 0)
        }
    }

    pub fn capacity(&mut self, capacity: i64) -> Self {
        self.capacity = Some(capacity);
        self.clone()
    }

    pub fn memory_limit(&mut self, memory_limit: i64) -> Self {
        self.memory_limit = Some(memory_limit);
        self.clone()
    }

    pub fn container(&mut self, container: &str) -> Self {
        self.container = Some(container.to_string());
        self.clone()
    }

    pub fn shared_name(&mut self, shared_name: &str) -> Self {
        self.shared_name = Some(shared_name.to_string());
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<i32> {
        let rc = Rc::new(self);
        {
            Edge::<i32>::new(rc.clone(), 0)
        }
    }

    pub fn build() -> Self {
        Self {
            capacity: None,
            memory_limit: None,
            phantom_dtypes: PhantomData,
            container: None,
            shared_name: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new() -> Edge<i32> {
        Self {
            capacity: None,
            memory_limit: None,
            phantom_dtypes: PhantomData,
            container: None,
            shared_name: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<T, input_Arg, Tshift, shift_Arg, Taxis, axis_Arg> GraphOperation for Roll<T, input_Arg, Tshift, shift_Arg, Taxis, axis_Arg>
where T: TensorType,
      T: Clone,
      input_Arg: Clone,
      input_Arg: GraphEdge<T>,
      input_Arg: 'static,
      Tshift: TensorType,
      Tshift: Clone,
      shift_Arg: Clone,
      shift_Arg: GraphEdge<Tshift>,
      shift_Arg: 'static,
      Taxis: TensorType,
      Taxis: Clone,
      axis_Arg: Clone,
      axis_Arg: GraphEdge<Taxis>,
      axis_Arg: 'static,
      T: 'static,
      Tshift: con_or_DT_INT32_or_DT_INT64,
      Tshift: 'static,
      Taxis: con_or_DT_INT32_or_DT_INT64,
      Taxis: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("Roll_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("Roll", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.input)?
        }
        {
            new_op.add_edge(&self.shift)?
        }
        {
            new_op.add_edge(&self.axis)?
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        {
            new_op.set_attr_type("Tshift", Tshift::data_type())?;
        }
        {
            new_op.set_attr_type("Taxis", Taxis::data_type())?;
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct Roll<T, input_Arg, Tshift, shift_Arg, Taxis, axis_Arg>
where T: TensorType,
      T: Clone,
      input_Arg: Clone,
      input_Arg: GraphEdge<T>,
      input_Arg: 'static,
      Tshift: TensorType,
      Tshift: Clone,
      shift_Arg: Clone,
      shift_Arg: GraphEdge<Tshift>,
      shift_Arg: 'static,
      Taxis: TensorType,
      Taxis: Clone,
      axis_Arg: Clone,
      axis_Arg: GraphEdge<Taxis>,
      axis_Arg: 'static,
      T: 'static,
      Tshift: con_or_DT_INT32_or_DT_INT64,
      Tshift: 'static,
      Taxis: con_or_DT_INT32_or_DT_INT64,
      Taxis: 'static,
{
    phantom_T: PhantomData<T>,
    input: input_Arg,
    phantom_Tshift: PhantomData<Tshift>,
    shift: shift_Arg,
    phantom_Taxis: PhantomData<Taxis>,
    axis: axis_Arg,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<T, input_Arg, Tshift, shift_Arg, Taxis, axis_Arg> Roll<T, input_Arg, Tshift, shift_Arg, Taxis, axis_Arg>
where T: TensorType,
      T: Clone,
      input_Arg: Clone,
      input_Arg: GraphEdge<T>,
      input_Arg: 'static,
      Tshift: TensorType,
      Tshift: Clone,
      shift_Arg: Clone,
      shift_Arg: GraphEdge<Tshift>,
      shift_Arg: 'static,
      Taxis: TensorType,
      Taxis: Clone,
      axis_Arg: Clone,
      axis_Arg: GraphEdge<Taxis>,
      axis_Arg: 'static,
      T: 'static,
      Tshift: con_or_DT_INT32_or_DT_INT64,
      Tshift: 'static,
      Taxis: con_or_DT_INT32_or_DT_INT64,
      Taxis: 'static,
{
    pub fn output(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(input: input_Arg, shift: shift_Arg, axis: axis_Arg) -> Self {
        Self {
            phantom_T: PhantomData,
            input,
            phantom_Tshift: PhantomData,
            shift,
            phantom_Taxis: PhantomData,
            axis,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(input: input_Arg, shift: shift_Arg, axis: axis_Arg) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            input,
            phantom_Tshift: PhantomData,
            shift,
            phantom_Taxis: PhantomData,
            axis,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<dtypes> GraphOperation for StageClear<dtypes>
where dtypes: TensorType,
      dtypes: 'static,
      dtypes: Clone,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("StageClear_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("StageClear", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            match self.capacity {
                None => new_op.set_attr_value_proto("capacity", &vec![24_u8, 0_u8,])?,
                Some(ref value) => (|attr: &i64| {new_op.set_attr_int("capacity", *attr)})(&value)?,
            };
        }
        {
            match self.memory_limit {
                None => new_op.set_attr_value_proto("memory_limit", &vec![24_u8, 0_u8,])?,
                Some(ref value) => (|attr: &i64| {new_op.set_attr_int("memory_limit", *attr)})(&value)?,
            };
        }
        {
            new_op.set_attr_type("dtypes", dtypes::data_type())?;
        }
        {
            match self.container {
                None => new_op.set_attr_value_proto("container", &vec![18_u8, 0_u8,])?,
                Some(ref value) => (|attr| {new_op.set_attr_string("container", attr)})(&value)?,
            };
        }
        {
            match self.shared_name {
                None => new_op.set_attr_value_proto("shared_name", &vec![18_u8, 0_u8,])?,
                Some(ref value) => (|attr| {new_op.set_attr_string("shared_name", attr)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct StageClear<dtypes>
where dtypes: TensorType,
      dtypes: 'static,
      dtypes: Clone,
{
    capacity: Option<i64>,
    memory_limit: Option<i64>,
    phantom_dtypes: PhantomData<dtypes>,
    container: Option<String>,
    shared_name: Option<String>,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<dtypes> StageClear<dtypes>
where dtypes: TensorType,
      dtypes: 'static,
      dtypes: Clone,
{
    pub fn capacity(&mut self, capacity: i64) -> Self {
        self.capacity = Some(capacity);
        self.clone()
    }

    pub fn memory_limit(&mut self, memory_limit: i64) -> Self {
        self.memory_limit = Some(memory_limit);
        self.clone()
    }

    pub fn container(&mut self, container: &str) -> Self {
        self.container = Some(container.to_string());
        self.clone()
    }

    pub fn shared_name(&mut self, shared_name: &str) -> Self {
        self.shared_name = Some(shared_name.to_string());
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> () {
        let rc = Rc::new(self);
        (
        )
    }

    pub fn build() -> Self {
        Self {
            capacity: None,
            memory_limit: None,
            phantom_dtypes: PhantomData,
            container: None,
            shared_name: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new() -> () {
        Self {
            capacity: None,
            memory_limit: None,
            phantom_dtypes: PhantomData,
            container: None,
            shared_name: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<overlaps_Arg, scores_Arg, max_output_size_Arg, overlap_threshold_Arg, score_threshold_Arg> GraphOperation for NonMaxSuppressionWithOverlaps<overlaps_Arg, scores_Arg, max_output_size_Arg, overlap_threshold_Arg, score_threshold_Arg>
where overlaps_Arg: Clone,
      overlaps_Arg: GraphEdge<f32>,
      overlaps_Arg: 'static,
      scores_Arg: Clone,
      scores_Arg: GraphEdge<f32>,
      scores_Arg: 'static,
      max_output_size_Arg: Clone,
      max_output_size_Arg: GraphEdge<i32>,
      max_output_size_Arg: 'static,
      overlap_threshold_Arg: Clone,
      overlap_threshold_Arg: GraphEdge<f32>,
      overlap_threshold_Arg: 'static,
      score_threshold_Arg: Clone,
      score_threshold_Arg: GraphEdge<f32>,
      score_threshold_Arg: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("NonMaxSuppressionWithOverlaps_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("NonMaxSuppressionWithOverlaps", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.overlaps)?
        }
        {
            new_op.add_edge(&self.scores)?
        }
        {
            new_op.add_edge(&self.max_output_size)?
        }
        {
            new_op.add_edge(&self.overlap_threshold)?
        }
        {
            new_op.add_edge(&self.score_threshold)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct NonMaxSuppressionWithOverlaps<overlaps_Arg, scores_Arg, max_output_size_Arg, overlap_threshold_Arg, score_threshold_Arg>
where overlaps_Arg: Clone,
      overlaps_Arg: GraphEdge<f32>,
      overlaps_Arg: 'static,
      scores_Arg: Clone,
      scores_Arg: GraphEdge<f32>,
      scores_Arg: 'static,
      max_output_size_Arg: Clone,
      max_output_size_Arg: GraphEdge<i32>,
      max_output_size_Arg: 'static,
      overlap_threshold_Arg: Clone,
      overlap_threshold_Arg: GraphEdge<f32>,
      overlap_threshold_Arg: 'static,
      score_threshold_Arg: Clone,
      score_threshold_Arg: GraphEdge<f32>,
      score_threshold_Arg: 'static,
{
    overlaps: overlaps_Arg,
    scores: scores_Arg,
    max_output_size: max_output_size_Arg,
    overlap_threshold: overlap_threshold_Arg,
    score_threshold: score_threshold_Arg,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<overlaps_Arg, scores_Arg, max_output_size_Arg, overlap_threshold_Arg, score_threshold_Arg> NonMaxSuppressionWithOverlaps<overlaps_Arg, scores_Arg, max_output_size_Arg, overlap_threshold_Arg, score_threshold_Arg>
where overlaps_Arg: Clone,
      overlaps_Arg: GraphEdge<f32>,
      overlaps_Arg: 'static,
      scores_Arg: Clone,
      scores_Arg: GraphEdge<f32>,
      scores_Arg: 'static,
      max_output_size_Arg: Clone,
      max_output_size_Arg: GraphEdge<i32>,
      max_output_size_Arg: 'static,
      overlap_threshold_Arg: Clone,
      overlap_threshold_Arg: GraphEdge<f32>,
      overlap_threshold_Arg: 'static,
      score_threshold_Arg: Clone,
      score_threshold_Arg: GraphEdge<f32>,
      score_threshold_Arg: 'static,
{
    pub fn selected_indices(self) -> Edge<i32> {
        let rc = Rc::new(self);
        {
            Edge::<i32>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<i32> {
        let rc = Rc::new(self);
        {
            Edge::<i32>::new(rc.clone(), 0)
        }
    }

    pub fn build(overlaps: overlaps_Arg, scores: scores_Arg, max_output_size: max_output_size_Arg, overlap_threshold: overlap_threshold_Arg, score_threshold: score_threshold_Arg) -> Self {
        Self {
            overlaps,
            scores,
            max_output_size,
            overlap_threshold,
            score_threshold,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(overlaps: overlaps_Arg, scores: scores_Arg, max_output_size: max_output_size_Arg, overlap_threshold: overlap_threshold_Arg, score_threshold: score_threshold_Arg) -> Edge<i32> {
        Self {
            overlaps,
            scores,
            max_output_size,
            overlap_threshold,
            score_threshold,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<orig_input_shape_Arg, T, grad_Arg> GraphOperation for AvgPoolGrad<orig_input_shape_Arg, T, grad_Arg>
where orig_input_shape_Arg: Clone,
      orig_input_shape_Arg: GraphEdge<i32>,
      orig_input_shape_Arg: 'static,
      T: TensorType,
      T: Clone,
      grad_Arg: Clone,
      grad_Arg: GraphEdge<T>,
      grad_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
      T: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("AvgPoolGrad_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("AvgPoolGrad", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.orig_input_shape)?
        }
        {
            new_op.add_edge(&self.grad)?
        }
        {
            (|attrs| {new_op.set_attr_int_list("ksize", attrs)})(&self.ksize)?
        }
        {
            (|attrs| {new_op.set_attr_int_list("strides", attrs)})(&self.strides)?
        }
        {
            (|attr| {new_op.set_attr_string("padding", attr)})(&self.padding)?
        }
        {
            match self.data_format {
                None => new_op.set_attr_value_proto("data_format", &vec![18_u8, 4_u8, 78_u8, 72_u8, 87_u8, 67_u8,])?,
                Some(ref value) => (|attr| {new_op.set_attr_string("data_format", attr)})(&value)?,
            };
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct AvgPoolGrad<orig_input_shape_Arg, T, grad_Arg>
where orig_input_shape_Arg: Clone,
      orig_input_shape_Arg: GraphEdge<i32>,
      orig_input_shape_Arg: 'static,
      T: TensorType,
      T: Clone,
      grad_Arg: Clone,
      grad_Arg: GraphEdge<T>,
      grad_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
      T: 'static,
{
    orig_input_shape: orig_input_shape_Arg,
    phantom_T: PhantomData<T>,
    grad: grad_Arg,
    ksize: Vec<i64>,
    strides: Vec<i64>,
    padding: String,
    data_format: Option<String>,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<orig_input_shape_Arg, T, grad_Arg> AvgPoolGrad<orig_input_shape_Arg, T, grad_Arg>
where orig_input_shape_Arg: Clone,
      orig_input_shape_Arg: GraphEdge<i32>,
      orig_input_shape_Arg: 'static,
      T: TensorType,
      T: Clone,
      grad_Arg: Clone,
      grad_Arg: GraphEdge<T>,
      grad_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
      T: 'static,
{
    pub fn output(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn data_format(&mut self, data_format: &str) -> Self {
        self.data_format = Some(data_format.to_string());
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(orig_input_shape: orig_input_shape_Arg, grad: grad_Arg, ksize: &[i64], strides: &[i64], padding: &str) -> Self {
        Self {
            orig_input_shape,
            phantom_T: PhantomData,
            grad,
            ksize: ksize.to_vec(),
            strides: strides.to_vec(),
            padding: padding.to_string(),
            data_format: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(orig_input_shape: orig_input_shape_Arg, grad: grad_Arg, ksize: &[i64], strides: &[i64], padding: &str) -> Edge<T> {
        Self {
            orig_input_shape,
            phantom_T: PhantomData,
            grad,
            ksize: ksize.to_vec(),
            strides: strides.to_vec(),
            padding: padding.to_string(),
            data_format: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<dtypes> GraphOperation for StageSize<dtypes>
where dtypes: TensorType,
      dtypes: 'static,
      dtypes: Clone,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("StageSize_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("StageSize", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            match self.capacity {
                None => new_op.set_attr_value_proto("capacity", &vec![24_u8, 0_u8,])?,
                Some(ref value) => (|attr: &i64| {new_op.set_attr_int("capacity", *attr)})(&value)?,
            };
        }
        {
            match self.memory_limit {
                None => new_op.set_attr_value_proto("memory_limit", &vec![24_u8, 0_u8,])?,
                Some(ref value) => (|attr: &i64| {new_op.set_attr_int("memory_limit", *attr)})(&value)?,
            };
        }
        {
            new_op.set_attr_type("dtypes", dtypes::data_type())?;
        }
        {
            match self.container {
                None => new_op.set_attr_value_proto("container", &vec![18_u8, 0_u8,])?,
                Some(ref value) => (|attr| {new_op.set_attr_string("container", attr)})(&value)?,
            };
        }
        {
            match self.shared_name {
                None => new_op.set_attr_value_proto("shared_name", &vec![18_u8, 0_u8,])?,
                Some(ref value) => (|attr| {new_op.set_attr_string("shared_name", attr)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct StageSize<dtypes>
where dtypes: TensorType,
      dtypes: 'static,
      dtypes: Clone,
{
    capacity: Option<i64>,
    memory_limit: Option<i64>,
    phantom_dtypes: PhantomData<dtypes>,
    container: Option<String>,
    shared_name: Option<String>,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<dtypes> StageSize<dtypes>
where dtypes: TensorType,
      dtypes: 'static,
      dtypes: Clone,
{
    pub fn size(self) -> Edge<i32> {
        let rc = Rc::new(self);
        {
            Edge::<i32>::new(rc.clone(), 0)
        }
    }

    pub fn capacity(&mut self, capacity: i64) -> Self {
        self.capacity = Some(capacity);
        self.clone()
    }

    pub fn memory_limit(&mut self, memory_limit: i64) -> Self {
        self.memory_limit = Some(memory_limit);
        self.clone()
    }

    pub fn container(&mut self, container: &str) -> Self {
        self.container = Some(container.to_string());
        self.clone()
    }

    pub fn shared_name(&mut self, shared_name: &str) -> Self {
        self.shared_name = Some(shared_name.to_string());
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<i32> {
        let rc = Rc::new(self);
        {
            Edge::<i32>::new(rc.clone(), 0)
        }
    }

    pub fn build() -> Self {
        Self {
            capacity: None,
            memory_limit: None,
            phantom_dtypes: PhantomData,
            container: None,
            shared_name: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new() -> Edge<i32> {
        Self {
            capacity: None,
            memory_limit: None,
            phantom_dtypes: PhantomData,
            container: None,
            shared_name: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<Tshape, input_sizes_Arg, T, filter_Arg, out_backprop_Arg> GraphOperation for Conv3DBackpropInputV2<Tshape, input_sizes_Arg, T, filter_Arg, out_backprop_Arg>
where Tshape: TensorType,
      Tshape: Clone,
      input_sizes_Arg: Clone,
      input_sizes_Arg: GraphEdge<Tshape>,
      input_sizes_Arg: 'static,
      T: TensorType,
      T: Clone,
      filter_Arg: Clone,
      filter_Arg: GraphEdge<T>,
      filter_Arg: 'static,
      out_backprop_Arg: Clone,
      out_backprop_Arg: GraphEdge<T>,
      out_backprop_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
      T: 'static,
      Tshape: con_or_DT_INT32_or_DT_INT64,
      Tshape: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("Conv3DBackpropInputV2_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("Conv3DBackpropInputV2", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.input_sizes)?
        }
        {
            new_op.add_edge(&self.filter)?
        }
        {
            new_op.add_edge(&self.out_backprop)?
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        {
            (|attrs| {new_op.set_attr_int_list("strides", attrs)})(&self.strides)?
        }
        {
            (|attr| {new_op.set_attr_string("padding", attr)})(&self.padding)?
        }
        {
            match self.data_format {
                None => new_op.set_attr_value_proto("data_format", &vec![18_u8, 5_u8, 78_u8, 68_u8, 72_u8, 87_u8, 67_u8,])?,
                Some(ref value) => (|attr| {new_op.set_attr_string("data_format", attr)})(&value)?,
            };
        }
        {
            match self.dilations {
                None => new_op.set_attr_value_proto("dilations", &vec![10_u8, 0_u8, 26_u8, 5_u8, 1_u8, 1_u8, 1_u8, 1_u8,])?,
                Some(ref value) => (|attrs| {new_op.set_attr_int_list("dilations", attrs)})(&value)?,
            };
        }
        {
            new_op.set_attr_type("Tshape", Tshape::data_type())?;
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct Conv3DBackpropInputV2<Tshape, input_sizes_Arg, T, filter_Arg, out_backprop_Arg>
where Tshape: TensorType,
      Tshape: Clone,
      input_sizes_Arg: Clone,
      input_sizes_Arg: GraphEdge<Tshape>,
      input_sizes_Arg: 'static,
      T: TensorType,
      T: Clone,
      filter_Arg: Clone,
      filter_Arg: GraphEdge<T>,
      filter_Arg: 'static,
      out_backprop_Arg: Clone,
      out_backprop_Arg: GraphEdge<T>,
      out_backprop_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
      T: 'static,
      Tshape: con_or_DT_INT32_or_DT_INT64,
      Tshape: 'static,
{
    phantom_Tshape: PhantomData<Tshape>,
    input_sizes: input_sizes_Arg,
    phantom_T: PhantomData<T>,
    filter: filter_Arg,
    out_backprop: out_backprop_Arg,
    strides: Vec<i64>,
    padding: String,
    data_format: Option<String>,
    dilations: Option<Vec<i64>>,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<Tshape, input_sizes_Arg, T, filter_Arg, out_backprop_Arg> Conv3DBackpropInputV2<Tshape, input_sizes_Arg, T, filter_Arg, out_backprop_Arg>
where Tshape: TensorType,
      Tshape: Clone,
      input_sizes_Arg: Clone,
      input_sizes_Arg: GraphEdge<Tshape>,
      input_sizes_Arg: 'static,
      T: TensorType,
      T: Clone,
      filter_Arg: Clone,
      filter_Arg: GraphEdge<T>,
      filter_Arg: 'static,
      out_backprop_Arg: Clone,
      out_backprop_Arg: GraphEdge<T>,
      out_backprop_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
      T: 'static,
      Tshape: con_or_DT_INT32_or_DT_INT64,
      Tshape: 'static,
{
    pub fn output(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn data_format(&mut self, data_format: &str) -> Self {
        self.data_format = Some(data_format.to_string());
        self.clone()
    }

    pub fn dilations(&mut self, dilations: &[i64]) -> Self {
        self.dilations = Some(dilations.to_vec());
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(input_sizes: input_sizes_Arg, filter: filter_Arg, out_backprop: out_backprop_Arg, strides: &[i64], padding: &str) -> Self {
        Self {
            phantom_Tshape: PhantomData,
            input_sizes,
            phantom_T: PhantomData,
            filter,
            out_backprop,
            strides: strides.to_vec(),
            padding: padding.to_string(),
            data_format: None,
            dilations: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(input_sizes: input_sizes_Arg, filter: filter_Arg, out_backprop: out_backprop_Arg, strides: &[i64], padding: &str) -> Edge<T> {
        Self {
            phantom_Tshape: PhantomData,
            input_sizes,
            phantom_T: PhantomData,
            filter,
            out_backprop,
            strides: strides.to_vec(),
            padding: padding.to_string(),
            data_format: None,
            dilations: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<T, input_Arg> GraphOperation for DepthToSpace<T, input_Arg>
where T: TensorType,
      T: Clone,
      input_Arg: Clone,
      input_Arg: GraphEdge<T>,
      input_Arg: 'static,
      T: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("DepthToSpace_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("DepthToSpace", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.input)?
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        {
            (|attr: &i64| {new_op.set_attr_int("block_size", *attr)})(&self.block_size)?
        }
        {
            match self.data_format {
                None => new_op.set_attr_value_proto("data_format", &vec![18_u8, 4_u8, 78_u8, 72_u8, 87_u8, 67_u8,])?,
                Some(ref value) => (|attr| {new_op.set_attr_string("data_format", attr)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct DepthToSpace<T, input_Arg>
where T: TensorType,
      T: Clone,
      input_Arg: Clone,
      input_Arg: GraphEdge<T>,
      input_Arg: 'static,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    input: input_Arg,
    block_size: i64,
    data_format: Option<String>,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<T, input_Arg> DepthToSpace<T, input_Arg>
where T: TensorType,
      T: Clone,
      input_Arg: Clone,
      input_Arg: GraphEdge<T>,
      input_Arg: 'static,
      T: 'static,
{
    pub fn output(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn data_format(&mut self, data_format: &str) -> Self {
        self.data_format = Some(data_format.to_string());
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(input: input_Arg, block_size: i64) -> Self {
        Self {
            phantom_T: PhantomData,
            input,
            block_size: block_size,
            data_format: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(input: input_Arg, block_size: i64) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            input,
            block_size: block_size,
            data_format: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<handle_Arg> GraphOperation for BarrierReadySize<handle_Arg>
where handle_Arg: Clone,
      handle_Arg: GraphRefEdge<String>,
      handle_Arg: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("BarrierReadySize_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("BarrierReadySize", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.handle)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct BarrierReadySize<handle_Arg>
where handle_Arg: Clone,
      handle_Arg: GraphRefEdge<String>,
      handle_Arg: 'static,
{
    handle: handle_Arg,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<handle_Arg> BarrierReadySize<handle_Arg>
where handle_Arg: Clone,
      handle_Arg: GraphRefEdge<String>,
      handle_Arg: 'static,
{
    pub fn size(self) -> Edge<i32> {
        let rc = Rc::new(self);
        {
            Edge::<i32>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<i32> {
        let rc = Rc::new(self);
        {
            Edge::<i32>::new(rc.clone(), 0)
        }
    }

    pub fn build(handle: handle_Arg) -> Self {
        Self {
            handle,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(handle: handle_Arg) -> Edge<i32> {
        Self {
            handle,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<inputs_Arg> GraphOperation for FakeQuantWithMinMaxArgs<inputs_Arg>
where inputs_Arg: Clone,
      inputs_Arg: GraphEdge<f32>,
      inputs_Arg: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("FakeQuantWithMinMaxArgs_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("FakeQuantWithMinMaxArgs", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.inputs)?
        }
        {
            match self.min {
                None => new_op.set_attr_value_proto("min", &vec![37_u8, 0_u8, 0_u8, 192_u8, 192_u8,])?,
                Some(ref value) => (|attr: &f32| {new_op.set_attr_float("min", *attr)})(&value)?,
            };
        }
        {
            match self.max {
                None => new_op.set_attr_value_proto("max", &vec![37_u8, 0_u8, 0_u8, 192_u8, 64_u8,])?,
                Some(ref value) => (|attr: &f32| {new_op.set_attr_float("max", *attr)})(&value)?,
            };
        }
        {
            match self.num_bits {
                None => new_op.set_attr_value_proto("num_bits", &vec![24_u8, 8_u8,])?,
                Some(ref value) => (|attr: &i64| {new_op.set_attr_int("num_bits", *attr)})(&value)?,
            };
        }
        {
            match self.narrow_range {
                None => new_op.set_attr_value_proto("narrow_range", &vec![40_u8, 0_u8,])?,
                Some(ref value) => (|attr: &bool| {new_op.set_attr_bool("narrow_range", *attr)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct FakeQuantWithMinMaxArgs<inputs_Arg>
where inputs_Arg: Clone,
      inputs_Arg: GraphEdge<f32>,
      inputs_Arg: 'static,
{
    inputs: inputs_Arg,
    min: Option<f32>,
    max: Option<f32>,
    num_bits: Option<i64>,
    narrow_range: Option<bool>,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<inputs_Arg> FakeQuantWithMinMaxArgs<inputs_Arg>
where inputs_Arg: Clone,
      inputs_Arg: GraphEdge<f32>,
      inputs_Arg: 'static,
{
    pub fn outputs(self) -> Edge<f32> {
        let rc = Rc::new(self);
        {
            Edge::<f32>::new(rc.clone(), 0)
        }
    }

    pub fn min(&mut self, min: f32) -> Self {
        self.min = Some(min);
        self.clone()
    }

    pub fn max(&mut self, max: f32) -> Self {
        self.max = Some(max);
        self.clone()
    }

    pub fn num_bits(&mut self, num_bits: i64) -> Self {
        self.num_bits = Some(num_bits);
        self.clone()
    }

    pub fn narrow_range(&mut self, narrow_range: bool) -> Self {
        self.narrow_range = Some(narrow_range);
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<f32> {
        let rc = Rc::new(self);
        {
            Edge::<f32>::new(rc.clone(), 0)
        }
    }

    pub fn build(inputs: inputs_Arg) -> Self {
        Self {
            inputs,
            min: None,
            max: None,
            num_bits: None,
            narrow_range: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(inputs: inputs_Arg) -> Edge<f32> {
        Self {
            inputs,
            min: None,
            max: None,
            num_bits: None,
            narrow_range: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<handle_Arg> GraphOperation for BarrierClose<handle_Arg>
where handle_Arg: Clone,
      handle_Arg: GraphRefEdge<String>,
      handle_Arg: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("BarrierClose_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("BarrierClose", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.handle)?
        }
        {
            match self.cancel_pending_enqueues {
                None => new_op.set_attr_value_proto("cancel_pending_enqueues", &vec![40_u8, 0_u8,])?,
                Some(ref value) => (|attr: &bool| {new_op.set_attr_bool("cancel_pending_enqueues", *attr)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct BarrierClose<handle_Arg>
where handle_Arg: Clone,
      handle_Arg: GraphRefEdge<String>,
      handle_Arg: 'static,
{
    handle: handle_Arg,
    cancel_pending_enqueues: Option<bool>,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<handle_Arg> BarrierClose<handle_Arg>
where handle_Arg: Clone,
      handle_Arg: GraphRefEdge<String>,
      handle_Arg: 'static,
{
    pub fn cancel_pending_enqueues(&mut self, cancel_pending_enqueues: bool) -> Self {
        self.cancel_pending_enqueues = Some(cancel_pending_enqueues);
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> () {
        let rc = Rc::new(self);
        (
        )
    }

    pub fn build(handle: handle_Arg) -> Self {
        Self {
            handle,
            cancel_pending_enqueues: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(handle: handle_Arg) -> () {
        Self {
            handle,
            cancel_pending_enqueues: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<handle_Arg, keys_Arg, T, values_Arg> GraphOperation for BarrierInsertMany<handle_Arg, keys_Arg, T, values_Arg>
where handle_Arg: Clone,
      handle_Arg: GraphRefEdge<String>,
      handle_Arg: 'static,
      keys_Arg: Clone,
      keys_Arg: GraphEdge<String>,
      keys_Arg: 'static,
      T: TensorType,
      T: Clone,
      values_Arg: Clone,
      values_Arg: GraphEdge<T>,
      values_Arg: 'static,
      T: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("BarrierInsertMany_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("BarrierInsertMany", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.handle)?
        }
        {
            new_op.add_edge(&self.keys)?
        }
        {
            new_op.add_edge(&self.values)?
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        {
            (|attr: &i64| {new_op.set_attr_int("component_index", *attr)})(&self.component_index)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct BarrierInsertMany<handle_Arg, keys_Arg, T, values_Arg>
where handle_Arg: Clone,
      handle_Arg: GraphRefEdge<String>,
      handle_Arg: 'static,
      keys_Arg: Clone,
      keys_Arg: GraphEdge<String>,
      keys_Arg: 'static,
      T: TensorType,
      T: Clone,
      values_Arg: Clone,
      values_Arg: GraphEdge<T>,
      values_Arg: 'static,
      T: 'static,
{
    handle: handle_Arg,
    keys: keys_Arg,
    phantom_T: PhantomData<T>,
    values: values_Arg,
    component_index: i64,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<handle_Arg, keys_Arg, T, values_Arg> BarrierInsertMany<handle_Arg, keys_Arg, T, values_Arg>
where handle_Arg: Clone,
      handle_Arg: GraphRefEdge<String>,
      handle_Arg: 'static,
      keys_Arg: Clone,
      keys_Arg: GraphEdge<String>,
      keys_Arg: 'static,
      T: TensorType,
      T: Clone,
      values_Arg: Clone,
      values_Arg: GraphEdge<T>,
      values_Arg: 'static,
      T: 'static,
{
    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> () {
        let rc = Rc::new(self);
        (
        )
    }

    pub fn build(handle: handle_Arg, keys: keys_Arg, values: values_Arg, component_index: i64) -> Self {
        Self {
            handle,
            keys,
            phantom_T: PhantomData,
            values,
            component_index: component_index,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(handle: handle_Arg, keys: keys_Arg, values: values_Arg, component_index: i64) -> () {
        Self {
            handle,
            keys,
            phantom_T: PhantomData,
            values,
            component_index: component_index,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<T, x_Arg> GraphOperation for Erf<T, x_Arg>
where T: TensorType,
      T: Clone,
      x_Arg: Clone,
      x_Arg: GraphEdge<T>,
      x_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
      T: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("Erf_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("Erf", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.x)?
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct Erf<T, x_Arg>
where T: TensorType,
      T: Clone,
      x_Arg: Clone,
      x_Arg: GraphEdge<T>,
      x_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    x: x_Arg,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<T, x_Arg> Erf<T, x_Arg>
where T: TensorType,
      T: Clone,
      x_Arg: Clone,
      x_Arg: GraphEdge<T>,
      x_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
      T: 'static,
{
    pub fn y(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(x: x_Arg) -> Self {
        Self {
            phantom_T: PhantomData,
            x,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(x: x_Arg) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            x,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<T, x_Arg> GraphOperation for Floor<T, x_Arg>
where T: TensorType,
      T: Clone,
      x_Arg: Clone,
      x_Arg: GraphEdge<T>,
      x_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
      T: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("Floor_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("Floor", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.x)?
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct Floor<T, x_Arg>
where T: TensorType,
      T: Clone,
      x_Arg: Clone,
      x_Arg: GraphEdge<T>,
      x_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    x: x_Arg,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<T, x_Arg> Floor<T, x_Arg>
where T: TensorType,
      T: Clone,
      x_Arg: Clone,
      x_Arg: GraphEdge<T>,
      x_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
      T: 'static,
{
    pub fn y(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(x: x_Arg) -> Self {
        Self {
            phantom_T: PhantomData,
            x,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(x: x_Arg) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            x,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<handle_Arg, flow_in_Arg> GraphOperation for TensorArraySizeV2<handle_Arg, flow_in_Arg>
where handle_Arg: Clone,
      handle_Arg: GraphEdge<String>,
      handle_Arg: 'static,
      flow_in_Arg: Clone,
      flow_in_Arg: GraphEdge<f32>,
      flow_in_Arg: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("TensorArraySizeV2_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("TensorArraySizeV2", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.handle)?
        }
        {
            new_op.add_edge(&self.flow_in)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct TensorArraySizeV2<handle_Arg, flow_in_Arg>
where handle_Arg: Clone,
      handle_Arg: GraphEdge<String>,
      handle_Arg: 'static,
      flow_in_Arg: Clone,
      flow_in_Arg: GraphEdge<f32>,
      flow_in_Arg: 'static,
{
    handle: handle_Arg,
    flow_in: flow_in_Arg,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<handle_Arg, flow_in_Arg> TensorArraySizeV2<handle_Arg, flow_in_Arg>
where handle_Arg: Clone,
      handle_Arg: GraphEdge<String>,
      handle_Arg: 'static,
      flow_in_Arg: Clone,
      flow_in_Arg: GraphEdge<f32>,
      flow_in_Arg: 'static,
{
    pub fn size(self) -> Edge<i32> {
        let rc = Rc::new(self);
        {
            Edge::<i32>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<i32> {
        let rc = Rc::new(self);
        {
            Edge::<i32>::new(rc.clone(), 0)
        }
    }

    pub fn build(handle: handle_Arg, flow_in: flow_in_Arg) -> Self {
        Self {
            handle,
            flow_in,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(handle: handle_Arg, flow_in: flow_in_Arg) -> Edge<i32> {
        Self {
            handle,
            flow_in,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<handle_Arg, flow_in_Arg, dtype> GraphOperation for TensorArrayConcat<handle_Arg, flow_in_Arg, dtype>
where handle_Arg: Clone,
      handle_Arg: GraphRefEdge<String>,
      handle_Arg: 'static,
      flow_in_Arg: Clone,
      flow_in_Arg: GraphEdge<f32>,
      flow_in_Arg: 'static,
      dtype: TensorType,
      dtype: 'static,
      dtype: Clone,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("TensorArrayConcat_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("TensorArrayConcat", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.handle)?
        }
        {
            new_op.add_edge(&self.flow_in)?
        }
        {
            new_op.set_attr_type("dtype", dtype::data_type())?;
        }
        {
            match self.element_shape_except0 {
                None => new_op.set_attr_value_proto("element_shape_except0", &vec![58_u8, 0_u8,])?,
                Some(ref value) => (|attr| {new_op.set_attr_shape("element_shape_except0", attr)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct TensorArrayConcat<handle_Arg, flow_in_Arg, dtype>
where handle_Arg: Clone,
      handle_Arg: GraphRefEdge<String>,
      handle_Arg: 'static,
      flow_in_Arg: Clone,
      flow_in_Arg: GraphEdge<f32>,
      flow_in_Arg: 'static,
      dtype: TensorType,
      dtype: 'static,
      dtype: Clone,
{
    handle: handle_Arg,
    flow_in: flow_in_Arg,
    phantom_dtype: PhantomData<dtype>,
    element_shape_except0: Option<OtherShape>,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<handle_Arg, flow_in_Arg, dtype> TensorArrayConcat<handle_Arg, flow_in_Arg, dtype>
where handle_Arg: Clone,
      handle_Arg: GraphRefEdge<String>,
      handle_Arg: 'static,
      flow_in_Arg: Clone,
      flow_in_Arg: GraphEdge<f32>,
      flow_in_Arg: 'static,
      dtype: TensorType,
      dtype: 'static,
      dtype: Clone,
{
    pub fn value(self) -> Edge<dtype> {
        let rc = Rc::new(self);
        {
            Edge::<dtype>::new(rc.clone(), 0)
        }
    }

    pub fn lengths(self) -> Edge<i64> {
        let rc = Rc::new(self);
        {
            Edge::<i64>::new(rc.clone(), 1)
        }
    }

    pub fn element_shape_except0(&mut self, element_shape_except0: &OtherShape) -> Self {
        self.element_shape_except0 = Some(element_shape_except0.clone());
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> (Edge<dtype>, Edge<i64>) {
        let rc = Rc::new(self);
        (
        {
            Edge::<dtype>::new(rc.clone(), 0)
        },
        {
            Edge::<i64>::new(rc.clone(), 1)
        },
        )
    }

    pub fn build(handle: handle_Arg, flow_in: flow_in_Arg) -> Self {
        Self {
            handle,
            flow_in,
            phantom_dtype: PhantomData,
            element_shape_except0: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(handle: handle_Arg, flow_in: flow_in_Arg) -> (Edge<dtype>, Edge<i64>) {
        Self {
            handle,
            flow_in,
            phantom_dtype: PhantomData,
            element_shape_except0: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

pub trait con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_COMPLEX64_or_DT_COMPLEX128 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_COMPLEX64_or_DT_COMPLEX128 for OtherComplex<f32> {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_COMPLEX64_or_DT_COMPLEX128 for OtherComplex<f64> {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_COMPLEX64_or_DT_COMPLEX128 for f32 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_COMPLEX64_or_DT_COMPLEX128 for f64 {
}

impl<T, input_Arg> GraphOperation for MatrixSquareRoot<T, input_Arg>
where T: TensorType,
      T: Clone,
      input_Arg: Clone,
      input_Arg: GraphEdge<T>,
      input_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_COMPLEX64_or_DT_COMPLEX128,
      T: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("MatrixSquareRoot_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("MatrixSquareRoot", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.input)?
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct MatrixSquareRoot<T, input_Arg>
where T: TensorType,
      T: Clone,
      input_Arg: Clone,
      input_Arg: GraphEdge<T>,
      input_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_COMPLEX64_or_DT_COMPLEX128,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    input: input_Arg,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<T, input_Arg> MatrixSquareRoot<T, input_Arg>
where T: TensorType,
      T: Clone,
      input_Arg: Clone,
      input_Arg: GraphEdge<T>,
      input_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_COMPLEX64_or_DT_COMPLEX128,
      T: 'static,
{
    pub fn output(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(input: input_Arg) -> Self {
        Self {
            phantom_T: PhantomData,
            input,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(input: input_Arg) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            input,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<T, var_Arg, gradient_accumulator_Arg, gradient_squared_accumulator_Arg, grad_Arg, Tindices, indices_Arg, lr_Arg, l1_Arg, l2_Arg, global_step_Arg> GraphOperation for SparseApplyAdagradDA<T, var_Arg, gradient_accumulator_Arg, gradient_squared_accumulator_Arg, grad_Arg, Tindices, indices_Arg, lr_Arg, l1_Arg, l2_Arg, global_step_Arg>
where T: TensorType,
      T: Clone,
      var_Arg: Clone,
      var_Arg: GraphRefEdge<T>,
      var_Arg: 'static,
      gradient_accumulator_Arg: Clone,
      gradient_accumulator_Arg: GraphRefEdge<T>,
      gradient_accumulator_Arg: 'static,
      gradient_squared_accumulator_Arg: Clone,
      gradient_squared_accumulator_Arg: GraphRefEdge<T>,
      gradient_squared_accumulator_Arg: 'static,
      grad_Arg: Clone,
      grad_Arg: GraphEdge<T>,
      grad_Arg: 'static,
      Tindices: TensorType,
      Tindices: Clone,
      indices_Arg: Clone,
      indices_Arg: GraphEdge<Tindices>,
      indices_Arg: 'static,
      lr_Arg: Clone,
      lr_Arg: GraphEdge<T>,
      lr_Arg: 'static,
      l1_Arg: Clone,
      l1_Arg: GraphEdge<T>,
      l1_Arg: 'static,
      l2_Arg: Clone,
      l2_Arg: GraphEdge<T>,
      l2_Arg: 'static,
      global_step_Arg: Clone,
      global_step_Arg: GraphEdge<i64>,
      global_step_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
      Tindices: con_or_DT_INT32_or_DT_INT64,
      Tindices: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("SparseApplyAdagradDA_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("SparseApplyAdagradDA", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.var)?
        }
        {
            new_op.add_edge(&self.gradient_accumulator)?
        }
        {
            new_op.add_edge(&self.gradient_squared_accumulator)?
        }
        {
            new_op.add_edge(&self.grad)?
        }
        {
            new_op.add_edge(&self.indices)?
        }
        {
            new_op.add_edge(&self.lr)?
        }
        {
            new_op.add_edge(&self.l1)?
        }
        {
            new_op.add_edge(&self.l2)?
        }
        {
            new_op.add_edge(&self.global_step)?
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        {
            new_op.set_attr_type("Tindices", Tindices::data_type())?;
        }
        {
            match self.use_locking {
                None => new_op.set_attr_value_proto("use_locking", &vec![40_u8, 0_u8,])?,
                Some(ref value) => (|attr: &bool| {new_op.set_attr_bool("use_locking", *attr)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct SparseApplyAdagradDA<T, var_Arg, gradient_accumulator_Arg, gradient_squared_accumulator_Arg, grad_Arg, Tindices, indices_Arg, lr_Arg, l1_Arg, l2_Arg, global_step_Arg>
where T: TensorType,
      T: Clone,
      var_Arg: Clone,
      var_Arg: GraphRefEdge<T>,
      var_Arg: 'static,
      gradient_accumulator_Arg: Clone,
      gradient_accumulator_Arg: GraphRefEdge<T>,
      gradient_accumulator_Arg: 'static,
      gradient_squared_accumulator_Arg: Clone,
      gradient_squared_accumulator_Arg: GraphRefEdge<T>,
      gradient_squared_accumulator_Arg: 'static,
      grad_Arg: Clone,
      grad_Arg: GraphEdge<T>,
      grad_Arg: 'static,
      Tindices: TensorType,
      Tindices: Clone,
      indices_Arg: Clone,
      indices_Arg: GraphEdge<Tindices>,
      indices_Arg: 'static,
      lr_Arg: Clone,
      lr_Arg: GraphEdge<T>,
      lr_Arg: 'static,
      l1_Arg: Clone,
      l1_Arg: GraphEdge<T>,
      l1_Arg: 'static,
      l2_Arg: Clone,
      l2_Arg: GraphEdge<T>,
      l2_Arg: 'static,
      global_step_Arg: Clone,
      global_step_Arg: GraphEdge<i64>,
      global_step_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
      Tindices: con_or_DT_INT32_or_DT_INT64,
      Tindices: 'static,
{
    phantom_T: PhantomData<T>,
    var: var_Arg,
    gradient_accumulator: gradient_accumulator_Arg,
    gradient_squared_accumulator: gradient_squared_accumulator_Arg,
    grad: grad_Arg,
    phantom_Tindices: PhantomData<Tindices>,
    indices: indices_Arg,
    lr: lr_Arg,
    l1: l1_Arg,
    l2: l2_Arg,
    global_step: global_step_Arg,
    use_locking: Option<bool>,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<T, var_Arg, gradient_accumulator_Arg, gradient_squared_accumulator_Arg, grad_Arg, Tindices, indices_Arg, lr_Arg, l1_Arg, l2_Arg, global_step_Arg> SparseApplyAdagradDA<T, var_Arg, gradient_accumulator_Arg, gradient_squared_accumulator_Arg, grad_Arg, Tindices, indices_Arg, lr_Arg, l1_Arg, l2_Arg, global_step_Arg>
where T: TensorType,
      T: Clone,
      var_Arg: Clone,
      var_Arg: GraphRefEdge<T>,
      var_Arg: 'static,
      gradient_accumulator_Arg: Clone,
      gradient_accumulator_Arg: GraphRefEdge<T>,
      gradient_accumulator_Arg: 'static,
      gradient_squared_accumulator_Arg: Clone,
      gradient_squared_accumulator_Arg: GraphRefEdge<T>,
      gradient_squared_accumulator_Arg: 'static,
      grad_Arg: Clone,
      grad_Arg: GraphEdge<T>,
      grad_Arg: 'static,
      Tindices: TensorType,
      Tindices: Clone,
      indices_Arg: Clone,
      indices_Arg: GraphEdge<Tindices>,
      indices_Arg: 'static,
      lr_Arg: Clone,
      lr_Arg: GraphEdge<T>,
      lr_Arg: 'static,
      l1_Arg: Clone,
      l1_Arg: GraphEdge<T>,
      l1_Arg: 'static,
      l2_Arg: Clone,
      l2_Arg: GraphEdge<T>,
      l2_Arg: 'static,
      global_step_Arg: Clone,
      global_step_Arg: GraphEdge<i64>,
      global_step_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
      Tindices: con_or_DT_INT32_or_DT_INT64,
      Tindices: 'static,
{
    pub fn out(self) -> RefEdge<T> {
        let rc = Rc::new(self);
        {
            RefEdge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn use_locking(&mut self, use_locking: bool) -> Self {
        self.use_locking = Some(use_locking);
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> RefEdge<T> {
        let rc = Rc::new(self);
        {
            RefEdge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(var: var_Arg, gradient_accumulator: gradient_accumulator_Arg, gradient_squared_accumulator: gradient_squared_accumulator_Arg, grad: grad_Arg, indices: indices_Arg, lr: lr_Arg, l1: l1_Arg, l2: l2_Arg, global_step: global_step_Arg) -> Self {
        Self {
            phantom_T: PhantomData,
            var,
            gradient_accumulator,
            gradient_squared_accumulator,
            grad,
            phantom_Tindices: PhantomData,
            indices,
            lr,
            l1,
            l2,
            global_step,
            use_locking: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(var: var_Arg, gradient_accumulator: gradient_accumulator_Arg, gradient_squared_accumulator: gradient_squared_accumulator_Arg, grad: grad_Arg, indices: indices_Arg, lr: lr_Arg, l1: l1_Arg, l2: l2_Arg, global_step: global_step_Arg) -> RefEdge<T> {
        Self {
            phantom_T: PhantomData,
            var,
            gradient_accumulator,
            gradient_squared_accumulator,
            grad,
            phantom_Tindices: PhantomData,
            indices,
            lr,
            l1,
            l2,
            global_step,
            use_locking: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<T, x_Arg, y_Arg> GraphOperation for DivNoNan<T, x_Arg, y_Arg>
where T: TensorType,
      T: Clone,
      x_Arg: Clone,
      x_Arg: GraphEdge<T>,
      x_Arg: 'static,
      y_Arg: Clone,
      y_Arg: GraphEdge<T>,
      y_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE,
      T: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("DivNoNan_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("DivNoNan", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.x)?
        }
        {
            new_op.add_edge(&self.y)?
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct DivNoNan<T, x_Arg, y_Arg>
where T: TensorType,
      T: Clone,
      x_Arg: Clone,
      x_Arg: GraphEdge<T>,
      x_Arg: 'static,
      y_Arg: Clone,
      y_Arg: GraphEdge<T>,
      y_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    x: x_Arg,
    y: y_Arg,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<T, x_Arg, y_Arg> DivNoNan<T, x_Arg, y_Arg>
where T: TensorType,
      T: Clone,
      x_Arg: Clone,
      x_Arg: GraphEdge<T>,
      x_Arg: 'static,
      y_Arg: Clone,
      y_Arg: GraphEdge<T>,
      y_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE,
      T: 'static,
{
    pub fn z(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(x: x_Arg, y: y_Arg) -> Self {
        Self {
            phantom_T: PhantomData,
            x,
            y,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(x: x_Arg, y: y_Arg) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            x,
            y,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<handle_Arg, indices_Arg, T, value_Arg, flow_in_Arg> GraphOperation for TensorArrayScatter<handle_Arg, indices_Arg, T, value_Arg, flow_in_Arg>
where handle_Arg: Clone,
      handle_Arg: GraphRefEdge<String>,
      handle_Arg: 'static,
      indices_Arg: Clone,
      indices_Arg: GraphEdge<i32>,
      indices_Arg: 'static,
      T: TensorType,
      T: Clone,
      value_Arg: Clone,
      value_Arg: GraphEdge<T>,
      value_Arg: 'static,
      flow_in_Arg: Clone,
      flow_in_Arg: GraphEdge<f32>,
      flow_in_Arg: 'static,
      T: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("TensorArrayScatter_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("TensorArrayScatter", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.handle)?
        }
        {
            new_op.add_edge(&self.indices)?
        }
        {
            new_op.add_edge(&self.value)?
        }
        {
            new_op.add_edge(&self.flow_in)?
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct TensorArrayScatter<handle_Arg, indices_Arg, T, value_Arg, flow_in_Arg>
where handle_Arg: Clone,
      handle_Arg: GraphRefEdge<String>,
      handle_Arg: 'static,
      indices_Arg: Clone,
      indices_Arg: GraphEdge<i32>,
      indices_Arg: 'static,
      T: TensorType,
      T: Clone,
      value_Arg: Clone,
      value_Arg: GraphEdge<T>,
      value_Arg: 'static,
      flow_in_Arg: Clone,
      flow_in_Arg: GraphEdge<f32>,
      flow_in_Arg: 'static,
      T: 'static,
{
    handle: handle_Arg,
    indices: indices_Arg,
    phantom_T: PhantomData<T>,
    value: value_Arg,
    flow_in: flow_in_Arg,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<handle_Arg, indices_Arg, T, value_Arg, flow_in_Arg> TensorArrayScatter<handle_Arg, indices_Arg, T, value_Arg, flow_in_Arg>
where handle_Arg: Clone,
      handle_Arg: GraphRefEdge<String>,
      handle_Arg: 'static,
      indices_Arg: Clone,
      indices_Arg: GraphEdge<i32>,
      indices_Arg: 'static,
      T: TensorType,
      T: Clone,
      value_Arg: Clone,
      value_Arg: GraphEdge<T>,
      value_Arg: 'static,
      flow_in_Arg: Clone,
      flow_in_Arg: GraphEdge<f32>,
      flow_in_Arg: 'static,
      T: 'static,
{
    pub fn flow_out(self) -> Edge<f32> {
        let rc = Rc::new(self);
        {
            Edge::<f32>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<f32> {
        let rc = Rc::new(self);
        {
            Edge::<f32>::new(rc.clone(), 0)
        }
    }

    pub fn build(handle: handle_Arg, indices: indices_Arg, value: value_Arg, flow_in: flow_in_Arg) -> Self {
        Self {
            handle,
            indices,
            phantom_T: PhantomData,
            value,
            flow_in,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(handle: handle_Arg, indices: indices_Arg, value: value_Arg, flow_in: flow_in_Arg) -> Edge<f32> {
        Self {
            handle,
            indices,
            phantom_T: PhantomData,
            value,
            flow_in,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<input_indices_Arg, T, input_values_Arg, input_shape_Arg, reduction_axes_Arg> GraphOperation for SparseReduceMax<input_indices_Arg, T, input_values_Arg, input_shape_Arg, reduction_axes_Arg>
where input_indices_Arg: Clone,
      input_indices_Arg: GraphEdge<i64>,
      input_indices_Arg: 'static,
      T: TensorType,
      T: Clone,
      input_values_Arg: Clone,
      input_values_Arg: GraphEdge<T>,
      input_values_Arg: 'static,
      input_shape_Arg: Clone,
      input_shape_Arg: GraphEdge<i64>,
      input_shape_Arg: 'static,
      reduction_axes_Arg: Clone,
      reduction_axes_Arg: GraphEdge<i32>,
      reduction_axes_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("SparseReduceMax_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("SparseReduceMax", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.input_indices)?
        }
        {
            new_op.add_edge(&self.input_values)?
        }
        {
            new_op.add_edge(&self.input_shape)?
        }
        {
            new_op.add_edge(&self.reduction_axes)?
        }
        {
            match self.keep_dims {
                None => new_op.set_attr_value_proto("keep_dims", &vec![40_u8, 0_u8,])?,
                Some(ref value) => (|attr: &bool| {new_op.set_attr_bool("keep_dims", *attr)})(&value)?,
            };
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct SparseReduceMax<input_indices_Arg, T, input_values_Arg, input_shape_Arg, reduction_axes_Arg>
where input_indices_Arg: Clone,
      input_indices_Arg: GraphEdge<i64>,
      input_indices_Arg: 'static,
      T: TensorType,
      T: Clone,
      input_values_Arg: Clone,
      input_values_Arg: GraphEdge<T>,
      input_values_Arg: 'static,
      input_shape_Arg: Clone,
      input_shape_Arg: GraphEdge<i64>,
      input_shape_Arg: 'static,
      reduction_axes_Arg: Clone,
      reduction_axes_Arg: GraphEdge<i32>,
      reduction_axes_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
{
    input_indices: input_indices_Arg,
    phantom_T: PhantomData<T>,
    input_values: input_values_Arg,
    input_shape: input_shape_Arg,
    reduction_axes: reduction_axes_Arg,
    keep_dims: Option<bool>,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<input_indices_Arg, T, input_values_Arg, input_shape_Arg, reduction_axes_Arg> SparseReduceMax<input_indices_Arg, T, input_values_Arg, input_shape_Arg, reduction_axes_Arg>
where input_indices_Arg: Clone,
      input_indices_Arg: GraphEdge<i64>,
      input_indices_Arg: 'static,
      T: TensorType,
      T: Clone,
      input_values_Arg: Clone,
      input_values_Arg: GraphEdge<T>,
      input_values_Arg: 'static,
      input_shape_Arg: Clone,
      input_shape_Arg: GraphEdge<i64>,
      input_shape_Arg: 'static,
      reduction_axes_Arg: Clone,
      reduction_axes_Arg: GraphEdge<i32>,
      reduction_axes_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
{
    pub fn output(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn keep_dims(&mut self, keep_dims: bool) -> Self {
        self.keep_dims = Some(keep_dims);
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(input_indices: input_indices_Arg, input_values: input_values_Arg, input_shape: input_shape_Arg, reduction_axes: reduction_axes_Arg) -> Self {
        Self {
            input_indices,
            phantom_T: PhantomData,
            input_values,
            input_shape,
            reduction_axes,
            keep_dims: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(input_indices: input_indices_Arg, input_values: input_values_Arg, input_shape: input_shape_Arg, reduction_axes: reduction_axes_Arg) -> Edge<T> {
        Self {
            input_indices,
            phantom_T: PhantomData,
            input_values,
            input_shape,
            reduction_axes,
            keep_dims: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<handle_Arg, T, value_Arg, flow_in_Arg> GraphOperation for TensorArrayUnpack<handle_Arg, T, value_Arg, flow_in_Arg>
where handle_Arg: Clone,
      handle_Arg: GraphRefEdge<String>,
      handle_Arg: 'static,
      T: TensorType,
      T: Clone,
      value_Arg: Clone,
      value_Arg: GraphEdge<T>,
      value_Arg: 'static,
      flow_in_Arg: Clone,
      flow_in_Arg: GraphEdge<f32>,
      flow_in_Arg: 'static,
      T: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("TensorArrayUnpack_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("TensorArrayUnpack", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.handle)?
        }
        {
            new_op.add_edge(&self.value)?
        }
        {
            new_op.add_edge(&self.flow_in)?
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct TensorArrayUnpack<handle_Arg, T, value_Arg, flow_in_Arg>
where handle_Arg: Clone,
      handle_Arg: GraphRefEdge<String>,
      handle_Arg: 'static,
      T: TensorType,
      T: Clone,
      value_Arg: Clone,
      value_Arg: GraphEdge<T>,
      value_Arg: 'static,
      flow_in_Arg: Clone,
      flow_in_Arg: GraphEdge<f32>,
      flow_in_Arg: 'static,
      T: 'static,
{
    handle: handle_Arg,
    phantom_T: PhantomData<T>,
    value: value_Arg,
    flow_in: flow_in_Arg,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<handle_Arg, T, value_Arg, flow_in_Arg> TensorArrayUnpack<handle_Arg, T, value_Arg, flow_in_Arg>
where handle_Arg: Clone,
      handle_Arg: GraphRefEdge<String>,
      handle_Arg: 'static,
      T: TensorType,
      T: Clone,
      value_Arg: Clone,
      value_Arg: GraphEdge<T>,
      value_Arg: 'static,
      flow_in_Arg: Clone,
      flow_in_Arg: GraphEdge<f32>,
      flow_in_Arg: 'static,
      T: 'static,
{
    pub fn flow_out(self) -> Edge<f32> {
        let rc = Rc::new(self);
        {
            Edge::<f32>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<f32> {
        let rc = Rc::new(self);
        {
            Edge::<f32>::new(rc.clone(), 0)
        }
    }

    pub fn build(handle: handle_Arg, value: value_Arg, flow_in: flow_in_Arg) -> Self {
        Self {
            handle,
            phantom_T: PhantomData,
            value,
            flow_in,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(handle: handle_Arg, value: value_Arg, flow_in: flow_in_Arg) -> Edge<f32> {
        Self {
            handle,
            phantom_T: PhantomData,
            value,
            flow_in,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<inputs_Arg> GraphOperation for _ConfigureDistributedTPU<inputs_Arg>
where inputs_Arg: Clone,
      inputs_Arg: GraphEdge<i32>,
      inputs_Arg: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("_ConfigureDistributedTPU_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("_ConfigureDistributedTPU", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.inputs)?
        }
        {
            (|attr: &i64| {new_op.set_attr_int("N", *attr)})(&self.N)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct _ConfigureDistributedTPU<inputs_Arg>
where inputs_Arg: Clone,
      inputs_Arg: GraphEdge<i32>,
      inputs_Arg: 'static,
{
    inputs: inputs_Arg,
    N: i64,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<inputs_Arg> _ConfigureDistributedTPU<inputs_Arg>
where inputs_Arg: Clone,
      inputs_Arg: GraphEdge<i32>,
      inputs_Arg: 'static,
{
    pub fn output(self) -> Edge<String> {
        let rc = Rc::new(self);
        {
            Edge::<String>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<String> {
        let rc = Rc::new(self);
        {
            Edge::<String>::new(rc.clone(), 0)
        }
    }

    pub fn build(inputs: inputs_Arg, N: i64) -> Self {
        Self {
            inputs,
            N: N,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(inputs: inputs_Arg, N: i64) -> Edge<String> {
        Self {
            inputs,
            N: N,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<handle_Arg, flow_in_Arg> GraphOperation for TensorArrayGradV2<handle_Arg, flow_in_Arg>
where handle_Arg: Clone,
      handle_Arg: GraphEdge<String>,
      handle_Arg: 'static,
      flow_in_Arg: Clone,
      flow_in_Arg: GraphEdge<f32>,
      flow_in_Arg: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("TensorArrayGradV2_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("TensorArrayGradV2", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.handle)?
        }
        {
            new_op.add_edge(&self.flow_in)?
        }
        {
            (|attr| {new_op.set_attr_string("source", attr)})(&self.source)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct TensorArrayGradV2<handle_Arg, flow_in_Arg>
where handle_Arg: Clone,
      handle_Arg: GraphEdge<String>,
      handle_Arg: 'static,
      flow_in_Arg: Clone,
      flow_in_Arg: GraphEdge<f32>,
      flow_in_Arg: 'static,
{
    handle: handle_Arg,
    flow_in: flow_in_Arg,
    source: String,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<handle_Arg, flow_in_Arg> TensorArrayGradV2<handle_Arg, flow_in_Arg>
where handle_Arg: Clone,
      handle_Arg: GraphEdge<String>,
      handle_Arg: 'static,
      flow_in_Arg: Clone,
      flow_in_Arg: GraphEdge<f32>,
      flow_in_Arg: 'static,
{
    pub fn grad_handle(self) -> Edge<String> {
        let rc = Rc::new(self);
        {
            Edge::<String>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<String> {
        let rc = Rc::new(self);
        {
            Edge::<String>::new(rc.clone(), 0)
        }
    }

    pub fn build(handle: handle_Arg, flow_in: flow_in_Arg, source: &str) -> Self {
        Self {
            handle,
            flow_in,
            source: source.to_string(),
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(handle: handle_Arg, flow_in: flow_in_Arg, source: &str) -> Edge<String> {
        Self {
            handle,
            flow_in,
            source: source.to_string(),
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<T, input_Arg> GraphOperation for DebugGradientIdentity<T, input_Arg>
where T: TensorType,
      T: Clone,
      input_Arg: Clone,
      input_Arg: GraphEdge<T>,
      input_Arg: 'static,
      T: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("DebugGradientIdentity_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("DebugGradientIdentity", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.input)?
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct DebugGradientIdentity<T, input_Arg>
where T: TensorType,
      T: Clone,
      input_Arg: Clone,
      input_Arg: GraphEdge<T>,
      input_Arg: 'static,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    input: input_Arg,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<T, input_Arg> DebugGradientIdentity<T, input_Arg>
where T: TensorType,
      T: Clone,
      input_Arg: Clone,
      input_Arg: GraphEdge<T>,
      input_Arg: 'static,
      T: 'static,
{
    pub fn output(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(input: input_Arg) -> Self {
        Self {
            phantom_T: PhantomData,
            input,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(input: input_Arg) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            input,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<size_Arg, dtype> GraphOperation for TensorArray<size_Arg, dtype>
where size_Arg: Clone,
      size_Arg: GraphEdge<i32>,
      size_Arg: 'static,
      dtype: TensorType,
      dtype: 'static,
      dtype: Clone,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("TensorArray_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("TensorArray", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.size)?
        }
        {
            new_op.set_attr_type("dtype", dtype::data_type())?;
        }
        {
            match self.dynamic_size {
                None => new_op.set_attr_value_proto("dynamic_size", &vec![40_u8, 0_u8,])?,
                Some(ref value) => (|attr: &bool| {new_op.set_attr_bool("dynamic_size", *attr)})(&value)?,
            };
        }
        {
            match self.clear_after_read {
                None => new_op.set_attr_value_proto("clear_after_read", &vec![40_u8, 1_u8,])?,
                Some(ref value) => (|attr: &bool| {new_op.set_attr_bool("clear_after_read", *attr)})(&value)?,
            };
        }
        {
            match self.tensor_array_name {
                None => new_op.set_attr_value_proto("tensor_array_name", &vec![18_u8, 0_u8,])?,
                Some(ref value) => (|attr| {new_op.set_attr_string("tensor_array_name", attr)})(&value)?,
            };
        }
        {
            match self.element_shape {
                None => new_op.set_attr_value_proto("element_shape", &vec![58_u8, 0_u8,])?,
                Some(ref value) => (|attr| {new_op.set_attr_shape("element_shape", attr)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct TensorArray<size_Arg, dtype>
where size_Arg: Clone,
      size_Arg: GraphEdge<i32>,
      size_Arg: 'static,
      dtype: TensorType,
      dtype: 'static,
      dtype: Clone,
{
    size: size_Arg,
    phantom_dtype: PhantomData<dtype>,
    dynamic_size: Option<bool>,
    clear_after_read: Option<bool>,
    tensor_array_name: Option<String>,
    element_shape: Option<OtherShape>,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<size_Arg, dtype> TensorArray<size_Arg, dtype>
where size_Arg: Clone,
      size_Arg: GraphEdge<i32>,
      size_Arg: 'static,
      dtype: TensorType,
      dtype: 'static,
      dtype: Clone,
{
    pub fn handle(self) -> RefEdge<String> {
        let rc = Rc::new(self);
        {
            RefEdge::<String>::new(rc.clone(), 0)
        }
    }

    pub fn dynamic_size(&mut self, dynamic_size: bool) -> Self {
        self.dynamic_size = Some(dynamic_size);
        self.clone()
    }

    pub fn clear_after_read(&mut self, clear_after_read: bool) -> Self {
        self.clear_after_read = Some(clear_after_read);
        self.clone()
    }

    pub fn tensor_array_name(&mut self, tensor_array_name: &str) -> Self {
        self.tensor_array_name = Some(tensor_array_name.to_string());
        self.clone()
    }

    pub fn element_shape(&mut self, element_shape: &OtherShape) -> Self {
        self.element_shape = Some(element_shape.clone());
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> RefEdge<String> {
        let rc = Rc::new(self);
        {
            RefEdge::<String>::new(rc.clone(), 0)
        }
    }

    pub fn build(size: size_Arg) -> Self {
        Self {
            size,
            phantom_dtype: PhantomData,
            dynamic_size: None,
            clear_after_read: None,
            tensor_array_name: None,
            element_shape: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(size: size_Arg) -> RefEdge<String> {
        Self {
            size,
            phantom_dtype: PhantomData,
            dynamic_size: None,
            clear_after_read: None,
            tensor_array_name: None,
            element_shape: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<T, gradients_Arg, outputs_Arg> GraphOperation for SeluGrad<T, gradients_Arg, outputs_Arg>
where T: TensorType,
      T: Clone,
      gradients_Arg: Clone,
      gradients_Arg: GraphEdge<T>,
      gradients_Arg: 'static,
      outputs_Arg: Clone,
      outputs_Arg: GraphEdge<T>,
      outputs_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
      T: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("SeluGrad_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("SeluGrad", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.gradients)?
        }
        {
            new_op.add_edge(&self.outputs)?
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct SeluGrad<T, gradients_Arg, outputs_Arg>
where T: TensorType,
      T: Clone,
      gradients_Arg: Clone,
      gradients_Arg: GraphEdge<T>,
      gradients_Arg: 'static,
      outputs_Arg: Clone,
      outputs_Arg: GraphEdge<T>,
      outputs_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    gradients: gradients_Arg,
    outputs: outputs_Arg,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<T, gradients_Arg, outputs_Arg> SeluGrad<T, gradients_Arg, outputs_Arg>
where T: TensorType,
      T: Clone,
      gradients_Arg: Clone,
      gradients_Arg: GraphEdge<T>,
      gradients_Arg: 'static,
      outputs_Arg: Clone,
      outputs_Arg: GraphEdge<T>,
      outputs_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
      T: 'static,
{
    pub fn backprops(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(gradients: gradients_Arg, outputs: outputs_Arg) -> Self {
        Self {
            phantom_T: PhantomData,
            gradients,
            outputs,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(gradients: gradients_Arg, outputs: outputs_Arg) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            gradients,
            outputs,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<handle_Arg> GraphOperation for StackClose<handle_Arg>
where handle_Arg: Clone,
      handle_Arg: GraphRefEdge<String>,
      handle_Arg: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("StackClose_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("StackClose", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.handle)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct StackClose<handle_Arg>
where handle_Arg: Clone,
      handle_Arg: GraphRefEdge<String>,
      handle_Arg: 'static,
{
    handle: handle_Arg,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<handle_Arg> StackClose<handle_Arg>
where handle_Arg: Clone,
      handle_Arg: GraphRefEdge<String>,
      handle_Arg: 'static,
{
    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> () {
        let rc = Rc::new(self);
        (
        )
    }

    pub fn build(handle: handle_Arg) -> Self {
        Self {
            handle,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(handle: handle_Arg) -> () {
        Self {
            handle,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<bytes_Arg> GraphOperation for DecodeCompressed<bytes_Arg>
where bytes_Arg: Clone,
      bytes_Arg: GraphEdge<String>,
      bytes_Arg: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("DecodeCompressed_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("DecodeCompressed", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.bytes)?
        }
        {
            match self.compression_type {
                None => new_op.set_attr_value_proto("compression_type", &vec![18_u8, 0_u8,])?,
                Some(ref value) => (|attr| {new_op.set_attr_string("compression_type", attr)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct DecodeCompressed<bytes_Arg>
where bytes_Arg: Clone,
      bytes_Arg: GraphEdge<String>,
      bytes_Arg: 'static,
{
    bytes: bytes_Arg,
    compression_type: Option<String>,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<bytes_Arg> DecodeCompressed<bytes_Arg>
where bytes_Arg: Clone,
      bytes_Arg: GraphEdge<String>,
      bytes_Arg: 'static,
{
    pub fn output(self) -> Edge<String> {
        let rc = Rc::new(self);
        {
            Edge::<String>::new(rc.clone(), 0)
        }
    }

    pub fn compression_type(&mut self, compression_type: &str) -> Self {
        self.compression_type = Some(compression_type.to_string());
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<String> {
        let rc = Rc::new(self);
        {
            Edge::<String>::new(rc.clone(), 0)
        }
    }

    pub fn build(bytes: bytes_Arg) -> Self {
        Self {
            bytes,
            compression_type: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(bytes: bytes_Arg) -> Edge<String> {
        Self {
            bytes,
            compression_type: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<T, input_Arg, input_h_Arg, input_c_Arg, params_Arg> GraphOperation for CudnnRNN<T, input_Arg, input_h_Arg, input_c_Arg, params_Arg>
where T: TensorType,
      T: Clone,
      input_Arg: Clone,
      input_Arg: GraphEdge<T>,
      input_Arg: 'static,
      input_h_Arg: Clone,
      input_h_Arg: GraphEdge<T>,
      input_h_Arg: 'static,
      input_c_Arg: Clone,
      input_c_Arg: GraphEdge<T>,
      input_c_Arg: 'static,
      params_Arg: Clone,
      params_Arg: GraphEdge<T>,
      params_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_HALF,
      T: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("CudnnRNN_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("CudnnRNN", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.input)?
        }
        {
            new_op.add_edge(&self.input_h)?
        }
        {
            new_op.add_edge(&self.input_c)?
        }
        {
            new_op.add_edge(&self.params)?
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        {
            match self.rnn_mode {
                None => new_op.set_attr_value_proto("rnn_mode", &vec![18_u8, 4_u8, 108_u8, 115_u8, 116_u8, 109_u8,])?,
                Some(ref value) => (|attr| {new_op.set_attr_string("rnn_mode", attr)})(&value)?,
            };
        }
        {
            match self.input_mode {
                None => new_op.set_attr_value_proto("input_mode", &vec![18_u8, 12_u8, 108_u8, 105_u8, 110_u8, 101_u8, 97_u8, 114_u8, 95_u8, 105_u8, 110_u8, 112_u8, 117_u8, 116_u8,])?,
                Some(ref value) => (|attr| {new_op.set_attr_string("input_mode", attr)})(&value)?,
            };
        }
        {
            match self.direction {
                None => new_op.set_attr_value_proto("direction", &vec![18_u8, 14_u8, 117_u8, 110_u8, 105_u8, 100_u8, 105_u8, 114_u8, 101_u8, 99_u8, 116_u8, 105_u8, 111_u8, 110_u8, 97_u8, 108_u8,])?,
                Some(ref value) => (|attr| {new_op.set_attr_string("direction", attr)})(&value)?,
            };
        }
        {
            match self.dropout {
                None => new_op.set_attr_value_proto("dropout", &vec![37_u8, 0_u8, 0_u8, 0_u8, 0_u8,])?,
                Some(ref value) => (|attr: &f32| {new_op.set_attr_float("dropout", *attr)})(&value)?,
            };
        }
        {
            match self.seed {
                None => new_op.set_attr_value_proto("seed", &vec![24_u8, 0_u8,])?,
                Some(ref value) => (|attr: &i64| {new_op.set_attr_int("seed", *attr)})(&value)?,
            };
        }
        {
            match self.seed2 {
                None => new_op.set_attr_value_proto("seed2", &vec![24_u8, 0_u8,])?,
                Some(ref value) => (|attr: &i64| {new_op.set_attr_int("seed2", *attr)})(&value)?,
            };
        }
        {
            match self.is_training {
                None => new_op.set_attr_value_proto("is_training", &vec![40_u8, 1_u8,])?,
                Some(ref value) => (|attr: &bool| {new_op.set_attr_bool("is_training", *attr)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct CudnnRNN<T, input_Arg, input_h_Arg, input_c_Arg, params_Arg>
where T: TensorType,
      T: Clone,
      input_Arg: Clone,
      input_Arg: GraphEdge<T>,
      input_Arg: 'static,
      input_h_Arg: Clone,
      input_h_Arg: GraphEdge<T>,
      input_h_Arg: 'static,
      input_c_Arg: Clone,
      input_c_Arg: GraphEdge<T>,
      input_c_Arg: 'static,
      params_Arg: Clone,
      params_Arg: GraphEdge<T>,
      params_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_HALF,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    input: input_Arg,
    input_h: input_h_Arg,
    input_c: input_c_Arg,
    params: params_Arg,
    rnn_mode: Option<String>,
    input_mode: Option<String>,
    direction: Option<String>,
    dropout: Option<f32>,
    seed: Option<i64>,
    seed2: Option<i64>,
    is_training: Option<bool>,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<T, input_Arg, input_h_Arg, input_c_Arg, params_Arg> CudnnRNN<T, input_Arg, input_h_Arg, input_c_Arg, params_Arg>
where T: TensorType,
      T: Clone,
      input_Arg: Clone,
      input_Arg: GraphEdge<T>,
      input_Arg: 'static,
      input_h_Arg: Clone,
      input_h_Arg: GraphEdge<T>,
      input_h_Arg: 'static,
      input_c_Arg: Clone,
      input_c_Arg: GraphEdge<T>,
      input_c_Arg: 'static,
      params_Arg: Clone,
      params_Arg: GraphEdge<T>,
      params_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_HALF,
      T: 'static,
{
    pub fn output(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn output_h(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 1)
        }
    }

    pub fn output_c(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 2)
        }
    }

    pub fn reserve_space(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 3)
        }
    }

    pub fn rnn_mode(&mut self, rnn_mode: &str) -> Self {
        self.rnn_mode = Some(rnn_mode.to_string());
        self.clone()
    }

    pub fn input_mode(&mut self, input_mode: &str) -> Self {
        self.input_mode = Some(input_mode.to_string());
        self.clone()
    }

    pub fn direction(&mut self, direction: &str) -> Self {
        self.direction = Some(direction.to_string());
        self.clone()
    }

    pub fn dropout(&mut self, dropout: f32) -> Self {
        self.dropout = Some(dropout);
        self.clone()
    }

    pub fn seed(&mut self, seed: i64) -> Self {
        self.seed = Some(seed);
        self.clone()
    }

    pub fn seed2(&mut self, seed2: i64) -> Self {
        self.seed2 = Some(seed2);
        self.clone()
    }

    pub fn is_training(&mut self, is_training: bool) -> Self {
        self.is_training = Some(is_training);
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> (Edge<T>, Edge<T>, Edge<T>, Edge<T>) {
        let rc = Rc::new(self);
        (
        {
            Edge::<T>::new(rc.clone(), 0)
        },
        {
            Edge::<T>::new(rc.clone(), 1)
        },
        {
            Edge::<T>::new(rc.clone(), 2)
        },
        {
            Edge::<T>::new(rc.clone(), 3)
        },
        )
    }

    pub fn build(input: input_Arg, input_h: input_h_Arg, input_c: input_c_Arg, params: params_Arg) -> Self {
        Self {
            phantom_T: PhantomData,
            input,
            input_h,
            input_c,
            params,
            rnn_mode: None,
            input_mode: None,
            direction: None,
            dropout: None,
            seed: None,
            seed2: None,
            is_training: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(input: input_Arg, input_h: input_h_Arg, input_c: input_c_Arg, params: params_Arg) -> (Edge<T>, Edge<T>, Edge<T>, Edge<T>) {
        Self {
            phantom_T: PhantomData,
            input,
            input_h,
            input_c,
            params,
            rnn_mode: None,
            input_mode: None,
            direction: None,
            dropout: None,
            seed: None,
            seed2: None,
            is_training: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<dtypes> GraphOperation for MapIncompleteSize<dtypes>
where dtypes: TensorType,
      dtypes: 'static,
      dtypes: Clone,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("MapIncompleteSize_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("MapIncompleteSize", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            match self.capacity {
                None => new_op.set_attr_value_proto("capacity", &vec![24_u8, 0_u8,])?,
                Some(ref value) => (|attr: &i64| {new_op.set_attr_int("capacity", *attr)})(&value)?,
            };
        }
        {
            match self.memory_limit {
                None => new_op.set_attr_value_proto("memory_limit", &vec![24_u8, 0_u8,])?,
                Some(ref value) => (|attr: &i64| {new_op.set_attr_int("memory_limit", *attr)})(&value)?,
            };
        }
        {
            new_op.set_attr_type("dtypes", dtypes::data_type())?;
        }
        {
            match self.container {
                None => new_op.set_attr_value_proto("container", &vec![18_u8, 0_u8,])?,
                Some(ref value) => (|attr| {new_op.set_attr_string("container", attr)})(&value)?,
            };
        }
        {
            match self.shared_name {
                None => new_op.set_attr_value_proto("shared_name", &vec![18_u8, 0_u8,])?,
                Some(ref value) => (|attr| {new_op.set_attr_string("shared_name", attr)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct MapIncompleteSize<dtypes>
where dtypes: TensorType,
      dtypes: 'static,
      dtypes: Clone,
{
    capacity: Option<i64>,
    memory_limit: Option<i64>,
    phantom_dtypes: PhantomData<dtypes>,
    container: Option<String>,
    shared_name: Option<String>,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<dtypes> MapIncompleteSize<dtypes>
where dtypes: TensorType,
      dtypes: 'static,
      dtypes: Clone,
{
    pub fn size(self) -> Edge<i32> {
        let rc = Rc::new(self);
        {
            Edge::<i32>::new(rc.clone(), 0)
        }
    }

    pub fn capacity(&mut self, capacity: i64) -> Self {
        self.capacity = Some(capacity);
        self.clone()
    }

    pub fn memory_limit(&mut self, memory_limit: i64) -> Self {
        self.memory_limit = Some(memory_limit);
        self.clone()
    }

    pub fn container(&mut self, container: &str) -> Self {
        self.container = Some(container.to_string());
        self.clone()
    }

    pub fn shared_name(&mut self, shared_name: &str) -> Self {
        self.shared_name = Some(shared_name.to_string());
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<i32> {
        let rc = Rc::new(self);
        {
            Edge::<i32>::new(rc.clone(), 0)
        }
    }

    pub fn build() -> Self {
        Self {
            capacity: None,
            memory_limit: None,
            phantom_dtypes: PhantomData,
            container: None,
            shared_name: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new() -> Edge<i32> {
        Self {
            capacity: None,
            memory_limit: None,
            phantom_dtypes: PhantomData,
            container: None,
            shared_name: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<T, input_Arg, filter_Arg, out_backprop_Arg> GraphOperation for Conv3DBackpropInput<T, input_Arg, filter_Arg, out_backprop_Arg>
where T: TensorType,
      T: Clone,
      input_Arg: Clone,
      input_Arg: GraphEdge<T>,
      input_Arg: 'static,
      filter_Arg: Clone,
      filter_Arg: GraphEdge<T>,
      filter_Arg: 'static,
      out_backprop_Arg: Clone,
      out_backprop_Arg: GraphEdge<T>,
      out_backprop_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_HALF,
      T: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("Conv3DBackpropInput_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("Conv3DBackpropInput", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.input)?
        }
        {
            new_op.add_edge(&self.filter)?
        }
        {
            new_op.add_edge(&self.out_backprop)?
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        {
            (|attrs| {new_op.set_attr_int_list("strides", attrs)})(&self.strides)?
        }
        {
            (|attr| {new_op.set_attr_string("padding", attr)})(&self.padding)?
        }
        {
            match self.dilations {
                None => new_op.set_attr_value_proto("dilations", &vec![10_u8, 0_u8, 26_u8, 5_u8, 1_u8, 1_u8, 1_u8, 1_u8,])?,
                Some(ref value) => (|attrs| {new_op.set_attr_int_list("dilations", attrs)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct Conv3DBackpropInput<T, input_Arg, filter_Arg, out_backprop_Arg>
where T: TensorType,
      T: Clone,
      input_Arg: Clone,
      input_Arg: GraphEdge<T>,
      input_Arg: 'static,
      filter_Arg: Clone,
      filter_Arg: GraphEdge<T>,
      filter_Arg: 'static,
      out_backprop_Arg: Clone,
      out_backprop_Arg: GraphEdge<T>,
      out_backprop_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_HALF,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    input: input_Arg,
    filter: filter_Arg,
    out_backprop: out_backprop_Arg,
    strides: Vec<i64>,
    padding: String,
    dilations: Option<Vec<i64>>,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<T, input_Arg, filter_Arg, out_backprop_Arg> Conv3DBackpropInput<T, input_Arg, filter_Arg, out_backprop_Arg>
where T: TensorType,
      T: Clone,
      input_Arg: Clone,
      input_Arg: GraphEdge<T>,
      input_Arg: 'static,
      filter_Arg: Clone,
      filter_Arg: GraphEdge<T>,
      filter_Arg: 'static,
      out_backprop_Arg: Clone,
      out_backprop_Arg: GraphEdge<T>,
      out_backprop_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_HALF,
      T: 'static,
{
    pub fn output(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn dilations(&mut self, dilations: &[i64]) -> Self {
        self.dilations = Some(dilations.to_vec());
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(input: input_Arg, filter: filter_Arg, out_backprop: out_backprop_Arg, strides: &[i64], padding: &str) -> Self {
        Self {
            phantom_T: PhantomData,
            input,
            filter,
            out_backprop,
            strides: strides.to_vec(),
            padding: padding.to_string(),
            dilations: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(input: input_Arg, filter: filter_Arg, out_backprop: out_backprop_Arg, strides: &[i64], padding: &str) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            input,
            filter,
            out_backprop,
            strides: strides.to_vec(),
            padding: padding.to_string(),
            dilations: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<handle_Arg, T, elem_Arg> GraphOperation for StackPush<handle_Arg, T, elem_Arg>
where handle_Arg: Clone,
      handle_Arg: GraphRefEdge<String>,
      handle_Arg: 'static,
      T: TensorType,
      T: Clone,
      elem_Arg: Clone,
      elem_Arg: GraphEdge<T>,
      elem_Arg: 'static,
      T: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("StackPush_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("StackPush", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.handle)?
        }
        {
            new_op.add_edge(&self.elem)?
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        {
            match self.swap_memory {
                None => new_op.set_attr_value_proto("swap_memory", &vec![40_u8, 0_u8,])?,
                Some(ref value) => (|attr: &bool| {new_op.set_attr_bool("swap_memory", *attr)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct StackPush<handle_Arg, T, elem_Arg>
where handle_Arg: Clone,
      handle_Arg: GraphRefEdge<String>,
      handle_Arg: 'static,
      T: TensorType,
      T: Clone,
      elem_Arg: Clone,
      elem_Arg: GraphEdge<T>,
      elem_Arg: 'static,
      T: 'static,
{
    handle: handle_Arg,
    phantom_T: PhantomData<T>,
    elem: elem_Arg,
    swap_memory: Option<bool>,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<handle_Arg, T, elem_Arg> StackPush<handle_Arg, T, elem_Arg>
where handle_Arg: Clone,
      handle_Arg: GraphRefEdge<String>,
      handle_Arg: 'static,
      T: TensorType,
      T: Clone,
      elem_Arg: Clone,
      elem_Arg: GraphEdge<T>,
      elem_Arg: 'static,
      T: 'static,
{
    pub fn output(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn swap_memory(&mut self, swap_memory: bool) -> Self {
        self.swap_memory = Some(swap_memory);
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(handle: handle_Arg, elem: elem_Arg) -> Self {
        Self {
            handle,
            phantom_T: PhantomData,
            elem,
            swap_memory: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(handle: handle_Arg, elem: elem_Arg) -> Edge<T> {
        Self {
            handle,
            phantom_T: PhantomData,
            elem,
            swap_memory: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<T, set1_Arg, set2_Arg> GraphOperation for DenseToDenseSetOperation<T, set1_Arg, set2_Arg>
where T: TensorType,
      T: Clone,
      set1_Arg: Clone,
      set1_Arg: GraphEdge<T>,
      set1_Arg: 'static,
      set2_Arg: Clone,
      set2_Arg: GraphEdge<T>,
      set2_Arg: 'static,
      T: con_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_STRING_or_DT_INT64_or_DT_UINT16,
      T: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("DenseToDenseSetOperation_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("DenseToDenseSetOperation", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.set1)?
        }
        {
            new_op.add_edge(&self.set2)?
        }
        {
            (|attr| {new_op.set_attr_string("set_operation", attr)})(&self.set_operation)?
        }
        {
            match self.validate_indices {
                None => new_op.set_attr_value_proto("validate_indices", &vec![40_u8, 1_u8,])?,
                Some(ref value) => (|attr: &bool| {new_op.set_attr_bool("validate_indices", *attr)})(&value)?,
            };
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct DenseToDenseSetOperation<T, set1_Arg, set2_Arg>
where T: TensorType,
      T: Clone,
      set1_Arg: Clone,
      set1_Arg: GraphEdge<T>,
      set1_Arg: 'static,
      set2_Arg: Clone,
      set2_Arg: GraphEdge<T>,
      set2_Arg: 'static,
      T: con_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_STRING_or_DT_INT64_or_DT_UINT16,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    set1: set1_Arg,
    set2: set2_Arg,
    set_operation: String,
    validate_indices: Option<bool>,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<T, set1_Arg, set2_Arg> DenseToDenseSetOperation<T, set1_Arg, set2_Arg>
where T: TensorType,
      T: Clone,
      set1_Arg: Clone,
      set1_Arg: GraphEdge<T>,
      set1_Arg: 'static,
      set2_Arg: Clone,
      set2_Arg: GraphEdge<T>,
      set2_Arg: 'static,
      T: con_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_STRING_or_DT_INT64_or_DT_UINT16,
      T: 'static,
{
    pub fn result_indices(self) -> Edge<i64> {
        let rc = Rc::new(self);
        {
            Edge::<i64>::new(rc.clone(), 0)
        }
    }

    pub fn result_values(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 1)
        }
    }

    pub fn result_shape(self) -> Edge<i64> {
        let rc = Rc::new(self);
        {
            Edge::<i64>::new(rc.clone(), 2)
        }
    }

    pub fn validate_indices(&mut self, validate_indices: bool) -> Self {
        self.validate_indices = Some(validate_indices);
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> (Edge<i64>, Edge<T>, Edge<i64>) {
        let rc = Rc::new(self);
        (
        {
            Edge::<i64>::new(rc.clone(), 0)
        },
        {
            Edge::<T>::new(rc.clone(), 1)
        },
        {
            Edge::<i64>::new(rc.clone(), 2)
        },
        )
    }

    pub fn build(set1: set1_Arg, set2: set2_Arg, set_operation: &str) -> Self {
        Self {
            phantom_T: PhantomData,
            set1,
            set2,
            set_operation: set_operation.to_string(),
            validate_indices: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(set1: set1_Arg, set2: set2_Arg, set_operation: &str) -> (Edge<i64>, Edge<T>, Edge<i64>) {
        Self {
            phantom_T: PhantomData,
            set1,
            set2,
            set_operation: set_operation.to_string(),
            validate_indices: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<basename_Arg, shard_Arg, num_shards_Arg> GraphOperation for ShardedFilename<basename_Arg, shard_Arg, num_shards_Arg>
where basename_Arg: Clone,
      basename_Arg: GraphEdge<String>,
      basename_Arg: 'static,
      shard_Arg: Clone,
      shard_Arg: GraphEdge<i32>,
      shard_Arg: 'static,
      num_shards_Arg: Clone,
      num_shards_Arg: GraphEdge<i32>,
      num_shards_Arg: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("ShardedFilename_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("ShardedFilename", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.basename)?
        }
        {
            new_op.add_edge(&self.shard)?
        }
        {
            new_op.add_edge(&self.num_shards)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct ShardedFilename<basename_Arg, shard_Arg, num_shards_Arg>
where basename_Arg: Clone,
      basename_Arg: GraphEdge<String>,
      basename_Arg: 'static,
      shard_Arg: Clone,
      shard_Arg: GraphEdge<i32>,
      shard_Arg: 'static,
      num_shards_Arg: Clone,
      num_shards_Arg: GraphEdge<i32>,
      num_shards_Arg: 'static,
{
    basename: basename_Arg,
    shard: shard_Arg,
    num_shards: num_shards_Arg,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<basename_Arg, shard_Arg, num_shards_Arg> ShardedFilename<basename_Arg, shard_Arg, num_shards_Arg>
where basename_Arg: Clone,
      basename_Arg: GraphEdge<String>,
      basename_Arg: 'static,
      shard_Arg: Clone,
      shard_Arg: GraphEdge<i32>,
      shard_Arg: 'static,
      num_shards_Arg: Clone,
      num_shards_Arg: GraphEdge<i32>,
      num_shards_Arg: 'static,
{
    pub fn filename(self) -> Edge<String> {
        let rc = Rc::new(self);
        {
            Edge::<String>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<String> {
        let rc = Rc::new(self);
        {
            Edge::<String>::new(rc.clone(), 0)
        }
    }

    pub fn build(basename: basename_Arg, shard: shard_Arg, num_shards: num_shards_Arg) -> Self {
        Self {
            basename,
            shard,
            num_shards,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(basename: basename_Arg, shard: shard_Arg, num_shards: num_shards_Arg) -> Edge<String> {
        Self {
            basename,
            shard,
            num_shards,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<handle_Arg, local_step_Arg, gradient_indices_Arg, dtype, gradient_values_Arg, gradient_shape_Arg> GraphOperation for SparseAccumulatorApplyGradient<handle_Arg, local_step_Arg, gradient_indices_Arg, dtype, gradient_values_Arg, gradient_shape_Arg>
where handle_Arg: Clone,
      handle_Arg: GraphRefEdge<String>,
      handle_Arg: 'static,
      local_step_Arg: Clone,
      local_step_Arg: GraphEdge<i64>,
      local_step_Arg: 'static,
      gradient_indices_Arg: Clone,
      gradient_indices_Arg: GraphEdge<i64>,
      gradient_indices_Arg: 'static,
      dtype: TensorType,
      dtype: Clone,
      gradient_values_Arg: Clone,
      gradient_values_Arg: GraphEdge<dtype>,
      gradient_values_Arg: 'static,
      gradient_shape_Arg: Clone,
      gradient_shape_Arg: GraphEdge<i64>,
      gradient_shape_Arg: 'static,
      dtype: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      dtype: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("SparseAccumulatorApplyGradient_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("SparseAccumulatorApplyGradient", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.handle)?
        }
        {
            new_op.add_edge(&self.local_step)?
        }
        {
            new_op.add_edge(&self.gradient_indices)?
        }
        {
            new_op.add_edge(&self.gradient_values)?
        }
        {
            new_op.add_edge(&self.gradient_shape)?
        }
        {
            new_op.set_attr_type("dtype", dtype::data_type())?;
        }
        {
            (|attr: &bool| {new_op.set_attr_bool("has_known_shape", *attr)})(&self.has_known_shape)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct SparseAccumulatorApplyGradient<handle_Arg, local_step_Arg, gradient_indices_Arg, dtype, gradient_values_Arg, gradient_shape_Arg>
where handle_Arg: Clone,
      handle_Arg: GraphRefEdge<String>,
      handle_Arg: 'static,
      local_step_Arg: Clone,
      local_step_Arg: GraphEdge<i64>,
      local_step_Arg: 'static,
      gradient_indices_Arg: Clone,
      gradient_indices_Arg: GraphEdge<i64>,
      gradient_indices_Arg: 'static,
      dtype: TensorType,
      dtype: Clone,
      gradient_values_Arg: Clone,
      gradient_values_Arg: GraphEdge<dtype>,
      gradient_values_Arg: 'static,
      gradient_shape_Arg: Clone,
      gradient_shape_Arg: GraphEdge<i64>,
      gradient_shape_Arg: 'static,
      dtype: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      dtype: 'static,
{
    handle: handle_Arg,
    local_step: local_step_Arg,
    gradient_indices: gradient_indices_Arg,
    phantom_dtype: PhantomData<dtype>,
    gradient_values: gradient_values_Arg,
    gradient_shape: gradient_shape_Arg,
    has_known_shape: bool,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<handle_Arg, local_step_Arg, gradient_indices_Arg, dtype, gradient_values_Arg, gradient_shape_Arg> SparseAccumulatorApplyGradient<handle_Arg, local_step_Arg, gradient_indices_Arg, dtype, gradient_values_Arg, gradient_shape_Arg>
where handle_Arg: Clone,
      handle_Arg: GraphRefEdge<String>,
      handle_Arg: 'static,
      local_step_Arg: Clone,
      local_step_Arg: GraphEdge<i64>,
      local_step_Arg: 'static,
      gradient_indices_Arg: Clone,
      gradient_indices_Arg: GraphEdge<i64>,
      gradient_indices_Arg: 'static,
      dtype: TensorType,
      dtype: Clone,
      gradient_values_Arg: Clone,
      gradient_values_Arg: GraphEdge<dtype>,
      gradient_values_Arg: 'static,
      gradient_shape_Arg: Clone,
      gradient_shape_Arg: GraphEdge<i64>,
      gradient_shape_Arg: 'static,
      dtype: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      dtype: 'static,
{
    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> () {
        let rc = Rc::new(self);
        (
        )
    }

    pub fn build(handle: handle_Arg, local_step: local_step_Arg, gradient_indices: gradient_indices_Arg, gradient_values: gradient_values_Arg, gradient_shape: gradient_shape_Arg, has_known_shape: bool) -> Self {
        Self {
            handle,
            local_step,
            gradient_indices,
            phantom_dtype: PhantomData,
            gradient_values,
            gradient_shape,
            has_known_shape: has_known_shape,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(handle: handle_Arg, local_step: local_step_Arg, gradient_indices: gradient_indices_Arg, gradient_values: gradient_values_Arg, gradient_shape: gradient_shape_Arg, has_known_shape: bool) -> () {
        Self {
            handle,
            local_step,
            gradient_indices,
            phantom_dtype: PhantomData,
            gradient_values,
            gradient_shape,
            has_known_shape: has_known_shape,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<handle_Arg, new_global_step_Arg> GraphOperation for AccumulatorSetGlobalStep<handle_Arg, new_global_step_Arg>
where handle_Arg: Clone,
      handle_Arg: GraphRefEdge<String>,
      handle_Arg: 'static,
      new_global_step_Arg: Clone,
      new_global_step_Arg: GraphEdge<i64>,
      new_global_step_Arg: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("AccumulatorSetGlobalStep_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("AccumulatorSetGlobalStep", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.handle)?
        }
        {
            new_op.add_edge(&self.new_global_step)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct AccumulatorSetGlobalStep<handle_Arg, new_global_step_Arg>
where handle_Arg: Clone,
      handle_Arg: GraphRefEdge<String>,
      handle_Arg: 'static,
      new_global_step_Arg: Clone,
      new_global_step_Arg: GraphEdge<i64>,
      new_global_step_Arg: 'static,
{
    handle: handle_Arg,
    new_global_step: new_global_step_Arg,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<handle_Arg, new_global_step_Arg> AccumulatorSetGlobalStep<handle_Arg, new_global_step_Arg>
where handle_Arg: Clone,
      handle_Arg: GraphRefEdge<String>,
      handle_Arg: 'static,
      new_global_step_Arg: Clone,
      new_global_step_Arg: GraphEdge<i64>,
      new_global_step_Arg: 'static,
{
    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> () {
        let rc = Rc::new(self);
        (
        )
    }

    pub fn build(handle: handle_Arg, new_global_step: new_global_step_Arg) -> Self {
        Self {
            handle,
            new_global_step,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(handle: handle_Arg, new_global_step: new_global_step_Arg) -> () {
        Self {
            handle,
            new_global_step,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<T, input_Arg> GraphOperation for MatrixDiagPart<T, input_Arg>
where T: TensorType,
      T: Clone,
      input_Arg: Clone,
      input_Arg: GraphEdge<T>,
      input_Arg: 'static,
      T: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("MatrixDiagPart_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("MatrixDiagPart", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.input)?
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct MatrixDiagPart<T, input_Arg>
where T: TensorType,
      T: Clone,
      input_Arg: Clone,
      input_Arg: GraphEdge<T>,
      input_Arg: 'static,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    input: input_Arg,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<T, input_Arg> MatrixDiagPart<T, input_Arg>
where T: TensorType,
      T: Clone,
      input_Arg: Clone,
      input_Arg: GraphEdge<T>,
      input_Arg: 'static,
      T: 'static,
{
    pub fn diagonal(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(input: input_Arg) -> Self {
        Self {
            phantom_T: PhantomData,
            input,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(input: input_Arg) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            input,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<contents_Arg, output_type> GraphOperation for ExtractJpegShape<contents_Arg, output_type>
where contents_Arg: Clone,
      contents_Arg: GraphEdge<String>,
      contents_Arg: 'static,
      output_type: TensorType,
      output_type: con_or_DT_INT32_or_DT_INT64,
      output_type: 'static,
      output_type: Clone,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("ExtractJpegShape_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("ExtractJpegShape", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.contents)?
        }
        {
            new_op.set_attr_type("output_type", output_type::data_type())?;
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct ExtractJpegShape<contents_Arg, output_type>
where contents_Arg: Clone,
      contents_Arg: GraphEdge<String>,
      contents_Arg: 'static,
      output_type: TensorType,
      output_type: con_or_DT_INT32_or_DT_INT64,
      output_type: 'static,
      output_type: Clone,
{
    contents: contents_Arg,
    phantom_output_type: PhantomData<output_type>,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<contents_Arg, output_type> ExtractJpegShape<contents_Arg, output_type>
where contents_Arg: Clone,
      contents_Arg: GraphEdge<String>,
      contents_Arg: 'static,
      output_type: TensorType,
      output_type: con_or_DT_INT32_or_DT_INT64,
      output_type: 'static,
      output_type: Clone,
{
    pub fn image_shape(self) -> Edge<output_type> {
        let rc = Rc::new(self);
        {
            Edge::<output_type>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<output_type> {
        let rc = Rc::new(self);
        {
            Edge::<output_type>::new(rc.clone(), 0)
        }
    }

    pub fn build(contents: contents_Arg) -> Self {
        Self {
            contents,
            phantom_output_type: PhantomData,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(contents: contents_Arg) -> Edge<output_type> {
        Self {
            contents,
            phantom_output_type: PhantomData,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<handle_Arg, elem_type> GraphOperation for StackPop<handle_Arg, elem_type>
where handle_Arg: Clone,
      handle_Arg: GraphRefEdge<String>,
      handle_Arg: 'static,
      elem_type: TensorType,
      elem_type: 'static,
      elem_type: Clone,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("StackPop_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("StackPop", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.handle)?
        }
        {
            new_op.set_attr_type("elem_type", elem_type::data_type())?;
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct StackPop<handle_Arg, elem_type>
where handle_Arg: Clone,
      handle_Arg: GraphRefEdge<String>,
      handle_Arg: 'static,
      elem_type: TensorType,
      elem_type: 'static,
      elem_type: Clone,
{
    handle: handle_Arg,
    phantom_elem_type: PhantomData<elem_type>,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<handle_Arg, elem_type> StackPop<handle_Arg, elem_type>
where handle_Arg: Clone,
      handle_Arg: GraphRefEdge<String>,
      handle_Arg: 'static,
      elem_type: TensorType,
      elem_type: 'static,
      elem_type: Clone,
{
    pub fn elem(self) -> Edge<elem_type> {
        let rc = Rc::new(self);
        {
            Edge::<elem_type>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<elem_type> {
        let rc = Rc::new(self);
        {
            Edge::<elem_type>::new(rc.clone(), 0)
        }
    }

    pub fn build(handle: handle_Arg) -> Self {
        Self {
            handle,
            phantom_elem_type: PhantomData,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(handle: handle_Arg) -> Edge<elem_type> {
        Self {
            handle,
            phantom_elem_type: PhantomData,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<T, x_Arg> GraphOperation for Inv<T, x_Arg>
where T: TensorType,
      T: Clone,
      x_Arg: Clone,
      x_Arg: GraphEdge<T>,
      x_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_COMPLEX64_or_DT_INT64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF,
      T: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("Inv_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("Inv", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.x)?
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct Inv<T, x_Arg>
where T: TensorType,
      T: Clone,
      x_Arg: Clone,
      x_Arg: GraphEdge<T>,
      x_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_COMPLEX64_or_DT_INT64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    x: x_Arg,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<T, x_Arg> Inv<T, x_Arg>
where T: TensorType,
      T: Clone,
      x_Arg: Clone,
      x_Arg: GraphEdge<T>,
      x_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_COMPLEX64_or_DT_INT64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF,
      T: 'static,
{
    pub fn y(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(x: x_Arg) -> Self {
        Self {
            phantom_T: PhantomData,
            x,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(x: x_Arg) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            x,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<indices_Arg, T, data_Arg> GraphOperation for ParallelDynamicStitch<indices_Arg, T, data_Arg>
where indices_Arg: Clone,
      indices_Arg: GraphEdge<i32>,
      indices_Arg: 'static,
      T: TensorType,
      T: Clone,
      data_Arg: Clone,
      data_Arg: GraphEdge<T>,
      data_Arg: 'static,
      T: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("ParallelDynamicStitch_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("ParallelDynamicStitch", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.indices)?
        }
        {
            new_op.add_edge(&self.data)?
        }
        {
            (|attr: &i64| {new_op.set_attr_int("N", *attr)})(&self.N)?
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct ParallelDynamicStitch<indices_Arg, T, data_Arg>
where indices_Arg: Clone,
      indices_Arg: GraphEdge<i32>,
      indices_Arg: 'static,
      T: TensorType,
      T: Clone,
      data_Arg: Clone,
      data_Arg: GraphEdge<T>,
      data_Arg: 'static,
      T: 'static,
{
    indices: indices_Arg,
    phantom_T: PhantomData<T>,
    data: data_Arg,
    N: i64,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<indices_Arg, T, data_Arg> ParallelDynamicStitch<indices_Arg, T, data_Arg>
where indices_Arg: Clone,
      indices_Arg: GraphEdge<i32>,
      indices_Arg: 'static,
      T: TensorType,
      T: Clone,
      data_Arg: Clone,
      data_Arg: GraphEdge<T>,
      data_Arg: 'static,
      T: 'static,
{
    pub fn merged(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(indices: indices_Arg, data: data_Arg, N: i64) -> Self {
        Self {
            indices,
            phantom_T: PhantomData,
            data,
            N: N,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(indices: indices_Arg, data: data_Arg, N: i64) -> Edge<T> {
        Self {
            indices,
            phantom_T: PhantomData,
            data,
            N: N,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<T, data_Arg, partitions_Arg> GraphOperation for DynamicPartition<T, data_Arg, partitions_Arg>
where T: TensorType,
      T: Clone,
      data_Arg: Clone,
      data_Arg: GraphEdge<T>,
      data_Arg: 'static,
      partitions_Arg: Clone,
      partitions_Arg: GraphEdge<i32>,
      partitions_Arg: 'static,
      T: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("DynamicPartition_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("DynamicPartition", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.data)?
        }
        {
            new_op.add_edge(&self.partitions)?
        }
        {
            (|attr: &i64| {new_op.set_attr_int("num_partitions", *attr)})(&self.num_partitions)?
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct DynamicPartition<T, data_Arg, partitions_Arg>
where T: TensorType,
      T: Clone,
      data_Arg: Clone,
      data_Arg: GraphEdge<T>,
      data_Arg: 'static,
      partitions_Arg: Clone,
      partitions_Arg: GraphEdge<i32>,
      partitions_Arg: 'static,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    data: data_Arg,
    partitions: partitions_Arg,
    num_partitions: i64,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<T, data_Arg, partitions_Arg> DynamicPartition<T, data_Arg, partitions_Arg>
where T: TensorType,
      T: Clone,
      data_Arg: Clone,
      data_Arg: GraphEdge<T>,
      data_Arg: 'static,
      partitions_Arg: Clone,
      partitions_Arg: GraphEdge<i32>,
      partitions_Arg: 'static,
      T: 'static,
{
    pub fn outputs(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(data: data_Arg, partitions: partitions_Arg, num_partitions: i64) -> Self {
        Self {
            phantom_T: PhantomData,
            data,
            partitions,
            num_partitions: num_partitions,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(data: data_Arg, partitions: partitions_Arg, num_partitions: i64) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            data,
            partitions,
            num_partitions: num_partitions,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<T, input_Arg> GraphOperation for BatchCholesky<T, input_Arg>
where T: TensorType,
      T: Clone,
      input_Arg: Clone,
      input_Arg: GraphEdge<T>,
      input_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE,
      T: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("BatchCholesky_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("BatchCholesky", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.input)?
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct BatchCholesky<T, input_Arg>
where T: TensorType,
      T: Clone,
      input_Arg: Clone,
      input_Arg: GraphEdge<T>,
      input_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    input: input_Arg,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<T, input_Arg> BatchCholesky<T, input_Arg>
where T: TensorType,
      T: Clone,
      input_Arg: Clone,
      input_Arg: GraphEdge<T>,
      input_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE,
      T: 'static,
{
    pub fn output(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(input: input_Arg) -> Self {
        Self {
            phantom_T: PhantomData,
            input,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(input: input_Arg) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            input,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<key_dtype, empty_key_Arg, value_dtype> GraphOperation for MutableDenseHashTable<key_dtype, empty_key_Arg, value_dtype>
where key_dtype: TensorType,
      key_dtype: Clone,
      empty_key_Arg: Clone,
      empty_key_Arg: GraphEdge<key_dtype>,
      empty_key_Arg: 'static,
      key_dtype: 'static,
      value_dtype: TensorType,
      value_dtype: 'static,
      value_dtype: Clone,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("MutableDenseHashTable_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("MutableDenseHashTable", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.empty_key)?
        }
        {
            match self.container {
                None => new_op.set_attr_value_proto("container", &vec![18_u8, 0_u8,])?,
                Some(ref value) => (|attr| {new_op.set_attr_string("container", attr)})(&value)?,
            };
        }
        {
            match self.shared_name {
                None => new_op.set_attr_value_proto("shared_name", &vec![18_u8, 0_u8,])?,
                Some(ref value) => (|attr| {new_op.set_attr_string("shared_name", attr)})(&value)?,
            };
        }
        {
            match self.use_node_name_sharing {
                None => new_op.set_attr_value_proto("use_node_name_sharing", &vec![40_u8, 0_u8,])?,
                Some(ref value) => (|attr: &bool| {new_op.set_attr_bool("use_node_name_sharing", *attr)})(&value)?,
            };
        }
        {
            new_op.set_attr_type("key_dtype", key_dtype::data_type())?;
        }
        {
            new_op.set_attr_type("value_dtype", value_dtype::data_type())?;
        }
        {
            match self.value_shape {
                None => new_op.set_attr_value_proto("value_shape", &vec![58_u8, 0_u8,])?,
                Some(ref value) => (|attr| {new_op.set_attr_shape("value_shape", attr)})(&value)?,
            };
        }
        {
            match self.initial_num_buckets {
                None => new_op.set_attr_value_proto("initial_num_buckets", &vec![24_u8, 128_u8, 128_u8, 8_u8,])?,
                Some(ref value) => (|attr: &i64| {new_op.set_attr_int("initial_num_buckets", *attr)})(&value)?,
            };
        }
        {
            match self.max_load_factor {
                None => new_op.set_attr_value_proto("max_load_factor", &vec![37_u8, 205_u8, 204_u8, 76_u8, 63_u8,])?,
                Some(ref value) => (|attr: &f32| {new_op.set_attr_float("max_load_factor", *attr)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct MutableDenseHashTable<key_dtype, empty_key_Arg, value_dtype>
where key_dtype: TensorType,
      key_dtype: Clone,
      empty_key_Arg: Clone,
      empty_key_Arg: GraphEdge<key_dtype>,
      empty_key_Arg: 'static,
      key_dtype: 'static,
      value_dtype: TensorType,
      value_dtype: 'static,
      value_dtype: Clone,
{
    phantom_key_dtype: PhantomData<key_dtype>,
    empty_key: empty_key_Arg,
    container: Option<String>,
    shared_name: Option<String>,
    use_node_name_sharing: Option<bool>,
    phantom_value_dtype: PhantomData<value_dtype>,
    value_shape: Option<OtherShape>,
    initial_num_buckets: Option<i64>,
    max_load_factor: Option<f32>,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<key_dtype, empty_key_Arg, value_dtype> MutableDenseHashTable<key_dtype, empty_key_Arg, value_dtype>
where key_dtype: TensorType,
      key_dtype: Clone,
      empty_key_Arg: Clone,
      empty_key_Arg: GraphEdge<key_dtype>,
      empty_key_Arg: 'static,
      key_dtype: 'static,
      value_dtype: TensorType,
      value_dtype: 'static,
      value_dtype: Clone,
{
    pub fn table_handle(self) -> RefEdge<String> {
        let rc = Rc::new(self);
        {
            RefEdge::<String>::new(rc.clone(), 0)
        }
    }

    pub fn container(&mut self, container: &str) -> Self {
        self.container = Some(container.to_string());
        self.clone()
    }

    pub fn shared_name(&mut self, shared_name: &str) -> Self {
        self.shared_name = Some(shared_name.to_string());
        self.clone()
    }

    pub fn use_node_name_sharing(&mut self, use_node_name_sharing: bool) -> Self {
        self.use_node_name_sharing = Some(use_node_name_sharing);
        self.clone()
    }

    pub fn value_shape(&mut self, value_shape: &OtherShape) -> Self {
        self.value_shape = Some(value_shape.clone());
        self.clone()
    }

    pub fn initial_num_buckets(&mut self, initial_num_buckets: i64) -> Self {
        self.initial_num_buckets = Some(initial_num_buckets);
        self.clone()
    }

    pub fn max_load_factor(&mut self, max_load_factor: f32) -> Self {
        self.max_load_factor = Some(max_load_factor);
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> RefEdge<String> {
        let rc = Rc::new(self);
        {
            RefEdge::<String>::new(rc.clone(), 0)
        }
    }

    pub fn build(empty_key: empty_key_Arg) -> Self {
        Self {
            phantom_key_dtype: PhantomData,
            empty_key,
            container: None,
            shared_name: None,
            use_node_name_sharing: None,
            phantom_value_dtype: PhantomData,
            value_shape: None,
            initial_num_buckets: None,
            max_load_factor: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(empty_key: empty_key_Arg) -> RefEdge<String> {
        Self {
            phantom_key_dtype: PhantomData,
            empty_key,
            container: None,
            shared_name: None,
            use_node_name_sharing: None,
            phantom_value_dtype: PhantomData,
            value_shape: None,
            initial_num_buckets: None,
            max_load_factor: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<true_classes_Arg> GraphOperation for UniformCandidateSampler<true_classes_Arg>
where true_classes_Arg: Clone,
      true_classes_Arg: GraphEdge<i64>,
      true_classes_Arg: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("UniformCandidateSampler_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("UniformCandidateSampler", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.true_classes)?
        }
        {
            (|attr: &i64| {new_op.set_attr_int("num_true", *attr)})(&self.num_true)?
        }
        {
            (|attr: &i64| {new_op.set_attr_int("num_sampled", *attr)})(&self.num_sampled)?
        }
        {
            (|attr: &bool| {new_op.set_attr_bool("unique", *attr)})(&self.unique)?
        }
        {
            (|attr: &i64| {new_op.set_attr_int("range_max", *attr)})(&self.range_max)?
        }
        {
            match self.seed {
                None => new_op.set_attr_value_proto("seed", &vec![24_u8, 0_u8,])?,
                Some(ref value) => (|attr: &i64| {new_op.set_attr_int("seed", *attr)})(&value)?,
            };
        }
        {
            match self.seed2 {
                None => new_op.set_attr_value_proto("seed2", &vec![24_u8, 0_u8,])?,
                Some(ref value) => (|attr: &i64| {new_op.set_attr_int("seed2", *attr)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct UniformCandidateSampler<true_classes_Arg>
where true_classes_Arg: Clone,
      true_classes_Arg: GraphEdge<i64>,
      true_classes_Arg: 'static,
{
    true_classes: true_classes_Arg,
    num_true: i64,
    num_sampled: i64,
    unique: bool,
    range_max: i64,
    seed: Option<i64>,
    seed2: Option<i64>,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<true_classes_Arg> UniformCandidateSampler<true_classes_Arg>
where true_classes_Arg: Clone,
      true_classes_Arg: GraphEdge<i64>,
      true_classes_Arg: 'static,
{
    pub fn sampled_candidates(self) -> Edge<i64> {
        let rc = Rc::new(self);
        {
            Edge::<i64>::new(rc.clone(), 0)
        }
    }

    pub fn true_expected_count(self) -> Edge<f32> {
        let rc = Rc::new(self);
        {
            Edge::<f32>::new(rc.clone(), 1)
        }
    }

    pub fn sampled_expected_count(self) -> Edge<f32> {
        let rc = Rc::new(self);
        {
            Edge::<f32>::new(rc.clone(), 2)
        }
    }

    pub fn seed(&mut self, seed: i64) -> Self {
        self.seed = Some(seed);
        self.clone()
    }

    pub fn seed2(&mut self, seed2: i64) -> Self {
        self.seed2 = Some(seed2);
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> (Edge<i64>, Edge<f32>, Edge<f32>) {
        let rc = Rc::new(self);
        (
        {
            Edge::<i64>::new(rc.clone(), 0)
        },
        {
            Edge::<f32>::new(rc.clone(), 1)
        },
        {
            Edge::<f32>::new(rc.clone(), 2)
        },
        )
    }

    pub fn build(true_classes: true_classes_Arg, num_true: i64, num_sampled: i64, unique: bool, range_max: i64) -> Self {
        Self {
            true_classes,
            num_true: num_true,
            num_sampled: num_sampled,
            unique: unique,
            range_max: range_max,
            seed: None,
            seed2: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(true_classes: true_classes_Arg, num_true: i64, num_sampled: i64, unique: bool, range_max: i64) -> (Edge<i64>, Edge<f32>, Edge<f32>) {
        Self {
            true_classes,
            num_true: num_true,
            num_sampled: num_sampled,
            unique: unique,
            range_max: range_max,
            seed: None,
            seed2: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<T, data_Arg, Tidx, indices_Arg, segment_ids_Arg> GraphOperation for SparseSegmentMean<T, data_Arg, Tidx, indices_Arg, segment_ids_Arg>
where T: TensorType,
      T: Clone,
      data_Arg: Clone,
      data_Arg: GraphEdge<T>,
      data_Arg: 'static,
      Tidx: TensorType,
      Tidx: Clone,
      indices_Arg: Clone,
      indices_Arg: GraphEdge<Tidx>,
      indices_Arg: 'static,
      segment_ids_Arg: Clone,
      segment_ids_Arg: GraphEdge<i32>,
      segment_ids_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE,
      T: 'static,
      Tidx: con_or_DT_INT32_or_DT_INT64,
      Tidx: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("SparseSegmentMean_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("SparseSegmentMean", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.data)?
        }
        {
            new_op.add_edge(&self.indices)?
        }
        {
            new_op.add_edge(&self.segment_ids)?
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        {
            new_op.set_attr_type("Tidx", Tidx::data_type())?;
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct SparseSegmentMean<T, data_Arg, Tidx, indices_Arg, segment_ids_Arg>
where T: TensorType,
      T: Clone,
      data_Arg: Clone,
      data_Arg: GraphEdge<T>,
      data_Arg: 'static,
      Tidx: TensorType,
      Tidx: Clone,
      indices_Arg: Clone,
      indices_Arg: GraphEdge<Tidx>,
      indices_Arg: 'static,
      segment_ids_Arg: Clone,
      segment_ids_Arg: GraphEdge<i32>,
      segment_ids_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE,
      T: 'static,
      Tidx: con_or_DT_INT32_or_DT_INT64,
      Tidx: 'static,
{
    phantom_T: PhantomData<T>,
    data: data_Arg,
    phantom_Tidx: PhantomData<Tidx>,
    indices: indices_Arg,
    segment_ids: segment_ids_Arg,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<T, data_Arg, Tidx, indices_Arg, segment_ids_Arg> SparseSegmentMean<T, data_Arg, Tidx, indices_Arg, segment_ids_Arg>
where T: TensorType,
      T: Clone,
      data_Arg: Clone,
      data_Arg: GraphEdge<T>,
      data_Arg: 'static,
      Tidx: TensorType,
      Tidx: Clone,
      indices_Arg: Clone,
      indices_Arg: GraphEdge<Tidx>,
      indices_Arg: 'static,
      segment_ids_Arg: Clone,
      segment_ids_Arg: GraphEdge<i32>,
      segment_ids_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE,
      T: 'static,
      Tidx: con_or_DT_INT32_or_DT_INT64,
      Tidx: 'static,
{
    pub fn output(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(data: data_Arg, indices: indices_Arg, segment_ids: segment_ids_Arg) -> Self {
        Self {
            phantom_T: PhantomData,
            data,
            phantom_Tidx: PhantomData,
            indices,
            segment_ids,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(data: data_Arg, indices: indices_Arg, segment_ids: segment_ids_Arg) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            data,
            phantom_Tidx: PhantomData,
            indices,
            segment_ids,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<T, l_Arg, grad_Arg> GraphOperation for BatchCholeskyGrad<T, l_Arg, grad_Arg>
where T: TensorType,
      T: Clone,
      l_Arg: Clone,
      l_Arg: GraphEdge<T>,
      l_Arg: 'static,
      grad_Arg: Clone,
      grad_Arg: GraphEdge<T>,
      grad_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE,
      T: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("BatchCholeskyGrad_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("BatchCholeskyGrad", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.l)?
        }
        {
            new_op.add_edge(&self.grad)?
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct BatchCholeskyGrad<T, l_Arg, grad_Arg>
where T: TensorType,
      T: Clone,
      l_Arg: Clone,
      l_Arg: GraphEdge<T>,
      l_Arg: 'static,
      grad_Arg: Clone,
      grad_Arg: GraphEdge<T>,
      grad_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    l: l_Arg,
    grad: grad_Arg,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<T, l_Arg, grad_Arg> BatchCholeskyGrad<T, l_Arg, grad_Arg>
where T: TensorType,
      T: Clone,
      l_Arg: Clone,
      l_Arg: GraphEdge<T>,
      l_Arg: 'static,
      grad_Arg: Clone,
      grad_Arg: GraphEdge<T>,
      grad_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE,
      T: 'static,
{
    pub fn output(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(l: l_Arg, grad: grad_Arg) -> Self {
        Self {
            phantom_T: PhantomData,
            l,
            grad,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(l: l_Arg, grad: grad_Arg) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            l,
            grad,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<inputs_Arg, labels_indices_Arg, labels_values_Arg, sequence_length_Arg> GraphOperation for CTCLoss<inputs_Arg, labels_indices_Arg, labels_values_Arg, sequence_length_Arg>
where inputs_Arg: Clone,
      inputs_Arg: GraphEdge<f32>,
      inputs_Arg: 'static,
      labels_indices_Arg: Clone,
      labels_indices_Arg: GraphEdge<i64>,
      labels_indices_Arg: 'static,
      labels_values_Arg: Clone,
      labels_values_Arg: GraphEdge<i32>,
      labels_values_Arg: 'static,
      sequence_length_Arg: Clone,
      sequence_length_Arg: GraphEdge<i32>,
      sequence_length_Arg: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("CTCLoss_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("CTCLoss", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.inputs)?
        }
        {
            new_op.add_edge(&self.labels_indices)?
        }
        {
            new_op.add_edge(&self.labels_values)?
        }
        {
            new_op.add_edge(&self.sequence_length)?
        }
        {
            match self.preprocess_collapse_repeated {
                None => new_op.set_attr_value_proto("preprocess_collapse_repeated", &vec![40_u8, 0_u8,])?,
                Some(ref value) => (|attr: &bool| {new_op.set_attr_bool("preprocess_collapse_repeated", *attr)})(&value)?,
            };
        }
        {
            match self.ctc_merge_repeated {
                None => new_op.set_attr_value_proto("ctc_merge_repeated", &vec![40_u8, 1_u8,])?,
                Some(ref value) => (|attr: &bool| {new_op.set_attr_bool("ctc_merge_repeated", *attr)})(&value)?,
            };
        }
        {
            match self.ignore_longer_outputs_than_inputs {
                None => new_op.set_attr_value_proto("ignore_longer_outputs_than_inputs", &vec![40_u8, 0_u8,])?,
                Some(ref value) => (|attr: &bool| {new_op.set_attr_bool("ignore_longer_outputs_than_inputs", *attr)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct CTCLoss<inputs_Arg, labels_indices_Arg, labels_values_Arg, sequence_length_Arg>
where inputs_Arg: Clone,
      inputs_Arg: GraphEdge<f32>,
      inputs_Arg: 'static,
      labels_indices_Arg: Clone,
      labels_indices_Arg: GraphEdge<i64>,
      labels_indices_Arg: 'static,
      labels_values_Arg: Clone,
      labels_values_Arg: GraphEdge<i32>,
      labels_values_Arg: 'static,
      sequence_length_Arg: Clone,
      sequence_length_Arg: GraphEdge<i32>,
      sequence_length_Arg: 'static,
{
    inputs: inputs_Arg,
    labels_indices: labels_indices_Arg,
    labels_values: labels_values_Arg,
    sequence_length: sequence_length_Arg,
    preprocess_collapse_repeated: Option<bool>,
    ctc_merge_repeated: Option<bool>,
    ignore_longer_outputs_than_inputs: Option<bool>,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<inputs_Arg, labels_indices_Arg, labels_values_Arg, sequence_length_Arg> CTCLoss<inputs_Arg, labels_indices_Arg, labels_values_Arg, sequence_length_Arg>
where inputs_Arg: Clone,
      inputs_Arg: GraphEdge<f32>,
      inputs_Arg: 'static,
      labels_indices_Arg: Clone,
      labels_indices_Arg: GraphEdge<i64>,
      labels_indices_Arg: 'static,
      labels_values_Arg: Clone,
      labels_values_Arg: GraphEdge<i32>,
      labels_values_Arg: 'static,
      sequence_length_Arg: Clone,
      sequence_length_Arg: GraphEdge<i32>,
      sequence_length_Arg: 'static,
{
    pub fn loss(self) -> Edge<f32> {
        let rc = Rc::new(self);
        {
            Edge::<f32>::new(rc.clone(), 0)
        }
    }

    pub fn gradient(self) -> Edge<f32> {
        let rc = Rc::new(self);
        {
            Edge::<f32>::new(rc.clone(), 1)
        }
    }

    pub fn preprocess_collapse_repeated(&mut self, preprocess_collapse_repeated: bool) -> Self {
        self.preprocess_collapse_repeated = Some(preprocess_collapse_repeated);
        self.clone()
    }

    pub fn ctc_merge_repeated(&mut self, ctc_merge_repeated: bool) -> Self {
        self.ctc_merge_repeated = Some(ctc_merge_repeated);
        self.clone()
    }

    pub fn ignore_longer_outputs_than_inputs(&mut self, ignore_longer_outputs_than_inputs: bool) -> Self {
        self.ignore_longer_outputs_than_inputs = Some(ignore_longer_outputs_than_inputs);
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> (Edge<f32>, Edge<f32>) {
        let rc = Rc::new(self);
        (
        {
            Edge::<f32>::new(rc.clone(), 0)
        },
        {
            Edge::<f32>::new(rc.clone(), 1)
        },
        )
    }

    pub fn build(inputs: inputs_Arg, labels_indices: labels_indices_Arg, labels_values: labels_values_Arg, sequence_length: sequence_length_Arg) -> Self {
        Self {
            inputs,
            labels_indices,
            labels_values,
            sequence_length,
            preprocess_collapse_repeated: None,
            ctc_merge_repeated: None,
            ignore_longer_outputs_than_inputs: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(inputs: inputs_Arg, labels_indices: labels_indices_Arg, labels_values: labels_values_Arg, sequence_length: sequence_length_Arg) -> (Edge<f32>, Edge<f32>) {
        Self {
            inputs,
            labels_indices,
            labels_values,
            sequence_length,
            preprocess_collapse_repeated: None,
            ctc_merge_repeated: None,
            ignore_longer_outputs_than_inputs: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<reverse_index_map_Arg, T, grad_values_Arg> GraphOperation for SparseFillEmptyRowsGrad<reverse_index_map_Arg, T, grad_values_Arg>
where reverse_index_map_Arg: Clone,
      reverse_index_map_Arg: GraphEdge<i64>,
      reverse_index_map_Arg: 'static,
      T: TensorType,
      T: Clone,
      grad_values_Arg: Clone,
      grad_values_Arg: GraphEdge<T>,
      grad_values_Arg: 'static,
      T: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("SparseFillEmptyRowsGrad_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("SparseFillEmptyRowsGrad", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.reverse_index_map)?
        }
        {
            new_op.add_edge(&self.grad_values)?
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct SparseFillEmptyRowsGrad<reverse_index_map_Arg, T, grad_values_Arg>
where reverse_index_map_Arg: Clone,
      reverse_index_map_Arg: GraphEdge<i64>,
      reverse_index_map_Arg: 'static,
      T: TensorType,
      T: Clone,
      grad_values_Arg: Clone,
      grad_values_Arg: GraphEdge<T>,
      grad_values_Arg: 'static,
      T: 'static,
{
    reverse_index_map: reverse_index_map_Arg,
    phantom_T: PhantomData<T>,
    grad_values: grad_values_Arg,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<reverse_index_map_Arg, T, grad_values_Arg> SparseFillEmptyRowsGrad<reverse_index_map_Arg, T, grad_values_Arg>
where reverse_index_map_Arg: Clone,
      reverse_index_map_Arg: GraphEdge<i64>,
      reverse_index_map_Arg: 'static,
      T: TensorType,
      T: Clone,
      grad_values_Arg: Clone,
      grad_values_Arg: GraphEdge<T>,
      grad_values_Arg: 'static,
      T: 'static,
{
    pub fn d_values(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn d_default_value(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 1)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> (Edge<T>, Edge<T>) {
        let rc = Rc::new(self);
        (
        {
            Edge::<T>::new(rc.clone(), 0)
        },
        {
            Edge::<T>::new(rc.clone(), 1)
        },
        )
    }

    pub fn build(reverse_index_map: reverse_index_map_Arg, grad_values: grad_values_Arg) -> Self {
        Self {
            reverse_index_map,
            phantom_T: PhantomData,
            grad_values,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(reverse_index_map: reverse_index_map_Arg, grad_values: grad_values_Arg) -> (Edge<T>, Edge<T>) {
        Self {
            reverse_index_map,
            phantom_T: PhantomData,
            grad_values,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

pub trait con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_BOOL_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_BOOL_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF for BFloat16 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_BOOL_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF for OtherComplex<f32> {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_BOOL_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF for OtherComplex<f64> {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_BOOL_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF for bool {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_BOOL_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF for f32 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_BOOL_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF for f64 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_BOOL_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF for i16 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_BOOL_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF for i32 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_BOOL_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF for i64 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_BOOL_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF for i8 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_BOOL_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF for u16 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_BOOL_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF for u8 {
}

impl<T, x_Arg> GraphOperation for OnesLike<T, x_Arg>
where T: TensorType,
      T: Clone,
      x_Arg: Clone,
      x_Arg: GraphEdge<T>,
      x_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_BOOL_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF,
      T: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("OnesLike_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("OnesLike", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.x)?
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct OnesLike<T, x_Arg>
where T: TensorType,
      T: Clone,
      x_Arg: Clone,
      x_Arg: GraphEdge<T>,
      x_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_BOOL_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    x: x_Arg,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<T, x_Arg> OnesLike<T, x_Arg>
where T: TensorType,
      T: Clone,
      x_Arg: Clone,
      x_Arg: GraphEdge<T>,
      x_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_BOOL_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF,
      T: 'static,
{
    pub fn y(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(x: x_Arg) -> Self {
        Self {
            phantom_T: PhantomData,
            x,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(x: x_Arg) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            x,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

pub trait con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_INT64_or_DT_BFLOAT16_or_DT_HALF_or_DT_HALF {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_INT64_or_DT_BFLOAT16_or_DT_HALF_or_DT_HALF for BFloat16 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_INT64_or_DT_BFLOAT16_or_DT_HALF_or_DT_HALF for f32 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_INT64_or_DT_BFLOAT16_or_DT_HALF_or_DT_HALF for f64 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_INT64_or_DT_BFLOAT16_or_DT_HALF_or_DT_HALF for i32 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_INT64_or_DT_BFLOAT16_or_DT_HALF_or_DT_HALF for i64 {
}

impl<T, x_Arg, y_Arg> GraphOperation for Mod<T, x_Arg, y_Arg>
where T: TensorType,
      T: Clone,
      x_Arg: Clone,
      x_Arg: GraphEdge<T>,
      x_Arg: 'static,
      y_Arg: Clone,
      y_Arg: GraphEdge<T>,
      y_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_INT64_or_DT_BFLOAT16_or_DT_HALF_or_DT_HALF,
      T: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("Mod_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("Mod", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.x)?
        }
        {
            new_op.add_edge(&self.y)?
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct Mod<T, x_Arg, y_Arg>
where T: TensorType,
      T: Clone,
      x_Arg: Clone,
      x_Arg: GraphEdge<T>,
      x_Arg: 'static,
      y_Arg: Clone,
      y_Arg: GraphEdge<T>,
      y_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_INT64_or_DT_BFLOAT16_or_DT_HALF_or_DT_HALF,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    x: x_Arg,
    y: y_Arg,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<T, x_Arg, y_Arg> Mod<T, x_Arg, y_Arg>
where T: TensorType,
      T: Clone,
      x_Arg: Clone,
      x_Arg: GraphEdge<T>,
      x_Arg: 'static,
      y_Arg: Clone,
      y_Arg: GraphEdge<T>,
      y_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_INT64_or_DT_BFLOAT16_or_DT_HALF_or_DT_HALF,
      T: 'static,
{
    pub fn z(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(x: x_Arg, y: y_Arg) -> Self {
        Self {
            phantom_T: PhantomData,
            x,
            y,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(x: x_Arg, y: y_Arg) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            x,
            y,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl GraphOperation for Abort {
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("Abort_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("Abort", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            match self.error_msg {
                None => new_op.set_attr_value_proto("error_msg", &vec![18_u8, 0_u8,])?,
                Some(ref value) => (|attr| {new_op.set_attr_string("error_msg", attr)})(&value)?,
            };
        }
        {
            match self.exit_without_error {
                None => new_op.set_attr_value_proto("exit_without_error", &vec![40_u8, 0_u8,])?,
                Some(ref value) => (|attr: &bool| {new_op.set_attr_bool("exit_without_error", *attr)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct Abort {
    error_msg: Option<String>,
    exit_without_error: Option<bool>,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl Abort {
    pub fn error_msg(&mut self, error_msg: &str) -> Self {
        self.error_msg = Some(error_msg.to_string());
        self.clone()
    }

    pub fn exit_without_error(&mut self, exit_without_error: bool) -> Self {
        self.exit_without_error = Some(exit_without_error);
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> () {
        let rc = Rc::new(self);
        (
        )
    }

    pub fn build() -> Self {
        Self {
            error_msg: None,
            exit_without_error: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new() -> () {
        Self {
            error_msg: None,
            exit_without_error: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<parameters_Arg, accumulators_Arg, gradient_accumulators_Arg> GraphOperation for LoadTPUEmbeddingProximalAdagradParametersGradAccumDebug<parameters_Arg, accumulators_Arg, gradient_accumulators_Arg>
where parameters_Arg: Clone,
      parameters_Arg: GraphEdge<f32>,
      parameters_Arg: 'static,
      accumulators_Arg: Clone,
      accumulators_Arg: GraphEdge<f32>,
      accumulators_Arg: 'static,
      gradient_accumulators_Arg: Clone,
      gradient_accumulators_Arg: GraphEdge<f32>,
      gradient_accumulators_Arg: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("LoadTPUEmbeddingProximalAdagradParametersGradAccumDebug_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("LoadTPUEmbeddingProximalAdagradParametersGradAccumDebug", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.parameters)?
        }
        {
            new_op.add_edge(&self.accumulators)?
        }
        {
            new_op.add_edge(&self.gradient_accumulators)?
        }
        {
            match self.table_id {
                None => new_op.set_attr_value_proto("table_id", &vec![24_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 1_u8,])?,
                Some(ref value) => (|attr: &i64| {new_op.set_attr_int("table_id", *attr)})(&value)?,
            };
        }
        {
            match self.table_name {
                None => new_op.set_attr_value_proto("table_name", &vec![18_u8, 0_u8,])?,
                Some(ref value) => (|attr| {new_op.set_attr_string("table_name", attr)})(&value)?,
            };
        }
        {
            (|attr: &i64| {new_op.set_attr_int("num_shards", *attr)})(&self.num_shards)?
        }
        {
            (|attr: &i64| {new_op.set_attr_int("shard_id", *attr)})(&self.shard_id)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct LoadTPUEmbeddingProximalAdagradParametersGradAccumDebug<parameters_Arg, accumulators_Arg, gradient_accumulators_Arg>
where parameters_Arg: Clone,
      parameters_Arg: GraphEdge<f32>,
      parameters_Arg: 'static,
      accumulators_Arg: Clone,
      accumulators_Arg: GraphEdge<f32>,
      accumulators_Arg: 'static,
      gradient_accumulators_Arg: Clone,
      gradient_accumulators_Arg: GraphEdge<f32>,
      gradient_accumulators_Arg: 'static,
{
    parameters: parameters_Arg,
    accumulators: accumulators_Arg,
    gradient_accumulators: gradient_accumulators_Arg,
    table_id: Option<i64>,
    table_name: Option<String>,
    num_shards: i64,
    shard_id: i64,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<parameters_Arg, accumulators_Arg, gradient_accumulators_Arg> LoadTPUEmbeddingProximalAdagradParametersGradAccumDebug<parameters_Arg, accumulators_Arg, gradient_accumulators_Arg>
where parameters_Arg: Clone,
      parameters_Arg: GraphEdge<f32>,
      parameters_Arg: 'static,
      accumulators_Arg: Clone,
      accumulators_Arg: GraphEdge<f32>,
      accumulators_Arg: 'static,
      gradient_accumulators_Arg: Clone,
      gradient_accumulators_Arg: GraphEdge<f32>,
      gradient_accumulators_Arg: 'static,
{
    pub fn table_id(&mut self, table_id: i64) -> Self {
        self.table_id = Some(table_id);
        self.clone()
    }

    pub fn table_name(&mut self, table_name: &str) -> Self {
        self.table_name = Some(table_name.to_string());
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> () {
        let rc = Rc::new(self);
        (
        )
    }

    pub fn build(parameters: parameters_Arg, accumulators: accumulators_Arg, gradient_accumulators: gradient_accumulators_Arg, num_shards: i64, shard_id: i64) -> Self {
        Self {
            parameters,
            accumulators,
            gradient_accumulators,
            table_id: None,
            table_name: None,
            num_shards: num_shards,
            shard_id: shard_id,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(parameters: parameters_Arg, accumulators: accumulators_Arg, gradient_accumulators: gradient_accumulators_Arg, num_shards: i64, shard_id: i64) -> () {
        Self {
            parameters,
            accumulators,
            gradient_accumulators,
            table_id: None,
            table_name: None,
            num_shards: num_shards,
            shard_id: shard_id,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<input_Arg> GraphOperation for LoopCond<input_Arg>
where input_Arg: Clone,
      input_Arg: GraphEdge<bool>,
      input_Arg: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("LoopCond_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("LoopCond", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.input)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct LoopCond<input_Arg>
where input_Arg: Clone,
      input_Arg: GraphEdge<bool>,
      input_Arg: 'static,
{
    input: input_Arg,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<input_Arg> LoopCond<input_Arg>
where input_Arg: Clone,
      input_Arg: GraphEdge<bool>,
      input_Arg: 'static,
{
    pub fn output(self) -> Edge<bool> {
        let rc = Rc::new(self);
        {
            Edge::<bool>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<bool> {
        let rc = Rc::new(self);
        {
            Edge::<bool>::new(rc.clone(), 0)
        }
    }

    pub fn build(input: input_Arg) -> Self {
        Self {
            input,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(input: input_Arg) -> Edge<bool> {
        Self {
            input,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<T, x_Arg, y_Arg> GraphOperation for SquaredDifference<T, x_Arg, y_Arg>
where T: TensorType,
      T: Clone,
      x_Arg: Clone,
      x_Arg: GraphEdge<T>,
      x_Arg: 'static,
      y_Arg: Clone,
      y_Arg: GraphEdge<T>,
      y_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_COMPLEX64_or_DT_INT64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF,
      T: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("SquaredDifference_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("SquaredDifference", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.x)?
        }
        {
            new_op.add_edge(&self.y)?
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct SquaredDifference<T, x_Arg, y_Arg>
where T: TensorType,
      T: Clone,
      x_Arg: Clone,
      x_Arg: GraphEdge<T>,
      x_Arg: 'static,
      y_Arg: Clone,
      y_Arg: GraphEdge<T>,
      y_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_COMPLEX64_or_DT_INT64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    x: x_Arg,
    y: y_Arg,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<T, x_Arg, y_Arg> SquaredDifference<T, x_Arg, y_Arg>
where T: TensorType,
      T: Clone,
      x_Arg: Clone,
      x_Arg: GraphEdge<T>,
      x_Arg: 'static,
      y_Arg: Clone,
      y_Arg: GraphEdge<T>,
      y_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_COMPLEX64_or_DT_INT64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF,
      T: 'static,
{
    pub fn z(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(x: x_Arg, y: y_Arg) -> Self {
        Self {
            phantom_T: PhantomData,
            x,
            y,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(x: x_Arg, y: y_Arg) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            x,
            y,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<S, shape_Arg, T, alpha_Arg> GraphOperation for RandomGamma<S, shape_Arg, T, alpha_Arg>
where S: TensorType,
      S: Clone,
      shape_Arg: Clone,
      shape_Arg: GraphEdge<S>,
      shape_Arg: 'static,
      T: TensorType,
      T: Clone,
      alpha_Arg: Clone,
      alpha_Arg: GraphEdge<T>,
      alpha_Arg: 'static,
      S: con_or_DT_INT32_or_DT_INT64,
      S: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_HALF,
      T: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("RandomGamma_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("RandomGamma", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.shape)?
        }
        {
            new_op.add_edge(&self.alpha)?
        }
        {
            match self.seed {
                None => new_op.set_attr_value_proto("seed", &vec![24_u8, 0_u8,])?,
                Some(ref value) => (|attr: &i64| {new_op.set_attr_int("seed", *attr)})(&value)?,
            };
        }
        {
            match self.seed2 {
                None => new_op.set_attr_value_proto("seed2", &vec![24_u8, 0_u8,])?,
                Some(ref value) => (|attr: &i64| {new_op.set_attr_int("seed2", *attr)})(&value)?,
            };
        }
        {
            new_op.set_attr_type("S", S::data_type())?;
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct RandomGamma<S, shape_Arg, T, alpha_Arg>
where S: TensorType,
      S: Clone,
      shape_Arg: Clone,
      shape_Arg: GraphEdge<S>,
      shape_Arg: 'static,
      T: TensorType,
      T: Clone,
      alpha_Arg: Clone,
      alpha_Arg: GraphEdge<T>,
      alpha_Arg: 'static,
      S: con_or_DT_INT32_or_DT_INT64,
      S: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_HALF,
      T: 'static,
{
    phantom_S: PhantomData<S>,
    shape: shape_Arg,
    phantom_T: PhantomData<T>,
    alpha: alpha_Arg,
    seed: Option<i64>,
    seed2: Option<i64>,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<S, shape_Arg, T, alpha_Arg> RandomGamma<S, shape_Arg, T, alpha_Arg>
where S: TensorType,
      S: Clone,
      shape_Arg: Clone,
      shape_Arg: GraphEdge<S>,
      shape_Arg: 'static,
      T: TensorType,
      T: Clone,
      alpha_Arg: Clone,
      alpha_Arg: GraphEdge<T>,
      alpha_Arg: 'static,
      S: con_or_DT_INT32_or_DT_INT64,
      S: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_HALF,
      T: 'static,
{
    pub fn output(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn seed(&mut self, seed: i64) -> Self {
        self.seed = Some(seed);
        self.clone()
    }

    pub fn seed2(&mut self, seed2: i64) -> Self {
        self.seed2 = Some(seed2);
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(shape: shape_Arg, alpha: alpha_Arg) -> Self {
        Self {
            phantom_S: PhantomData,
            shape,
            phantom_T: PhantomData,
            alpha,
            seed: None,
            seed2: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(shape: shape_Arg, alpha: alpha_Arg) -> Edge<T> {
        Self {
            phantom_S: PhantomData,
            shape,
            phantom_T: PhantomData,
            alpha,
            seed: None,
            seed2: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<Tinput, input_Arg, input_min_Arg, input_max_Arg, out_type> GraphOperation for QuantizeDownAndShrinkRange<Tinput, input_Arg, input_min_Arg, input_max_Arg, out_type>
where Tinput: TensorType,
      Tinput: Clone,
      input_Arg: Clone,
      input_Arg: GraphEdge<Tinput>,
      input_Arg: 'static,
      input_min_Arg: Clone,
      input_min_Arg: GraphEdge<f32>,
      input_min_Arg: 'static,
      input_max_Arg: Clone,
      input_max_Arg: GraphEdge<f32>,
      input_max_Arg: 'static,
      out_type: TensorType,
      Tinput: con_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_QINT16_or_DT_QUINT16,
      Tinput: 'static,
      out_type: con_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_QINT16_or_DT_QUINT16,
      out_type: 'static,
      out_type: Clone,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("QuantizeDownAndShrinkRange_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("QuantizeDownAndShrinkRange", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.input)?
        }
        {
            new_op.add_edge(&self.input_min)?
        }
        {
            new_op.add_edge(&self.input_max)?
        }
        {
            new_op.set_attr_type("Tinput", Tinput::data_type())?;
        }
        {
            new_op.set_attr_type("out_type", out_type::data_type())?;
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct QuantizeDownAndShrinkRange<Tinput, input_Arg, input_min_Arg, input_max_Arg, out_type>
where Tinput: TensorType,
      Tinput: Clone,
      input_Arg: Clone,
      input_Arg: GraphEdge<Tinput>,
      input_Arg: 'static,
      input_min_Arg: Clone,
      input_min_Arg: GraphEdge<f32>,
      input_min_Arg: 'static,
      input_max_Arg: Clone,
      input_max_Arg: GraphEdge<f32>,
      input_max_Arg: 'static,
      out_type: TensorType,
      Tinput: con_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_QINT16_or_DT_QUINT16,
      Tinput: 'static,
      out_type: con_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_QINT16_or_DT_QUINT16,
      out_type: 'static,
      out_type: Clone,
{
    phantom_Tinput: PhantomData<Tinput>,
    input: input_Arg,
    input_min: input_min_Arg,
    input_max: input_max_Arg,
    phantom_out_type: PhantomData<out_type>,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<Tinput, input_Arg, input_min_Arg, input_max_Arg, out_type> QuantizeDownAndShrinkRange<Tinput, input_Arg, input_min_Arg, input_max_Arg, out_type>
where Tinput: TensorType,
      Tinput: Clone,
      input_Arg: Clone,
      input_Arg: GraphEdge<Tinput>,
      input_Arg: 'static,
      input_min_Arg: Clone,
      input_min_Arg: GraphEdge<f32>,
      input_min_Arg: 'static,
      input_max_Arg: Clone,
      input_max_Arg: GraphEdge<f32>,
      input_max_Arg: 'static,
      out_type: TensorType,
      Tinput: con_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_QINT16_or_DT_QUINT16,
      Tinput: 'static,
      out_type: con_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_QINT16_or_DT_QUINT16,
      out_type: 'static,
      out_type: Clone,
{
    pub fn output(self) -> Edge<out_type> {
        let rc = Rc::new(self);
        {
            Edge::<out_type>::new(rc.clone(), 0)
        }
    }

    pub fn output_min(self) -> Edge<f32> {
        let rc = Rc::new(self);
        {
            Edge::<f32>::new(rc.clone(), 1)
        }
    }

    pub fn output_max(self) -> Edge<f32> {
        let rc = Rc::new(self);
        {
            Edge::<f32>::new(rc.clone(), 2)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> (Edge<out_type>, Edge<f32>, Edge<f32>) {
        let rc = Rc::new(self);
        (
        {
            Edge::<out_type>::new(rc.clone(), 0)
        },
        {
            Edge::<f32>::new(rc.clone(), 1)
        },
        {
            Edge::<f32>::new(rc.clone(), 2)
        },
        )
    }

    pub fn build(input: input_Arg, input_min: input_min_Arg, input_max: input_max_Arg) -> Self {
        Self {
            phantom_Tinput: PhantomData,
            input,
            input_min,
            input_max,
            phantom_out_type: PhantomData,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(input: input_Arg, input_min: input_min_Arg, input_max: input_max_Arg) -> (Edge<out_type>, Edge<f32>, Edge<f32>) {
        Self {
            phantom_Tinput: PhantomData,
            input,
            input_min,
            input_max,
            phantom_out_type: PhantomData,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl GraphOperation for Fact {
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("Fact_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("Fact", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct Fact {
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl Fact {
    pub fn fact(self) -> Edge<String> {
        let rc = Rc::new(self);
        {
            Edge::<String>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<String> {
        let rc = Rc::new(self);
        {
            Edge::<String>::new(rc.clone(), 0)
        }
    }

    pub fn build() -> Self {
        Self {
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new() -> Edge<String> {
        Self {
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<T, data_Arg> GraphOperation for NextIteration<T, data_Arg>
where T: TensorType,
      T: Clone,
      data_Arg: Clone,
      data_Arg: GraphEdge<T>,
      data_Arg: 'static,
      T: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("NextIteration_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("NextIteration", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.data)?
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct NextIteration<T, data_Arg>
where T: TensorType,
      T: Clone,
      data_Arg: Clone,
      data_Arg: GraphEdge<T>,
      data_Arg: 'static,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    data: data_Arg,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<T, data_Arg> NextIteration<T, data_Arg>
where T: TensorType,
      T: Clone,
      data_Arg: Clone,
      data_Arg: GraphEdge<T>,
      data_Arg: 'static,
      T: 'static,
{
    pub fn output(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(data: data_Arg) -> Self {
        Self {
            phantom_T: PhantomData,
            data,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(data: data_Arg) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            data,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<T, x_Arg> GraphOperation for Lgamma<T, x_Arg>
where T: TensorType,
      T: Clone,
      x_Arg: Clone,
      x_Arg: GraphEdge<T>,
      x_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
      T: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("Lgamma_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("Lgamma", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.x)?
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct Lgamma<T, x_Arg>
where T: TensorType,
      T: Clone,
      x_Arg: Clone,
      x_Arg: GraphEdge<T>,
      x_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    x: x_Arg,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<T, x_Arg> Lgamma<T, x_Arg>
where T: TensorType,
      T: Clone,
      x_Arg: Clone,
      x_Arg: GraphEdge<T>,
      x_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
      T: 'static,
{
    pub fn y(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(x: x_Arg) -> Self {
        Self {
            phantom_T: PhantomData,
            x,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(x: x_Arg) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            x,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<T, input_Arg> GraphOperation for Snapshot<T, input_Arg>
where T: TensorType,
      T: Clone,
      input_Arg: Clone,
      input_Arg: GraphEdge<T>,
      input_Arg: 'static,
      T: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("Snapshot_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("Snapshot", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.input)?
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct Snapshot<T, input_Arg>
where T: TensorType,
      T: Clone,
      input_Arg: Clone,
      input_Arg: GraphEdge<T>,
      input_Arg: 'static,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    input: input_Arg,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<T, input_Arg> Snapshot<T, input_Arg>
where T: TensorType,
      T: Clone,
      input_Arg: Clone,
      input_Arg: GraphEdge<T>,
      input_Arg: 'static,
      T: 'static,
{
    pub fn output(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(input: input_Arg) -> Self {
        Self {
            phantom_T: PhantomData,
            input,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(input: input_Arg) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            input,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<T, data_Arg> GraphOperation for RefExit<T, data_Arg>
where T: TensorType,
      T: Clone,
      data_Arg: Clone,
      data_Arg: GraphRefEdge<T>,
      data_Arg: 'static,
      T: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("RefExit_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("RefExit", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.data)?
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct RefExit<T, data_Arg>
where T: TensorType,
      T: Clone,
      data_Arg: Clone,
      data_Arg: GraphRefEdge<T>,
      data_Arg: 'static,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    data: data_Arg,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<T, data_Arg> RefExit<T, data_Arg>
where T: TensorType,
      T: Clone,
      data_Arg: Clone,
      data_Arg: GraphRefEdge<T>,
      data_Arg: 'static,
      T: 'static,
{
    pub fn output(self) -> RefEdge<T> {
        let rc = Rc::new(self);
        {
            RefEdge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> RefEdge<T> {
        let rc = Rc::new(self);
        {
            RefEdge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(data: data_Arg) -> Self {
        Self {
            phantom_T: PhantomData,
            data,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(data: data_Arg) -> RefEdge<T> {
        Self {
            phantom_T: PhantomData,
            data,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<Tindices, indices_Arg, T, updates_Arg, shape_Arg> GraphOperation for ScatterNd<Tindices, indices_Arg, T, updates_Arg, shape_Arg>
where Tindices: TensorType,
      Tindices: Clone,
      indices_Arg: Clone,
      indices_Arg: GraphEdge<Tindices>,
      indices_Arg: 'static,
      T: TensorType,
      T: Clone,
      updates_Arg: Clone,
      updates_Arg: GraphEdge<T>,
      updates_Arg: 'static,
      shape_Arg: Clone,
      shape_Arg: GraphEdge<Tindices>,
      shape_Arg: 'static,
      T: 'static,
      Tindices: con_or_DT_INT32_or_DT_INT64,
      Tindices: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("ScatterNd_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("ScatterNd", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.indices)?
        }
        {
            new_op.add_edge(&self.updates)?
        }
        {
            new_op.add_edge(&self.shape)?
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        {
            new_op.set_attr_type("Tindices", Tindices::data_type())?;
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct ScatterNd<Tindices, indices_Arg, T, updates_Arg, shape_Arg>
where Tindices: TensorType,
      Tindices: Clone,
      indices_Arg: Clone,
      indices_Arg: GraphEdge<Tindices>,
      indices_Arg: 'static,
      T: TensorType,
      T: Clone,
      updates_Arg: Clone,
      updates_Arg: GraphEdge<T>,
      updates_Arg: 'static,
      shape_Arg: Clone,
      shape_Arg: GraphEdge<Tindices>,
      shape_Arg: 'static,
      T: 'static,
      Tindices: con_or_DT_INT32_or_DT_INT64,
      Tindices: 'static,
{
    phantom_Tindices: PhantomData<Tindices>,
    indices: indices_Arg,
    phantom_T: PhantomData<T>,
    updates: updates_Arg,
    shape: shape_Arg,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<Tindices, indices_Arg, T, updates_Arg, shape_Arg> ScatterNd<Tindices, indices_Arg, T, updates_Arg, shape_Arg>
where Tindices: TensorType,
      Tindices: Clone,
      indices_Arg: Clone,
      indices_Arg: GraphEdge<Tindices>,
      indices_Arg: 'static,
      T: TensorType,
      T: Clone,
      updates_Arg: Clone,
      updates_Arg: GraphEdge<T>,
      updates_Arg: 'static,
      shape_Arg: Clone,
      shape_Arg: GraphEdge<Tindices>,
      shape_Arg: 'static,
      T: 'static,
      Tindices: con_or_DT_INT32_or_DT_INT64,
      Tindices: 'static,
{
    pub fn output(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(indices: indices_Arg, updates: updates_Arg, shape: shape_Arg) -> Self {
        Self {
            phantom_Tindices: PhantomData,
            indices,
            phantom_T: PhantomData,
            updates,
            shape,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(indices: indices_Arg, updates: updates_Arg, shape: shape_Arg) -> Edge<T> {
        Self {
            phantom_Tindices: PhantomData,
            indices,
            phantom_T: PhantomData,
            updates,
            shape,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<T, inputs_Arg> GraphOperation for RefMerge<T, inputs_Arg>
where T: TensorType,
      T: Clone,
      inputs_Arg: Clone,
      inputs_Arg: GraphRefEdge<T>,
      inputs_Arg: 'static,
      T: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("RefMerge_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("RefMerge", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.inputs)?
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        {
            (|attr: &i64| {new_op.set_attr_int("N", *attr)})(&self.N)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct RefMerge<T, inputs_Arg>
where T: TensorType,
      T: Clone,
      inputs_Arg: Clone,
      inputs_Arg: GraphRefEdge<T>,
      inputs_Arg: 'static,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    inputs: inputs_Arg,
    N: i64,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<T, inputs_Arg> RefMerge<T, inputs_Arg>
where T: TensorType,
      T: Clone,
      inputs_Arg: Clone,
      inputs_Arg: GraphRefEdge<T>,
      inputs_Arg: 'static,
      T: 'static,
{
    pub fn output(self) -> RefEdge<T> {
        let rc = Rc::new(self);
        {
            RefEdge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn value_index(self) -> Edge<i32> {
        let rc = Rc::new(self);
        {
            Edge::<i32>::new(rc.clone(), 1)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> (RefEdge<T>, Edge<i32>) {
        let rc = Rc::new(self);
        (
        {
            RefEdge::<T>::new(rc.clone(), 0)
        },
        {
            Edge::<i32>::new(rc.clone(), 1)
        },
        )
    }

    pub fn build(inputs: inputs_Arg, N: i64) -> Self {
        Self {
            phantom_T: PhantomData,
            inputs,
            N: N,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(inputs: inputs_Arg, N: i64) -> (RefEdge<T>, Edge<i32>) {
        Self {
            phantom_T: PhantomData,
            inputs,
            N: N,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<T, data_Arg, pred_Arg> GraphOperation for Switch<T, data_Arg, pred_Arg>
where T: TensorType,
      T: Clone,
      data_Arg: Clone,
      data_Arg: GraphEdge<T>,
      data_Arg: 'static,
      pred_Arg: Clone,
      pred_Arg: GraphEdge<bool>,
      pred_Arg: 'static,
      T: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("Switch_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("Switch", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.data)?
        }
        {
            new_op.add_edge(&self.pred)?
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct Switch<T, data_Arg, pred_Arg>
where T: TensorType,
      T: Clone,
      data_Arg: Clone,
      data_Arg: GraphEdge<T>,
      data_Arg: 'static,
      pred_Arg: Clone,
      pred_Arg: GraphEdge<bool>,
      pred_Arg: 'static,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    data: data_Arg,
    pred: pred_Arg,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<T, data_Arg, pred_Arg> Switch<T, data_Arg, pred_Arg>
where T: TensorType,
      T: Clone,
      data_Arg: Clone,
      data_Arg: GraphEdge<T>,
      data_Arg: 'static,
      pred_Arg: Clone,
      pred_Arg: GraphEdge<bool>,
      pred_Arg: 'static,
      T: 'static,
{
    pub fn output_false(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn output_true(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 1)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> (Edge<T>, Edge<T>) {
        let rc = Rc::new(self);
        (
        {
            Edge::<T>::new(rc.clone(), 0)
        },
        {
            Edge::<T>::new(rc.clone(), 1)
        },
        )
    }

    pub fn build(data: data_Arg, pred: pred_Arg) -> Self {
        Self {
            phantom_T: PhantomData,
            data,
            pred,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(data: data_Arg, pred: pred_Arg) -> (Edge<T>, Edge<T>) {
        Self {
            phantom_T: PhantomData,
            data,
            pred,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<input_Arg> GraphOperation for DecodeBase64<input_Arg>
where input_Arg: Clone,
      input_Arg: GraphEdge<String>,
      input_Arg: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("DecodeBase64_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("DecodeBase64", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.input)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct DecodeBase64<input_Arg>
where input_Arg: Clone,
      input_Arg: GraphEdge<String>,
      input_Arg: 'static,
{
    input: input_Arg,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<input_Arg> DecodeBase64<input_Arg>
where input_Arg: Clone,
      input_Arg: GraphEdge<String>,
      input_Arg: 'static,
{
    pub fn output(self) -> Edge<String> {
        let rc = Rc::new(self);
        {
            Edge::<String>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<String> {
        let rc = Rc::new(self);
        {
            Edge::<String>::new(rc.clone(), 0)
        }
    }

    pub fn build(input: input_Arg) -> Self {
        Self {
            input,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(input: input_Arg) -> Edge<String> {
        Self {
            input,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

pub trait con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_INT64_or_DT_HALF {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_INT64_or_DT_HALF for f32 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_INT64_or_DT_HALF for f64 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_INT64_or_DT_HALF for i32 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_INT64_or_DT_HALF for i64 {
}

impl<T> GraphOperation for CollectiveBcastRecv<T>
where T: TensorType,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_INT64_or_DT_HALF,
      T: 'static,
      T: Clone,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("CollectiveBcastRecv_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("CollectiveBcastRecv", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        {
            (|attr: &i64| {new_op.set_attr_int("group_size", *attr)})(&self.group_size)?
        }
        {
            (|attr: &i64| {new_op.set_attr_int("group_key", *attr)})(&self.group_key)?
        }
        {
            (|attr: &i64| {new_op.set_attr_int("instance_key", *attr)})(&self.instance_key)?
        }
        {
            (|attr| {new_op.set_attr_shape("shape", attr)})(&self.shape)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct CollectiveBcastRecv<T>
where T: TensorType,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_INT64_or_DT_HALF,
      T: 'static,
      T: Clone,
{
    phantom_T: PhantomData<T>,
    group_size: i64,
    group_key: i64,
    instance_key: i64,
    shape: OtherShape,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<T> CollectiveBcastRecv<T>
where T: TensorType,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_INT64_or_DT_HALF,
      T: 'static,
      T: Clone,
{
    pub fn data(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(group_size: i64, group_key: i64, instance_key: i64, shape: &OtherShape) -> Self {
        Self {
            phantom_T: PhantomData,
            group_size: group_size,
            group_key: group_key,
            instance_key: instance_key,
            shape: shape.clone(),
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(group_size: i64, group_key: i64, instance_key: i64, shape: &OtherShape) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            group_size: group_size,
            group_key: group_key,
            instance_key: instance_key,
            shape: shape.clone(),
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<T, x_Arg> GraphOperation for Rsqrt<T, x_Arg>
where T: TensorType,
      T: Clone,
      x_Arg: Clone,
      x_Arg: GraphEdge<T>,
      x_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_COMPLEX64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF,
      T: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("Rsqrt_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("Rsqrt", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.x)?
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct Rsqrt<T, x_Arg>
where T: TensorType,
      T: Clone,
      x_Arg: Clone,
      x_Arg: GraphEdge<T>,
      x_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_COMPLEX64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    x: x_Arg,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<T, x_Arg> Rsqrt<T, x_Arg>
where T: TensorType,
      T: Clone,
      x_Arg: Clone,
      x_Arg: GraphEdge<T>,
      x_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_COMPLEX64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF,
      T: 'static,
{
    pub fn y(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(x: x_Arg) -> Self {
        Self {
            phantom_T: PhantomData,
            x,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(x: x_Arg) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            x,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<T, data_Arg, pred_Arg> GraphOperation for RefSwitch<T, data_Arg, pred_Arg>
where T: TensorType,
      T: Clone,
      data_Arg: Clone,
      data_Arg: GraphRefEdge<T>,
      data_Arg: 'static,
      pred_Arg: Clone,
      pred_Arg: GraphEdge<bool>,
      pred_Arg: 'static,
      T: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("RefSwitch_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("RefSwitch", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.data)?
        }
        {
            new_op.add_edge(&self.pred)?
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct RefSwitch<T, data_Arg, pred_Arg>
where T: TensorType,
      T: Clone,
      data_Arg: Clone,
      data_Arg: GraphRefEdge<T>,
      data_Arg: 'static,
      pred_Arg: Clone,
      pred_Arg: GraphEdge<bool>,
      pred_Arg: 'static,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    data: data_Arg,
    pred: pred_Arg,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<T, data_Arg, pred_Arg> RefSwitch<T, data_Arg, pred_Arg>
where T: TensorType,
      T: Clone,
      data_Arg: Clone,
      data_Arg: GraphRefEdge<T>,
      data_Arg: 'static,
      pred_Arg: Clone,
      pred_Arg: GraphEdge<bool>,
      pred_Arg: 'static,
      T: 'static,
{
    pub fn output_false(self) -> RefEdge<T> {
        let rc = Rc::new(self);
        {
            RefEdge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn output_true(self) -> RefEdge<T> {
        let rc = Rc::new(self);
        {
            RefEdge::<T>::new(rc.clone(), 1)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> (RefEdge<T>, RefEdge<T>) {
        let rc = Rc::new(self);
        (
        {
            RefEdge::<T>::new(rc.clone(), 0)
        },
        {
            RefEdge::<T>::new(rc.clone(), 1)
        },
        )
    }

    pub fn build(data: data_Arg, pred: pred_Arg) -> Self {
        Self {
            phantom_T: PhantomData,
            data,
            pred,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(data: data_Arg, pred: pred_Arg) -> (RefEdge<T>, RefEdge<T>) {
        Self {
            phantom_T: PhantomData,
            data,
            pred,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<T, input_Arg> GraphOperation for CollectiveBcastSend<T, input_Arg>
where T: TensorType,
      T: Clone,
      input_Arg: Clone,
      input_Arg: GraphEdge<T>,
      input_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_INT64_or_DT_HALF,
      T: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("CollectiveBcastSend_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("CollectiveBcastSend", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.input)?
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        {
            (|attr: &i64| {new_op.set_attr_int("group_size", *attr)})(&self.group_size)?
        }
        {
            (|attr: &i64| {new_op.set_attr_int("group_key", *attr)})(&self.group_key)?
        }
        {
            (|attr: &i64| {new_op.set_attr_int("instance_key", *attr)})(&self.instance_key)?
        }
        {
            (|attr| {new_op.set_attr_shape("shape", attr)})(&self.shape)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct CollectiveBcastSend<T, input_Arg>
where T: TensorType,
      T: Clone,
      input_Arg: Clone,
      input_Arg: GraphEdge<T>,
      input_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_INT64_or_DT_HALF,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    input: input_Arg,
    group_size: i64,
    group_key: i64,
    instance_key: i64,
    shape: OtherShape,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<T, input_Arg> CollectiveBcastSend<T, input_Arg>
where T: TensorType,
      T: Clone,
      input_Arg: Clone,
      input_Arg: GraphEdge<T>,
      input_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_INT64_or_DT_HALF,
      T: 'static,
{
    pub fn data(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(input: input_Arg, group_size: i64, group_key: i64, instance_key: i64, shape: &OtherShape) -> Self {
        Self {
            phantom_T: PhantomData,
            input,
            group_size: group_size,
            group_key: group_key,
            instance_key: instance_key,
            shape: shape.clone(),
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(input: input_Arg, group_size: i64, group_key: i64, instance_key: i64, shape: &OtherShape) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            input,
            group_size: group_size,
            group_key: group_key,
            instance_key: instance_key,
            shape: shape.clone(),
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<T, x_Arg> GraphOperation for DeepCopy<T, x_Arg>
where T: TensorType,
      T: Clone,
      x_Arg: Clone,
      x_Arg: GraphEdge<T>,
      x_Arg: 'static,
      T: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("DeepCopy_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("DeepCopy", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.x)?
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct DeepCopy<T, x_Arg>
where T: TensorType,
      T: Clone,
      x_Arg: Clone,
      x_Arg: GraphEdge<T>,
      x_Arg: 'static,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    x: x_Arg,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<T, x_Arg> DeepCopy<T, x_Arg>
where T: TensorType,
      T: Clone,
      x_Arg: Clone,
      x_Arg: GraphEdge<T>,
      x_Arg: 'static,
      T: 'static,
{
    pub fn y(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(x: x_Arg) -> Self {
        Self {
            phantom_T: PhantomData,
            x,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(x: x_Arg) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            x,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<T, input_Arg> GraphOperation for CollectiveReduce<T, input_Arg>
where T: TensorType,
      T: Clone,
      input_Arg: Clone,
      input_Arg: GraphEdge<T>,
      input_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_INT64_or_DT_HALF,
      T: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("CollectiveReduce_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("CollectiveReduce", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.input)?
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        {
            (|attr: &i64| {new_op.set_attr_int("group_size", *attr)})(&self.group_size)?
        }
        {
            (|attr: &i64| {new_op.set_attr_int("group_key", *attr)})(&self.group_key)?
        }
        {
            (|attr: &i64| {new_op.set_attr_int("instance_key", *attr)})(&self.instance_key)?
        }
        {
            (|attr| {new_op.set_attr_string("merge_op", attr)})(&self.merge_op)?
        }
        {
            (|attr| {new_op.set_attr_string("final_op", attr)})(&self.final_op)?
        }
        {
            (|attrs| {new_op.set_attr_int_list("subdiv_offsets", attrs)})(&self.subdiv_offsets)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct CollectiveReduce<T, input_Arg>
where T: TensorType,
      T: Clone,
      input_Arg: Clone,
      input_Arg: GraphEdge<T>,
      input_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_INT64_or_DT_HALF,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    input: input_Arg,
    group_size: i64,
    group_key: i64,
    instance_key: i64,
    merge_op: String,
    final_op: String,
    subdiv_offsets: Vec<i64>,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<T, input_Arg> CollectiveReduce<T, input_Arg>
where T: TensorType,
      T: Clone,
      input_Arg: Clone,
      input_Arg: GraphEdge<T>,
      input_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_INT64_or_DT_HALF,
      T: 'static,
{
    pub fn data(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(input: input_Arg, group_size: i64, group_key: i64, instance_key: i64, merge_op: &str, final_op: &str, subdiv_offsets: &[i64]) -> Self {
        Self {
            phantom_T: PhantomData,
            input,
            group_size: group_size,
            group_key: group_key,
            instance_key: instance_key,
            merge_op: merge_op.to_string(),
            final_op: final_op.to_string(),
            subdiv_offsets: subdiv_offsets.to_vec(),
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(input: input_Arg, group_size: i64, group_key: i64, instance_key: i64, merge_op: &str, final_op: &str, subdiv_offsets: &[i64]) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            input,
            group_size: group_size,
            group_key: group_key,
            instance_key: instance_key,
            merge_op: merge_op.to_string(),
            final_op: final_op.to_string(),
            subdiv_offsets: subdiv_offsets.to_vec(),
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<T, data_Arg> GraphOperation for RefEnter<T, data_Arg>
where T: TensorType,
      T: Clone,
      data_Arg: Clone,
      data_Arg: GraphRefEdge<T>,
      data_Arg: 'static,
      T: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("RefEnter_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("RefEnter", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.data)?
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        {
            (|attr| {new_op.set_attr_string("frame_name", attr)})(&self.frame_name)?
        }
        {
            match self.is_constant {
                None => new_op.set_attr_value_proto("is_constant", &vec![40_u8, 0_u8,])?,
                Some(ref value) => (|attr: &bool| {new_op.set_attr_bool("is_constant", *attr)})(&value)?,
            };
        }
        {
            match self.parallel_iterations {
                None => new_op.set_attr_value_proto("parallel_iterations", &vec![24_u8, 10_u8,])?,
                Some(ref value) => (|attr: &i64| {new_op.set_attr_int("parallel_iterations", *attr)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct RefEnter<T, data_Arg>
where T: TensorType,
      T: Clone,
      data_Arg: Clone,
      data_Arg: GraphRefEdge<T>,
      data_Arg: 'static,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    data: data_Arg,
    frame_name: String,
    is_constant: Option<bool>,
    parallel_iterations: Option<i64>,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<T, data_Arg> RefEnter<T, data_Arg>
where T: TensorType,
      T: Clone,
      data_Arg: Clone,
      data_Arg: GraphRefEdge<T>,
      data_Arg: 'static,
      T: 'static,
{
    pub fn output(self) -> RefEdge<T> {
        let rc = Rc::new(self);
        {
            RefEdge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn is_constant(&mut self, is_constant: bool) -> Self {
        self.is_constant = Some(is_constant);
        self.clone()
    }

    pub fn parallel_iterations(&mut self, parallel_iterations: i64) -> Self {
        self.parallel_iterations = Some(parallel_iterations);
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> RefEdge<T> {
        let rc = Rc::new(self);
        {
            RefEdge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(data: data_Arg, frame_name: &str) -> Self {
        Self {
            phantom_T: PhantomData,
            data,
            frame_name: frame_name.to_string(),
            is_constant: None,
            parallel_iterations: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(data: data_Arg, frame_name: &str) -> RefEdge<T> {
        Self {
            phantom_T: PhantomData,
            data,
            frame_name: frame_name.to_string(),
            is_constant: None,
            parallel_iterations: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<true_classes_Arg> GraphOperation for FixedUnigramCandidateSampler<true_classes_Arg>
where true_classes_Arg: Clone,
      true_classes_Arg: GraphEdge<i64>,
      true_classes_Arg: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("FixedUnigramCandidateSampler_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("FixedUnigramCandidateSampler", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.true_classes)?
        }
        {
            (|attr: &i64| {new_op.set_attr_int("num_true", *attr)})(&self.num_true)?
        }
        {
            (|attr: &i64| {new_op.set_attr_int("num_sampled", *attr)})(&self.num_sampled)?
        }
        {
            (|attr: &bool| {new_op.set_attr_bool("unique", *attr)})(&self.unique)?
        }
        {
            (|attr: &i64| {new_op.set_attr_int("range_max", *attr)})(&self.range_max)?
        }
        {
            match self.vocab_file {
                None => new_op.set_attr_value_proto("vocab_file", &vec![18_u8, 0_u8,])?,
                Some(ref value) => (|attr| {new_op.set_attr_string("vocab_file", attr)})(&value)?,
            };
        }
        {
            match self.distortion {
                None => new_op.set_attr_value_proto("distortion", &vec![37_u8, 0_u8, 0_u8, 128_u8, 63_u8,])?,
                Some(ref value) => (|attr: &f32| {new_op.set_attr_float("distortion", *attr)})(&value)?,
            };
        }
        {
            match self.num_reserved_ids {
                None => new_op.set_attr_value_proto("num_reserved_ids", &vec![24_u8, 0_u8,])?,
                Some(ref value) => (|attr: &i64| {new_op.set_attr_int("num_reserved_ids", *attr)})(&value)?,
            };
        }
        {
            match self.num_shards {
                None => new_op.set_attr_value_proto("num_shards", &vec![24_u8, 1_u8,])?,
                Some(ref value) => (|attr: &i64| {new_op.set_attr_int("num_shards", *attr)})(&value)?,
            };
        }
        {
            match self.shard {
                None => new_op.set_attr_value_proto("shard", &vec![24_u8, 0_u8,])?,
                Some(ref value) => (|attr: &i64| {new_op.set_attr_int("shard", *attr)})(&value)?,
            };
        }
        {
            match self.unigrams {
                None => new_op.set_attr_value_proto("unigrams", &vec![10_u8, 0_u8,])?,
                Some(ref value) => (|attrs| {new_op.set_attr_float_list("unigrams", attrs)})(&value)?,
            };
        }
        {
            match self.seed {
                None => new_op.set_attr_value_proto("seed", &vec![24_u8, 0_u8,])?,
                Some(ref value) => (|attr: &i64| {new_op.set_attr_int("seed", *attr)})(&value)?,
            };
        }
        {
            match self.seed2 {
                None => new_op.set_attr_value_proto("seed2", &vec![24_u8, 0_u8,])?,
                Some(ref value) => (|attr: &i64| {new_op.set_attr_int("seed2", *attr)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct FixedUnigramCandidateSampler<true_classes_Arg>
where true_classes_Arg: Clone,
      true_classes_Arg: GraphEdge<i64>,
      true_classes_Arg: 'static,
{
    true_classes: true_classes_Arg,
    num_true: i64,
    num_sampled: i64,
    unique: bool,
    range_max: i64,
    vocab_file: Option<String>,
    distortion: Option<f32>,
    num_reserved_ids: Option<i64>,
    num_shards: Option<i64>,
    shard: Option<i64>,
    unigrams: Option<Vec<f32>>,
    seed: Option<i64>,
    seed2: Option<i64>,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<true_classes_Arg> FixedUnigramCandidateSampler<true_classes_Arg>
where true_classes_Arg: Clone,
      true_classes_Arg: GraphEdge<i64>,
      true_classes_Arg: 'static,
{
    pub fn sampled_candidates(self) -> Edge<i64> {
        let rc = Rc::new(self);
        {
            Edge::<i64>::new(rc.clone(), 0)
        }
    }

    pub fn true_expected_count(self) -> Edge<f32> {
        let rc = Rc::new(self);
        {
            Edge::<f32>::new(rc.clone(), 1)
        }
    }

    pub fn sampled_expected_count(self) -> Edge<f32> {
        let rc = Rc::new(self);
        {
            Edge::<f32>::new(rc.clone(), 2)
        }
    }

    pub fn vocab_file(&mut self, vocab_file: &str) -> Self {
        self.vocab_file = Some(vocab_file.to_string());
        self.clone()
    }

    pub fn distortion(&mut self, distortion: f32) -> Self {
        self.distortion = Some(distortion);
        self.clone()
    }

    pub fn num_reserved_ids(&mut self, num_reserved_ids: i64) -> Self {
        self.num_reserved_ids = Some(num_reserved_ids);
        self.clone()
    }

    pub fn num_shards(&mut self, num_shards: i64) -> Self {
        self.num_shards = Some(num_shards);
        self.clone()
    }

    pub fn shard(&mut self, shard: i64) -> Self {
        self.shard = Some(shard);
        self.clone()
    }

    pub fn unigrams(&mut self, unigrams: &[f32]) -> Self {
        self.unigrams = Some(unigrams.to_vec());
        self.clone()
    }

    pub fn seed(&mut self, seed: i64) -> Self {
        self.seed = Some(seed);
        self.clone()
    }

    pub fn seed2(&mut self, seed2: i64) -> Self {
        self.seed2 = Some(seed2);
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> (Edge<i64>, Edge<f32>, Edge<f32>) {
        let rc = Rc::new(self);
        (
        {
            Edge::<i64>::new(rc.clone(), 0)
        },
        {
            Edge::<f32>::new(rc.clone(), 1)
        },
        {
            Edge::<f32>::new(rc.clone(), 2)
        },
        )
    }

    pub fn build(true_classes: true_classes_Arg, num_true: i64, num_sampled: i64, unique: bool, range_max: i64) -> Self {
        Self {
            true_classes,
            num_true: num_true,
            num_sampled: num_sampled,
            unique: unique,
            range_max: range_max,
            vocab_file: None,
            distortion: None,
            num_reserved_ids: None,
            num_shards: None,
            shard: None,
            unigrams: None,
            seed: None,
            seed2: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(true_classes: true_classes_Arg, num_true: i64, num_sampled: i64, unique: bool, range_max: i64) -> (Edge<i64>, Edge<f32>, Edge<f32>) {
        Self {
            true_classes,
            num_true: num_true,
            num_sampled: num_sampled,
            unique: unique,
            range_max: range_max,
            vocab_file: None,
            distortion: None,
            num_reserved_ids: None,
            num_shards: None,
            shard: None,
            unigrams: None,
            seed: None,
            seed2: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<handle_Arg> GraphOperation for BarrierIncompleteSize<handle_Arg>
where handle_Arg: Clone,
      handle_Arg: GraphRefEdge<String>,
      handle_Arg: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("BarrierIncompleteSize_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("BarrierIncompleteSize", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.handle)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct BarrierIncompleteSize<handle_Arg>
where handle_Arg: Clone,
      handle_Arg: GraphRefEdge<String>,
      handle_Arg: 'static,
{
    handle: handle_Arg,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<handle_Arg> BarrierIncompleteSize<handle_Arg>
where handle_Arg: Clone,
      handle_Arg: GraphRefEdge<String>,
      handle_Arg: 'static,
{
    pub fn size(self) -> Edge<i32> {
        let rc = Rc::new(self);
        {
            Edge::<i32>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<i32> {
        let rc = Rc::new(self);
        {
            Edge::<i32>::new(rc.clone(), 0)
        }
    }

    pub fn build(handle: handle_Arg) -> Self {
        Self {
            handle,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(handle: handle_Arg) -> Edge<i32> {
        Self {
            handle,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<T, input_Arg, ksize_Arg, strides_Arg> GraphOperation for MaxPoolV2<T, input_Arg, ksize_Arg, strides_Arg>
where T: TensorType,
      T: Clone,
      input_Arg: Clone,
      input_Arg: GraphEdge<T>,
      input_Arg: 'static,
      ksize_Arg: Clone,
      ksize_Arg: GraphEdge<i32>,
      ksize_Arg: 'static,
      strides_Arg: Clone,
      strides_Arg: GraphEdge<i32>,
      strides_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_QINT8_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF,
      T: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("MaxPoolV2_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("MaxPoolV2", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.input)?
        }
        {
            new_op.add_edge(&self.ksize)?
        }
        {
            new_op.add_edge(&self.strides)?
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        {
            (|attr| {new_op.set_attr_string("padding", attr)})(&self.padding)?
        }
        {
            match self.data_format {
                None => new_op.set_attr_value_proto("data_format", &vec![18_u8, 4_u8, 78_u8, 72_u8, 87_u8, 67_u8,])?,
                Some(ref value) => (|attr| {new_op.set_attr_string("data_format", attr)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct MaxPoolV2<T, input_Arg, ksize_Arg, strides_Arg>
where T: TensorType,
      T: Clone,
      input_Arg: Clone,
      input_Arg: GraphEdge<T>,
      input_Arg: 'static,
      ksize_Arg: Clone,
      ksize_Arg: GraphEdge<i32>,
      ksize_Arg: 'static,
      strides_Arg: Clone,
      strides_Arg: GraphEdge<i32>,
      strides_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_QINT8_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    input: input_Arg,
    ksize: ksize_Arg,
    strides: strides_Arg,
    padding: String,
    data_format: Option<String>,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<T, input_Arg, ksize_Arg, strides_Arg> MaxPoolV2<T, input_Arg, ksize_Arg, strides_Arg>
where T: TensorType,
      T: Clone,
      input_Arg: Clone,
      input_Arg: GraphEdge<T>,
      input_Arg: 'static,
      ksize_Arg: Clone,
      ksize_Arg: GraphEdge<i32>,
      ksize_Arg: 'static,
      strides_Arg: Clone,
      strides_Arg: GraphEdge<i32>,
      strides_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_QINT8_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF,
      T: 'static,
{
    pub fn output(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn data_format(&mut self, data_format: &str) -> Self {
        self.data_format = Some(data_format.to_string());
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(input: input_Arg, ksize: ksize_Arg, strides: strides_Arg, padding: &str) -> Self {
        Self {
            phantom_T: PhantomData,
            input,
            ksize,
            strides,
            padding: padding.to_string(),
            data_format: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(input: input_Arg, ksize: ksize_Arg, strides: strides_Arg, padding: &str) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            input,
            ksize,
            strides,
            padding: padding.to_string(),
            data_format: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<true_classes_Arg> GraphOperation for ThreadUnsafeUnigramCandidateSampler<true_classes_Arg>
where true_classes_Arg: Clone,
      true_classes_Arg: GraphEdge<i64>,
      true_classes_Arg: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("ThreadUnsafeUnigramCandidateSampler_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("ThreadUnsafeUnigramCandidateSampler", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.true_classes)?
        }
        {
            (|attr: &i64| {new_op.set_attr_int("num_true", *attr)})(&self.num_true)?
        }
        {
            (|attr: &i64| {new_op.set_attr_int("num_sampled", *attr)})(&self.num_sampled)?
        }
        {
            (|attr: &bool| {new_op.set_attr_bool("unique", *attr)})(&self.unique)?
        }
        {
            (|attr: &i64| {new_op.set_attr_int("range_max", *attr)})(&self.range_max)?
        }
        {
            match self.seed {
                None => new_op.set_attr_value_proto("seed", &vec![24_u8, 0_u8,])?,
                Some(ref value) => (|attr: &i64| {new_op.set_attr_int("seed", *attr)})(&value)?,
            };
        }
        {
            match self.seed2 {
                None => new_op.set_attr_value_proto("seed2", &vec![24_u8, 0_u8,])?,
                Some(ref value) => (|attr: &i64| {new_op.set_attr_int("seed2", *attr)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct ThreadUnsafeUnigramCandidateSampler<true_classes_Arg>
where true_classes_Arg: Clone,
      true_classes_Arg: GraphEdge<i64>,
      true_classes_Arg: 'static,
{
    true_classes: true_classes_Arg,
    num_true: i64,
    num_sampled: i64,
    unique: bool,
    range_max: i64,
    seed: Option<i64>,
    seed2: Option<i64>,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<true_classes_Arg> ThreadUnsafeUnigramCandidateSampler<true_classes_Arg>
where true_classes_Arg: Clone,
      true_classes_Arg: GraphEdge<i64>,
      true_classes_Arg: 'static,
{
    pub fn sampled_candidates(self) -> Edge<i64> {
        let rc = Rc::new(self);
        {
            Edge::<i64>::new(rc.clone(), 0)
        }
    }

    pub fn true_expected_count(self) -> Edge<f32> {
        let rc = Rc::new(self);
        {
            Edge::<f32>::new(rc.clone(), 1)
        }
    }

    pub fn sampled_expected_count(self) -> Edge<f32> {
        let rc = Rc::new(self);
        {
            Edge::<f32>::new(rc.clone(), 2)
        }
    }

    pub fn seed(&mut self, seed: i64) -> Self {
        self.seed = Some(seed);
        self.clone()
    }

    pub fn seed2(&mut self, seed2: i64) -> Self {
        self.seed2 = Some(seed2);
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> (Edge<i64>, Edge<f32>, Edge<f32>) {
        let rc = Rc::new(self);
        (
        {
            Edge::<i64>::new(rc.clone(), 0)
        },
        {
            Edge::<f32>::new(rc.clone(), 1)
        },
        {
            Edge::<f32>::new(rc.clone(), 2)
        },
        )
    }

    pub fn build(true_classes: true_classes_Arg, num_true: i64, num_sampled: i64, unique: bool, range_max: i64) -> Self {
        Self {
            true_classes,
            num_true: num_true,
            num_sampled: num_sampled,
            unique: unique,
            range_max: range_max,
            seed: None,
            seed2: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(true_classes: true_classes_Arg, num_true: i64, num_sampled: i64, unique: bool, range_max: i64) -> (Edge<i64>, Edge<f32>, Edge<f32>) {
        Self {
            true_classes,
            num_true: num_true,
            num_sampled: num_sampled,
            unique: unique,
            range_max: range_max,
            seed: None,
            seed2: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<handle_Arg> GraphOperation for QueueIsClosed<handle_Arg>
where handle_Arg: Clone,
      handle_Arg: GraphRefEdge<String>,
      handle_Arg: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("QueueIsClosed_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("QueueIsClosed", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.handle)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct QueueIsClosed<handle_Arg>
where handle_Arg: Clone,
      handle_Arg: GraphRefEdge<String>,
      handle_Arg: 'static,
{
    handle: handle_Arg,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<handle_Arg> QueueIsClosed<handle_Arg>
where handle_Arg: Clone,
      handle_Arg: GraphRefEdge<String>,
      handle_Arg: 'static,
{
    pub fn is_closed(self) -> Edge<bool> {
        let rc = Rc::new(self);
        {
            Edge::<bool>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<bool> {
        let rc = Rc::new(self);
        {
            Edge::<bool>::new(rc.clone(), 0)
        }
    }

    pub fn build(handle: handle_Arg) -> Self {
        Self {
            handle,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(handle: handle_Arg) -> Edge<bool> {
        Self {
            handle,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<component_types> GraphOperation for FIFOQueue<component_types>
where component_types: TensorType,
      component_types: 'static,
      component_types: Clone,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("FIFOQueue_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("FIFOQueue", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.set_attr_type("component_types", component_types::data_type())?;
        }
        {
            match self.shapes {
                None => new_op.set_attr_value_proto("shapes", &vec![10_u8, 0_u8,])?,
                Some(ref value) => (|attrs| {new_op.set_attr_shape_list("shapes", attrs)})(&value)?,
            };
        }
        {
            match self.capacity {
                None => new_op.set_attr_value_proto("capacity", &vec![24_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 1_u8,])?,
                Some(ref value) => (|attr: &i64| {new_op.set_attr_int("capacity", *attr)})(&value)?,
            };
        }
        {
            match self.container {
                None => new_op.set_attr_value_proto("container", &vec![18_u8, 0_u8,])?,
                Some(ref value) => (|attr| {new_op.set_attr_string("container", attr)})(&value)?,
            };
        }
        {
            match self.shared_name {
                None => new_op.set_attr_value_proto("shared_name", &vec![18_u8, 0_u8,])?,
                Some(ref value) => (|attr| {new_op.set_attr_string("shared_name", attr)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct FIFOQueue<component_types>
where component_types: TensorType,
      component_types: 'static,
      component_types: Clone,
{
    phantom_component_types: PhantomData<component_types>,
    shapes: Option<Vec<OtherShape>>,
    capacity: Option<i64>,
    container: Option<String>,
    shared_name: Option<String>,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<component_types> FIFOQueue<component_types>
where component_types: TensorType,
      component_types: 'static,
      component_types: Clone,
{
    pub fn handle(self) -> RefEdge<String> {
        let rc = Rc::new(self);
        {
            RefEdge::<String>::new(rc.clone(), 0)
        }
    }

    pub fn shapes(&mut self, shapes: &[OtherShape]) -> Self {
        self.shapes = Some(shapes.to_vec());
        self.clone()
    }

    pub fn capacity(&mut self, capacity: i64) -> Self {
        self.capacity = Some(capacity);
        self.clone()
    }

    pub fn container(&mut self, container: &str) -> Self {
        self.container = Some(container.to_string());
        self.clone()
    }

    pub fn shared_name(&mut self, shared_name: &str) -> Self {
        self.shared_name = Some(shared_name.to_string());
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> RefEdge<String> {
        let rc = Rc::new(self);
        {
            RefEdge::<String>::new(rc.clone(), 0)
        }
    }

    pub fn build() -> Self {
        Self {
            phantom_component_types: PhantomData,
            shapes: None,
            capacity: None,
            container: None,
            shared_name: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new() -> RefEdge<String> {
        Self {
            phantom_component_types: PhantomData,
            shapes: None,
            capacity: None,
            container: None,
            shared_name: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<T, inputs_Arg> GraphOperation for TPUReplicatedInput<T, inputs_Arg>
where T: TensorType,
      T: Clone,
      inputs_Arg: Clone,
      inputs_Arg: GraphEdge<T>,
      inputs_Arg: 'static,
      T: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("TPUReplicatedInput_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("TPUReplicatedInput", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.inputs)?
        }
        {
            (|attr: &i64| {new_op.set_attr_int("N", *attr)})(&self.N)?
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct TPUReplicatedInput<T, inputs_Arg>
where T: TensorType,
      T: Clone,
      inputs_Arg: Clone,
      inputs_Arg: GraphEdge<T>,
      inputs_Arg: 'static,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    inputs: inputs_Arg,
    N: i64,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<T, inputs_Arg> TPUReplicatedInput<T, inputs_Arg>
where T: TensorType,
      T: Clone,
      inputs_Arg: Clone,
      inputs_Arg: GraphEdge<T>,
      inputs_Arg: 'static,
      T: 'static,
{
    pub fn output(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(inputs: inputs_Arg, N: i64) -> Self {
        Self {
            phantom_T: PhantomData,
            inputs,
            N: N,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(inputs: inputs_Arg, N: i64) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            inputs,
            N: N,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<T, input_Arg> GraphOperation for SpaceToDepth<T, input_Arg>
where T: TensorType,
      T: Clone,
      input_Arg: Clone,
      input_Arg: GraphEdge<T>,
      input_Arg: 'static,
      T: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("SpaceToDepth_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("SpaceToDepth", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.input)?
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        {
            (|attr: &i64| {new_op.set_attr_int("block_size", *attr)})(&self.block_size)?
        }
        {
            match self.data_format {
                None => new_op.set_attr_value_proto("data_format", &vec![18_u8, 4_u8, 78_u8, 72_u8, 87_u8, 67_u8,])?,
                Some(ref value) => (|attr| {new_op.set_attr_string("data_format", attr)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct SpaceToDepth<T, input_Arg>
where T: TensorType,
      T: Clone,
      input_Arg: Clone,
      input_Arg: GraphEdge<T>,
      input_Arg: 'static,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    input: input_Arg,
    block_size: i64,
    data_format: Option<String>,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<T, input_Arg> SpaceToDepth<T, input_Arg>
where T: TensorType,
      T: Clone,
      input_Arg: Clone,
      input_Arg: GraphEdge<T>,
      input_Arg: 'static,
      T: 'static,
{
    pub fn output(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn data_format(&mut self, data_format: &str) -> Self {
        self.data_format = Some(data_format.to_string());
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(input: input_Arg, block_size: i64) -> Self {
        Self {
            phantom_T: PhantomData,
            input,
            block_size: block_size,
            data_format: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(input: input_Arg, block_size: i64) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            input,
            block_size: block_size,
            data_format: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<true_classes_Arg> GraphOperation for LogUniformCandidateSampler<true_classes_Arg>
where true_classes_Arg: Clone,
      true_classes_Arg: GraphEdge<i64>,
      true_classes_Arg: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("LogUniformCandidateSampler_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("LogUniformCandidateSampler", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.true_classes)?
        }
        {
            (|attr: &i64| {new_op.set_attr_int("num_true", *attr)})(&self.num_true)?
        }
        {
            (|attr: &i64| {new_op.set_attr_int("num_sampled", *attr)})(&self.num_sampled)?
        }
        {
            (|attr: &bool| {new_op.set_attr_bool("unique", *attr)})(&self.unique)?
        }
        {
            (|attr: &i64| {new_op.set_attr_int("range_max", *attr)})(&self.range_max)?
        }
        {
            match self.seed {
                None => new_op.set_attr_value_proto("seed", &vec![24_u8, 0_u8,])?,
                Some(ref value) => (|attr: &i64| {new_op.set_attr_int("seed", *attr)})(&value)?,
            };
        }
        {
            match self.seed2 {
                None => new_op.set_attr_value_proto("seed2", &vec![24_u8, 0_u8,])?,
                Some(ref value) => (|attr: &i64| {new_op.set_attr_int("seed2", *attr)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct LogUniformCandidateSampler<true_classes_Arg>
where true_classes_Arg: Clone,
      true_classes_Arg: GraphEdge<i64>,
      true_classes_Arg: 'static,
{
    true_classes: true_classes_Arg,
    num_true: i64,
    num_sampled: i64,
    unique: bool,
    range_max: i64,
    seed: Option<i64>,
    seed2: Option<i64>,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<true_classes_Arg> LogUniformCandidateSampler<true_classes_Arg>
where true_classes_Arg: Clone,
      true_classes_Arg: GraphEdge<i64>,
      true_classes_Arg: 'static,
{
    pub fn sampled_candidates(self) -> Edge<i64> {
        let rc = Rc::new(self);
        {
            Edge::<i64>::new(rc.clone(), 0)
        }
    }

    pub fn true_expected_count(self) -> Edge<f32> {
        let rc = Rc::new(self);
        {
            Edge::<f32>::new(rc.clone(), 1)
        }
    }

    pub fn sampled_expected_count(self) -> Edge<f32> {
        let rc = Rc::new(self);
        {
            Edge::<f32>::new(rc.clone(), 2)
        }
    }

    pub fn seed(&mut self, seed: i64) -> Self {
        self.seed = Some(seed);
        self.clone()
    }

    pub fn seed2(&mut self, seed2: i64) -> Self {
        self.seed2 = Some(seed2);
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> (Edge<i64>, Edge<f32>, Edge<f32>) {
        let rc = Rc::new(self);
        (
        {
            Edge::<i64>::new(rc.clone(), 0)
        },
        {
            Edge::<f32>::new(rc.clone(), 1)
        },
        {
            Edge::<f32>::new(rc.clone(), 2)
        },
        )
    }

    pub fn build(true_classes: true_classes_Arg, num_true: i64, num_sampled: i64, unique: bool, range_max: i64) -> Self {
        Self {
            true_classes,
            num_true: num_true,
            num_sampled: num_sampled,
            unique: unique,
            range_max: range_max,
            seed: None,
            seed2: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(true_classes: true_classes_Arg, num_true: i64, num_sampled: i64, unique: bool, range_max: i64) -> (Edge<i64>, Edge<f32>, Edge<f32>) {
        Self {
            true_classes,
            num_true: num_true,
            num_sampled: num_sampled,
            unique: unique,
            range_max: range_max,
            seed: None,
            seed2: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<S, shape_Arg, dtype, rate_Arg> GraphOperation for RandomPoisson<S, shape_Arg, dtype, rate_Arg>
where S: TensorType,
      S: Clone,
      shape_Arg: Clone,
      shape_Arg: GraphEdge<S>,
      shape_Arg: 'static,
      dtype: TensorType,
      dtype: Clone,
      rate_Arg: Clone,
      rate_Arg: GraphEdge<dtype>,
      rate_Arg: 'static,
      S: con_or_DT_INT32_or_DT_INT64,
      S: 'static,
      dtype: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_HALF,
      dtype: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("RandomPoisson_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("RandomPoisson", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.shape)?
        }
        {
            new_op.add_edge(&self.rate)?
        }
        {
            match self.seed {
                None => new_op.set_attr_value_proto("seed", &vec![24_u8, 0_u8,])?,
                Some(ref value) => (|attr: &i64| {new_op.set_attr_int("seed", *attr)})(&value)?,
            };
        }
        {
            match self.seed2 {
                None => new_op.set_attr_value_proto("seed2", &vec![24_u8, 0_u8,])?,
                Some(ref value) => (|attr: &i64| {new_op.set_attr_int("seed2", *attr)})(&value)?,
            };
        }
        {
            new_op.set_attr_type("S", S::data_type())?;
        }
        {
            new_op.set_attr_type("dtype", dtype::data_type())?;
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct RandomPoisson<S, shape_Arg, dtype, rate_Arg>
where S: TensorType,
      S: Clone,
      shape_Arg: Clone,
      shape_Arg: GraphEdge<S>,
      shape_Arg: 'static,
      dtype: TensorType,
      dtype: Clone,
      rate_Arg: Clone,
      rate_Arg: GraphEdge<dtype>,
      rate_Arg: 'static,
      S: con_or_DT_INT32_or_DT_INT64,
      S: 'static,
      dtype: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_HALF,
      dtype: 'static,
{
    phantom_S: PhantomData<S>,
    shape: shape_Arg,
    phantom_dtype: PhantomData<dtype>,
    rate: rate_Arg,
    seed: Option<i64>,
    seed2: Option<i64>,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<S, shape_Arg, dtype, rate_Arg> RandomPoisson<S, shape_Arg, dtype, rate_Arg>
where S: TensorType,
      S: Clone,
      shape_Arg: Clone,
      shape_Arg: GraphEdge<S>,
      shape_Arg: 'static,
      dtype: TensorType,
      dtype: Clone,
      rate_Arg: Clone,
      rate_Arg: GraphEdge<dtype>,
      rate_Arg: 'static,
      S: con_or_DT_INT32_or_DT_INT64,
      S: 'static,
      dtype: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_HALF,
      dtype: 'static,
{
    pub fn output(self) -> Edge<dtype> {
        let rc = Rc::new(self);
        {
            Edge::<dtype>::new(rc.clone(), 0)
        }
    }

    pub fn seed(&mut self, seed: i64) -> Self {
        self.seed = Some(seed);
        self.clone()
    }

    pub fn seed2(&mut self, seed2: i64) -> Self {
        self.seed2 = Some(seed2);
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<dtype> {
        let rc = Rc::new(self);
        {
            Edge::<dtype>::new(rc.clone(), 0)
        }
    }

    pub fn build(shape: shape_Arg, rate: rate_Arg) -> Self {
        Self {
            phantom_S: PhantomData,
            shape,
            phantom_dtype: PhantomData,
            rate,
            seed: None,
            seed2: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(shape: shape_Arg, rate: rate_Arg) -> Edge<dtype> {
        Self {
            phantom_S: PhantomData,
            shape,
            phantom_dtype: PhantomData,
            rate,
            seed: None,
            seed2: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<Tinput, features_Arg, max_value_Arg, min_features_Arg, max_features_Arg, out_type> GraphOperation for QuantizedReluX<Tinput, features_Arg, max_value_Arg, min_features_Arg, max_features_Arg, out_type>
where Tinput: TensorType,
      Tinput: Clone,
      features_Arg: Clone,
      features_Arg: GraphEdge<Tinput>,
      features_Arg: 'static,
      max_value_Arg: Clone,
      max_value_Arg: GraphEdge<f32>,
      max_value_Arg: 'static,
      min_features_Arg: Clone,
      min_features_Arg: GraphEdge<f32>,
      min_features_Arg: 'static,
      max_features_Arg: Clone,
      max_features_Arg: GraphEdge<f32>,
      max_features_Arg: 'static,
      out_type: TensorType,
      Tinput: con_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_QINT16_or_DT_QUINT16,
      Tinput: 'static,
      out_type: con_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_QINT16_or_DT_QUINT16,
      out_type: 'static,
      out_type: Clone,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("QuantizedReluX_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("QuantizedReluX", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.features)?
        }
        {
            new_op.add_edge(&self.max_value)?
        }
        {
            new_op.add_edge(&self.min_features)?
        }
        {
            new_op.add_edge(&self.max_features)?
        }
        {
            new_op.set_attr_type("Tinput", Tinput::data_type())?;
        }
        {
            new_op.set_attr_type("out_type", out_type::data_type())?;
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct QuantizedReluX<Tinput, features_Arg, max_value_Arg, min_features_Arg, max_features_Arg, out_type>
where Tinput: TensorType,
      Tinput: Clone,
      features_Arg: Clone,
      features_Arg: GraphEdge<Tinput>,
      features_Arg: 'static,
      max_value_Arg: Clone,
      max_value_Arg: GraphEdge<f32>,
      max_value_Arg: 'static,
      min_features_Arg: Clone,
      min_features_Arg: GraphEdge<f32>,
      min_features_Arg: 'static,
      max_features_Arg: Clone,
      max_features_Arg: GraphEdge<f32>,
      max_features_Arg: 'static,
      out_type: TensorType,
      Tinput: con_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_QINT16_or_DT_QUINT16,
      Tinput: 'static,
      out_type: con_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_QINT16_or_DT_QUINT16,
      out_type: 'static,
      out_type: Clone,
{
    phantom_Tinput: PhantomData<Tinput>,
    features: features_Arg,
    max_value: max_value_Arg,
    min_features: min_features_Arg,
    max_features: max_features_Arg,
    phantom_out_type: PhantomData<out_type>,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<Tinput, features_Arg, max_value_Arg, min_features_Arg, max_features_Arg, out_type> QuantizedReluX<Tinput, features_Arg, max_value_Arg, min_features_Arg, max_features_Arg, out_type>
where Tinput: TensorType,
      Tinput: Clone,
      features_Arg: Clone,
      features_Arg: GraphEdge<Tinput>,
      features_Arg: 'static,
      max_value_Arg: Clone,
      max_value_Arg: GraphEdge<f32>,
      max_value_Arg: 'static,
      min_features_Arg: Clone,
      min_features_Arg: GraphEdge<f32>,
      min_features_Arg: 'static,
      max_features_Arg: Clone,
      max_features_Arg: GraphEdge<f32>,
      max_features_Arg: 'static,
      out_type: TensorType,
      Tinput: con_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_QINT16_or_DT_QUINT16,
      Tinput: 'static,
      out_type: con_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_QINT16_or_DT_QUINT16,
      out_type: 'static,
      out_type: Clone,
{
    pub fn activations(self) -> Edge<out_type> {
        let rc = Rc::new(self);
        {
            Edge::<out_type>::new(rc.clone(), 0)
        }
    }

    pub fn min_activations(self) -> Edge<f32> {
        let rc = Rc::new(self);
        {
            Edge::<f32>::new(rc.clone(), 1)
        }
    }

    pub fn max_activations(self) -> Edge<f32> {
        let rc = Rc::new(self);
        {
            Edge::<f32>::new(rc.clone(), 2)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> (Edge<out_type>, Edge<f32>, Edge<f32>) {
        let rc = Rc::new(self);
        (
        {
            Edge::<out_type>::new(rc.clone(), 0)
        },
        {
            Edge::<f32>::new(rc.clone(), 1)
        },
        {
            Edge::<f32>::new(rc.clone(), 2)
        },
        )
    }

    pub fn build(features: features_Arg, max_value: max_value_Arg, min_features: min_features_Arg, max_features: max_features_Arg) -> Self {
        Self {
            phantom_Tinput: PhantomData,
            features,
            max_value,
            min_features,
            max_features,
            phantom_out_type: PhantomData,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(features: features_Arg, max_value: max_value_Arg, min_features: min_features_Arg, max_features: max_features_Arg) -> (Edge<out_type>, Edge<f32>, Edge<f32>) {
        Self {
            phantom_Tinput: PhantomData,
            features,
            max_value,
            min_features,
            max_features,
            phantom_out_type: PhantomData,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<T, x_Arg, y_Arg> GraphOperation for Less<T, x_Arg, y_Arg>
where T: TensorType,
      T: Clone,
      x_Arg: Clone,
      x_Arg: GraphEdge<T>,
      x_Arg: 'static,
      y_Arg: Clone,
      y_Arg: GraphEdge<T>,
      y_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("Less_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("Less", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.x)?
        }
        {
            new_op.add_edge(&self.y)?
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct Less<T, x_Arg, y_Arg>
where T: TensorType,
      T: Clone,
      x_Arg: Clone,
      x_Arg: GraphEdge<T>,
      x_Arg: 'static,
      y_Arg: Clone,
      y_Arg: GraphEdge<T>,
      y_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    x: x_Arg,
    y: y_Arg,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<T, x_Arg, y_Arg> Less<T, x_Arg, y_Arg>
where T: TensorType,
      T: Clone,
      x_Arg: Clone,
      x_Arg: GraphEdge<T>,
      x_Arg: 'static,
      y_Arg: Clone,
      y_Arg: GraphEdge<T>,
      y_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
{
    pub fn z(self) -> Edge<bool> {
        let rc = Rc::new(self);
        {
            Edge::<bool>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<bool> {
        let rc = Rc::new(self);
        {
            Edge::<bool>::new(rc.clone(), 0)
        }
    }

    pub fn build(x: x_Arg, y: y_Arg) -> Self {
        Self {
            phantom_T: PhantomData,
            x,
            y,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(x: x_Arg, y: y_Arg) -> Edge<bool> {
        Self {
            phantom_T: PhantomData,
            x,
            y,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<dtype, input_Arg> GraphOperation for OutfeedEnqueue<dtype, input_Arg>
where dtype: TensorType,
      dtype: Clone,
      input_Arg: Clone,
      input_Arg: GraphEdge<dtype>,
      input_Arg: 'static,
      dtype: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("OutfeedEnqueue_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("OutfeedEnqueue", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.input)?
        }
        {
            new_op.set_attr_type("dtype", dtype::data_type())?;
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct OutfeedEnqueue<dtype, input_Arg>
where dtype: TensorType,
      dtype: Clone,
      input_Arg: Clone,
      input_Arg: GraphEdge<dtype>,
      input_Arg: 'static,
      dtype: 'static,
{
    phantom_dtype: PhantomData<dtype>,
    input: input_Arg,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<dtype, input_Arg> OutfeedEnqueue<dtype, input_Arg>
where dtype: TensorType,
      dtype: Clone,
      input_Arg: Clone,
      input_Arg: GraphEdge<dtype>,
      input_Arg: 'static,
      dtype: 'static,
{
    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> () {
        let rc = Rc::new(self);
        (
        )
    }

    pub fn build(input: input_Arg) -> Self {
        Self {
            phantom_dtype: PhantomData,
            input,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(input: input_Arg) -> () {
        Self {
            phantom_dtype: PhantomData,
            input,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<tag_Arg, T, values_Arg> GraphOperation for HistogramSummary<tag_Arg, T, values_Arg>
where tag_Arg: Clone,
      tag_Arg: GraphEdge<String>,
      tag_Arg: 'static,
      T: TensorType,
      T: Clone,
      values_Arg: Clone,
      values_Arg: GraphEdge<T>,
      values_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("HistogramSummary_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("HistogramSummary", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.tag)?
        }
        {
            new_op.add_edge(&self.values)?
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct HistogramSummary<tag_Arg, T, values_Arg>
where tag_Arg: Clone,
      tag_Arg: GraphEdge<String>,
      tag_Arg: 'static,
      T: TensorType,
      T: Clone,
      values_Arg: Clone,
      values_Arg: GraphEdge<T>,
      values_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
{
    tag: tag_Arg,
    phantom_T: PhantomData<T>,
    values: values_Arg,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<tag_Arg, T, values_Arg> HistogramSummary<tag_Arg, T, values_Arg>
where tag_Arg: Clone,
      tag_Arg: GraphEdge<String>,
      tag_Arg: 'static,
      T: TensorType,
      T: Clone,
      values_Arg: Clone,
      values_Arg: GraphEdge<T>,
      values_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
{
    pub fn summary(self) -> Edge<String> {
        let rc = Rc::new(self);
        {
            Edge::<String>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<String> {
        let rc = Rc::new(self);
        {
            Edge::<String>::new(rc.clone(), 0)
        }
    }

    pub fn build(tag: tag_Arg, values: values_Arg) -> Self {
        Self {
            tag,
            phantom_T: PhantomData,
            values,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(tag: tag_Arg, values: values_Arg) -> Edge<String> {
        Self {
            tag,
            phantom_T: PhantomData,
            values,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl GraphOperation for _ShutdownDistributedTPU {
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("_ShutdownDistributedTPU_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("_ShutdownDistributedTPU", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct _ShutdownDistributedTPU {
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl _ShutdownDistributedTPU {
    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> () {
        let rc = Rc::new(self);
        (
        )
    }

    pub fn build() -> Self {
        Self {
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new() -> () {
        Self {
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<handle_Arg, index_Arg, T, value_Arg, flow_in_Arg> GraphOperation for TensorArrayWriteV2<handle_Arg, index_Arg, T, value_Arg, flow_in_Arg>
where handle_Arg: Clone,
      handle_Arg: GraphEdge<String>,
      handle_Arg: 'static,
      index_Arg: Clone,
      index_Arg: GraphEdge<i32>,
      index_Arg: 'static,
      T: TensorType,
      T: Clone,
      value_Arg: Clone,
      value_Arg: GraphEdge<T>,
      value_Arg: 'static,
      flow_in_Arg: Clone,
      flow_in_Arg: GraphEdge<f32>,
      flow_in_Arg: 'static,
      T: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("TensorArrayWriteV2_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("TensorArrayWriteV2", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.handle)?
        }
        {
            new_op.add_edge(&self.index)?
        }
        {
            new_op.add_edge(&self.value)?
        }
        {
            new_op.add_edge(&self.flow_in)?
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct TensorArrayWriteV2<handle_Arg, index_Arg, T, value_Arg, flow_in_Arg>
where handle_Arg: Clone,
      handle_Arg: GraphEdge<String>,
      handle_Arg: 'static,
      index_Arg: Clone,
      index_Arg: GraphEdge<i32>,
      index_Arg: 'static,
      T: TensorType,
      T: Clone,
      value_Arg: Clone,
      value_Arg: GraphEdge<T>,
      value_Arg: 'static,
      flow_in_Arg: Clone,
      flow_in_Arg: GraphEdge<f32>,
      flow_in_Arg: 'static,
      T: 'static,
{
    handle: handle_Arg,
    index: index_Arg,
    phantom_T: PhantomData<T>,
    value: value_Arg,
    flow_in: flow_in_Arg,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<handle_Arg, index_Arg, T, value_Arg, flow_in_Arg> TensorArrayWriteV2<handle_Arg, index_Arg, T, value_Arg, flow_in_Arg>
where handle_Arg: Clone,
      handle_Arg: GraphEdge<String>,
      handle_Arg: 'static,
      index_Arg: Clone,
      index_Arg: GraphEdge<i32>,
      index_Arg: 'static,
      T: TensorType,
      T: Clone,
      value_Arg: Clone,
      value_Arg: GraphEdge<T>,
      value_Arg: 'static,
      flow_in_Arg: Clone,
      flow_in_Arg: GraphEdge<f32>,
      flow_in_Arg: 'static,
      T: 'static,
{
    pub fn flow_out(self) -> Edge<f32> {
        let rc = Rc::new(self);
        {
            Edge::<f32>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<f32> {
        let rc = Rc::new(self);
        {
            Edge::<f32>::new(rc.clone(), 0)
        }
    }

    pub fn build(handle: handle_Arg, index: index_Arg, value: value_Arg, flow_in: flow_in_Arg) -> Self {
        Self {
            handle,
            index,
            phantom_T: PhantomData,
            value,
            flow_in,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(handle: handle_Arg, index: index_Arg, value: value_Arg, flow_in: flow_in_Arg) -> Edge<f32> {
        Self {
            handle,
            index,
            phantom_T: PhantomData,
            value,
            flow_in,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<T, input_Arg, Tindices, start_indices_Arg, size_indices_Arg> GraphOperation for XlaDynamicSlice<T, input_Arg, Tindices, start_indices_Arg, size_indices_Arg>
where T: TensorType,
      T: Clone,
      input_Arg: Clone,
      input_Arg: GraphEdge<T>,
      input_Arg: 'static,
      Tindices: TensorType,
      Tindices: Clone,
      start_indices_Arg: Clone,
      start_indices_Arg: GraphEdge<Tindices>,
      start_indices_Arg: 'static,
      size_indices_Arg: Clone,
      size_indices_Arg: GraphEdge<Tindices>,
      size_indices_Arg: 'static,
      T: 'static,
      Tindices: con_or_DT_INT32_or_DT_INT64,
      Tindices: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("XlaDynamicSlice_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("XlaDynamicSlice", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.input)?
        }
        {
            new_op.add_edge(&self.start_indices)?
        }
        {
            new_op.add_edge(&self.size_indices)?
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        {
            new_op.set_attr_type("Tindices", Tindices::data_type())?;
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct XlaDynamicSlice<T, input_Arg, Tindices, start_indices_Arg, size_indices_Arg>
where T: TensorType,
      T: Clone,
      input_Arg: Clone,
      input_Arg: GraphEdge<T>,
      input_Arg: 'static,
      Tindices: TensorType,
      Tindices: Clone,
      start_indices_Arg: Clone,
      start_indices_Arg: GraphEdge<Tindices>,
      start_indices_Arg: 'static,
      size_indices_Arg: Clone,
      size_indices_Arg: GraphEdge<Tindices>,
      size_indices_Arg: 'static,
      T: 'static,
      Tindices: con_or_DT_INT32_or_DT_INT64,
      Tindices: 'static,
{
    phantom_T: PhantomData<T>,
    input: input_Arg,
    phantom_Tindices: PhantomData<Tindices>,
    start_indices: start_indices_Arg,
    size_indices: size_indices_Arg,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<T, input_Arg, Tindices, start_indices_Arg, size_indices_Arg> XlaDynamicSlice<T, input_Arg, Tindices, start_indices_Arg, size_indices_Arg>
where T: TensorType,
      T: Clone,
      input_Arg: Clone,
      input_Arg: GraphEdge<T>,
      input_Arg: 'static,
      Tindices: TensorType,
      Tindices: Clone,
      start_indices_Arg: Clone,
      start_indices_Arg: GraphEdge<Tindices>,
      start_indices_Arg: 'static,
      size_indices_Arg: Clone,
      size_indices_Arg: GraphEdge<Tindices>,
      size_indices_Arg: 'static,
      T: 'static,
      Tindices: con_or_DT_INT32_or_DT_INT64,
      Tindices: 'static,
{
    pub fn output(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(input: input_Arg, start_indices: start_indices_Arg, size_indices: size_indices_Arg) -> Self {
        Self {
            phantom_T: PhantomData,
            input,
            phantom_Tindices: PhantomData,
            start_indices,
            size_indices,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(input: input_Arg, start_indices: start_indices_Arg, size_indices: size_indices_Arg) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            input,
            phantom_Tindices: PhantomData,
            start_indices,
            size_indices,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<images_Arg, delta_Arg> GraphOperation for AdjustHue<images_Arg, delta_Arg>
where images_Arg: Clone,
      images_Arg: GraphEdge<f32>,
      images_Arg: 'static,
      delta_Arg: Clone,
      delta_Arg: GraphEdge<f32>,
      delta_Arg: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("AdjustHue_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("AdjustHue", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.images)?
        }
        {
            new_op.add_edge(&self.delta)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct AdjustHue<images_Arg, delta_Arg>
where images_Arg: Clone,
      images_Arg: GraphEdge<f32>,
      images_Arg: 'static,
      delta_Arg: Clone,
      delta_Arg: GraphEdge<f32>,
      delta_Arg: 'static,
{
    images: images_Arg,
    delta: delta_Arg,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<images_Arg, delta_Arg> AdjustHue<images_Arg, delta_Arg>
where images_Arg: Clone,
      images_Arg: GraphEdge<f32>,
      images_Arg: 'static,
      delta_Arg: Clone,
      delta_Arg: GraphEdge<f32>,
      delta_Arg: 'static,
{
    pub fn output(self) -> Edge<f32> {
        let rc = Rc::new(self);
        {
            Edge::<f32>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<f32> {
        let rc = Rc::new(self);
        {
            Edge::<f32>::new(rc.clone(), 0)
        }
    }

    pub fn build(images: images_Arg, delta: delta_Arg) -> Self {
        Self {
            images,
            delta,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(images: images_Arg, delta: delta_Arg) -> Edge<f32> {
        Self {
            images,
            delta,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<T, x_Arg, y_Arg, mkl_x_Arg, mkl_y_Arg> GraphOperation for _MklSquaredDifference<T, x_Arg, y_Arg, mkl_x_Arg, mkl_y_Arg>
where T: TensorType,
      T: Clone,
      x_Arg: Clone,
      x_Arg: GraphEdge<T>,
      x_Arg: 'static,
      y_Arg: Clone,
      y_Arg: GraphEdge<T>,
      y_Arg: 'static,
      mkl_x_Arg: Clone,
      mkl_x_Arg: GraphEdge<u8>,
      mkl_x_Arg: 'static,
      mkl_y_Arg: Clone,
      mkl_y_Arg: GraphEdge<u8>,
      mkl_y_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_COMPLEX64_or_DT_INT64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF,
      T: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("_MklSquaredDifference_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("_MklSquaredDifference", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.x)?
        }
        {
            new_op.add_edge(&self.y)?
        }
        {
            new_op.add_edge(&self.mkl_x)?
        }
        {
            new_op.add_edge(&self.mkl_y)?
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct _MklSquaredDifference<T, x_Arg, y_Arg, mkl_x_Arg, mkl_y_Arg>
where T: TensorType,
      T: Clone,
      x_Arg: Clone,
      x_Arg: GraphEdge<T>,
      x_Arg: 'static,
      y_Arg: Clone,
      y_Arg: GraphEdge<T>,
      y_Arg: 'static,
      mkl_x_Arg: Clone,
      mkl_x_Arg: GraphEdge<u8>,
      mkl_x_Arg: 'static,
      mkl_y_Arg: Clone,
      mkl_y_Arg: GraphEdge<u8>,
      mkl_y_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_COMPLEX64_or_DT_INT64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    x: x_Arg,
    y: y_Arg,
    mkl_x: mkl_x_Arg,
    mkl_y: mkl_y_Arg,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<T, x_Arg, y_Arg, mkl_x_Arg, mkl_y_Arg> _MklSquaredDifference<T, x_Arg, y_Arg, mkl_x_Arg, mkl_y_Arg>
where T: TensorType,
      T: Clone,
      x_Arg: Clone,
      x_Arg: GraphEdge<T>,
      x_Arg: 'static,
      y_Arg: Clone,
      y_Arg: GraphEdge<T>,
      y_Arg: 'static,
      mkl_x_Arg: Clone,
      mkl_x_Arg: GraphEdge<u8>,
      mkl_x_Arg: 'static,
      mkl_y_Arg: Clone,
      mkl_y_Arg: GraphEdge<u8>,
      mkl_y_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_COMPLEX64_or_DT_INT64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF,
      T: 'static,
{
    pub fn z(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn mkl_z(self) -> Edge<u8> {
        let rc = Rc::new(self);
        {
            Edge::<u8>::new(rc.clone(), 1)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> (Edge<T>, Edge<u8>) {
        let rc = Rc::new(self);
        (
        {
            Edge::<T>::new(rc.clone(), 0)
        },
        {
            Edge::<u8>::new(rc.clone(), 1)
        },
        )
    }

    pub fn build(x: x_Arg, y: y_Arg, mkl_x: mkl_x_Arg, mkl_y: mkl_y_Arg) -> Self {
        Self {
            phantom_T: PhantomData,
            x,
            y,
            mkl_x,
            mkl_y,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(x: x_Arg, y: y_Arg, mkl_x: mkl_x_Arg, mkl_y: mkl_y_Arg) -> (Edge<T>, Edge<u8>) {
        Self {
            phantom_T: PhantomData,
            x,
            y,
            mkl_x,
            mkl_y,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<component_types> GraphOperation for Barrier<component_types>
where component_types: TensorType,
      component_types: 'static,
      component_types: Clone,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("Barrier_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("Barrier", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.set_attr_type("component_types", component_types::data_type())?;
        }
        {
            match self.shapes {
                None => new_op.set_attr_value_proto("shapes", &vec![10_u8, 0_u8,])?,
                Some(ref value) => (|attrs| {new_op.set_attr_shape_list("shapes", attrs)})(&value)?,
            };
        }
        {
            match self.capacity {
                None => new_op.set_attr_value_proto("capacity", &vec![24_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 1_u8,])?,
                Some(ref value) => (|attr: &i64| {new_op.set_attr_int("capacity", *attr)})(&value)?,
            };
        }
        {
            match self.container {
                None => new_op.set_attr_value_proto("container", &vec![18_u8, 0_u8,])?,
                Some(ref value) => (|attr| {new_op.set_attr_string("container", attr)})(&value)?,
            };
        }
        {
            match self.shared_name {
                None => new_op.set_attr_value_proto("shared_name", &vec![18_u8, 0_u8,])?,
                Some(ref value) => (|attr| {new_op.set_attr_string("shared_name", attr)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct Barrier<component_types>
where component_types: TensorType,
      component_types: 'static,
      component_types: Clone,
{
    phantom_component_types: PhantomData<component_types>,
    shapes: Option<Vec<OtherShape>>,
    capacity: Option<i64>,
    container: Option<String>,
    shared_name: Option<String>,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<component_types> Barrier<component_types>
where component_types: TensorType,
      component_types: 'static,
      component_types: Clone,
{
    pub fn handle(self) -> RefEdge<String> {
        let rc = Rc::new(self);
        {
            RefEdge::<String>::new(rc.clone(), 0)
        }
    }

    pub fn shapes(&mut self, shapes: &[OtherShape]) -> Self {
        self.shapes = Some(shapes.to_vec());
        self.clone()
    }

    pub fn capacity(&mut self, capacity: i64) -> Self {
        self.capacity = Some(capacity);
        self.clone()
    }

    pub fn container(&mut self, container: &str) -> Self {
        self.container = Some(container.to_string());
        self.clone()
    }

    pub fn shared_name(&mut self, shared_name: &str) -> Self {
        self.shared_name = Some(shared_name.to_string());
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> RefEdge<String> {
        let rc = Rc::new(self);
        {
            RefEdge::<String>::new(rc.clone(), 0)
        }
    }

    pub fn build() -> Self {
        Self {
            phantom_component_types: PhantomData,
            shapes: None,
            capacity: None,
            container: None,
            shared_name: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new() -> RefEdge<String> {
        Self {
            phantom_component_types: PhantomData,
            shapes: None,
            capacity: None,
            container: None,
            shared_name: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<dtypes> GraphOperation for OrderedMapIncompleteSize<dtypes>
where dtypes: TensorType,
      dtypes: 'static,
      dtypes: Clone,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("OrderedMapIncompleteSize_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("OrderedMapIncompleteSize", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            match self.capacity {
                None => new_op.set_attr_value_proto("capacity", &vec![24_u8, 0_u8,])?,
                Some(ref value) => (|attr: &i64| {new_op.set_attr_int("capacity", *attr)})(&value)?,
            };
        }
        {
            match self.memory_limit {
                None => new_op.set_attr_value_proto("memory_limit", &vec![24_u8, 0_u8,])?,
                Some(ref value) => (|attr: &i64| {new_op.set_attr_int("memory_limit", *attr)})(&value)?,
            };
        }
        {
            new_op.set_attr_type("dtypes", dtypes::data_type())?;
        }
        {
            match self.container {
                None => new_op.set_attr_value_proto("container", &vec![18_u8, 0_u8,])?,
                Some(ref value) => (|attr| {new_op.set_attr_string("container", attr)})(&value)?,
            };
        }
        {
            match self.shared_name {
                None => new_op.set_attr_value_proto("shared_name", &vec![18_u8, 0_u8,])?,
                Some(ref value) => (|attr| {new_op.set_attr_string("shared_name", attr)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct OrderedMapIncompleteSize<dtypes>
where dtypes: TensorType,
      dtypes: 'static,
      dtypes: Clone,
{
    capacity: Option<i64>,
    memory_limit: Option<i64>,
    phantom_dtypes: PhantomData<dtypes>,
    container: Option<String>,
    shared_name: Option<String>,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<dtypes> OrderedMapIncompleteSize<dtypes>
where dtypes: TensorType,
      dtypes: 'static,
      dtypes: Clone,
{
    pub fn size(self) -> Edge<i32> {
        let rc = Rc::new(self);
        {
            Edge::<i32>::new(rc.clone(), 0)
        }
    }

    pub fn capacity(&mut self, capacity: i64) -> Self {
        self.capacity = Some(capacity);
        self.clone()
    }

    pub fn memory_limit(&mut self, memory_limit: i64) -> Self {
        self.memory_limit = Some(memory_limit);
        self.clone()
    }

    pub fn container(&mut self, container: &str) -> Self {
        self.container = Some(container.to_string());
        self.clone()
    }

    pub fn shared_name(&mut self, shared_name: &str) -> Self {
        self.shared_name = Some(shared_name.to_string());
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<i32> {
        let rc = Rc::new(self);
        {
            Edge::<i32>::new(rc.clone(), 0)
        }
    }

    pub fn build() -> Self {
        Self {
            capacity: None,
            memory_limit: None,
            phantom_dtypes: PhantomData,
            container: None,
            shared_name: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new() -> Edge<i32> {
        Self {
            capacity: None,
            memory_limit: None,
            phantom_dtypes: PhantomData,
            container: None,
            shared_name: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<max_cache_size_Arg, block_size_Arg, max_staleness_Arg> GraphOperation for GcsConfigureBlockCache<max_cache_size_Arg, block_size_Arg, max_staleness_Arg>
where max_cache_size_Arg: Clone,
      max_cache_size_Arg: GraphEdge<u64>,
      max_cache_size_Arg: 'static,
      block_size_Arg: Clone,
      block_size_Arg: GraphEdge<u64>,
      block_size_Arg: 'static,
      max_staleness_Arg: Clone,
      max_staleness_Arg: GraphEdge<u64>,
      max_staleness_Arg: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("GcsConfigureBlockCache_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("GcsConfigureBlockCache", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.max_cache_size)?
        }
        {
            new_op.add_edge(&self.block_size)?
        }
        {
            new_op.add_edge(&self.max_staleness)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct GcsConfigureBlockCache<max_cache_size_Arg, block_size_Arg, max_staleness_Arg>
where max_cache_size_Arg: Clone,
      max_cache_size_Arg: GraphEdge<u64>,
      max_cache_size_Arg: 'static,
      block_size_Arg: Clone,
      block_size_Arg: GraphEdge<u64>,
      block_size_Arg: 'static,
      max_staleness_Arg: Clone,
      max_staleness_Arg: GraphEdge<u64>,
      max_staleness_Arg: 'static,
{
    max_cache_size: max_cache_size_Arg,
    block_size: block_size_Arg,
    max_staleness: max_staleness_Arg,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<max_cache_size_Arg, block_size_Arg, max_staleness_Arg> GcsConfigureBlockCache<max_cache_size_Arg, block_size_Arg, max_staleness_Arg>
where max_cache_size_Arg: Clone,
      max_cache_size_Arg: GraphEdge<u64>,
      max_cache_size_Arg: 'static,
      block_size_Arg: Clone,
      block_size_Arg: GraphEdge<u64>,
      block_size_Arg: 'static,
      max_staleness_Arg: Clone,
      max_staleness_Arg: GraphEdge<u64>,
      max_staleness_Arg: 'static,
{
    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> () {
        let rc = Rc::new(self);
        (
        )
    }

    pub fn build(max_cache_size: max_cache_size_Arg, block_size: block_size_Arg, max_staleness: max_staleness_Arg) -> Self {
        Self {
            max_cache_size,
            block_size,
            max_staleness,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(max_cache_size: max_cache_size_Arg, block_size: block_size_Arg, max_staleness: max_staleness_Arg) -> () {
        Self {
            max_cache_size,
            block_size,
            max_staleness,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<dtypes> GraphOperation for OrderedMapSize<dtypes>
where dtypes: TensorType,
      dtypes: 'static,
      dtypes: Clone,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("OrderedMapSize_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("OrderedMapSize", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            match self.capacity {
                None => new_op.set_attr_value_proto("capacity", &vec![24_u8, 0_u8,])?,
                Some(ref value) => (|attr: &i64| {new_op.set_attr_int("capacity", *attr)})(&value)?,
            };
        }
        {
            match self.memory_limit {
                None => new_op.set_attr_value_proto("memory_limit", &vec![24_u8, 0_u8,])?,
                Some(ref value) => (|attr: &i64| {new_op.set_attr_int("memory_limit", *attr)})(&value)?,
            };
        }
        {
            new_op.set_attr_type("dtypes", dtypes::data_type())?;
        }
        {
            match self.container {
                None => new_op.set_attr_value_proto("container", &vec![18_u8, 0_u8,])?,
                Some(ref value) => (|attr| {new_op.set_attr_string("container", attr)})(&value)?,
            };
        }
        {
            match self.shared_name {
                None => new_op.set_attr_value_proto("shared_name", &vec![18_u8, 0_u8,])?,
                Some(ref value) => (|attr| {new_op.set_attr_string("shared_name", attr)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct OrderedMapSize<dtypes>
where dtypes: TensorType,
      dtypes: 'static,
      dtypes: Clone,
{
    capacity: Option<i64>,
    memory_limit: Option<i64>,
    phantom_dtypes: PhantomData<dtypes>,
    container: Option<String>,
    shared_name: Option<String>,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<dtypes> OrderedMapSize<dtypes>
where dtypes: TensorType,
      dtypes: 'static,
      dtypes: Clone,
{
    pub fn size(self) -> Edge<i32> {
        let rc = Rc::new(self);
        {
            Edge::<i32>::new(rc.clone(), 0)
        }
    }

    pub fn capacity(&mut self, capacity: i64) -> Self {
        self.capacity = Some(capacity);
        self.clone()
    }

    pub fn memory_limit(&mut self, memory_limit: i64) -> Self {
        self.memory_limit = Some(memory_limit);
        self.clone()
    }

    pub fn container(&mut self, container: &str) -> Self {
        self.container = Some(container.to_string());
        self.clone()
    }

    pub fn shared_name(&mut self, shared_name: &str) -> Self {
        self.shared_name = Some(shared_name.to_string());
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<i32> {
        let rc = Rc::new(self);
        {
            Edge::<i32>::new(rc.clone(), 0)
        }
    }

    pub fn build() -> Self {
        Self {
            capacity: None,
            memory_limit: None,
            phantom_dtypes: PhantomData,
            container: None,
            shared_name: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new() -> Edge<i32> {
        Self {
            capacity: None,
            memory_limit: None,
            phantom_dtypes: PhantomData,
            container: None,
            shared_name: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<contents_Arg> GraphOperation for DecodeBmp<contents_Arg>
where contents_Arg: Clone,
      contents_Arg: GraphEdge<String>,
      contents_Arg: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("DecodeBmp_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("DecodeBmp", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.contents)?
        }
        {
            match self.channels {
                None => new_op.set_attr_value_proto("channels", &vec![24_u8, 0_u8,])?,
                Some(ref value) => (|attr: &i64| {new_op.set_attr_int("channels", *attr)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct DecodeBmp<contents_Arg>
where contents_Arg: Clone,
      contents_Arg: GraphEdge<String>,
      contents_Arg: 'static,
{
    contents: contents_Arg,
    channels: Option<i64>,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<contents_Arg> DecodeBmp<contents_Arg>
where contents_Arg: Clone,
      contents_Arg: GraphEdge<String>,
      contents_Arg: 'static,
{
    pub fn image(self) -> Edge<u8> {
        let rc = Rc::new(self);
        {
            Edge::<u8>::new(rc.clone(), 0)
        }
    }

    pub fn channels(&mut self, channels: i64) -> Self {
        self.channels = Some(channels);
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<u8> {
        let rc = Rc::new(self);
        {
            Edge::<u8>::new(rc.clone(), 0)
        }
    }

    pub fn build(contents: contents_Arg) -> Self {
        Self {
            contents,
            channels: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(contents: contents_Arg) -> Edge<u8> {
        Self {
            contents,
            channels: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<contents_Arg> GraphOperation for DecodeJpeg<contents_Arg>
where contents_Arg: Clone,
      contents_Arg: GraphEdge<String>,
      contents_Arg: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("DecodeJpeg_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("DecodeJpeg", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.contents)?
        }
        {
            match self.channels {
                None => new_op.set_attr_value_proto("channels", &vec![24_u8, 0_u8,])?,
                Some(ref value) => (|attr: &i64| {new_op.set_attr_int("channels", *attr)})(&value)?,
            };
        }
        {
            match self.ratio {
                None => new_op.set_attr_value_proto("ratio", &vec![24_u8, 1_u8,])?,
                Some(ref value) => (|attr: &i64| {new_op.set_attr_int("ratio", *attr)})(&value)?,
            };
        }
        {
            match self.fancy_upscaling {
                None => new_op.set_attr_value_proto("fancy_upscaling", &vec![40_u8, 1_u8,])?,
                Some(ref value) => (|attr: &bool| {new_op.set_attr_bool("fancy_upscaling", *attr)})(&value)?,
            };
        }
        {
            match self.try_recover_truncated {
                None => new_op.set_attr_value_proto("try_recover_truncated", &vec![40_u8, 0_u8,])?,
                Some(ref value) => (|attr: &bool| {new_op.set_attr_bool("try_recover_truncated", *attr)})(&value)?,
            };
        }
        {
            match self.acceptable_fraction {
                None => new_op.set_attr_value_proto("acceptable_fraction", &vec![37_u8, 0_u8, 0_u8, 128_u8, 63_u8,])?,
                Some(ref value) => (|attr: &f32| {new_op.set_attr_float("acceptable_fraction", *attr)})(&value)?,
            };
        }
        {
            match self.dct_method {
                None => new_op.set_attr_value_proto("dct_method", &vec![18_u8, 0_u8,])?,
                Some(ref value) => (|attr| {new_op.set_attr_string("dct_method", attr)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct DecodeJpeg<contents_Arg>
where contents_Arg: Clone,
      contents_Arg: GraphEdge<String>,
      contents_Arg: 'static,
{
    contents: contents_Arg,
    channels: Option<i64>,
    ratio: Option<i64>,
    fancy_upscaling: Option<bool>,
    try_recover_truncated: Option<bool>,
    acceptable_fraction: Option<f32>,
    dct_method: Option<String>,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<contents_Arg> DecodeJpeg<contents_Arg>
where contents_Arg: Clone,
      contents_Arg: GraphEdge<String>,
      contents_Arg: 'static,
{
    pub fn image(self) -> Edge<u8> {
        let rc = Rc::new(self);
        {
            Edge::<u8>::new(rc.clone(), 0)
        }
    }

    pub fn channels(&mut self, channels: i64) -> Self {
        self.channels = Some(channels);
        self.clone()
    }

    pub fn ratio(&mut self, ratio: i64) -> Self {
        self.ratio = Some(ratio);
        self.clone()
    }

    pub fn fancy_upscaling(&mut self, fancy_upscaling: bool) -> Self {
        self.fancy_upscaling = Some(fancy_upscaling);
        self.clone()
    }

    pub fn try_recover_truncated(&mut self, try_recover_truncated: bool) -> Self {
        self.try_recover_truncated = Some(try_recover_truncated);
        self.clone()
    }

    pub fn acceptable_fraction(&mut self, acceptable_fraction: f32) -> Self {
        self.acceptable_fraction = Some(acceptable_fraction);
        self.clone()
    }

    pub fn dct_method(&mut self, dct_method: &str) -> Self {
        self.dct_method = Some(dct_method.to_string());
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<u8> {
        let rc = Rc::new(self);
        {
            Edge::<u8>::new(rc.clone(), 0)
        }
    }

    pub fn build(contents: contents_Arg) -> Self {
        Self {
            contents,
            channels: None,
            ratio: None,
            fancy_upscaling: None,
            try_recover_truncated: None,
            acceptable_fraction: None,
            dct_method: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(contents: contents_Arg) -> Edge<u8> {
        Self {
            contents,
            channels: None,
            ratio: None,
            fancy_upscaling: None,
            try_recover_truncated: None,
            acceptable_fraction: None,
            dct_method: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<node_ids_Arg, gradients_Arg, hessians_Arg, bucketized_features_list_Arg> GraphOperation for BoostedTreesMakeStatsSummary<node_ids_Arg, gradients_Arg, hessians_Arg, bucketized_features_list_Arg>
where node_ids_Arg: Clone,
      node_ids_Arg: GraphEdge<i32>,
      node_ids_Arg: 'static,
      gradients_Arg: Clone,
      gradients_Arg: GraphEdge<f32>,
      gradients_Arg: 'static,
      hessians_Arg: Clone,
      hessians_Arg: GraphEdge<f32>,
      hessians_Arg: 'static,
      bucketized_features_list_Arg: Clone,
      bucketized_features_list_Arg: GraphEdge<i32>,
      bucketized_features_list_Arg: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("BoostedTreesMakeStatsSummary_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("BoostedTreesMakeStatsSummary", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.node_ids)?
        }
        {
            new_op.add_edge(&self.gradients)?
        }
        {
            new_op.add_edge(&self.hessians)?
        }
        {
            new_op.add_edge(&self.bucketized_features_list)?
        }
        {
            (|attr: &i64| {new_op.set_attr_int("max_splits", *attr)})(&self.max_splits)?
        }
        {
            (|attr: &i64| {new_op.set_attr_int("num_buckets", *attr)})(&self.num_buckets)?
        }
        {
            (|attr: &i64| {new_op.set_attr_int("num_features", *attr)})(&self.num_features)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct BoostedTreesMakeStatsSummary<node_ids_Arg, gradients_Arg, hessians_Arg, bucketized_features_list_Arg>
where node_ids_Arg: Clone,
      node_ids_Arg: GraphEdge<i32>,
      node_ids_Arg: 'static,
      gradients_Arg: Clone,
      gradients_Arg: GraphEdge<f32>,
      gradients_Arg: 'static,
      hessians_Arg: Clone,
      hessians_Arg: GraphEdge<f32>,
      hessians_Arg: 'static,
      bucketized_features_list_Arg: Clone,
      bucketized_features_list_Arg: GraphEdge<i32>,
      bucketized_features_list_Arg: 'static,
{
    node_ids: node_ids_Arg,
    gradients: gradients_Arg,
    hessians: hessians_Arg,
    bucketized_features_list: bucketized_features_list_Arg,
    max_splits: i64,
    num_buckets: i64,
    num_features: i64,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<node_ids_Arg, gradients_Arg, hessians_Arg, bucketized_features_list_Arg> BoostedTreesMakeStatsSummary<node_ids_Arg, gradients_Arg, hessians_Arg, bucketized_features_list_Arg>
where node_ids_Arg: Clone,
      node_ids_Arg: GraphEdge<i32>,
      node_ids_Arg: 'static,
      gradients_Arg: Clone,
      gradients_Arg: GraphEdge<f32>,
      gradients_Arg: 'static,
      hessians_Arg: Clone,
      hessians_Arg: GraphEdge<f32>,
      hessians_Arg: 'static,
      bucketized_features_list_Arg: Clone,
      bucketized_features_list_Arg: GraphEdge<i32>,
      bucketized_features_list_Arg: 'static,
{
    pub fn stats_summary(self) -> Edge<f32> {
        let rc = Rc::new(self);
        {
            Edge::<f32>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<f32> {
        let rc = Rc::new(self);
        {
            Edge::<f32>::new(rc.clone(), 0)
        }
    }

    pub fn build(node_ids: node_ids_Arg, gradients: gradients_Arg, hessians: hessians_Arg, bucketized_features_list: bucketized_features_list_Arg, max_splits: i64, num_buckets: i64, num_features: i64) -> Self {
        Self {
            node_ids,
            gradients,
            hessians,
            bucketized_features_list,
            max_splits: max_splits,
            num_buckets: num_buckets,
            num_features: num_features,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(node_ids: node_ids_Arg, gradients: gradients_Arg, hessians: hessians_Arg, bucketized_features_list: bucketized_features_list_Arg, max_splits: i64, num_buckets: i64, num_features: i64) -> Edge<f32> {
        Self {
            node_ids,
            gradients,
            hessians,
            bucketized_features_list,
            max_splits: max_splits,
            num_buckets: num_buckets,
            num_features: num_features,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl GraphOperation for RetrieveTPUEmbeddingCenteredRMSPropParameters {
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("RetrieveTPUEmbeddingCenteredRMSPropParameters_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("RetrieveTPUEmbeddingCenteredRMSPropParameters", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            match self.table_id {
                None => new_op.set_attr_value_proto("table_id", &vec![24_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 1_u8,])?,
                Some(ref value) => (|attr: &i64| {new_op.set_attr_int("table_id", *attr)})(&value)?,
            };
        }
        {
            match self.table_name {
                None => new_op.set_attr_value_proto("table_name", &vec![18_u8, 0_u8,])?,
                Some(ref value) => (|attr| {new_op.set_attr_string("table_name", attr)})(&value)?,
            };
        }
        {
            (|attr: &i64| {new_op.set_attr_int("num_shards", *attr)})(&self.num_shards)?
        }
        {
            (|attr: &i64| {new_op.set_attr_int("shard_id", *attr)})(&self.shard_id)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct RetrieveTPUEmbeddingCenteredRMSPropParameters {
    table_id: Option<i64>,
    table_name: Option<String>,
    num_shards: i64,
    shard_id: i64,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl RetrieveTPUEmbeddingCenteredRMSPropParameters {
    pub fn parameters(self) -> Edge<f32> {
        let rc = Rc::new(self);
        {
            Edge::<f32>::new(rc.clone(), 0)
        }
    }

    pub fn ms(self) -> Edge<f32> {
        let rc = Rc::new(self);
        {
            Edge::<f32>::new(rc.clone(), 1)
        }
    }

    pub fn mom(self) -> Edge<f32> {
        let rc = Rc::new(self);
        {
            Edge::<f32>::new(rc.clone(), 2)
        }
    }

    pub fn mg(self) -> Edge<f32> {
        let rc = Rc::new(self);
        {
            Edge::<f32>::new(rc.clone(), 3)
        }
    }

    pub fn table_id(&mut self, table_id: i64) -> Self {
        self.table_id = Some(table_id);
        self.clone()
    }

    pub fn table_name(&mut self, table_name: &str) -> Self {
        self.table_name = Some(table_name.to_string());
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> (Edge<f32>, Edge<f32>, Edge<f32>, Edge<f32>) {
        let rc = Rc::new(self);
        (
        {
            Edge::<f32>::new(rc.clone(), 0)
        },
        {
            Edge::<f32>::new(rc.clone(), 1)
        },
        {
            Edge::<f32>::new(rc.clone(), 2)
        },
        {
            Edge::<f32>::new(rc.clone(), 3)
        },
        )
    }

    pub fn build(num_shards: i64, shard_id: i64) -> Self {
        Self {
            table_id: None,
            table_name: None,
            num_shards: num_shards,
            shard_id: shard_id,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(num_shards: i64, shard_id: i64) -> (Edge<f32>, Edge<f32>, Edge<f32>, Edge<f32>) {
        Self {
            table_id: None,
            table_name: None,
            num_shards: num_shards,
            shard_id: shard_id,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<T, x_Arg, Tout> GraphOperation for ComplexAbs<T, x_Arg, Tout>
where T: TensorType,
      T: Clone,
      x_Arg: Clone,
      x_Arg: GraphEdge<T>,
      x_Arg: 'static,
      Tout: TensorType,
      T: con_or_DT_COMPLEX64_or_DT_COMPLEX128,
      T: 'static,
      Tout: con_or_DT_FLOAT_or_DT_DOUBLE,
      Tout: 'static,
      Tout: Clone,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("ComplexAbs_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("ComplexAbs", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.x)?
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        {
            new_op.set_attr_type("Tout", Tout::data_type())?;
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct ComplexAbs<T, x_Arg, Tout>
where T: TensorType,
      T: Clone,
      x_Arg: Clone,
      x_Arg: GraphEdge<T>,
      x_Arg: 'static,
      Tout: TensorType,
      T: con_or_DT_COMPLEX64_or_DT_COMPLEX128,
      T: 'static,
      Tout: con_or_DT_FLOAT_or_DT_DOUBLE,
      Tout: 'static,
      Tout: Clone,
{
    phantom_T: PhantomData<T>,
    x: x_Arg,
    phantom_Tout: PhantomData<Tout>,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<T, x_Arg, Tout> ComplexAbs<T, x_Arg, Tout>
where T: TensorType,
      T: Clone,
      x_Arg: Clone,
      x_Arg: GraphEdge<T>,
      x_Arg: 'static,
      Tout: TensorType,
      T: con_or_DT_COMPLEX64_or_DT_COMPLEX128,
      T: 'static,
      Tout: con_or_DT_FLOAT_or_DT_DOUBLE,
      Tout: 'static,
      Tout: Clone,
{
    pub fn y(self) -> Edge<Tout> {
        let rc = Rc::new(self);
        {
            Edge::<Tout>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<Tout> {
        let rc = Rc::new(self);
        {
            Edge::<Tout>::new(rc.clone(), 0)
        }
    }

    pub fn build(x: x_Arg) -> Self {
        Self {
            phantom_T: PhantomData,
            x,
            phantom_Tout: PhantomData,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(x: x_Arg) -> Edge<Tout> {
        Self {
            phantom_T: PhantomData,
            x,
            phantom_Tout: PhantomData,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<x_Arg, y_Arg> GraphOperation for LogicalAnd<x_Arg, y_Arg>
where x_Arg: Clone,
      x_Arg: GraphEdge<bool>,
      x_Arg: 'static,
      y_Arg: Clone,
      y_Arg: GraphEdge<bool>,
      y_Arg: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("LogicalAnd_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("LogicalAnd", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.x)?
        }
        {
            new_op.add_edge(&self.y)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct LogicalAnd<x_Arg, y_Arg>
where x_Arg: Clone,
      x_Arg: GraphEdge<bool>,
      x_Arg: 'static,
      y_Arg: Clone,
      y_Arg: GraphEdge<bool>,
      y_Arg: 'static,
{
    x: x_Arg,
    y: y_Arg,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<x_Arg, y_Arg> LogicalAnd<x_Arg, y_Arg>
where x_Arg: Clone,
      x_Arg: GraphEdge<bool>,
      x_Arg: 'static,
      y_Arg: Clone,
      y_Arg: GraphEdge<bool>,
      y_Arg: 'static,
{
    pub fn z(self) -> Edge<bool> {
        let rc = Rc::new(self);
        {
            Edge::<bool>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<bool> {
        let rc = Rc::new(self);
        {
            Edge::<bool>::new(rc.clone(), 0)
        }
    }

    pub fn build(x: x_Arg, y: y_Arg) -> Self {
        Self {
            x,
            y,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(x: x_Arg, y: y_Arg) -> Edge<bool> {
        Self {
            x,
            y,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<handle_Arg> GraphOperation for DeleteSessionTensor<handle_Arg>
where handle_Arg: Clone,
      handle_Arg: GraphEdge<String>,
      handle_Arg: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("DeleteSessionTensor_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("DeleteSessionTensor", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.handle)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct DeleteSessionTensor<handle_Arg>
where handle_Arg: Clone,
      handle_Arg: GraphEdge<String>,
      handle_Arg: 'static,
{
    handle: handle_Arg,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<handle_Arg> DeleteSessionTensor<handle_Arg>
where handle_Arg: Clone,
      handle_Arg: GraphEdge<String>,
      handle_Arg: 'static,
{
    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> () {
        let rc = Rc::new(self);
        (
        )
    }

    pub fn build(handle: handle_Arg) -> Self {
        Self {
            handle,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(handle: handle_Arg) -> () {
        Self {
            handle,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

pub trait con_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_UINT16_or_DT_UINT32_or_DT_UINT64 {
}

impl con_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_UINT16_or_DT_UINT32_or_DT_UINT64 for i16 {
}

impl con_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_UINT16_or_DT_UINT32_or_DT_UINT64 for i32 {
}

impl con_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_UINT16_or_DT_UINT32_or_DT_UINT64 for i64 {
}

impl con_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_UINT16_or_DT_UINT32_or_DT_UINT64 for i8 {
}

impl con_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_UINT16_or_DT_UINT32_or_DT_UINT64 for u16 {
}

impl con_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_UINT16_or_DT_UINT32_or_DT_UINT64 for u32 {
}

impl con_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_UINT16_or_DT_UINT32_or_DT_UINT64 for u64 {
}

impl con_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_UINT16_or_DT_UINT32_or_DT_UINT64 for u8 {
}

impl<T, x_Arg, y_Arg> GraphOperation for LeftShift<T, x_Arg, y_Arg>
where T: TensorType,
      T: Clone,
      x_Arg: Clone,
      x_Arg: GraphEdge<T>,
      x_Arg: 'static,
      y_Arg: Clone,
      y_Arg: GraphEdge<T>,
      y_Arg: 'static,
      T: con_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_UINT16_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("LeftShift_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("LeftShift", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.x)?
        }
        {
            new_op.add_edge(&self.y)?
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct LeftShift<T, x_Arg, y_Arg>
where T: TensorType,
      T: Clone,
      x_Arg: Clone,
      x_Arg: GraphEdge<T>,
      x_Arg: 'static,
      y_Arg: Clone,
      y_Arg: GraphEdge<T>,
      y_Arg: 'static,
      T: con_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_UINT16_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    x: x_Arg,
    y: y_Arg,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<T, x_Arg, y_Arg> LeftShift<T, x_Arg, y_Arg>
where T: TensorType,
      T: Clone,
      x_Arg: Clone,
      x_Arg: GraphEdge<T>,
      x_Arg: 'static,
      y_Arg: Clone,
      y_Arg: GraphEdge<T>,
      y_Arg: 'static,
      T: con_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_UINT16_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
{
    pub fn z(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(x: x_Arg, y: y_Arg) -> Self {
        Self {
            phantom_T: PhantomData,
            x,
            y,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(x: x_Arg, y: y_Arg) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            x,
            y,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<T, x_Arg, y_Arg> GraphOperation for BitwiseXor<T, x_Arg, y_Arg>
where T: TensorType,
      T: Clone,
      x_Arg: Clone,
      x_Arg: GraphEdge<T>,
      x_Arg: 'static,
      y_Arg: Clone,
      y_Arg: GraphEdge<T>,
      y_Arg: 'static,
      T: con_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_UINT16_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("BitwiseXor_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("BitwiseXor", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.x)?
        }
        {
            new_op.add_edge(&self.y)?
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct BitwiseXor<T, x_Arg, y_Arg>
where T: TensorType,
      T: Clone,
      x_Arg: Clone,
      x_Arg: GraphEdge<T>,
      x_Arg: 'static,
      y_Arg: Clone,
      y_Arg: GraphEdge<T>,
      y_Arg: 'static,
      T: con_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_UINT16_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    x: x_Arg,
    y: y_Arg,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<T, x_Arg, y_Arg> BitwiseXor<T, x_Arg, y_Arg>
where T: TensorType,
      T: Clone,
      x_Arg: Clone,
      x_Arg: GraphEdge<T>,
      x_Arg: 'static,
      y_Arg: Clone,
      y_Arg: GraphEdge<T>,
      y_Arg: 'static,
      T: con_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_UINT16_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
{
    pub fn z(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(x: x_Arg, y: y_Arg) -> Self {
        Self {
            phantom_T: PhantomData,
            x,
            y,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(x: x_Arg, y: y_Arg) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            x,
            y,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<T, x_Arg> GraphOperation for PopulationCount<T, x_Arg>
where T: TensorType,
      T: Clone,
      x_Arg: Clone,
      x_Arg: GraphEdge<T>,
      x_Arg: 'static,
      T: con_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_UINT16_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("PopulationCount_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("PopulationCount", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.x)?
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct PopulationCount<T, x_Arg>
where T: TensorType,
      T: Clone,
      x_Arg: Clone,
      x_Arg: GraphEdge<T>,
      x_Arg: 'static,
      T: con_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_UINT16_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    x: x_Arg,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<T, x_Arg> PopulationCount<T, x_Arg>
where T: TensorType,
      T: Clone,
      x_Arg: Clone,
      x_Arg: GraphEdge<T>,
      x_Arg: 'static,
      T: con_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_UINT16_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
{
    pub fn y(self) -> Edge<u8> {
        let rc = Rc::new(self);
        {
            Edge::<u8>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<u8> {
        let rc = Rc::new(self);
        {
            Edge::<u8>::new(rc.clone(), 0)
        }
    }

    pub fn build(x: x_Arg) -> Self {
        Self {
            phantom_T: PhantomData,
            x,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(x: x_Arg) -> Edge<u8> {
        Self {
            phantom_T: PhantomData,
            x,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<T, data_Arg, Tindices, segment_ids_Arg> GraphOperation for SegmentMean<T, data_Arg, Tindices, segment_ids_Arg>
where T: TensorType,
      T: Clone,
      data_Arg: Clone,
      data_Arg: GraphEdge<T>,
      data_Arg: 'static,
      Tindices: TensorType,
      Tindices: Clone,
      segment_ids_Arg: Clone,
      segment_ids_Arg: GraphEdge<Tindices>,
      segment_ids_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
      Tindices: con_or_DT_INT32_or_DT_INT64,
      Tindices: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("SegmentMean_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("SegmentMean", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.data)?
        }
        {
            new_op.add_edge(&self.segment_ids)?
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        {
            new_op.set_attr_type("Tindices", Tindices::data_type())?;
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct SegmentMean<T, data_Arg, Tindices, segment_ids_Arg>
where T: TensorType,
      T: Clone,
      data_Arg: Clone,
      data_Arg: GraphEdge<T>,
      data_Arg: 'static,
      Tindices: TensorType,
      Tindices: Clone,
      segment_ids_Arg: Clone,
      segment_ids_Arg: GraphEdge<Tindices>,
      segment_ids_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
      Tindices: con_or_DT_INT32_or_DT_INT64,
      Tindices: 'static,
{
    phantom_T: PhantomData<T>,
    data: data_Arg,
    phantom_Tindices: PhantomData<Tindices>,
    segment_ids: segment_ids_Arg,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<T, data_Arg, Tindices, segment_ids_Arg> SegmentMean<T, data_Arg, Tindices, segment_ids_Arg>
where T: TensorType,
      T: Clone,
      data_Arg: Clone,
      data_Arg: GraphEdge<T>,
      data_Arg: 'static,
      Tindices: TensorType,
      Tindices: Clone,
      segment_ids_Arg: Clone,
      segment_ids_Arg: GraphEdge<Tindices>,
      segment_ids_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
      Tindices: con_or_DT_INT32_or_DT_INT64,
      Tindices: 'static,
{
    pub fn output(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(data: data_Arg, segment_ids: segment_ids_Arg) -> Self {
        Self {
            phantom_T: PhantomData,
            data,
            phantom_Tindices: PhantomData,
            segment_ids,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(data: data_Arg, segment_ids: segment_ids_Arg) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            data,
            phantom_Tindices: PhantomData,
            segment_ids,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<orig_input_shape_Arg, T, grad_Arg> GraphOperation for AvgPool3DGrad<orig_input_shape_Arg, T, grad_Arg>
where orig_input_shape_Arg: Clone,
      orig_input_shape_Arg: GraphEdge<i32>,
      orig_input_shape_Arg: 'static,
      T: TensorType,
      T: Clone,
      grad_Arg: Clone,
      grad_Arg: GraphEdge<T>,
      grad_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
      T: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("AvgPool3DGrad_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("AvgPool3DGrad", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.orig_input_shape)?
        }
        {
            new_op.add_edge(&self.grad)?
        }
        {
            (|attrs| {new_op.set_attr_int_list("ksize", attrs)})(&self.ksize)?
        }
        {
            (|attrs| {new_op.set_attr_int_list("strides", attrs)})(&self.strides)?
        }
        {
            (|attr| {new_op.set_attr_string("padding", attr)})(&self.padding)?
        }
        {
            match self.data_format {
                None => new_op.set_attr_value_proto("data_format", &vec![18_u8, 5_u8, 78_u8, 68_u8, 72_u8, 87_u8, 67_u8,])?,
                Some(ref value) => (|attr| {new_op.set_attr_string("data_format", attr)})(&value)?,
            };
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct AvgPool3DGrad<orig_input_shape_Arg, T, grad_Arg>
where orig_input_shape_Arg: Clone,
      orig_input_shape_Arg: GraphEdge<i32>,
      orig_input_shape_Arg: 'static,
      T: TensorType,
      T: Clone,
      grad_Arg: Clone,
      grad_Arg: GraphEdge<T>,
      grad_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
      T: 'static,
{
    orig_input_shape: orig_input_shape_Arg,
    phantom_T: PhantomData<T>,
    grad: grad_Arg,
    ksize: Vec<i64>,
    strides: Vec<i64>,
    padding: String,
    data_format: Option<String>,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<orig_input_shape_Arg, T, grad_Arg> AvgPool3DGrad<orig_input_shape_Arg, T, grad_Arg>
where orig_input_shape_Arg: Clone,
      orig_input_shape_Arg: GraphEdge<i32>,
      orig_input_shape_Arg: 'static,
      T: TensorType,
      T: Clone,
      grad_Arg: Clone,
      grad_Arg: GraphEdge<T>,
      grad_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
      T: 'static,
{
    pub fn output(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn data_format(&mut self, data_format: &str) -> Self {
        self.data_format = Some(data_format.to_string());
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(orig_input_shape: orig_input_shape_Arg, grad: grad_Arg, ksize: &[i64], strides: &[i64], padding: &str) -> Self {
        Self {
            orig_input_shape,
            phantom_T: PhantomData,
            grad,
            ksize: ksize.to_vec(),
            strides: strides.to_vec(),
            padding: padding.to_string(),
            data_format: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(orig_input_shape: orig_input_shape_Arg, grad: grad_Arg, ksize: &[i64], strides: &[i64], padding: &str) -> Edge<T> {
        Self {
            orig_input_shape,
            phantom_T: PhantomData,
            grad,
            ksize: ksize.to_vec(),
            strides: strides.to_vec(),
            padding: padding.to_string(),
            data_format: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<T, original_input_Arg, batch_index_Arg, grad_Arg, id_Arg> GraphOperation for UnbatchGrad<T, original_input_Arg, batch_index_Arg, grad_Arg, id_Arg>
where T: TensorType,
      T: Clone,
      original_input_Arg: Clone,
      original_input_Arg: GraphEdge<T>,
      original_input_Arg: 'static,
      batch_index_Arg: Clone,
      batch_index_Arg: GraphEdge<i64>,
      batch_index_Arg: 'static,
      grad_Arg: Clone,
      grad_Arg: GraphEdge<T>,
      grad_Arg: 'static,
      id_Arg: Clone,
      id_Arg: GraphEdge<i64>,
      id_Arg: 'static,
      T: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("UnbatchGrad_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("UnbatchGrad", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.original_input)?
        }
        {
            new_op.add_edge(&self.batch_index)?
        }
        {
            new_op.add_edge(&self.grad)?
        }
        {
            new_op.add_edge(&self.id)?
        }
        {
            match self.container {
                None => new_op.set_attr_value_proto("container", &vec![18_u8, 0_u8,])?,
                Some(ref value) => (|attr| {new_op.set_attr_string("container", attr)})(&value)?,
            };
        }
        {
            match self.shared_name {
                None => new_op.set_attr_value_proto("shared_name", &vec![18_u8, 0_u8,])?,
                Some(ref value) => (|attr| {new_op.set_attr_string("shared_name", attr)})(&value)?,
            };
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct UnbatchGrad<T, original_input_Arg, batch_index_Arg, grad_Arg, id_Arg>
where T: TensorType,
      T: Clone,
      original_input_Arg: Clone,
      original_input_Arg: GraphEdge<T>,
      original_input_Arg: 'static,
      batch_index_Arg: Clone,
      batch_index_Arg: GraphEdge<i64>,
      batch_index_Arg: 'static,
      grad_Arg: Clone,
      grad_Arg: GraphEdge<T>,
      grad_Arg: 'static,
      id_Arg: Clone,
      id_Arg: GraphEdge<i64>,
      id_Arg: 'static,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    original_input: original_input_Arg,
    batch_index: batch_index_Arg,
    grad: grad_Arg,
    id: id_Arg,
    container: Option<String>,
    shared_name: Option<String>,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<T, original_input_Arg, batch_index_Arg, grad_Arg, id_Arg> UnbatchGrad<T, original_input_Arg, batch_index_Arg, grad_Arg, id_Arg>
where T: TensorType,
      T: Clone,
      original_input_Arg: Clone,
      original_input_Arg: GraphEdge<T>,
      original_input_Arg: 'static,
      batch_index_Arg: Clone,
      batch_index_Arg: GraphEdge<i64>,
      batch_index_Arg: 'static,
      grad_Arg: Clone,
      grad_Arg: GraphEdge<T>,
      grad_Arg: 'static,
      id_Arg: Clone,
      id_Arg: GraphEdge<i64>,
      id_Arg: 'static,
      T: 'static,
{
    pub fn batched_grad(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn container(&mut self, container: &str) -> Self {
        self.container = Some(container.to_string());
        self.clone()
    }

    pub fn shared_name(&mut self, shared_name: &str) -> Self {
        self.shared_name = Some(shared_name.to_string());
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(original_input: original_input_Arg, batch_index: batch_index_Arg, grad: grad_Arg, id: id_Arg) -> Self {
        Self {
            phantom_T: PhantomData,
            original_input,
            batch_index,
            grad,
            id,
            container: None,
            shared_name: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(original_input: original_input_Arg, batch_index: batch_index_Arg, grad: grad_Arg, id: id_Arg) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            original_input,
            batch_index,
            grad,
            id,
            container: None,
            shared_name: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<T, input_Arg> GraphOperation for DebugGradientRefIdentity<T, input_Arg>
where T: TensorType,
      T: Clone,
      input_Arg: Clone,
      input_Arg: GraphRefEdge<T>,
      input_Arg: 'static,
      T: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("DebugGradientRefIdentity_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("DebugGradientRefIdentity", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.input)?
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct DebugGradientRefIdentity<T, input_Arg>
where T: TensorType,
      T: Clone,
      input_Arg: Clone,
      input_Arg: GraphRefEdge<T>,
      input_Arg: 'static,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    input: input_Arg,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<T, input_Arg> DebugGradientRefIdentity<T, input_Arg>
where T: TensorType,
      T: Clone,
      input_Arg: Clone,
      input_Arg: GraphRefEdge<T>,
      input_Arg: 'static,
      T: 'static,
{
    pub fn output(self) -> RefEdge<T> {
        let rc = Rc::new(self);
        {
            RefEdge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> RefEdge<T> {
        let rc = Rc::new(self);
        {
            RefEdge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(input: input_Arg) -> Self {
        Self {
            phantom_T: PhantomData,
            input,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(input: input_Arg) -> RefEdge<T> {
        Self {
            phantom_T: PhantomData,
            input,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<T, inputs_Arg> GraphOperation for AccumulateNV2<T, inputs_Arg>
where T: TensorType,
      T: Clone,
      inputs_Arg: Clone,
      inputs_Arg: GraphEdge<T>,
      inputs_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("AccumulateNV2_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("AccumulateNV2", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.inputs)?
        }
        {
            (|attr: &i64| {new_op.set_attr_int("N", *attr)})(&self.N)?
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        {
            (|attr| {new_op.set_attr_shape("shape", attr)})(&self.shape)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct AccumulateNV2<T, inputs_Arg>
where T: TensorType,
      T: Clone,
      inputs_Arg: Clone,
      inputs_Arg: GraphEdge<T>,
      inputs_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    inputs: inputs_Arg,
    N: i64,
    shape: OtherShape,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<T, inputs_Arg> AccumulateNV2<T, inputs_Arg>
where T: TensorType,
      T: Clone,
      inputs_Arg: Clone,
      inputs_Arg: GraphEdge<T>,
      inputs_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
{
    pub fn sum(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(inputs: inputs_Arg, N: i64, shape: &OtherShape) -> Self {
        Self {
            phantom_T: PhantomData,
            inputs,
            N: N,
            shape: shape.clone(),
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(inputs: inputs_Arg, N: i64, shape: &OtherShape) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            inputs,
            N: N,
            shape: shape.clone(),
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<T, input_Arg> GraphOperation for XlaSort<T, input_Arg>
where T: TensorType,
      T: Clone,
      input_Arg: Clone,
      input_Arg: GraphEdge<T>,
      input_Arg: 'static,
      T: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("XlaSort_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("XlaSort", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.input)?
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct XlaSort<T, input_Arg>
where T: TensorType,
      T: Clone,
      input_Arg: Clone,
      input_Arg: GraphEdge<T>,
      input_Arg: 'static,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    input: input_Arg,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<T, input_Arg> XlaSort<T, input_Arg>
where T: TensorType,
      T: Clone,
      input_Arg: Clone,
      input_Arg: GraphEdge<T>,
      input_Arg: 'static,
      T: 'static,
{
    pub fn output(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(input: input_Arg) -> Self {
        Self {
            phantom_T: PhantomData,
            input,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(input: input_Arg) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            input,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<reader_handle_Arg> GraphOperation for ReaderReset<reader_handle_Arg>
where reader_handle_Arg: Clone,
      reader_handle_Arg: GraphRefEdge<String>,
      reader_handle_Arg: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("ReaderReset_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("ReaderReset", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.reader_handle)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct ReaderReset<reader_handle_Arg>
where reader_handle_Arg: Clone,
      reader_handle_Arg: GraphRefEdge<String>,
      reader_handle_Arg: 'static,
{
    reader_handle: reader_handle_Arg,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<reader_handle_Arg> ReaderReset<reader_handle_Arg>
where reader_handle_Arg: Clone,
      reader_handle_Arg: GraphRefEdge<String>,
      reader_handle_Arg: 'static,
{
    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> () {
        let rc = Rc::new(self);
        (
        )
    }

    pub fn build(reader_handle: reader_handle_Arg) -> Self {
        Self {
            reader_handle,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(reader_handle: reader_handle_Arg) -> () {
        Self {
            reader_handle,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<inputs_Arg, sequence_length_Arg> GraphOperation for CTCBeamSearchDecoder<inputs_Arg, sequence_length_Arg>
where inputs_Arg: Clone,
      inputs_Arg: GraphEdge<f32>,
      inputs_Arg: 'static,
      sequence_length_Arg: Clone,
      sequence_length_Arg: GraphEdge<i32>,
      sequence_length_Arg: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("CTCBeamSearchDecoder_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("CTCBeamSearchDecoder", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.inputs)?
        }
        {
            new_op.add_edge(&self.sequence_length)?
        }
        {
            (|attr: &i64| {new_op.set_attr_int("beam_width", *attr)})(&self.beam_width)?
        }
        {
            (|attr: &i64| {new_op.set_attr_int("top_paths", *attr)})(&self.top_paths)?
        }
        {
            match self.merge_repeated {
                None => new_op.set_attr_value_proto("merge_repeated", &vec![40_u8, 1_u8,])?,
                Some(ref value) => (|attr: &bool| {new_op.set_attr_bool("merge_repeated", *attr)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct CTCBeamSearchDecoder<inputs_Arg, sequence_length_Arg>
where inputs_Arg: Clone,
      inputs_Arg: GraphEdge<f32>,
      inputs_Arg: 'static,
      sequence_length_Arg: Clone,
      sequence_length_Arg: GraphEdge<i32>,
      sequence_length_Arg: 'static,
{
    inputs: inputs_Arg,
    sequence_length: sequence_length_Arg,
    beam_width: i64,
    top_paths: i64,
    merge_repeated: Option<bool>,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<inputs_Arg, sequence_length_Arg> CTCBeamSearchDecoder<inputs_Arg, sequence_length_Arg>
where inputs_Arg: Clone,
      inputs_Arg: GraphEdge<f32>,
      inputs_Arg: 'static,
      sequence_length_Arg: Clone,
      sequence_length_Arg: GraphEdge<i32>,
      sequence_length_Arg: 'static,
{
    pub fn decoded_indices(self) -> Edge<i64> {
        let rc = Rc::new(self);
        {
            Edge::<i64>::new(rc.clone(), 0)
        }
    }

    pub fn decoded_values(self) -> Edge<i64> {
        let rc = Rc::new(self);
        {
            Edge::<i64>::new(rc.clone(), 1)
        }
    }

    pub fn decoded_shape(self) -> Edge<i64> {
        let rc = Rc::new(self);
        {
            Edge::<i64>::new(rc.clone(), 2)
        }
    }

    pub fn log_probability(self) -> Edge<f32> {
        let rc = Rc::new(self);
        {
            Edge::<f32>::new(rc.clone(), 3)
        }
    }

    pub fn merge_repeated(&mut self, merge_repeated: bool) -> Self {
        self.merge_repeated = Some(merge_repeated);
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> (Edge<i64>, Edge<i64>, Edge<i64>, Edge<f32>) {
        let rc = Rc::new(self);
        (
        {
            Edge::<i64>::new(rc.clone(), 0)
        },
        {
            Edge::<i64>::new(rc.clone(), 1)
        },
        {
            Edge::<i64>::new(rc.clone(), 2)
        },
        {
            Edge::<f32>::new(rc.clone(), 3)
        },
        )
    }

    pub fn build(inputs: inputs_Arg, sequence_length: sequence_length_Arg, beam_width: i64, top_paths: i64) -> Self {
        Self {
            inputs,
            sequence_length,
            beam_width: beam_width,
            top_paths: top_paths,
            merge_repeated: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(inputs: inputs_Arg, sequence_length: sequence_length_Arg, beam_width: i64, top_paths: i64) -> (Edge<i64>, Edge<i64>, Edge<i64>, Edge<f32>) {
        Self {
            inputs,
            sequence_length,
            beam_width: beam_width,
            top_paths: top_paths,
            merge_repeated: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<input_Arg> GraphOperation for AudioSpectrogram<input_Arg>
where input_Arg: Clone,
      input_Arg: GraphEdge<f32>,
      input_Arg: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("AudioSpectrogram_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("AudioSpectrogram", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.input)?
        }
        {
            (|attr: &i64| {new_op.set_attr_int("window_size", *attr)})(&self.window_size)?
        }
        {
            (|attr: &i64| {new_op.set_attr_int("stride", *attr)})(&self.stride)?
        }
        {
            match self.magnitude_squared {
                None => new_op.set_attr_value_proto("magnitude_squared", &vec![40_u8, 0_u8,])?,
                Some(ref value) => (|attr: &bool| {new_op.set_attr_bool("magnitude_squared", *attr)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct AudioSpectrogram<input_Arg>
where input_Arg: Clone,
      input_Arg: GraphEdge<f32>,
      input_Arg: 'static,
{
    input: input_Arg,
    window_size: i64,
    stride: i64,
    magnitude_squared: Option<bool>,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<input_Arg> AudioSpectrogram<input_Arg>
where input_Arg: Clone,
      input_Arg: GraphEdge<f32>,
      input_Arg: 'static,
{
    pub fn spectrogram(self) -> Edge<f32> {
        let rc = Rc::new(self);
        {
            Edge::<f32>::new(rc.clone(), 0)
        }
    }

    pub fn magnitude_squared(&mut self, magnitude_squared: bool) -> Self {
        self.magnitude_squared = Some(magnitude_squared);
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<f32> {
        let rc = Rc::new(self);
        {
            Edge::<f32>::new(rc.clone(), 0)
        }
    }

    pub fn build(input: input_Arg, window_size: i64, stride: i64) -> Self {
        Self {
            input,
            window_size: window_size,
            stride: stride,
            magnitude_squared: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(input: input_Arg, window_size: i64, stride: i64) -> Edge<f32> {
        Self {
            input,
            window_size: window_size,
            stride: stride,
            magnitude_squared: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<T, var_Arg, m_Arg, v_Arg, beta1_power_Arg, lr_Arg, beta1_Arg, beta2_Arg, epsilon_Arg, grad_Arg> GraphOperation for ApplyAdaMax<T, var_Arg, m_Arg, v_Arg, beta1_power_Arg, lr_Arg, beta1_Arg, beta2_Arg, epsilon_Arg, grad_Arg>
where T: TensorType,
      T: Clone,
      var_Arg: Clone,
      var_Arg: GraphRefEdge<T>,
      var_Arg: 'static,
      m_Arg: Clone,
      m_Arg: GraphRefEdge<T>,
      m_Arg: 'static,
      v_Arg: Clone,
      v_Arg: GraphRefEdge<T>,
      v_Arg: 'static,
      beta1_power_Arg: Clone,
      beta1_power_Arg: GraphEdge<T>,
      beta1_power_Arg: 'static,
      lr_Arg: Clone,
      lr_Arg: GraphEdge<T>,
      lr_Arg: 'static,
      beta1_Arg: Clone,
      beta1_Arg: GraphEdge<T>,
      beta1_Arg: 'static,
      beta2_Arg: Clone,
      beta2_Arg: GraphEdge<T>,
      beta2_Arg: 'static,
      epsilon_Arg: Clone,
      epsilon_Arg: GraphEdge<T>,
      epsilon_Arg: 'static,
      grad_Arg: Clone,
      grad_Arg: GraphEdge<T>,
      grad_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("ApplyAdaMax_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("ApplyAdaMax", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.var)?
        }
        {
            new_op.add_edge(&self.m)?
        }
        {
            new_op.add_edge(&self.v)?
        }
        {
            new_op.add_edge(&self.beta1_power)?
        }
        {
            new_op.add_edge(&self.lr)?
        }
        {
            new_op.add_edge(&self.beta1)?
        }
        {
            new_op.add_edge(&self.beta2)?
        }
        {
            new_op.add_edge(&self.epsilon)?
        }
        {
            new_op.add_edge(&self.grad)?
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        {
            match self.use_locking {
                None => new_op.set_attr_value_proto("use_locking", &vec![40_u8, 0_u8,])?,
                Some(ref value) => (|attr: &bool| {new_op.set_attr_bool("use_locking", *attr)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct ApplyAdaMax<T, var_Arg, m_Arg, v_Arg, beta1_power_Arg, lr_Arg, beta1_Arg, beta2_Arg, epsilon_Arg, grad_Arg>
where T: TensorType,
      T: Clone,
      var_Arg: Clone,
      var_Arg: GraphRefEdge<T>,
      var_Arg: 'static,
      m_Arg: Clone,
      m_Arg: GraphRefEdge<T>,
      m_Arg: 'static,
      v_Arg: Clone,
      v_Arg: GraphRefEdge<T>,
      v_Arg: 'static,
      beta1_power_Arg: Clone,
      beta1_power_Arg: GraphEdge<T>,
      beta1_power_Arg: 'static,
      lr_Arg: Clone,
      lr_Arg: GraphEdge<T>,
      lr_Arg: 'static,
      beta1_Arg: Clone,
      beta1_Arg: GraphEdge<T>,
      beta1_Arg: 'static,
      beta2_Arg: Clone,
      beta2_Arg: GraphEdge<T>,
      beta2_Arg: 'static,
      epsilon_Arg: Clone,
      epsilon_Arg: GraphEdge<T>,
      epsilon_Arg: 'static,
      grad_Arg: Clone,
      grad_Arg: GraphEdge<T>,
      grad_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    var: var_Arg,
    m: m_Arg,
    v: v_Arg,
    beta1_power: beta1_power_Arg,
    lr: lr_Arg,
    beta1: beta1_Arg,
    beta2: beta2_Arg,
    epsilon: epsilon_Arg,
    grad: grad_Arg,
    use_locking: Option<bool>,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<T, var_Arg, m_Arg, v_Arg, beta1_power_Arg, lr_Arg, beta1_Arg, beta2_Arg, epsilon_Arg, grad_Arg> ApplyAdaMax<T, var_Arg, m_Arg, v_Arg, beta1_power_Arg, lr_Arg, beta1_Arg, beta2_Arg, epsilon_Arg, grad_Arg>
where T: TensorType,
      T: Clone,
      var_Arg: Clone,
      var_Arg: GraphRefEdge<T>,
      var_Arg: 'static,
      m_Arg: Clone,
      m_Arg: GraphRefEdge<T>,
      m_Arg: 'static,
      v_Arg: Clone,
      v_Arg: GraphRefEdge<T>,
      v_Arg: 'static,
      beta1_power_Arg: Clone,
      beta1_power_Arg: GraphEdge<T>,
      beta1_power_Arg: 'static,
      lr_Arg: Clone,
      lr_Arg: GraphEdge<T>,
      lr_Arg: 'static,
      beta1_Arg: Clone,
      beta1_Arg: GraphEdge<T>,
      beta1_Arg: 'static,
      beta2_Arg: Clone,
      beta2_Arg: GraphEdge<T>,
      beta2_Arg: 'static,
      epsilon_Arg: Clone,
      epsilon_Arg: GraphEdge<T>,
      epsilon_Arg: 'static,
      grad_Arg: Clone,
      grad_Arg: GraphEdge<T>,
      grad_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
{
    pub fn out(self) -> RefEdge<T> {
        let rc = Rc::new(self);
        {
            RefEdge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn use_locking(&mut self, use_locking: bool) -> Self {
        self.use_locking = Some(use_locking);
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> RefEdge<T> {
        let rc = Rc::new(self);
        {
            RefEdge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(var: var_Arg, m: m_Arg, v: v_Arg, beta1_power: beta1_power_Arg, lr: lr_Arg, beta1: beta1_Arg, beta2: beta2_Arg, epsilon: epsilon_Arg, grad: grad_Arg) -> Self {
        Self {
            phantom_T: PhantomData,
            var,
            m,
            v,
            beta1_power,
            lr,
            beta1,
            beta2,
            epsilon,
            grad,
            use_locking: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(var: var_Arg, m: m_Arg, v: v_Arg, beta1_power: beta1_power_Arg, lr: lr_Arg, beta1: beta1_Arg, beta2: beta2_Arg, epsilon: epsilon_Arg, grad: grad_Arg) -> RefEdge<T> {
        Self {
            phantom_T: PhantomData,
            var,
            m,
            v,
            beta1_power,
            lr,
            beta1,
            beta2,
            epsilon,
            grad,
            use_locking: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<T, alpha_Arg, sample_Arg> GraphOperation for RandomGammaGrad<T, alpha_Arg, sample_Arg>
where T: TensorType,
      T: Clone,
      alpha_Arg: Clone,
      alpha_Arg: GraphEdge<T>,
      alpha_Arg: 'static,
      sample_Arg: Clone,
      sample_Arg: GraphEdge<T>,
      sample_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE,
      T: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("RandomGammaGrad_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("RandomGammaGrad", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.alpha)?
        }
        {
            new_op.add_edge(&self.sample)?
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct RandomGammaGrad<T, alpha_Arg, sample_Arg>
where T: TensorType,
      T: Clone,
      alpha_Arg: Clone,
      alpha_Arg: GraphEdge<T>,
      alpha_Arg: 'static,
      sample_Arg: Clone,
      sample_Arg: GraphEdge<T>,
      sample_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    alpha: alpha_Arg,
    sample: sample_Arg,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<T, alpha_Arg, sample_Arg> RandomGammaGrad<T, alpha_Arg, sample_Arg>
where T: TensorType,
      T: Clone,
      alpha_Arg: Clone,
      alpha_Arg: GraphEdge<T>,
      alpha_Arg: 'static,
      sample_Arg: Clone,
      sample_Arg: GraphEdge<T>,
      sample_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE,
      T: 'static,
{
    pub fn output(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(alpha: alpha_Arg, sample: sample_Arg) -> Self {
        Self {
            phantom_T: PhantomData,
            alpha,
            sample,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(alpha: alpha_Arg, sample: sample_Arg) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            alpha,
            sample,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

pub trait con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_STRING_or_DT_COMPLEX64_or_DT_INT64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_STRING_or_DT_COMPLEX64_or_DT_INT64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF for BFloat16 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_STRING_or_DT_COMPLEX64_or_DT_INT64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF for OtherComplex<f32> {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_STRING_or_DT_COMPLEX64_or_DT_INT64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF for OtherComplex<f64> {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_STRING_or_DT_COMPLEX64_or_DT_INT64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF for String {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_STRING_or_DT_COMPLEX64_or_DT_INT64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF for f32 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_STRING_or_DT_COMPLEX64_or_DT_INT64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF for f64 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_STRING_or_DT_COMPLEX64_or_DT_INT64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF for i16 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_STRING_or_DT_COMPLEX64_or_DT_INT64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF for i32 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_STRING_or_DT_COMPLEX64_or_DT_INT64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF for i64 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_STRING_or_DT_COMPLEX64_or_DT_INT64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF for i8 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_STRING_or_DT_COMPLEX64_or_DT_INT64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF for u8 {
}

impl<T, x_Arg, y_Arg> GraphOperation for Add<T, x_Arg, y_Arg>
where T: TensorType,
      T: Clone,
      x_Arg: Clone,
      x_Arg: GraphEdge<T>,
      x_Arg: 'static,
      y_Arg: Clone,
      y_Arg: GraphEdge<T>,
      y_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_STRING_or_DT_COMPLEX64_or_DT_INT64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF,
      T: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("Add_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("Add", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.x)?
        }
        {
            new_op.add_edge(&self.y)?
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct Add<T, x_Arg, y_Arg>
where T: TensorType,
      T: Clone,
      x_Arg: Clone,
      x_Arg: GraphEdge<T>,
      x_Arg: 'static,
      y_Arg: Clone,
      y_Arg: GraphEdge<T>,
      y_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_STRING_or_DT_COMPLEX64_or_DT_INT64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    x: x_Arg,
    y: y_Arg,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<T, x_Arg, y_Arg> Add<T, x_Arg, y_Arg>
where T: TensorType,
      T: Clone,
      x_Arg: Clone,
      x_Arg: GraphEdge<T>,
      x_Arg: 'static,
      y_Arg: Clone,
      y_Arg: GraphEdge<T>,
      y_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_STRING_or_DT_COMPLEX64_or_DT_INT64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF,
      T: 'static,
{
    pub fn z(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(x: x_Arg, y: y_Arg) -> Self {
        Self {
            phantom_T: PhantomData,
            x,
            y,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(x: x_Arg, y: y_Arg) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            x,
            y,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<T1, x_Arg, T2, y_Arg, min_x_Arg, max_x_Arg, min_y_Arg, max_y_Arg, Toutput> GraphOperation for QuantizedAdd<T1, x_Arg, T2, y_Arg, min_x_Arg, max_x_Arg, min_y_Arg, max_y_Arg, Toutput>
where T1: TensorType,
      T1: Clone,
      x_Arg: Clone,
      x_Arg: GraphEdge<T1>,
      x_Arg: 'static,
      T2: TensorType,
      T2: Clone,
      y_Arg: Clone,
      y_Arg: GraphEdge<T2>,
      y_Arg: 'static,
      min_x_Arg: Clone,
      min_x_Arg: GraphEdge<f32>,
      min_x_Arg: 'static,
      max_x_Arg: Clone,
      max_x_Arg: GraphEdge<f32>,
      max_x_Arg: 'static,
      min_y_Arg: Clone,
      min_y_Arg: GraphEdge<f32>,
      min_y_Arg: 'static,
      max_y_Arg: Clone,
      max_y_Arg: GraphEdge<f32>,
      max_y_Arg: 'static,
      Toutput: TensorType,
      T1: con_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_QINT16_or_DT_QUINT16,
      T1: 'static,
      T2: con_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_QINT16_or_DT_QUINT16,
      T2: 'static,
      Toutput: con_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_QINT16_or_DT_QUINT16,
      Toutput: 'static,
      Toutput: Clone,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("QuantizedAdd_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("QuantizedAdd", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.x)?
        }
        {
            new_op.add_edge(&self.y)?
        }
        {
            new_op.add_edge(&self.min_x)?
        }
        {
            new_op.add_edge(&self.max_x)?
        }
        {
            new_op.add_edge(&self.min_y)?
        }
        {
            new_op.add_edge(&self.max_y)?
        }
        {
            new_op.set_attr_type("T1", T1::data_type())?;
        }
        {
            new_op.set_attr_type("T2", T2::data_type())?;
        }
        {
            new_op.set_attr_type("Toutput", Toutput::data_type())?;
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct QuantizedAdd<T1, x_Arg, T2, y_Arg, min_x_Arg, max_x_Arg, min_y_Arg, max_y_Arg, Toutput>
where T1: TensorType,
      T1: Clone,
      x_Arg: Clone,
      x_Arg: GraphEdge<T1>,
      x_Arg: 'static,
      T2: TensorType,
      T2: Clone,
      y_Arg: Clone,
      y_Arg: GraphEdge<T2>,
      y_Arg: 'static,
      min_x_Arg: Clone,
      min_x_Arg: GraphEdge<f32>,
      min_x_Arg: 'static,
      max_x_Arg: Clone,
      max_x_Arg: GraphEdge<f32>,
      max_x_Arg: 'static,
      min_y_Arg: Clone,
      min_y_Arg: GraphEdge<f32>,
      min_y_Arg: 'static,
      max_y_Arg: Clone,
      max_y_Arg: GraphEdge<f32>,
      max_y_Arg: 'static,
      Toutput: TensorType,
      T1: con_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_QINT16_or_DT_QUINT16,
      T1: 'static,
      T2: con_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_QINT16_or_DT_QUINT16,
      T2: 'static,
      Toutput: con_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_QINT16_or_DT_QUINT16,
      Toutput: 'static,
      Toutput: Clone,
{
    phantom_T1: PhantomData<T1>,
    x: x_Arg,
    phantom_T2: PhantomData<T2>,
    y: y_Arg,
    min_x: min_x_Arg,
    max_x: max_x_Arg,
    min_y: min_y_Arg,
    max_y: max_y_Arg,
    phantom_Toutput: PhantomData<Toutput>,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<T1, x_Arg, T2, y_Arg, min_x_Arg, max_x_Arg, min_y_Arg, max_y_Arg, Toutput> QuantizedAdd<T1, x_Arg, T2, y_Arg, min_x_Arg, max_x_Arg, min_y_Arg, max_y_Arg, Toutput>
where T1: TensorType,
      T1: Clone,
      x_Arg: Clone,
      x_Arg: GraphEdge<T1>,
      x_Arg: 'static,
      T2: TensorType,
      T2: Clone,
      y_Arg: Clone,
      y_Arg: GraphEdge<T2>,
      y_Arg: 'static,
      min_x_Arg: Clone,
      min_x_Arg: GraphEdge<f32>,
      min_x_Arg: 'static,
      max_x_Arg: Clone,
      max_x_Arg: GraphEdge<f32>,
      max_x_Arg: 'static,
      min_y_Arg: Clone,
      min_y_Arg: GraphEdge<f32>,
      min_y_Arg: 'static,
      max_y_Arg: Clone,
      max_y_Arg: GraphEdge<f32>,
      max_y_Arg: 'static,
      Toutput: TensorType,
      T1: con_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_QINT16_or_DT_QUINT16,
      T1: 'static,
      T2: con_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_QINT16_or_DT_QUINT16,
      T2: 'static,
      Toutput: con_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_QINT16_or_DT_QUINT16,
      Toutput: 'static,
      Toutput: Clone,
{
    pub fn z(self) -> Edge<Toutput> {
        let rc = Rc::new(self);
        {
            Edge::<Toutput>::new(rc.clone(), 0)
        }
    }

    pub fn min_z(self) -> Edge<f32> {
        let rc = Rc::new(self);
        {
            Edge::<f32>::new(rc.clone(), 1)
        }
    }

    pub fn max_z(self) -> Edge<f32> {
        let rc = Rc::new(self);
        {
            Edge::<f32>::new(rc.clone(), 2)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> (Edge<Toutput>, Edge<f32>, Edge<f32>) {
        let rc = Rc::new(self);
        (
        {
            Edge::<Toutput>::new(rc.clone(), 0)
        },
        {
            Edge::<f32>::new(rc.clone(), 1)
        },
        {
            Edge::<f32>::new(rc.clone(), 2)
        },
        )
    }

    pub fn build(x: x_Arg, y: y_Arg, min_x: min_x_Arg, max_x: max_x_Arg, min_y: min_y_Arg, max_y: max_y_Arg) -> Self {
        Self {
            phantom_T1: PhantomData,
            x,
            phantom_T2: PhantomData,
            y,
            min_x,
            max_x,
            min_y,
            max_y,
            phantom_Toutput: PhantomData,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(x: x_Arg, y: y_Arg, min_x: min_x_Arg, max_x: max_x_Arg, min_y: min_y_Arg, max_y: max_y_Arg) -> (Edge<Toutput>, Edge<f32>, Edge<f32>) {
        Self {
            phantom_T1: PhantomData,
            x,
            phantom_T2: PhantomData,
            y,
            min_x,
            max_x,
            min_y,
            max_y,
            phantom_Toutput: PhantomData,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<contents_Arg> GraphOperation for DecodeWav<contents_Arg>
where contents_Arg: Clone,
      contents_Arg: GraphEdge<String>,
      contents_Arg: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("DecodeWav_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("DecodeWav", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.contents)?
        }
        {
            match self.desired_channels {
                None => new_op.set_attr_value_proto("desired_channels", &vec![24_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 1_u8,])?,
                Some(ref value) => (|attr: &i64| {new_op.set_attr_int("desired_channels", *attr)})(&value)?,
            };
        }
        {
            match self.desired_samples {
                None => new_op.set_attr_value_proto("desired_samples", &vec![24_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 1_u8,])?,
                Some(ref value) => (|attr: &i64| {new_op.set_attr_int("desired_samples", *attr)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct DecodeWav<contents_Arg>
where contents_Arg: Clone,
      contents_Arg: GraphEdge<String>,
      contents_Arg: 'static,
{
    contents: contents_Arg,
    desired_channels: Option<i64>,
    desired_samples: Option<i64>,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<contents_Arg> DecodeWav<contents_Arg>
where contents_Arg: Clone,
      contents_Arg: GraphEdge<String>,
      contents_Arg: 'static,
{
    pub fn audio(self) -> Edge<f32> {
        let rc = Rc::new(self);
        {
            Edge::<f32>::new(rc.clone(), 0)
        }
    }

    pub fn sample_rate(self) -> Edge<i32> {
        let rc = Rc::new(self);
        {
            Edge::<i32>::new(rc.clone(), 1)
        }
    }

    pub fn desired_channels(&mut self, desired_channels: i64) -> Self {
        self.desired_channels = Some(desired_channels);
        self.clone()
    }

    pub fn desired_samples(&mut self, desired_samples: i64) -> Self {
        self.desired_samples = Some(desired_samples);
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> (Edge<f32>, Edge<i32>) {
        let rc = Rc::new(self);
        (
        {
            Edge::<f32>::new(rc.clone(), 0)
        },
        {
            Edge::<i32>::new(rc.clone(), 1)
        },
        )
    }

    pub fn build(contents: contents_Arg) -> Self {
        Self {
            contents,
            desired_channels: None,
            desired_samples: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(contents: contents_Arg) -> (Edge<f32>, Edge<i32>) {
        Self {
            contents,
            desired_channels: None,
            desired_samples: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<T, x_Arg, out_idx> GraphOperation for Unique<T, x_Arg, out_idx>
where T: TensorType,
      T: Clone,
      x_Arg: Clone,
      x_Arg: GraphEdge<T>,
      x_Arg: 'static,
      out_idx: TensorType,
      T: 'static,
      out_idx: con_or_DT_INT32_or_DT_INT64,
      out_idx: 'static,
      out_idx: Clone,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("Unique_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("Unique", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.x)?
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        {
            new_op.set_attr_type("out_idx", out_idx::data_type())?;
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct Unique<T, x_Arg, out_idx>
where T: TensorType,
      T: Clone,
      x_Arg: Clone,
      x_Arg: GraphEdge<T>,
      x_Arg: 'static,
      out_idx: TensorType,
      T: 'static,
      out_idx: con_or_DT_INT32_or_DT_INT64,
      out_idx: 'static,
      out_idx: Clone,
{
    phantom_T: PhantomData<T>,
    x: x_Arg,
    phantom_out_idx: PhantomData<out_idx>,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<T, x_Arg, out_idx> Unique<T, x_Arg, out_idx>
where T: TensorType,
      T: Clone,
      x_Arg: Clone,
      x_Arg: GraphEdge<T>,
      x_Arg: 'static,
      out_idx: TensorType,
      T: 'static,
      out_idx: con_or_DT_INT32_or_DT_INT64,
      out_idx: 'static,
      out_idx: Clone,
{
    pub fn y(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn idx(self) -> Edge<out_idx> {
        let rc = Rc::new(self);
        {
            Edge::<out_idx>::new(rc.clone(), 1)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> (Edge<T>, Edge<out_idx>) {
        let rc = Rc::new(self);
        (
        {
            Edge::<T>::new(rc.clone(), 0)
        },
        {
            Edge::<out_idx>::new(rc.clone(), 1)
        },
        )
    }

    pub fn build(x: x_Arg) -> Self {
        Self {
            phantom_T: PhantomData,
            x,
            phantom_out_idx: PhantomData,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(x: x_Arg) -> (Edge<T>, Edge<out_idx>) {
        Self {
            phantom_T: PhantomData,
            x,
            phantom_out_idx: PhantomData,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<index_Arg, T, inputs_Arg> GraphOperation for RefSelect<index_Arg, T, inputs_Arg>
where index_Arg: Clone,
      index_Arg: GraphEdge<i32>,
      index_Arg: 'static,
      T: TensorType,
      T: Clone,
      inputs_Arg: Clone,
      inputs_Arg: GraphRefEdge<T>,
      inputs_Arg: 'static,
      T: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("RefSelect_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("RefSelect", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.index)?
        }
        {
            new_op.add_edge(&self.inputs)?
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        {
            (|attr: &i64| {new_op.set_attr_int("N", *attr)})(&self.N)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct RefSelect<index_Arg, T, inputs_Arg>
where index_Arg: Clone,
      index_Arg: GraphEdge<i32>,
      index_Arg: 'static,
      T: TensorType,
      T: Clone,
      inputs_Arg: Clone,
      inputs_Arg: GraphRefEdge<T>,
      inputs_Arg: 'static,
      T: 'static,
{
    index: index_Arg,
    phantom_T: PhantomData<T>,
    inputs: inputs_Arg,
    N: i64,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<index_Arg, T, inputs_Arg> RefSelect<index_Arg, T, inputs_Arg>
where index_Arg: Clone,
      index_Arg: GraphEdge<i32>,
      index_Arg: 'static,
      T: TensorType,
      T: Clone,
      inputs_Arg: Clone,
      inputs_Arg: GraphRefEdge<T>,
      inputs_Arg: 'static,
      T: 'static,
{
    pub fn output(self) -> RefEdge<T> {
        let rc = Rc::new(self);
        {
            RefEdge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> RefEdge<T> {
        let rc = Rc::new(self);
        {
            RefEdge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(index: index_Arg, inputs: inputs_Arg, N: i64) -> Self {
        Self {
            index,
            phantom_T: PhantomData,
            inputs,
            N: N,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(index: index_Arg, inputs: inputs_Arg, N: i64) -> RefEdge<T> {
        Self {
            index,
            phantom_T: PhantomData,
            inputs,
            N: N,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<T, input_Arg, Tpaddings, paddings_Arg> GraphOperation for MirrorPad<T, input_Arg, Tpaddings, paddings_Arg>
where T: TensorType,
      T: Clone,
      input_Arg: Clone,
      input_Arg: GraphEdge<T>,
      input_Arg: 'static,
      Tpaddings: TensorType,
      Tpaddings: Clone,
      paddings_Arg: Clone,
      paddings_Arg: GraphEdge<Tpaddings>,
      paddings_Arg: 'static,
      T: 'static,
      Tpaddings: con_or_DT_INT32_or_DT_INT64,
      Tpaddings: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("MirrorPad_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("MirrorPad", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.input)?
        }
        {
            new_op.add_edge(&self.paddings)?
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        {
            new_op.set_attr_type("Tpaddings", Tpaddings::data_type())?;
        }
        {
            (|attr| {new_op.set_attr_string("mode", attr)})(&self.mode)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct MirrorPad<T, input_Arg, Tpaddings, paddings_Arg>
where T: TensorType,
      T: Clone,
      input_Arg: Clone,
      input_Arg: GraphEdge<T>,
      input_Arg: 'static,
      Tpaddings: TensorType,
      Tpaddings: Clone,
      paddings_Arg: Clone,
      paddings_Arg: GraphEdge<Tpaddings>,
      paddings_Arg: 'static,
      T: 'static,
      Tpaddings: con_or_DT_INT32_or_DT_INT64,
      Tpaddings: 'static,
{
    phantom_T: PhantomData<T>,
    input: input_Arg,
    phantom_Tpaddings: PhantomData<Tpaddings>,
    paddings: paddings_Arg,
    mode: String,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<T, input_Arg, Tpaddings, paddings_Arg> MirrorPad<T, input_Arg, Tpaddings, paddings_Arg>
where T: TensorType,
      T: Clone,
      input_Arg: Clone,
      input_Arg: GraphEdge<T>,
      input_Arg: 'static,
      Tpaddings: TensorType,
      Tpaddings: Clone,
      paddings_Arg: Clone,
      paddings_Arg: GraphEdge<Tpaddings>,
      paddings_Arg: 'static,
      T: 'static,
      Tpaddings: con_or_DT_INT32_or_DT_INT64,
      Tpaddings: 'static,
{
    pub fn output(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(input: input_Arg, paddings: paddings_Arg, mode: &str) -> Self {
        Self {
            phantom_T: PhantomData,
            input,
            phantom_Tpaddings: PhantomData,
            paddings,
            mode: mode.to_string(),
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(input: input_Arg, paddings: paddings_Arg, mode: &str) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            input,
            phantom_Tpaddings: PhantomData,
            paddings,
            mode: mode.to_string(),
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<gradients_Arg, inputs_Arg, min_Arg, max_Arg> GraphOperation for FakeQuantWithMinMaxVarsPerChannelGradient<gradients_Arg, inputs_Arg, min_Arg, max_Arg>
where gradients_Arg: Clone,
      gradients_Arg: GraphEdge<f32>,
      gradients_Arg: 'static,
      inputs_Arg: Clone,
      inputs_Arg: GraphEdge<f32>,
      inputs_Arg: 'static,
      min_Arg: Clone,
      min_Arg: GraphEdge<f32>,
      min_Arg: 'static,
      max_Arg: Clone,
      max_Arg: GraphEdge<f32>,
      max_Arg: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("FakeQuantWithMinMaxVarsPerChannelGradient_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("FakeQuantWithMinMaxVarsPerChannelGradient", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.gradients)?
        }
        {
            new_op.add_edge(&self.inputs)?
        }
        {
            new_op.add_edge(&self.min)?
        }
        {
            new_op.add_edge(&self.max)?
        }
        {
            match self.num_bits {
                None => new_op.set_attr_value_proto("num_bits", &vec![24_u8, 8_u8,])?,
                Some(ref value) => (|attr: &i64| {new_op.set_attr_int("num_bits", *attr)})(&value)?,
            };
        }
        {
            match self.narrow_range {
                None => new_op.set_attr_value_proto("narrow_range", &vec![40_u8, 0_u8,])?,
                Some(ref value) => (|attr: &bool| {new_op.set_attr_bool("narrow_range", *attr)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct FakeQuantWithMinMaxVarsPerChannelGradient<gradients_Arg, inputs_Arg, min_Arg, max_Arg>
where gradients_Arg: Clone,
      gradients_Arg: GraphEdge<f32>,
      gradients_Arg: 'static,
      inputs_Arg: Clone,
      inputs_Arg: GraphEdge<f32>,
      inputs_Arg: 'static,
      min_Arg: Clone,
      min_Arg: GraphEdge<f32>,
      min_Arg: 'static,
      max_Arg: Clone,
      max_Arg: GraphEdge<f32>,
      max_Arg: 'static,
{
    gradients: gradients_Arg,
    inputs: inputs_Arg,
    min: min_Arg,
    max: max_Arg,
    num_bits: Option<i64>,
    narrow_range: Option<bool>,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<gradients_Arg, inputs_Arg, min_Arg, max_Arg> FakeQuantWithMinMaxVarsPerChannelGradient<gradients_Arg, inputs_Arg, min_Arg, max_Arg>
where gradients_Arg: Clone,
      gradients_Arg: GraphEdge<f32>,
      gradients_Arg: 'static,
      inputs_Arg: Clone,
      inputs_Arg: GraphEdge<f32>,
      inputs_Arg: 'static,
      min_Arg: Clone,
      min_Arg: GraphEdge<f32>,
      min_Arg: 'static,
      max_Arg: Clone,
      max_Arg: GraphEdge<f32>,
      max_Arg: 'static,
{
    pub fn backprops_wrt_input(self) -> Edge<f32> {
        let rc = Rc::new(self);
        {
            Edge::<f32>::new(rc.clone(), 0)
        }
    }

    pub fn backprop_wrt_min(self) -> Edge<f32> {
        let rc = Rc::new(self);
        {
            Edge::<f32>::new(rc.clone(), 1)
        }
    }

    pub fn backprop_wrt_max(self) -> Edge<f32> {
        let rc = Rc::new(self);
        {
            Edge::<f32>::new(rc.clone(), 2)
        }
    }

    pub fn num_bits(&mut self, num_bits: i64) -> Self {
        self.num_bits = Some(num_bits);
        self.clone()
    }

    pub fn narrow_range(&mut self, narrow_range: bool) -> Self {
        self.narrow_range = Some(narrow_range);
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> (Edge<f32>, Edge<f32>, Edge<f32>) {
        let rc = Rc::new(self);
        (
        {
            Edge::<f32>::new(rc.clone(), 0)
        },
        {
            Edge::<f32>::new(rc.clone(), 1)
        },
        {
            Edge::<f32>::new(rc.clone(), 2)
        },
        )
    }

    pub fn build(gradients: gradients_Arg, inputs: inputs_Arg, min: min_Arg, max: max_Arg) -> Self {
        Self {
            gradients,
            inputs,
            min,
            max,
            num_bits: None,
            narrow_range: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(gradients: gradients_Arg, inputs: inputs_Arg, min: min_Arg, max: max_Arg) -> (Edge<f32>, Edge<f32>, Edge<f32>) {
        Self {
            gradients,
            inputs,
            min,
            max,
            num_bits: None,
            narrow_range: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<handle_Arg, index_Arg, flow_in_Arg, dtype> GraphOperation for TensorArrayRead<handle_Arg, index_Arg, flow_in_Arg, dtype>
where handle_Arg: Clone,
      handle_Arg: GraphRefEdge<String>,
      handle_Arg: 'static,
      index_Arg: Clone,
      index_Arg: GraphEdge<i32>,
      index_Arg: 'static,
      flow_in_Arg: Clone,
      flow_in_Arg: GraphEdge<f32>,
      flow_in_Arg: 'static,
      dtype: TensorType,
      dtype: 'static,
      dtype: Clone,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("TensorArrayRead_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("TensorArrayRead", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.handle)?
        }
        {
            new_op.add_edge(&self.index)?
        }
        {
            new_op.add_edge(&self.flow_in)?
        }
        {
            new_op.set_attr_type("dtype", dtype::data_type())?;
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct TensorArrayRead<handle_Arg, index_Arg, flow_in_Arg, dtype>
where handle_Arg: Clone,
      handle_Arg: GraphRefEdge<String>,
      handle_Arg: 'static,
      index_Arg: Clone,
      index_Arg: GraphEdge<i32>,
      index_Arg: 'static,
      flow_in_Arg: Clone,
      flow_in_Arg: GraphEdge<f32>,
      flow_in_Arg: 'static,
      dtype: TensorType,
      dtype: 'static,
      dtype: Clone,
{
    handle: handle_Arg,
    index: index_Arg,
    flow_in: flow_in_Arg,
    phantom_dtype: PhantomData<dtype>,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<handle_Arg, index_Arg, flow_in_Arg, dtype> TensorArrayRead<handle_Arg, index_Arg, flow_in_Arg, dtype>
where handle_Arg: Clone,
      handle_Arg: GraphRefEdge<String>,
      handle_Arg: 'static,
      index_Arg: Clone,
      index_Arg: GraphEdge<i32>,
      index_Arg: 'static,
      flow_in_Arg: Clone,
      flow_in_Arg: GraphEdge<f32>,
      flow_in_Arg: 'static,
      dtype: TensorType,
      dtype: 'static,
      dtype: Clone,
{
    pub fn value(self) -> Edge<dtype> {
        let rc = Rc::new(self);
        {
            Edge::<dtype>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<dtype> {
        let rc = Rc::new(self);
        {
            Edge::<dtype>::new(rc.clone(), 0)
        }
    }

    pub fn build(handle: handle_Arg, index: index_Arg, flow_in: flow_in_Arg) -> Self {
        Self {
            handle,
            index,
            flow_in,
            phantom_dtype: PhantomData,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(handle: handle_Arg, index: index_Arg, flow_in: flow_in_Arg) -> Edge<dtype> {
        Self {
            handle,
            index,
            flow_in,
            phantom_dtype: PhantomData,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<T, a_Arg, b_Arg, x_Arg> GraphOperation for Betainc<T, a_Arg, b_Arg, x_Arg>
where T: TensorType,
      T: Clone,
      a_Arg: Clone,
      a_Arg: GraphEdge<T>,
      a_Arg: 'static,
      b_Arg: Clone,
      b_Arg: GraphEdge<T>,
      b_Arg: 'static,
      x_Arg: Clone,
      x_Arg: GraphEdge<T>,
      x_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE,
      T: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("Betainc_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("Betainc", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.a)?
        }
        {
            new_op.add_edge(&self.b)?
        }
        {
            new_op.add_edge(&self.x)?
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct Betainc<T, a_Arg, b_Arg, x_Arg>
where T: TensorType,
      T: Clone,
      a_Arg: Clone,
      a_Arg: GraphEdge<T>,
      a_Arg: 'static,
      b_Arg: Clone,
      b_Arg: GraphEdge<T>,
      b_Arg: 'static,
      x_Arg: Clone,
      x_Arg: GraphEdge<T>,
      x_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    a: a_Arg,
    b: b_Arg,
    x: x_Arg,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<T, a_Arg, b_Arg, x_Arg> Betainc<T, a_Arg, b_Arg, x_Arg>
where T: TensorType,
      T: Clone,
      a_Arg: Clone,
      a_Arg: GraphEdge<T>,
      a_Arg: 'static,
      b_Arg: Clone,
      b_Arg: GraphEdge<T>,
      b_Arg: 'static,
      x_Arg: Clone,
      x_Arg: GraphEdge<T>,
      x_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE,
      T: 'static,
{
    pub fn z(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(a: a_Arg, b: b_Arg, x: x_Arg) -> Self {
        Self {
            phantom_T: PhantomData,
            a,
            b,
            x,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(a: a_Arg, b: b_Arg, x: x_Arg) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            a,
            b,
            x,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<inputs_Arg, min_Arg, max_Arg> GraphOperation for FakeQuantWithMinMaxVarsPerChannel<inputs_Arg, min_Arg, max_Arg>
where inputs_Arg: Clone,
      inputs_Arg: GraphEdge<f32>,
      inputs_Arg: 'static,
      min_Arg: Clone,
      min_Arg: GraphEdge<f32>,
      min_Arg: 'static,
      max_Arg: Clone,
      max_Arg: GraphEdge<f32>,
      max_Arg: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("FakeQuantWithMinMaxVarsPerChannel_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("FakeQuantWithMinMaxVarsPerChannel", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.inputs)?
        }
        {
            new_op.add_edge(&self.min)?
        }
        {
            new_op.add_edge(&self.max)?
        }
        {
            match self.num_bits {
                None => new_op.set_attr_value_proto("num_bits", &vec![24_u8, 8_u8,])?,
                Some(ref value) => (|attr: &i64| {new_op.set_attr_int("num_bits", *attr)})(&value)?,
            };
        }
        {
            match self.narrow_range {
                None => new_op.set_attr_value_proto("narrow_range", &vec![40_u8, 0_u8,])?,
                Some(ref value) => (|attr: &bool| {new_op.set_attr_bool("narrow_range", *attr)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct FakeQuantWithMinMaxVarsPerChannel<inputs_Arg, min_Arg, max_Arg>
where inputs_Arg: Clone,
      inputs_Arg: GraphEdge<f32>,
      inputs_Arg: 'static,
      min_Arg: Clone,
      min_Arg: GraphEdge<f32>,
      min_Arg: 'static,
      max_Arg: Clone,
      max_Arg: GraphEdge<f32>,
      max_Arg: 'static,
{
    inputs: inputs_Arg,
    min: min_Arg,
    max: max_Arg,
    num_bits: Option<i64>,
    narrow_range: Option<bool>,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<inputs_Arg, min_Arg, max_Arg> FakeQuantWithMinMaxVarsPerChannel<inputs_Arg, min_Arg, max_Arg>
where inputs_Arg: Clone,
      inputs_Arg: GraphEdge<f32>,
      inputs_Arg: 'static,
      min_Arg: Clone,
      min_Arg: GraphEdge<f32>,
      min_Arg: 'static,
      max_Arg: Clone,
      max_Arg: GraphEdge<f32>,
      max_Arg: 'static,
{
    pub fn outputs(self) -> Edge<f32> {
        let rc = Rc::new(self);
        {
            Edge::<f32>::new(rc.clone(), 0)
        }
    }

    pub fn num_bits(&mut self, num_bits: i64) -> Self {
        self.num_bits = Some(num_bits);
        self.clone()
    }

    pub fn narrow_range(&mut self, narrow_range: bool) -> Self {
        self.narrow_range = Some(narrow_range);
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<f32> {
        let rc = Rc::new(self);
        {
            Edge::<f32>::new(rc.clone(), 0)
        }
    }

    pub fn build(inputs: inputs_Arg, min: min_Arg, max: max_Arg) -> Self {
        Self {
            inputs,
            min,
            max,
            num_bits: None,
            narrow_range: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(inputs: inputs_Arg, min: min_Arg, max: max_Arg) -> Edge<f32> {
        Self {
            inputs,
            min,
            max,
            num_bits: None,
            narrow_range: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<K, keys_Arg, V, values_Arg> GraphOperation for XlaKeyValueSort<K, keys_Arg, V, values_Arg>
where K: TensorType,
      K: Clone,
      keys_Arg: Clone,
      keys_Arg: GraphEdge<K>,
      keys_Arg: 'static,
      V: TensorType,
      V: Clone,
      values_Arg: Clone,
      values_Arg: GraphEdge<V>,
      values_Arg: 'static,
      K: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      K: 'static,
      V: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("XlaKeyValueSort_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("XlaKeyValueSort", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.keys)?
        }
        {
            new_op.add_edge(&self.values)?
        }
        {
            new_op.set_attr_type("K", K::data_type())?;
        }
        {
            new_op.set_attr_type("V", V::data_type())?;
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct XlaKeyValueSort<K, keys_Arg, V, values_Arg>
where K: TensorType,
      K: Clone,
      keys_Arg: Clone,
      keys_Arg: GraphEdge<K>,
      keys_Arg: 'static,
      V: TensorType,
      V: Clone,
      values_Arg: Clone,
      values_Arg: GraphEdge<V>,
      values_Arg: 'static,
      K: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      K: 'static,
      V: 'static,
{
    phantom_K: PhantomData<K>,
    keys: keys_Arg,
    phantom_V: PhantomData<V>,
    values: values_Arg,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<K, keys_Arg, V, values_Arg> XlaKeyValueSort<K, keys_Arg, V, values_Arg>
where K: TensorType,
      K: Clone,
      keys_Arg: Clone,
      keys_Arg: GraphEdge<K>,
      keys_Arg: 'static,
      V: TensorType,
      V: Clone,
      values_Arg: Clone,
      values_Arg: GraphEdge<V>,
      values_Arg: 'static,
      K: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      K: 'static,
      V: 'static,
{
    pub fn sorted_keys(self) -> Edge<K> {
        let rc = Rc::new(self);
        {
            Edge::<K>::new(rc.clone(), 0)
        }
    }

    pub fn sorted_values(self) -> Edge<V> {
        let rc = Rc::new(self);
        {
            Edge::<V>::new(rc.clone(), 1)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> (Edge<K>, Edge<V>) {
        let rc = Rc::new(self);
        (
        {
            Edge::<K>::new(rc.clone(), 0)
        },
        {
            Edge::<V>::new(rc.clone(), 1)
        },
        )
    }

    pub fn build(keys: keys_Arg, values: values_Arg) -> Self {
        Self {
            phantom_K: PhantomData,
            keys,
            phantom_V: PhantomData,
            values,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(keys: keys_Arg, values: values_Arg) -> (Edge<K>, Edge<V>) {
        Self {
            phantom_K: PhantomData,
            keys,
            phantom_V: PhantomData,
            values,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<parameters_Arg, accumulators_Arg, linears_Arg> GraphOperation for LoadTPUEmbeddingFTRLParameters<parameters_Arg, accumulators_Arg, linears_Arg>
where parameters_Arg: Clone,
      parameters_Arg: GraphEdge<f32>,
      parameters_Arg: 'static,
      accumulators_Arg: Clone,
      accumulators_Arg: GraphEdge<f32>,
      accumulators_Arg: 'static,
      linears_Arg: Clone,
      linears_Arg: GraphEdge<f32>,
      linears_Arg: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("LoadTPUEmbeddingFTRLParameters_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("LoadTPUEmbeddingFTRLParameters", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.parameters)?
        }
        {
            new_op.add_edge(&self.accumulators)?
        }
        {
            new_op.add_edge(&self.linears)?
        }
        {
            match self.table_id {
                None => new_op.set_attr_value_proto("table_id", &vec![24_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 1_u8,])?,
                Some(ref value) => (|attr: &i64| {new_op.set_attr_int("table_id", *attr)})(&value)?,
            };
        }
        {
            match self.table_name {
                None => new_op.set_attr_value_proto("table_name", &vec![18_u8, 0_u8,])?,
                Some(ref value) => (|attr| {new_op.set_attr_string("table_name", attr)})(&value)?,
            };
        }
        {
            (|attr: &i64| {new_op.set_attr_int("num_shards", *attr)})(&self.num_shards)?
        }
        {
            (|attr: &i64| {new_op.set_attr_int("shard_id", *attr)})(&self.shard_id)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct LoadTPUEmbeddingFTRLParameters<parameters_Arg, accumulators_Arg, linears_Arg>
where parameters_Arg: Clone,
      parameters_Arg: GraphEdge<f32>,
      parameters_Arg: 'static,
      accumulators_Arg: Clone,
      accumulators_Arg: GraphEdge<f32>,
      accumulators_Arg: 'static,
      linears_Arg: Clone,
      linears_Arg: GraphEdge<f32>,
      linears_Arg: 'static,
{
    parameters: parameters_Arg,
    accumulators: accumulators_Arg,
    linears: linears_Arg,
    table_id: Option<i64>,
    table_name: Option<String>,
    num_shards: i64,
    shard_id: i64,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<parameters_Arg, accumulators_Arg, linears_Arg> LoadTPUEmbeddingFTRLParameters<parameters_Arg, accumulators_Arg, linears_Arg>
where parameters_Arg: Clone,
      parameters_Arg: GraphEdge<f32>,
      parameters_Arg: 'static,
      accumulators_Arg: Clone,
      accumulators_Arg: GraphEdge<f32>,
      accumulators_Arg: 'static,
      linears_Arg: Clone,
      linears_Arg: GraphEdge<f32>,
      linears_Arg: 'static,
{
    pub fn table_id(&mut self, table_id: i64) -> Self {
        self.table_id = Some(table_id);
        self.clone()
    }

    pub fn table_name(&mut self, table_name: &str) -> Self {
        self.table_name = Some(table_name.to_string());
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> () {
        let rc = Rc::new(self);
        (
        )
    }

    pub fn build(parameters: parameters_Arg, accumulators: accumulators_Arg, linears: linears_Arg, num_shards: i64, shard_id: i64) -> Self {
        Self {
            parameters,
            accumulators,
            linears,
            table_id: None,
            table_name: None,
            num_shards: num_shards,
            shard_id: shard_id,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(parameters: parameters_Arg, accumulators: accumulators_Arg, linears: linears_Arg, num_shards: i64, shard_id: i64) -> () {
        Self {
            parameters,
            accumulators,
            linears,
            table_id: None,
            table_name: None,
            num_shards: num_shards,
            shard_id: shard_id,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<T, input_Arg, update_Arg, Tindices, indices_Arg> GraphOperation for XlaDynamicUpdateSlice<T, input_Arg, update_Arg, Tindices, indices_Arg>
where T: TensorType,
      T: Clone,
      input_Arg: Clone,
      input_Arg: GraphEdge<T>,
      input_Arg: 'static,
      update_Arg: Clone,
      update_Arg: GraphEdge<T>,
      update_Arg: 'static,
      Tindices: TensorType,
      Tindices: Clone,
      indices_Arg: Clone,
      indices_Arg: GraphEdge<Tindices>,
      indices_Arg: 'static,
      T: 'static,
      Tindices: con_or_DT_INT32_or_DT_INT64,
      Tindices: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("XlaDynamicUpdateSlice_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("XlaDynamicUpdateSlice", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.input)?
        }
        {
            new_op.add_edge(&self.update)?
        }
        {
            new_op.add_edge(&self.indices)?
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        {
            new_op.set_attr_type("Tindices", Tindices::data_type())?;
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct XlaDynamicUpdateSlice<T, input_Arg, update_Arg, Tindices, indices_Arg>
where T: TensorType,
      T: Clone,
      input_Arg: Clone,
      input_Arg: GraphEdge<T>,
      input_Arg: 'static,
      update_Arg: Clone,
      update_Arg: GraphEdge<T>,
      update_Arg: 'static,
      Tindices: TensorType,
      Tindices: Clone,
      indices_Arg: Clone,
      indices_Arg: GraphEdge<Tindices>,
      indices_Arg: 'static,
      T: 'static,
      Tindices: con_or_DT_INT32_or_DT_INT64,
      Tindices: 'static,
{
    phantom_T: PhantomData<T>,
    input: input_Arg,
    update: update_Arg,
    phantom_Tindices: PhantomData<Tindices>,
    indices: indices_Arg,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<T, input_Arg, update_Arg, Tindices, indices_Arg> XlaDynamicUpdateSlice<T, input_Arg, update_Arg, Tindices, indices_Arg>
where T: TensorType,
      T: Clone,
      input_Arg: Clone,
      input_Arg: GraphEdge<T>,
      input_Arg: 'static,
      update_Arg: Clone,
      update_Arg: GraphEdge<T>,
      update_Arg: 'static,
      Tindices: TensorType,
      Tindices: Clone,
      indices_Arg: Clone,
      indices_Arg: GraphEdge<Tindices>,
      indices_Arg: 'static,
      T: 'static,
      Tindices: con_or_DT_INT32_or_DT_INT64,
      Tindices: 'static,
{
    pub fn output(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(input: input_Arg, update: update_Arg, indices: indices_Arg) -> Self {
        Self {
            phantom_T: PhantomData,
            input,
            update,
            phantom_Tindices: PhantomData,
            indices,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(input: input_Arg, update: update_Arg, indices: indices_Arg) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            input,
            update,
            phantom_Tindices: PhantomData,
            indices,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<shape_Arg, dtype> GraphOperation for Empty<shape_Arg, dtype>
where shape_Arg: Clone,
      shape_Arg: GraphEdge<i32>,
      shape_Arg: 'static,
      dtype: TensorType,
      dtype: 'static,
      dtype: Clone,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("Empty_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("Empty", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.shape)?
        }
        {
            new_op.set_attr_type("dtype", dtype::data_type())?;
        }
        {
            match self.init {
                None => new_op.set_attr_value_proto("init", &vec![40_u8, 0_u8,])?,
                Some(ref value) => (|attr: &bool| {new_op.set_attr_bool("init", *attr)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct Empty<shape_Arg, dtype>
where shape_Arg: Clone,
      shape_Arg: GraphEdge<i32>,
      shape_Arg: 'static,
      dtype: TensorType,
      dtype: 'static,
      dtype: Clone,
{
    shape: shape_Arg,
    phantom_dtype: PhantomData<dtype>,
    init: Option<bool>,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<shape_Arg, dtype> Empty<shape_Arg, dtype>
where shape_Arg: Clone,
      shape_Arg: GraphEdge<i32>,
      shape_Arg: 'static,
      dtype: TensorType,
      dtype: 'static,
      dtype: Clone,
{
    pub fn output(self) -> Edge<dtype> {
        let rc = Rc::new(self);
        {
            Edge::<dtype>::new(rc.clone(), 0)
        }
    }

    pub fn init(&mut self, init: bool) -> Self {
        self.init = Some(init);
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<dtype> {
        let rc = Rc::new(self);
        {
            Edge::<dtype>::new(rc.clone(), 0)
        }
    }

    pub fn build(shape: shape_Arg) -> Self {
        Self {
            shape,
            phantom_dtype: PhantomData,
            init: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(shape: shape_Arg) -> Edge<dtype> {
        Self {
            shape,
            phantom_dtype: PhantomData,
            init: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl GraphOperation for RetrieveTPUEmbeddingMDLAdagradLightParameters {
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("RetrieveTPUEmbeddingMDLAdagradLightParameters_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("RetrieveTPUEmbeddingMDLAdagradLightParameters", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            match self.table_id {
                None => new_op.set_attr_value_proto("table_id", &vec![24_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 1_u8,])?,
                Some(ref value) => (|attr: &i64| {new_op.set_attr_int("table_id", *attr)})(&value)?,
            };
        }
        {
            match self.table_name {
                None => new_op.set_attr_value_proto("table_name", &vec![18_u8, 0_u8,])?,
                Some(ref value) => (|attr| {new_op.set_attr_string("table_name", attr)})(&value)?,
            };
        }
        {
            (|attr: &i64| {new_op.set_attr_int("num_shards", *attr)})(&self.num_shards)?
        }
        {
            (|attr: &i64| {new_op.set_attr_int("shard_id", *attr)})(&self.shard_id)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct RetrieveTPUEmbeddingMDLAdagradLightParameters {
    table_id: Option<i64>,
    table_name: Option<String>,
    num_shards: i64,
    shard_id: i64,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl RetrieveTPUEmbeddingMDLAdagradLightParameters {
    pub fn parameters(self) -> Edge<f32> {
        let rc = Rc::new(self);
        {
            Edge::<f32>::new(rc.clone(), 0)
        }
    }

    pub fn accumulators(self) -> Edge<f32> {
        let rc = Rc::new(self);
        {
            Edge::<f32>::new(rc.clone(), 1)
        }
    }

    pub fn weights(self) -> Edge<f32> {
        let rc = Rc::new(self);
        {
            Edge::<f32>::new(rc.clone(), 2)
        }
    }

    pub fn benefits(self) -> Edge<f32> {
        let rc = Rc::new(self);
        {
            Edge::<f32>::new(rc.clone(), 3)
        }
    }

    pub fn table_id(&mut self, table_id: i64) -> Self {
        self.table_id = Some(table_id);
        self.clone()
    }

    pub fn table_name(&mut self, table_name: &str) -> Self {
        self.table_name = Some(table_name.to_string());
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> (Edge<f32>, Edge<f32>, Edge<f32>, Edge<f32>) {
        let rc = Rc::new(self);
        (
        {
            Edge::<f32>::new(rc.clone(), 0)
        },
        {
            Edge::<f32>::new(rc.clone(), 1)
        },
        {
            Edge::<f32>::new(rc.clone(), 2)
        },
        {
            Edge::<f32>::new(rc.clone(), 3)
        },
        )
    }

    pub fn build(num_shards: i64, shard_id: i64) -> Self {
        Self {
            table_id: None,
            table_name: None,
            num_shards: num_shards,
            shard_id: shard_id,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(num_shards: i64, shard_id: i64) -> (Edge<f32>, Edge<f32>, Edge<f32>, Edge<f32>) {
        Self {
            table_id: None,
            table_name: None,
            num_shards: num_shards,
            shard_id: shard_id,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<T, value_Arg> GraphOperation for FractionalAvgPool<T, value_Arg>
where T: TensorType,
      T: Clone,
      value_Arg: Clone,
      value_Arg: GraphEdge<T>,
      value_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_INT64,
      T: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("FractionalAvgPool_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("FractionalAvgPool", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.value)?
        }
        {
            (|attrs| {new_op.set_attr_float_list("pooling_ratio", attrs)})(&self.pooling_ratio)?
        }
        {
            match self.pseudo_random {
                None => new_op.set_attr_value_proto("pseudo_random", &vec![40_u8, 0_u8,])?,
                Some(ref value) => (|attr: &bool| {new_op.set_attr_bool("pseudo_random", *attr)})(&value)?,
            };
        }
        {
            match self.overlapping {
                None => new_op.set_attr_value_proto("overlapping", &vec![40_u8, 0_u8,])?,
                Some(ref value) => (|attr: &bool| {new_op.set_attr_bool("overlapping", *attr)})(&value)?,
            };
        }
        {
            match self.deterministic {
                None => new_op.set_attr_value_proto("deterministic", &vec![40_u8, 0_u8,])?,
                Some(ref value) => (|attr: &bool| {new_op.set_attr_bool("deterministic", *attr)})(&value)?,
            };
        }
        {
            match self.seed {
                None => new_op.set_attr_value_proto("seed", &vec![24_u8, 0_u8,])?,
                Some(ref value) => (|attr: &i64| {new_op.set_attr_int("seed", *attr)})(&value)?,
            };
        }
        {
            match self.seed2 {
                None => new_op.set_attr_value_proto("seed2", &vec![24_u8, 0_u8,])?,
                Some(ref value) => (|attr: &i64| {new_op.set_attr_int("seed2", *attr)})(&value)?,
            };
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct FractionalAvgPool<T, value_Arg>
where T: TensorType,
      T: Clone,
      value_Arg: Clone,
      value_Arg: GraphEdge<T>,
      value_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_INT64,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    value: value_Arg,
    pooling_ratio: Vec<f32>,
    pseudo_random: Option<bool>,
    overlapping: Option<bool>,
    deterministic: Option<bool>,
    seed: Option<i64>,
    seed2: Option<i64>,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<T, value_Arg> FractionalAvgPool<T, value_Arg>
where T: TensorType,
      T: Clone,
      value_Arg: Clone,
      value_Arg: GraphEdge<T>,
      value_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_INT64,
      T: 'static,
{
    pub fn output(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn row_pooling_sequence(self) -> Edge<i64> {
        let rc = Rc::new(self);
        {
            Edge::<i64>::new(rc.clone(), 1)
        }
    }

    pub fn col_pooling_sequence(self) -> Edge<i64> {
        let rc = Rc::new(self);
        {
            Edge::<i64>::new(rc.clone(), 2)
        }
    }

    pub fn pseudo_random(&mut self, pseudo_random: bool) -> Self {
        self.pseudo_random = Some(pseudo_random);
        self.clone()
    }

    pub fn overlapping(&mut self, overlapping: bool) -> Self {
        self.overlapping = Some(overlapping);
        self.clone()
    }

    pub fn deterministic(&mut self, deterministic: bool) -> Self {
        self.deterministic = Some(deterministic);
        self.clone()
    }

    pub fn seed(&mut self, seed: i64) -> Self {
        self.seed = Some(seed);
        self.clone()
    }

    pub fn seed2(&mut self, seed2: i64) -> Self {
        self.seed2 = Some(seed2);
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> (Edge<T>, Edge<i64>, Edge<i64>) {
        let rc = Rc::new(self);
        (
        {
            Edge::<T>::new(rc.clone(), 0)
        },
        {
            Edge::<i64>::new(rc.clone(), 1)
        },
        {
            Edge::<i64>::new(rc.clone(), 2)
        },
        )
    }

    pub fn build(value: value_Arg, pooling_ratio: &[f32]) -> Self {
        Self {
            phantom_T: PhantomData,
            value,
            pooling_ratio: pooling_ratio.to_vec(),
            pseudo_random: None,
            overlapping: None,
            deterministic: None,
            seed: None,
            seed2: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(value: value_Arg, pooling_ratio: &[f32]) -> (Edge<T>, Edge<i64>, Edge<i64>) {
        Self {
            phantom_T: PhantomData,
            value,
            pooling_ratio: pooling_ratio.to_vec(),
            pseudo_random: None,
            overlapping: None,
            deterministic: None,
            seed: None,
            seed2: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<T, input_Arg> GraphOperation for ExtractVolumePatches<T, input_Arg>
where T: TensorType,
      T: Clone,
      input_Arg: Clone,
      input_Arg: GraphEdge<T>,
      input_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("ExtractVolumePatches_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("ExtractVolumePatches", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.input)?
        }
        {
            (|attrs| {new_op.set_attr_int_list("ksizes", attrs)})(&self.ksizes)?
        }
        {
            (|attrs| {new_op.set_attr_int_list("strides", attrs)})(&self.strides)?
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        {
            (|attr| {new_op.set_attr_string("padding", attr)})(&self.padding)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct ExtractVolumePatches<T, input_Arg>
where T: TensorType,
      T: Clone,
      input_Arg: Clone,
      input_Arg: GraphEdge<T>,
      input_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    input: input_Arg,
    ksizes: Vec<i64>,
    strides: Vec<i64>,
    padding: String,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<T, input_Arg> ExtractVolumePatches<T, input_Arg>
where T: TensorType,
      T: Clone,
      input_Arg: Clone,
      input_Arg: GraphEdge<T>,
      input_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
{
    pub fn patches(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(input: input_Arg, ksizes: &[i64], strides: &[i64], padding: &str) -> Self {
        Self {
            phantom_T: PhantomData,
            input,
            ksizes: ksizes.to_vec(),
            strides: strides.to_vec(),
            padding: padding.to_string(),
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(input: input_Arg, ksizes: &[i64], strides: &[i64], padding: &str) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            input,
            ksizes: ksizes.to_vec(),
            strides: strides.to_vec(),
            padding: padding.to_string(),
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<T, value_Arg> GraphOperation for GetSessionHandle<T, value_Arg>
where T: TensorType,
      T: Clone,
      value_Arg: Clone,
      value_Arg: GraphEdge<T>,
      value_Arg: 'static,
      T: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("GetSessionHandle_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("GetSessionHandle", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.value)?
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct GetSessionHandle<T, value_Arg>
where T: TensorType,
      T: Clone,
      value_Arg: Clone,
      value_Arg: GraphEdge<T>,
      value_Arg: 'static,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    value: value_Arg,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<T, value_Arg> GetSessionHandle<T, value_Arg>
where T: TensorType,
      T: Clone,
      value_Arg: Clone,
      value_Arg: GraphEdge<T>,
      value_Arg: 'static,
      T: 'static,
{
    pub fn handle(self) -> Edge<String> {
        let rc = Rc::new(self);
        {
            Edge::<String>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<String> {
        let rc = Rc::new(self);
        {
            Edge::<String>::new(rc.clone(), 0)
        }
    }

    pub fn build(value: value_Arg) -> Self {
        Self {
            phantom_T: PhantomData,
            value,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(value: value_Arg) -> Edge<String> {
        Self {
            phantom_T: PhantomData,
            value,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<table_handle_Arg, Tkeys, Tvalues> GraphOperation for LookupTableExport<table_handle_Arg, Tkeys, Tvalues>
where table_handle_Arg: Clone,
      table_handle_Arg: GraphRefEdge<String>,
      table_handle_Arg: 'static,
      Tkeys: TensorType,
      Tvalues: TensorType,
      Tkeys: 'static,
      Tkeys: Clone,
      Tvalues: 'static,
      Tvalues: Clone,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("LookupTableExport_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("LookupTableExport", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.table_handle)?
        }
        {
            new_op.set_attr_type("Tkeys", Tkeys::data_type())?;
        }
        {
            new_op.set_attr_type("Tvalues", Tvalues::data_type())?;
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct LookupTableExport<table_handle_Arg, Tkeys, Tvalues>
where table_handle_Arg: Clone,
      table_handle_Arg: GraphRefEdge<String>,
      table_handle_Arg: 'static,
      Tkeys: TensorType,
      Tvalues: TensorType,
      Tkeys: 'static,
      Tkeys: Clone,
      Tvalues: 'static,
      Tvalues: Clone,
{
    table_handle: table_handle_Arg,
    phantom_Tkeys: PhantomData<Tkeys>,
    phantom_Tvalues: PhantomData<Tvalues>,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<table_handle_Arg, Tkeys, Tvalues> LookupTableExport<table_handle_Arg, Tkeys, Tvalues>
where table_handle_Arg: Clone,
      table_handle_Arg: GraphRefEdge<String>,
      table_handle_Arg: 'static,
      Tkeys: TensorType,
      Tvalues: TensorType,
      Tkeys: 'static,
      Tkeys: Clone,
      Tvalues: 'static,
      Tvalues: Clone,
{
    pub fn keys(self) -> Edge<Tkeys> {
        let rc = Rc::new(self);
        {
            Edge::<Tkeys>::new(rc.clone(), 0)
        }
    }

    pub fn values(self) -> Edge<Tvalues> {
        let rc = Rc::new(self);
        {
            Edge::<Tvalues>::new(rc.clone(), 1)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> (Edge<Tkeys>, Edge<Tvalues>) {
        let rc = Rc::new(self);
        (
        {
            Edge::<Tkeys>::new(rc.clone(), 0)
        },
        {
            Edge::<Tvalues>::new(rc.clone(), 1)
        },
        )
    }

    pub fn build(table_handle: table_handle_Arg) -> Self {
        Self {
            table_handle,
            phantom_Tkeys: PhantomData,
            phantom_Tvalues: PhantomData,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(table_handle: table_handle_Arg) -> (Edge<Tkeys>, Edge<Tvalues>) {
        Self {
            table_handle,
            phantom_Tkeys: PhantomData,
            phantom_Tvalues: PhantomData,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<T, input_Arg> GraphOperation for BatchMatrixInverse<T, input_Arg>
where T: TensorType,
      T: Clone,
      input_Arg: Clone,
      input_Arg: GraphEdge<T>,
      input_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE,
      T: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("BatchMatrixInverse_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("BatchMatrixInverse", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.input)?
        }
        {
            match self.adjoint {
                None => new_op.set_attr_value_proto("adjoint", &vec![40_u8, 0_u8,])?,
                Some(ref value) => (|attr: &bool| {new_op.set_attr_bool("adjoint", *attr)})(&value)?,
            };
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct BatchMatrixInverse<T, input_Arg>
where T: TensorType,
      T: Clone,
      input_Arg: Clone,
      input_Arg: GraphEdge<T>,
      input_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    input: input_Arg,
    adjoint: Option<bool>,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<T, input_Arg> BatchMatrixInverse<T, input_Arg>
where T: TensorType,
      T: Clone,
      input_Arg: Clone,
      input_Arg: GraphEdge<T>,
      input_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE,
      T: 'static,
{
    pub fn output(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn adjoint(&mut self, adjoint: bool) -> Self {
        self.adjoint = Some(adjoint);
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(input: input_Arg) -> Self {
        Self {
            phantom_T: PhantomData,
            input,
            adjoint: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(input: input_Arg) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            input,
            adjoint: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<handle_Arg, T, value_Arg, lengths_Arg, flow_in_Arg> GraphOperation for TensorArraySplit<handle_Arg, T, value_Arg, lengths_Arg, flow_in_Arg>
where handle_Arg: Clone,
      handle_Arg: GraphRefEdge<String>,
      handle_Arg: 'static,
      T: TensorType,
      T: Clone,
      value_Arg: Clone,
      value_Arg: GraphEdge<T>,
      value_Arg: 'static,
      lengths_Arg: Clone,
      lengths_Arg: GraphEdge<i64>,
      lengths_Arg: 'static,
      flow_in_Arg: Clone,
      flow_in_Arg: GraphEdge<f32>,
      flow_in_Arg: 'static,
      T: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("TensorArraySplit_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("TensorArraySplit", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.handle)?
        }
        {
            new_op.add_edge(&self.value)?
        }
        {
            new_op.add_edge(&self.lengths)?
        }
        {
            new_op.add_edge(&self.flow_in)?
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct TensorArraySplit<handle_Arg, T, value_Arg, lengths_Arg, flow_in_Arg>
where handle_Arg: Clone,
      handle_Arg: GraphRefEdge<String>,
      handle_Arg: 'static,
      T: TensorType,
      T: Clone,
      value_Arg: Clone,
      value_Arg: GraphEdge<T>,
      value_Arg: 'static,
      lengths_Arg: Clone,
      lengths_Arg: GraphEdge<i64>,
      lengths_Arg: 'static,
      flow_in_Arg: Clone,
      flow_in_Arg: GraphEdge<f32>,
      flow_in_Arg: 'static,
      T: 'static,
{
    handle: handle_Arg,
    phantom_T: PhantomData<T>,
    value: value_Arg,
    lengths: lengths_Arg,
    flow_in: flow_in_Arg,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<handle_Arg, T, value_Arg, lengths_Arg, flow_in_Arg> TensorArraySplit<handle_Arg, T, value_Arg, lengths_Arg, flow_in_Arg>
where handle_Arg: Clone,
      handle_Arg: GraphRefEdge<String>,
      handle_Arg: 'static,
      T: TensorType,
      T: Clone,
      value_Arg: Clone,
      value_Arg: GraphEdge<T>,
      value_Arg: 'static,
      lengths_Arg: Clone,
      lengths_Arg: GraphEdge<i64>,
      lengths_Arg: 'static,
      flow_in_Arg: Clone,
      flow_in_Arg: GraphEdge<f32>,
      flow_in_Arg: 'static,
      T: 'static,
{
    pub fn flow_out(self) -> Edge<f32> {
        let rc = Rc::new(self);
        {
            Edge::<f32>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<f32> {
        let rc = Rc::new(self);
        {
            Edge::<f32>::new(rc.clone(), 0)
        }
    }

    pub fn build(handle: handle_Arg, value: value_Arg, lengths: lengths_Arg, flow_in: flow_in_Arg) -> Self {
        Self {
            handle,
            phantom_T: PhantomData,
            value,
            lengths,
            flow_in,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(handle: handle_Arg, value: value_Arg, lengths: lengths_Arg, flow_in: flow_in_Arg) -> Edge<f32> {
        Self {
            handle,
            phantom_T: PhantomData,
            value,
            lengths,
            flow_in,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<new_vocab_file_Arg, old_vocab_file_Arg> GraphOperation for GenerateVocabRemapping<new_vocab_file_Arg, old_vocab_file_Arg>
where new_vocab_file_Arg: Clone,
      new_vocab_file_Arg: GraphEdge<String>,
      new_vocab_file_Arg: 'static,
      old_vocab_file_Arg: Clone,
      old_vocab_file_Arg: GraphEdge<String>,
      old_vocab_file_Arg: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("GenerateVocabRemapping_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("GenerateVocabRemapping", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.new_vocab_file)?
        }
        {
            new_op.add_edge(&self.old_vocab_file)?
        }
        {
            (|attr: &i64| {new_op.set_attr_int("new_vocab_offset", *attr)})(&self.new_vocab_offset)?
        }
        {
            (|attr: &i64| {new_op.set_attr_int("num_new_vocab", *attr)})(&self.num_new_vocab)?
        }
        {
            match self.old_vocab_size {
                None => new_op.set_attr_value_proto("old_vocab_size", &vec![24_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 1_u8,])?,
                Some(ref value) => (|attr: &i64| {new_op.set_attr_int("old_vocab_size", *attr)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct GenerateVocabRemapping<new_vocab_file_Arg, old_vocab_file_Arg>
where new_vocab_file_Arg: Clone,
      new_vocab_file_Arg: GraphEdge<String>,
      new_vocab_file_Arg: 'static,
      old_vocab_file_Arg: Clone,
      old_vocab_file_Arg: GraphEdge<String>,
      old_vocab_file_Arg: 'static,
{
    new_vocab_file: new_vocab_file_Arg,
    old_vocab_file: old_vocab_file_Arg,
    new_vocab_offset: i64,
    num_new_vocab: i64,
    old_vocab_size: Option<i64>,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<new_vocab_file_Arg, old_vocab_file_Arg> GenerateVocabRemapping<new_vocab_file_Arg, old_vocab_file_Arg>
where new_vocab_file_Arg: Clone,
      new_vocab_file_Arg: GraphEdge<String>,
      new_vocab_file_Arg: 'static,
      old_vocab_file_Arg: Clone,
      old_vocab_file_Arg: GraphEdge<String>,
      old_vocab_file_Arg: 'static,
{
    pub fn remapping(self) -> Edge<i64> {
        let rc = Rc::new(self);
        {
            Edge::<i64>::new(rc.clone(), 0)
        }
    }

    pub fn num_present(self) -> Edge<i32> {
        let rc = Rc::new(self);
        {
            Edge::<i32>::new(rc.clone(), 1)
        }
    }

    pub fn old_vocab_size(&mut self, old_vocab_size: i64) -> Self {
        self.old_vocab_size = Some(old_vocab_size);
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> (Edge<i64>, Edge<i32>) {
        let rc = Rc::new(self);
        (
        {
            Edge::<i64>::new(rc.clone(), 0)
        },
        {
            Edge::<i32>::new(rc.clone(), 1)
        },
        )
    }

    pub fn build(new_vocab_file: new_vocab_file_Arg, old_vocab_file: old_vocab_file_Arg, new_vocab_offset: i64, num_new_vocab: i64) -> Self {
        Self {
            new_vocab_file,
            old_vocab_file,
            new_vocab_offset: new_vocab_offset,
            num_new_vocab: num_new_vocab,
            old_vocab_size: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(new_vocab_file: new_vocab_file_Arg, old_vocab_file: old_vocab_file_Arg, new_vocab_offset: i64, num_new_vocab: i64) -> (Edge<i64>, Edge<i32>) {
        Self {
            new_vocab_file,
            old_vocab_file,
            new_vocab_offset: new_vocab_offset,
            num_new_vocab: num_new_vocab,
            old_vocab_size: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<topology_Arg> GraphOperation for _SetGlobalTPUArray<topology_Arg>
where topology_Arg: Clone,
      topology_Arg: GraphEdge<String>,
      topology_Arg: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("_SetGlobalTPUArray_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("_SetGlobalTPUArray", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.topology)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct _SetGlobalTPUArray<topology_Arg>
where topology_Arg: Clone,
      topology_Arg: GraphEdge<String>,
      topology_Arg: 'static,
{
    topology: topology_Arg,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<topology_Arg> _SetGlobalTPUArray<topology_Arg>
where topology_Arg: Clone,
      topology_Arg: GraphEdge<String>,
      topology_Arg: 'static,
{
    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> () {
        let rc = Rc::new(self);
        (
        )
    }

    pub fn build(topology: topology_Arg) -> Self {
        Self {
            topology,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(topology: topology_Arg) -> () {
        Self {
            topology,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<handle_Arg, num_required_Arg, dtype> GraphOperation for AccumulatorTakeGradient<handle_Arg, num_required_Arg, dtype>
where handle_Arg: Clone,
      handle_Arg: GraphRefEdge<String>,
      handle_Arg: 'static,
      num_required_Arg: Clone,
      num_required_Arg: GraphEdge<i32>,
      num_required_Arg: 'static,
      dtype: TensorType,
      dtype: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      dtype: 'static,
      dtype: Clone,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("AccumulatorTakeGradient_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("AccumulatorTakeGradient", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.handle)?
        }
        {
            new_op.add_edge(&self.num_required)?
        }
        {
            new_op.set_attr_type("dtype", dtype::data_type())?;
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct AccumulatorTakeGradient<handle_Arg, num_required_Arg, dtype>
where handle_Arg: Clone,
      handle_Arg: GraphRefEdge<String>,
      handle_Arg: 'static,
      num_required_Arg: Clone,
      num_required_Arg: GraphEdge<i32>,
      num_required_Arg: 'static,
      dtype: TensorType,
      dtype: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      dtype: 'static,
      dtype: Clone,
{
    handle: handle_Arg,
    num_required: num_required_Arg,
    phantom_dtype: PhantomData<dtype>,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<handle_Arg, num_required_Arg, dtype> AccumulatorTakeGradient<handle_Arg, num_required_Arg, dtype>
where handle_Arg: Clone,
      handle_Arg: GraphRefEdge<String>,
      handle_Arg: 'static,
      num_required_Arg: Clone,
      num_required_Arg: GraphEdge<i32>,
      num_required_Arg: 'static,
      dtype: TensorType,
      dtype: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      dtype: 'static,
      dtype: Clone,
{
    pub fn average(self) -> Edge<dtype> {
        let rc = Rc::new(self);
        {
            Edge::<dtype>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<dtype> {
        let rc = Rc::new(self);
        {
            Edge::<dtype>::new(rc.clone(), 0)
        }
    }

    pub fn build(handle: handle_Arg, num_required: num_required_Arg) -> Self {
        Self {
            handle,
            num_required,
            phantom_dtype: PhantomData,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(handle: handle_Arg, num_required: num_required_Arg) -> Edge<dtype> {
        Self {
            handle,
            num_required,
            phantom_dtype: PhantomData,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<sparse_indices_Arg, T, sparse_values_Arg, sparse_shape_Arg, out_type> GraphOperation for SerializeSparse<sparse_indices_Arg, T, sparse_values_Arg, sparse_shape_Arg, out_type>
where sparse_indices_Arg: Clone,
      sparse_indices_Arg: GraphEdge<i64>,
      sparse_indices_Arg: 'static,
      T: TensorType,
      T: Clone,
      sparse_values_Arg: Clone,
      sparse_values_Arg: GraphEdge<T>,
      sparse_values_Arg: 'static,
      sparse_shape_Arg: Clone,
      sparse_shape_Arg: GraphEdge<i64>,
      sparse_shape_Arg: 'static,
      out_type: TensorType,
      T: 'static,
      out_type: con_or_DT_STRING_or_DT_VARIANT,
      out_type: 'static,
      out_type: Clone,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("SerializeSparse_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("SerializeSparse", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.sparse_indices)?
        }
        {
            new_op.add_edge(&self.sparse_values)?
        }
        {
            new_op.add_edge(&self.sparse_shape)?
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        {
            new_op.set_attr_type("out_type", out_type::data_type())?;
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct SerializeSparse<sparse_indices_Arg, T, sparse_values_Arg, sparse_shape_Arg, out_type>
where sparse_indices_Arg: Clone,
      sparse_indices_Arg: GraphEdge<i64>,
      sparse_indices_Arg: 'static,
      T: TensorType,
      T: Clone,
      sparse_values_Arg: Clone,
      sparse_values_Arg: GraphEdge<T>,
      sparse_values_Arg: 'static,
      sparse_shape_Arg: Clone,
      sparse_shape_Arg: GraphEdge<i64>,
      sparse_shape_Arg: 'static,
      out_type: TensorType,
      T: 'static,
      out_type: con_or_DT_STRING_or_DT_VARIANT,
      out_type: 'static,
      out_type: Clone,
{
    sparse_indices: sparse_indices_Arg,
    phantom_T: PhantomData<T>,
    sparse_values: sparse_values_Arg,
    sparse_shape: sparse_shape_Arg,
    phantom_out_type: PhantomData<out_type>,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<sparse_indices_Arg, T, sparse_values_Arg, sparse_shape_Arg, out_type> SerializeSparse<sparse_indices_Arg, T, sparse_values_Arg, sparse_shape_Arg, out_type>
where sparse_indices_Arg: Clone,
      sparse_indices_Arg: GraphEdge<i64>,
      sparse_indices_Arg: 'static,
      T: TensorType,
      T: Clone,
      sparse_values_Arg: Clone,
      sparse_values_Arg: GraphEdge<T>,
      sparse_values_Arg: 'static,
      sparse_shape_Arg: Clone,
      sparse_shape_Arg: GraphEdge<i64>,
      sparse_shape_Arg: 'static,
      out_type: TensorType,
      T: 'static,
      out_type: con_or_DT_STRING_or_DT_VARIANT,
      out_type: 'static,
      out_type: Clone,
{
    pub fn serialized_sparse(self) -> Edge<out_type> {
        let rc = Rc::new(self);
        {
            Edge::<out_type>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<out_type> {
        let rc = Rc::new(self);
        {
            Edge::<out_type>::new(rc.clone(), 0)
        }
    }

    pub fn build(sparse_indices: sparse_indices_Arg, sparse_values: sparse_values_Arg, sparse_shape: sparse_shape_Arg) -> Self {
        Self {
            sparse_indices,
            phantom_T: PhantomData,
            sparse_values,
            sparse_shape,
            phantom_out_type: PhantomData,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(sparse_indices: sparse_indices_Arg, sparse_values: sparse_values_Arg, sparse_shape: sparse_shape_Arg) -> Edge<out_type> {
        Self {
            sparse_indices,
            phantom_T: PhantomData,
            sparse_values,
            sparse_shape,
            phantom_out_type: PhantomData,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<true_classes_Arg> GraphOperation for LearnedUnigramCandidateSampler<true_classes_Arg>
where true_classes_Arg: Clone,
      true_classes_Arg: GraphEdge<i64>,
      true_classes_Arg: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("LearnedUnigramCandidateSampler_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("LearnedUnigramCandidateSampler", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.true_classes)?
        }
        {
            (|attr: &i64| {new_op.set_attr_int("num_true", *attr)})(&self.num_true)?
        }
        {
            (|attr: &i64| {new_op.set_attr_int("num_sampled", *attr)})(&self.num_sampled)?
        }
        {
            (|attr: &bool| {new_op.set_attr_bool("unique", *attr)})(&self.unique)?
        }
        {
            (|attr: &i64| {new_op.set_attr_int("range_max", *attr)})(&self.range_max)?
        }
        {
            match self.seed {
                None => new_op.set_attr_value_proto("seed", &vec![24_u8, 0_u8,])?,
                Some(ref value) => (|attr: &i64| {new_op.set_attr_int("seed", *attr)})(&value)?,
            };
        }
        {
            match self.seed2 {
                None => new_op.set_attr_value_proto("seed2", &vec![24_u8, 0_u8,])?,
                Some(ref value) => (|attr: &i64| {new_op.set_attr_int("seed2", *attr)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct LearnedUnigramCandidateSampler<true_classes_Arg>
where true_classes_Arg: Clone,
      true_classes_Arg: GraphEdge<i64>,
      true_classes_Arg: 'static,
{
    true_classes: true_classes_Arg,
    num_true: i64,
    num_sampled: i64,
    unique: bool,
    range_max: i64,
    seed: Option<i64>,
    seed2: Option<i64>,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<true_classes_Arg> LearnedUnigramCandidateSampler<true_classes_Arg>
where true_classes_Arg: Clone,
      true_classes_Arg: GraphEdge<i64>,
      true_classes_Arg: 'static,
{
    pub fn sampled_candidates(self) -> Edge<i64> {
        let rc = Rc::new(self);
        {
            Edge::<i64>::new(rc.clone(), 0)
        }
    }

    pub fn true_expected_count(self) -> Edge<f32> {
        let rc = Rc::new(self);
        {
            Edge::<f32>::new(rc.clone(), 1)
        }
    }

    pub fn sampled_expected_count(self) -> Edge<f32> {
        let rc = Rc::new(self);
        {
            Edge::<f32>::new(rc.clone(), 2)
        }
    }

    pub fn seed(&mut self, seed: i64) -> Self {
        self.seed = Some(seed);
        self.clone()
    }

    pub fn seed2(&mut self, seed2: i64) -> Self {
        self.seed2 = Some(seed2);
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> (Edge<i64>, Edge<f32>, Edge<f32>) {
        let rc = Rc::new(self);
        (
        {
            Edge::<i64>::new(rc.clone(), 0)
        },
        {
            Edge::<f32>::new(rc.clone(), 1)
        },
        {
            Edge::<f32>::new(rc.clone(), 2)
        },
        )
    }

    pub fn build(true_classes: true_classes_Arg, num_true: i64, num_sampled: i64, unique: bool, range_max: i64) -> Self {
        Self {
            true_classes,
            num_true: num_true,
            num_sampled: num_sampled,
            unique: unique,
            range_max: range_max,
            seed: None,
            seed2: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(true_classes: true_classes_Arg, num_true: i64, num_sampled: i64, unique: bool, range_max: i64) -> (Edge<i64>, Edge<f32>, Edge<f32>) {
        Self {
            true_classes,
            num_true: num_true,
            num_sampled: num_sampled,
            unique: unique,
            range_max: range_max,
            seed: None,
            seed2: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

pub trait con_or_DT_FLOAT_or_DT_HALF {
}

impl con_or_DT_FLOAT_or_DT_HALF for f32 {
}

impl<T, images_Arg, boxes_Arg> GraphOperation for DrawBoundingBoxes<T, images_Arg, boxes_Arg>
where T: TensorType,
      T: Clone,
      images_Arg: Clone,
      images_Arg: GraphEdge<T>,
      images_Arg: 'static,
      boxes_Arg: Clone,
      boxes_Arg: GraphEdge<f32>,
      boxes_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_HALF,
      T: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("DrawBoundingBoxes_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("DrawBoundingBoxes", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.images)?
        }
        {
            new_op.add_edge(&self.boxes)?
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct DrawBoundingBoxes<T, images_Arg, boxes_Arg>
where T: TensorType,
      T: Clone,
      images_Arg: Clone,
      images_Arg: GraphEdge<T>,
      images_Arg: 'static,
      boxes_Arg: Clone,
      boxes_Arg: GraphEdge<f32>,
      boxes_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_HALF,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    images: images_Arg,
    boxes: boxes_Arg,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<T, images_Arg, boxes_Arg> DrawBoundingBoxes<T, images_Arg, boxes_Arg>
where T: TensorType,
      T: Clone,
      images_Arg: Clone,
      images_Arg: GraphEdge<T>,
      images_Arg: 'static,
      boxes_Arg: Clone,
      boxes_Arg: GraphEdge<f32>,
      boxes_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_HALF,
      T: 'static,
{
    pub fn output(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(images: images_Arg, boxes: boxes_Arg) -> Self {
        Self {
            phantom_T: PhantomData,
            images,
            boxes,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(images: images_Arg, boxes: boxes_Arg) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            images,
            boxes,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<T, input_Arg, init_value_Arg, Tindices, window_dimensions_Arg, window_strides_Arg, base_dilations_Arg, window_dilations_Arg, padding_Arg> GraphOperation for XlaReduceWindow<T, input_Arg, init_value_Arg, Tindices, window_dimensions_Arg, window_strides_Arg, base_dilations_Arg, window_dilations_Arg, padding_Arg>
where T: TensorType,
      T: Clone,
      input_Arg: Clone,
      input_Arg: GraphEdge<T>,
      input_Arg: 'static,
      init_value_Arg: Clone,
      init_value_Arg: GraphEdge<T>,
      init_value_Arg: 'static,
      Tindices: TensorType,
      Tindices: Clone,
      window_dimensions_Arg: Clone,
      window_dimensions_Arg: GraphEdge<Tindices>,
      window_dimensions_Arg: 'static,
      window_strides_Arg: Clone,
      window_strides_Arg: GraphEdge<Tindices>,
      window_strides_Arg: 'static,
      base_dilations_Arg: Clone,
      base_dilations_Arg: GraphEdge<Tindices>,
      base_dilations_Arg: 'static,
      window_dilations_Arg: Clone,
      window_dilations_Arg: GraphEdge<Tindices>,
      window_dilations_Arg: 'static,
      padding_Arg: Clone,
      padding_Arg: GraphEdge<Tindices>,
      padding_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
      Tindices: con_or_DT_INT32_or_DT_INT64,
      Tindices: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("XlaReduceWindow_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("XlaReduceWindow", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.input)?
        }
        {
            new_op.add_edge(&self.init_value)?
        }
        {
            new_op.add_edge(&self.window_dimensions)?
        }
        {
            new_op.add_edge(&self.window_strides)?
        }
        {
            new_op.add_edge(&self.base_dilations)?
        }
        {
            new_op.add_edge(&self.window_dilations)?
        }
        {
            new_op.add_edge(&self.padding)?
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        {
            new_op.set_attr_type("Tindices", Tindices::data_type())?;
        }
        {
            (|attr| {new_op.set_attr_func_name("computation", attr)})(&self.computation)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct XlaReduceWindow<T, input_Arg, init_value_Arg, Tindices, window_dimensions_Arg, window_strides_Arg, base_dilations_Arg, window_dilations_Arg, padding_Arg>
where T: TensorType,
      T: Clone,
      input_Arg: Clone,
      input_Arg: GraphEdge<T>,
      input_Arg: 'static,
      init_value_Arg: Clone,
      init_value_Arg: GraphEdge<T>,
      init_value_Arg: 'static,
      Tindices: TensorType,
      Tindices: Clone,
      window_dimensions_Arg: Clone,
      window_dimensions_Arg: GraphEdge<Tindices>,
      window_dimensions_Arg: 'static,
      window_strides_Arg: Clone,
      window_strides_Arg: GraphEdge<Tindices>,
      window_strides_Arg: 'static,
      base_dilations_Arg: Clone,
      base_dilations_Arg: GraphEdge<Tindices>,
      base_dilations_Arg: 'static,
      window_dilations_Arg: Clone,
      window_dilations_Arg: GraphEdge<Tindices>,
      window_dilations_Arg: 'static,
      padding_Arg: Clone,
      padding_Arg: GraphEdge<Tindices>,
      padding_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
      Tindices: con_or_DT_INT32_or_DT_INT64,
      Tindices: 'static,
{
    phantom_T: PhantomData<T>,
    input: input_Arg,
    init_value: init_value_Arg,
    phantom_Tindices: PhantomData<Tindices>,
    window_dimensions: window_dimensions_Arg,
    window_strides: window_strides_Arg,
    base_dilations: base_dilations_Arg,
    window_dilations: window_dilations_Arg,
    padding: padding_Arg,
    computation: String,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<T, input_Arg, init_value_Arg, Tindices, window_dimensions_Arg, window_strides_Arg, base_dilations_Arg, window_dilations_Arg, padding_Arg> XlaReduceWindow<T, input_Arg, init_value_Arg, Tindices, window_dimensions_Arg, window_strides_Arg, base_dilations_Arg, window_dilations_Arg, padding_Arg>
where T: TensorType,
      T: Clone,
      input_Arg: Clone,
      input_Arg: GraphEdge<T>,
      input_Arg: 'static,
      init_value_Arg: Clone,
      init_value_Arg: GraphEdge<T>,
      init_value_Arg: 'static,
      Tindices: TensorType,
      Tindices: Clone,
      window_dimensions_Arg: Clone,
      window_dimensions_Arg: GraphEdge<Tindices>,
      window_dimensions_Arg: 'static,
      window_strides_Arg: Clone,
      window_strides_Arg: GraphEdge<Tindices>,
      window_strides_Arg: 'static,
      base_dilations_Arg: Clone,
      base_dilations_Arg: GraphEdge<Tindices>,
      base_dilations_Arg: 'static,
      window_dilations_Arg: Clone,
      window_dilations_Arg: GraphEdge<Tindices>,
      window_dilations_Arg: 'static,
      padding_Arg: Clone,
      padding_Arg: GraphEdge<Tindices>,
      padding_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
      Tindices: con_or_DT_INT32_or_DT_INT64,
      Tindices: 'static,
{
    pub fn output(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(input: input_Arg, init_value: init_value_Arg, window_dimensions: window_dimensions_Arg, window_strides: window_strides_Arg, base_dilations: base_dilations_Arg, window_dilations: window_dilations_Arg, padding: padding_Arg, computation: &str) -> Self {
        Self {
            phantom_T: PhantomData,
            input,
            init_value,
            phantom_Tindices: PhantomData,
            window_dimensions,
            window_strides,
            base_dilations,
            window_dilations,
            padding,
            computation: computation.to_string(),
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(input: input_Arg, init_value: init_value_Arg, window_dimensions: window_dimensions_Arg, window_strides: window_strides_Arg, base_dilations: base_dilations_Arg, window_dilations: window_dilations_Arg, padding: padding_Arg, computation: &str) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            input,
            init_value,
            phantom_Tindices: PhantomData,
            window_dimensions,
            window_strides,
            base_dilations,
            window_dilations,
            padding,
            computation: computation.to_string(),
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<T, operand_Arg, Tindices, window_dimensions_Arg, window_strides_Arg, padding_Arg, source_Arg, init_value_Arg> GraphOperation for XlaSelectAndScatter<T, operand_Arg, Tindices, window_dimensions_Arg, window_strides_Arg, padding_Arg, source_Arg, init_value_Arg>
where T: TensorType,
      T: Clone,
      operand_Arg: Clone,
      operand_Arg: GraphEdge<T>,
      operand_Arg: 'static,
      Tindices: TensorType,
      Tindices: Clone,
      window_dimensions_Arg: Clone,
      window_dimensions_Arg: GraphEdge<Tindices>,
      window_dimensions_Arg: 'static,
      window_strides_Arg: Clone,
      window_strides_Arg: GraphEdge<Tindices>,
      window_strides_Arg: 'static,
      padding_Arg: Clone,
      padding_Arg: GraphEdge<Tindices>,
      padding_Arg: 'static,
      source_Arg: Clone,
      source_Arg: GraphEdge<T>,
      source_Arg: 'static,
      init_value_Arg: Clone,
      init_value_Arg: GraphEdge<T>,
      init_value_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
      Tindices: con_or_DT_INT32_or_DT_INT64,
      Tindices: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("XlaSelectAndScatter_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("XlaSelectAndScatter", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.operand)?
        }
        {
            new_op.add_edge(&self.window_dimensions)?
        }
        {
            new_op.add_edge(&self.window_strides)?
        }
        {
            new_op.add_edge(&self.padding)?
        }
        {
            new_op.add_edge(&self.source)?
        }
        {
            new_op.add_edge(&self.init_value)?
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        {
            new_op.set_attr_type("Tindices", Tindices::data_type())?;
        }
        {
            (|attr| {new_op.set_attr_func_name("select", attr)})(&self.select)?
        }
        {
            (|attr| {new_op.set_attr_func_name("scatter", attr)})(&self.scatter)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct XlaSelectAndScatter<T, operand_Arg, Tindices, window_dimensions_Arg, window_strides_Arg, padding_Arg, source_Arg, init_value_Arg>
where T: TensorType,
      T: Clone,
      operand_Arg: Clone,
      operand_Arg: GraphEdge<T>,
      operand_Arg: 'static,
      Tindices: TensorType,
      Tindices: Clone,
      window_dimensions_Arg: Clone,
      window_dimensions_Arg: GraphEdge<Tindices>,
      window_dimensions_Arg: 'static,
      window_strides_Arg: Clone,
      window_strides_Arg: GraphEdge<Tindices>,
      window_strides_Arg: 'static,
      padding_Arg: Clone,
      padding_Arg: GraphEdge<Tindices>,
      padding_Arg: 'static,
      source_Arg: Clone,
      source_Arg: GraphEdge<T>,
      source_Arg: 'static,
      init_value_Arg: Clone,
      init_value_Arg: GraphEdge<T>,
      init_value_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
      Tindices: con_or_DT_INT32_or_DT_INT64,
      Tindices: 'static,
{
    phantom_T: PhantomData<T>,
    operand: operand_Arg,
    phantom_Tindices: PhantomData<Tindices>,
    window_dimensions: window_dimensions_Arg,
    window_strides: window_strides_Arg,
    padding: padding_Arg,
    source: source_Arg,
    init_value: init_value_Arg,
    select: String,
    scatter: String,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<T, operand_Arg, Tindices, window_dimensions_Arg, window_strides_Arg, padding_Arg, source_Arg, init_value_Arg> XlaSelectAndScatter<T, operand_Arg, Tindices, window_dimensions_Arg, window_strides_Arg, padding_Arg, source_Arg, init_value_Arg>
where T: TensorType,
      T: Clone,
      operand_Arg: Clone,
      operand_Arg: GraphEdge<T>,
      operand_Arg: 'static,
      Tindices: TensorType,
      Tindices: Clone,
      window_dimensions_Arg: Clone,
      window_dimensions_Arg: GraphEdge<Tindices>,
      window_dimensions_Arg: 'static,
      window_strides_Arg: Clone,
      window_strides_Arg: GraphEdge<Tindices>,
      window_strides_Arg: 'static,
      padding_Arg: Clone,
      padding_Arg: GraphEdge<Tindices>,
      padding_Arg: 'static,
      source_Arg: Clone,
      source_Arg: GraphEdge<T>,
      source_Arg: 'static,
      init_value_Arg: Clone,
      init_value_Arg: GraphEdge<T>,
      init_value_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
      Tindices: con_or_DT_INT32_or_DT_INT64,
      Tindices: 'static,
{
    pub fn output(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(operand: operand_Arg, window_dimensions: window_dimensions_Arg, window_strides: window_strides_Arg, padding: padding_Arg, source: source_Arg, init_value: init_value_Arg, select: &str, scatter: &str) -> Self {
        Self {
            phantom_T: PhantomData,
            operand,
            phantom_Tindices: PhantomData,
            window_dimensions,
            window_strides,
            padding,
            source,
            init_value,
            select: select.to_string(),
            scatter: scatter.to_string(),
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(operand: operand_Arg, window_dimensions: window_dimensions_Arg, window_strides: window_strides_Arg, padding: padding_Arg, source: source_Arg, init_value: init_value_Arg, select: &str, scatter: &str) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            operand,
            phantom_Tindices: PhantomData,
            window_dimensions,
            window_strides,
            padding,
            source,
            init_value,
            select: select.to_string(),
            scatter: scatter.to_string(),
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl GraphOperation for RetrieveTPUEmbeddingAdadeltaParametersGradAccumDebug {
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("RetrieveTPUEmbeddingAdadeltaParametersGradAccumDebug_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("RetrieveTPUEmbeddingAdadeltaParametersGradAccumDebug", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            match self.table_id {
                None => new_op.set_attr_value_proto("table_id", &vec![24_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 1_u8,])?,
                Some(ref value) => (|attr: &i64| {new_op.set_attr_int("table_id", *attr)})(&value)?,
            };
        }
        {
            match self.table_name {
                None => new_op.set_attr_value_proto("table_name", &vec![18_u8, 0_u8,])?,
                Some(ref value) => (|attr| {new_op.set_attr_string("table_name", attr)})(&value)?,
            };
        }
        {
            (|attr: &i64| {new_op.set_attr_int("num_shards", *attr)})(&self.num_shards)?
        }
        {
            (|attr: &i64| {new_op.set_attr_int("shard_id", *attr)})(&self.shard_id)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct RetrieveTPUEmbeddingAdadeltaParametersGradAccumDebug {
    table_id: Option<i64>,
    table_name: Option<String>,
    num_shards: i64,
    shard_id: i64,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl RetrieveTPUEmbeddingAdadeltaParametersGradAccumDebug {
    pub fn parameters(self) -> Edge<f32> {
        let rc = Rc::new(self);
        {
            Edge::<f32>::new(rc.clone(), 0)
        }
    }

    pub fn accumulators(self) -> Edge<f32> {
        let rc = Rc::new(self);
        {
            Edge::<f32>::new(rc.clone(), 1)
        }
    }

    pub fn updates(self) -> Edge<f32> {
        let rc = Rc::new(self);
        {
            Edge::<f32>::new(rc.clone(), 2)
        }
    }

    pub fn gradient_accumulators(self) -> Edge<f32> {
        let rc = Rc::new(self);
        {
            Edge::<f32>::new(rc.clone(), 3)
        }
    }

    pub fn table_id(&mut self, table_id: i64) -> Self {
        self.table_id = Some(table_id);
        self.clone()
    }

    pub fn table_name(&mut self, table_name: &str) -> Self {
        self.table_name = Some(table_name.to_string());
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> (Edge<f32>, Edge<f32>, Edge<f32>, Edge<f32>) {
        let rc = Rc::new(self);
        (
        {
            Edge::<f32>::new(rc.clone(), 0)
        },
        {
            Edge::<f32>::new(rc.clone(), 1)
        },
        {
            Edge::<f32>::new(rc.clone(), 2)
        },
        {
            Edge::<f32>::new(rc.clone(), 3)
        },
        )
    }

    pub fn build(num_shards: i64, shard_id: i64) -> Self {
        Self {
            table_id: None,
            table_name: None,
            num_shards: num_shards,
            shard_id: shard_id,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(num_shards: i64, shard_id: i64) -> (Edge<f32>, Edge<f32>, Edge<f32>, Edge<f32>) {
        Self {
            table_id: None,
            table_name: None,
            num_shards: num_shards,
            shard_id: shard_id,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<T, data_Arg> GraphOperation for RefNextIteration<T, data_Arg>
where T: TensorType,
      T: Clone,
      data_Arg: Clone,
      data_Arg: GraphRefEdge<T>,
      data_Arg: 'static,
      T: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("RefNextIteration_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("RefNextIteration", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.data)?
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct RefNextIteration<T, data_Arg>
where T: TensorType,
      T: Clone,
      data_Arg: Clone,
      data_Arg: GraphRefEdge<T>,
      data_Arg: 'static,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    data: data_Arg,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<T, data_Arg> RefNextIteration<T, data_Arg>
where T: TensorType,
      T: Clone,
      data_Arg: Clone,
      data_Arg: GraphRefEdge<T>,
      data_Arg: 'static,
      T: 'static,
{
    pub fn output(self) -> RefEdge<T> {
        let rc = Rc::new(self);
        {
            RefEdge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> RefEdge<T> {
        let rc = Rc::new(self);
        {
            RefEdge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(data: data_Arg) -> Self {
        Self {
            phantom_T: PhantomData,
            data,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(data: data_Arg) -> RefEdge<T> {
        Self {
            phantom_T: PhantomData,
            data,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<T, x_Arg> GraphOperation for ZerosLike<T, x_Arg>
where T: TensorType,
      T: Clone,
      x_Arg: Clone,
      x_Arg: GraphEdge<T>,
      x_Arg: 'static,
      T: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("ZerosLike_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("ZerosLike", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.x)?
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct ZerosLike<T, x_Arg>
where T: TensorType,
      T: Clone,
      x_Arg: Clone,
      x_Arg: GraphEdge<T>,
      x_Arg: 'static,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    x: x_Arg,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<T, x_Arg> ZerosLike<T, x_Arg>
where T: TensorType,
      T: Clone,
      x_Arg: Clone,
      x_Arg: GraphEdge<T>,
      x_Arg: 'static,
      T: 'static,
{
    pub fn y(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(x: x_Arg) -> Self {
        Self {
            phantom_T: PhantomData,
            x,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(x: x_Arg) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            x,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<sample_indices_Arg, embedding_indices_Arg, aggregation_weights_Arg, mode_override_Arg> GraphOperation for EnqueueTPUEmbeddingSparseBatch<sample_indices_Arg, embedding_indices_Arg, aggregation_weights_Arg, mode_override_Arg>
where sample_indices_Arg: Clone,
      sample_indices_Arg: GraphEdge<i32>,
      sample_indices_Arg: 'static,
      embedding_indices_Arg: Clone,
      embedding_indices_Arg: GraphEdge<i32>,
      embedding_indices_Arg: 'static,
      aggregation_weights_Arg: Clone,
      aggregation_weights_Arg: GraphEdge<f32>,
      aggregation_weights_Arg: 'static,
      mode_override_Arg: Clone,
      mode_override_Arg: GraphEdge<String>,
      mode_override_Arg: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("EnqueueTPUEmbeddingSparseBatch_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("EnqueueTPUEmbeddingSparseBatch", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.sample_indices)?
        }
        {
            new_op.add_edge(&self.embedding_indices)?
        }
        {
            new_op.add_edge(&self.aggregation_weights)?
        }
        {
            new_op.add_edge(&self.mode_override)?
        }
        {
            (|attr: &i64| {new_op.set_attr_int("N", *attr)})(&self.N)?
        }
        {
            match self.device_ordinal {
                None => new_op.set_attr_value_proto("device_ordinal", &vec![24_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 1_u8,])?,
                Some(ref value) => (|attr: &i64| {new_op.set_attr_int("device_ordinal", *attr)})(&value)?,
            };
        }
        {
            match self.combiners {
                None => new_op.set_attr_value_proto("combiners", &vec![10_u8, 0_u8,])?,
                Some(ref value) => (|attrs| {new_op.set_attr_string_list("combiners", attrs)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct EnqueueTPUEmbeddingSparseBatch<sample_indices_Arg, embedding_indices_Arg, aggregation_weights_Arg, mode_override_Arg>
where sample_indices_Arg: Clone,
      sample_indices_Arg: GraphEdge<i32>,
      sample_indices_Arg: 'static,
      embedding_indices_Arg: Clone,
      embedding_indices_Arg: GraphEdge<i32>,
      embedding_indices_Arg: 'static,
      aggregation_weights_Arg: Clone,
      aggregation_weights_Arg: GraphEdge<f32>,
      aggregation_weights_Arg: 'static,
      mode_override_Arg: Clone,
      mode_override_Arg: GraphEdge<String>,
      mode_override_Arg: 'static,
{
    sample_indices: sample_indices_Arg,
    embedding_indices: embedding_indices_Arg,
    aggregation_weights: aggregation_weights_Arg,
    mode_override: mode_override_Arg,
    N: i64,
    device_ordinal: Option<i64>,
    combiners: Option<Vec<String>>,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<sample_indices_Arg, embedding_indices_Arg, aggregation_weights_Arg, mode_override_Arg> EnqueueTPUEmbeddingSparseBatch<sample_indices_Arg, embedding_indices_Arg, aggregation_weights_Arg, mode_override_Arg>
where sample_indices_Arg: Clone,
      sample_indices_Arg: GraphEdge<i32>,
      sample_indices_Arg: 'static,
      embedding_indices_Arg: Clone,
      embedding_indices_Arg: GraphEdge<i32>,
      embedding_indices_Arg: 'static,
      aggregation_weights_Arg: Clone,
      aggregation_weights_Arg: GraphEdge<f32>,
      aggregation_weights_Arg: 'static,
      mode_override_Arg: Clone,
      mode_override_Arg: GraphEdge<String>,
      mode_override_Arg: 'static,
{
    pub fn device_ordinal(&mut self, device_ordinal: i64) -> Self {
        self.device_ordinal = Some(device_ordinal);
        self.clone()
    }

    pub fn combiners(&mut self, combiners: &[String]) -> Self {
        self.combiners = Some(combiners.to_vec());
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> () {
        let rc = Rc::new(self);
        (
        )
    }

    pub fn build(sample_indices: sample_indices_Arg, embedding_indices: embedding_indices_Arg, aggregation_weights: aggregation_weights_Arg, mode_override: mode_override_Arg, N: i64) -> Self {
        Self {
            sample_indices,
            embedding_indices,
            aggregation_weights,
            mode_override,
            N: N,
            device_ordinal: None,
            combiners: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(sample_indices: sample_indices_Arg, embedding_indices: embedding_indices_Arg, aggregation_weights: aggregation_weights_Arg, mode_override: mode_override_Arg, N: i64) -> () {
        Self {
            sample_indices,
            embedding_indices,
            aggregation_weights,
            mode_override,
            N: N,
            device_ordinal: None,
            combiners: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<T, x_Arg, Taxis, axis_Arg, out_idx> GraphOperation for UniqueV2<T, x_Arg, Taxis, axis_Arg, out_idx>
where T: TensorType,
      T: Clone,
      x_Arg: Clone,
      x_Arg: GraphEdge<T>,
      x_Arg: 'static,
      Taxis: TensorType,
      Taxis: Clone,
      axis_Arg: Clone,
      axis_Arg: GraphEdge<Taxis>,
      axis_Arg: 'static,
      out_idx: TensorType,
      T: 'static,
      Taxis: con_or_DT_INT32_or_DT_INT64,
      Taxis: 'static,
      out_idx: con_or_DT_INT32_or_DT_INT64,
      out_idx: 'static,
      out_idx: Clone,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("UniqueV2_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("UniqueV2", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.x)?
        }
        {
            new_op.add_edge(&self.axis)?
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        {
            new_op.set_attr_type("Taxis", Taxis::data_type())?;
        }
        {
            new_op.set_attr_type("out_idx", out_idx::data_type())?;
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct UniqueV2<T, x_Arg, Taxis, axis_Arg, out_idx>
where T: TensorType,
      T: Clone,
      x_Arg: Clone,
      x_Arg: GraphEdge<T>,
      x_Arg: 'static,
      Taxis: TensorType,
      Taxis: Clone,
      axis_Arg: Clone,
      axis_Arg: GraphEdge<Taxis>,
      axis_Arg: 'static,
      out_idx: TensorType,
      T: 'static,
      Taxis: con_or_DT_INT32_or_DT_INT64,
      Taxis: 'static,
      out_idx: con_or_DT_INT32_or_DT_INT64,
      out_idx: 'static,
      out_idx: Clone,
{
    phantom_T: PhantomData<T>,
    x: x_Arg,
    phantom_Taxis: PhantomData<Taxis>,
    axis: axis_Arg,
    phantom_out_idx: PhantomData<out_idx>,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<T, x_Arg, Taxis, axis_Arg, out_idx> UniqueV2<T, x_Arg, Taxis, axis_Arg, out_idx>
where T: TensorType,
      T: Clone,
      x_Arg: Clone,
      x_Arg: GraphEdge<T>,
      x_Arg: 'static,
      Taxis: TensorType,
      Taxis: Clone,
      axis_Arg: Clone,
      axis_Arg: GraphEdge<Taxis>,
      axis_Arg: 'static,
      out_idx: TensorType,
      T: 'static,
      Taxis: con_or_DT_INT32_or_DT_INT64,
      Taxis: 'static,
      out_idx: con_or_DT_INT32_or_DT_INT64,
      out_idx: 'static,
      out_idx: Clone,
{
    pub fn y(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn idx(self) -> Edge<out_idx> {
        let rc = Rc::new(self);
        {
            Edge::<out_idx>::new(rc.clone(), 1)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> (Edge<T>, Edge<out_idx>) {
        let rc = Rc::new(self);
        (
        {
            Edge::<T>::new(rc.clone(), 0)
        },
        {
            Edge::<out_idx>::new(rc.clone(), 1)
        },
        )
    }

    pub fn build(x: x_Arg, axis: axis_Arg) -> Self {
        Self {
            phantom_T: PhantomData,
            x,
            phantom_Taxis: PhantomData,
            axis,
            phantom_out_idx: PhantomData,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(x: x_Arg, axis: axis_Arg) -> (Edge<T>, Edge<out_idx>) {
        Self {
            phantom_T: PhantomData,
            x,
            phantom_Taxis: PhantomData,
            axis,
            phantom_out_idx: PhantomData,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<T, x_Arg, i_Arg, v_Arg> GraphOperation for InplaceAdd<T, x_Arg, i_Arg, v_Arg>
where T: TensorType,
      T: Clone,
      x_Arg: Clone,
      x_Arg: GraphEdge<T>,
      x_Arg: 'static,
      i_Arg: Clone,
      i_Arg: GraphEdge<i32>,
      i_Arg: 'static,
      v_Arg: Clone,
      v_Arg: GraphEdge<T>,
      v_Arg: 'static,
      T: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("InplaceAdd_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("InplaceAdd", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.x)?
        }
        {
            new_op.add_edge(&self.i)?
        }
        {
            new_op.add_edge(&self.v)?
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct InplaceAdd<T, x_Arg, i_Arg, v_Arg>
where T: TensorType,
      T: Clone,
      x_Arg: Clone,
      x_Arg: GraphEdge<T>,
      x_Arg: 'static,
      i_Arg: Clone,
      i_Arg: GraphEdge<i32>,
      i_Arg: 'static,
      v_Arg: Clone,
      v_Arg: GraphEdge<T>,
      v_Arg: 'static,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    x: x_Arg,
    i: i_Arg,
    v: v_Arg,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<T, x_Arg, i_Arg, v_Arg> InplaceAdd<T, x_Arg, i_Arg, v_Arg>
where T: TensorType,
      T: Clone,
      x_Arg: Clone,
      x_Arg: GraphEdge<T>,
      x_Arg: 'static,
      i_Arg: Clone,
      i_Arg: GraphEdge<i32>,
      i_Arg: 'static,
      v_Arg: Clone,
      v_Arg: GraphEdge<T>,
      v_Arg: 'static,
      T: 'static,
{
    pub fn y(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(x: x_Arg, i: i_Arg, v: v_Arg) -> Self {
        Self {
            phantom_T: PhantomData,
            x,
            i,
            v,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(x: x_Arg, i: i_Arg, v: v_Arg) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            x,
            i,
            v,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<x_Arg, y_Arg> GraphOperation for LogicalOr<x_Arg, y_Arg>
where x_Arg: Clone,
      x_Arg: GraphEdge<bool>,
      x_Arg: 'static,
      y_Arg: Clone,
      y_Arg: GraphEdge<bool>,
      y_Arg: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("LogicalOr_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("LogicalOr", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.x)?
        }
        {
            new_op.add_edge(&self.y)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct LogicalOr<x_Arg, y_Arg>
where x_Arg: Clone,
      x_Arg: GraphEdge<bool>,
      x_Arg: 'static,
      y_Arg: Clone,
      y_Arg: GraphEdge<bool>,
      y_Arg: 'static,
{
    x: x_Arg,
    y: y_Arg,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<x_Arg, y_Arg> LogicalOr<x_Arg, y_Arg>
where x_Arg: Clone,
      x_Arg: GraphEdge<bool>,
      x_Arg: 'static,
      y_Arg: Clone,
      y_Arg: GraphEdge<bool>,
      y_Arg: 'static,
{
    pub fn z(self) -> Edge<bool> {
        let rc = Rc::new(self);
        {
            Edge::<bool>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<bool> {
        let rc = Rc::new(self);
        {
            Edge::<bool>::new(rc.clone(), 0)
        }
    }

    pub fn build(x: x_Arg, y: y_Arg) -> Self {
        Self {
            x,
            y,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(x: x_Arg, y: y_Arg) -> Edge<bool> {
        Self {
            x,
            y,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<T, a_Arg, x_Arg> GraphOperation for IgammaGradA<T, a_Arg, x_Arg>
where T: TensorType,
      T: Clone,
      a_Arg: Clone,
      a_Arg: GraphEdge<T>,
      a_Arg: 'static,
      x_Arg: Clone,
      x_Arg: GraphEdge<T>,
      x_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE,
      T: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("IgammaGradA_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("IgammaGradA", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.a)?
        }
        {
            new_op.add_edge(&self.x)?
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct IgammaGradA<T, a_Arg, x_Arg>
where T: TensorType,
      T: Clone,
      a_Arg: Clone,
      a_Arg: GraphEdge<T>,
      a_Arg: 'static,
      x_Arg: Clone,
      x_Arg: GraphEdge<T>,
      x_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    a: a_Arg,
    x: x_Arg,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<T, a_Arg, x_Arg> IgammaGradA<T, a_Arg, x_Arg>
where T: TensorType,
      T: Clone,
      a_Arg: Clone,
      a_Arg: GraphEdge<T>,
      a_Arg: 'static,
      x_Arg: Clone,
      x_Arg: GraphEdge<T>,
      x_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE,
      T: 'static,
{
    pub fn z(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(a: a_Arg, x: x_Arg) -> Self {
        Self {
            phantom_T: PhantomData,
            a,
            x,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(a: a_Arg, x: x_Arg) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            a,
            x,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<sparse_handles_Arg, dtype> GraphOperation for TakeManySparseFromTensorsMap<sparse_handles_Arg, dtype>
where sparse_handles_Arg: Clone,
      sparse_handles_Arg: GraphEdge<i64>,
      sparse_handles_Arg: 'static,
      dtype: TensorType,
      dtype: 'static,
      dtype: Clone,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("TakeManySparseFromTensorsMap_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("TakeManySparseFromTensorsMap", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.sparse_handles)?
        }
        {
            new_op.set_attr_type("dtype", dtype::data_type())?;
        }
        {
            match self.container {
                None => new_op.set_attr_value_proto("container", &vec![18_u8, 0_u8,])?,
                Some(ref value) => (|attr| {new_op.set_attr_string("container", attr)})(&value)?,
            };
        }
        {
            match self.shared_name {
                None => new_op.set_attr_value_proto("shared_name", &vec![18_u8, 0_u8,])?,
                Some(ref value) => (|attr| {new_op.set_attr_string("shared_name", attr)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct TakeManySparseFromTensorsMap<sparse_handles_Arg, dtype>
where sparse_handles_Arg: Clone,
      sparse_handles_Arg: GraphEdge<i64>,
      sparse_handles_Arg: 'static,
      dtype: TensorType,
      dtype: 'static,
      dtype: Clone,
{
    sparse_handles: sparse_handles_Arg,
    phantom_dtype: PhantomData<dtype>,
    container: Option<String>,
    shared_name: Option<String>,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<sparse_handles_Arg, dtype> TakeManySparseFromTensorsMap<sparse_handles_Arg, dtype>
where sparse_handles_Arg: Clone,
      sparse_handles_Arg: GraphEdge<i64>,
      sparse_handles_Arg: 'static,
      dtype: TensorType,
      dtype: 'static,
      dtype: Clone,
{
    pub fn sparse_indices(self) -> Edge<i64> {
        let rc = Rc::new(self);
        {
            Edge::<i64>::new(rc.clone(), 0)
        }
    }

    pub fn sparse_values(self) -> Edge<dtype> {
        let rc = Rc::new(self);
        {
            Edge::<dtype>::new(rc.clone(), 1)
        }
    }

    pub fn sparse_shape(self) -> Edge<i64> {
        let rc = Rc::new(self);
        {
            Edge::<i64>::new(rc.clone(), 2)
        }
    }

    pub fn container(&mut self, container: &str) -> Self {
        self.container = Some(container.to_string());
        self.clone()
    }

    pub fn shared_name(&mut self, shared_name: &str) -> Self {
        self.shared_name = Some(shared_name.to_string());
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> (Edge<i64>, Edge<dtype>, Edge<i64>) {
        let rc = Rc::new(self);
        (
        {
            Edge::<i64>::new(rc.clone(), 0)
        },
        {
            Edge::<dtype>::new(rc.clone(), 1)
        },
        {
            Edge::<i64>::new(rc.clone(), 2)
        },
        )
    }

    pub fn build(sparse_handles: sparse_handles_Arg) -> Self {
        Self {
            sparse_handles,
            phantom_dtype: PhantomData,
            container: None,
            shared_name: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(sparse_handles: sparse_handles_Arg) -> (Edge<i64>, Edge<dtype>, Edge<i64>) {
        Self {
            sparse_handles,
            phantom_dtype: PhantomData,
            container: None,
            shared_name: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<dtype> GraphOperation for Const<dtype>
where dtype: TensorType,
      dtype: 'static,
      dtype: Clone,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("Const_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("Const", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            (|attr: &Rc<AnyTensor>| {new_op.set_attr_tensor_owned("value", attr.clone())})(&self.value)?
        }
        {
            new_op.set_attr_type("dtype", dtype::data_type())?;
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct Const<dtype>
where dtype: TensorType,
      dtype: 'static,
      dtype: Clone,
{
    value: Rc<AnyTensor>,
    phantom_dtype: PhantomData<dtype>,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<dtype> Const<dtype>
where dtype: TensorType,
      dtype: 'static,
      dtype: Clone,
{
    pub fn output(self) -> Edge<dtype> {
        let rc = Rc::new(self);
        {
            Edge::<dtype>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<dtype> {
        let rc = Rc::new(self);
        {
            Edge::<dtype>::new(rc.clone(), 0)
        }
    }

    pub fn build<value_T, value_TensorType>(value: value_T) -> Self
    where Tensor<value_TensorType>: From<value_T>,
          value_T: 'static,
          value_TensorType: TensorType,
    {
        Self {
            value: Rc::new(Tensor::<value_TensorType>::from(value)),
            phantom_dtype: PhantomData,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new<value_T, value_TensorType>(value: value_T) -> Edge<dtype>
    where Tensor<value_TensorType>: From<value_T>,
          value_T: 'static,
          value_TensorType: TensorType,
    {
        Self {
            value: Rc::new(Tensor::<value_TensorType>::from(value)),
            phantom_dtype: PhantomData,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<sample_indices_Arg, embedding_indices_Arg, aggregation_weights_Arg, mode_override_Arg> GraphOperation for EnqueueTPUEmbeddingSparseTensorBatch<sample_indices_Arg, embedding_indices_Arg, aggregation_weights_Arg, mode_override_Arg>
where sample_indices_Arg: Clone,
      sample_indices_Arg: GraphEdge<i32>,
      sample_indices_Arg: 'static,
      embedding_indices_Arg: Clone,
      embedding_indices_Arg: GraphEdge<i32>,
      embedding_indices_Arg: 'static,
      aggregation_weights_Arg: Clone,
      aggregation_weights_Arg: GraphEdge<f32>,
      aggregation_weights_Arg: 'static,
      mode_override_Arg: Clone,
      mode_override_Arg: GraphEdge<String>,
      mode_override_Arg: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("EnqueueTPUEmbeddingSparseTensorBatch_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("EnqueueTPUEmbeddingSparseTensorBatch", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.sample_indices)?
        }
        {
            new_op.add_edge(&self.embedding_indices)?
        }
        {
            new_op.add_edge(&self.aggregation_weights)?
        }
        {
            new_op.add_edge(&self.mode_override)?
        }
        {
            (|attr: &i64| {new_op.set_attr_int("N", *attr)})(&self.N)?
        }
        {
            match self.device_ordinal {
                None => new_op.set_attr_value_proto("device_ordinal", &vec![24_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 1_u8,])?,
                Some(ref value) => (|attr: &i64| {new_op.set_attr_int("device_ordinal", *attr)})(&value)?,
            };
        }
        {
            match self.combiners {
                None => new_op.set_attr_value_proto("combiners", &vec![10_u8, 0_u8,])?,
                Some(ref value) => (|attrs| {new_op.set_attr_string_list("combiners", attrs)})(&value)?,
            };
        }
        {
            (|attrs| {new_op.set_attr_int_list("table_ids", attrs)})(&self.table_ids)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct EnqueueTPUEmbeddingSparseTensorBatch<sample_indices_Arg, embedding_indices_Arg, aggregation_weights_Arg, mode_override_Arg>
where sample_indices_Arg: Clone,
      sample_indices_Arg: GraphEdge<i32>,
      sample_indices_Arg: 'static,
      embedding_indices_Arg: Clone,
      embedding_indices_Arg: GraphEdge<i32>,
      embedding_indices_Arg: 'static,
      aggregation_weights_Arg: Clone,
      aggregation_weights_Arg: GraphEdge<f32>,
      aggregation_weights_Arg: 'static,
      mode_override_Arg: Clone,
      mode_override_Arg: GraphEdge<String>,
      mode_override_Arg: 'static,
{
    sample_indices: sample_indices_Arg,
    embedding_indices: embedding_indices_Arg,
    aggregation_weights: aggregation_weights_Arg,
    mode_override: mode_override_Arg,
    N: i64,
    device_ordinal: Option<i64>,
    combiners: Option<Vec<String>>,
    table_ids: Vec<i64>,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<sample_indices_Arg, embedding_indices_Arg, aggregation_weights_Arg, mode_override_Arg> EnqueueTPUEmbeddingSparseTensorBatch<sample_indices_Arg, embedding_indices_Arg, aggregation_weights_Arg, mode_override_Arg>
where sample_indices_Arg: Clone,
      sample_indices_Arg: GraphEdge<i32>,
      sample_indices_Arg: 'static,
      embedding_indices_Arg: Clone,
      embedding_indices_Arg: GraphEdge<i32>,
      embedding_indices_Arg: 'static,
      aggregation_weights_Arg: Clone,
      aggregation_weights_Arg: GraphEdge<f32>,
      aggregation_weights_Arg: 'static,
      mode_override_Arg: Clone,
      mode_override_Arg: GraphEdge<String>,
      mode_override_Arg: 'static,
{
    pub fn device_ordinal(&mut self, device_ordinal: i64) -> Self {
        self.device_ordinal = Some(device_ordinal);
        self.clone()
    }

    pub fn combiners(&mut self, combiners: &[String]) -> Self {
        self.combiners = Some(combiners.to_vec());
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> () {
        let rc = Rc::new(self);
        (
        )
    }

    pub fn build(sample_indices: sample_indices_Arg, embedding_indices: embedding_indices_Arg, aggregation_weights: aggregation_weights_Arg, mode_override: mode_override_Arg, N: i64, table_ids: &[i64]) -> Self {
        Self {
            sample_indices,
            embedding_indices,
            aggregation_weights,
            mode_override,
            N: N,
            device_ordinal: None,
            combiners: None,
            table_ids: table_ids.to_vec(),
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(sample_indices: sample_indices_Arg, embedding_indices: embedding_indices_Arg, aggregation_weights: aggregation_weights_Arg, mode_override: mode_override_Arg, N: i64, table_ids: &[i64]) -> () {
        Self {
            sample_indices,
            embedding_indices,
            aggregation_weights,
            mode_override,
            N: N,
            device_ordinal: None,
            combiners: None,
            table_ids: table_ids.to_vec(),
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<parameters_Arg> GraphOperation for LoadTPUEmbeddingStochasticGradientDescentParameters<parameters_Arg>
where parameters_Arg: Clone,
      parameters_Arg: GraphEdge<f32>,
      parameters_Arg: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("LoadTPUEmbeddingStochasticGradientDescentParameters_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("LoadTPUEmbeddingStochasticGradientDescentParameters", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.parameters)?
        }
        {
            match self.table_id {
                None => new_op.set_attr_value_proto("table_id", &vec![24_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 1_u8,])?,
                Some(ref value) => (|attr: &i64| {new_op.set_attr_int("table_id", *attr)})(&value)?,
            };
        }
        {
            match self.table_name {
                None => new_op.set_attr_value_proto("table_name", &vec![18_u8, 0_u8,])?,
                Some(ref value) => (|attr| {new_op.set_attr_string("table_name", attr)})(&value)?,
            };
        }
        {
            (|attr: &i64| {new_op.set_attr_int("num_shards", *attr)})(&self.num_shards)?
        }
        {
            (|attr: &i64| {new_op.set_attr_int("shard_id", *attr)})(&self.shard_id)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct LoadTPUEmbeddingStochasticGradientDescentParameters<parameters_Arg>
where parameters_Arg: Clone,
      parameters_Arg: GraphEdge<f32>,
      parameters_Arg: 'static,
{
    parameters: parameters_Arg,
    table_id: Option<i64>,
    table_name: Option<String>,
    num_shards: i64,
    shard_id: i64,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<parameters_Arg> LoadTPUEmbeddingStochasticGradientDescentParameters<parameters_Arg>
where parameters_Arg: Clone,
      parameters_Arg: GraphEdge<f32>,
      parameters_Arg: 'static,
{
    pub fn table_id(&mut self, table_id: i64) -> Self {
        self.table_id = Some(table_id);
        self.clone()
    }

    pub fn table_name(&mut self, table_name: &str) -> Self {
        self.table_name = Some(table_name.to_string());
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> () {
        let rc = Rc::new(self);
        (
        )
    }

    pub fn build(parameters: parameters_Arg, num_shards: i64, shard_id: i64) -> Self {
        Self {
            parameters,
            table_id: None,
            table_name: None,
            num_shards: num_shards,
            shard_id: shard_id,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(parameters: parameters_Arg, num_shards: i64, shard_id: i64) -> () {
        Self {
            parameters,
            table_id: None,
            table_name: None,
            num_shards: num_shards,
            shard_id: shard_id,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

pub trait con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF for BFloat16 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF for OtherComplex<f32> {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF for OtherComplex<f64> {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF for f32 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF for f64 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF for i16 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF for i32 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF for i64 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF for i8 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF for u16 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF for u8 {
}

impl<T, x_Arg, y_Arg> GraphOperation for Mul<T, x_Arg, y_Arg>
where T: TensorType,
      T: Clone,
      x_Arg: Clone,
      x_Arg: GraphEdge<T>,
      x_Arg: 'static,
      y_Arg: Clone,
      y_Arg: GraphEdge<T>,
      y_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF,
      T: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("Mul_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("Mul", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.x)?
        }
        {
            new_op.add_edge(&self.y)?
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct Mul<T, x_Arg, y_Arg>
where T: TensorType,
      T: Clone,
      x_Arg: Clone,
      x_Arg: GraphEdge<T>,
      x_Arg: 'static,
      y_Arg: Clone,
      y_Arg: GraphEdge<T>,
      y_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    x: x_Arg,
    y: y_Arg,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<T, x_Arg, y_Arg> Mul<T, x_Arg, y_Arg>
where T: TensorType,
      T: Clone,
      x_Arg: Clone,
      x_Arg: GraphEdge<T>,
      x_Arg: 'static,
      y_Arg: Clone,
      y_Arg: GraphEdge<T>,
      y_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF,
      T: 'static,
{
    pub fn z(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(x: x_Arg, y: y_Arg) -> Self {
        Self {
            phantom_T: PhantomData,
            x,
            y,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(x: x_Arg, y: y_Arg) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            x,
            y,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<T, value_Arg, bias_Arg> GraphOperation for BiasAdd<T, value_Arg, bias_Arg>
where T: TensorType,
      T: Clone,
      value_Arg: Clone,
      value_Arg: GraphEdge<T>,
      value_Arg: 'static,
      bias_Arg: Clone,
      bias_Arg: GraphEdge<T>,
      bias_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("BiasAdd_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("BiasAdd", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.value)?
        }
        {
            new_op.add_edge(&self.bias)?
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        {
            match self.data_format {
                None => new_op.set_attr_value_proto("data_format", &vec![18_u8, 4_u8, 78_u8, 72_u8, 87_u8, 67_u8,])?,
                Some(ref value) => (|attr| {new_op.set_attr_string("data_format", attr)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct BiasAdd<T, value_Arg, bias_Arg>
where T: TensorType,
      T: Clone,
      value_Arg: Clone,
      value_Arg: GraphEdge<T>,
      value_Arg: 'static,
      bias_Arg: Clone,
      bias_Arg: GraphEdge<T>,
      bias_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    value: value_Arg,
    bias: bias_Arg,
    data_format: Option<String>,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<T, value_Arg, bias_Arg> BiasAdd<T, value_Arg, bias_Arg>
where T: TensorType,
      T: Clone,
      value_Arg: Clone,
      value_Arg: GraphEdge<T>,
      value_Arg: 'static,
      bias_Arg: Clone,
      bias_Arg: GraphEdge<T>,
      bias_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
{
    pub fn output(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn data_format(&mut self, data_format: &str) -> Self {
        self.data_format = Some(data_format.to_string());
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(value: value_Arg, bias: bias_Arg) -> Self {
        Self {
            phantom_T: PhantomData,
            value,
            bias,
            data_format: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(value: value_Arg, bias: bias_Arg) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            value,
            bias,
            data_format: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<T, input_Arg, Tdim, dim_Arg> GraphOperation for ExpandDims<T, input_Arg, Tdim, dim_Arg>
where T: TensorType,
      T: Clone,
      input_Arg: Clone,
      input_Arg: GraphEdge<T>,
      input_Arg: 'static,
      Tdim: TensorType,
      Tdim: Clone,
      dim_Arg: Clone,
      dim_Arg: GraphEdge<Tdim>,
      dim_Arg: 'static,
      T: 'static,
      Tdim: con_or_DT_INT32_or_DT_INT64,
      Tdim: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("ExpandDims_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("ExpandDims", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.input)?
        }
        {
            new_op.add_edge(&self.dim)?
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        {
            new_op.set_attr_type("Tdim", Tdim::data_type())?;
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct ExpandDims<T, input_Arg, Tdim, dim_Arg>
where T: TensorType,
      T: Clone,
      input_Arg: Clone,
      input_Arg: GraphEdge<T>,
      input_Arg: 'static,
      Tdim: TensorType,
      Tdim: Clone,
      dim_Arg: Clone,
      dim_Arg: GraphEdge<Tdim>,
      dim_Arg: 'static,
      T: 'static,
      Tdim: con_or_DT_INT32_or_DT_INT64,
      Tdim: 'static,
{
    phantom_T: PhantomData<T>,
    input: input_Arg,
    phantom_Tdim: PhantomData<Tdim>,
    dim: dim_Arg,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<T, input_Arg, Tdim, dim_Arg> ExpandDims<T, input_Arg, Tdim, dim_Arg>
where T: TensorType,
      T: Clone,
      input_Arg: Clone,
      input_Arg: GraphEdge<T>,
      input_Arg: 'static,
      Tdim: TensorType,
      Tdim: Clone,
      dim_Arg: Clone,
      dim_Arg: GraphEdge<Tdim>,
      dim_Arg: 'static,
      T: 'static,
      Tdim: con_or_DT_INT32_or_DT_INT64,
      Tdim: 'static,
{
    pub fn output(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(input: input_Arg, dim: dim_Arg) -> Self {
        Self {
            phantom_T: PhantomData,
            input,
            phantom_Tdim: PhantomData,
            dim,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(input: input_Arg, dim: dim_Arg) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            input,
            phantom_Tdim: PhantomData,
            dim,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<T, input_Arg, Tmultiples, multiples_Arg> GraphOperation for Tile<T, input_Arg, Tmultiples, multiples_Arg>
where T: TensorType,
      T: Clone,
      input_Arg: Clone,
      input_Arg: GraphEdge<T>,
      input_Arg: 'static,
      Tmultiples: TensorType,
      Tmultiples: Clone,
      multiples_Arg: Clone,
      multiples_Arg: GraphEdge<Tmultiples>,
      multiples_Arg: 'static,
      T: 'static,
      Tmultiples: con_or_DT_INT32_or_DT_INT64,
      Tmultiples: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("Tile_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("Tile", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.input)?
        }
        {
            new_op.add_edge(&self.multiples)?
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        {
            new_op.set_attr_type("Tmultiples", Tmultiples::data_type())?;
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct Tile<T, input_Arg, Tmultiples, multiples_Arg>
where T: TensorType,
      T: Clone,
      input_Arg: Clone,
      input_Arg: GraphEdge<T>,
      input_Arg: 'static,
      Tmultiples: TensorType,
      Tmultiples: Clone,
      multiples_Arg: Clone,
      multiples_Arg: GraphEdge<Tmultiples>,
      multiples_Arg: 'static,
      T: 'static,
      Tmultiples: con_or_DT_INT32_or_DT_INT64,
      Tmultiples: 'static,
{
    phantom_T: PhantomData<T>,
    input: input_Arg,
    phantom_Tmultiples: PhantomData<Tmultiples>,
    multiples: multiples_Arg,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<T, input_Arg, Tmultiples, multiples_Arg> Tile<T, input_Arg, Tmultiples, multiples_Arg>
where T: TensorType,
      T: Clone,
      input_Arg: Clone,
      input_Arg: GraphEdge<T>,
      input_Arg: 'static,
      Tmultiples: TensorType,
      Tmultiples: Clone,
      multiples_Arg: Clone,
      multiples_Arg: GraphEdge<Tmultiples>,
      multiples_Arg: 'static,
      T: 'static,
      Tmultiples: con_or_DT_INT32_or_DT_INT64,
      Tmultiples: 'static,
{
    pub fn output(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(input: input_Arg, multiples: multiples_Arg) -> Self {
        Self {
            phantom_T: PhantomData,
            input,
            phantom_Tmultiples: PhantomData,
            multiples,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(input: input_Arg, multiples: multiples_Arg) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            input,
            phantom_Tmultiples: PhantomData,
            multiples,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl GraphOperation for RecvTPUEmbeddingActivations {
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("RecvTPUEmbeddingActivations_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("RecvTPUEmbeddingActivations", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            (|attr: &i64| {new_op.set_attr_int("num_outputs", *attr)})(&self.num_outputs)?
        }
        {
            (|attr| {new_op.set_attr_string("config", attr)})(&self.config)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct RecvTPUEmbeddingActivations {
    num_outputs: i64,
    config: String,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl RecvTPUEmbeddingActivations {
    pub fn outputs(self) -> Edge<f32> {
        let rc = Rc::new(self);
        {
            Edge::<f32>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<f32> {
        let rc = Rc::new(self);
        {
            Edge::<f32>::new(rc.clone(), 0)
        }
    }

    pub fn build(num_outputs: i64, config: &str) -> Self {
        Self {
            num_outputs: num_outputs,
            config: config.to_string(),
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(num_outputs: i64, config: &str) -> Edge<f32> {
        Self {
            num_outputs: num_outputs,
            config: config.to_string(),
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<request_Arg> GraphOperation for WorkerHeartbeat<request_Arg>
where request_Arg: Clone,
      request_Arg: GraphEdge<String>,
      request_Arg: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("WorkerHeartbeat_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("WorkerHeartbeat", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.request)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct WorkerHeartbeat<request_Arg>
where request_Arg: Clone,
      request_Arg: GraphEdge<String>,
      request_Arg: 'static,
{
    request: request_Arg,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<request_Arg> WorkerHeartbeat<request_Arg>
where request_Arg: Clone,
      request_Arg: GraphEdge<String>,
      request_Arg: 'static,
{
    pub fn response(self) -> Edge<String> {
        let rc = Rc::new(self);
        {
            Edge::<String>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<String> {
        let rc = Rc::new(self);
        {
            Edge::<String>::new(rc.clone(), 0)
        }
    }

    pub fn build(request: request_Arg) -> Self {
        Self {
            request,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(request: request_Arg) -> Edge<String> {
        Self {
            request,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<condition_Arg, T, t_Arg, e_Arg> GraphOperation for Select<condition_Arg, T, t_Arg, e_Arg>
where condition_Arg: Clone,
      condition_Arg: GraphEdge<bool>,
      condition_Arg: 'static,
      T: TensorType,
      T: Clone,
      t_Arg: Clone,
      t_Arg: GraphEdge<T>,
      t_Arg: 'static,
      e_Arg: Clone,
      e_Arg: GraphEdge<T>,
      e_Arg: 'static,
      T: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("Select_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("Select", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.condition)?
        }
        {
            new_op.add_edge(&self.t)?
        }
        {
            new_op.add_edge(&self.e)?
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct Select<condition_Arg, T, t_Arg, e_Arg>
where condition_Arg: Clone,
      condition_Arg: GraphEdge<bool>,
      condition_Arg: 'static,
      T: TensorType,
      T: Clone,
      t_Arg: Clone,
      t_Arg: GraphEdge<T>,
      t_Arg: 'static,
      e_Arg: Clone,
      e_Arg: GraphEdge<T>,
      e_Arg: 'static,
      T: 'static,
{
    condition: condition_Arg,
    phantom_T: PhantomData<T>,
    t: t_Arg,
    e: e_Arg,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<condition_Arg, T, t_Arg, e_Arg> Select<condition_Arg, T, t_Arg, e_Arg>
where condition_Arg: Clone,
      condition_Arg: GraphEdge<bool>,
      condition_Arg: 'static,
      T: TensorType,
      T: Clone,
      t_Arg: Clone,
      t_Arg: GraphEdge<T>,
      t_Arg: 'static,
      e_Arg: Clone,
      e_Arg: GraphEdge<T>,
      e_Arg: 'static,
      T: 'static,
{
    pub fn output(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(condition: condition_Arg, t: t_Arg, e: e_Arg) -> Self {
        Self {
            condition,
            phantom_T: PhantomData,
            t,
            e,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(condition: condition_Arg, t: t_Arg, e: e_Arg) -> Edge<T> {
        Self {
            condition,
            phantom_T: PhantomData,
            t,
            e,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<T, y_Arg, dy_Arg> GraphOperation for RsqrtGrad<T, y_Arg, dy_Arg>
where T: TensorType,
      T: Clone,
      y_Arg: Clone,
      y_Arg: GraphEdge<T>,
      y_Arg: 'static,
      dy_Arg: Clone,
      dy_Arg: GraphEdge<T>,
      dy_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_COMPLEX64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF,
      T: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("RsqrtGrad_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("RsqrtGrad", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.y)?
        }
        {
            new_op.add_edge(&self.dy)?
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct RsqrtGrad<T, y_Arg, dy_Arg>
where T: TensorType,
      T: Clone,
      y_Arg: Clone,
      y_Arg: GraphEdge<T>,
      y_Arg: 'static,
      dy_Arg: Clone,
      dy_Arg: GraphEdge<T>,
      dy_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_COMPLEX64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    y: y_Arg,
    dy: dy_Arg,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<T, y_Arg, dy_Arg> RsqrtGrad<T, y_Arg, dy_Arg>
where T: TensorType,
      T: Clone,
      y_Arg: Clone,
      y_Arg: GraphEdge<T>,
      y_Arg: 'static,
      dy_Arg: Clone,
      dy_Arg: GraphEdge<T>,
      dy_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_COMPLEX64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF,
      T: 'static,
{
    pub fn z(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(y: y_Arg, dy: dy_Arg) -> Self {
        Self {
            phantom_T: PhantomData,
            y,
            dy,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(y: y_Arg, dy: dy_Arg) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            y,
            dy,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<T, input_Arg, Tpaddings, paddings_Arg, constant_values_Arg> GraphOperation for PadV2<T, input_Arg, Tpaddings, paddings_Arg, constant_values_Arg>
where T: TensorType,
      T: Clone,
      input_Arg: Clone,
      input_Arg: GraphEdge<T>,
      input_Arg: 'static,
      Tpaddings: TensorType,
      Tpaddings: Clone,
      paddings_Arg: Clone,
      paddings_Arg: GraphEdge<Tpaddings>,
      paddings_Arg: 'static,
      constant_values_Arg: Clone,
      constant_values_Arg: GraphEdge<T>,
      constant_values_Arg: 'static,
      T: 'static,
      Tpaddings: con_or_DT_INT32_or_DT_INT64,
      Tpaddings: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("PadV2_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("PadV2", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.input)?
        }
        {
            new_op.add_edge(&self.paddings)?
        }
        {
            new_op.add_edge(&self.constant_values)?
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        {
            new_op.set_attr_type("Tpaddings", Tpaddings::data_type())?;
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct PadV2<T, input_Arg, Tpaddings, paddings_Arg, constant_values_Arg>
where T: TensorType,
      T: Clone,
      input_Arg: Clone,
      input_Arg: GraphEdge<T>,
      input_Arg: 'static,
      Tpaddings: TensorType,
      Tpaddings: Clone,
      paddings_Arg: Clone,
      paddings_Arg: GraphEdge<Tpaddings>,
      paddings_Arg: 'static,
      constant_values_Arg: Clone,
      constant_values_Arg: GraphEdge<T>,
      constant_values_Arg: 'static,
      T: 'static,
      Tpaddings: con_or_DT_INT32_or_DT_INT64,
      Tpaddings: 'static,
{
    phantom_T: PhantomData<T>,
    input: input_Arg,
    phantom_Tpaddings: PhantomData<Tpaddings>,
    paddings: paddings_Arg,
    constant_values: constant_values_Arg,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<T, input_Arg, Tpaddings, paddings_Arg, constant_values_Arg> PadV2<T, input_Arg, Tpaddings, paddings_Arg, constant_values_Arg>
where T: TensorType,
      T: Clone,
      input_Arg: Clone,
      input_Arg: GraphEdge<T>,
      input_Arg: 'static,
      Tpaddings: TensorType,
      Tpaddings: Clone,
      paddings_Arg: Clone,
      paddings_Arg: GraphEdge<Tpaddings>,
      paddings_Arg: 'static,
      constant_values_Arg: Clone,
      constant_values_Arg: GraphEdge<T>,
      constant_values_Arg: 'static,
      T: 'static,
      Tpaddings: con_or_DT_INT32_or_DT_INT64,
      Tpaddings: 'static,
{
    pub fn output(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(input: input_Arg, paddings: paddings_Arg, constant_values: constant_values_Arg) -> Self {
        Self {
            phantom_T: PhantomData,
            input,
            phantom_Tpaddings: PhantomData,
            paddings,
            constant_values,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(input: input_Arg, paddings: paddings_Arg, constant_values: constant_values_Arg) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            input,
            phantom_Tpaddings: PhantomData,
            paddings,
            constant_values,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<parameters_Arg, accumulators_Arg> GraphOperation for LoadTPUEmbeddingProximalAdagradParameters<parameters_Arg, accumulators_Arg>
where parameters_Arg: Clone,
      parameters_Arg: GraphEdge<f32>,
      parameters_Arg: 'static,
      accumulators_Arg: Clone,
      accumulators_Arg: GraphEdge<f32>,
      accumulators_Arg: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("LoadTPUEmbeddingProximalAdagradParameters_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("LoadTPUEmbeddingProximalAdagradParameters", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.parameters)?
        }
        {
            new_op.add_edge(&self.accumulators)?
        }
        {
            match self.table_id {
                None => new_op.set_attr_value_proto("table_id", &vec![24_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 1_u8,])?,
                Some(ref value) => (|attr: &i64| {new_op.set_attr_int("table_id", *attr)})(&value)?,
            };
        }
        {
            match self.table_name {
                None => new_op.set_attr_value_proto("table_name", &vec![18_u8, 0_u8,])?,
                Some(ref value) => (|attr| {new_op.set_attr_string("table_name", attr)})(&value)?,
            };
        }
        {
            (|attr: &i64| {new_op.set_attr_int("num_shards", *attr)})(&self.num_shards)?
        }
        {
            (|attr: &i64| {new_op.set_attr_int("shard_id", *attr)})(&self.shard_id)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct LoadTPUEmbeddingProximalAdagradParameters<parameters_Arg, accumulators_Arg>
where parameters_Arg: Clone,
      parameters_Arg: GraphEdge<f32>,
      parameters_Arg: 'static,
      accumulators_Arg: Clone,
      accumulators_Arg: GraphEdge<f32>,
      accumulators_Arg: 'static,
{
    parameters: parameters_Arg,
    accumulators: accumulators_Arg,
    table_id: Option<i64>,
    table_name: Option<String>,
    num_shards: i64,
    shard_id: i64,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<parameters_Arg, accumulators_Arg> LoadTPUEmbeddingProximalAdagradParameters<parameters_Arg, accumulators_Arg>
where parameters_Arg: Clone,
      parameters_Arg: GraphEdge<f32>,
      parameters_Arg: 'static,
      accumulators_Arg: Clone,
      accumulators_Arg: GraphEdge<f32>,
      accumulators_Arg: 'static,
{
    pub fn table_id(&mut self, table_id: i64) -> Self {
        self.table_id = Some(table_id);
        self.clone()
    }

    pub fn table_name(&mut self, table_name: &str) -> Self {
        self.table_name = Some(table_name.to_string());
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> () {
        let rc = Rc::new(self);
        (
        )
    }

    pub fn build(parameters: parameters_Arg, accumulators: accumulators_Arg, num_shards: i64, shard_id: i64) -> Self {
        Self {
            parameters,
            accumulators,
            table_id: None,
            table_name: None,
            num_shards: num_shards,
            shard_id: shard_id,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(parameters: parameters_Arg, accumulators: accumulators_Arg, num_shards: i64, shard_id: i64) -> () {
        Self {
            parameters,
            accumulators,
            table_id: None,
            table_name: None,
            num_shards: num_shards,
            shard_id: shard_id,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<T, input_Arg, Tpaddings, paddings_Arg> GraphOperation for MirrorPadGrad<T, input_Arg, Tpaddings, paddings_Arg>
where T: TensorType,
      T: Clone,
      input_Arg: Clone,
      input_Arg: GraphEdge<T>,
      input_Arg: 'static,
      Tpaddings: TensorType,
      Tpaddings: Clone,
      paddings_Arg: Clone,
      paddings_Arg: GraphEdge<Tpaddings>,
      paddings_Arg: 'static,
      T: 'static,
      Tpaddings: con_or_DT_INT32_or_DT_INT64,
      Tpaddings: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("MirrorPadGrad_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("MirrorPadGrad", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.input)?
        }
        {
            new_op.add_edge(&self.paddings)?
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        {
            new_op.set_attr_type("Tpaddings", Tpaddings::data_type())?;
        }
        {
            (|attr| {new_op.set_attr_string("mode", attr)})(&self.mode)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct MirrorPadGrad<T, input_Arg, Tpaddings, paddings_Arg>
where T: TensorType,
      T: Clone,
      input_Arg: Clone,
      input_Arg: GraphEdge<T>,
      input_Arg: 'static,
      Tpaddings: TensorType,
      Tpaddings: Clone,
      paddings_Arg: Clone,
      paddings_Arg: GraphEdge<Tpaddings>,
      paddings_Arg: 'static,
      T: 'static,
      Tpaddings: con_or_DT_INT32_or_DT_INT64,
      Tpaddings: 'static,
{
    phantom_T: PhantomData<T>,
    input: input_Arg,
    phantom_Tpaddings: PhantomData<Tpaddings>,
    paddings: paddings_Arg,
    mode: String,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<T, input_Arg, Tpaddings, paddings_Arg> MirrorPadGrad<T, input_Arg, Tpaddings, paddings_Arg>
where T: TensorType,
      T: Clone,
      input_Arg: Clone,
      input_Arg: GraphEdge<T>,
      input_Arg: 'static,
      Tpaddings: TensorType,
      Tpaddings: Clone,
      paddings_Arg: Clone,
      paddings_Arg: GraphEdge<Tpaddings>,
      paddings_Arg: 'static,
      T: 'static,
      Tpaddings: con_or_DT_INT32_or_DT_INT64,
      Tpaddings: 'static,
{
    pub fn output(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(input: input_Arg, paddings: paddings_Arg, mode: &str) -> Self {
        Self {
            phantom_T: PhantomData,
            input,
            phantom_Tpaddings: PhantomData,
            paddings,
            mode: mode.to_string(),
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(input: input_Arg, paddings: paddings_Arg, mode: &str) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            input,
            phantom_Tpaddings: PhantomData,
            paddings,
            mode: mode.to_string(),
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

pub trait con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_STRING_or_DT_COMPLEX64_or_DT_INT64_or_DT_BOOL_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_STRING_or_DT_COMPLEX64_or_DT_INT64_or_DT_BOOL_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF for OtherComplex<f32> {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_STRING_or_DT_COMPLEX64_or_DT_INT64_or_DT_BOOL_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF for OtherComplex<f64> {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_STRING_or_DT_COMPLEX64_or_DT_INT64_or_DT_BOOL_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF for String {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_STRING_or_DT_COMPLEX64_or_DT_INT64_or_DT_BOOL_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF for bool {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_STRING_or_DT_COMPLEX64_or_DT_INT64_or_DT_BOOL_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF for f32 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_STRING_or_DT_COMPLEX64_or_DT_INT64_or_DT_BOOL_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF for f64 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_STRING_or_DT_COMPLEX64_or_DT_INT64_or_DT_BOOL_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF for i16 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_STRING_or_DT_COMPLEX64_or_DT_INT64_or_DT_BOOL_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF for i32 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_STRING_or_DT_COMPLEX64_or_DT_INT64_or_DT_BOOL_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF for i64 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_STRING_or_DT_COMPLEX64_or_DT_INT64_or_DT_BOOL_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF for i8 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_STRING_or_DT_COMPLEX64_or_DT_INT64_or_DT_BOOL_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF for u16 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_STRING_or_DT_COMPLEX64_or_DT_INT64_or_DT_BOOL_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF for u8 {
}

impl<T, tensor_Arg, dims_Arg> GraphOperation for Reverse<T, tensor_Arg, dims_Arg>
where T: TensorType,
      T: Clone,
      tensor_Arg: Clone,
      tensor_Arg: GraphEdge<T>,
      tensor_Arg: 'static,
      dims_Arg: Clone,
      dims_Arg: GraphEdge<bool>,
      dims_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_STRING_or_DT_COMPLEX64_or_DT_INT64_or_DT_BOOL_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF,
      T: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("Reverse_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("Reverse", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.tensor)?
        }
        {
            new_op.add_edge(&self.dims)?
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct Reverse<T, tensor_Arg, dims_Arg>
where T: TensorType,
      T: Clone,
      tensor_Arg: Clone,
      tensor_Arg: GraphEdge<T>,
      tensor_Arg: 'static,
      dims_Arg: Clone,
      dims_Arg: GraphEdge<bool>,
      dims_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_STRING_or_DT_COMPLEX64_or_DT_INT64_or_DT_BOOL_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    tensor: tensor_Arg,
    dims: dims_Arg,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<T, tensor_Arg, dims_Arg> Reverse<T, tensor_Arg, dims_Arg>
where T: TensorType,
      T: Clone,
      tensor_Arg: Clone,
      tensor_Arg: GraphEdge<T>,
      tensor_Arg: 'static,
      dims_Arg: Clone,
      dims_Arg: GraphEdge<bool>,
      dims_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_STRING_or_DT_COMPLEX64_or_DT_INT64_or_DT_BOOL_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF,
      T: 'static,
{
    pub fn output(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(tensor: tensor_Arg, dims: dims_Arg) -> Self {
        Self {
            phantom_T: PhantomData,
            tensor,
            dims,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(tensor: tensor_Arg, dims: dims_Arg) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            tensor,
            dims,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<T, logits_Arg> GraphOperation for LogSoftmax<T, logits_Arg>
where T: TensorType,
      T: Clone,
      logits_Arg: Clone,
      logits_Arg: GraphEdge<T>,
      logits_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
      T: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("LogSoftmax_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("LogSoftmax", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.logits)?
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct LogSoftmax<T, logits_Arg>
where T: TensorType,
      T: Clone,
      logits_Arg: Clone,
      logits_Arg: GraphEdge<T>,
      logits_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    logits: logits_Arg,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<T, logits_Arg> LogSoftmax<T, logits_Arg>
where T: TensorType,
      T: Clone,
      logits_Arg: Clone,
      logits_Arg: GraphEdge<T>,
      logits_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
      T: 'static,
{
    pub fn logsoftmax(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(logits: logits_Arg) -> Self {
        Self {
            phantom_T: PhantomData,
            logits,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(logits: logits_Arg) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            logits,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<T, x_Arg> GraphOperation for InvertPermutation<T, x_Arg>
where T: TensorType,
      T: Clone,
      x_Arg: Clone,
      x_Arg: GraphEdge<T>,
      x_Arg: 'static,
      T: con_or_DT_INT32_or_DT_INT64,
      T: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("InvertPermutation_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("InvertPermutation", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.x)?
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct InvertPermutation<T, x_Arg>
where T: TensorType,
      T: Clone,
      x_Arg: Clone,
      x_Arg: GraphEdge<T>,
      x_Arg: 'static,
      T: con_or_DT_INT32_or_DT_INT64,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    x: x_Arg,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<T, x_Arg> InvertPermutation<T, x_Arg>
where T: TensorType,
      T: Clone,
      x_Arg: Clone,
      x_Arg: GraphEdge<T>,
      x_Arg: 'static,
      T: con_or_DT_INT32_or_DT_INT64,
      T: 'static,
{
    pub fn y(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(x: x_Arg) -> Self {
        Self {
            phantom_T: PhantomData,
            x,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(x: x_Arg) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            x,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<handle_Arg> GraphOperation for TensorArrayClose<handle_Arg>
where handle_Arg: Clone,
      handle_Arg: GraphRefEdge<String>,
      handle_Arg: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("TensorArrayClose_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("TensorArrayClose", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.handle)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct TensorArrayClose<handle_Arg>
where handle_Arg: Clone,
      handle_Arg: GraphRefEdge<String>,
      handle_Arg: 'static,
{
    handle: handle_Arg,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<handle_Arg> TensorArrayClose<handle_Arg>
where handle_Arg: Clone,
      handle_Arg: GraphRefEdge<String>,
      handle_Arg: 'static,
{
    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> () {
        let rc = Rc::new(self);
        (
        )
    }

    pub fn build(handle: handle_Arg) -> Self {
        Self {
            handle,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(handle: handle_Arg) -> () {
        Self {
            handle,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<T, input_Arg, filter_Arg> GraphOperation for Conv2D<T, input_Arg, filter_Arg>
where T: TensorType,
      T: Clone,
      input_Arg: Clone,
      input_Arg: GraphEdge<T>,
      input_Arg: 'static,
      filter_Arg: Clone,
      filter_Arg: GraphEdge<T>,
      filter_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
      T: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("Conv2D_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("Conv2D", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.input)?
        }
        {
            new_op.add_edge(&self.filter)?
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        {
            (|attrs| {new_op.set_attr_int_list("strides", attrs)})(&self.strides)?
        }
        {
            match self.use_cudnn_on_gpu {
                None => new_op.set_attr_value_proto("use_cudnn_on_gpu", &vec![40_u8, 1_u8,])?,
                Some(ref value) => (|attr: &bool| {new_op.set_attr_bool("use_cudnn_on_gpu", *attr)})(&value)?,
            };
        }
        {
            (|attr| {new_op.set_attr_string("padding", attr)})(&self.padding)?
        }
        {
            match self.data_format {
                None => new_op.set_attr_value_proto("data_format", &vec![18_u8, 4_u8, 78_u8, 72_u8, 87_u8, 67_u8,])?,
                Some(ref value) => (|attr| {new_op.set_attr_string("data_format", attr)})(&value)?,
            };
        }
        {
            match self.dilations {
                None => new_op.set_attr_value_proto("dilations", &vec![10_u8, 0_u8, 26_u8, 4_u8,])?,
                Some(ref value) => (|attrs| {new_op.set_attr_int_list("dilations", attrs)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct Conv2D<T, input_Arg, filter_Arg>
where T: TensorType,
      T: Clone,
      input_Arg: Clone,
      input_Arg: GraphEdge<T>,
      input_Arg: 'static,
      filter_Arg: Clone,
      filter_Arg: GraphEdge<T>,
      filter_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    input: input_Arg,
    filter: filter_Arg,
    strides: Vec<i64>,
    use_cudnn_on_gpu: Option<bool>,
    padding: String,
    data_format: Option<String>,
    dilations: Option<Vec<i64>>,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<T, input_Arg, filter_Arg> Conv2D<T, input_Arg, filter_Arg>
where T: TensorType,
      T: Clone,
      input_Arg: Clone,
      input_Arg: GraphEdge<T>,
      input_Arg: 'static,
      filter_Arg: Clone,
      filter_Arg: GraphEdge<T>,
      filter_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
      T: 'static,
{
    pub fn output(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn use_cudnn_on_gpu(&mut self, use_cudnn_on_gpu: bool) -> Self {
        self.use_cudnn_on_gpu = Some(use_cudnn_on_gpu);
        self.clone()
    }

    pub fn data_format(&mut self, data_format: &str) -> Self {
        self.data_format = Some(data_format.to_string());
        self.clone()
    }

    pub fn dilations(&mut self, dilations: &[i64]) -> Self {
        self.dilations = Some(dilations.to_vec());
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(input: input_Arg, filter: filter_Arg, strides: &[i64], padding: &str) -> Self {
        Self {
            phantom_T: PhantomData,
            input,
            filter,
            strides: strides.to_vec(),
            use_cudnn_on_gpu: None,
            padding: padding.to_string(),
            data_format: None,
            dilations: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(input: input_Arg, filter: filter_Arg, strides: &[i64], padding: &str) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            input,
            filter,
            strides: strides.to_vec(),
            use_cudnn_on_gpu: None,
            padding: padding.to_string(),
            data_format: None,
            dilations: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<T, tensor_Arg, Tshape, shape_Arg> GraphOperation for Reshape<T, tensor_Arg, Tshape, shape_Arg>
where T: TensorType,
      T: Clone,
      tensor_Arg: Clone,
      tensor_Arg: GraphEdge<T>,
      tensor_Arg: 'static,
      Tshape: TensorType,
      Tshape: Clone,
      shape_Arg: Clone,
      shape_Arg: GraphEdge<Tshape>,
      shape_Arg: 'static,
      T: 'static,
      Tshape: con_or_DT_INT32_or_DT_INT64,
      Tshape: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("Reshape_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("Reshape", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.tensor)?
        }
        {
            new_op.add_edge(&self.shape)?
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        {
            new_op.set_attr_type("Tshape", Tshape::data_type())?;
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct Reshape<T, tensor_Arg, Tshape, shape_Arg>
where T: TensorType,
      T: Clone,
      tensor_Arg: Clone,
      tensor_Arg: GraphEdge<T>,
      tensor_Arg: 'static,
      Tshape: TensorType,
      Tshape: Clone,
      shape_Arg: Clone,
      shape_Arg: GraphEdge<Tshape>,
      shape_Arg: 'static,
      T: 'static,
      Tshape: con_or_DT_INT32_or_DT_INT64,
      Tshape: 'static,
{
    phantom_T: PhantomData<T>,
    tensor: tensor_Arg,
    phantom_Tshape: PhantomData<Tshape>,
    shape: shape_Arg,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<T, tensor_Arg, Tshape, shape_Arg> Reshape<T, tensor_Arg, Tshape, shape_Arg>
where T: TensorType,
      T: Clone,
      tensor_Arg: Clone,
      tensor_Arg: GraphEdge<T>,
      tensor_Arg: 'static,
      Tshape: TensorType,
      Tshape: Clone,
      shape_Arg: Clone,
      shape_Arg: GraphEdge<Tshape>,
      shape_Arg: 'static,
      T: 'static,
      Tshape: con_or_DT_INT32_or_DT_INT64,
      Tshape: 'static,
{
    pub fn output(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(tensor: tensor_Arg, shape: shape_Arg) -> Self {
        Self {
            phantom_T: PhantomData,
            tensor,
            phantom_Tshape: PhantomData,
            shape,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(tensor: tensor_Arg, shape: shape_Arg) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            tensor,
            phantom_Tshape: PhantomData,
            shape,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<T, boxes_Arg, scores_Arg, max_output_size_Arg, iou_threshold_Arg> GraphOperation for NonMaxSuppressionV2<T, boxes_Arg, scores_Arg, max_output_size_Arg, iou_threshold_Arg>
where T: TensorType,
      T: Clone,
      boxes_Arg: Clone,
      boxes_Arg: GraphEdge<T>,
      boxes_Arg: 'static,
      scores_Arg: Clone,
      scores_Arg: GraphEdge<T>,
      scores_Arg: 'static,
      max_output_size_Arg: Clone,
      max_output_size_Arg: GraphEdge<i32>,
      max_output_size_Arg: 'static,
      iou_threshold_Arg: Clone,
      iou_threshold_Arg: GraphEdge<f32>,
      iou_threshold_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_HALF,
      T: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("NonMaxSuppressionV2_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("NonMaxSuppressionV2", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.boxes)?
        }
        {
            new_op.add_edge(&self.scores)?
        }
        {
            new_op.add_edge(&self.max_output_size)?
        }
        {
            new_op.add_edge(&self.iou_threshold)?
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct NonMaxSuppressionV2<T, boxes_Arg, scores_Arg, max_output_size_Arg, iou_threshold_Arg>
where T: TensorType,
      T: Clone,
      boxes_Arg: Clone,
      boxes_Arg: GraphEdge<T>,
      boxes_Arg: 'static,
      scores_Arg: Clone,
      scores_Arg: GraphEdge<T>,
      scores_Arg: 'static,
      max_output_size_Arg: Clone,
      max_output_size_Arg: GraphEdge<i32>,
      max_output_size_Arg: 'static,
      iou_threshold_Arg: Clone,
      iou_threshold_Arg: GraphEdge<f32>,
      iou_threshold_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_HALF,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    boxes: boxes_Arg,
    scores: scores_Arg,
    max_output_size: max_output_size_Arg,
    iou_threshold: iou_threshold_Arg,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<T, boxes_Arg, scores_Arg, max_output_size_Arg, iou_threshold_Arg> NonMaxSuppressionV2<T, boxes_Arg, scores_Arg, max_output_size_Arg, iou_threshold_Arg>
where T: TensorType,
      T: Clone,
      boxes_Arg: Clone,
      boxes_Arg: GraphEdge<T>,
      boxes_Arg: 'static,
      scores_Arg: Clone,
      scores_Arg: GraphEdge<T>,
      scores_Arg: 'static,
      max_output_size_Arg: Clone,
      max_output_size_Arg: GraphEdge<i32>,
      max_output_size_Arg: 'static,
      iou_threshold_Arg: Clone,
      iou_threshold_Arg: GraphEdge<f32>,
      iou_threshold_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_HALF,
      T: 'static,
{
    pub fn selected_indices(self) -> Edge<i32> {
        let rc = Rc::new(self);
        {
            Edge::<i32>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<i32> {
        let rc = Rc::new(self);
        {
            Edge::<i32>::new(rc.clone(), 0)
        }
    }

    pub fn build(boxes: boxes_Arg, scores: scores_Arg, max_output_size: max_output_size_Arg, iou_threshold: iou_threshold_Arg) -> Self {
        Self {
            phantom_T: PhantomData,
            boxes,
            scores,
            max_output_size,
            iou_threshold,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(boxes: boxes_Arg, scores: scores_Arg, max_output_size: max_output_size_Arg, iou_threshold: iou_threshold_Arg) -> Edge<i32> {
        Self {
            phantom_T: PhantomData,
            boxes,
            scores,
            max_output_size,
            iou_threshold,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<inputs_Arg, reduction_indices_Arg> GraphOperation for ReduceJoin<inputs_Arg, reduction_indices_Arg>
where inputs_Arg: Clone,
      inputs_Arg: GraphEdge<String>,
      inputs_Arg: 'static,
      reduction_indices_Arg: Clone,
      reduction_indices_Arg: GraphEdge<i32>,
      reduction_indices_Arg: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("ReduceJoin_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("ReduceJoin", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.inputs)?
        }
        {
            new_op.add_edge(&self.reduction_indices)?
        }
        {
            match self.keep_dims {
                None => new_op.set_attr_value_proto("keep_dims", &vec![40_u8, 0_u8,])?,
                Some(ref value) => (|attr: &bool| {new_op.set_attr_bool("keep_dims", *attr)})(&value)?,
            };
        }
        {
            match self.separator {
                None => new_op.set_attr_value_proto("separator", &vec![18_u8, 0_u8,])?,
                Some(ref value) => (|attr| {new_op.set_attr_string("separator", attr)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct ReduceJoin<inputs_Arg, reduction_indices_Arg>
where inputs_Arg: Clone,
      inputs_Arg: GraphEdge<String>,
      inputs_Arg: 'static,
      reduction_indices_Arg: Clone,
      reduction_indices_Arg: GraphEdge<i32>,
      reduction_indices_Arg: 'static,
{
    inputs: inputs_Arg,
    reduction_indices: reduction_indices_Arg,
    keep_dims: Option<bool>,
    separator: Option<String>,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<inputs_Arg, reduction_indices_Arg> ReduceJoin<inputs_Arg, reduction_indices_Arg>
where inputs_Arg: Clone,
      inputs_Arg: GraphEdge<String>,
      inputs_Arg: 'static,
      reduction_indices_Arg: Clone,
      reduction_indices_Arg: GraphEdge<i32>,
      reduction_indices_Arg: 'static,
{
    pub fn output(self) -> Edge<String> {
        let rc = Rc::new(self);
        {
            Edge::<String>::new(rc.clone(), 0)
        }
    }

    pub fn keep_dims(&mut self, keep_dims: bool) -> Self {
        self.keep_dims = Some(keep_dims);
        self.clone()
    }

    pub fn separator(&mut self, separator: &str) -> Self {
        self.separator = Some(separator.to_string());
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<String> {
        let rc = Rc::new(self);
        {
            Edge::<String>::new(rc.clone(), 0)
        }
    }

    pub fn build(inputs: inputs_Arg, reduction_indices: reduction_indices_Arg) -> Self {
        Self {
            inputs,
            reduction_indices,
            keep_dims: None,
            separator: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(inputs: inputs_Arg, reduction_indices: reduction_indices_Arg) -> Edge<String> {
        Self {
            inputs,
            reduction_indices,
            keep_dims: None,
            separator: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<reader_handle_Arg, state_Arg> GraphOperation for ReaderRestoreState<reader_handle_Arg, state_Arg>
where reader_handle_Arg: Clone,
      reader_handle_Arg: GraphRefEdge<String>,
      reader_handle_Arg: 'static,
      state_Arg: Clone,
      state_Arg: GraphEdge<String>,
      state_Arg: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("ReaderRestoreState_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("ReaderRestoreState", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.reader_handle)?
        }
        {
            new_op.add_edge(&self.state)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct ReaderRestoreState<reader_handle_Arg, state_Arg>
where reader_handle_Arg: Clone,
      reader_handle_Arg: GraphRefEdge<String>,
      reader_handle_Arg: 'static,
      state_Arg: Clone,
      state_Arg: GraphEdge<String>,
      state_Arg: 'static,
{
    reader_handle: reader_handle_Arg,
    state: state_Arg,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<reader_handle_Arg, state_Arg> ReaderRestoreState<reader_handle_Arg, state_Arg>
where reader_handle_Arg: Clone,
      reader_handle_Arg: GraphRefEdge<String>,
      reader_handle_Arg: 'static,
      state_Arg: Clone,
      state_Arg: GraphEdge<String>,
      state_Arg: 'static,
{
    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> () {
        let rc = Rc::new(self);
        (
        )
    }

    pub fn build(reader_handle: reader_handle_Arg, state: state_Arg) -> Self {
        Self {
            reader_handle,
            state,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(reader_handle: reader_handle_Arg, state: state_Arg) -> () {
        Self {
            reader_handle,
            state,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<T, input_Arg, Tlen, seq_lengths_Arg> GraphOperation for ReverseSequence<T, input_Arg, Tlen, seq_lengths_Arg>
where T: TensorType,
      T: Clone,
      input_Arg: Clone,
      input_Arg: GraphEdge<T>,
      input_Arg: 'static,
      Tlen: TensorType,
      Tlen: Clone,
      seq_lengths_Arg: Clone,
      seq_lengths_Arg: GraphEdge<Tlen>,
      seq_lengths_Arg: 'static,
      T: 'static,
      Tlen: con_or_DT_INT32_or_DT_INT64,
      Tlen: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("ReverseSequence_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("ReverseSequence", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.input)?
        }
        {
            new_op.add_edge(&self.seq_lengths)?
        }
        {
            (|attr: &i64| {new_op.set_attr_int("seq_dim", *attr)})(&self.seq_dim)?
        }
        {
            match self.batch_dim {
                None => new_op.set_attr_value_proto("batch_dim", &vec![24_u8, 0_u8,])?,
                Some(ref value) => (|attr: &i64| {new_op.set_attr_int("batch_dim", *attr)})(&value)?,
            };
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        {
            new_op.set_attr_type("Tlen", Tlen::data_type())?;
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct ReverseSequence<T, input_Arg, Tlen, seq_lengths_Arg>
where T: TensorType,
      T: Clone,
      input_Arg: Clone,
      input_Arg: GraphEdge<T>,
      input_Arg: 'static,
      Tlen: TensorType,
      Tlen: Clone,
      seq_lengths_Arg: Clone,
      seq_lengths_Arg: GraphEdge<Tlen>,
      seq_lengths_Arg: 'static,
      T: 'static,
      Tlen: con_or_DT_INT32_or_DT_INT64,
      Tlen: 'static,
{
    phantom_T: PhantomData<T>,
    input: input_Arg,
    phantom_Tlen: PhantomData<Tlen>,
    seq_lengths: seq_lengths_Arg,
    seq_dim: i64,
    batch_dim: Option<i64>,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<T, input_Arg, Tlen, seq_lengths_Arg> ReverseSequence<T, input_Arg, Tlen, seq_lengths_Arg>
where T: TensorType,
      T: Clone,
      input_Arg: Clone,
      input_Arg: GraphEdge<T>,
      input_Arg: 'static,
      Tlen: TensorType,
      Tlen: Clone,
      seq_lengths_Arg: Clone,
      seq_lengths_Arg: GraphEdge<Tlen>,
      seq_lengths_Arg: 'static,
      T: 'static,
      Tlen: con_or_DT_INT32_or_DT_INT64,
      Tlen: 'static,
{
    pub fn output(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn batch_dim(&mut self, batch_dim: i64) -> Self {
        self.batch_dim = Some(batch_dim);
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(input: input_Arg, seq_lengths: seq_lengths_Arg, seq_dim: i64) -> Self {
        Self {
            phantom_T: PhantomData,
            input,
            phantom_Tlen: PhantomData,
            seq_lengths,
            seq_dim: seq_dim,
            batch_dim: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(input: input_Arg, seq_lengths: seq_lengths_Arg, seq_dim: i64) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            input,
            phantom_Tlen: PhantomData,
            seq_lengths,
            seq_dim: seq_dim,
            batch_dim: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<T, tensor_Arg> GraphOperation for XlaSend<T, tensor_Arg>
where T: TensorType,
      T: Clone,
      tensor_Arg: Clone,
      tensor_Arg: GraphEdge<T>,
      tensor_Arg: 'static,
      T: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("XlaSend_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("XlaSend", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.tensor)?
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        {
            (|attr| {new_op.set_attr_string("tensor_name", attr)})(&self.tensor_name)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct XlaSend<T, tensor_Arg>
where T: TensorType,
      T: Clone,
      tensor_Arg: Clone,
      tensor_Arg: GraphEdge<T>,
      tensor_Arg: 'static,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    tensor: tensor_Arg,
    tensor_name: String,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<T, tensor_Arg> XlaSend<T, tensor_Arg>
where T: TensorType,
      T: Clone,
      tensor_Arg: Clone,
      tensor_Arg: GraphEdge<T>,
      tensor_Arg: 'static,
      T: 'static,
{
    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> () {
        let rc = Rc::new(self);
        (
        )
    }

    pub fn build(tensor: tensor_Arg, tensor_name: &str) -> Self {
        Self {
            phantom_T: PhantomData,
            tensor,
            tensor_name: tensor_name.to_string(),
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(tensor: tensor_Arg, tensor_name: &str) -> () {
        Self {
            phantom_T: PhantomData,
            tensor,
            tensor_name: tensor_name.to_string(),
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<T, var_Arg, gradient_accumulator_Arg, gradient_squared_accumulator_Arg, grad_Arg, lr_Arg, l1_Arg, l2_Arg, global_step_Arg> GraphOperation for ApplyAdagradDA<T, var_Arg, gradient_accumulator_Arg, gradient_squared_accumulator_Arg, grad_Arg, lr_Arg, l1_Arg, l2_Arg, global_step_Arg>
where T: TensorType,
      T: Clone,
      var_Arg: Clone,
      var_Arg: GraphRefEdge<T>,
      var_Arg: 'static,
      gradient_accumulator_Arg: Clone,
      gradient_accumulator_Arg: GraphRefEdge<T>,
      gradient_accumulator_Arg: 'static,
      gradient_squared_accumulator_Arg: Clone,
      gradient_squared_accumulator_Arg: GraphRefEdge<T>,
      gradient_squared_accumulator_Arg: 'static,
      grad_Arg: Clone,
      grad_Arg: GraphEdge<T>,
      grad_Arg: 'static,
      lr_Arg: Clone,
      lr_Arg: GraphEdge<T>,
      lr_Arg: 'static,
      l1_Arg: Clone,
      l1_Arg: GraphEdge<T>,
      l1_Arg: 'static,
      l2_Arg: Clone,
      l2_Arg: GraphEdge<T>,
      l2_Arg: 'static,
      global_step_Arg: Clone,
      global_step_Arg: GraphEdge<i64>,
      global_step_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("ApplyAdagradDA_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("ApplyAdagradDA", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.var)?
        }
        {
            new_op.add_edge(&self.gradient_accumulator)?
        }
        {
            new_op.add_edge(&self.gradient_squared_accumulator)?
        }
        {
            new_op.add_edge(&self.grad)?
        }
        {
            new_op.add_edge(&self.lr)?
        }
        {
            new_op.add_edge(&self.l1)?
        }
        {
            new_op.add_edge(&self.l2)?
        }
        {
            new_op.add_edge(&self.global_step)?
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        {
            match self.use_locking {
                None => new_op.set_attr_value_proto("use_locking", &vec![40_u8, 0_u8,])?,
                Some(ref value) => (|attr: &bool| {new_op.set_attr_bool("use_locking", *attr)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct ApplyAdagradDA<T, var_Arg, gradient_accumulator_Arg, gradient_squared_accumulator_Arg, grad_Arg, lr_Arg, l1_Arg, l2_Arg, global_step_Arg>
where T: TensorType,
      T: Clone,
      var_Arg: Clone,
      var_Arg: GraphRefEdge<T>,
      var_Arg: 'static,
      gradient_accumulator_Arg: Clone,
      gradient_accumulator_Arg: GraphRefEdge<T>,
      gradient_accumulator_Arg: 'static,
      gradient_squared_accumulator_Arg: Clone,
      gradient_squared_accumulator_Arg: GraphRefEdge<T>,
      gradient_squared_accumulator_Arg: 'static,
      grad_Arg: Clone,
      grad_Arg: GraphEdge<T>,
      grad_Arg: 'static,
      lr_Arg: Clone,
      lr_Arg: GraphEdge<T>,
      lr_Arg: 'static,
      l1_Arg: Clone,
      l1_Arg: GraphEdge<T>,
      l1_Arg: 'static,
      l2_Arg: Clone,
      l2_Arg: GraphEdge<T>,
      l2_Arg: 'static,
      global_step_Arg: Clone,
      global_step_Arg: GraphEdge<i64>,
      global_step_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    var: var_Arg,
    gradient_accumulator: gradient_accumulator_Arg,
    gradient_squared_accumulator: gradient_squared_accumulator_Arg,
    grad: grad_Arg,
    lr: lr_Arg,
    l1: l1_Arg,
    l2: l2_Arg,
    global_step: global_step_Arg,
    use_locking: Option<bool>,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<T, var_Arg, gradient_accumulator_Arg, gradient_squared_accumulator_Arg, grad_Arg, lr_Arg, l1_Arg, l2_Arg, global_step_Arg> ApplyAdagradDA<T, var_Arg, gradient_accumulator_Arg, gradient_squared_accumulator_Arg, grad_Arg, lr_Arg, l1_Arg, l2_Arg, global_step_Arg>
where T: TensorType,
      T: Clone,
      var_Arg: Clone,
      var_Arg: GraphRefEdge<T>,
      var_Arg: 'static,
      gradient_accumulator_Arg: Clone,
      gradient_accumulator_Arg: GraphRefEdge<T>,
      gradient_accumulator_Arg: 'static,
      gradient_squared_accumulator_Arg: Clone,
      gradient_squared_accumulator_Arg: GraphRefEdge<T>,
      gradient_squared_accumulator_Arg: 'static,
      grad_Arg: Clone,
      grad_Arg: GraphEdge<T>,
      grad_Arg: 'static,
      lr_Arg: Clone,
      lr_Arg: GraphEdge<T>,
      lr_Arg: 'static,
      l1_Arg: Clone,
      l1_Arg: GraphEdge<T>,
      l1_Arg: 'static,
      l2_Arg: Clone,
      l2_Arg: GraphEdge<T>,
      l2_Arg: 'static,
      global_step_Arg: Clone,
      global_step_Arg: GraphEdge<i64>,
      global_step_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
{
    pub fn out(self) -> RefEdge<T> {
        let rc = Rc::new(self);
        {
            RefEdge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn use_locking(&mut self, use_locking: bool) -> Self {
        self.use_locking = Some(use_locking);
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> RefEdge<T> {
        let rc = Rc::new(self);
        {
            RefEdge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(var: var_Arg, gradient_accumulator: gradient_accumulator_Arg, gradient_squared_accumulator: gradient_squared_accumulator_Arg, grad: grad_Arg, lr: lr_Arg, l1: l1_Arg, l2: l2_Arg, global_step: global_step_Arg) -> Self {
        Self {
            phantom_T: PhantomData,
            var,
            gradient_accumulator,
            gradient_squared_accumulator,
            grad,
            lr,
            l1,
            l2,
            global_step,
            use_locking: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(var: var_Arg, gradient_accumulator: gradient_accumulator_Arg, gradient_squared_accumulator: gradient_squared_accumulator_Arg, grad: grad_Arg, lr: lr_Arg, l1: l1_Arg, l2: l2_Arg, global_step: global_step_Arg) -> RefEdge<T> {
        Self {
            phantom_T: PhantomData,
            var,
            gradient_accumulator,
            gradient_squared_accumulator,
            grad,
            lr,
            l1,
            l2,
            global_step,
            use_locking: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<T, values_Arg> GraphOperation for Pack<T, values_Arg>
where T: TensorType,
      T: Clone,
      values_Arg: Clone,
      values_Arg: GraphEdge<T>,
      values_Arg: 'static,
      T: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("Pack_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("Pack", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.values)?
        }
        {
            (|attr: &i64| {new_op.set_attr_int("N", *attr)})(&self.N)?
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        {
            match self.axis {
                None => new_op.set_attr_value_proto("axis", &vec![24_u8, 0_u8,])?,
                Some(ref value) => (|attr: &i64| {new_op.set_attr_int("axis", *attr)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct Pack<T, values_Arg>
where T: TensorType,
      T: Clone,
      values_Arg: Clone,
      values_Arg: GraphEdge<T>,
      values_Arg: 'static,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    values: values_Arg,
    N: i64,
    axis: Option<i64>,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<T, values_Arg> Pack<T, values_Arg>
where T: TensorType,
      T: Clone,
      values_Arg: Clone,
      values_Arg: GraphEdge<T>,
      values_Arg: 'static,
      T: 'static,
{
    pub fn output(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn axis(&mut self, axis: i64) -> Self {
        self.axis = Some(axis);
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(values: values_Arg, N: i64) -> Self {
        Self {
            phantom_T: PhantomData,
            values,
            N: N,
            axis: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(values: values_Arg, N: i64) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            values,
            N: N,
            axis: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<input_indices_Arg, input_shape_Arg, new_shape_Arg> GraphOperation for SparseReshape<input_indices_Arg, input_shape_Arg, new_shape_Arg>
where input_indices_Arg: Clone,
      input_indices_Arg: GraphEdge<i64>,
      input_indices_Arg: 'static,
      input_shape_Arg: Clone,
      input_shape_Arg: GraphEdge<i64>,
      input_shape_Arg: 'static,
      new_shape_Arg: Clone,
      new_shape_Arg: GraphEdge<i64>,
      new_shape_Arg: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("SparseReshape_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("SparseReshape", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.input_indices)?
        }
        {
            new_op.add_edge(&self.input_shape)?
        }
        {
            new_op.add_edge(&self.new_shape)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct SparseReshape<input_indices_Arg, input_shape_Arg, new_shape_Arg>
where input_indices_Arg: Clone,
      input_indices_Arg: GraphEdge<i64>,
      input_indices_Arg: 'static,
      input_shape_Arg: Clone,
      input_shape_Arg: GraphEdge<i64>,
      input_shape_Arg: 'static,
      new_shape_Arg: Clone,
      new_shape_Arg: GraphEdge<i64>,
      new_shape_Arg: 'static,
{
    input_indices: input_indices_Arg,
    input_shape: input_shape_Arg,
    new_shape: new_shape_Arg,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<input_indices_Arg, input_shape_Arg, new_shape_Arg> SparseReshape<input_indices_Arg, input_shape_Arg, new_shape_Arg>
where input_indices_Arg: Clone,
      input_indices_Arg: GraphEdge<i64>,
      input_indices_Arg: 'static,
      input_shape_Arg: Clone,
      input_shape_Arg: GraphEdge<i64>,
      input_shape_Arg: 'static,
      new_shape_Arg: Clone,
      new_shape_Arg: GraphEdge<i64>,
      new_shape_Arg: 'static,
{
    pub fn output_indices(self) -> Edge<i64> {
        let rc = Rc::new(self);
        {
            Edge::<i64>::new(rc.clone(), 0)
        }
    }

    pub fn output_shape(self) -> Edge<i64> {
        let rc = Rc::new(self);
        {
            Edge::<i64>::new(rc.clone(), 1)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> (Edge<i64>, Edge<i64>) {
        let rc = Rc::new(self);
        (
        {
            Edge::<i64>::new(rc.clone(), 0)
        },
        {
            Edge::<i64>::new(rc.clone(), 1)
        },
        )
    }

    pub fn build(input_indices: input_indices_Arg, input_shape: input_shape_Arg, new_shape: new_shape_Arg) -> Self {
        Self {
            input_indices,
            input_shape,
            new_shape,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(input_indices: input_indices_Arg, input_shape: input_shape_Arg, new_shape: new_shape_Arg) -> (Edge<i64>, Edge<i64>) {
        Self {
            input_indices,
            input_shape,
            new_shape,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<handle_Arg, T, value_Arg, lengths_Arg, flow_in_Arg> GraphOperation for TensorArraySplitV2<handle_Arg, T, value_Arg, lengths_Arg, flow_in_Arg>
where handle_Arg: Clone,
      handle_Arg: GraphEdge<String>,
      handle_Arg: 'static,
      T: TensorType,
      T: Clone,
      value_Arg: Clone,
      value_Arg: GraphEdge<T>,
      value_Arg: 'static,
      lengths_Arg: Clone,
      lengths_Arg: GraphEdge<i64>,
      lengths_Arg: 'static,
      flow_in_Arg: Clone,
      flow_in_Arg: GraphEdge<f32>,
      flow_in_Arg: 'static,
      T: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("TensorArraySplitV2_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("TensorArraySplitV2", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.handle)?
        }
        {
            new_op.add_edge(&self.value)?
        }
        {
            new_op.add_edge(&self.lengths)?
        }
        {
            new_op.add_edge(&self.flow_in)?
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct TensorArraySplitV2<handle_Arg, T, value_Arg, lengths_Arg, flow_in_Arg>
where handle_Arg: Clone,
      handle_Arg: GraphEdge<String>,
      handle_Arg: 'static,
      T: TensorType,
      T: Clone,
      value_Arg: Clone,
      value_Arg: GraphEdge<T>,
      value_Arg: 'static,
      lengths_Arg: Clone,
      lengths_Arg: GraphEdge<i64>,
      lengths_Arg: 'static,
      flow_in_Arg: Clone,
      flow_in_Arg: GraphEdge<f32>,
      flow_in_Arg: 'static,
      T: 'static,
{
    handle: handle_Arg,
    phantom_T: PhantomData<T>,
    value: value_Arg,
    lengths: lengths_Arg,
    flow_in: flow_in_Arg,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<handle_Arg, T, value_Arg, lengths_Arg, flow_in_Arg> TensorArraySplitV2<handle_Arg, T, value_Arg, lengths_Arg, flow_in_Arg>
where handle_Arg: Clone,
      handle_Arg: GraphEdge<String>,
      handle_Arg: 'static,
      T: TensorType,
      T: Clone,
      value_Arg: Clone,
      value_Arg: GraphEdge<T>,
      value_Arg: 'static,
      lengths_Arg: Clone,
      lengths_Arg: GraphEdge<i64>,
      lengths_Arg: 'static,
      flow_in_Arg: Clone,
      flow_in_Arg: GraphEdge<f32>,
      flow_in_Arg: 'static,
      T: 'static,
{
    pub fn flow_out(self) -> Edge<f32> {
        let rc = Rc::new(self);
        {
            Edge::<f32>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<f32> {
        let rc = Rc::new(self);
        {
            Edge::<f32>::new(rc.clone(), 0)
        }
    }

    pub fn build(handle: handle_Arg, value: value_Arg, lengths: lengths_Arg, flow_in: flow_in_Arg) -> Self {
        Self {
            handle,
            phantom_T: PhantomData,
            value,
            lengths,
            flow_in,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(handle: handle_Arg, value: value_Arg, lengths: lengths_Arg, flow_in: flow_in_Arg) -> Edge<f32> {
        Self {
            handle,
            phantom_T: PhantomData,
            value,
            lengths,
            flow_in,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<T, ref__Arg, value_Arg> GraphOperation for AssignAdd<T, ref__Arg, value_Arg>
where T: TensorType,
      T: Clone,
      ref__Arg: Clone,
      ref__Arg: GraphRefEdge<T>,
      ref__Arg: 'static,
      value_Arg: Clone,
      value_Arg: GraphEdge<T>,
      value_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("AssignAdd_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("AssignAdd", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.ref_)?
        }
        {
            new_op.add_edge(&self.value)?
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        {
            match self.use_locking {
                None => new_op.set_attr_value_proto("use_locking", &vec![40_u8, 0_u8,])?,
                Some(ref value) => (|attr: &bool| {new_op.set_attr_bool("use_locking", *attr)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct AssignAdd<T, ref__Arg, value_Arg>
where T: TensorType,
      T: Clone,
      ref__Arg: Clone,
      ref__Arg: GraphRefEdge<T>,
      ref__Arg: 'static,
      value_Arg: Clone,
      value_Arg: GraphEdge<T>,
      value_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    ref_: ref__Arg,
    value: value_Arg,
    use_locking: Option<bool>,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<T, ref__Arg, value_Arg> AssignAdd<T, ref__Arg, value_Arg>
where T: TensorType,
      T: Clone,
      ref__Arg: Clone,
      ref__Arg: GraphRefEdge<T>,
      ref__Arg: 'static,
      value_Arg: Clone,
      value_Arg: GraphEdge<T>,
      value_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
{
    pub fn output_ref(self) -> RefEdge<T> {
        let rc = Rc::new(self);
        {
            RefEdge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn use_locking(&mut self, use_locking: bool) -> Self {
        self.use_locking = Some(use_locking);
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> RefEdge<T> {
        let rc = Rc::new(self);
        {
            RefEdge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(ref_: ref__Arg, value: value_Arg) -> Self {
        Self {
            phantom_T: PhantomData,
            ref_,
            value,
            use_locking: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(ref_: ref__Arg, value: value_Arg) -> RefEdge<T> {
        Self {
            phantom_T: PhantomData,
            ref_,
            value,
            use_locking: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<parameters_Arg, ms_Arg, mom_Arg, mg_Arg> GraphOperation for LoadTPUEmbeddingCenteredRMSPropParameters<parameters_Arg, ms_Arg, mom_Arg, mg_Arg>
where parameters_Arg: Clone,
      parameters_Arg: GraphEdge<f32>,
      parameters_Arg: 'static,
      ms_Arg: Clone,
      ms_Arg: GraphEdge<f32>,
      ms_Arg: 'static,
      mom_Arg: Clone,
      mom_Arg: GraphEdge<f32>,
      mom_Arg: 'static,
      mg_Arg: Clone,
      mg_Arg: GraphEdge<f32>,
      mg_Arg: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("LoadTPUEmbeddingCenteredRMSPropParameters_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("LoadTPUEmbeddingCenteredRMSPropParameters", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.parameters)?
        }
        {
            new_op.add_edge(&self.ms)?
        }
        {
            new_op.add_edge(&self.mom)?
        }
        {
            new_op.add_edge(&self.mg)?
        }
        {
            match self.table_id {
                None => new_op.set_attr_value_proto("table_id", &vec![24_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 1_u8,])?,
                Some(ref value) => (|attr: &i64| {new_op.set_attr_int("table_id", *attr)})(&value)?,
            };
        }
        {
            match self.table_name {
                None => new_op.set_attr_value_proto("table_name", &vec![18_u8, 0_u8,])?,
                Some(ref value) => (|attr| {new_op.set_attr_string("table_name", attr)})(&value)?,
            };
        }
        {
            (|attr: &i64| {new_op.set_attr_int("num_shards", *attr)})(&self.num_shards)?
        }
        {
            (|attr: &i64| {new_op.set_attr_int("shard_id", *attr)})(&self.shard_id)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct LoadTPUEmbeddingCenteredRMSPropParameters<parameters_Arg, ms_Arg, mom_Arg, mg_Arg>
where parameters_Arg: Clone,
      parameters_Arg: GraphEdge<f32>,
      parameters_Arg: 'static,
      ms_Arg: Clone,
      ms_Arg: GraphEdge<f32>,
      ms_Arg: 'static,
      mom_Arg: Clone,
      mom_Arg: GraphEdge<f32>,
      mom_Arg: 'static,
      mg_Arg: Clone,
      mg_Arg: GraphEdge<f32>,
      mg_Arg: 'static,
{
    parameters: parameters_Arg,
    ms: ms_Arg,
    mom: mom_Arg,
    mg: mg_Arg,
    table_id: Option<i64>,
    table_name: Option<String>,
    num_shards: i64,
    shard_id: i64,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<parameters_Arg, ms_Arg, mom_Arg, mg_Arg> LoadTPUEmbeddingCenteredRMSPropParameters<parameters_Arg, ms_Arg, mom_Arg, mg_Arg>
where parameters_Arg: Clone,
      parameters_Arg: GraphEdge<f32>,
      parameters_Arg: 'static,
      ms_Arg: Clone,
      ms_Arg: GraphEdge<f32>,
      ms_Arg: 'static,
      mom_Arg: Clone,
      mom_Arg: GraphEdge<f32>,
      mom_Arg: 'static,
      mg_Arg: Clone,
      mg_Arg: GraphEdge<f32>,
      mg_Arg: 'static,
{
    pub fn table_id(&mut self, table_id: i64) -> Self {
        self.table_id = Some(table_id);
        self.clone()
    }

    pub fn table_name(&mut self, table_name: &str) -> Self {
        self.table_name = Some(table_name.to_string());
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> () {
        let rc = Rc::new(self);
        (
        )
    }

    pub fn build(parameters: parameters_Arg, ms: ms_Arg, mom: mom_Arg, mg: mg_Arg, num_shards: i64, shard_id: i64) -> Self {
        Self {
            parameters,
            ms,
            mom,
            mg,
            table_id: None,
            table_name: None,
            num_shards: num_shards,
            shard_id: shard_id,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(parameters: parameters_Arg, ms: ms_Arg, mom: mom_Arg, mg: mg_Arg, num_shards: i64, shard_id: i64) -> () {
        Self {
            parameters,
            ms,
            mom,
            mg,
            table_id: None,
            table_name: None,
            num_shards: num_shards,
            shard_id: shard_id,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl GraphOperation for RetrieveTPUEmbeddingRMSPropParameters {
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("RetrieveTPUEmbeddingRMSPropParameters_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("RetrieveTPUEmbeddingRMSPropParameters", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            match self.table_id {
                None => new_op.set_attr_value_proto("table_id", &vec![24_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 1_u8,])?,
                Some(ref value) => (|attr: &i64| {new_op.set_attr_int("table_id", *attr)})(&value)?,
            };
        }
        {
            match self.table_name {
                None => new_op.set_attr_value_proto("table_name", &vec![18_u8, 0_u8,])?,
                Some(ref value) => (|attr| {new_op.set_attr_string("table_name", attr)})(&value)?,
            };
        }
        {
            (|attr: &i64| {new_op.set_attr_int("num_shards", *attr)})(&self.num_shards)?
        }
        {
            (|attr: &i64| {new_op.set_attr_int("shard_id", *attr)})(&self.shard_id)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct RetrieveTPUEmbeddingRMSPropParameters {
    table_id: Option<i64>,
    table_name: Option<String>,
    num_shards: i64,
    shard_id: i64,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl RetrieveTPUEmbeddingRMSPropParameters {
    pub fn parameters(self) -> Edge<f32> {
        let rc = Rc::new(self);
        {
            Edge::<f32>::new(rc.clone(), 0)
        }
    }

    pub fn ms(self) -> Edge<f32> {
        let rc = Rc::new(self);
        {
            Edge::<f32>::new(rc.clone(), 1)
        }
    }

    pub fn mom(self) -> Edge<f32> {
        let rc = Rc::new(self);
        {
            Edge::<f32>::new(rc.clone(), 2)
        }
    }

    pub fn table_id(&mut self, table_id: i64) -> Self {
        self.table_id = Some(table_id);
        self.clone()
    }

    pub fn table_name(&mut self, table_name: &str) -> Self {
        self.table_name = Some(table_name.to_string());
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> (Edge<f32>, Edge<f32>, Edge<f32>) {
        let rc = Rc::new(self);
        (
        {
            Edge::<f32>::new(rc.clone(), 0)
        },
        {
            Edge::<f32>::new(rc.clone(), 1)
        },
        {
            Edge::<f32>::new(rc.clone(), 2)
        },
        )
    }

    pub fn build(num_shards: i64, shard_id: i64) -> Self {
        Self {
            table_id: None,
            table_name: None,
            num_shards: num_shards,
            shard_id: shard_id,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(num_shards: i64, shard_id: i64) -> (Edge<f32>, Edge<f32>, Edge<f32>) {
        Self {
            table_id: None,
            table_name: None,
            num_shards: num_shards,
            shard_id: shard_id,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<dtype> GraphOperation for Variable<dtype>
where dtype: TensorType,
      dtype: 'static,
      dtype: Clone,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("Variable_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("Variable", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            (|attr| {new_op.set_attr_shape("shape", attr)})(&self.shape)?
        }
        {
            new_op.set_attr_type("dtype", dtype::data_type())?;
        }
        {
            match self.container {
                None => new_op.set_attr_value_proto("container", &vec![18_u8, 0_u8,])?,
                Some(ref value) => (|attr| {new_op.set_attr_string("container", attr)})(&value)?,
            };
        }
        {
            match self.shared_name {
                None => new_op.set_attr_value_proto("shared_name", &vec![18_u8, 0_u8,])?,
                Some(ref value) => (|attr| {new_op.set_attr_string("shared_name", attr)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct Variable<dtype>
where dtype: TensorType,
      dtype: 'static,
      dtype: Clone,
{
    shape: OtherShape,
    phantom_dtype: PhantomData<dtype>,
    container: Option<String>,
    shared_name: Option<String>,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<dtype> Variable<dtype>
where dtype: TensorType,
      dtype: 'static,
      dtype: Clone,
{
    pub fn ref_(self) -> RefEdge<dtype> {
        let rc = Rc::new(self);
        {
            RefEdge::<dtype>::new(rc.clone(), 0)
        }
    }

    pub fn container(&mut self, container: &str) -> Self {
        self.container = Some(container.to_string());
        self.clone()
    }

    pub fn shared_name(&mut self, shared_name: &str) -> Self {
        self.shared_name = Some(shared_name.to_string());
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> RefEdge<dtype> {
        let rc = Rc::new(self);
        {
            RefEdge::<dtype>::new(rc.clone(), 0)
        }
    }

    pub fn build(shape: &OtherShape) -> Self {
        Self {
            shape: shape.clone(),
            phantom_dtype: PhantomData,
            container: None,
            shared_name: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(shape: &OtherShape) -> RefEdge<dtype> {
        Self {
            shape: shape.clone(),
            phantom_dtype: PhantomData,
            container: None,
            shared_name: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<parameters_Arg, momenta_Arg, velocities_Arg, gradient_accumulators_Arg> GraphOperation for LoadTPUEmbeddingADAMParametersGradAccumDebug<parameters_Arg, momenta_Arg, velocities_Arg, gradient_accumulators_Arg>
where parameters_Arg: Clone,
      parameters_Arg: GraphEdge<f32>,
      parameters_Arg: 'static,
      momenta_Arg: Clone,
      momenta_Arg: GraphEdge<f32>,
      momenta_Arg: 'static,
      velocities_Arg: Clone,
      velocities_Arg: GraphEdge<f32>,
      velocities_Arg: 'static,
      gradient_accumulators_Arg: Clone,
      gradient_accumulators_Arg: GraphEdge<f32>,
      gradient_accumulators_Arg: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("LoadTPUEmbeddingADAMParametersGradAccumDebug_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("LoadTPUEmbeddingADAMParametersGradAccumDebug", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.parameters)?
        }
        {
            new_op.add_edge(&self.momenta)?
        }
        {
            new_op.add_edge(&self.velocities)?
        }
        {
            new_op.add_edge(&self.gradient_accumulators)?
        }
        {
            match self.table_id {
                None => new_op.set_attr_value_proto("table_id", &vec![24_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 1_u8,])?,
                Some(ref value) => (|attr: &i64| {new_op.set_attr_int("table_id", *attr)})(&value)?,
            };
        }
        {
            match self.table_name {
                None => new_op.set_attr_value_proto("table_name", &vec![18_u8, 0_u8,])?,
                Some(ref value) => (|attr| {new_op.set_attr_string("table_name", attr)})(&value)?,
            };
        }
        {
            (|attr: &i64| {new_op.set_attr_int("num_shards", *attr)})(&self.num_shards)?
        }
        {
            (|attr: &i64| {new_op.set_attr_int("shard_id", *attr)})(&self.shard_id)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct LoadTPUEmbeddingADAMParametersGradAccumDebug<parameters_Arg, momenta_Arg, velocities_Arg, gradient_accumulators_Arg>
where parameters_Arg: Clone,
      parameters_Arg: GraphEdge<f32>,
      parameters_Arg: 'static,
      momenta_Arg: Clone,
      momenta_Arg: GraphEdge<f32>,
      momenta_Arg: 'static,
      velocities_Arg: Clone,
      velocities_Arg: GraphEdge<f32>,
      velocities_Arg: 'static,
      gradient_accumulators_Arg: Clone,
      gradient_accumulators_Arg: GraphEdge<f32>,
      gradient_accumulators_Arg: 'static,
{
    parameters: parameters_Arg,
    momenta: momenta_Arg,
    velocities: velocities_Arg,
    gradient_accumulators: gradient_accumulators_Arg,
    table_id: Option<i64>,
    table_name: Option<String>,
    num_shards: i64,
    shard_id: i64,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<parameters_Arg, momenta_Arg, velocities_Arg, gradient_accumulators_Arg> LoadTPUEmbeddingADAMParametersGradAccumDebug<parameters_Arg, momenta_Arg, velocities_Arg, gradient_accumulators_Arg>
where parameters_Arg: Clone,
      parameters_Arg: GraphEdge<f32>,
      parameters_Arg: 'static,
      momenta_Arg: Clone,
      momenta_Arg: GraphEdge<f32>,
      momenta_Arg: 'static,
      velocities_Arg: Clone,
      velocities_Arg: GraphEdge<f32>,
      velocities_Arg: 'static,
      gradient_accumulators_Arg: Clone,
      gradient_accumulators_Arg: GraphEdge<f32>,
      gradient_accumulators_Arg: 'static,
{
    pub fn table_id(&mut self, table_id: i64) -> Self {
        self.table_id = Some(table_id);
        self.clone()
    }

    pub fn table_name(&mut self, table_name: &str) -> Self {
        self.table_name = Some(table_name.to_string());
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> () {
        let rc = Rc::new(self);
        (
        )
    }

    pub fn build(parameters: parameters_Arg, momenta: momenta_Arg, velocities: velocities_Arg, gradient_accumulators: gradient_accumulators_Arg, num_shards: i64, shard_id: i64) -> Self {
        Self {
            parameters,
            momenta,
            velocities,
            gradient_accumulators,
            table_id: None,
            table_name: None,
            num_shards: num_shards,
            shard_id: shard_id,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(parameters: parameters_Arg, momenta: momenta_Arg, velocities: velocities_Arg, gradient_accumulators: gradient_accumulators_Arg, num_shards: i64, shard_id: i64) -> () {
        Self {
            parameters,
            momenta,
            velocities,
            gradient_accumulators,
            table_id: None,
            table_name: None,
            num_shards: num_shards,
            shard_id: shard_id,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<sparse_indices_Arg, T, sparse_values_Arg, sparse_shape_Arg> GraphOperation for AddManySparseToTensorsMap<sparse_indices_Arg, T, sparse_values_Arg, sparse_shape_Arg>
where sparse_indices_Arg: Clone,
      sparse_indices_Arg: GraphEdge<i64>,
      sparse_indices_Arg: 'static,
      T: TensorType,
      T: Clone,
      sparse_values_Arg: Clone,
      sparse_values_Arg: GraphEdge<T>,
      sparse_values_Arg: 'static,
      sparse_shape_Arg: Clone,
      sparse_shape_Arg: GraphEdge<i64>,
      sparse_shape_Arg: 'static,
      T: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("AddManySparseToTensorsMap_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("AddManySparseToTensorsMap", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.sparse_indices)?
        }
        {
            new_op.add_edge(&self.sparse_values)?
        }
        {
            new_op.add_edge(&self.sparse_shape)?
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        {
            match self.container {
                None => new_op.set_attr_value_proto("container", &vec![18_u8, 0_u8,])?,
                Some(ref value) => (|attr| {new_op.set_attr_string("container", attr)})(&value)?,
            };
        }
        {
            match self.shared_name {
                None => new_op.set_attr_value_proto("shared_name", &vec![18_u8, 0_u8,])?,
                Some(ref value) => (|attr| {new_op.set_attr_string("shared_name", attr)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct AddManySparseToTensorsMap<sparse_indices_Arg, T, sparse_values_Arg, sparse_shape_Arg>
where sparse_indices_Arg: Clone,
      sparse_indices_Arg: GraphEdge<i64>,
      sparse_indices_Arg: 'static,
      T: TensorType,
      T: Clone,
      sparse_values_Arg: Clone,
      sparse_values_Arg: GraphEdge<T>,
      sparse_values_Arg: 'static,
      sparse_shape_Arg: Clone,
      sparse_shape_Arg: GraphEdge<i64>,
      sparse_shape_Arg: 'static,
      T: 'static,
{
    sparse_indices: sparse_indices_Arg,
    phantom_T: PhantomData<T>,
    sparse_values: sparse_values_Arg,
    sparse_shape: sparse_shape_Arg,
    container: Option<String>,
    shared_name: Option<String>,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<sparse_indices_Arg, T, sparse_values_Arg, sparse_shape_Arg> AddManySparseToTensorsMap<sparse_indices_Arg, T, sparse_values_Arg, sparse_shape_Arg>
where sparse_indices_Arg: Clone,
      sparse_indices_Arg: GraphEdge<i64>,
      sparse_indices_Arg: 'static,
      T: TensorType,
      T: Clone,
      sparse_values_Arg: Clone,
      sparse_values_Arg: GraphEdge<T>,
      sparse_values_Arg: 'static,
      sparse_shape_Arg: Clone,
      sparse_shape_Arg: GraphEdge<i64>,
      sparse_shape_Arg: 'static,
      T: 'static,
{
    pub fn sparse_handles(self) -> Edge<i64> {
        let rc = Rc::new(self);
        {
            Edge::<i64>::new(rc.clone(), 0)
        }
    }

    pub fn container(&mut self, container: &str) -> Self {
        self.container = Some(container.to_string());
        self.clone()
    }

    pub fn shared_name(&mut self, shared_name: &str) -> Self {
        self.shared_name = Some(shared_name.to_string());
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<i64> {
        let rc = Rc::new(self);
        {
            Edge::<i64>::new(rc.clone(), 0)
        }
    }

    pub fn build(sparse_indices: sparse_indices_Arg, sparse_values: sparse_values_Arg, sparse_shape: sparse_shape_Arg) -> Self {
        Self {
            sparse_indices,
            phantom_T: PhantomData,
            sparse_values,
            sparse_shape,
            container: None,
            shared_name: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(sparse_indices: sparse_indices_Arg, sparse_values: sparse_values_Arg, sparse_shape: sparse_shape_Arg) -> Edge<i64> {
        Self {
            sparse_indices,
            phantom_T: PhantomData,
            sparse_values,
            sparse_shape,
            container: None,
            shared_name: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<table_handle_Arg, Tin, keys_Arg, Tout, values_Arg> GraphOperation for LookupTableImport<table_handle_Arg, Tin, keys_Arg, Tout, values_Arg>
where table_handle_Arg: Clone,
      table_handle_Arg: GraphRefEdge<String>,
      table_handle_Arg: 'static,
      Tin: TensorType,
      Tin: Clone,
      keys_Arg: Clone,
      keys_Arg: GraphEdge<Tin>,
      keys_Arg: 'static,
      Tout: TensorType,
      Tout: Clone,
      values_Arg: Clone,
      values_Arg: GraphEdge<Tout>,
      values_Arg: 'static,
      Tin: 'static,
      Tout: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("LookupTableImport_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("LookupTableImport", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.table_handle)?
        }
        {
            new_op.add_edge(&self.keys)?
        }
        {
            new_op.add_edge(&self.values)?
        }
        {
            new_op.set_attr_type("Tin", Tin::data_type())?;
        }
        {
            new_op.set_attr_type("Tout", Tout::data_type())?;
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct LookupTableImport<table_handle_Arg, Tin, keys_Arg, Tout, values_Arg>
where table_handle_Arg: Clone,
      table_handle_Arg: GraphRefEdge<String>,
      table_handle_Arg: 'static,
      Tin: TensorType,
      Tin: Clone,
      keys_Arg: Clone,
      keys_Arg: GraphEdge<Tin>,
      keys_Arg: 'static,
      Tout: TensorType,
      Tout: Clone,
      values_Arg: Clone,
      values_Arg: GraphEdge<Tout>,
      values_Arg: 'static,
      Tin: 'static,
      Tout: 'static,
{
    table_handle: table_handle_Arg,
    phantom_Tin: PhantomData<Tin>,
    keys: keys_Arg,
    phantom_Tout: PhantomData<Tout>,
    values: values_Arg,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<table_handle_Arg, Tin, keys_Arg, Tout, values_Arg> LookupTableImport<table_handle_Arg, Tin, keys_Arg, Tout, values_Arg>
where table_handle_Arg: Clone,
      table_handle_Arg: GraphRefEdge<String>,
      table_handle_Arg: 'static,
      Tin: TensorType,
      Tin: Clone,
      keys_Arg: Clone,
      keys_Arg: GraphEdge<Tin>,
      keys_Arg: 'static,
      Tout: TensorType,
      Tout: Clone,
      values_Arg: Clone,
      values_Arg: GraphEdge<Tout>,
      values_Arg: 'static,
      Tin: 'static,
      Tout: 'static,
{
    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> () {
        let rc = Rc::new(self);
        (
        )
    }

    pub fn build(table_handle: table_handle_Arg, keys: keys_Arg, values: values_Arg) -> Self {
        Self {
            table_handle,
            phantom_Tin: PhantomData,
            keys,
            phantom_Tout: PhantomData,
            values,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(table_handle: table_handle_Arg, keys: keys_Arg, values: values_Arg) -> () {
        Self {
            table_handle,
            phantom_Tin: PhantomData,
            keys,
            phantom_Tout: PhantomData,
            values,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<parameters_Arg, accumulators_Arg, updates_Arg> GraphOperation for LoadTPUEmbeddingAdadeltaParameters<parameters_Arg, accumulators_Arg, updates_Arg>
where parameters_Arg: Clone,
      parameters_Arg: GraphEdge<f32>,
      parameters_Arg: 'static,
      accumulators_Arg: Clone,
      accumulators_Arg: GraphEdge<f32>,
      accumulators_Arg: 'static,
      updates_Arg: Clone,
      updates_Arg: GraphEdge<f32>,
      updates_Arg: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("LoadTPUEmbeddingAdadeltaParameters_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("LoadTPUEmbeddingAdadeltaParameters", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.parameters)?
        }
        {
            new_op.add_edge(&self.accumulators)?
        }
        {
            new_op.add_edge(&self.updates)?
        }
        {
            match self.table_id {
                None => new_op.set_attr_value_proto("table_id", &vec![24_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 1_u8,])?,
                Some(ref value) => (|attr: &i64| {new_op.set_attr_int("table_id", *attr)})(&value)?,
            };
        }
        {
            match self.table_name {
                None => new_op.set_attr_value_proto("table_name", &vec![18_u8, 0_u8,])?,
                Some(ref value) => (|attr| {new_op.set_attr_string("table_name", attr)})(&value)?,
            };
        }
        {
            (|attr: &i64| {new_op.set_attr_int("num_shards", *attr)})(&self.num_shards)?
        }
        {
            (|attr: &i64| {new_op.set_attr_int("shard_id", *attr)})(&self.shard_id)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct LoadTPUEmbeddingAdadeltaParameters<parameters_Arg, accumulators_Arg, updates_Arg>
where parameters_Arg: Clone,
      parameters_Arg: GraphEdge<f32>,
      parameters_Arg: 'static,
      accumulators_Arg: Clone,
      accumulators_Arg: GraphEdge<f32>,
      accumulators_Arg: 'static,
      updates_Arg: Clone,
      updates_Arg: GraphEdge<f32>,
      updates_Arg: 'static,
{
    parameters: parameters_Arg,
    accumulators: accumulators_Arg,
    updates: updates_Arg,
    table_id: Option<i64>,
    table_name: Option<String>,
    num_shards: i64,
    shard_id: i64,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<parameters_Arg, accumulators_Arg, updates_Arg> LoadTPUEmbeddingAdadeltaParameters<parameters_Arg, accumulators_Arg, updates_Arg>
where parameters_Arg: Clone,
      parameters_Arg: GraphEdge<f32>,
      parameters_Arg: 'static,
      accumulators_Arg: Clone,
      accumulators_Arg: GraphEdge<f32>,
      accumulators_Arg: 'static,
      updates_Arg: Clone,
      updates_Arg: GraphEdge<f32>,
      updates_Arg: 'static,
{
    pub fn table_id(&mut self, table_id: i64) -> Self {
        self.table_id = Some(table_id);
        self.clone()
    }

    pub fn table_name(&mut self, table_name: &str) -> Self {
        self.table_name = Some(table_name.to_string());
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> () {
        let rc = Rc::new(self);
        (
        )
    }

    pub fn build(parameters: parameters_Arg, accumulators: accumulators_Arg, updates: updates_Arg, num_shards: i64, shard_id: i64) -> Self {
        Self {
            parameters,
            accumulators,
            updates,
            table_id: None,
            table_name: None,
            num_shards: num_shards,
            shard_id: shard_id,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(parameters: parameters_Arg, accumulators: accumulators_Arg, updates: updates_Arg, num_shards: i64, shard_id: i64) -> () {
        Self {
            parameters,
            accumulators,
            updates,
            table_id: None,
            table_name: None,
            num_shards: num_shards,
            shard_id: shard_id,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl GraphOperation for TPUCompilationResult {
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("TPUCompilationResult_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("TPUCompilationResult", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct TPUCompilationResult {
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl TPUCompilationResult {
    pub fn output(self) -> Edge<String> {
        let rc = Rc::new(self);
        {
            Edge::<String>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<String> {
        let rc = Rc::new(self);
        {
            Edge::<String>::new(rc.clone(), 0)
        }
    }

    pub fn build() -> Self {
        Self {
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new() -> Edge<String> {
        Self {
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<json_Arg> GraphOperation for GcsConfigureCredentials<json_Arg>
where json_Arg: Clone,
      json_Arg: GraphEdge<String>,
      json_Arg: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("GcsConfigureCredentials_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("GcsConfigureCredentials", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.json)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct GcsConfigureCredentials<json_Arg>
where json_Arg: Clone,
      json_Arg: GraphEdge<String>,
      json_Arg: 'static,
{
    json: json_Arg,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<json_Arg> GcsConfigureCredentials<json_Arg>
where json_Arg: Clone,
      json_Arg: GraphEdge<String>,
      json_Arg: 'static,
{
    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> () {
        let rc = Rc::new(self);
        (
        )
    }

    pub fn build(json: json_Arg) -> Self {
        Self {
            json,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(json: json_Arg) -> () {
        Self {
            json,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<reader_handle_Arg> GraphOperation for ReaderNumWorkUnitsCompleted<reader_handle_Arg>
where reader_handle_Arg: Clone,
      reader_handle_Arg: GraphRefEdge<String>,
      reader_handle_Arg: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("ReaderNumWorkUnitsCompleted_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("ReaderNumWorkUnitsCompleted", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.reader_handle)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct ReaderNumWorkUnitsCompleted<reader_handle_Arg>
where reader_handle_Arg: Clone,
      reader_handle_Arg: GraphRefEdge<String>,
      reader_handle_Arg: 'static,
{
    reader_handle: reader_handle_Arg,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<reader_handle_Arg> ReaderNumWorkUnitsCompleted<reader_handle_Arg>
where reader_handle_Arg: Clone,
      reader_handle_Arg: GraphRefEdge<String>,
      reader_handle_Arg: 'static,
{
    pub fn units_completed(self) -> Edge<i64> {
        let rc = Rc::new(self);
        {
            Edge::<i64>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<i64> {
        let rc = Rc::new(self);
        {
            Edge::<i64>::new(rc.clone(), 0)
        }
    }

    pub fn build(reader_handle: reader_handle_Arg) -> Self {
        Self {
            reader_handle,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(reader_handle: reader_handle_Arg) -> Edge<i64> {
        Self {
            reader_handle,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<T, input_Arg> GraphOperation for XlaClusterOutput<T, input_Arg>
where T: TensorType,
      T: Clone,
      input_Arg: Clone,
      input_Arg: GraphEdge<T>,
      input_Arg: 'static,
      T: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("XlaClusterOutput_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("XlaClusterOutput", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.input)?
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct XlaClusterOutput<T, input_Arg>
where T: TensorType,
      T: Clone,
      input_Arg: Clone,
      input_Arg: GraphEdge<T>,
      input_Arg: 'static,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    input: input_Arg,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<T, input_Arg> XlaClusterOutput<T, input_Arg>
where T: TensorType,
      T: Clone,
      input_Arg: Clone,
      input_Arg: GraphEdge<T>,
      input_Arg: 'static,
      T: 'static,
{
    pub fn outputs(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(input: input_Arg) -> Self {
        Self {
            phantom_T: PhantomData,
            input,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(input: input_Arg) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            input,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<T, input_Arg, Index, begin_Arg, end_Arg, strides_Arg> GraphOperation for StridedSlice<T, input_Arg, Index, begin_Arg, end_Arg, strides_Arg>
where T: TensorType,
      T: Clone,
      input_Arg: Clone,
      input_Arg: GraphEdge<T>,
      input_Arg: 'static,
      Index: TensorType,
      Index: Clone,
      begin_Arg: Clone,
      begin_Arg: GraphEdge<Index>,
      begin_Arg: 'static,
      end_Arg: Clone,
      end_Arg: GraphEdge<Index>,
      end_Arg: 'static,
      strides_Arg: Clone,
      strides_Arg: GraphEdge<Index>,
      strides_Arg: 'static,
      T: 'static,
      Index: con_or_DT_INT32_or_DT_INT64,
      Index: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("StridedSlice_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("StridedSlice", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.input)?
        }
        {
            new_op.add_edge(&self.begin)?
        }
        {
            new_op.add_edge(&self.end)?
        }
        {
            new_op.add_edge(&self.strides)?
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        {
            new_op.set_attr_type("Index", Index::data_type())?;
        }
        {
            match self.begin_mask {
                None => new_op.set_attr_value_proto("begin_mask", &vec![24_u8, 0_u8,])?,
                Some(ref value) => (|attr: &i64| {new_op.set_attr_int("begin_mask", *attr)})(&value)?,
            };
        }
        {
            match self.end_mask {
                None => new_op.set_attr_value_proto("end_mask", &vec![24_u8, 0_u8,])?,
                Some(ref value) => (|attr: &i64| {new_op.set_attr_int("end_mask", *attr)})(&value)?,
            };
        }
        {
            match self.ellipsis_mask {
                None => new_op.set_attr_value_proto("ellipsis_mask", &vec![24_u8, 0_u8,])?,
                Some(ref value) => (|attr: &i64| {new_op.set_attr_int("ellipsis_mask", *attr)})(&value)?,
            };
        }
        {
            match self.new_axis_mask {
                None => new_op.set_attr_value_proto("new_axis_mask", &vec![24_u8, 0_u8,])?,
                Some(ref value) => (|attr: &i64| {new_op.set_attr_int("new_axis_mask", *attr)})(&value)?,
            };
        }
        {
            match self.shrink_axis_mask {
                None => new_op.set_attr_value_proto("shrink_axis_mask", &vec![24_u8, 0_u8,])?,
                Some(ref value) => (|attr: &i64| {new_op.set_attr_int("shrink_axis_mask", *attr)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct StridedSlice<T, input_Arg, Index, begin_Arg, end_Arg, strides_Arg>
where T: TensorType,
      T: Clone,
      input_Arg: Clone,
      input_Arg: GraphEdge<T>,
      input_Arg: 'static,
      Index: TensorType,
      Index: Clone,
      begin_Arg: Clone,
      begin_Arg: GraphEdge<Index>,
      begin_Arg: 'static,
      end_Arg: Clone,
      end_Arg: GraphEdge<Index>,
      end_Arg: 'static,
      strides_Arg: Clone,
      strides_Arg: GraphEdge<Index>,
      strides_Arg: 'static,
      T: 'static,
      Index: con_or_DT_INT32_or_DT_INT64,
      Index: 'static,
{
    phantom_T: PhantomData<T>,
    input: input_Arg,
    phantom_Index: PhantomData<Index>,
    begin: begin_Arg,
    end: end_Arg,
    strides: strides_Arg,
    begin_mask: Option<i64>,
    end_mask: Option<i64>,
    ellipsis_mask: Option<i64>,
    new_axis_mask: Option<i64>,
    shrink_axis_mask: Option<i64>,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<T, input_Arg, Index, begin_Arg, end_Arg, strides_Arg> StridedSlice<T, input_Arg, Index, begin_Arg, end_Arg, strides_Arg>
where T: TensorType,
      T: Clone,
      input_Arg: Clone,
      input_Arg: GraphEdge<T>,
      input_Arg: 'static,
      Index: TensorType,
      Index: Clone,
      begin_Arg: Clone,
      begin_Arg: GraphEdge<Index>,
      begin_Arg: 'static,
      end_Arg: Clone,
      end_Arg: GraphEdge<Index>,
      end_Arg: 'static,
      strides_Arg: Clone,
      strides_Arg: GraphEdge<Index>,
      strides_Arg: 'static,
      T: 'static,
      Index: con_or_DT_INT32_or_DT_INT64,
      Index: 'static,
{
    pub fn output(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn begin_mask(&mut self, begin_mask: i64) -> Self {
        self.begin_mask = Some(begin_mask);
        self.clone()
    }

    pub fn end_mask(&mut self, end_mask: i64) -> Self {
        self.end_mask = Some(end_mask);
        self.clone()
    }

    pub fn ellipsis_mask(&mut self, ellipsis_mask: i64) -> Self {
        self.ellipsis_mask = Some(ellipsis_mask);
        self.clone()
    }

    pub fn new_axis_mask(&mut self, new_axis_mask: i64) -> Self {
        self.new_axis_mask = Some(new_axis_mask);
        self.clone()
    }

    pub fn shrink_axis_mask(&mut self, shrink_axis_mask: i64) -> Self {
        self.shrink_axis_mask = Some(shrink_axis_mask);
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(input: input_Arg, begin: begin_Arg, end: end_Arg, strides: strides_Arg) -> Self {
        Self {
            phantom_T: PhantomData,
            input,
            phantom_Index: PhantomData,
            begin,
            end,
            strides,
            begin_mask: None,
            end_mask: None,
            ellipsis_mask: None,
            new_axis_mask: None,
            shrink_axis_mask: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(input: input_Arg, begin: begin_Arg, end: end_Arg, strides: strides_Arg) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            input,
            phantom_Index: PhantomData,
            begin,
            end,
            strides,
            begin_mask: None,
            end_mask: None,
            ellipsis_mask: None,
            new_axis_mask: None,
            shrink_axis_mask: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<T, input_Arg> GraphOperation for TPUReplicatedOutput<T, input_Arg>
where T: TensorType,
      T: Clone,
      input_Arg: Clone,
      input_Arg: GraphEdge<T>,
      input_Arg: 'static,
      T: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("TPUReplicatedOutput_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("TPUReplicatedOutput", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.input)?
        }
        {
            (|attr: &i64| {new_op.set_attr_int("num_replicas", *attr)})(&self.num_replicas)?
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct TPUReplicatedOutput<T, input_Arg>
where T: TensorType,
      T: Clone,
      input_Arg: Clone,
      input_Arg: GraphEdge<T>,
      input_Arg: 'static,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    input: input_Arg,
    num_replicas: i64,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<T, input_Arg> TPUReplicatedOutput<T, input_Arg>
where T: TensorType,
      T: Clone,
      input_Arg: Clone,
      input_Arg: GraphEdge<T>,
      input_Arg: 'static,
      T: 'static,
{
    pub fn outputs(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(input: input_Arg, num_replicas: i64) -> Self {
        Self {
            phantom_T: PhantomData,
            input,
            num_replicas: num_replicas,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(input: input_Arg, num_replicas: i64) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            input,
            num_replicas: num_replicas,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

pub trait con_or_DT_FLOAT_or_DT_BFLOAT16 {
}

impl con_or_DT_FLOAT_or_DT_BFLOAT16 for BFloat16 {
}

impl con_or_DT_FLOAT_or_DT_BFLOAT16 for f32 {
}

impl<T, input_Arg, group_assignment_Arg> GraphOperation for CrossReplicaSum<T, input_Arg, group_assignment_Arg>
where T: TensorType,
      T: Clone,
      input_Arg: Clone,
      input_Arg: GraphEdge<T>,
      input_Arg: 'static,
      group_assignment_Arg: Clone,
      group_assignment_Arg: GraphEdge<i32>,
      group_assignment_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_BFLOAT16,
      T: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("CrossReplicaSum_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("CrossReplicaSum", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.input)?
        }
        {
            new_op.add_edge(&self.group_assignment)?
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct CrossReplicaSum<T, input_Arg, group_assignment_Arg>
where T: TensorType,
      T: Clone,
      input_Arg: Clone,
      input_Arg: GraphEdge<T>,
      input_Arg: 'static,
      group_assignment_Arg: Clone,
      group_assignment_Arg: GraphEdge<i32>,
      group_assignment_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_BFLOAT16,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    input: input_Arg,
    group_assignment: group_assignment_Arg,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<T, input_Arg, group_assignment_Arg> CrossReplicaSum<T, input_Arg, group_assignment_Arg>
where T: TensorType,
      T: Clone,
      input_Arg: Clone,
      input_Arg: GraphEdge<T>,
      input_Arg: 'static,
      group_assignment_Arg: Clone,
      group_assignment_Arg: GraphEdge<i32>,
      group_assignment_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_BFLOAT16,
      T: 'static,
{
    pub fn output(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(input: input_Arg, group_assignment: group_assignment_Arg) -> Self {
        Self {
            phantom_T: PhantomData,
            input,
            group_assignment,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(input: input_Arg, group_assignment: group_assignment_Arg) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            input,
            group_assignment,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<gradients_Arg, inputs_Arg, min_Arg, max_Arg> GraphOperation for FakeQuantWithMinMaxVarsGradient<gradients_Arg, inputs_Arg, min_Arg, max_Arg>
where gradients_Arg: Clone,
      gradients_Arg: GraphEdge<f32>,
      gradients_Arg: 'static,
      inputs_Arg: Clone,
      inputs_Arg: GraphEdge<f32>,
      inputs_Arg: 'static,
      min_Arg: Clone,
      min_Arg: GraphEdge<f32>,
      min_Arg: 'static,
      max_Arg: Clone,
      max_Arg: GraphEdge<f32>,
      max_Arg: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("FakeQuantWithMinMaxVarsGradient_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("FakeQuantWithMinMaxVarsGradient", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.gradients)?
        }
        {
            new_op.add_edge(&self.inputs)?
        }
        {
            new_op.add_edge(&self.min)?
        }
        {
            new_op.add_edge(&self.max)?
        }
        {
            match self.num_bits {
                None => new_op.set_attr_value_proto("num_bits", &vec![24_u8, 8_u8,])?,
                Some(ref value) => (|attr: &i64| {new_op.set_attr_int("num_bits", *attr)})(&value)?,
            };
        }
        {
            match self.narrow_range {
                None => new_op.set_attr_value_proto("narrow_range", &vec![40_u8, 0_u8,])?,
                Some(ref value) => (|attr: &bool| {new_op.set_attr_bool("narrow_range", *attr)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct FakeQuantWithMinMaxVarsGradient<gradients_Arg, inputs_Arg, min_Arg, max_Arg>
where gradients_Arg: Clone,
      gradients_Arg: GraphEdge<f32>,
      gradients_Arg: 'static,
      inputs_Arg: Clone,
      inputs_Arg: GraphEdge<f32>,
      inputs_Arg: 'static,
      min_Arg: Clone,
      min_Arg: GraphEdge<f32>,
      min_Arg: 'static,
      max_Arg: Clone,
      max_Arg: GraphEdge<f32>,
      max_Arg: 'static,
{
    gradients: gradients_Arg,
    inputs: inputs_Arg,
    min: min_Arg,
    max: max_Arg,
    num_bits: Option<i64>,
    narrow_range: Option<bool>,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<gradients_Arg, inputs_Arg, min_Arg, max_Arg> FakeQuantWithMinMaxVarsGradient<gradients_Arg, inputs_Arg, min_Arg, max_Arg>
where gradients_Arg: Clone,
      gradients_Arg: GraphEdge<f32>,
      gradients_Arg: 'static,
      inputs_Arg: Clone,
      inputs_Arg: GraphEdge<f32>,
      inputs_Arg: 'static,
      min_Arg: Clone,
      min_Arg: GraphEdge<f32>,
      min_Arg: 'static,
      max_Arg: Clone,
      max_Arg: GraphEdge<f32>,
      max_Arg: 'static,
{
    pub fn backprops_wrt_input(self) -> Edge<f32> {
        let rc = Rc::new(self);
        {
            Edge::<f32>::new(rc.clone(), 0)
        }
    }

    pub fn backprop_wrt_min(self) -> Edge<f32> {
        let rc = Rc::new(self);
        {
            Edge::<f32>::new(rc.clone(), 1)
        }
    }

    pub fn backprop_wrt_max(self) -> Edge<f32> {
        let rc = Rc::new(self);
        {
            Edge::<f32>::new(rc.clone(), 2)
        }
    }

    pub fn num_bits(&mut self, num_bits: i64) -> Self {
        self.num_bits = Some(num_bits);
        self.clone()
    }

    pub fn narrow_range(&mut self, narrow_range: bool) -> Self {
        self.narrow_range = Some(narrow_range);
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> (Edge<f32>, Edge<f32>, Edge<f32>) {
        let rc = Rc::new(self);
        (
        {
            Edge::<f32>::new(rc.clone(), 0)
        },
        {
            Edge::<f32>::new(rc.clone(), 1)
        },
        {
            Edge::<f32>::new(rc.clone(), 2)
        },
        )
    }

    pub fn build(gradients: gradients_Arg, inputs: inputs_Arg, min: min_Arg, max: max_Arg) -> Self {
        Self {
            gradients,
            inputs,
            min,
            max,
            num_bits: None,
            narrow_range: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(gradients: gradients_Arg, inputs: inputs_Arg, min: min_Arg, max: max_Arg) -> (Edge<f32>, Edge<f32>, Edge<f32>) {
        Self {
            gradients,
            inputs,
            min,
            max,
            num_bits: None,
            narrow_range: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<table_handle_Arg, filename_Arg> GraphOperation for InitializeTableFromTextFile<table_handle_Arg, filename_Arg>
where table_handle_Arg: Clone,
      table_handle_Arg: GraphRefEdge<String>,
      table_handle_Arg: 'static,
      filename_Arg: Clone,
      filename_Arg: GraphEdge<String>,
      filename_Arg: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("InitializeTableFromTextFile_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("InitializeTableFromTextFile", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.table_handle)?
        }
        {
            new_op.add_edge(&self.filename)?
        }
        {
            (|attr: &i64| {new_op.set_attr_int("key_index", *attr)})(&self.key_index)?
        }
        {
            (|attr: &i64| {new_op.set_attr_int("value_index", *attr)})(&self.value_index)?
        }
        {
            match self.vocab_size {
                None => new_op.set_attr_value_proto("vocab_size", &vec![24_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 1_u8,])?,
                Some(ref value) => (|attr: &i64| {new_op.set_attr_int("vocab_size", *attr)})(&value)?,
            };
        }
        {
            match self.delimiter {
                None => new_op.set_attr_value_proto("delimiter", &vec![18_u8, 1_u8,])?,
                Some(ref value) => (|attr| {new_op.set_attr_string("delimiter", attr)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct InitializeTableFromTextFile<table_handle_Arg, filename_Arg>
where table_handle_Arg: Clone,
      table_handle_Arg: GraphRefEdge<String>,
      table_handle_Arg: 'static,
      filename_Arg: Clone,
      filename_Arg: GraphEdge<String>,
      filename_Arg: 'static,
{
    table_handle: table_handle_Arg,
    filename: filename_Arg,
    key_index: i64,
    value_index: i64,
    vocab_size: Option<i64>,
    delimiter: Option<String>,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<table_handle_Arg, filename_Arg> InitializeTableFromTextFile<table_handle_Arg, filename_Arg>
where table_handle_Arg: Clone,
      table_handle_Arg: GraphRefEdge<String>,
      table_handle_Arg: 'static,
      filename_Arg: Clone,
      filename_Arg: GraphEdge<String>,
      filename_Arg: 'static,
{
    pub fn vocab_size(&mut self, vocab_size: i64) -> Self {
        self.vocab_size = Some(vocab_size);
        self.clone()
    }

    pub fn delimiter(&mut self, delimiter: &str) -> Self {
        self.delimiter = Some(delimiter.to_string());
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> () {
        let rc = Rc::new(self);
        (
        )
    }

    pub fn build(table_handle: table_handle_Arg, filename: filename_Arg, key_index: i64, value_index: i64) -> Self {
        Self {
            table_handle,
            filename,
            key_index: key_index,
            value_index: value_index,
            vocab_size: None,
            delimiter: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(table_handle: table_handle_Arg, filename: filename_Arg, key_index: i64, value_index: i64) -> () {
        Self {
            table_handle,
            filename,
            key_index: key_index,
            value_index: value_index,
            vocab_size: None,
            delimiter: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<T, tensor_Arg> GraphOperation for _Send<T, tensor_Arg>
where T: TensorType,
      T: Clone,
      tensor_Arg: Clone,
      tensor_Arg: GraphEdge<T>,
      tensor_Arg: 'static,
      T: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("_Send_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("_Send", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.tensor)?
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        {
            (|attr| {new_op.set_attr_string("tensor_name", attr)})(&self.tensor_name)?
        }
        {
            (|attr| {new_op.set_attr_string("send_device", attr)})(&self.send_device)?
        }
        {
            (|attr: &i64| {new_op.set_attr_int("send_device_incarnation", *attr)})(&self.send_device_incarnation)?
        }
        {
            (|attr| {new_op.set_attr_string("recv_device", attr)})(&self.recv_device)?
        }
        {
            match self.client_terminated {
                None => new_op.set_attr_value_proto("client_terminated", &vec![40_u8, 0_u8,])?,
                Some(ref value) => (|attr: &bool| {new_op.set_attr_bool("client_terminated", *attr)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct _Send<T, tensor_Arg>
where T: TensorType,
      T: Clone,
      tensor_Arg: Clone,
      tensor_Arg: GraphEdge<T>,
      tensor_Arg: 'static,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    tensor: tensor_Arg,
    tensor_name: String,
    send_device: String,
    send_device_incarnation: i64,
    recv_device: String,
    client_terminated: Option<bool>,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<T, tensor_Arg> _Send<T, tensor_Arg>
where T: TensorType,
      T: Clone,
      tensor_Arg: Clone,
      tensor_Arg: GraphEdge<T>,
      tensor_Arg: 'static,
      T: 'static,
{
    pub fn client_terminated(&mut self, client_terminated: bool) -> Self {
        self.client_terminated = Some(client_terminated);
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> () {
        let rc = Rc::new(self);
        (
        )
    }

    pub fn build(tensor: tensor_Arg, tensor_name: &str, send_device: &str, send_device_incarnation: i64, recv_device: &str) -> Self {
        Self {
            phantom_T: PhantomData,
            tensor,
            tensor_name: tensor_name.to_string(),
            send_device: send_device.to_string(),
            send_device_incarnation: send_device_incarnation,
            recv_device: recv_device.to_string(),
            client_terminated: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(tensor: tensor_Arg, tensor_name: &str, send_device: &str, send_device_incarnation: i64, recv_device: &str) -> () {
        Self {
            phantom_T: PhantomData,
            tensor,
            tensor_name: tensor_name.to_string(),
            send_device: send_device.to_string(),
            send_device_incarnation: send_device_incarnation,
            recv_device: recv_device.to_string(),
            client_terminated: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<T, x_Arg, y_Arg> GraphOperation for Minimum<T, x_Arg, y_Arg>
where T: TensorType,
      T: Clone,
      x_Arg: Clone,
      x_Arg: GraphEdge<T>,
      x_Arg: 'static,
      y_Arg: Clone,
      y_Arg: GraphEdge<T>,
      y_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_INT64_or_DT_BFLOAT16_or_DT_HALF,
      T: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("Minimum_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("Minimum", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.x)?
        }
        {
            new_op.add_edge(&self.y)?
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct Minimum<T, x_Arg, y_Arg>
where T: TensorType,
      T: Clone,
      x_Arg: Clone,
      x_Arg: GraphEdge<T>,
      x_Arg: 'static,
      y_Arg: Clone,
      y_Arg: GraphEdge<T>,
      y_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_INT64_or_DT_BFLOAT16_or_DT_HALF,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    x: x_Arg,
    y: y_Arg,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<T, x_Arg, y_Arg> Minimum<T, x_Arg, y_Arg>
where T: TensorType,
      T: Clone,
      x_Arg: Clone,
      x_Arg: GraphEdge<T>,
      x_Arg: 'static,
      y_Arg: Clone,
      y_Arg: GraphEdge<T>,
      y_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_INT64_or_DT_BFLOAT16_or_DT_HALF,
      T: 'static,
{
    pub fn z(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(x: x_Arg, y: y_Arg) -> Self {
        Self {
            phantom_T: PhantomData,
            x,
            y,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(x: x_Arg, y: y_Arg) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            x,
            y,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<T, values_Arg> GraphOperation for ParallelConcat<T, values_Arg>
where T: TensorType,
      T: Clone,
      values_Arg: Clone,
      values_Arg: GraphEdge<T>,
      values_Arg: 'static,
      T: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("ParallelConcat_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("ParallelConcat", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.values)?
        }
        {
            (|attr: &i64| {new_op.set_attr_int("N", *attr)})(&self.N)?
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        {
            (|attr| {new_op.set_attr_shape("shape", attr)})(&self.shape)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct ParallelConcat<T, values_Arg>
where T: TensorType,
      T: Clone,
      values_Arg: Clone,
      values_Arg: GraphEdge<T>,
      values_Arg: 'static,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    values: values_Arg,
    N: i64,
    shape: OtherShape,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<T, values_Arg> ParallelConcat<T, values_Arg>
where T: TensorType,
      T: Clone,
      values_Arg: Clone,
      values_Arg: GraphEdge<T>,
      values_Arg: 'static,
      T: 'static,
{
    pub fn output(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(values: values_Arg, N: i64, shape: &OtherShape) -> Self {
        Self {
            phantom_T: PhantomData,
            values,
            N: N,
            shape: shape.clone(),
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(values: values_Arg, N: i64, shape: &OtherShape) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            values,
            N: N,
            shape: shape.clone(),
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<dtype> GraphOperation for OutfeedDequeue<dtype>
where dtype: TensorType,
      dtype: 'static,
      dtype: Clone,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("OutfeedDequeue_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("OutfeedDequeue", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.set_attr_type("dtype", dtype::data_type())?;
        }
        {
            (|attr| {new_op.set_attr_shape("shape", attr)})(&self.shape)?
        }
        {
            match self.device_ordinal {
                None => new_op.set_attr_value_proto("device_ordinal", &vec![24_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 1_u8,])?,
                Some(ref value) => (|attr: &i64| {new_op.set_attr_int("device_ordinal", *attr)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct OutfeedDequeue<dtype>
where dtype: TensorType,
      dtype: 'static,
      dtype: Clone,
{
    phantom_dtype: PhantomData<dtype>,
    shape: OtherShape,
    device_ordinal: Option<i64>,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<dtype> OutfeedDequeue<dtype>
where dtype: TensorType,
      dtype: 'static,
      dtype: Clone,
{
    pub fn output(self) -> Edge<dtype> {
        let rc = Rc::new(self);
        {
            Edge::<dtype>::new(rc.clone(), 0)
        }
    }

    pub fn device_ordinal(&mut self, device_ordinal: i64) -> Self {
        self.device_ordinal = Some(device_ordinal);
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<dtype> {
        let rc = Rc::new(self);
        {
            Edge::<dtype>::new(rc.clone(), 0)
        }
    }

    pub fn build(shape: &OtherShape) -> Self {
        Self {
            phantom_dtype: PhantomData,
            shape: shape.clone(),
            device_ordinal: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(shape: &OtherShape) -> Edge<dtype> {
        Self {
            phantom_dtype: PhantomData,
            shape: shape.clone(),
            device_ordinal: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl GraphOperation for RetrieveTPUEmbeddingAdagradParametersGradAccumDebug {
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("RetrieveTPUEmbeddingAdagradParametersGradAccumDebug_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("RetrieveTPUEmbeddingAdagradParametersGradAccumDebug", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            match self.table_id {
                None => new_op.set_attr_value_proto("table_id", &vec![24_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 1_u8,])?,
                Some(ref value) => (|attr: &i64| {new_op.set_attr_int("table_id", *attr)})(&value)?,
            };
        }
        {
            match self.table_name {
                None => new_op.set_attr_value_proto("table_name", &vec![18_u8, 0_u8,])?,
                Some(ref value) => (|attr| {new_op.set_attr_string("table_name", attr)})(&value)?,
            };
        }
        {
            (|attr: &i64| {new_op.set_attr_int("num_shards", *attr)})(&self.num_shards)?
        }
        {
            (|attr: &i64| {new_op.set_attr_int("shard_id", *attr)})(&self.shard_id)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct RetrieveTPUEmbeddingAdagradParametersGradAccumDebug {
    table_id: Option<i64>,
    table_name: Option<String>,
    num_shards: i64,
    shard_id: i64,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl RetrieveTPUEmbeddingAdagradParametersGradAccumDebug {
    pub fn parameters(self) -> Edge<f32> {
        let rc = Rc::new(self);
        {
            Edge::<f32>::new(rc.clone(), 0)
        }
    }

    pub fn accumulators(self) -> Edge<f32> {
        let rc = Rc::new(self);
        {
            Edge::<f32>::new(rc.clone(), 1)
        }
    }

    pub fn gradient_accumulators(self) -> Edge<f32> {
        let rc = Rc::new(self);
        {
            Edge::<f32>::new(rc.clone(), 2)
        }
    }

    pub fn table_id(&mut self, table_id: i64) -> Self {
        self.table_id = Some(table_id);
        self.clone()
    }

    pub fn table_name(&mut self, table_name: &str) -> Self {
        self.table_name = Some(table_name.to_string());
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> (Edge<f32>, Edge<f32>, Edge<f32>) {
        let rc = Rc::new(self);
        (
        {
            Edge::<f32>::new(rc.clone(), 0)
        },
        {
            Edge::<f32>::new(rc.clone(), 1)
        },
        {
            Edge::<f32>::new(rc.clone(), 2)
        },
        )
    }

    pub fn build(num_shards: i64, shard_id: i64) -> Self {
        Self {
            table_id: None,
            table_name: None,
            num_shards: num_shards,
            shard_id: shard_id,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(num_shards: i64, shard_id: i64) -> (Edge<f32>, Edge<f32>, Edge<f32>) {
        Self {
            table_id: None,
            table_name: None,
            num_shards: num_shards,
            shard_id: shard_id,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<T, l_Arg, grad_Arg> GraphOperation for CholeskyGrad<T, l_Arg, grad_Arg>
where T: TensorType,
      T: Clone,
      l_Arg: Clone,
      l_Arg: GraphEdge<T>,
      l_Arg: 'static,
      grad_Arg: Clone,
      grad_Arg: GraphEdge<T>,
      grad_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE,
      T: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("CholeskyGrad_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("CholeskyGrad", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.l)?
        }
        {
            new_op.add_edge(&self.grad)?
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct CholeskyGrad<T, l_Arg, grad_Arg>
where T: TensorType,
      T: Clone,
      l_Arg: Clone,
      l_Arg: GraphEdge<T>,
      l_Arg: 'static,
      grad_Arg: Clone,
      grad_Arg: GraphEdge<T>,
      grad_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    l: l_Arg,
    grad: grad_Arg,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<T, l_Arg, grad_Arg> CholeskyGrad<T, l_Arg, grad_Arg>
where T: TensorType,
      T: Clone,
      l_Arg: Clone,
      l_Arg: GraphEdge<T>,
      l_Arg: 'static,
      grad_Arg: Clone,
      grad_Arg: GraphEdge<T>,
      grad_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE,
      T: 'static,
{
    pub fn output(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(l: l_Arg, grad: grad_Arg) -> Self {
        Self {
            phantom_T: PhantomData,
            l,
            grad,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(l: l_Arg, grad: grad_Arg) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            l,
            grad,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<T, x_Arg> GraphOperation for Atanh<T, x_Arg>
where T: TensorType,
      T: Clone,
      x_Arg: Clone,
      x_Arg: GraphEdge<T>,
      x_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_COMPLEX64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF,
      T: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("Atanh_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("Atanh", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.x)?
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct Atanh<T, x_Arg>
where T: TensorType,
      T: Clone,
      x_Arg: Clone,
      x_Arg: GraphEdge<T>,
      x_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_COMPLEX64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    x: x_Arg,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<T, x_Arg> Atanh<T, x_Arg>
where T: TensorType,
      T: Clone,
      x_Arg: Clone,
      x_Arg: GraphEdge<T>,
      x_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_COMPLEX64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF,
      T: 'static,
{
    pub fn y(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(x: x_Arg) -> Self {
        Self {
            phantom_T: PhantomData,
            x,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(x: x_Arg) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            x,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<T, input_Arg, group_assignment_Arg> GraphOperation for AllToAll<T, input_Arg, group_assignment_Arg>
where T: TensorType,
      T: Clone,
      input_Arg: Clone,
      input_Arg: GraphEdge<T>,
      input_Arg: 'static,
      group_assignment_Arg: Clone,
      group_assignment_Arg: GraphEdge<i32>,
      group_assignment_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_BFLOAT16,
      T: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("AllToAll_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("AllToAll", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.input)?
        }
        {
            new_op.add_edge(&self.group_assignment)?
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        {
            (|attr: &i64| {new_op.set_attr_int("concat_dimension", *attr)})(&self.concat_dimension)?
        }
        {
            (|attr: &i64| {new_op.set_attr_int("split_dimension", *attr)})(&self.split_dimension)?
        }
        {
            (|attr: &i64| {new_op.set_attr_int("split_count", *attr)})(&self.split_count)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct AllToAll<T, input_Arg, group_assignment_Arg>
where T: TensorType,
      T: Clone,
      input_Arg: Clone,
      input_Arg: GraphEdge<T>,
      input_Arg: 'static,
      group_assignment_Arg: Clone,
      group_assignment_Arg: GraphEdge<i32>,
      group_assignment_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_BFLOAT16,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    input: input_Arg,
    group_assignment: group_assignment_Arg,
    concat_dimension: i64,
    split_dimension: i64,
    split_count: i64,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<T, input_Arg, group_assignment_Arg> AllToAll<T, input_Arg, group_assignment_Arg>
where T: TensorType,
      T: Clone,
      input_Arg: Clone,
      input_Arg: GraphEdge<T>,
      input_Arg: 'static,
      group_assignment_Arg: Clone,
      group_assignment_Arg: GraphEdge<i32>,
      group_assignment_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_BFLOAT16,
      T: 'static,
{
    pub fn output(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(input: input_Arg, group_assignment: group_assignment_Arg, concat_dimension: i64, split_dimension: i64, split_count: i64) -> Self {
        Self {
            phantom_T: PhantomData,
            input,
            group_assignment,
            concat_dimension: concat_dimension,
            split_dimension: split_dimension,
            split_count: split_count,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(input: input_Arg, group_assignment: group_assignment_Arg, concat_dimension: i64, split_dimension: i64, split_count: i64) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            input,
            group_assignment,
            concat_dimension: concat_dimension,
            split_dimension: split_dimension,
            split_count: split_count,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<T, input_Arg, input_h_Arg, input_c_Arg, params_Arg> GraphOperation for CudnnRNNV2<T, input_Arg, input_h_Arg, input_c_Arg, params_Arg>
where T: TensorType,
      T: Clone,
      input_Arg: Clone,
      input_Arg: GraphEdge<T>,
      input_Arg: 'static,
      input_h_Arg: Clone,
      input_h_Arg: GraphEdge<T>,
      input_h_Arg: 'static,
      input_c_Arg: Clone,
      input_c_Arg: GraphEdge<T>,
      input_c_Arg: 'static,
      params_Arg: Clone,
      params_Arg: GraphEdge<T>,
      params_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_HALF,
      T: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("CudnnRNNV2_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("CudnnRNNV2", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.input)?
        }
        {
            new_op.add_edge(&self.input_h)?
        }
        {
            new_op.add_edge(&self.input_c)?
        }
        {
            new_op.add_edge(&self.params)?
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        {
            match self.rnn_mode {
                None => new_op.set_attr_value_proto("rnn_mode", &vec![18_u8, 4_u8, 108_u8, 115_u8, 116_u8, 109_u8,])?,
                Some(ref value) => (|attr| {new_op.set_attr_string("rnn_mode", attr)})(&value)?,
            };
        }
        {
            match self.input_mode {
                None => new_op.set_attr_value_proto("input_mode", &vec![18_u8, 12_u8, 108_u8, 105_u8, 110_u8, 101_u8, 97_u8, 114_u8, 95_u8, 105_u8, 110_u8, 112_u8, 117_u8, 116_u8,])?,
                Some(ref value) => (|attr| {new_op.set_attr_string("input_mode", attr)})(&value)?,
            };
        }
        {
            match self.direction {
                None => new_op.set_attr_value_proto("direction", &vec![18_u8, 14_u8, 117_u8, 110_u8, 105_u8, 100_u8, 105_u8, 114_u8, 101_u8, 99_u8, 116_u8, 105_u8, 111_u8, 110_u8, 97_u8, 108_u8,])?,
                Some(ref value) => (|attr| {new_op.set_attr_string("direction", attr)})(&value)?,
            };
        }
        {
            match self.dropout {
                None => new_op.set_attr_value_proto("dropout", &vec![37_u8, 0_u8, 0_u8, 0_u8, 0_u8,])?,
                Some(ref value) => (|attr: &f32| {new_op.set_attr_float("dropout", *attr)})(&value)?,
            };
        }
        {
            match self.seed {
                None => new_op.set_attr_value_proto("seed", &vec![24_u8, 0_u8,])?,
                Some(ref value) => (|attr: &i64| {new_op.set_attr_int("seed", *attr)})(&value)?,
            };
        }
        {
            match self.seed2 {
                None => new_op.set_attr_value_proto("seed2", &vec![24_u8, 0_u8,])?,
                Some(ref value) => (|attr: &i64| {new_op.set_attr_int("seed2", *attr)})(&value)?,
            };
        }
        {
            match self.is_training {
                None => new_op.set_attr_value_proto("is_training", &vec![40_u8, 1_u8,])?,
                Some(ref value) => (|attr: &bool| {new_op.set_attr_bool("is_training", *attr)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct CudnnRNNV2<T, input_Arg, input_h_Arg, input_c_Arg, params_Arg>
where T: TensorType,
      T: Clone,
      input_Arg: Clone,
      input_Arg: GraphEdge<T>,
      input_Arg: 'static,
      input_h_Arg: Clone,
      input_h_Arg: GraphEdge<T>,
      input_h_Arg: 'static,
      input_c_Arg: Clone,
      input_c_Arg: GraphEdge<T>,
      input_c_Arg: 'static,
      params_Arg: Clone,
      params_Arg: GraphEdge<T>,
      params_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_HALF,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    input: input_Arg,
    input_h: input_h_Arg,
    input_c: input_c_Arg,
    params: params_Arg,
    rnn_mode: Option<String>,
    input_mode: Option<String>,
    direction: Option<String>,
    dropout: Option<f32>,
    seed: Option<i64>,
    seed2: Option<i64>,
    is_training: Option<bool>,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<T, input_Arg, input_h_Arg, input_c_Arg, params_Arg> CudnnRNNV2<T, input_Arg, input_h_Arg, input_c_Arg, params_Arg>
where T: TensorType,
      T: Clone,
      input_Arg: Clone,
      input_Arg: GraphEdge<T>,
      input_Arg: 'static,
      input_h_Arg: Clone,
      input_h_Arg: GraphEdge<T>,
      input_h_Arg: 'static,
      input_c_Arg: Clone,
      input_c_Arg: GraphEdge<T>,
      input_c_Arg: 'static,
      params_Arg: Clone,
      params_Arg: GraphEdge<T>,
      params_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_HALF,
      T: 'static,
{
    pub fn output(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn output_h(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 1)
        }
    }

    pub fn output_c(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 2)
        }
    }

    pub fn reserve_space(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 3)
        }
    }

    pub fn host_reserved(self) -> Edge<i8> {
        let rc = Rc::new(self);
        {
            Edge::<i8>::new(rc.clone(), 4)
        }
    }

    pub fn rnn_mode(&mut self, rnn_mode: &str) -> Self {
        self.rnn_mode = Some(rnn_mode.to_string());
        self.clone()
    }

    pub fn input_mode(&mut self, input_mode: &str) -> Self {
        self.input_mode = Some(input_mode.to_string());
        self.clone()
    }

    pub fn direction(&mut self, direction: &str) -> Self {
        self.direction = Some(direction.to_string());
        self.clone()
    }

    pub fn dropout(&mut self, dropout: f32) -> Self {
        self.dropout = Some(dropout);
        self.clone()
    }

    pub fn seed(&mut self, seed: i64) -> Self {
        self.seed = Some(seed);
        self.clone()
    }

    pub fn seed2(&mut self, seed2: i64) -> Self {
        self.seed2 = Some(seed2);
        self.clone()
    }

    pub fn is_training(&mut self, is_training: bool) -> Self {
        self.is_training = Some(is_training);
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> (Edge<T>, Edge<T>, Edge<T>, Edge<T>, Edge<i8>) {
        let rc = Rc::new(self);
        (
        {
            Edge::<T>::new(rc.clone(), 0)
        },
        {
            Edge::<T>::new(rc.clone(), 1)
        },
        {
            Edge::<T>::new(rc.clone(), 2)
        },
        {
            Edge::<T>::new(rc.clone(), 3)
        },
        {
            Edge::<i8>::new(rc.clone(), 4)
        },
        )
    }

    pub fn build(input: input_Arg, input_h: input_h_Arg, input_c: input_c_Arg, params: params_Arg) -> Self {
        Self {
            phantom_T: PhantomData,
            input,
            input_h,
            input_c,
            params,
            rnn_mode: None,
            input_mode: None,
            direction: None,
            dropout: None,
            seed: None,
            seed2: None,
            is_training: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(input: input_Arg, input_h: input_h_Arg, input_c: input_c_Arg, params: params_Arg) -> (Edge<T>, Edge<T>, Edge<T>, Edge<T>, Edge<i8>) {
        Self {
            phantom_T: PhantomData,
            input,
            input_h,
            input_c,
            params,
            rnn_mode: None,
            input_mode: None,
            direction: None,
            dropout: None,
            seed: None,
            seed2: None,
            is_training: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl GraphOperation for TPUReplicateMetadata {
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("TPUReplicateMetadata_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("TPUReplicateMetadata", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            (|attr: &i64| {new_op.set_attr_int("num_replicas", *attr)})(&self.num_replicas)?
        }
        {
            match self.num_cores_per_replica {
                None => new_op.set_attr_value_proto("num_cores_per_replica", &vec![24_u8, 1_u8,])?,
                Some(ref value) => (|attr: &i64| {new_op.set_attr_int("num_cores_per_replica", *attr)})(&value)?,
            };
        }
        {
            match self.topology {
                None => new_op.set_attr_value_proto("topology", &vec![18_u8, 0_u8,])?,
                Some(ref value) => (|attr| {new_op.set_attr_string("topology", attr)})(&value)?,
            };
        }
        {
            match self.use_tpu {
                None => new_op.set_attr_value_proto("use_tpu", &vec![40_u8, 1_u8,])?,
                Some(ref value) => (|attr: &bool| {new_op.set_attr_bool("use_tpu", *attr)})(&value)?,
            };
        }
        {
            match self.device_assignment {
                None => new_op.set_attr_value_proto("device_assignment", &vec![10_u8, 0_u8,])?,
                Some(ref value) => (|attrs| {new_op.set_attr_int_list("device_assignment", attrs)})(&value)?,
            };
        }
        {
            match self.computation_shape {
                None => new_op.set_attr_value_proto("computation_shape", &vec![10_u8, 0_u8,])?,
                Some(ref value) => (|attrs| {new_op.set_attr_int_list("computation_shape", attrs)})(&value)?,
            };
        }
        {
            match self.host_compute_core {
                None => new_op.set_attr_value_proto("host_compute_core", &vec![10_u8, 0_u8,])?,
                Some(ref value) => (|attrs| {new_op.set_attr_string_list("host_compute_core", attrs)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct TPUReplicateMetadata {
    num_replicas: i64,
    num_cores_per_replica: Option<i64>,
    topology: Option<String>,
    use_tpu: Option<bool>,
    device_assignment: Option<Vec<i64>>,
    computation_shape: Option<Vec<i64>>,
    host_compute_core: Option<Vec<String>>,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl TPUReplicateMetadata {
    pub fn num_cores_per_replica(&mut self, num_cores_per_replica: i64) -> Self {
        self.num_cores_per_replica = Some(num_cores_per_replica);
        self.clone()
    }

    pub fn topology(&mut self, topology: &str) -> Self {
        self.topology = Some(topology.to_string());
        self.clone()
    }

    pub fn use_tpu(&mut self, use_tpu: bool) -> Self {
        self.use_tpu = Some(use_tpu);
        self.clone()
    }

    pub fn device_assignment(&mut self, device_assignment: &[i64]) -> Self {
        self.device_assignment = Some(device_assignment.to_vec());
        self.clone()
    }

    pub fn computation_shape(&mut self, computation_shape: &[i64]) -> Self {
        self.computation_shape = Some(computation_shape.to_vec());
        self.clone()
    }

    pub fn host_compute_core(&mut self, host_compute_core: &[String]) -> Self {
        self.host_compute_core = Some(host_compute_core.to_vec());
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> () {
        let rc = Rc::new(self);
        (
        )
    }

    pub fn build(num_replicas: i64) -> Self {
        Self {
            num_replicas: num_replicas,
            num_cores_per_replica: None,
            topology: None,
            use_tpu: None,
            device_assignment: None,
            computation_shape: None,
            host_compute_core: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(num_replicas: i64) -> () {
        Self {
            num_replicas: num_replicas,
            num_cores_per_replica: None,
            topology: None,
            use_tpu: None,
            device_assignment: None,
            computation_shape: None,
            host_compute_core: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<parameters_Arg, accumulators_Arg, linears_Arg, gradient_accumulators_Arg> GraphOperation for LoadTPUEmbeddingFTRLParametersGradAccumDebug<parameters_Arg, accumulators_Arg, linears_Arg, gradient_accumulators_Arg>
where parameters_Arg: Clone,
      parameters_Arg: GraphEdge<f32>,
      parameters_Arg: 'static,
      accumulators_Arg: Clone,
      accumulators_Arg: GraphEdge<f32>,
      accumulators_Arg: 'static,
      linears_Arg: Clone,
      linears_Arg: GraphEdge<f32>,
      linears_Arg: 'static,
      gradient_accumulators_Arg: Clone,
      gradient_accumulators_Arg: GraphEdge<f32>,
      gradient_accumulators_Arg: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("LoadTPUEmbeddingFTRLParametersGradAccumDebug_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("LoadTPUEmbeddingFTRLParametersGradAccumDebug", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.parameters)?
        }
        {
            new_op.add_edge(&self.accumulators)?
        }
        {
            new_op.add_edge(&self.linears)?
        }
        {
            new_op.add_edge(&self.gradient_accumulators)?
        }
        {
            match self.table_id {
                None => new_op.set_attr_value_proto("table_id", &vec![24_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 1_u8,])?,
                Some(ref value) => (|attr: &i64| {new_op.set_attr_int("table_id", *attr)})(&value)?,
            };
        }
        {
            match self.table_name {
                None => new_op.set_attr_value_proto("table_name", &vec![18_u8, 0_u8,])?,
                Some(ref value) => (|attr| {new_op.set_attr_string("table_name", attr)})(&value)?,
            };
        }
        {
            (|attr: &i64| {new_op.set_attr_int("num_shards", *attr)})(&self.num_shards)?
        }
        {
            (|attr: &i64| {new_op.set_attr_int("shard_id", *attr)})(&self.shard_id)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct LoadTPUEmbeddingFTRLParametersGradAccumDebug<parameters_Arg, accumulators_Arg, linears_Arg, gradient_accumulators_Arg>
where parameters_Arg: Clone,
      parameters_Arg: GraphEdge<f32>,
      parameters_Arg: 'static,
      accumulators_Arg: Clone,
      accumulators_Arg: GraphEdge<f32>,
      accumulators_Arg: 'static,
      linears_Arg: Clone,
      linears_Arg: GraphEdge<f32>,
      linears_Arg: 'static,
      gradient_accumulators_Arg: Clone,
      gradient_accumulators_Arg: GraphEdge<f32>,
      gradient_accumulators_Arg: 'static,
{
    parameters: parameters_Arg,
    accumulators: accumulators_Arg,
    linears: linears_Arg,
    gradient_accumulators: gradient_accumulators_Arg,
    table_id: Option<i64>,
    table_name: Option<String>,
    num_shards: i64,
    shard_id: i64,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<parameters_Arg, accumulators_Arg, linears_Arg, gradient_accumulators_Arg> LoadTPUEmbeddingFTRLParametersGradAccumDebug<parameters_Arg, accumulators_Arg, linears_Arg, gradient_accumulators_Arg>
where parameters_Arg: Clone,
      parameters_Arg: GraphEdge<f32>,
      parameters_Arg: 'static,
      accumulators_Arg: Clone,
      accumulators_Arg: GraphEdge<f32>,
      accumulators_Arg: 'static,
      linears_Arg: Clone,
      linears_Arg: GraphEdge<f32>,
      linears_Arg: 'static,
      gradient_accumulators_Arg: Clone,
      gradient_accumulators_Arg: GraphEdge<f32>,
      gradient_accumulators_Arg: 'static,
{
    pub fn table_id(&mut self, table_id: i64) -> Self {
        self.table_id = Some(table_id);
        self.clone()
    }

    pub fn table_name(&mut self, table_name: &str) -> Self {
        self.table_name = Some(table_name.to_string());
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> () {
        let rc = Rc::new(self);
        (
        )
    }

    pub fn build(parameters: parameters_Arg, accumulators: accumulators_Arg, linears: linears_Arg, gradient_accumulators: gradient_accumulators_Arg, num_shards: i64, shard_id: i64) -> Self {
        Self {
            parameters,
            accumulators,
            linears,
            gradient_accumulators,
            table_id: None,
            table_name: None,
            num_shards: num_shards,
            shard_id: shard_id,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(parameters: parameters_Arg, accumulators: accumulators_Arg, linears: linears_Arg, gradient_accumulators: gradient_accumulators_Arg, num_shards: i64, shard_id: i64) -> () {
        Self {
            parameters,
            accumulators,
            linears,
            gradient_accumulators,
            table_id: None,
            table_name: None,
            num_shards: num_shards,
            shard_id: shard_id,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<dtype, ref__Arg> GraphOperation for IsVariableInitialized<dtype, ref__Arg>
where dtype: TensorType,
      dtype: Clone,
      ref__Arg: Clone,
      ref__Arg: GraphRefEdge<dtype>,
      ref__Arg: 'static,
      dtype: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("IsVariableInitialized_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("IsVariableInitialized", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.ref_)?
        }
        {
            new_op.set_attr_type("dtype", dtype::data_type())?;
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct IsVariableInitialized<dtype, ref__Arg>
where dtype: TensorType,
      dtype: Clone,
      ref__Arg: Clone,
      ref__Arg: GraphRefEdge<dtype>,
      ref__Arg: 'static,
      dtype: 'static,
{
    phantom_dtype: PhantomData<dtype>,
    ref_: ref__Arg,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<dtype, ref__Arg> IsVariableInitialized<dtype, ref__Arg>
where dtype: TensorType,
      dtype: Clone,
      ref__Arg: Clone,
      ref__Arg: GraphRefEdge<dtype>,
      ref__Arg: 'static,
      dtype: 'static,
{
    pub fn is_initialized(self) -> Edge<bool> {
        let rc = Rc::new(self);
        {
            Edge::<bool>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<bool> {
        let rc = Rc::new(self);
        {
            Edge::<bool>::new(rc.clone(), 0)
        }
    }

    pub fn build(ref_: ref__Arg) -> Self {
        Self {
            phantom_dtype: PhantomData,
            ref_,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(ref_: ref__Arg) -> Edge<bool> {
        Self {
            phantom_dtype: PhantomData,
            ref_,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<T, input_Arg, input_min_Arg, input_max_Arg> GraphOperation for QuantizeAndDequantizeV2<T, input_Arg, input_min_Arg, input_max_Arg>
where T: TensorType,
      T: Clone,
      input_Arg: Clone,
      input_Arg: GraphEdge<T>,
      input_Arg: 'static,
      input_min_Arg: Clone,
      input_min_Arg: GraphEdge<T>,
      input_min_Arg: 'static,
      input_max_Arg: Clone,
      input_max_Arg: GraphEdge<T>,
      input_max_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
      T: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("QuantizeAndDequantizeV2_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("QuantizeAndDequantizeV2", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.input)?
        }
        {
            new_op.add_edge(&self.input_min)?
        }
        {
            new_op.add_edge(&self.input_max)?
        }
        {
            match self.signed_input {
                None => new_op.set_attr_value_proto("signed_input", &vec![40_u8, 1_u8,])?,
                Some(ref value) => (|attr: &bool| {new_op.set_attr_bool("signed_input", *attr)})(&value)?,
            };
        }
        {
            match self.num_bits {
                None => new_op.set_attr_value_proto("num_bits", &vec![24_u8, 8_u8,])?,
                Some(ref value) => (|attr: &i64| {new_op.set_attr_int("num_bits", *attr)})(&value)?,
            };
        }
        {
            match self.range_given {
                None => new_op.set_attr_value_proto("range_given", &vec![40_u8, 0_u8,])?,
                Some(ref value) => (|attr: &bool| {new_op.set_attr_bool("range_given", *attr)})(&value)?,
            };
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        {
            match self.round_mode {
                None => new_op.set_attr_value_proto("round_mode", &vec![18_u8, 12_u8, 72_u8, 65_u8, 76_u8, 70_u8, 95_u8, 84_u8, 79_u8, 95_u8, 69_u8, 86_u8, 69_u8, 78_u8,])?,
                Some(ref value) => (|attr| {new_op.set_attr_string("round_mode", attr)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct QuantizeAndDequantizeV2<T, input_Arg, input_min_Arg, input_max_Arg>
where T: TensorType,
      T: Clone,
      input_Arg: Clone,
      input_Arg: GraphEdge<T>,
      input_Arg: 'static,
      input_min_Arg: Clone,
      input_min_Arg: GraphEdge<T>,
      input_min_Arg: 'static,
      input_max_Arg: Clone,
      input_max_Arg: GraphEdge<T>,
      input_max_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    input: input_Arg,
    input_min: input_min_Arg,
    input_max: input_max_Arg,
    signed_input: Option<bool>,
    num_bits: Option<i64>,
    range_given: Option<bool>,
    round_mode: Option<String>,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<T, input_Arg, input_min_Arg, input_max_Arg> QuantizeAndDequantizeV2<T, input_Arg, input_min_Arg, input_max_Arg>
where T: TensorType,
      T: Clone,
      input_Arg: Clone,
      input_Arg: GraphEdge<T>,
      input_Arg: 'static,
      input_min_Arg: Clone,
      input_min_Arg: GraphEdge<T>,
      input_min_Arg: 'static,
      input_max_Arg: Clone,
      input_max_Arg: GraphEdge<T>,
      input_max_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
      T: 'static,
{
    pub fn output(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn signed_input(&mut self, signed_input: bool) -> Self {
        self.signed_input = Some(signed_input);
        self.clone()
    }

    pub fn num_bits(&mut self, num_bits: i64) -> Self {
        self.num_bits = Some(num_bits);
        self.clone()
    }

    pub fn range_given(&mut self, range_given: bool) -> Self {
        self.range_given = Some(range_given);
        self.clone()
    }

    pub fn round_mode(&mut self, round_mode: &str) -> Self {
        self.round_mode = Some(round_mode.to_string());
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(input: input_Arg, input_min: input_min_Arg, input_max: input_max_Arg) -> Self {
        Self {
            phantom_T: PhantomData,
            input,
            input_min,
            input_max,
            signed_input: None,
            num_bits: None,
            range_given: None,
            round_mode: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(input: input_Arg, input_min: input_min_Arg, input_max: input_max_Arg) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            input,
            input_min,
            input_max,
            signed_input: None,
            num_bits: None,
            range_given: None,
            round_mode: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<T, input_Arg, Tblock_shape, block_shape_Arg, Tpaddings, paddings_Arg> GraphOperation for SpaceToBatchND<T, input_Arg, Tblock_shape, block_shape_Arg, Tpaddings, paddings_Arg>
where T: TensorType,
      T: Clone,
      input_Arg: Clone,
      input_Arg: GraphEdge<T>,
      input_Arg: 'static,
      Tblock_shape: TensorType,
      Tblock_shape: Clone,
      block_shape_Arg: Clone,
      block_shape_Arg: GraphEdge<Tblock_shape>,
      block_shape_Arg: 'static,
      Tpaddings: TensorType,
      Tpaddings: Clone,
      paddings_Arg: Clone,
      paddings_Arg: GraphEdge<Tpaddings>,
      paddings_Arg: 'static,
      T: 'static,
      Tblock_shape: con_or_DT_INT32_or_DT_INT64,
      Tblock_shape: 'static,
      Tpaddings: con_or_DT_INT32_or_DT_INT64,
      Tpaddings: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("SpaceToBatchND_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("SpaceToBatchND", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.input)?
        }
        {
            new_op.add_edge(&self.block_shape)?
        }
        {
            new_op.add_edge(&self.paddings)?
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        {
            new_op.set_attr_type("Tblock_shape", Tblock_shape::data_type())?;
        }
        {
            new_op.set_attr_type("Tpaddings", Tpaddings::data_type())?;
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct SpaceToBatchND<T, input_Arg, Tblock_shape, block_shape_Arg, Tpaddings, paddings_Arg>
where T: TensorType,
      T: Clone,
      input_Arg: Clone,
      input_Arg: GraphEdge<T>,
      input_Arg: 'static,
      Tblock_shape: TensorType,
      Tblock_shape: Clone,
      block_shape_Arg: Clone,
      block_shape_Arg: GraphEdge<Tblock_shape>,
      block_shape_Arg: 'static,
      Tpaddings: TensorType,
      Tpaddings: Clone,
      paddings_Arg: Clone,
      paddings_Arg: GraphEdge<Tpaddings>,
      paddings_Arg: 'static,
      T: 'static,
      Tblock_shape: con_or_DT_INT32_or_DT_INT64,
      Tblock_shape: 'static,
      Tpaddings: con_or_DT_INT32_or_DT_INT64,
      Tpaddings: 'static,
{
    phantom_T: PhantomData<T>,
    input: input_Arg,
    phantom_Tblock_shape: PhantomData<Tblock_shape>,
    block_shape: block_shape_Arg,
    phantom_Tpaddings: PhantomData<Tpaddings>,
    paddings: paddings_Arg,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<T, input_Arg, Tblock_shape, block_shape_Arg, Tpaddings, paddings_Arg> SpaceToBatchND<T, input_Arg, Tblock_shape, block_shape_Arg, Tpaddings, paddings_Arg>
where T: TensorType,
      T: Clone,
      input_Arg: Clone,
      input_Arg: GraphEdge<T>,
      input_Arg: 'static,
      Tblock_shape: TensorType,
      Tblock_shape: Clone,
      block_shape_Arg: Clone,
      block_shape_Arg: GraphEdge<Tblock_shape>,
      block_shape_Arg: 'static,
      Tpaddings: TensorType,
      Tpaddings: Clone,
      paddings_Arg: Clone,
      paddings_Arg: GraphEdge<Tpaddings>,
      paddings_Arg: 'static,
      T: 'static,
      Tblock_shape: con_or_DT_INT32_or_DT_INT64,
      Tblock_shape: 'static,
      Tpaddings: con_or_DT_INT32_or_DT_INT64,
      Tpaddings: 'static,
{
    pub fn output(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(input: input_Arg, block_shape: block_shape_Arg, paddings: paddings_Arg) -> Self {
        Self {
            phantom_T: PhantomData,
            input,
            phantom_Tblock_shape: PhantomData,
            block_shape,
            phantom_Tpaddings: PhantomData,
            paddings,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(input: input_Arg, block_shape: block_shape_Arg, paddings: paddings_Arg) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            input,
            phantom_Tblock_shape: PhantomData,
            block_shape,
            phantom_Tpaddings: PhantomData,
            paddings,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<T, shape_Arg, Tseed, seed_Arg, dtype> GraphOperation for StatelessRandomUniform<T, shape_Arg, Tseed, seed_Arg, dtype>
where T: TensorType,
      T: Clone,
      shape_Arg: Clone,
      shape_Arg: GraphEdge<T>,
      shape_Arg: 'static,
      Tseed: TensorType,
      Tseed: Clone,
      seed_Arg: Clone,
      seed_Arg: GraphEdge<Tseed>,
      seed_Arg: 'static,
      dtype: TensorType,
      dtype: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
      dtype: 'static,
      dtype: Clone,
      T: con_or_DT_INT32_or_DT_INT64,
      T: 'static,
      Tseed: con_or_DT_INT32_or_DT_INT64,
      Tseed: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("StatelessRandomUniform_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("StatelessRandomUniform", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.shape)?
        }
        {
            new_op.add_edge(&self.seed)?
        }
        {
            new_op.set_attr_type("dtype", dtype::data_type())?;
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        {
            new_op.set_attr_type("Tseed", Tseed::data_type())?;
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct StatelessRandomUniform<T, shape_Arg, Tseed, seed_Arg, dtype>
where T: TensorType,
      T: Clone,
      shape_Arg: Clone,
      shape_Arg: GraphEdge<T>,
      shape_Arg: 'static,
      Tseed: TensorType,
      Tseed: Clone,
      seed_Arg: Clone,
      seed_Arg: GraphEdge<Tseed>,
      seed_Arg: 'static,
      dtype: TensorType,
      dtype: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
      dtype: 'static,
      dtype: Clone,
      T: con_or_DT_INT32_or_DT_INT64,
      T: 'static,
      Tseed: con_or_DT_INT32_or_DT_INT64,
      Tseed: 'static,
{
    phantom_T: PhantomData<T>,
    shape: shape_Arg,
    phantom_Tseed: PhantomData<Tseed>,
    seed: seed_Arg,
    phantom_dtype: PhantomData<dtype>,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<T, shape_Arg, Tseed, seed_Arg, dtype> StatelessRandomUniform<T, shape_Arg, Tseed, seed_Arg, dtype>
where T: TensorType,
      T: Clone,
      shape_Arg: Clone,
      shape_Arg: GraphEdge<T>,
      shape_Arg: 'static,
      Tseed: TensorType,
      Tseed: Clone,
      seed_Arg: Clone,
      seed_Arg: GraphEdge<Tseed>,
      seed_Arg: 'static,
      dtype: TensorType,
      dtype: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
      dtype: 'static,
      dtype: Clone,
      T: con_or_DT_INT32_or_DT_INT64,
      T: 'static,
      Tseed: con_or_DT_INT32_or_DT_INT64,
      Tseed: 'static,
{
    pub fn output(self) -> Edge<dtype> {
        let rc = Rc::new(self);
        {
            Edge::<dtype>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<dtype> {
        let rc = Rc::new(self);
        {
            Edge::<dtype>::new(rc.clone(), 0)
        }
    }

    pub fn build(shape: shape_Arg, seed: seed_Arg) -> Self {
        Self {
            phantom_T: PhantomData,
            shape,
            phantom_Tseed: PhantomData,
            seed,
            phantom_dtype: PhantomData,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(shape: shape_Arg, seed: seed_Arg) -> Edge<dtype> {
        Self {
            phantom_T: PhantomData,
            shape,
            phantom_Tseed: PhantomData,
            seed,
            phantom_dtype: PhantomData,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<dtype> GraphOperation for InfeedDequeue<dtype>
where dtype: TensorType,
      dtype: 'static,
      dtype: Clone,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("InfeedDequeue_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("InfeedDequeue", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.set_attr_type("dtype", dtype::data_type())?;
        }
        {
            (|attr| {new_op.set_attr_shape("shape", attr)})(&self.shape)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct InfeedDequeue<dtype>
where dtype: TensorType,
      dtype: 'static,
      dtype: Clone,
{
    phantom_dtype: PhantomData<dtype>,
    shape: OtherShape,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<dtype> InfeedDequeue<dtype>
where dtype: TensorType,
      dtype: 'static,
      dtype: Clone,
{
    pub fn output(self) -> Edge<dtype> {
        let rc = Rc::new(self);
        {
            Edge::<dtype>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<dtype> {
        let rc = Rc::new(self);
        {
            Edge::<dtype>::new(rc.clone(), 0)
        }
    }

    pub fn build(shape: &OtherShape) -> Self {
        Self {
            phantom_dtype: PhantomData,
            shape: shape.clone(),
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(shape: &OtherShape) -> Edge<dtype> {
        Self {
            phantom_dtype: PhantomData,
            shape: shape.clone(),
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<T, x_Arg> GraphOperation for IsFinite<T, x_Arg>
where T: TensorType,
      T: Clone,
      x_Arg: Clone,
      x_Arg: GraphEdge<T>,
      x_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
      T: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("IsFinite_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("IsFinite", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.x)?
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct IsFinite<T, x_Arg>
where T: TensorType,
      T: Clone,
      x_Arg: Clone,
      x_Arg: GraphEdge<T>,
      x_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    x: x_Arg,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<T, x_Arg> IsFinite<T, x_Arg>
where T: TensorType,
      T: Clone,
      x_Arg: Clone,
      x_Arg: GraphEdge<T>,
      x_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
      T: 'static,
{
    pub fn y(self) -> Edge<bool> {
        let rc = Rc::new(self);
        {
            Edge::<bool>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<bool> {
        let rc = Rc::new(self);
        {
            Edge::<bool>::new(rc.clone(), 0)
        }
    }

    pub fn build(x: x_Arg) -> Self {
        Self {
            phantom_T: PhantomData,
            x,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(x: x_Arg) -> Edge<bool> {
        Self {
            phantom_T: PhantomData,
            x,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<T, input_Arg> GraphOperation for GuaranteeConst<T, input_Arg>
where T: TensorType,
      T: Clone,
      input_Arg: Clone,
      input_Arg: GraphEdge<T>,
      input_Arg: 'static,
      T: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("GuaranteeConst_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("GuaranteeConst", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.input)?
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct GuaranteeConst<T, input_Arg>
where T: TensorType,
      T: Clone,
      input_Arg: Clone,
      input_Arg: GraphEdge<T>,
      input_Arg: 'static,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    input: input_Arg,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<T, input_Arg> GuaranteeConst<T, input_Arg>
where T: TensorType,
      T: Clone,
      input_Arg: Clone,
      input_Arg: GraphEdge<T>,
      input_Arg: 'static,
      T: 'static,
{
    pub fn output(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(input: input_Arg) -> Self {
        Self {
            phantom_T: PhantomData,
            input,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(input: input_Arg) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            input,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<Tparams, params_Arg, Tindices, indices_Arg> GraphOperation for GatherNd<Tparams, params_Arg, Tindices, indices_Arg>
where Tparams: TensorType,
      Tparams: Clone,
      params_Arg: Clone,
      params_Arg: GraphEdge<Tparams>,
      params_Arg: 'static,
      Tindices: TensorType,
      Tindices: Clone,
      indices_Arg: Clone,
      indices_Arg: GraphEdge<Tindices>,
      indices_Arg: 'static,
      Tparams: 'static,
      Tindices: con_or_DT_INT32_or_DT_INT64,
      Tindices: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("GatherNd_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("GatherNd", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.params)?
        }
        {
            new_op.add_edge(&self.indices)?
        }
        {
            new_op.set_attr_type("Tparams", Tparams::data_type())?;
        }
        {
            new_op.set_attr_type("Tindices", Tindices::data_type())?;
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct GatherNd<Tparams, params_Arg, Tindices, indices_Arg>
where Tparams: TensorType,
      Tparams: Clone,
      params_Arg: Clone,
      params_Arg: GraphEdge<Tparams>,
      params_Arg: 'static,
      Tindices: TensorType,
      Tindices: Clone,
      indices_Arg: Clone,
      indices_Arg: GraphEdge<Tindices>,
      indices_Arg: 'static,
      Tparams: 'static,
      Tindices: con_or_DT_INT32_or_DT_INT64,
      Tindices: 'static,
{
    phantom_Tparams: PhantomData<Tparams>,
    params: params_Arg,
    phantom_Tindices: PhantomData<Tindices>,
    indices: indices_Arg,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<Tparams, params_Arg, Tindices, indices_Arg> GatherNd<Tparams, params_Arg, Tindices, indices_Arg>
where Tparams: TensorType,
      Tparams: Clone,
      params_Arg: Clone,
      params_Arg: GraphEdge<Tparams>,
      params_Arg: 'static,
      Tindices: TensorType,
      Tindices: Clone,
      indices_Arg: Clone,
      indices_Arg: GraphEdge<Tindices>,
      indices_Arg: 'static,
      Tparams: 'static,
      Tindices: con_or_DT_INT32_or_DT_INT64,
      Tindices: 'static,
{
    pub fn output(self) -> Edge<Tparams> {
        let rc = Rc::new(self);
        {
            Edge::<Tparams>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<Tparams> {
        let rc = Rc::new(self);
        {
            Edge::<Tparams>::new(rc.clone(), 0)
        }
    }

    pub fn build(params: params_Arg, indices: indices_Arg) -> Self {
        Self {
            phantom_Tparams: PhantomData,
            params,
            phantom_Tindices: PhantomData,
            indices,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(params: params_Arg, indices: indices_Arg) -> Edge<Tparams> {
        Self {
            phantom_Tparams: PhantomData,
            params,
            phantom_Tindices: PhantomData,
            indices,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<T, x_Arg, out_idx> GraphOperation for UniqueWithCounts<T, x_Arg, out_idx>
where T: TensorType,
      T: Clone,
      x_Arg: Clone,
      x_Arg: GraphEdge<T>,
      x_Arg: 'static,
      out_idx: TensorType,
      T: 'static,
      out_idx: con_or_DT_INT32_or_DT_INT64,
      out_idx: 'static,
      out_idx: Clone,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("UniqueWithCounts_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("UniqueWithCounts", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.x)?
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        {
            new_op.set_attr_type("out_idx", out_idx::data_type())?;
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct UniqueWithCounts<T, x_Arg, out_idx>
where T: TensorType,
      T: Clone,
      x_Arg: Clone,
      x_Arg: GraphEdge<T>,
      x_Arg: 'static,
      out_idx: TensorType,
      T: 'static,
      out_idx: con_or_DT_INT32_or_DT_INT64,
      out_idx: 'static,
      out_idx: Clone,
{
    phantom_T: PhantomData<T>,
    x: x_Arg,
    phantom_out_idx: PhantomData<out_idx>,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<T, x_Arg, out_idx> UniqueWithCounts<T, x_Arg, out_idx>
where T: TensorType,
      T: Clone,
      x_Arg: Clone,
      x_Arg: GraphEdge<T>,
      x_Arg: 'static,
      out_idx: TensorType,
      T: 'static,
      out_idx: con_or_DT_INT32_or_DT_INT64,
      out_idx: 'static,
      out_idx: Clone,
{
    pub fn y(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn idx(self) -> Edge<out_idx> {
        let rc = Rc::new(self);
        {
            Edge::<out_idx>::new(rc.clone(), 1)
        }
    }

    pub fn count(self) -> Edge<out_idx> {
        let rc = Rc::new(self);
        {
            Edge::<out_idx>::new(rc.clone(), 2)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> (Edge<T>, Edge<out_idx>, Edge<out_idx>) {
        let rc = Rc::new(self);
        (
        {
            Edge::<T>::new(rc.clone(), 0)
        },
        {
            Edge::<out_idx>::new(rc.clone(), 1)
        },
        {
            Edge::<out_idx>::new(rc.clone(), 2)
        },
        )
    }

    pub fn build(x: x_Arg) -> Self {
        Self {
            phantom_T: PhantomData,
            x,
            phantom_out_idx: PhantomData,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(x: x_Arg) -> (Edge<T>, Edge<out_idx>, Edge<out_idx>) {
        Self {
            phantom_T: PhantomData,
            x,
            phantom_out_idx: PhantomData,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<T, x_Arg, y_Arg, out_idx> GraphOperation for ListDiff<T, x_Arg, y_Arg, out_idx>
where T: TensorType,
      T: Clone,
      x_Arg: Clone,
      x_Arg: GraphEdge<T>,
      x_Arg: 'static,
      y_Arg: Clone,
      y_Arg: GraphEdge<T>,
      y_Arg: 'static,
      out_idx: TensorType,
      T: 'static,
      out_idx: con_or_DT_INT32_or_DT_INT64,
      out_idx: 'static,
      out_idx: Clone,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("ListDiff_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("ListDiff", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.x)?
        }
        {
            new_op.add_edge(&self.y)?
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        {
            new_op.set_attr_type("out_idx", out_idx::data_type())?;
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct ListDiff<T, x_Arg, y_Arg, out_idx>
where T: TensorType,
      T: Clone,
      x_Arg: Clone,
      x_Arg: GraphEdge<T>,
      x_Arg: 'static,
      y_Arg: Clone,
      y_Arg: GraphEdge<T>,
      y_Arg: 'static,
      out_idx: TensorType,
      T: 'static,
      out_idx: con_or_DT_INT32_or_DT_INT64,
      out_idx: 'static,
      out_idx: Clone,
{
    phantom_T: PhantomData<T>,
    x: x_Arg,
    y: y_Arg,
    phantom_out_idx: PhantomData<out_idx>,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<T, x_Arg, y_Arg, out_idx> ListDiff<T, x_Arg, y_Arg, out_idx>
where T: TensorType,
      T: Clone,
      x_Arg: Clone,
      x_Arg: GraphEdge<T>,
      x_Arg: 'static,
      y_Arg: Clone,
      y_Arg: GraphEdge<T>,
      y_Arg: 'static,
      out_idx: TensorType,
      T: 'static,
      out_idx: con_or_DT_INT32_or_DT_INT64,
      out_idx: 'static,
      out_idx: Clone,
{
    pub fn out(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn idx(self) -> Edge<out_idx> {
        let rc = Rc::new(self);
        {
            Edge::<out_idx>::new(rc.clone(), 1)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> (Edge<T>, Edge<out_idx>) {
        let rc = Rc::new(self);
        (
        {
            Edge::<T>::new(rc.clone(), 0)
        },
        {
            Edge::<out_idx>::new(rc.clone(), 1)
        },
        )
    }

    pub fn build(x: x_Arg, y: y_Arg) -> Self {
        Self {
            phantom_T: PhantomData,
            x,
            y,
            phantom_out_idx: PhantomData,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(x: x_Arg, y: y_Arg) -> (Edge<T>, Edge<out_idx>) {
        Self {
            phantom_T: PhantomData,
            x,
            y,
            phantom_out_idx: PhantomData,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<parameters_Arg, accumulators_Arg, updates_Arg, gradient_accumulators_Arg> GraphOperation for LoadTPUEmbeddingAdadeltaParametersGradAccumDebug<parameters_Arg, accumulators_Arg, updates_Arg, gradient_accumulators_Arg>
where parameters_Arg: Clone,
      parameters_Arg: GraphEdge<f32>,
      parameters_Arg: 'static,
      accumulators_Arg: Clone,
      accumulators_Arg: GraphEdge<f32>,
      accumulators_Arg: 'static,
      updates_Arg: Clone,
      updates_Arg: GraphEdge<f32>,
      updates_Arg: 'static,
      gradient_accumulators_Arg: Clone,
      gradient_accumulators_Arg: GraphEdge<f32>,
      gradient_accumulators_Arg: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("LoadTPUEmbeddingAdadeltaParametersGradAccumDebug_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("LoadTPUEmbeddingAdadeltaParametersGradAccumDebug", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.parameters)?
        }
        {
            new_op.add_edge(&self.accumulators)?
        }
        {
            new_op.add_edge(&self.updates)?
        }
        {
            new_op.add_edge(&self.gradient_accumulators)?
        }
        {
            match self.table_id {
                None => new_op.set_attr_value_proto("table_id", &vec![24_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 1_u8,])?,
                Some(ref value) => (|attr: &i64| {new_op.set_attr_int("table_id", *attr)})(&value)?,
            };
        }
        {
            match self.table_name {
                None => new_op.set_attr_value_proto("table_name", &vec![18_u8, 0_u8,])?,
                Some(ref value) => (|attr| {new_op.set_attr_string("table_name", attr)})(&value)?,
            };
        }
        {
            (|attr: &i64| {new_op.set_attr_int("num_shards", *attr)})(&self.num_shards)?
        }
        {
            (|attr: &i64| {new_op.set_attr_int("shard_id", *attr)})(&self.shard_id)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct LoadTPUEmbeddingAdadeltaParametersGradAccumDebug<parameters_Arg, accumulators_Arg, updates_Arg, gradient_accumulators_Arg>
where parameters_Arg: Clone,
      parameters_Arg: GraphEdge<f32>,
      parameters_Arg: 'static,
      accumulators_Arg: Clone,
      accumulators_Arg: GraphEdge<f32>,
      accumulators_Arg: 'static,
      updates_Arg: Clone,
      updates_Arg: GraphEdge<f32>,
      updates_Arg: 'static,
      gradient_accumulators_Arg: Clone,
      gradient_accumulators_Arg: GraphEdge<f32>,
      gradient_accumulators_Arg: 'static,
{
    parameters: parameters_Arg,
    accumulators: accumulators_Arg,
    updates: updates_Arg,
    gradient_accumulators: gradient_accumulators_Arg,
    table_id: Option<i64>,
    table_name: Option<String>,
    num_shards: i64,
    shard_id: i64,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<parameters_Arg, accumulators_Arg, updates_Arg, gradient_accumulators_Arg> LoadTPUEmbeddingAdadeltaParametersGradAccumDebug<parameters_Arg, accumulators_Arg, updates_Arg, gradient_accumulators_Arg>
where parameters_Arg: Clone,
      parameters_Arg: GraphEdge<f32>,
      parameters_Arg: 'static,
      accumulators_Arg: Clone,
      accumulators_Arg: GraphEdge<f32>,
      accumulators_Arg: 'static,
      updates_Arg: Clone,
      updates_Arg: GraphEdge<f32>,
      updates_Arg: 'static,
      gradient_accumulators_Arg: Clone,
      gradient_accumulators_Arg: GraphEdge<f32>,
      gradient_accumulators_Arg: 'static,
{
    pub fn table_id(&mut self, table_id: i64) -> Self {
        self.table_id = Some(table_id);
        self.clone()
    }

    pub fn table_name(&mut self, table_name: &str) -> Self {
        self.table_name = Some(table_name.to_string());
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> () {
        let rc = Rc::new(self);
        (
        )
    }

    pub fn build(parameters: parameters_Arg, accumulators: accumulators_Arg, updates: updates_Arg, gradient_accumulators: gradient_accumulators_Arg, num_shards: i64, shard_id: i64) -> Self {
        Self {
            parameters,
            accumulators,
            updates,
            gradient_accumulators,
            table_id: None,
            table_name: None,
            num_shards: num_shards,
            shard_id: shard_id,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(parameters: parameters_Arg, accumulators: accumulators_Arg, updates: updates_Arg, gradient_accumulators: gradient_accumulators_Arg, num_shards: i64, shard_id: i64) -> () {
        Self {
            parameters,
            accumulators,
            updates,
            gradient_accumulators,
            table_id: None,
            table_name: None,
            num_shards: num_shards,
            shard_id: shard_id,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<T, input_Arg, Tidx, shape_Arg> GraphOperation for BroadcastTo<T, input_Arg, Tidx, shape_Arg>
where T: TensorType,
      T: Clone,
      input_Arg: Clone,
      input_Arg: GraphEdge<T>,
      input_Arg: 'static,
      Tidx: TensorType,
      Tidx: Clone,
      shape_Arg: Clone,
      shape_Arg: GraphEdge<Tidx>,
      shape_Arg: 'static,
      T: 'static,
      Tidx: con_or_DT_INT32_or_DT_INT64,
      Tidx: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("BroadcastTo_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("BroadcastTo", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.input)?
        }
        {
            new_op.add_edge(&self.shape)?
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        {
            new_op.set_attr_type("Tidx", Tidx::data_type())?;
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct BroadcastTo<T, input_Arg, Tidx, shape_Arg>
where T: TensorType,
      T: Clone,
      input_Arg: Clone,
      input_Arg: GraphEdge<T>,
      input_Arg: 'static,
      Tidx: TensorType,
      Tidx: Clone,
      shape_Arg: Clone,
      shape_Arg: GraphEdge<Tidx>,
      shape_Arg: 'static,
      T: 'static,
      Tidx: con_or_DT_INT32_or_DT_INT64,
      Tidx: 'static,
{
    phantom_T: PhantomData<T>,
    input: input_Arg,
    phantom_Tidx: PhantomData<Tidx>,
    shape: shape_Arg,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<T, input_Arg, Tidx, shape_Arg> BroadcastTo<T, input_Arg, Tidx, shape_Arg>
where T: TensorType,
      T: Clone,
      input_Arg: Clone,
      input_Arg: GraphEdge<T>,
      input_Arg: 'static,
      Tidx: TensorType,
      Tidx: Clone,
      shape_Arg: Clone,
      shape_Arg: GraphEdge<Tidx>,
      shape_Arg: 'static,
      T: 'static,
      Tidx: con_or_DT_INT32_or_DT_INT64,
      Tidx: 'static,
{
    pub fn output(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(input: input_Arg, shape: shape_Arg) -> Self {
        Self {
            phantom_T: PhantomData,
            input,
            phantom_Tidx: PhantomData,
            shape,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(input: input_Arg, shape: shape_Arg) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            input,
            phantom_Tidx: PhantomData,
            shape,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<T, input_Arg> GraphOperation for DebugNumericSummary<T, input_Arg>
where T: TensorType,
      T: Clone,
      input_Arg: Clone,
      input_Arg: GraphEdge<T>,
      input_Arg: 'static,
      T: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("DebugNumericSummary_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("DebugNumericSummary", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.input)?
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        {
            match self.device_name {
                None => new_op.set_attr_value_proto("device_name", &vec![18_u8, 0_u8,])?,
                Some(ref value) => (|attr| {new_op.set_attr_string("device_name", attr)})(&value)?,
            };
        }
        {
            match self.tensor_name {
                None => new_op.set_attr_value_proto("tensor_name", &vec![18_u8, 0_u8,])?,
                Some(ref value) => (|attr| {new_op.set_attr_string("tensor_name", attr)})(&value)?,
            };
        }
        {
            match self.debug_urls {
                None => new_op.set_attr_value_proto("debug_urls", &vec![10_u8, 0_u8,])?,
                Some(ref value) => (|attrs| {new_op.set_attr_string_list("debug_urls", attrs)})(&value)?,
            };
        }
        {
            match self.lower_bound {
                None => new_op.set_attr_value_proto("lower_bound", &vec![37_u8, 0_u8, 0_u8, 128_u8, 255_u8,])?,
                Some(ref value) => (|attr: &f32| {new_op.set_attr_float("lower_bound", *attr)})(&value)?,
            };
        }
        {
            match self.upper_bound {
                None => new_op.set_attr_value_proto("upper_bound", &vec![37_u8, 0_u8, 0_u8, 128_u8, 127_u8,])?,
                Some(ref value) => (|attr: &f32| {new_op.set_attr_float("upper_bound", *attr)})(&value)?,
            };
        }
        {
            match self.mute_if_healthy {
                None => new_op.set_attr_value_proto("mute_if_healthy", &vec![40_u8, 0_u8,])?,
                Some(ref value) => (|attr: &bool| {new_op.set_attr_bool("mute_if_healthy", *attr)})(&value)?,
            };
        }
        {
            match self.gated_grpc {
                None => new_op.set_attr_value_proto("gated_grpc", &vec![40_u8, 0_u8,])?,
                Some(ref value) => (|attr: &bool| {new_op.set_attr_bool("gated_grpc", *attr)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct DebugNumericSummary<T, input_Arg>
where T: TensorType,
      T: Clone,
      input_Arg: Clone,
      input_Arg: GraphEdge<T>,
      input_Arg: 'static,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    input: input_Arg,
    device_name: Option<String>,
    tensor_name: Option<String>,
    debug_urls: Option<Vec<String>>,
    lower_bound: Option<f32>,
    upper_bound: Option<f32>,
    mute_if_healthy: Option<bool>,
    gated_grpc: Option<bool>,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<T, input_Arg> DebugNumericSummary<T, input_Arg>
where T: TensorType,
      T: Clone,
      input_Arg: Clone,
      input_Arg: GraphEdge<T>,
      input_Arg: 'static,
      T: 'static,
{
    pub fn output(self) -> Edge<f64> {
        let rc = Rc::new(self);
        {
            Edge::<f64>::new(rc.clone(), 0)
        }
    }

    pub fn device_name(&mut self, device_name: &str) -> Self {
        self.device_name = Some(device_name.to_string());
        self.clone()
    }

    pub fn tensor_name(&mut self, tensor_name: &str) -> Self {
        self.tensor_name = Some(tensor_name.to_string());
        self.clone()
    }

    pub fn debug_urls(&mut self, debug_urls: &[String]) -> Self {
        self.debug_urls = Some(debug_urls.to_vec());
        self.clone()
    }

    pub fn lower_bound(&mut self, lower_bound: f32) -> Self {
        self.lower_bound = Some(lower_bound);
        self.clone()
    }

    pub fn upper_bound(&mut self, upper_bound: f32) -> Self {
        self.upper_bound = Some(upper_bound);
        self.clone()
    }

    pub fn mute_if_healthy(&mut self, mute_if_healthy: bool) -> Self {
        self.mute_if_healthy = Some(mute_if_healthy);
        self.clone()
    }

    pub fn gated_grpc(&mut self, gated_grpc: bool) -> Self {
        self.gated_grpc = Some(gated_grpc);
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<f64> {
        let rc = Rc::new(self);
        {
            Edge::<f64>::new(rc.clone(), 0)
        }
    }

    pub fn build(input: input_Arg) -> Self {
        Self {
            phantom_T: PhantomData,
            input,
            device_name: None,
            tensor_name: None,
            debug_urls: None,
            lower_bound: None,
            upper_bound: None,
            mute_if_healthy: None,
            gated_grpc: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(input: input_Arg) -> Edge<f64> {
        Self {
            phantom_T: PhantomData,
            input,
            device_name: None,
            tensor_name: None,
            debug_urls: None,
            lower_bound: None,
            upper_bound: None,
            mute_if_healthy: None,
            gated_grpc: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<sparse_indices_Arg, T, sparse_values_Arg, sparse_shape_Arg> GraphOperation for AddSparseToTensorsMap<sparse_indices_Arg, T, sparse_values_Arg, sparse_shape_Arg>
where sparse_indices_Arg: Clone,
      sparse_indices_Arg: GraphEdge<i64>,
      sparse_indices_Arg: 'static,
      T: TensorType,
      T: Clone,
      sparse_values_Arg: Clone,
      sparse_values_Arg: GraphEdge<T>,
      sparse_values_Arg: 'static,
      sparse_shape_Arg: Clone,
      sparse_shape_Arg: GraphEdge<i64>,
      sparse_shape_Arg: 'static,
      T: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("AddSparseToTensorsMap_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("AddSparseToTensorsMap", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.sparse_indices)?
        }
        {
            new_op.add_edge(&self.sparse_values)?
        }
        {
            new_op.add_edge(&self.sparse_shape)?
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        {
            match self.container {
                None => new_op.set_attr_value_proto("container", &vec![18_u8, 0_u8,])?,
                Some(ref value) => (|attr| {new_op.set_attr_string("container", attr)})(&value)?,
            };
        }
        {
            match self.shared_name {
                None => new_op.set_attr_value_proto("shared_name", &vec![18_u8, 0_u8,])?,
                Some(ref value) => (|attr| {new_op.set_attr_string("shared_name", attr)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct AddSparseToTensorsMap<sparse_indices_Arg, T, sparse_values_Arg, sparse_shape_Arg>
where sparse_indices_Arg: Clone,
      sparse_indices_Arg: GraphEdge<i64>,
      sparse_indices_Arg: 'static,
      T: TensorType,
      T: Clone,
      sparse_values_Arg: Clone,
      sparse_values_Arg: GraphEdge<T>,
      sparse_values_Arg: 'static,
      sparse_shape_Arg: Clone,
      sparse_shape_Arg: GraphEdge<i64>,
      sparse_shape_Arg: 'static,
      T: 'static,
{
    sparse_indices: sparse_indices_Arg,
    phantom_T: PhantomData<T>,
    sparse_values: sparse_values_Arg,
    sparse_shape: sparse_shape_Arg,
    container: Option<String>,
    shared_name: Option<String>,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<sparse_indices_Arg, T, sparse_values_Arg, sparse_shape_Arg> AddSparseToTensorsMap<sparse_indices_Arg, T, sparse_values_Arg, sparse_shape_Arg>
where sparse_indices_Arg: Clone,
      sparse_indices_Arg: GraphEdge<i64>,
      sparse_indices_Arg: 'static,
      T: TensorType,
      T: Clone,
      sparse_values_Arg: Clone,
      sparse_values_Arg: GraphEdge<T>,
      sparse_values_Arg: 'static,
      sparse_shape_Arg: Clone,
      sparse_shape_Arg: GraphEdge<i64>,
      sparse_shape_Arg: 'static,
      T: 'static,
{
    pub fn sparse_handle(self) -> Edge<i64> {
        let rc = Rc::new(self);
        {
            Edge::<i64>::new(rc.clone(), 0)
        }
    }

    pub fn container(&mut self, container: &str) -> Self {
        self.container = Some(container.to_string());
        self.clone()
    }

    pub fn shared_name(&mut self, shared_name: &str) -> Self {
        self.shared_name = Some(shared_name.to_string());
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<i64> {
        let rc = Rc::new(self);
        {
            Edge::<i64>::new(rc.clone(), 0)
        }
    }

    pub fn build(sparse_indices: sparse_indices_Arg, sparse_values: sparse_values_Arg, sparse_shape: sparse_shape_Arg) -> Self {
        Self {
            sparse_indices,
            phantom_T: PhantomData,
            sparse_values,
            sparse_shape,
            container: None,
            shared_name: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(sparse_indices: sparse_indices_Arg, sparse_values: sparse_values_Arg, sparse_shape: sparse_shape_Arg) -> Edge<i64> {
        Self {
            sparse_indices,
            phantom_T: PhantomData,
            sparse_values,
            sparse_shape,
            container: None,
            shared_name: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<T, input_Arg, filter_Arg, out_backprop_Arg> GraphOperation for Dilation2DBackpropFilter<T, input_Arg, filter_Arg, out_backprop_Arg>
where T: TensorType,
      T: Clone,
      input_Arg: Clone,
      input_Arg: GraphEdge<T>,
      input_Arg: 'static,
      filter_Arg: Clone,
      filter_Arg: GraphEdge<T>,
      filter_Arg: 'static,
      out_backprop_Arg: Clone,
      out_backprop_Arg: GraphEdge<T>,
      out_backprop_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("Dilation2DBackpropFilter_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("Dilation2DBackpropFilter", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.input)?
        }
        {
            new_op.add_edge(&self.filter)?
        }
        {
            new_op.add_edge(&self.out_backprop)?
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        {
            (|attrs| {new_op.set_attr_int_list("strides", attrs)})(&self.strides)?
        }
        {
            (|attrs| {new_op.set_attr_int_list("rates", attrs)})(&self.rates)?
        }
        {
            (|attr| {new_op.set_attr_string("padding", attr)})(&self.padding)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct Dilation2DBackpropFilter<T, input_Arg, filter_Arg, out_backprop_Arg>
where T: TensorType,
      T: Clone,
      input_Arg: Clone,
      input_Arg: GraphEdge<T>,
      input_Arg: 'static,
      filter_Arg: Clone,
      filter_Arg: GraphEdge<T>,
      filter_Arg: 'static,
      out_backprop_Arg: Clone,
      out_backprop_Arg: GraphEdge<T>,
      out_backprop_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    input: input_Arg,
    filter: filter_Arg,
    out_backprop: out_backprop_Arg,
    strides: Vec<i64>,
    rates: Vec<i64>,
    padding: String,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<T, input_Arg, filter_Arg, out_backprop_Arg> Dilation2DBackpropFilter<T, input_Arg, filter_Arg, out_backprop_Arg>
where T: TensorType,
      T: Clone,
      input_Arg: Clone,
      input_Arg: GraphEdge<T>,
      input_Arg: 'static,
      filter_Arg: Clone,
      filter_Arg: GraphEdge<T>,
      filter_Arg: 'static,
      out_backprop_Arg: Clone,
      out_backprop_Arg: GraphEdge<T>,
      out_backprop_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
{
    pub fn filter_backprop(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(input: input_Arg, filter: filter_Arg, out_backprop: out_backprop_Arg, strides: &[i64], rates: &[i64], padding: &str) -> Self {
        Self {
            phantom_T: PhantomData,
            input,
            filter,
            out_backprop,
            strides: strides.to_vec(),
            rates: rates.to_vec(),
            padding: padding.to_string(),
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(input: input_Arg, filter: filter_Arg, out_backprop: out_backprop_Arg, strides: &[i64], rates: &[i64], padding: &str) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            input,
            filter,
            out_backprop,
            strides: strides.to_vec(),
            rates: rates.to_vec(),
            padding: padding.to_string(),
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<T, ref__Arg, Tindices, indices_Arg, updates_Arg> GraphOperation for ScatterSub<T, ref__Arg, Tindices, indices_Arg, updates_Arg>
where T: TensorType,
      T: Clone,
      ref__Arg: Clone,
      ref__Arg: GraphRefEdge<T>,
      ref__Arg: 'static,
      Tindices: TensorType,
      Tindices: Clone,
      indices_Arg: Clone,
      indices_Arg: GraphEdge<Tindices>,
      indices_Arg: 'static,
      updates_Arg: Clone,
      updates_Arg: GraphEdge<T>,
      updates_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
      Tindices: con_or_DT_INT32_or_DT_INT64,
      Tindices: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("ScatterSub_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("ScatterSub", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.ref_)?
        }
        {
            new_op.add_edge(&self.indices)?
        }
        {
            new_op.add_edge(&self.updates)?
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        {
            new_op.set_attr_type("Tindices", Tindices::data_type())?;
        }
        {
            match self.use_locking {
                None => new_op.set_attr_value_proto("use_locking", &vec![40_u8, 0_u8,])?,
                Some(ref value) => (|attr: &bool| {new_op.set_attr_bool("use_locking", *attr)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct ScatterSub<T, ref__Arg, Tindices, indices_Arg, updates_Arg>
where T: TensorType,
      T: Clone,
      ref__Arg: Clone,
      ref__Arg: GraphRefEdge<T>,
      ref__Arg: 'static,
      Tindices: TensorType,
      Tindices: Clone,
      indices_Arg: Clone,
      indices_Arg: GraphEdge<Tindices>,
      indices_Arg: 'static,
      updates_Arg: Clone,
      updates_Arg: GraphEdge<T>,
      updates_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
      Tindices: con_or_DT_INT32_or_DT_INT64,
      Tindices: 'static,
{
    phantom_T: PhantomData<T>,
    ref_: ref__Arg,
    phantom_Tindices: PhantomData<Tindices>,
    indices: indices_Arg,
    updates: updates_Arg,
    use_locking: Option<bool>,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<T, ref__Arg, Tindices, indices_Arg, updates_Arg> ScatterSub<T, ref__Arg, Tindices, indices_Arg, updates_Arg>
where T: TensorType,
      T: Clone,
      ref__Arg: Clone,
      ref__Arg: GraphRefEdge<T>,
      ref__Arg: 'static,
      Tindices: TensorType,
      Tindices: Clone,
      indices_Arg: Clone,
      indices_Arg: GraphEdge<Tindices>,
      indices_Arg: 'static,
      updates_Arg: Clone,
      updates_Arg: GraphEdge<T>,
      updates_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
      Tindices: con_or_DT_INT32_or_DT_INT64,
      Tindices: 'static,
{
    pub fn output_ref(self) -> RefEdge<T> {
        let rc = Rc::new(self);
        {
            RefEdge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn use_locking(&mut self, use_locking: bool) -> Self {
        self.use_locking = Some(use_locking);
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> RefEdge<T> {
        let rc = Rc::new(self);
        {
            RefEdge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(ref_: ref__Arg, indices: indices_Arg, updates: updates_Arg) -> Self {
        Self {
            phantom_T: PhantomData,
            ref_,
            phantom_Tindices: PhantomData,
            indices,
            updates,
            use_locking: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(ref_: ref__Arg, indices: indices_Arg, updates: updates_Arg) -> RefEdge<T> {
        Self {
            phantom_T: PhantomData,
            ref_,
            phantom_Tindices: PhantomData,
            indices,
            updates,
            use_locking: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<T, input_Arg, input_h_Arg, input_c_Arg, params_Arg, output_Arg, output_h_Arg, output_c_Arg, output_backprop_Arg, output_h_backprop_Arg, output_c_backprop_Arg, reserve_space_Arg> GraphOperation for CudnnRNNBackprop<T, input_Arg, input_h_Arg, input_c_Arg, params_Arg, output_Arg, output_h_Arg, output_c_Arg, output_backprop_Arg, output_h_backprop_Arg, output_c_backprop_Arg, reserve_space_Arg>
where T: TensorType,
      T: Clone,
      input_Arg: Clone,
      input_Arg: GraphEdge<T>,
      input_Arg: 'static,
      input_h_Arg: Clone,
      input_h_Arg: GraphEdge<T>,
      input_h_Arg: 'static,
      input_c_Arg: Clone,
      input_c_Arg: GraphEdge<T>,
      input_c_Arg: 'static,
      params_Arg: Clone,
      params_Arg: GraphEdge<T>,
      params_Arg: 'static,
      output_Arg: Clone,
      output_Arg: GraphEdge<T>,
      output_Arg: 'static,
      output_h_Arg: Clone,
      output_h_Arg: GraphEdge<T>,
      output_h_Arg: 'static,
      output_c_Arg: Clone,
      output_c_Arg: GraphEdge<T>,
      output_c_Arg: 'static,
      output_backprop_Arg: Clone,
      output_backprop_Arg: GraphEdge<T>,
      output_backprop_Arg: 'static,
      output_h_backprop_Arg: Clone,
      output_h_backprop_Arg: GraphEdge<T>,
      output_h_backprop_Arg: 'static,
      output_c_backprop_Arg: Clone,
      output_c_backprop_Arg: GraphEdge<T>,
      output_c_backprop_Arg: 'static,
      reserve_space_Arg: Clone,
      reserve_space_Arg: GraphEdge<T>,
      reserve_space_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_HALF,
      T: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("CudnnRNNBackprop_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("CudnnRNNBackprop", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.input)?
        }
        {
            new_op.add_edge(&self.input_h)?
        }
        {
            new_op.add_edge(&self.input_c)?
        }
        {
            new_op.add_edge(&self.params)?
        }
        {
            new_op.add_edge(&self.output)?
        }
        {
            new_op.add_edge(&self.output_h)?
        }
        {
            new_op.add_edge(&self.output_c)?
        }
        {
            new_op.add_edge(&self.output_backprop)?
        }
        {
            new_op.add_edge(&self.output_h_backprop)?
        }
        {
            new_op.add_edge(&self.output_c_backprop)?
        }
        {
            new_op.add_edge(&self.reserve_space)?
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        {
            match self.rnn_mode {
                None => new_op.set_attr_value_proto("rnn_mode", &vec![18_u8, 4_u8, 108_u8, 115_u8, 116_u8, 109_u8,])?,
                Some(ref value) => (|attr| {new_op.set_attr_string("rnn_mode", attr)})(&value)?,
            };
        }
        {
            match self.input_mode {
                None => new_op.set_attr_value_proto("input_mode", &vec![18_u8, 12_u8, 108_u8, 105_u8, 110_u8, 101_u8, 97_u8, 114_u8, 95_u8, 105_u8, 110_u8, 112_u8, 117_u8, 116_u8,])?,
                Some(ref value) => (|attr| {new_op.set_attr_string("input_mode", attr)})(&value)?,
            };
        }
        {
            match self.direction {
                None => new_op.set_attr_value_proto("direction", &vec![18_u8, 14_u8, 117_u8, 110_u8, 105_u8, 100_u8, 105_u8, 114_u8, 101_u8, 99_u8, 116_u8, 105_u8, 111_u8, 110_u8, 97_u8, 108_u8,])?,
                Some(ref value) => (|attr| {new_op.set_attr_string("direction", attr)})(&value)?,
            };
        }
        {
            match self.dropout {
                None => new_op.set_attr_value_proto("dropout", &vec![37_u8, 0_u8, 0_u8, 0_u8, 0_u8,])?,
                Some(ref value) => (|attr: &f32| {new_op.set_attr_float("dropout", *attr)})(&value)?,
            };
        }
        {
            match self.seed {
                None => new_op.set_attr_value_proto("seed", &vec![24_u8, 0_u8,])?,
                Some(ref value) => (|attr: &i64| {new_op.set_attr_int("seed", *attr)})(&value)?,
            };
        }
        {
            match self.seed2 {
                None => new_op.set_attr_value_proto("seed2", &vec![24_u8, 0_u8,])?,
                Some(ref value) => (|attr: &i64| {new_op.set_attr_int("seed2", *attr)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct CudnnRNNBackprop<T, input_Arg, input_h_Arg, input_c_Arg, params_Arg, output_Arg, output_h_Arg, output_c_Arg, output_backprop_Arg, output_h_backprop_Arg, output_c_backprop_Arg, reserve_space_Arg>
where T: TensorType,
      T: Clone,
      input_Arg: Clone,
      input_Arg: GraphEdge<T>,
      input_Arg: 'static,
      input_h_Arg: Clone,
      input_h_Arg: GraphEdge<T>,
      input_h_Arg: 'static,
      input_c_Arg: Clone,
      input_c_Arg: GraphEdge<T>,
      input_c_Arg: 'static,
      params_Arg: Clone,
      params_Arg: GraphEdge<T>,
      params_Arg: 'static,
      output_Arg: Clone,
      output_Arg: GraphEdge<T>,
      output_Arg: 'static,
      output_h_Arg: Clone,
      output_h_Arg: GraphEdge<T>,
      output_h_Arg: 'static,
      output_c_Arg: Clone,
      output_c_Arg: GraphEdge<T>,
      output_c_Arg: 'static,
      output_backprop_Arg: Clone,
      output_backprop_Arg: GraphEdge<T>,
      output_backprop_Arg: 'static,
      output_h_backprop_Arg: Clone,
      output_h_backprop_Arg: GraphEdge<T>,
      output_h_backprop_Arg: 'static,
      output_c_backprop_Arg: Clone,
      output_c_backprop_Arg: GraphEdge<T>,
      output_c_backprop_Arg: 'static,
      reserve_space_Arg: Clone,
      reserve_space_Arg: GraphEdge<T>,
      reserve_space_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_HALF,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    input: input_Arg,
    input_h: input_h_Arg,
    input_c: input_c_Arg,
    params: params_Arg,
    output: output_Arg,
    output_h: output_h_Arg,
    output_c: output_c_Arg,
    output_backprop: output_backprop_Arg,
    output_h_backprop: output_h_backprop_Arg,
    output_c_backprop: output_c_backprop_Arg,
    reserve_space: reserve_space_Arg,
    rnn_mode: Option<String>,
    input_mode: Option<String>,
    direction: Option<String>,
    dropout: Option<f32>,
    seed: Option<i64>,
    seed2: Option<i64>,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<T, input_Arg, input_h_Arg, input_c_Arg, params_Arg, output_Arg, output_h_Arg, output_c_Arg, output_backprop_Arg, output_h_backprop_Arg, output_c_backprop_Arg, reserve_space_Arg> CudnnRNNBackprop<T, input_Arg, input_h_Arg, input_c_Arg, params_Arg, output_Arg, output_h_Arg, output_c_Arg, output_backprop_Arg, output_h_backprop_Arg, output_c_backprop_Arg, reserve_space_Arg>
where T: TensorType,
      T: Clone,
      input_Arg: Clone,
      input_Arg: GraphEdge<T>,
      input_Arg: 'static,
      input_h_Arg: Clone,
      input_h_Arg: GraphEdge<T>,
      input_h_Arg: 'static,
      input_c_Arg: Clone,
      input_c_Arg: GraphEdge<T>,
      input_c_Arg: 'static,
      params_Arg: Clone,
      params_Arg: GraphEdge<T>,
      params_Arg: 'static,
      output_Arg: Clone,
      output_Arg: GraphEdge<T>,
      output_Arg: 'static,
      output_h_Arg: Clone,
      output_h_Arg: GraphEdge<T>,
      output_h_Arg: 'static,
      output_c_Arg: Clone,
      output_c_Arg: GraphEdge<T>,
      output_c_Arg: 'static,
      output_backprop_Arg: Clone,
      output_backprop_Arg: GraphEdge<T>,
      output_backprop_Arg: 'static,
      output_h_backprop_Arg: Clone,
      output_h_backprop_Arg: GraphEdge<T>,
      output_h_backprop_Arg: 'static,
      output_c_backprop_Arg: Clone,
      output_c_backprop_Arg: GraphEdge<T>,
      output_c_backprop_Arg: 'static,
      reserve_space_Arg: Clone,
      reserve_space_Arg: GraphEdge<T>,
      reserve_space_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_HALF,
      T: 'static,
{
    pub fn input_backprop(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn input_h_backprop(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 1)
        }
    }

    pub fn input_c_backprop(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 2)
        }
    }

    pub fn params_backprop(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 3)
        }
    }

    pub fn rnn_mode(&mut self, rnn_mode: &str) -> Self {
        self.rnn_mode = Some(rnn_mode.to_string());
        self.clone()
    }

    pub fn input_mode(&mut self, input_mode: &str) -> Self {
        self.input_mode = Some(input_mode.to_string());
        self.clone()
    }

    pub fn direction(&mut self, direction: &str) -> Self {
        self.direction = Some(direction.to_string());
        self.clone()
    }

    pub fn dropout(&mut self, dropout: f32) -> Self {
        self.dropout = Some(dropout);
        self.clone()
    }

    pub fn seed(&mut self, seed: i64) -> Self {
        self.seed = Some(seed);
        self.clone()
    }

    pub fn seed2(&mut self, seed2: i64) -> Self {
        self.seed2 = Some(seed2);
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> (Edge<T>, Edge<T>, Edge<T>, Edge<T>) {
        let rc = Rc::new(self);
        (
        {
            Edge::<T>::new(rc.clone(), 0)
        },
        {
            Edge::<T>::new(rc.clone(), 1)
        },
        {
            Edge::<T>::new(rc.clone(), 2)
        },
        {
            Edge::<T>::new(rc.clone(), 3)
        },
        )
    }

    pub fn build(input: input_Arg, input_h: input_h_Arg, input_c: input_c_Arg, params: params_Arg, output: output_Arg, output_h: output_h_Arg, output_c: output_c_Arg, output_backprop: output_backprop_Arg, output_h_backprop: output_h_backprop_Arg, output_c_backprop: output_c_backprop_Arg, reserve_space: reserve_space_Arg) -> Self {
        Self {
            phantom_T: PhantomData,
            input,
            input_h,
            input_c,
            params,
            output,
            output_h,
            output_c,
            output_backprop,
            output_h_backprop,
            output_c_backprop,
            reserve_space,
            rnn_mode: None,
            input_mode: None,
            direction: None,
            dropout: None,
            seed: None,
            seed2: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(input: input_Arg, input_h: input_h_Arg, input_c: input_c_Arg, params: params_Arg, output: output_Arg, output_h: output_h_Arg, output_c: output_c_Arg, output_backprop: output_backprop_Arg, output_h_backprop: output_h_backprop_Arg, output_c_backprop: output_c_backprop_Arg, reserve_space: reserve_space_Arg) -> (Edge<T>, Edge<T>, Edge<T>, Edge<T>) {
        Self {
            phantom_T: PhantomData,
            input,
            input_h,
            input_c,
            params,
            output,
            output_h,
            output_c,
            output_backprop,
            output_h_backprop,
            output_c_backprop,
            reserve_space,
            rnn_mode: None,
            input_mode: None,
            direction: None,
            dropout: None,
            seed: None,
            seed2: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<dtype, input_Arg> GraphOperation for InfeedEnqueue<dtype, input_Arg>
where dtype: TensorType,
      dtype: Clone,
      input_Arg: Clone,
      input_Arg: GraphEdge<dtype>,
      input_Arg: 'static,
      dtype: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("InfeedEnqueue_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("InfeedEnqueue", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.input)?
        }
        {
            new_op.set_attr_type("dtype", dtype::data_type())?;
        }
        {
            match self.shape {
                None => new_op.set_attr_value_proto("shape", &vec![58_u8, 0_u8,])?,
                Some(ref value) => (|attr| {new_op.set_attr_shape("shape", attr)})(&value)?,
            };
        }
        {
            match self.device_ordinal {
                None => new_op.set_attr_value_proto("device_ordinal", &vec![24_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 1_u8,])?,
                Some(ref value) => (|attr: &i64| {new_op.set_attr_int("device_ordinal", *attr)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct InfeedEnqueue<dtype, input_Arg>
where dtype: TensorType,
      dtype: Clone,
      input_Arg: Clone,
      input_Arg: GraphEdge<dtype>,
      input_Arg: 'static,
      dtype: 'static,
{
    phantom_dtype: PhantomData<dtype>,
    input: input_Arg,
    shape: Option<OtherShape>,
    device_ordinal: Option<i64>,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<dtype, input_Arg> InfeedEnqueue<dtype, input_Arg>
where dtype: TensorType,
      dtype: Clone,
      input_Arg: Clone,
      input_Arg: GraphEdge<dtype>,
      input_Arg: 'static,
      dtype: 'static,
{
    pub fn shape(&mut self, shape: &OtherShape) -> Self {
        self.shape = Some(shape.clone());
        self.clone()
    }

    pub fn device_ordinal(&mut self, device_ordinal: i64) -> Self {
        self.device_ordinal = Some(device_ordinal);
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> () {
        let rc = Rc::new(self);
        (
        )
    }

    pub fn build(input: input_Arg) -> Self {
        Self {
            phantom_dtype: PhantomData,
            input,
            shape: None,
            device_ordinal: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(input: input_Arg) -> () {
        Self {
            phantom_dtype: PhantomData,
            input,
            shape: None,
            device_ordinal: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<input_Arg> GraphOperation for PrintV2<input_Arg>
where input_Arg: Clone,
      input_Arg: GraphEdge<String>,
      input_Arg: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("PrintV2_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("PrintV2", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.input)?
        }
        {
            match self.output_stream {
                None => new_op.set_attr_value_proto("output_stream", &vec![18_u8, 6_u8, 115_u8, 116_u8, 100_u8, 101_u8, 114_u8, 114_u8,])?,
                Some(ref value) => (|attr| {new_op.set_attr_string("output_stream", attr)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct PrintV2<input_Arg>
where input_Arg: Clone,
      input_Arg: GraphEdge<String>,
      input_Arg: 'static,
{
    input: input_Arg,
    output_stream: Option<String>,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<input_Arg> PrintV2<input_Arg>
where input_Arg: Clone,
      input_Arg: GraphEdge<String>,
      input_Arg: 'static,
{
    pub fn output_stream(&mut self, output_stream: &str) -> Self {
        self.output_stream = Some(output_stream.to_string());
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> () {
        let rc = Rc::new(self);
        (
        )
    }

    pub fn build(input: input_Arg) -> Self {
        Self {
            input,
            output_stream: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(input: input_Arg) -> () {
        Self {
            input,
            output_stream: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl GraphOperation for RetrieveTPUEmbeddingFTRLParameters {
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("RetrieveTPUEmbeddingFTRLParameters_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("RetrieveTPUEmbeddingFTRLParameters", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            match self.table_id {
                None => new_op.set_attr_value_proto("table_id", &vec![24_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 1_u8,])?,
                Some(ref value) => (|attr: &i64| {new_op.set_attr_int("table_id", *attr)})(&value)?,
            };
        }
        {
            match self.table_name {
                None => new_op.set_attr_value_proto("table_name", &vec![18_u8, 0_u8,])?,
                Some(ref value) => (|attr| {new_op.set_attr_string("table_name", attr)})(&value)?,
            };
        }
        {
            (|attr: &i64| {new_op.set_attr_int("num_shards", *attr)})(&self.num_shards)?
        }
        {
            (|attr: &i64| {new_op.set_attr_int("shard_id", *attr)})(&self.shard_id)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct RetrieveTPUEmbeddingFTRLParameters {
    table_id: Option<i64>,
    table_name: Option<String>,
    num_shards: i64,
    shard_id: i64,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl RetrieveTPUEmbeddingFTRLParameters {
    pub fn parameters(self) -> Edge<f32> {
        let rc = Rc::new(self);
        {
            Edge::<f32>::new(rc.clone(), 0)
        }
    }

    pub fn accumulators(self) -> Edge<f32> {
        let rc = Rc::new(self);
        {
            Edge::<f32>::new(rc.clone(), 1)
        }
    }

    pub fn linears(self) -> Edge<f32> {
        let rc = Rc::new(self);
        {
            Edge::<f32>::new(rc.clone(), 2)
        }
    }

    pub fn table_id(&mut self, table_id: i64) -> Self {
        self.table_id = Some(table_id);
        self.clone()
    }

    pub fn table_name(&mut self, table_name: &str) -> Self {
        self.table_name = Some(table_name.to_string());
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> (Edge<f32>, Edge<f32>, Edge<f32>) {
        let rc = Rc::new(self);
        (
        {
            Edge::<f32>::new(rc.clone(), 0)
        },
        {
            Edge::<f32>::new(rc.clone(), 1)
        },
        {
            Edge::<f32>::new(rc.clone(), 2)
        },
        )
    }

    pub fn build(num_shards: i64, shard_id: i64) -> Self {
        Self {
            table_id: None,
            table_name: None,
            num_shards: num_shards,
            shard_id: shard_id,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(num_shards: i64, shard_id: i64) -> (Edge<f32>, Edge<f32>, Edge<f32>) {
        Self {
            table_id: None,
            table_name: None,
            num_shards: num_shards,
            shard_id: shard_id,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<T, input_Arg> GraphOperation for DebugNanCount<T, input_Arg>
where T: TensorType,
      T: Clone,
      input_Arg: Clone,
      input_Arg: GraphEdge<T>,
      input_Arg: 'static,
      T: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("DebugNanCount_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("DebugNanCount", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.input)?
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        {
            match self.device_name {
                None => new_op.set_attr_value_proto("device_name", &vec![18_u8, 0_u8,])?,
                Some(ref value) => (|attr| {new_op.set_attr_string("device_name", attr)})(&value)?,
            };
        }
        {
            match self.tensor_name {
                None => new_op.set_attr_value_proto("tensor_name", &vec![18_u8, 0_u8,])?,
                Some(ref value) => (|attr| {new_op.set_attr_string("tensor_name", attr)})(&value)?,
            };
        }
        {
            match self.debug_urls {
                None => new_op.set_attr_value_proto("debug_urls", &vec![10_u8, 0_u8,])?,
                Some(ref value) => (|attrs| {new_op.set_attr_string_list("debug_urls", attrs)})(&value)?,
            };
        }
        {
            match self.gated_grpc {
                None => new_op.set_attr_value_proto("gated_grpc", &vec![40_u8, 0_u8,])?,
                Some(ref value) => (|attr: &bool| {new_op.set_attr_bool("gated_grpc", *attr)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct DebugNanCount<T, input_Arg>
where T: TensorType,
      T: Clone,
      input_Arg: Clone,
      input_Arg: GraphEdge<T>,
      input_Arg: 'static,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    input: input_Arg,
    device_name: Option<String>,
    tensor_name: Option<String>,
    debug_urls: Option<Vec<String>>,
    gated_grpc: Option<bool>,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<T, input_Arg> DebugNanCount<T, input_Arg>
where T: TensorType,
      T: Clone,
      input_Arg: Clone,
      input_Arg: GraphEdge<T>,
      input_Arg: 'static,
      T: 'static,
{
    pub fn output(self) -> Edge<i64> {
        let rc = Rc::new(self);
        {
            Edge::<i64>::new(rc.clone(), 0)
        }
    }

    pub fn device_name(&mut self, device_name: &str) -> Self {
        self.device_name = Some(device_name.to_string());
        self.clone()
    }

    pub fn tensor_name(&mut self, tensor_name: &str) -> Self {
        self.tensor_name = Some(tensor_name.to_string());
        self.clone()
    }

    pub fn debug_urls(&mut self, debug_urls: &[String]) -> Self {
        self.debug_urls = Some(debug_urls.to_vec());
        self.clone()
    }

    pub fn gated_grpc(&mut self, gated_grpc: bool) -> Self {
        self.gated_grpc = Some(gated_grpc);
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<i64> {
        let rc = Rc::new(self);
        {
            Edge::<i64>::new(rc.clone(), 0)
        }
    }

    pub fn build(input: input_Arg) -> Self {
        Self {
            phantom_T: PhantomData,
            input,
            device_name: None,
            tensor_name: None,
            debug_urls: None,
            gated_grpc: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(input: input_Arg) -> Edge<i64> {
        Self {
            phantom_T: PhantomData,
            input,
            device_name: None,
            tensor_name: None,
            debug_urls: None,
            gated_grpc: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<T, var_Arg, ms_Arg, mom_Arg, lr_Arg, rho_Arg, momentum_Arg, epsilon_Arg, grad_Arg> GraphOperation for ApplyRMSProp<T, var_Arg, ms_Arg, mom_Arg, lr_Arg, rho_Arg, momentum_Arg, epsilon_Arg, grad_Arg>
where T: TensorType,
      T: Clone,
      var_Arg: Clone,
      var_Arg: GraphRefEdge<T>,
      var_Arg: 'static,
      ms_Arg: Clone,
      ms_Arg: GraphRefEdge<T>,
      ms_Arg: 'static,
      mom_Arg: Clone,
      mom_Arg: GraphRefEdge<T>,
      mom_Arg: 'static,
      lr_Arg: Clone,
      lr_Arg: GraphEdge<T>,
      lr_Arg: 'static,
      rho_Arg: Clone,
      rho_Arg: GraphEdge<T>,
      rho_Arg: 'static,
      momentum_Arg: Clone,
      momentum_Arg: GraphEdge<T>,
      momentum_Arg: 'static,
      epsilon_Arg: Clone,
      epsilon_Arg: GraphEdge<T>,
      epsilon_Arg: 'static,
      grad_Arg: Clone,
      grad_Arg: GraphEdge<T>,
      grad_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("ApplyRMSProp_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("ApplyRMSProp", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.var)?
        }
        {
            new_op.add_edge(&self.ms)?
        }
        {
            new_op.add_edge(&self.mom)?
        }
        {
            new_op.add_edge(&self.lr)?
        }
        {
            new_op.add_edge(&self.rho)?
        }
        {
            new_op.add_edge(&self.momentum)?
        }
        {
            new_op.add_edge(&self.epsilon)?
        }
        {
            new_op.add_edge(&self.grad)?
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        {
            match self.use_locking {
                None => new_op.set_attr_value_proto("use_locking", &vec![40_u8, 0_u8,])?,
                Some(ref value) => (|attr: &bool| {new_op.set_attr_bool("use_locking", *attr)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct ApplyRMSProp<T, var_Arg, ms_Arg, mom_Arg, lr_Arg, rho_Arg, momentum_Arg, epsilon_Arg, grad_Arg>
where T: TensorType,
      T: Clone,
      var_Arg: Clone,
      var_Arg: GraphRefEdge<T>,
      var_Arg: 'static,
      ms_Arg: Clone,
      ms_Arg: GraphRefEdge<T>,
      ms_Arg: 'static,
      mom_Arg: Clone,
      mom_Arg: GraphRefEdge<T>,
      mom_Arg: 'static,
      lr_Arg: Clone,
      lr_Arg: GraphEdge<T>,
      lr_Arg: 'static,
      rho_Arg: Clone,
      rho_Arg: GraphEdge<T>,
      rho_Arg: 'static,
      momentum_Arg: Clone,
      momentum_Arg: GraphEdge<T>,
      momentum_Arg: 'static,
      epsilon_Arg: Clone,
      epsilon_Arg: GraphEdge<T>,
      epsilon_Arg: 'static,
      grad_Arg: Clone,
      grad_Arg: GraphEdge<T>,
      grad_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    var: var_Arg,
    ms: ms_Arg,
    mom: mom_Arg,
    lr: lr_Arg,
    rho: rho_Arg,
    momentum: momentum_Arg,
    epsilon: epsilon_Arg,
    grad: grad_Arg,
    use_locking: Option<bool>,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<T, var_Arg, ms_Arg, mom_Arg, lr_Arg, rho_Arg, momentum_Arg, epsilon_Arg, grad_Arg> ApplyRMSProp<T, var_Arg, ms_Arg, mom_Arg, lr_Arg, rho_Arg, momentum_Arg, epsilon_Arg, grad_Arg>
where T: TensorType,
      T: Clone,
      var_Arg: Clone,
      var_Arg: GraphRefEdge<T>,
      var_Arg: 'static,
      ms_Arg: Clone,
      ms_Arg: GraphRefEdge<T>,
      ms_Arg: 'static,
      mom_Arg: Clone,
      mom_Arg: GraphRefEdge<T>,
      mom_Arg: 'static,
      lr_Arg: Clone,
      lr_Arg: GraphEdge<T>,
      lr_Arg: 'static,
      rho_Arg: Clone,
      rho_Arg: GraphEdge<T>,
      rho_Arg: 'static,
      momentum_Arg: Clone,
      momentum_Arg: GraphEdge<T>,
      momentum_Arg: 'static,
      epsilon_Arg: Clone,
      epsilon_Arg: GraphEdge<T>,
      epsilon_Arg: 'static,
      grad_Arg: Clone,
      grad_Arg: GraphEdge<T>,
      grad_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
{
    pub fn out(self) -> RefEdge<T> {
        let rc = Rc::new(self);
        {
            RefEdge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn use_locking(&mut self, use_locking: bool) -> Self {
        self.use_locking = Some(use_locking);
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> RefEdge<T> {
        let rc = Rc::new(self);
        {
            RefEdge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(var: var_Arg, ms: ms_Arg, mom: mom_Arg, lr: lr_Arg, rho: rho_Arg, momentum: momentum_Arg, epsilon: epsilon_Arg, grad: grad_Arg) -> Self {
        Self {
            phantom_T: PhantomData,
            var,
            ms,
            mom,
            lr,
            rho,
            momentum,
            epsilon,
            grad,
            use_locking: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(var: var_Arg, ms: ms_Arg, mom: mom_Arg, lr: lr_Arg, rho: rho_Arg, momentum: momentum_Arg, epsilon: epsilon_Arg, grad: grad_Arg) -> RefEdge<T> {
        Self {
            phantom_T: PhantomData,
            var,
            ms,
            mom,
            lr,
            rho,
            momentum,
            epsilon,
            grad,
            use_locking: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<inputs_Arg, min_Arg, max_Arg> GraphOperation for FakeQuantWithMinMaxVars<inputs_Arg, min_Arg, max_Arg>
where inputs_Arg: Clone,
      inputs_Arg: GraphEdge<f32>,
      inputs_Arg: 'static,
      min_Arg: Clone,
      min_Arg: GraphEdge<f32>,
      min_Arg: 'static,
      max_Arg: Clone,
      max_Arg: GraphEdge<f32>,
      max_Arg: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("FakeQuantWithMinMaxVars_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("FakeQuantWithMinMaxVars", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.inputs)?
        }
        {
            new_op.add_edge(&self.min)?
        }
        {
            new_op.add_edge(&self.max)?
        }
        {
            match self.num_bits {
                None => new_op.set_attr_value_proto("num_bits", &vec![24_u8, 8_u8,])?,
                Some(ref value) => (|attr: &i64| {new_op.set_attr_int("num_bits", *attr)})(&value)?,
            };
        }
        {
            match self.narrow_range {
                None => new_op.set_attr_value_proto("narrow_range", &vec![40_u8, 0_u8,])?,
                Some(ref value) => (|attr: &bool| {new_op.set_attr_bool("narrow_range", *attr)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct FakeQuantWithMinMaxVars<inputs_Arg, min_Arg, max_Arg>
where inputs_Arg: Clone,
      inputs_Arg: GraphEdge<f32>,
      inputs_Arg: 'static,
      min_Arg: Clone,
      min_Arg: GraphEdge<f32>,
      min_Arg: 'static,
      max_Arg: Clone,
      max_Arg: GraphEdge<f32>,
      max_Arg: 'static,
{
    inputs: inputs_Arg,
    min: min_Arg,
    max: max_Arg,
    num_bits: Option<i64>,
    narrow_range: Option<bool>,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<inputs_Arg, min_Arg, max_Arg> FakeQuantWithMinMaxVars<inputs_Arg, min_Arg, max_Arg>
where inputs_Arg: Clone,
      inputs_Arg: GraphEdge<f32>,
      inputs_Arg: 'static,
      min_Arg: Clone,
      min_Arg: GraphEdge<f32>,
      min_Arg: 'static,
      max_Arg: Clone,
      max_Arg: GraphEdge<f32>,
      max_Arg: 'static,
{
    pub fn outputs(self) -> Edge<f32> {
        let rc = Rc::new(self);
        {
            Edge::<f32>::new(rc.clone(), 0)
        }
    }

    pub fn num_bits(&mut self, num_bits: i64) -> Self {
        self.num_bits = Some(num_bits);
        self.clone()
    }

    pub fn narrow_range(&mut self, narrow_range: bool) -> Self {
        self.narrow_range = Some(narrow_range);
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<f32> {
        let rc = Rc::new(self);
        {
            Edge::<f32>::new(rc.clone(), 0)
        }
    }

    pub fn build(inputs: inputs_Arg, min: min_Arg, max: max_Arg) -> Self {
        Self {
            inputs,
            min,
            max,
            num_bits: None,
            narrow_range: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(inputs: inputs_Arg, min: min_Arg, max: max_Arg) -> Edge<f32> {
        Self {
            inputs,
            min,
            max,
            num_bits: None,
            narrow_range: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<T, input_Arg, Tidx, dimension_Arg, output_type> GraphOperation for ArgMax<T, input_Arg, Tidx, dimension_Arg, output_type>
where T: TensorType,
      T: Clone,
      input_Arg: Clone,
      input_Arg: GraphEdge<T>,
      input_Arg: 'static,
      Tidx: TensorType,
      Tidx: Clone,
      dimension_Arg: Clone,
      dimension_Arg: GraphEdge<Tidx>,
      dimension_Arg: 'static,
      output_type: TensorType,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
      Tidx: con_or_DT_INT32_or_DT_INT64,
      Tidx: 'static,
      output_type: con_or_DT_INT32_or_DT_INT64,
      output_type: 'static,
      output_type: Clone,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("ArgMax_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("ArgMax", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.input)?
        }
        {
            new_op.add_edge(&self.dimension)?
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        {
            new_op.set_attr_type("Tidx", Tidx::data_type())?;
        }
        {
            new_op.set_attr_type("output_type", output_type::data_type())?;
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct ArgMax<T, input_Arg, Tidx, dimension_Arg, output_type>
where T: TensorType,
      T: Clone,
      input_Arg: Clone,
      input_Arg: GraphEdge<T>,
      input_Arg: 'static,
      Tidx: TensorType,
      Tidx: Clone,
      dimension_Arg: Clone,
      dimension_Arg: GraphEdge<Tidx>,
      dimension_Arg: 'static,
      output_type: TensorType,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
      Tidx: con_or_DT_INT32_or_DT_INT64,
      Tidx: 'static,
      output_type: con_or_DT_INT32_or_DT_INT64,
      output_type: 'static,
      output_type: Clone,
{
    phantom_T: PhantomData<T>,
    input: input_Arg,
    phantom_Tidx: PhantomData<Tidx>,
    dimension: dimension_Arg,
    phantom_output_type: PhantomData<output_type>,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<T, input_Arg, Tidx, dimension_Arg, output_type> ArgMax<T, input_Arg, Tidx, dimension_Arg, output_type>
where T: TensorType,
      T: Clone,
      input_Arg: Clone,
      input_Arg: GraphEdge<T>,
      input_Arg: 'static,
      Tidx: TensorType,
      Tidx: Clone,
      dimension_Arg: Clone,
      dimension_Arg: GraphEdge<Tidx>,
      dimension_Arg: 'static,
      output_type: TensorType,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
      Tidx: con_or_DT_INT32_or_DT_INT64,
      Tidx: 'static,
      output_type: con_or_DT_INT32_or_DT_INT64,
      output_type: 'static,
      output_type: Clone,
{
    pub fn output(self) -> Edge<output_type> {
        let rc = Rc::new(self);
        {
            Edge::<output_type>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<output_type> {
        let rc = Rc::new(self);
        {
            Edge::<output_type>::new(rc.clone(), 0)
        }
    }

    pub fn build(input: input_Arg, dimension: dimension_Arg) -> Self {
        Self {
            phantom_T: PhantomData,
            input,
            phantom_Tidx: PhantomData,
            dimension,
            phantom_output_type: PhantomData,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(input: input_Arg, dimension: dimension_Arg) -> Edge<output_type> {
        Self {
            phantom_T: PhantomData,
            input,
            phantom_Tidx: PhantomData,
            dimension,
            phantom_output_type: PhantomData,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<T, value_Arg> GraphOperation for FractionalMaxPool<T, value_Arg>
where T: TensorType,
      T: Clone,
      value_Arg: Clone,
      value_Arg: GraphEdge<T>,
      value_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_INT64,
      T: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("FractionalMaxPool_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("FractionalMaxPool", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.value)?
        }
        {
            (|attrs| {new_op.set_attr_float_list("pooling_ratio", attrs)})(&self.pooling_ratio)?
        }
        {
            match self.pseudo_random {
                None => new_op.set_attr_value_proto("pseudo_random", &vec![40_u8, 0_u8,])?,
                Some(ref value) => (|attr: &bool| {new_op.set_attr_bool("pseudo_random", *attr)})(&value)?,
            };
        }
        {
            match self.overlapping {
                None => new_op.set_attr_value_proto("overlapping", &vec![40_u8, 0_u8,])?,
                Some(ref value) => (|attr: &bool| {new_op.set_attr_bool("overlapping", *attr)})(&value)?,
            };
        }
        {
            match self.deterministic {
                None => new_op.set_attr_value_proto("deterministic", &vec![40_u8, 0_u8,])?,
                Some(ref value) => (|attr: &bool| {new_op.set_attr_bool("deterministic", *attr)})(&value)?,
            };
        }
        {
            match self.seed {
                None => new_op.set_attr_value_proto("seed", &vec![24_u8, 0_u8,])?,
                Some(ref value) => (|attr: &i64| {new_op.set_attr_int("seed", *attr)})(&value)?,
            };
        }
        {
            match self.seed2 {
                None => new_op.set_attr_value_proto("seed2", &vec![24_u8, 0_u8,])?,
                Some(ref value) => (|attr: &i64| {new_op.set_attr_int("seed2", *attr)})(&value)?,
            };
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct FractionalMaxPool<T, value_Arg>
where T: TensorType,
      T: Clone,
      value_Arg: Clone,
      value_Arg: GraphEdge<T>,
      value_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_INT64,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    value: value_Arg,
    pooling_ratio: Vec<f32>,
    pseudo_random: Option<bool>,
    overlapping: Option<bool>,
    deterministic: Option<bool>,
    seed: Option<i64>,
    seed2: Option<i64>,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<T, value_Arg> FractionalMaxPool<T, value_Arg>
where T: TensorType,
      T: Clone,
      value_Arg: Clone,
      value_Arg: GraphEdge<T>,
      value_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_INT64,
      T: 'static,
{
    pub fn output(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn row_pooling_sequence(self) -> Edge<i64> {
        let rc = Rc::new(self);
        {
            Edge::<i64>::new(rc.clone(), 1)
        }
    }

    pub fn col_pooling_sequence(self) -> Edge<i64> {
        let rc = Rc::new(self);
        {
            Edge::<i64>::new(rc.clone(), 2)
        }
    }

    pub fn pseudo_random(&mut self, pseudo_random: bool) -> Self {
        self.pseudo_random = Some(pseudo_random);
        self.clone()
    }

    pub fn overlapping(&mut self, overlapping: bool) -> Self {
        self.overlapping = Some(overlapping);
        self.clone()
    }

    pub fn deterministic(&mut self, deterministic: bool) -> Self {
        self.deterministic = Some(deterministic);
        self.clone()
    }

    pub fn seed(&mut self, seed: i64) -> Self {
        self.seed = Some(seed);
        self.clone()
    }

    pub fn seed2(&mut self, seed2: i64) -> Self {
        self.seed2 = Some(seed2);
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> (Edge<T>, Edge<i64>, Edge<i64>) {
        let rc = Rc::new(self);
        (
        {
            Edge::<T>::new(rc.clone(), 0)
        },
        {
            Edge::<i64>::new(rc.clone(), 1)
        },
        {
            Edge::<i64>::new(rc.clone(), 2)
        },
        )
    }

    pub fn build(value: value_Arg, pooling_ratio: &[f32]) -> Self {
        Self {
            phantom_T: PhantomData,
            value,
            pooling_ratio: pooling_ratio.to_vec(),
            pseudo_random: None,
            overlapping: None,
            deterministic: None,
            seed: None,
            seed2: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(value: value_Arg, pooling_ratio: &[f32]) -> (Edge<T>, Edge<i64>, Edge<i64>) {
        Self {
            phantom_T: PhantomData,
            value,
            pooling_ratio: pooling_ratio.to_vec(),
            pseudo_random: None,
            overlapping: None,
            deterministic: None,
            seed: None,
            seed2: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

pub trait con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_BOOL_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_BOOL_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64 for BFloat16 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_BOOL_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64 for OtherComplex<f32> {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_BOOL_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64 for OtherComplex<f64> {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_BOOL_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64 for bool {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_BOOL_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64 for f32 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_BOOL_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64 for f64 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_BOOL_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64 for i16 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_BOOL_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64 for i32 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_BOOL_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64 for i64 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_BOOL_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64 for i8 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_BOOL_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64 for u16 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_BOOL_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64 for u32 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_BOOL_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64 for u64 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_BOOL_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64 for u8 {
}

impl<T, input_Arg, Tindices, indices_Arg, updates_Arg> GraphOperation for ScatterNdNonAliasingAdd<T, input_Arg, Tindices, indices_Arg, updates_Arg>
where T: TensorType,
      T: Clone,
      input_Arg: Clone,
      input_Arg: GraphEdge<T>,
      input_Arg: 'static,
      Tindices: TensorType,
      Tindices: Clone,
      indices_Arg: Clone,
      indices_Arg: GraphEdge<Tindices>,
      indices_Arg: 'static,
      updates_Arg: Clone,
      updates_Arg: GraphEdge<T>,
      updates_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_BOOL_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
      Tindices: con_or_DT_INT32_or_DT_INT64,
      Tindices: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("ScatterNdNonAliasingAdd_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("ScatterNdNonAliasingAdd", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.input)?
        }
        {
            new_op.add_edge(&self.indices)?
        }
        {
            new_op.add_edge(&self.updates)?
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        {
            new_op.set_attr_type("Tindices", Tindices::data_type())?;
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct ScatterNdNonAliasingAdd<T, input_Arg, Tindices, indices_Arg, updates_Arg>
where T: TensorType,
      T: Clone,
      input_Arg: Clone,
      input_Arg: GraphEdge<T>,
      input_Arg: 'static,
      Tindices: TensorType,
      Tindices: Clone,
      indices_Arg: Clone,
      indices_Arg: GraphEdge<Tindices>,
      indices_Arg: 'static,
      updates_Arg: Clone,
      updates_Arg: GraphEdge<T>,
      updates_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_BOOL_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
      Tindices: con_or_DT_INT32_or_DT_INT64,
      Tindices: 'static,
{
    phantom_T: PhantomData<T>,
    input: input_Arg,
    phantom_Tindices: PhantomData<Tindices>,
    indices: indices_Arg,
    updates: updates_Arg,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<T, input_Arg, Tindices, indices_Arg, updates_Arg> ScatterNdNonAliasingAdd<T, input_Arg, Tindices, indices_Arg, updates_Arg>
where T: TensorType,
      T: Clone,
      input_Arg: Clone,
      input_Arg: GraphEdge<T>,
      input_Arg: 'static,
      Tindices: TensorType,
      Tindices: Clone,
      indices_Arg: Clone,
      indices_Arg: GraphEdge<Tindices>,
      indices_Arg: 'static,
      updates_Arg: Clone,
      updates_Arg: GraphEdge<T>,
      updates_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_BOOL_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
      Tindices: con_or_DT_INT32_or_DT_INT64,
      Tindices: 'static,
{
    pub fn output(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(input: input_Arg, indices: indices_Arg, updates: updates_Arg) -> Self {
        Self {
            phantom_T: PhantomData,
            input,
            phantom_Tindices: PhantomData,
            indices,
            updates,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(input: input_Arg, indices: indices_Arg, updates: updates_Arg) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            input,
            phantom_Tindices: PhantomData,
            indices,
            updates,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<handle_Arg, flow_in_Arg> GraphOperation for TensorArraySize<handle_Arg, flow_in_Arg>
where handle_Arg: Clone,
      handle_Arg: GraphRefEdge<String>,
      handle_Arg: 'static,
      flow_in_Arg: Clone,
      flow_in_Arg: GraphEdge<f32>,
      flow_in_Arg: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("TensorArraySize_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("TensorArraySize", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.handle)?
        }
        {
            new_op.add_edge(&self.flow_in)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct TensorArraySize<handle_Arg, flow_in_Arg>
where handle_Arg: Clone,
      handle_Arg: GraphRefEdge<String>,
      handle_Arg: 'static,
      flow_in_Arg: Clone,
      flow_in_Arg: GraphEdge<f32>,
      flow_in_Arg: 'static,
{
    handle: handle_Arg,
    flow_in: flow_in_Arg,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<handle_Arg, flow_in_Arg> TensorArraySize<handle_Arg, flow_in_Arg>
where handle_Arg: Clone,
      handle_Arg: GraphRefEdge<String>,
      handle_Arg: 'static,
      flow_in_Arg: Clone,
      flow_in_Arg: GraphEdge<f32>,
      flow_in_Arg: 'static,
{
    pub fn size(self) -> Edge<i32> {
        let rc = Rc::new(self);
        {
            Edge::<i32>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<i32> {
        let rc = Rc::new(self);
        {
            Edge::<i32>::new(rc.clone(), 0)
        }
    }

    pub fn build(handle: handle_Arg, flow_in: flow_in_Arg) -> Self {
        Self {
            handle,
            flow_in,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(handle: handle_Arg, flow_in: flow_in_Arg) -> Edge<i32> {
        Self {
            handle,
            flow_in,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<inputs_Arg, sequence_length_Arg> GraphOperation for CTCGreedyDecoder<inputs_Arg, sequence_length_Arg>
where inputs_Arg: Clone,
      inputs_Arg: GraphEdge<f32>,
      inputs_Arg: 'static,
      sequence_length_Arg: Clone,
      sequence_length_Arg: GraphEdge<i32>,
      sequence_length_Arg: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("CTCGreedyDecoder_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("CTCGreedyDecoder", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.inputs)?
        }
        {
            new_op.add_edge(&self.sequence_length)?
        }
        {
            match self.merge_repeated {
                None => new_op.set_attr_value_proto("merge_repeated", &vec![40_u8, 0_u8,])?,
                Some(ref value) => (|attr: &bool| {new_op.set_attr_bool("merge_repeated", *attr)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct CTCGreedyDecoder<inputs_Arg, sequence_length_Arg>
where inputs_Arg: Clone,
      inputs_Arg: GraphEdge<f32>,
      inputs_Arg: 'static,
      sequence_length_Arg: Clone,
      sequence_length_Arg: GraphEdge<i32>,
      sequence_length_Arg: 'static,
{
    inputs: inputs_Arg,
    sequence_length: sequence_length_Arg,
    merge_repeated: Option<bool>,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<inputs_Arg, sequence_length_Arg> CTCGreedyDecoder<inputs_Arg, sequence_length_Arg>
where inputs_Arg: Clone,
      inputs_Arg: GraphEdge<f32>,
      inputs_Arg: 'static,
      sequence_length_Arg: Clone,
      sequence_length_Arg: GraphEdge<i32>,
      sequence_length_Arg: 'static,
{
    pub fn decoded_indices(self) -> Edge<i64> {
        let rc = Rc::new(self);
        {
            Edge::<i64>::new(rc.clone(), 0)
        }
    }

    pub fn decoded_values(self) -> Edge<i64> {
        let rc = Rc::new(self);
        {
            Edge::<i64>::new(rc.clone(), 1)
        }
    }

    pub fn decoded_shape(self) -> Edge<i64> {
        let rc = Rc::new(self);
        {
            Edge::<i64>::new(rc.clone(), 2)
        }
    }

    pub fn log_probability(self) -> Edge<f32> {
        let rc = Rc::new(self);
        {
            Edge::<f32>::new(rc.clone(), 3)
        }
    }

    pub fn merge_repeated(&mut self, merge_repeated: bool) -> Self {
        self.merge_repeated = Some(merge_repeated);
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> (Edge<i64>, Edge<i64>, Edge<i64>, Edge<f32>) {
        let rc = Rc::new(self);
        (
        {
            Edge::<i64>::new(rc.clone(), 0)
        },
        {
            Edge::<i64>::new(rc.clone(), 1)
        },
        {
            Edge::<i64>::new(rc.clone(), 2)
        },
        {
            Edge::<f32>::new(rc.clone(), 3)
        },
        )
    }

    pub fn build(inputs: inputs_Arg, sequence_length: sequence_length_Arg) -> Self {
        Self {
            inputs,
            sequence_length,
            merge_repeated: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(inputs: inputs_Arg, sequence_length: sequence_length_Arg) -> (Edge<i64>, Edge<i64>, Edge<i64>, Edge<f32>) {
        Self {
            inputs,
            sequence_length,
            merge_repeated: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<parameters_Arg, momenta_Arg> GraphOperation for LoadTPUEmbeddingMomentumParameters<parameters_Arg, momenta_Arg>
where parameters_Arg: Clone,
      parameters_Arg: GraphEdge<f32>,
      parameters_Arg: 'static,
      momenta_Arg: Clone,
      momenta_Arg: GraphEdge<f32>,
      momenta_Arg: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("LoadTPUEmbeddingMomentumParameters_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("LoadTPUEmbeddingMomentumParameters", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.parameters)?
        }
        {
            new_op.add_edge(&self.momenta)?
        }
        {
            match self.table_id {
                None => new_op.set_attr_value_proto("table_id", &vec![24_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 1_u8,])?,
                Some(ref value) => (|attr: &i64| {new_op.set_attr_int("table_id", *attr)})(&value)?,
            };
        }
        {
            match self.table_name {
                None => new_op.set_attr_value_proto("table_name", &vec![18_u8, 0_u8,])?,
                Some(ref value) => (|attr| {new_op.set_attr_string("table_name", attr)})(&value)?,
            };
        }
        {
            (|attr: &i64| {new_op.set_attr_int("num_shards", *attr)})(&self.num_shards)?
        }
        {
            (|attr: &i64| {new_op.set_attr_int("shard_id", *attr)})(&self.shard_id)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct LoadTPUEmbeddingMomentumParameters<parameters_Arg, momenta_Arg>
where parameters_Arg: Clone,
      parameters_Arg: GraphEdge<f32>,
      parameters_Arg: 'static,
      momenta_Arg: Clone,
      momenta_Arg: GraphEdge<f32>,
      momenta_Arg: 'static,
{
    parameters: parameters_Arg,
    momenta: momenta_Arg,
    table_id: Option<i64>,
    table_name: Option<String>,
    num_shards: i64,
    shard_id: i64,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<parameters_Arg, momenta_Arg> LoadTPUEmbeddingMomentumParameters<parameters_Arg, momenta_Arg>
where parameters_Arg: Clone,
      parameters_Arg: GraphEdge<f32>,
      parameters_Arg: 'static,
      momenta_Arg: Clone,
      momenta_Arg: GraphEdge<f32>,
      momenta_Arg: 'static,
{
    pub fn table_id(&mut self, table_id: i64) -> Self {
        self.table_id = Some(table_id);
        self.clone()
    }

    pub fn table_name(&mut self, table_name: &str) -> Self {
        self.table_name = Some(table_name.to_string());
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> () {
        let rc = Rc::new(self);
        (
        )
    }

    pub fn build(parameters: parameters_Arg, momenta: momenta_Arg, num_shards: i64, shard_id: i64) -> Self {
        Self {
            parameters,
            momenta,
            table_id: None,
            table_name: None,
            num_shards: num_shards,
            shard_id: shard_id,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(parameters: parameters_Arg, momenta: momenta_Arg, num_shards: i64, shard_id: i64) -> () {
        Self {
            parameters,
            momenta,
            table_id: None,
            table_name: None,
            num_shards: num_shards,
            shard_id: shard_id,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<float_values_Arg, bucket_boundaries_Arg> GraphOperation for BoostedTreesBucketize<float_values_Arg, bucket_boundaries_Arg>
where float_values_Arg: Clone,
      float_values_Arg: GraphEdge<f32>,
      float_values_Arg: 'static,
      bucket_boundaries_Arg: Clone,
      bucket_boundaries_Arg: GraphEdge<f32>,
      bucket_boundaries_Arg: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("BoostedTreesBucketize_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("BoostedTreesBucketize", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.float_values)?
        }
        {
            new_op.add_edge(&self.bucket_boundaries)?
        }
        {
            (|attr: &i64| {new_op.set_attr_int("num_features", *attr)})(&self.num_features)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct BoostedTreesBucketize<float_values_Arg, bucket_boundaries_Arg>
where float_values_Arg: Clone,
      float_values_Arg: GraphEdge<f32>,
      float_values_Arg: 'static,
      bucket_boundaries_Arg: Clone,
      bucket_boundaries_Arg: GraphEdge<f32>,
      bucket_boundaries_Arg: 'static,
{
    float_values: float_values_Arg,
    bucket_boundaries: bucket_boundaries_Arg,
    num_features: i64,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<float_values_Arg, bucket_boundaries_Arg> BoostedTreesBucketize<float_values_Arg, bucket_boundaries_Arg>
where float_values_Arg: Clone,
      float_values_Arg: GraphEdge<f32>,
      float_values_Arg: 'static,
      bucket_boundaries_Arg: Clone,
      bucket_boundaries_Arg: GraphEdge<f32>,
      bucket_boundaries_Arg: 'static,
{
    pub fn buckets(self) -> Edge<i32> {
        let rc = Rc::new(self);
        {
            Edge::<i32>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<i32> {
        let rc = Rc::new(self);
        {
            Edge::<i32>::new(rc.clone(), 0)
        }
    }

    pub fn build(float_values: float_values_Arg, bucket_boundaries: bucket_boundaries_Arg, num_features: i64) -> Self {
        Self {
            float_values,
            bucket_boundaries,
            num_features: num_features,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(float_values: float_values_Arg, bucket_boundaries: bucket_boundaries_Arg, num_features: i64) -> Edge<i32> {
        Self {
            float_values,
            bucket_boundaries,
            num_features: num_features,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<T, ref__Arg, Tindices, indices_Arg, updates_Arg> GraphOperation for ScatterNdAdd<T, ref__Arg, Tindices, indices_Arg, updates_Arg>
where T: TensorType,
      T: Clone,
      ref__Arg: Clone,
      ref__Arg: GraphRefEdge<T>,
      ref__Arg: 'static,
      Tindices: TensorType,
      Tindices: Clone,
      indices_Arg: Clone,
      indices_Arg: GraphEdge<Tindices>,
      indices_Arg: 'static,
      updates_Arg: Clone,
      updates_Arg: GraphEdge<T>,
      updates_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
      Tindices: con_or_DT_INT32_or_DT_INT64,
      Tindices: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("ScatterNdAdd_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("ScatterNdAdd", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.ref_)?
        }
        {
            new_op.add_edge(&self.indices)?
        }
        {
            new_op.add_edge(&self.updates)?
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        {
            new_op.set_attr_type("Tindices", Tindices::data_type())?;
        }
        {
            match self.use_locking {
                None => new_op.set_attr_value_proto("use_locking", &vec![40_u8, 0_u8,])?,
                Some(ref value) => (|attr: &bool| {new_op.set_attr_bool("use_locking", *attr)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct ScatterNdAdd<T, ref__Arg, Tindices, indices_Arg, updates_Arg>
where T: TensorType,
      T: Clone,
      ref__Arg: Clone,
      ref__Arg: GraphRefEdge<T>,
      ref__Arg: 'static,
      Tindices: TensorType,
      Tindices: Clone,
      indices_Arg: Clone,
      indices_Arg: GraphEdge<Tindices>,
      indices_Arg: 'static,
      updates_Arg: Clone,
      updates_Arg: GraphEdge<T>,
      updates_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
      Tindices: con_or_DT_INT32_or_DT_INT64,
      Tindices: 'static,
{
    phantom_T: PhantomData<T>,
    ref_: ref__Arg,
    phantom_Tindices: PhantomData<Tindices>,
    indices: indices_Arg,
    updates: updates_Arg,
    use_locking: Option<bool>,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<T, ref__Arg, Tindices, indices_Arg, updates_Arg> ScatterNdAdd<T, ref__Arg, Tindices, indices_Arg, updates_Arg>
where T: TensorType,
      T: Clone,
      ref__Arg: Clone,
      ref__Arg: GraphRefEdge<T>,
      ref__Arg: 'static,
      Tindices: TensorType,
      Tindices: Clone,
      indices_Arg: Clone,
      indices_Arg: GraphEdge<Tindices>,
      indices_Arg: 'static,
      updates_Arg: Clone,
      updates_Arg: GraphEdge<T>,
      updates_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
      Tindices: con_or_DT_INT32_or_DT_INT64,
      Tindices: 'static,
{
    pub fn output_ref(self) -> RefEdge<T> {
        let rc = Rc::new(self);
        {
            RefEdge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn use_locking(&mut self, use_locking: bool) -> Self {
        self.use_locking = Some(use_locking);
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> RefEdge<T> {
        let rc = Rc::new(self);
        {
            RefEdge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(ref_: ref__Arg, indices: indices_Arg, updates: updates_Arg) -> Self {
        Self {
            phantom_T: PhantomData,
            ref_,
            phantom_Tindices: PhantomData,
            indices,
            updates,
            use_locking: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(ref_: ref__Arg, indices: indices_Arg, updates: updates_Arg) -> RefEdge<T> {
        Self {
            phantom_T: PhantomData,
            ref_,
            phantom_Tindices: PhantomData,
            indices,
            updates,
            use_locking: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<T, ref__Arg, Tindices, indices_Arg, updates_Arg> GraphOperation for ScatterDiv<T, ref__Arg, Tindices, indices_Arg, updates_Arg>
where T: TensorType,
      T: Clone,
      ref__Arg: Clone,
      ref__Arg: GraphRefEdge<T>,
      ref__Arg: 'static,
      Tindices: TensorType,
      Tindices: Clone,
      indices_Arg: Clone,
      indices_Arg: GraphEdge<Tindices>,
      indices_Arg: 'static,
      updates_Arg: Clone,
      updates_Arg: GraphEdge<T>,
      updates_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
      Tindices: con_or_DT_INT32_or_DT_INT64,
      Tindices: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("ScatterDiv_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("ScatterDiv", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.ref_)?
        }
        {
            new_op.add_edge(&self.indices)?
        }
        {
            new_op.add_edge(&self.updates)?
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        {
            new_op.set_attr_type("Tindices", Tindices::data_type())?;
        }
        {
            match self.use_locking {
                None => new_op.set_attr_value_proto("use_locking", &vec![40_u8, 0_u8,])?,
                Some(ref value) => (|attr: &bool| {new_op.set_attr_bool("use_locking", *attr)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct ScatterDiv<T, ref__Arg, Tindices, indices_Arg, updates_Arg>
where T: TensorType,
      T: Clone,
      ref__Arg: Clone,
      ref__Arg: GraphRefEdge<T>,
      ref__Arg: 'static,
      Tindices: TensorType,
      Tindices: Clone,
      indices_Arg: Clone,
      indices_Arg: GraphEdge<Tindices>,
      indices_Arg: 'static,
      updates_Arg: Clone,
      updates_Arg: GraphEdge<T>,
      updates_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
      Tindices: con_or_DT_INT32_or_DT_INT64,
      Tindices: 'static,
{
    phantom_T: PhantomData<T>,
    ref_: ref__Arg,
    phantom_Tindices: PhantomData<Tindices>,
    indices: indices_Arg,
    updates: updates_Arg,
    use_locking: Option<bool>,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<T, ref__Arg, Tindices, indices_Arg, updates_Arg> ScatterDiv<T, ref__Arg, Tindices, indices_Arg, updates_Arg>
where T: TensorType,
      T: Clone,
      ref__Arg: Clone,
      ref__Arg: GraphRefEdge<T>,
      ref__Arg: 'static,
      Tindices: TensorType,
      Tindices: Clone,
      indices_Arg: Clone,
      indices_Arg: GraphEdge<Tindices>,
      indices_Arg: 'static,
      updates_Arg: Clone,
      updates_Arg: GraphEdge<T>,
      updates_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
      Tindices: con_or_DT_INT32_or_DT_INT64,
      Tindices: 'static,
{
    pub fn output_ref(self) -> RefEdge<T> {
        let rc = Rc::new(self);
        {
            RefEdge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn use_locking(&mut self, use_locking: bool) -> Self {
        self.use_locking = Some(use_locking);
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> RefEdge<T> {
        let rc = Rc::new(self);
        {
            RefEdge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(ref_: ref__Arg, indices: indices_Arg, updates: updates_Arg) -> Self {
        Self {
            phantom_T: PhantomData,
            ref_,
            phantom_Tindices: PhantomData,
            indices,
            updates,
            use_locking: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(ref_: ref__Arg, indices: indices_Arg, updates: updates_Arg) -> RefEdge<T> {
        Self {
            phantom_T: PhantomData,
            ref_,
            phantom_Tindices: PhantomData,
            indices,
            updates,
            use_locking: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<T, x_Arg> GraphOperation for Atan<T, x_Arg>
where T: TensorType,
      T: Clone,
      x_Arg: Clone,
      x_Arg: GraphEdge<T>,
      x_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_COMPLEX64_or_DT_INT64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF,
      T: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("Atan_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("Atan", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.x)?
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct Atan<T, x_Arg>
where T: TensorType,
      T: Clone,
      x_Arg: Clone,
      x_Arg: GraphEdge<T>,
      x_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_COMPLEX64_or_DT_INT64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    x: x_Arg,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<T, x_Arg> Atan<T, x_Arg>
where T: TensorType,
      T: Clone,
      x_Arg: Clone,
      x_Arg: GraphEdge<T>,
      x_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_COMPLEX64_or_DT_INT64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF,
      T: 'static,
{
    pub fn y(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(x: x_Arg) -> Self {
        Self {
            phantom_T: PhantomData,
            x,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(x: x_Arg) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            x,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<audio_Arg, sample_rate_Arg> GraphOperation for EncodeWav<audio_Arg, sample_rate_Arg>
where audio_Arg: Clone,
      audio_Arg: GraphEdge<f32>,
      audio_Arg: 'static,
      sample_rate_Arg: Clone,
      sample_rate_Arg: GraphEdge<i32>,
      sample_rate_Arg: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("EncodeWav_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("EncodeWav", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.audio)?
        }
        {
            new_op.add_edge(&self.sample_rate)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct EncodeWav<audio_Arg, sample_rate_Arg>
where audio_Arg: Clone,
      audio_Arg: GraphEdge<f32>,
      audio_Arg: 'static,
      sample_rate_Arg: Clone,
      sample_rate_Arg: GraphEdge<i32>,
      sample_rate_Arg: 'static,
{
    audio: audio_Arg,
    sample_rate: sample_rate_Arg,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<audio_Arg, sample_rate_Arg> EncodeWav<audio_Arg, sample_rate_Arg>
where audio_Arg: Clone,
      audio_Arg: GraphEdge<f32>,
      audio_Arg: 'static,
      sample_rate_Arg: Clone,
      sample_rate_Arg: GraphEdge<i32>,
      sample_rate_Arg: 'static,
{
    pub fn contents(self) -> Edge<String> {
        let rc = Rc::new(self);
        {
            Edge::<String>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<String> {
        let rc = Rc::new(self);
        {
            Edge::<String>::new(rc.clone(), 0)
        }
    }

    pub fn build(audio: audio_Arg, sample_rate: sample_rate_Arg) -> Self {
        Self {
            audio,
            sample_rate,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(audio: audio_Arg, sample_rate: sample_rate_Arg) -> Edge<String> {
        Self {
            audio,
            sample_rate,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<T, input_Arg> GraphOperation for Squeeze<T, input_Arg>
where T: TensorType,
      T: Clone,
      input_Arg: Clone,
      input_Arg: GraphEdge<T>,
      input_Arg: 'static,
      T: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("Squeeze_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("Squeeze", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.input)?
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        {
            match self.squeeze_dims {
                None => new_op.set_attr_value_proto("squeeze_dims", &vec![10_u8, 0_u8,])?,
                Some(ref value) => (|attrs| {new_op.set_attr_int_list("squeeze_dims", attrs)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct Squeeze<T, input_Arg>
where T: TensorType,
      T: Clone,
      input_Arg: Clone,
      input_Arg: GraphEdge<T>,
      input_Arg: 'static,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    input: input_Arg,
    squeeze_dims: Option<Vec<i64>>,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<T, input_Arg> Squeeze<T, input_Arg>
where T: TensorType,
      T: Clone,
      input_Arg: Clone,
      input_Arg: GraphEdge<T>,
      input_Arg: 'static,
      T: 'static,
{
    pub fn output(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn squeeze_dims(&mut self, squeeze_dims: &[i64]) -> Self {
        self.squeeze_dims = Some(squeeze_dims.to_vec());
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(input: input_Arg) -> Self {
        Self {
            phantom_T: PhantomData,
            input,
            squeeze_dims: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(input: input_Arg) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            input,
            squeeze_dims: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<parameters_Arg, momenta_Arg, velocities_Arg> GraphOperation for LoadTPUEmbeddingADAMParameters<parameters_Arg, momenta_Arg, velocities_Arg>
where parameters_Arg: Clone,
      parameters_Arg: GraphEdge<f32>,
      parameters_Arg: 'static,
      momenta_Arg: Clone,
      momenta_Arg: GraphEdge<f32>,
      momenta_Arg: 'static,
      velocities_Arg: Clone,
      velocities_Arg: GraphEdge<f32>,
      velocities_Arg: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("LoadTPUEmbeddingADAMParameters_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("LoadTPUEmbeddingADAMParameters", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.parameters)?
        }
        {
            new_op.add_edge(&self.momenta)?
        }
        {
            new_op.add_edge(&self.velocities)?
        }
        {
            match self.table_id {
                None => new_op.set_attr_value_proto("table_id", &vec![24_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 1_u8,])?,
                Some(ref value) => (|attr: &i64| {new_op.set_attr_int("table_id", *attr)})(&value)?,
            };
        }
        {
            match self.table_name {
                None => new_op.set_attr_value_proto("table_name", &vec![18_u8, 0_u8,])?,
                Some(ref value) => (|attr| {new_op.set_attr_string("table_name", attr)})(&value)?,
            };
        }
        {
            (|attr: &i64| {new_op.set_attr_int("num_shards", *attr)})(&self.num_shards)?
        }
        {
            (|attr: &i64| {new_op.set_attr_int("shard_id", *attr)})(&self.shard_id)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct LoadTPUEmbeddingADAMParameters<parameters_Arg, momenta_Arg, velocities_Arg>
where parameters_Arg: Clone,
      parameters_Arg: GraphEdge<f32>,
      parameters_Arg: 'static,
      momenta_Arg: Clone,
      momenta_Arg: GraphEdge<f32>,
      momenta_Arg: 'static,
      velocities_Arg: Clone,
      velocities_Arg: GraphEdge<f32>,
      velocities_Arg: 'static,
{
    parameters: parameters_Arg,
    momenta: momenta_Arg,
    velocities: velocities_Arg,
    table_id: Option<i64>,
    table_name: Option<String>,
    num_shards: i64,
    shard_id: i64,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<parameters_Arg, momenta_Arg, velocities_Arg> LoadTPUEmbeddingADAMParameters<parameters_Arg, momenta_Arg, velocities_Arg>
where parameters_Arg: Clone,
      parameters_Arg: GraphEdge<f32>,
      parameters_Arg: 'static,
      momenta_Arg: Clone,
      momenta_Arg: GraphEdge<f32>,
      momenta_Arg: 'static,
      velocities_Arg: Clone,
      velocities_Arg: GraphEdge<f32>,
      velocities_Arg: 'static,
{
    pub fn table_id(&mut self, table_id: i64) -> Self {
        self.table_id = Some(table_id);
        self.clone()
    }

    pub fn table_name(&mut self, table_name: &str) -> Self {
        self.table_name = Some(table_name.to_string());
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> () {
        let rc = Rc::new(self);
        (
        )
    }

    pub fn build(parameters: parameters_Arg, momenta: momenta_Arg, velocities: velocities_Arg, num_shards: i64, shard_id: i64) -> Self {
        Self {
            parameters,
            momenta,
            velocities,
            table_id: None,
            table_name: None,
            num_shards: num_shards,
            shard_id: shard_id,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(parameters: parameters_Arg, momenta: momenta_Arg, velocities: velocities_Arg, num_shards: i64, shard_id: i64) -> () {
        Self {
            parameters,
            momenta,
            velocities,
            table_id: None,
            table_name: None,
            num_shards: num_shards,
            shard_id: shard_id,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<T, input_Arg> GraphOperation for NcclBroadcast<T, input_Arg>
where T: TensorType,
      T: Clone,
      input_Arg: Clone,
      input_Arg: GraphEdge<T>,
      input_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_INT64_or_DT_HALF,
      T: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("NcclBroadcast_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("NcclBroadcast", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.input)?
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        {
            (|attr| {new_op.set_attr_shape("shape", attr)})(&self.shape)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct NcclBroadcast<T, input_Arg>
where T: TensorType,
      T: Clone,
      input_Arg: Clone,
      input_Arg: GraphEdge<T>,
      input_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_INT64_or_DT_HALF,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    input: input_Arg,
    shape: OtherShape,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<T, input_Arg> NcclBroadcast<T, input_Arg>
where T: TensorType,
      T: Clone,
      input_Arg: Clone,
      input_Arg: GraphEdge<T>,
      input_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_INT64_or_DT_HALF,
      T: 'static,
{
    pub fn output(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(input: input_Arg, shape: &OtherShape) -> Self {
        Self {
            phantom_T: PhantomData,
            input,
            shape: shape.clone(),
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(input: input_Arg, shape: &OtherShape) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            input,
            shape: shape.clone(),
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<T, images_Arg, size_Arg> GraphOperation for ResizeArea<T, images_Arg, size_Arg>
where T: TensorType,
      T: Clone,
      images_Arg: Clone,
      images_Arg: GraphEdge<T>,
      images_Arg: 'static,
      size_Arg: Clone,
      size_Arg: GraphEdge<i32>,
      size_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_UINT16_or_DT_HALF,
      T: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("ResizeArea_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("ResizeArea", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.images)?
        }
        {
            new_op.add_edge(&self.size)?
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        {
            match self.align_corners {
                None => new_op.set_attr_value_proto("align_corners", &vec![40_u8, 0_u8,])?,
                Some(ref value) => (|attr: &bool| {new_op.set_attr_bool("align_corners", *attr)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct ResizeArea<T, images_Arg, size_Arg>
where T: TensorType,
      T: Clone,
      images_Arg: Clone,
      images_Arg: GraphEdge<T>,
      images_Arg: 'static,
      size_Arg: Clone,
      size_Arg: GraphEdge<i32>,
      size_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_UINT16_or_DT_HALF,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    images: images_Arg,
    size: size_Arg,
    align_corners: Option<bool>,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<T, images_Arg, size_Arg> ResizeArea<T, images_Arg, size_Arg>
where T: TensorType,
      T: Clone,
      images_Arg: Clone,
      images_Arg: GraphEdge<T>,
      images_Arg: 'static,
      size_Arg: Clone,
      size_Arg: GraphEdge<i32>,
      size_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_UINT16_or_DT_HALF,
      T: 'static,
{
    pub fn resized_images(self) -> Edge<f32> {
        let rc = Rc::new(self);
        {
            Edge::<f32>::new(rc.clone(), 0)
        }
    }

    pub fn align_corners(&mut self, align_corners: bool) -> Self {
        self.align_corners = Some(align_corners);
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<f32> {
        let rc = Rc::new(self);
        {
            Edge::<f32>::new(rc.clone(), 0)
        }
    }

    pub fn build(images: images_Arg, size: size_Arg) -> Self {
        Self {
            phantom_T: PhantomData,
            images,
            size,
            align_corners: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(images: images_Arg, size: size_Arg) -> Edge<f32> {
        Self {
            phantom_T: PhantomData,
            images,
            size,
            align_corners: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<w_in_Arg, w_out_Arg, examples_Arg, labels_Arg, lr_Arg> GraphOperation for NegTrain<w_in_Arg, w_out_Arg, examples_Arg, labels_Arg, lr_Arg>
where w_in_Arg: Clone,
      w_in_Arg: GraphRefEdge<f32>,
      w_in_Arg: 'static,
      w_out_Arg: Clone,
      w_out_Arg: GraphRefEdge<f32>,
      w_out_Arg: 'static,
      examples_Arg: Clone,
      examples_Arg: GraphEdge<i32>,
      examples_Arg: 'static,
      labels_Arg: Clone,
      labels_Arg: GraphEdge<i32>,
      labels_Arg: 'static,
      lr_Arg: Clone,
      lr_Arg: GraphEdge<f32>,
      lr_Arg: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("NegTrain_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("NegTrain", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.w_in)?
        }
        {
            new_op.add_edge(&self.w_out)?
        }
        {
            new_op.add_edge(&self.examples)?
        }
        {
            new_op.add_edge(&self.labels)?
        }
        {
            new_op.add_edge(&self.lr)?
        }
        {
            (|attrs| {new_op.set_attr_int_list("vocab_count", attrs)})(&self.vocab_count)?
        }
        {
            (|attr: &i64| {new_op.set_attr_int("num_negative_samples", *attr)})(&self.num_negative_samples)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct NegTrain<w_in_Arg, w_out_Arg, examples_Arg, labels_Arg, lr_Arg>
where w_in_Arg: Clone,
      w_in_Arg: GraphRefEdge<f32>,
      w_in_Arg: 'static,
      w_out_Arg: Clone,
      w_out_Arg: GraphRefEdge<f32>,
      w_out_Arg: 'static,
      examples_Arg: Clone,
      examples_Arg: GraphEdge<i32>,
      examples_Arg: 'static,
      labels_Arg: Clone,
      labels_Arg: GraphEdge<i32>,
      labels_Arg: 'static,
      lr_Arg: Clone,
      lr_Arg: GraphEdge<f32>,
      lr_Arg: 'static,
{
    w_in: w_in_Arg,
    w_out: w_out_Arg,
    examples: examples_Arg,
    labels: labels_Arg,
    lr: lr_Arg,
    vocab_count: Vec<i64>,
    num_negative_samples: i64,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<w_in_Arg, w_out_Arg, examples_Arg, labels_Arg, lr_Arg> NegTrain<w_in_Arg, w_out_Arg, examples_Arg, labels_Arg, lr_Arg>
where w_in_Arg: Clone,
      w_in_Arg: GraphRefEdge<f32>,
      w_in_Arg: 'static,
      w_out_Arg: Clone,
      w_out_Arg: GraphRefEdge<f32>,
      w_out_Arg: 'static,
      examples_Arg: Clone,
      examples_Arg: GraphEdge<i32>,
      examples_Arg: 'static,
      labels_Arg: Clone,
      labels_Arg: GraphEdge<i32>,
      labels_Arg: 'static,
      lr_Arg: Clone,
      lr_Arg: GraphEdge<f32>,
      lr_Arg: 'static,
{
    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> () {
        let rc = Rc::new(self);
        (
        )
    }

    pub fn build(w_in: w_in_Arg, w_out: w_out_Arg, examples: examples_Arg, labels: labels_Arg, lr: lr_Arg, vocab_count: &[i64], num_negative_samples: i64) -> Self {
        Self {
            w_in,
            w_out,
            examples,
            labels,
            lr,
            vocab_count: vocab_count.to_vec(),
            num_negative_samples: num_negative_samples,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(w_in: w_in_Arg, w_out: w_out_Arg, examples: examples_Arg, labels: labels_Arg, lr: lr_Arg, vocab_count: &[i64], num_negative_samples: i64) -> () {
        Self {
            w_in,
            w_out,
            examples,
            labels,
            lr,
            vocab_count: vocab_count.to_vec(),
            num_negative_samples: num_negative_samples,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<T, input_Arg, Tout> GraphOperation for Real<T, input_Arg, Tout>
where T: TensorType,
      T: Clone,
      input_Arg: Clone,
      input_Arg: GraphEdge<T>,
      input_Arg: 'static,
      Tout: TensorType,
      T: con_or_DT_COMPLEX64_or_DT_COMPLEX128,
      T: 'static,
      Tout: con_or_DT_FLOAT_or_DT_DOUBLE,
      Tout: 'static,
      Tout: Clone,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("Real_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("Real", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.input)?
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        {
            new_op.set_attr_type("Tout", Tout::data_type())?;
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct Real<T, input_Arg, Tout>
where T: TensorType,
      T: Clone,
      input_Arg: Clone,
      input_Arg: GraphEdge<T>,
      input_Arg: 'static,
      Tout: TensorType,
      T: con_or_DT_COMPLEX64_or_DT_COMPLEX128,
      T: 'static,
      Tout: con_or_DT_FLOAT_or_DT_DOUBLE,
      Tout: 'static,
      Tout: Clone,
{
    phantom_T: PhantomData<T>,
    input: input_Arg,
    phantom_Tout: PhantomData<Tout>,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<T, input_Arg, Tout> Real<T, input_Arg, Tout>
where T: TensorType,
      T: Clone,
      input_Arg: Clone,
      input_Arg: GraphEdge<T>,
      input_Arg: 'static,
      Tout: TensorType,
      T: con_or_DT_COMPLEX64_or_DT_COMPLEX128,
      T: 'static,
      Tout: con_or_DT_FLOAT_or_DT_DOUBLE,
      Tout: 'static,
      Tout: Clone,
{
    pub fn output(self) -> Edge<Tout> {
        let rc = Rc::new(self);
        {
            Edge::<Tout>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<Tout> {
        let rc = Rc::new(self);
        {
            Edge::<Tout>::new(rc.clone(), 0)
        }
    }

    pub fn build(input: input_Arg) -> Self {
        Self {
            phantom_T: PhantomData,
            input,
            phantom_Tout: PhantomData,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(input: input_Arg) -> Edge<Tout> {
        Self {
            phantom_T: PhantomData,
            input,
            phantom_Tout: PhantomData,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<T, x_Arg, y_Arg> GraphOperation for RealDiv<T, x_Arg, y_Arg>
where T: TensorType,
      T: Clone,
      x_Arg: Clone,
      x_Arg: GraphEdge<T>,
      x_Arg: 'static,
      y_Arg: Clone,
      y_Arg: GraphEdge<T>,
      y_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF,
      T: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("RealDiv_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("RealDiv", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.x)?
        }
        {
            new_op.add_edge(&self.y)?
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct RealDiv<T, x_Arg, y_Arg>
where T: TensorType,
      T: Clone,
      x_Arg: Clone,
      x_Arg: GraphEdge<T>,
      x_Arg: 'static,
      y_Arg: Clone,
      y_Arg: GraphEdge<T>,
      y_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    x: x_Arg,
    y: y_Arg,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<T, x_Arg, y_Arg> RealDiv<T, x_Arg, y_Arg>
where T: TensorType,
      T: Clone,
      x_Arg: Clone,
      x_Arg: GraphEdge<T>,
      x_Arg: 'static,
      y_Arg: Clone,
      y_Arg: GraphEdge<T>,
      y_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF,
      T: 'static,
{
    pub fn z(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(x: x_Arg, y: y_Arg) -> Self {
        Self {
            phantom_T: PhantomData,
            x,
            y,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(x: x_Arg, y: y_Arg) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            x,
            y,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<parameters_Arg, accumulators_Arg> GraphOperation for LoadTPUEmbeddingAdagradParameters<parameters_Arg, accumulators_Arg>
where parameters_Arg: Clone,
      parameters_Arg: GraphEdge<f32>,
      parameters_Arg: 'static,
      accumulators_Arg: Clone,
      accumulators_Arg: GraphEdge<f32>,
      accumulators_Arg: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("LoadTPUEmbeddingAdagradParameters_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("LoadTPUEmbeddingAdagradParameters", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.parameters)?
        }
        {
            new_op.add_edge(&self.accumulators)?
        }
        {
            match self.table_id {
                None => new_op.set_attr_value_proto("table_id", &vec![24_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 1_u8,])?,
                Some(ref value) => (|attr: &i64| {new_op.set_attr_int("table_id", *attr)})(&value)?,
            };
        }
        {
            match self.table_name {
                None => new_op.set_attr_value_proto("table_name", &vec![18_u8, 0_u8,])?,
                Some(ref value) => (|attr| {new_op.set_attr_string("table_name", attr)})(&value)?,
            };
        }
        {
            (|attr: &i64| {new_op.set_attr_int("num_shards", *attr)})(&self.num_shards)?
        }
        {
            (|attr: &i64| {new_op.set_attr_int("shard_id", *attr)})(&self.shard_id)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct LoadTPUEmbeddingAdagradParameters<parameters_Arg, accumulators_Arg>
where parameters_Arg: Clone,
      parameters_Arg: GraphEdge<f32>,
      parameters_Arg: 'static,
      accumulators_Arg: Clone,
      accumulators_Arg: GraphEdge<f32>,
      accumulators_Arg: 'static,
{
    parameters: parameters_Arg,
    accumulators: accumulators_Arg,
    table_id: Option<i64>,
    table_name: Option<String>,
    num_shards: i64,
    shard_id: i64,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<parameters_Arg, accumulators_Arg> LoadTPUEmbeddingAdagradParameters<parameters_Arg, accumulators_Arg>
where parameters_Arg: Clone,
      parameters_Arg: GraphEdge<f32>,
      parameters_Arg: 'static,
      accumulators_Arg: Clone,
      accumulators_Arg: GraphEdge<f32>,
      accumulators_Arg: 'static,
{
    pub fn table_id(&mut self, table_id: i64) -> Self {
        self.table_id = Some(table_id);
        self.clone()
    }

    pub fn table_name(&mut self, table_name: &str) -> Self {
        self.table_name = Some(table_name.to_string());
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> () {
        let rc = Rc::new(self);
        (
        )
    }

    pub fn build(parameters: parameters_Arg, accumulators: accumulators_Arg, num_shards: i64, shard_id: i64) -> Self {
        Self {
            parameters,
            accumulators,
            table_id: None,
            table_name: None,
            num_shards: num_shards,
            shard_id: shard_id,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(parameters: parameters_Arg, accumulators: accumulators_Arg, num_shards: i64, shard_id: i64) -> () {
        Self {
            parameters,
            accumulators,
            table_id: None,
            table_name: None,
            num_shards: num_shards,
            shard_id: shard_id,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<T, var_Arg, m_Arg, v_Arg, beta1_power_Arg, beta2_power_Arg, lr_Arg, beta1_Arg, beta2_Arg, epsilon_Arg, grad_Arg> GraphOperation for ApplyAdam<T, var_Arg, m_Arg, v_Arg, beta1_power_Arg, beta2_power_Arg, lr_Arg, beta1_Arg, beta2_Arg, epsilon_Arg, grad_Arg>
where T: TensorType,
      T: Clone,
      var_Arg: Clone,
      var_Arg: GraphRefEdge<T>,
      var_Arg: 'static,
      m_Arg: Clone,
      m_Arg: GraphRefEdge<T>,
      m_Arg: 'static,
      v_Arg: Clone,
      v_Arg: GraphRefEdge<T>,
      v_Arg: 'static,
      beta1_power_Arg: Clone,
      beta1_power_Arg: GraphEdge<T>,
      beta1_power_Arg: 'static,
      beta2_power_Arg: Clone,
      beta2_power_Arg: GraphEdge<T>,
      beta2_power_Arg: 'static,
      lr_Arg: Clone,
      lr_Arg: GraphEdge<T>,
      lr_Arg: 'static,
      beta1_Arg: Clone,
      beta1_Arg: GraphEdge<T>,
      beta1_Arg: 'static,
      beta2_Arg: Clone,
      beta2_Arg: GraphEdge<T>,
      beta2_Arg: 'static,
      epsilon_Arg: Clone,
      epsilon_Arg: GraphEdge<T>,
      epsilon_Arg: 'static,
      grad_Arg: Clone,
      grad_Arg: GraphEdge<T>,
      grad_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("ApplyAdam_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("ApplyAdam", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.var)?
        }
        {
            new_op.add_edge(&self.m)?
        }
        {
            new_op.add_edge(&self.v)?
        }
        {
            new_op.add_edge(&self.beta1_power)?
        }
        {
            new_op.add_edge(&self.beta2_power)?
        }
        {
            new_op.add_edge(&self.lr)?
        }
        {
            new_op.add_edge(&self.beta1)?
        }
        {
            new_op.add_edge(&self.beta2)?
        }
        {
            new_op.add_edge(&self.epsilon)?
        }
        {
            new_op.add_edge(&self.grad)?
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        {
            match self.use_locking {
                None => new_op.set_attr_value_proto("use_locking", &vec![40_u8, 0_u8,])?,
                Some(ref value) => (|attr: &bool| {new_op.set_attr_bool("use_locking", *attr)})(&value)?,
            };
        }
        {
            match self.use_nesterov {
                None => new_op.set_attr_value_proto("use_nesterov", &vec![40_u8, 0_u8,])?,
                Some(ref value) => (|attr: &bool| {new_op.set_attr_bool("use_nesterov", *attr)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct ApplyAdam<T, var_Arg, m_Arg, v_Arg, beta1_power_Arg, beta2_power_Arg, lr_Arg, beta1_Arg, beta2_Arg, epsilon_Arg, grad_Arg>
where T: TensorType,
      T: Clone,
      var_Arg: Clone,
      var_Arg: GraphRefEdge<T>,
      var_Arg: 'static,
      m_Arg: Clone,
      m_Arg: GraphRefEdge<T>,
      m_Arg: 'static,
      v_Arg: Clone,
      v_Arg: GraphRefEdge<T>,
      v_Arg: 'static,
      beta1_power_Arg: Clone,
      beta1_power_Arg: GraphEdge<T>,
      beta1_power_Arg: 'static,
      beta2_power_Arg: Clone,
      beta2_power_Arg: GraphEdge<T>,
      beta2_power_Arg: 'static,
      lr_Arg: Clone,
      lr_Arg: GraphEdge<T>,
      lr_Arg: 'static,
      beta1_Arg: Clone,
      beta1_Arg: GraphEdge<T>,
      beta1_Arg: 'static,
      beta2_Arg: Clone,
      beta2_Arg: GraphEdge<T>,
      beta2_Arg: 'static,
      epsilon_Arg: Clone,
      epsilon_Arg: GraphEdge<T>,
      epsilon_Arg: 'static,
      grad_Arg: Clone,
      grad_Arg: GraphEdge<T>,
      grad_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    var: var_Arg,
    m: m_Arg,
    v: v_Arg,
    beta1_power: beta1_power_Arg,
    beta2_power: beta2_power_Arg,
    lr: lr_Arg,
    beta1: beta1_Arg,
    beta2: beta2_Arg,
    epsilon: epsilon_Arg,
    grad: grad_Arg,
    use_locking: Option<bool>,
    use_nesterov: Option<bool>,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<T, var_Arg, m_Arg, v_Arg, beta1_power_Arg, beta2_power_Arg, lr_Arg, beta1_Arg, beta2_Arg, epsilon_Arg, grad_Arg> ApplyAdam<T, var_Arg, m_Arg, v_Arg, beta1_power_Arg, beta2_power_Arg, lr_Arg, beta1_Arg, beta2_Arg, epsilon_Arg, grad_Arg>
where T: TensorType,
      T: Clone,
      var_Arg: Clone,
      var_Arg: GraphRefEdge<T>,
      var_Arg: 'static,
      m_Arg: Clone,
      m_Arg: GraphRefEdge<T>,
      m_Arg: 'static,
      v_Arg: Clone,
      v_Arg: GraphRefEdge<T>,
      v_Arg: 'static,
      beta1_power_Arg: Clone,
      beta1_power_Arg: GraphEdge<T>,
      beta1_power_Arg: 'static,
      beta2_power_Arg: Clone,
      beta2_power_Arg: GraphEdge<T>,
      beta2_power_Arg: 'static,
      lr_Arg: Clone,
      lr_Arg: GraphEdge<T>,
      lr_Arg: 'static,
      beta1_Arg: Clone,
      beta1_Arg: GraphEdge<T>,
      beta1_Arg: 'static,
      beta2_Arg: Clone,
      beta2_Arg: GraphEdge<T>,
      beta2_Arg: 'static,
      epsilon_Arg: Clone,
      epsilon_Arg: GraphEdge<T>,
      epsilon_Arg: 'static,
      grad_Arg: Clone,
      grad_Arg: GraphEdge<T>,
      grad_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
{
    pub fn out(self) -> RefEdge<T> {
        let rc = Rc::new(self);
        {
            RefEdge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn use_locking(&mut self, use_locking: bool) -> Self {
        self.use_locking = Some(use_locking);
        self.clone()
    }

    pub fn use_nesterov(&mut self, use_nesterov: bool) -> Self {
        self.use_nesterov = Some(use_nesterov);
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> RefEdge<T> {
        let rc = Rc::new(self);
        {
            RefEdge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(var: var_Arg, m: m_Arg, v: v_Arg, beta1_power: beta1_power_Arg, beta2_power: beta2_power_Arg, lr: lr_Arg, beta1: beta1_Arg, beta2: beta2_Arg, epsilon: epsilon_Arg, grad: grad_Arg) -> Self {
        Self {
            phantom_T: PhantomData,
            var,
            m,
            v,
            beta1_power,
            beta2_power,
            lr,
            beta1,
            beta2,
            epsilon,
            grad,
            use_locking: None,
            use_nesterov: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(var: var_Arg, m: m_Arg, v: v_Arg, beta1_power: beta1_power_Arg, beta2_power: beta2_power_Arg, lr: lr_Arg, beta1: beta1_Arg, beta2: beta2_Arg, epsilon: epsilon_Arg, grad: grad_Arg) -> RefEdge<T> {
        Self {
            phantom_T: PhantomData,
            var,
            m,
            v,
            beta1_power,
            beta2_power,
            lr,
            beta1,
            beta2,
            epsilon,
            grad,
            use_locking: None,
            use_nesterov: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<dtype> GraphOperation for TemporaryVariable<dtype>
where dtype: TensorType,
      dtype: 'static,
      dtype: Clone,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("TemporaryVariable_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("TemporaryVariable", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            (|attr| {new_op.set_attr_shape("shape", attr)})(&self.shape)?
        }
        {
            new_op.set_attr_type("dtype", dtype::data_type())?;
        }
        {
            match self.var_name {
                None => new_op.set_attr_value_proto("var_name", &vec![18_u8, 0_u8,])?,
                Some(ref value) => (|attr| {new_op.set_attr_string("var_name", attr)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct TemporaryVariable<dtype>
where dtype: TensorType,
      dtype: 'static,
      dtype: Clone,
{
    shape: OtherShape,
    phantom_dtype: PhantomData<dtype>,
    var_name: Option<String>,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<dtype> TemporaryVariable<dtype>
where dtype: TensorType,
      dtype: 'static,
      dtype: Clone,
{
    pub fn ref_(self) -> RefEdge<dtype> {
        let rc = Rc::new(self);
        {
            RefEdge::<dtype>::new(rc.clone(), 0)
        }
    }

    pub fn var_name(&mut self, var_name: &str) -> Self {
        self.var_name = Some(var_name.to_string());
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> RefEdge<dtype> {
        let rc = Rc::new(self);
        {
            RefEdge::<dtype>::new(rc.clone(), 0)
        }
    }

    pub fn build(shape: &OtherShape) -> Self {
        Self {
            shape: shape.clone(),
            phantom_dtype: PhantomData,
            var_name: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(shape: &OtherShape) -> RefEdge<dtype> {
        Self {
            shape: shape.clone(),
            phantom_dtype: PhantomData,
            var_name: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<T, x_Arg, q_Arg> GraphOperation for Zeta<T, x_Arg, q_Arg>
where T: TensorType,
      T: Clone,
      x_Arg: Clone,
      x_Arg: GraphEdge<T>,
      x_Arg: 'static,
      q_Arg: Clone,
      q_Arg: GraphEdge<T>,
      q_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE,
      T: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("Zeta_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("Zeta", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.x)?
        }
        {
            new_op.add_edge(&self.q)?
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct Zeta<T, x_Arg, q_Arg>
where T: TensorType,
      T: Clone,
      x_Arg: Clone,
      x_Arg: GraphEdge<T>,
      x_Arg: 'static,
      q_Arg: Clone,
      q_Arg: GraphEdge<T>,
      q_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    x: x_Arg,
    q: q_Arg,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<T, x_Arg, q_Arg> Zeta<T, x_Arg, q_Arg>
where T: TensorType,
      T: Clone,
      x_Arg: Clone,
      x_Arg: GraphEdge<T>,
      x_Arg: 'static,
      q_Arg: Clone,
      q_Arg: GraphEdge<T>,
      q_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE,
      T: 'static,
{
    pub fn z(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(x: x_Arg, q: q_Arg) -> Self {
        Self {
            phantom_T: PhantomData,
            x,
            q,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(x: x_Arg, q: q_Arg) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            x,
            q,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<T, y_Arg, dy_Arg> GraphOperation for ReciprocalGrad<T, y_Arg, dy_Arg>
where T: TensorType,
      T: Clone,
      y_Arg: Clone,
      y_Arg: GraphEdge<T>,
      y_Arg: 'static,
      dy_Arg: Clone,
      dy_Arg: GraphEdge<T>,
      dy_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_COMPLEX64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF,
      T: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("ReciprocalGrad_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("ReciprocalGrad", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.y)?
        }
        {
            new_op.add_edge(&self.dy)?
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct ReciprocalGrad<T, y_Arg, dy_Arg>
where T: TensorType,
      T: Clone,
      y_Arg: Clone,
      y_Arg: GraphEdge<T>,
      y_Arg: 'static,
      dy_Arg: Clone,
      dy_Arg: GraphEdge<T>,
      dy_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_COMPLEX64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    y: y_Arg,
    dy: dy_Arg,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<T, y_Arg, dy_Arg> ReciprocalGrad<T, y_Arg, dy_Arg>
where T: TensorType,
      T: Clone,
      y_Arg: Clone,
      y_Arg: GraphEdge<T>,
      y_Arg: 'static,
      dy_Arg: Clone,
      dy_Arg: GraphEdge<T>,
      dy_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_COMPLEX64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF,
      T: 'static,
{
    pub fn z(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(y: y_Arg, dy: dy_Arg) -> Self {
        Self {
            phantom_T: PhantomData,
            y,
            dy,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(y: y_Arg, dy: dy_Arg) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            y,
            dy,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<inputs_Arg, learning_rates_Arg> GraphOperation for SendTPUEmbeddingGradients<inputs_Arg, learning_rates_Arg>
where inputs_Arg: Clone,
      inputs_Arg: GraphEdge<f32>,
      inputs_Arg: 'static,
      learning_rates_Arg: Clone,
      learning_rates_Arg: GraphEdge<f32>,
      learning_rates_Arg: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("SendTPUEmbeddingGradients_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("SendTPUEmbeddingGradients", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.inputs)?
        }
        {
            new_op.add_edge(&self.learning_rates)?
        }
        {
            (|attr: &i64| {new_op.set_attr_int("N", *attr)})(&self.N)?
        }
        {
            match self.NN {
                None => new_op.set_attr_value_proto("NN", &vec![24_u8, 0_u8,])?,
                Some(ref value) => (|attr: &i64| {new_op.set_attr_int("NN", *attr)})(&value)?,
            };
        }
        {
            (|attr| {new_op.set_attr_string("config", attr)})(&self.config)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct SendTPUEmbeddingGradients<inputs_Arg, learning_rates_Arg>
where inputs_Arg: Clone,
      inputs_Arg: GraphEdge<f32>,
      inputs_Arg: 'static,
      learning_rates_Arg: Clone,
      learning_rates_Arg: GraphEdge<f32>,
      learning_rates_Arg: 'static,
{
    inputs: inputs_Arg,
    learning_rates: learning_rates_Arg,
    N: i64,
    NN: Option<i64>,
    config: String,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<inputs_Arg, learning_rates_Arg> SendTPUEmbeddingGradients<inputs_Arg, learning_rates_Arg>
where inputs_Arg: Clone,
      inputs_Arg: GraphEdge<f32>,
      inputs_Arg: 'static,
      learning_rates_Arg: Clone,
      learning_rates_Arg: GraphEdge<f32>,
      learning_rates_Arg: 'static,
{
    pub fn NN(&mut self, NN: i64) -> Self {
        self.NN = Some(NN);
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> () {
        let rc = Rc::new(self);
        (
        )
    }

    pub fn build(inputs: inputs_Arg, learning_rates: learning_rates_Arg, N: i64, config: &str) -> Self {
        Self {
            inputs,
            learning_rates,
            N: N,
            NN: None,
            config: config.to_string(),
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(inputs: inputs_Arg, learning_rates: learning_rates_Arg, N: i64, config: &str) -> () {
        Self {
            inputs,
            learning_rates,
            N: N,
            NN: None,
            config: config.to_string(),
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<T, input_Arg, padding_value_Arg, Tindices, padding_low_Arg, padding_high_Arg, padding_interior_Arg> GraphOperation for XlaPad<T, input_Arg, padding_value_Arg, Tindices, padding_low_Arg, padding_high_Arg, padding_interior_Arg>
where T: TensorType,
      T: Clone,
      input_Arg: Clone,
      input_Arg: GraphEdge<T>,
      input_Arg: 'static,
      padding_value_Arg: Clone,
      padding_value_Arg: GraphEdge<T>,
      padding_value_Arg: 'static,
      Tindices: TensorType,
      Tindices: Clone,
      padding_low_Arg: Clone,
      padding_low_Arg: GraphEdge<Tindices>,
      padding_low_Arg: 'static,
      padding_high_Arg: Clone,
      padding_high_Arg: GraphEdge<Tindices>,
      padding_high_Arg: 'static,
      padding_interior_Arg: Clone,
      padding_interior_Arg: GraphEdge<Tindices>,
      padding_interior_Arg: 'static,
      T: 'static,
      Tindices: con_or_DT_INT32_or_DT_INT64,
      Tindices: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("XlaPad_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("XlaPad", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.input)?
        }
        {
            new_op.add_edge(&self.padding_value)?
        }
        {
            new_op.add_edge(&self.padding_low)?
        }
        {
            new_op.add_edge(&self.padding_high)?
        }
        {
            new_op.add_edge(&self.padding_interior)?
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        {
            new_op.set_attr_type("Tindices", Tindices::data_type())?;
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct XlaPad<T, input_Arg, padding_value_Arg, Tindices, padding_low_Arg, padding_high_Arg, padding_interior_Arg>
where T: TensorType,
      T: Clone,
      input_Arg: Clone,
      input_Arg: GraphEdge<T>,
      input_Arg: 'static,
      padding_value_Arg: Clone,
      padding_value_Arg: GraphEdge<T>,
      padding_value_Arg: 'static,
      Tindices: TensorType,
      Tindices: Clone,
      padding_low_Arg: Clone,
      padding_low_Arg: GraphEdge<Tindices>,
      padding_low_Arg: 'static,
      padding_high_Arg: Clone,
      padding_high_Arg: GraphEdge<Tindices>,
      padding_high_Arg: 'static,
      padding_interior_Arg: Clone,
      padding_interior_Arg: GraphEdge<Tindices>,
      padding_interior_Arg: 'static,
      T: 'static,
      Tindices: con_or_DT_INT32_or_DT_INT64,
      Tindices: 'static,
{
    phantom_T: PhantomData<T>,
    input: input_Arg,
    padding_value: padding_value_Arg,
    phantom_Tindices: PhantomData<Tindices>,
    padding_low: padding_low_Arg,
    padding_high: padding_high_Arg,
    padding_interior: padding_interior_Arg,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<T, input_Arg, padding_value_Arg, Tindices, padding_low_Arg, padding_high_Arg, padding_interior_Arg> XlaPad<T, input_Arg, padding_value_Arg, Tindices, padding_low_Arg, padding_high_Arg, padding_interior_Arg>
where T: TensorType,
      T: Clone,
      input_Arg: Clone,
      input_Arg: GraphEdge<T>,
      input_Arg: 'static,
      padding_value_Arg: Clone,
      padding_value_Arg: GraphEdge<T>,
      padding_value_Arg: 'static,
      Tindices: TensorType,
      Tindices: Clone,
      padding_low_Arg: Clone,
      padding_low_Arg: GraphEdge<Tindices>,
      padding_low_Arg: 'static,
      padding_high_Arg: Clone,
      padding_high_Arg: GraphEdge<Tindices>,
      padding_high_Arg: 'static,
      padding_interior_Arg: Clone,
      padding_interior_Arg: GraphEdge<Tindices>,
      padding_interior_Arg: 'static,
      T: 'static,
      Tindices: con_or_DT_INT32_or_DT_INT64,
      Tindices: 'static,
{
    pub fn output(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(input: input_Arg, padding_value: padding_value_Arg, padding_low: padding_low_Arg, padding_high: padding_high_Arg, padding_interior: padding_interior_Arg) -> Self {
        Self {
            phantom_T: PhantomData,
            input,
            padding_value,
            phantom_Tindices: PhantomData,
            padding_low,
            padding_high,
            padding_interior,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(input: input_Arg, padding_value: padding_value_Arg, padding_low: padding_low_Arg, padding_high: padding_high_Arg, padding_interior: padding_interior_Arg) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            input,
            padding_value,
            phantom_Tindices: PhantomData,
            padding_low,
            padding_high,
            padding_interior,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<T, x_Arg> GraphOperation for Neg<T, x_Arg>
where T: TensorType,
      T: Clone,
      x_Arg: Clone,
      x_Arg: GraphEdge<T>,
      x_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_COMPLEX64_or_DT_INT64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF,
      T: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("Neg_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("Neg", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.x)?
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct Neg<T, x_Arg>
where T: TensorType,
      T: Clone,
      x_Arg: Clone,
      x_Arg: GraphEdge<T>,
      x_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_COMPLEX64_or_DT_INT64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    x: x_Arg,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<T, x_Arg> Neg<T, x_Arg>
where T: TensorType,
      T: Clone,
      x_Arg: Clone,
      x_Arg: GraphEdge<T>,
      x_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_COMPLEX64_or_DT_INT64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF,
      T: 'static,
{
    pub fn y(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(x: x_Arg) -> Self {
        Self {
            phantom_T: PhantomData,
            x,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(x: x_Arg) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            x,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<T, input_Arg, input_h_Arg, input_c_Arg, params_Arg, output_Arg, output_h_Arg, output_c_Arg, output_backprop_Arg, output_h_backprop_Arg, output_c_backprop_Arg, reserve_space_Arg, host_reserved_Arg> GraphOperation for CudnnRNNBackpropV2<T, input_Arg, input_h_Arg, input_c_Arg, params_Arg, output_Arg, output_h_Arg, output_c_Arg, output_backprop_Arg, output_h_backprop_Arg, output_c_backprop_Arg, reserve_space_Arg, host_reserved_Arg>
where T: TensorType,
      T: Clone,
      input_Arg: Clone,
      input_Arg: GraphEdge<T>,
      input_Arg: 'static,
      input_h_Arg: Clone,
      input_h_Arg: GraphEdge<T>,
      input_h_Arg: 'static,
      input_c_Arg: Clone,
      input_c_Arg: GraphEdge<T>,
      input_c_Arg: 'static,
      params_Arg: Clone,
      params_Arg: GraphEdge<T>,
      params_Arg: 'static,
      output_Arg: Clone,
      output_Arg: GraphEdge<T>,
      output_Arg: 'static,
      output_h_Arg: Clone,
      output_h_Arg: GraphEdge<T>,
      output_h_Arg: 'static,
      output_c_Arg: Clone,
      output_c_Arg: GraphEdge<T>,
      output_c_Arg: 'static,
      output_backprop_Arg: Clone,
      output_backprop_Arg: GraphEdge<T>,
      output_backprop_Arg: 'static,
      output_h_backprop_Arg: Clone,
      output_h_backprop_Arg: GraphEdge<T>,
      output_h_backprop_Arg: 'static,
      output_c_backprop_Arg: Clone,
      output_c_backprop_Arg: GraphEdge<T>,
      output_c_backprop_Arg: 'static,
      reserve_space_Arg: Clone,
      reserve_space_Arg: GraphEdge<T>,
      reserve_space_Arg: 'static,
      host_reserved_Arg: Clone,
      host_reserved_Arg: GraphEdge<i8>,
      host_reserved_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_HALF,
      T: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("CudnnRNNBackpropV2_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("CudnnRNNBackpropV2", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.input)?
        }
        {
            new_op.add_edge(&self.input_h)?
        }
        {
            new_op.add_edge(&self.input_c)?
        }
        {
            new_op.add_edge(&self.params)?
        }
        {
            new_op.add_edge(&self.output)?
        }
        {
            new_op.add_edge(&self.output_h)?
        }
        {
            new_op.add_edge(&self.output_c)?
        }
        {
            new_op.add_edge(&self.output_backprop)?
        }
        {
            new_op.add_edge(&self.output_h_backprop)?
        }
        {
            new_op.add_edge(&self.output_c_backprop)?
        }
        {
            new_op.add_edge(&self.reserve_space)?
        }
        {
            new_op.add_edge(&self.host_reserved)?
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        {
            match self.rnn_mode {
                None => new_op.set_attr_value_proto("rnn_mode", &vec![18_u8, 4_u8, 108_u8, 115_u8, 116_u8, 109_u8,])?,
                Some(ref value) => (|attr| {new_op.set_attr_string("rnn_mode", attr)})(&value)?,
            };
        }
        {
            match self.input_mode {
                None => new_op.set_attr_value_proto("input_mode", &vec![18_u8, 12_u8, 108_u8, 105_u8, 110_u8, 101_u8, 97_u8, 114_u8, 95_u8, 105_u8, 110_u8, 112_u8, 117_u8, 116_u8,])?,
                Some(ref value) => (|attr| {new_op.set_attr_string("input_mode", attr)})(&value)?,
            };
        }
        {
            match self.direction {
                None => new_op.set_attr_value_proto("direction", &vec![18_u8, 14_u8, 117_u8, 110_u8, 105_u8, 100_u8, 105_u8, 114_u8, 101_u8, 99_u8, 116_u8, 105_u8, 111_u8, 110_u8, 97_u8, 108_u8,])?,
                Some(ref value) => (|attr| {new_op.set_attr_string("direction", attr)})(&value)?,
            };
        }
        {
            match self.dropout {
                None => new_op.set_attr_value_proto("dropout", &vec![37_u8, 0_u8, 0_u8, 0_u8, 0_u8,])?,
                Some(ref value) => (|attr: &f32| {new_op.set_attr_float("dropout", *attr)})(&value)?,
            };
        }
        {
            match self.seed {
                None => new_op.set_attr_value_proto("seed", &vec![24_u8, 0_u8,])?,
                Some(ref value) => (|attr: &i64| {new_op.set_attr_int("seed", *attr)})(&value)?,
            };
        }
        {
            match self.seed2 {
                None => new_op.set_attr_value_proto("seed2", &vec![24_u8, 0_u8,])?,
                Some(ref value) => (|attr: &i64| {new_op.set_attr_int("seed2", *attr)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct CudnnRNNBackpropV2<T, input_Arg, input_h_Arg, input_c_Arg, params_Arg, output_Arg, output_h_Arg, output_c_Arg, output_backprop_Arg, output_h_backprop_Arg, output_c_backprop_Arg, reserve_space_Arg, host_reserved_Arg>
where T: TensorType,
      T: Clone,
      input_Arg: Clone,
      input_Arg: GraphEdge<T>,
      input_Arg: 'static,
      input_h_Arg: Clone,
      input_h_Arg: GraphEdge<T>,
      input_h_Arg: 'static,
      input_c_Arg: Clone,
      input_c_Arg: GraphEdge<T>,
      input_c_Arg: 'static,
      params_Arg: Clone,
      params_Arg: GraphEdge<T>,
      params_Arg: 'static,
      output_Arg: Clone,
      output_Arg: GraphEdge<T>,
      output_Arg: 'static,
      output_h_Arg: Clone,
      output_h_Arg: GraphEdge<T>,
      output_h_Arg: 'static,
      output_c_Arg: Clone,
      output_c_Arg: GraphEdge<T>,
      output_c_Arg: 'static,
      output_backprop_Arg: Clone,
      output_backprop_Arg: GraphEdge<T>,
      output_backprop_Arg: 'static,
      output_h_backprop_Arg: Clone,
      output_h_backprop_Arg: GraphEdge<T>,
      output_h_backprop_Arg: 'static,
      output_c_backprop_Arg: Clone,
      output_c_backprop_Arg: GraphEdge<T>,
      output_c_backprop_Arg: 'static,
      reserve_space_Arg: Clone,
      reserve_space_Arg: GraphEdge<T>,
      reserve_space_Arg: 'static,
      host_reserved_Arg: Clone,
      host_reserved_Arg: GraphEdge<i8>,
      host_reserved_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_HALF,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    input: input_Arg,
    input_h: input_h_Arg,
    input_c: input_c_Arg,
    params: params_Arg,
    output: output_Arg,
    output_h: output_h_Arg,
    output_c: output_c_Arg,
    output_backprop: output_backprop_Arg,
    output_h_backprop: output_h_backprop_Arg,
    output_c_backprop: output_c_backprop_Arg,
    reserve_space: reserve_space_Arg,
    host_reserved: host_reserved_Arg,
    rnn_mode: Option<String>,
    input_mode: Option<String>,
    direction: Option<String>,
    dropout: Option<f32>,
    seed: Option<i64>,
    seed2: Option<i64>,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<T, input_Arg, input_h_Arg, input_c_Arg, params_Arg, output_Arg, output_h_Arg, output_c_Arg, output_backprop_Arg, output_h_backprop_Arg, output_c_backprop_Arg, reserve_space_Arg, host_reserved_Arg> CudnnRNNBackpropV2<T, input_Arg, input_h_Arg, input_c_Arg, params_Arg, output_Arg, output_h_Arg, output_c_Arg, output_backprop_Arg, output_h_backprop_Arg, output_c_backprop_Arg, reserve_space_Arg, host_reserved_Arg>
where T: TensorType,
      T: Clone,
      input_Arg: Clone,
      input_Arg: GraphEdge<T>,
      input_Arg: 'static,
      input_h_Arg: Clone,
      input_h_Arg: GraphEdge<T>,
      input_h_Arg: 'static,
      input_c_Arg: Clone,
      input_c_Arg: GraphEdge<T>,
      input_c_Arg: 'static,
      params_Arg: Clone,
      params_Arg: GraphEdge<T>,
      params_Arg: 'static,
      output_Arg: Clone,
      output_Arg: GraphEdge<T>,
      output_Arg: 'static,
      output_h_Arg: Clone,
      output_h_Arg: GraphEdge<T>,
      output_h_Arg: 'static,
      output_c_Arg: Clone,
      output_c_Arg: GraphEdge<T>,
      output_c_Arg: 'static,
      output_backprop_Arg: Clone,
      output_backprop_Arg: GraphEdge<T>,
      output_backprop_Arg: 'static,
      output_h_backprop_Arg: Clone,
      output_h_backprop_Arg: GraphEdge<T>,
      output_h_backprop_Arg: 'static,
      output_c_backprop_Arg: Clone,
      output_c_backprop_Arg: GraphEdge<T>,
      output_c_backprop_Arg: 'static,
      reserve_space_Arg: Clone,
      reserve_space_Arg: GraphEdge<T>,
      reserve_space_Arg: 'static,
      host_reserved_Arg: Clone,
      host_reserved_Arg: GraphEdge<i8>,
      host_reserved_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_HALF,
      T: 'static,
{
    pub fn input_backprop(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn input_h_backprop(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 1)
        }
    }

    pub fn input_c_backprop(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 2)
        }
    }

    pub fn params_backprop(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 3)
        }
    }

    pub fn rnn_mode(&mut self, rnn_mode: &str) -> Self {
        self.rnn_mode = Some(rnn_mode.to_string());
        self.clone()
    }

    pub fn input_mode(&mut self, input_mode: &str) -> Self {
        self.input_mode = Some(input_mode.to_string());
        self.clone()
    }

    pub fn direction(&mut self, direction: &str) -> Self {
        self.direction = Some(direction.to_string());
        self.clone()
    }

    pub fn dropout(&mut self, dropout: f32) -> Self {
        self.dropout = Some(dropout);
        self.clone()
    }

    pub fn seed(&mut self, seed: i64) -> Self {
        self.seed = Some(seed);
        self.clone()
    }

    pub fn seed2(&mut self, seed2: i64) -> Self {
        self.seed2 = Some(seed2);
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> (Edge<T>, Edge<T>, Edge<T>, Edge<T>) {
        let rc = Rc::new(self);
        (
        {
            Edge::<T>::new(rc.clone(), 0)
        },
        {
            Edge::<T>::new(rc.clone(), 1)
        },
        {
            Edge::<T>::new(rc.clone(), 2)
        },
        {
            Edge::<T>::new(rc.clone(), 3)
        },
        )
    }

    pub fn build(input: input_Arg, input_h: input_h_Arg, input_c: input_c_Arg, params: params_Arg, output: output_Arg, output_h: output_h_Arg, output_c: output_c_Arg, output_backprop: output_backprop_Arg, output_h_backprop: output_h_backprop_Arg, output_c_backprop: output_c_backprop_Arg, reserve_space: reserve_space_Arg, host_reserved: host_reserved_Arg) -> Self {
        Self {
            phantom_T: PhantomData,
            input,
            input_h,
            input_c,
            params,
            output,
            output_h,
            output_c,
            output_backprop,
            output_h_backprop,
            output_c_backprop,
            reserve_space,
            host_reserved,
            rnn_mode: None,
            input_mode: None,
            direction: None,
            dropout: None,
            seed: None,
            seed2: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(input: input_Arg, input_h: input_h_Arg, input_c: input_c_Arg, params: params_Arg, output: output_Arg, output_h: output_h_Arg, output_c: output_c_Arg, output_backprop: output_backprop_Arg, output_h_backprop: output_h_backprop_Arg, output_c_backprop: output_c_backprop_Arg, reserve_space: reserve_space_Arg, host_reserved: host_reserved_Arg) -> (Edge<T>, Edge<T>, Edge<T>, Edge<T>) {
        Self {
            phantom_T: PhantomData,
            input,
            input_h,
            input_c,
            params,
            output,
            output_h,
            output_c,
            output_backprop,
            output_h_backprop,
            output_c_backprop,
            reserve_space,
            host_reserved,
            rnn_mode: None,
            input_mode: None,
            direction: None,
            dropout: None,
            seed: None,
            seed2: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<T, input_Arg> GraphOperation for EnsureShape<T, input_Arg>
where T: TensorType,
      T: Clone,
      input_Arg: Clone,
      input_Arg: GraphEdge<T>,
      input_Arg: 'static,
      T: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("EnsureShape_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("EnsureShape", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.input)?
        }
        {
            (|attr| {new_op.set_attr_shape("shape", attr)})(&self.shape)?
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct EnsureShape<T, input_Arg>
where T: TensorType,
      T: Clone,
      input_Arg: Clone,
      input_Arg: GraphEdge<T>,
      input_Arg: 'static,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    input: input_Arg,
    shape: OtherShape,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<T, input_Arg> EnsureShape<T, input_Arg>
where T: TensorType,
      T: Clone,
      input_Arg: Clone,
      input_Arg: GraphEdge<T>,
      input_Arg: 'static,
      T: 'static,
{
    pub fn output(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(input: input_Arg, shape: &OtherShape) -> Self {
        Self {
            phantom_T: PhantomData,
            input,
            shape: shape.clone(),
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(input: input_Arg, shape: &OtherShape) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            input,
            shape: shape.clone(),
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<table_handle_Arg, Tin, keys_Arg, Tout, default_value_Arg> GraphOperation for LookupTableFind<table_handle_Arg, Tin, keys_Arg, Tout, default_value_Arg>
where table_handle_Arg: Clone,
      table_handle_Arg: GraphRefEdge<String>,
      table_handle_Arg: 'static,
      Tin: TensorType,
      Tin: Clone,
      keys_Arg: Clone,
      keys_Arg: GraphEdge<Tin>,
      keys_Arg: 'static,
      Tout: TensorType,
      Tout: Clone,
      default_value_Arg: Clone,
      default_value_Arg: GraphEdge<Tout>,
      default_value_Arg: 'static,
      Tin: 'static,
      Tout: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("LookupTableFind_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("LookupTableFind", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.table_handle)?
        }
        {
            new_op.add_edge(&self.keys)?
        }
        {
            new_op.add_edge(&self.default_value)?
        }
        {
            new_op.set_attr_type("Tin", Tin::data_type())?;
        }
        {
            new_op.set_attr_type("Tout", Tout::data_type())?;
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct LookupTableFind<table_handle_Arg, Tin, keys_Arg, Tout, default_value_Arg>
where table_handle_Arg: Clone,
      table_handle_Arg: GraphRefEdge<String>,
      table_handle_Arg: 'static,
      Tin: TensorType,
      Tin: Clone,
      keys_Arg: Clone,
      keys_Arg: GraphEdge<Tin>,
      keys_Arg: 'static,
      Tout: TensorType,
      Tout: Clone,
      default_value_Arg: Clone,
      default_value_Arg: GraphEdge<Tout>,
      default_value_Arg: 'static,
      Tin: 'static,
      Tout: 'static,
{
    table_handle: table_handle_Arg,
    phantom_Tin: PhantomData<Tin>,
    keys: keys_Arg,
    phantom_Tout: PhantomData<Tout>,
    default_value: default_value_Arg,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<table_handle_Arg, Tin, keys_Arg, Tout, default_value_Arg> LookupTableFind<table_handle_Arg, Tin, keys_Arg, Tout, default_value_Arg>
where table_handle_Arg: Clone,
      table_handle_Arg: GraphRefEdge<String>,
      table_handle_Arg: 'static,
      Tin: TensorType,
      Tin: Clone,
      keys_Arg: Clone,
      keys_Arg: GraphEdge<Tin>,
      keys_Arg: 'static,
      Tout: TensorType,
      Tout: Clone,
      default_value_Arg: Clone,
      default_value_Arg: GraphEdge<Tout>,
      default_value_Arg: 'static,
      Tin: 'static,
      Tout: 'static,
{
    pub fn values(self) -> Edge<Tout> {
        let rc = Rc::new(self);
        {
            Edge::<Tout>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<Tout> {
        let rc = Rc::new(self);
        {
            Edge::<Tout>::new(rc.clone(), 0)
        }
    }

    pub fn build(table_handle: table_handle_Arg, keys: keys_Arg, default_value: default_value_Arg) -> Self {
        Self {
            table_handle,
            phantom_Tin: PhantomData,
            keys,
            phantom_Tout: PhantomData,
            default_value,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(table_handle: table_handle_Arg, keys: keys_Arg, default_value: default_value_Arg) -> Edge<Tout> {
        Self {
            table_handle,
            phantom_Tin: PhantomData,
            keys,
            phantom_Tout: PhantomData,
            default_value,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<dtype> GraphOperation for SparseConditionalAccumulator<dtype>
where dtype: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      dtype: TensorType,
      dtype: 'static,
      dtype: Clone,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("SparseConditionalAccumulator_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("SparseConditionalAccumulator", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.set_attr_type("dtype", dtype::data_type())?;
        }
        {
            (|attr| {new_op.set_attr_shape("shape", attr)})(&self.shape)?
        }
        {
            match self.container {
                None => new_op.set_attr_value_proto("container", &vec![18_u8, 0_u8,])?,
                Some(ref value) => (|attr| {new_op.set_attr_string("container", attr)})(&value)?,
            };
        }
        {
            match self.shared_name {
                None => new_op.set_attr_value_proto("shared_name", &vec![18_u8, 0_u8,])?,
                Some(ref value) => (|attr| {new_op.set_attr_string("shared_name", attr)})(&value)?,
            };
        }
        {
            match self.reduction_type {
                None => new_op.set_attr_value_proto("reduction_type", &vec![18_u8, 4_u8, 77_u8, 69_u8, 65_u8, 78_u8,])?,
                Some(ref value) => (|attr| {new_op.set_attr_string("reduction_type", attr)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct SparseConditionalAccumulator<dtype>
where dtype: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      dtype: TensorType,
      dtype: 'static,
      dtype: Clone,
{
    phantom_dtype: PhantomData<dtype>,
    shape: OtherShape,
    container: Option<String>,
    shared_name: Option<String>,
    reduction_type: Option<String>,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<dtype> SparseConditionalAccumulator<dtype>
where dtype: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      dtype: TensorType,
      dtype: 'static,
      dtype: Clone,
{
    pub fn handle(self) -> RefEdge<String> {
        let rc = Rc::new(self);
        {
            RefEdge::<String>::new(rc.clone(), 0)
        }
    }

    pub fn container(&mut self, container: &str) -> Self {
        self.container = Some(container.to_string());
        self.clone()
    }

    pub fn shared_name(&mut self, shared_name: &str) -> Self {
        self.shared_name = Some(shared_name.to_string());
        self.clone()
    }

    pub fn reduction_type(&mut self, reduction_type: &str) -> Self {
        self.reduction_type = Some(reduction_type.to_string());
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> RefEdge<String> {
        let rc = Rc::new(self);
        {
            RefEdge::<String>::new(rc.clone(), 0)
        }
    }

    pub fn build(shape: &OtherShape) -> Self {
        Self {
            phantom_dtype: PhantomData,
            shape: shape.clone(),
            container: None,
            shared_name: None,
            reduction_type: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(shape: &OtherShape) -> RefEdge<String> {
        Self {
            phantom_dtype: PhantomData,
            shape: shape.clone(),
            container: None,
            shared_name: None,
            reduction_type: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<spectrogram_Arg, sample_rate_Arg> GraphOperation for Mfcc<spectrogram_Arg, sample_rate_Arg>
where spectrogram_Arg: Clone,
      spectrogram_Arg: GraphEdge<f32>,
      spectrogram_Arg: 'static,
      sample_rate_Arg: Clone,
      sample_rate_Arg: GraphEdge<i32>,
      sample_rate_Arg: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("Mfcc_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("Mfcc", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.spectrogram)?
        }
        {
            new_op.add_edge(&self.sample_rate)?
        }
        {
            match self.upper_frequency_limit {
                None => new_op.set_attr_value_proto("upper_frequency_limit", &vec![37_u8, 0_u8, 0_u8, 122_u8, 69_u8,])?,
                Some(ref value) => (|attr: &f32| {new_op.set_attr_float("upper_frequency_limit", *attr)})(&value)?,
            };
        }
        {
            match self.lower_frequency_limit {
                None => new_op.set_attr_value_proto("lower_frequency_limit", &vec![37_u8, 0_u8, 0_u8, 160_u8, 65_u8,])?,
                Some(ref value) => (|attr: &f32| {new_op.set_attr_float("lower_frequency_limit", *attr)})(&value)?,
            };
        }
        {
            match self.filterbank_channel_count {
                None => new_op.set_attr_value_proto("filterbank_channel_count", &vec![24_u8, 40_u8,])?,
                Some(ref value) => (|attr: &i64| {new_op.set_attr_int("filterbank_channel_count", *attr)})(&value)?,
            };
        }
        {
            match self.dct_coefficient_count {
                None => new_op.set_attr_value_proto("dct_coefficient_count", &vec![24_u8, 13_u8,])?,
                Some(ref value) => (|attr: &i64| {new_op.set_attr_int("dct_coefficient_count", *attr)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct Mfcc<spectrogram_Arg, sample_rate_Arg>
where spectrogram_Arg: Clone,
      spectrogram_Arg: GraphEdge<f32>,
      spectrogram_Arg: 'static,
      sample_rate_Arg: Clone,
      sample_rate_Arg: GraphEdge<i32>,
      sample_rate_Arg: 'static,
{
    spectrogram: spectrogram_Arg,
    sample_rate: sample_rate_Arg,
    upper_frequency_limit: Option<f32>,
    lower_frequency_limit: Option<f32>,
    filterbank_channel_count: Option<i64>,
    dct_coefficient_count: Option<i64>,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<spectrogram_Arg, sample_rate_Arg> Mfcc<spectrogram_Arg, sample_rate_Arg>
where spectrogram_Arg: Clone,
      spectrogram_Arg: GraphEdge<f32>,
      spectrogram_Arg: 'static,
      sample_rate_Arg: Clone,
      sample_rate_Arg: GraphEdge<i32>,
      sample_rate_Arg: 'static,
{
    pub fn output(self) -> Edge<f32> {
        let rc = Rc::new(self);
        {
            Edge::<f32>::new(rc.clone(), 0)
        }
    }

    pub fn upper_frequency_limit(&mut self, upper_frequency_limit: f32) -> Self {
        self.upper_frequency_limit = Some(upper_frequency_limit);
        self.clone()
    }

    pub fn lower_frequency_limit(&mut self, lower_frequency_limit: f32) -> Self {
        self.lower_frequency_limit = Some(lower_frequency_limit);
        self.clone()
    }

    pub fn filterbank_channel_count(&mut self, filterbank_channel_count: i64) -> Self {
        self.filterbank_channel_count = Some(filterbank_channel_count);
        self.clone()
    }

    pub fn dct_coefficient_count(&mut self, dct_coefficient_count: i64) -> Self {
        self.dct_coefficient_count = Some(dct_coefficient_count);
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<f32> {
        let rc = Rc::new(self);
        {
            Edge::<f32>::new(rc.clone(), 0)
        }
    }

    pub fn build(spectrogram: spectrogram_Arg, sample_rate: sample_rate_Arg) -> Self {
        Self {
            spectrogram,
            sample_rate,
            upper_frequency_limit: None,
            lower_frequency_limit: None,
            filterbank_channel_count: None,
            dct_coefficient_count: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(spectrogram: spectrogram_Arg, sample_rate: sample_rate_Arg) -> Edge<f32> {
        Self {
            spectrogram,
            sample_rate,
            upper_frequency_limit: None,
            lower_frequency_limit: None,
            filterbank_channel_count: None,
            dct_coefficient_count: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<component_types> GraphOperation for PriorityQueue<component_types>
where component_types: TensorType,
      component_types: 'static,
      component_types: Clone,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("PriorityQueue_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("PriorityQueue", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.set_attr_type("component_types", component_types::data_type())?;
        }
        {
            (|attrs| {new_op.set_attr_shape_list("shapes", attrs)})(&self.shapes)?
        }
        {
            match self.capacity {
                None => new_op.set_attr_value_proto("capacity", &vec![24_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 1_u8,])?,
                Some(ref value) => (|attr: &i64| {new_op.set_attr_int("capacity", *attr)})(&value)?,
            };
        }
        {
            match self.container {
                None => new_op.set_attr_value_proto("container", &vec![18_u8, 0_u8,])?,
                Some(ref value) => (|attr| {new_op.set_attr_string("container", attr)})(&value)?,
            };
        }
        {
            match self.shared_name {
                None => new_op.set_attr_value_proto("shared_name", &vec![18_u8, 0_u8,])?,
                Some(ref value) => (|attr| {new_op.set_attr_string("shared_name", attr)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct PriorityQueue<component_types>
where component_types: TensorType,
      component_types: 'static,
      component_types: Clone,
{
    phantom_component_types: PhantomData<component_types>,
    shapes: Vec<OtherShape>,
    capacity: Option<i64>,
    container: Option<String>,
    shared_name: Option<String>,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<component_types> PriorityQueue<component_types>
where component_types: TensorType,
      component_types: 'static,
      component_types: Clone,
{
    pub fn handle(self) -> RefEdge<String> {
        let rc = Rc::new(self);
        {
            RefEdge::<String>::new(rc.clone(), 0)
        }
    }

    pub fn capacity(&mut self, capacity: i64) -> Self {
        self.capacity = Some(capacity);
        self.clone()
    }

    pub fn container(&mut self, container: &str) -> Self {
        self.container = Some(container.to_string());
        self.clone()
    }

    pub fn shared_name(&mut self, shared_name: &str) -> Self {
        self.shared_name = Some(shared_name.to_string());
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> RefEdge<String> {
        let rc = Rc::new(self);
        {
            RefEdge::<String>::new(rc.clone(), 0)
        }
    }

    pub fn build(shapes: &[OtherShape]) -> Self {
        Self {
            phantom_component_types: PhantomData,
            shapes: shapes.to_vec(),
            capacity: None,
            container: None,
            shared_name: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(shapes: &[OtherShape]) -> RefEdge<String> {
        Self {
            phantom_component_types: PhantomData,
            shapes: shapes.to_vec(),
            capacity: None,
            container: None,
            shared_name: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<T, x_Arg> GraphOperation for Reciprocal<T, x_Arg>
where T: TensorType,
      T: Clone,
      x_Arg: Clone,
      x_Arg: GraphEdge<T>,
      x_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_COMPLEX64_or_DT_INT64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF,
      T: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("Reciprocal_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("Reciprocal", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.x)?
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct Reciprocal<T, x_Arg>
where T: TensorType,
      T: Clone,
      x_Arg: Clone,
      x_Arg: GraphEdge<T>,
      x_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_COMPLEX64_or_DT_INT64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    x: x_Arg,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<T, x_Arg> Reciprocal<T, x_Arg>
where T: TensorType,
      T: Clone,
      x_Arg: Clone,
      x_Arg: GraphEdge<T>,
      x_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_COMPLEX64_or_DT_INT64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF,
      T: 'static,
{
    pub fn y(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(x: x_Arg) -> Self {
        Self {
            phantom_T: PhantomData,
            x,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(x: x_Arg) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            x,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<T, input_Arg, num_lower_Arg, num_upper_Arg> GraphOperation for BatchMatrixBandPart<T, input_Arg, num_lower_Arg, num_upper_Arg>
where T: TensorType,
      T: Clone,
      input_Arg: Clone,
      input_Arg: GraphEdge<T>,
      input_Arg: 'static,
      num_lower_Arg: Clone,
      num_lower_Arg: GraphEdge<i64>,
      num_lower_Arg: 'static,
      num_upper_Arg: Clone,
      num_upper_Arg: GraphEdge<i64>,
      num_upper_Arg: 'static,
      T: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("BatchMatrixBandPart_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("BatchMatrixBandPart", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.input)?
        }
        {
            new_op.add_edge(&self.num_lower)?
        }
        {
            new_op.add_edge(&self.num_upper)?
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct BatchMatrixBandPart<T, input_Arg, num_lower_Arg, num_upper_Arg>
where T: TensorType,
      T: Clone,
      input_Arg: Clone,
      input_Arg: GraphEdge<T>,
      input_Arg: 'static,
      num_lower_Arg: Clone,
      num_lower_Arg: GraphEdge<i64>,
      num_lower_Arg: 'static,
      num_upper_Arg: Clone,
      num_upper_Arg: GraphEdge<i64>,
      num_upper_Arg: 'static,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    input: input_Arg,
    num_lower: num_lower_Arg,
    num_upper: num_upper_Arg,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<T, input_Arg, num_lower_Arg, num_upper_Arg> BatchMatrixBandPart<T, input_Arg, num_lower_Arg, num_upper_Arg>
where T: TensorType,
      T: Clone,
      input_Arg: Clone,
      input_Arg: GraphEdge<T>,
      input_Arg: 'static,
      num_lower_Arg: Clone,
      num_lower_Arg: GraphEdge<i64>,
      num_lower_Arg: 'static,
      num_upper_Arg: Clone,
      num_upper_Arg: GraphEdge<i64>,
      num_upper_Arg: 'static,
      T: 'static,
{
    pub fn band(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(input: input_Arg, num_lower: num_lower_Arg, num_upper: num_upper_Arg) -> Self {
        Self {
            phantom_T: PhantomData,
            input,
            num_lower,
            num_upper,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(input: input_Arg, num_lower: num_lower_Arg, num_upper: num_upper_Arg) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            input,
            num_lower,
            num_upper,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<input_Arg> GraphOperation for _InitializeHostForDistributedTPU<input_Arg>
where input_Arg: Clone,
      input_Arg: GraphEdge<String>,
      input_Arg: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("_InitializeHostForDistributedTPU_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("_InitializeHostForDistributedTPU", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.input)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct _InitializeHostForDistributedTPU<input_Arg>
where input_Arg: Clone,
      input_Arg: GraphEdge<String>,
      input_Arg: 'static,
{
    input: input_Arg,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<input_Arg> _InitializeHostForDistributedTPU<input_Arg>
where input_Arg: Clone,
      input_Arg: GraphEdge<String>,
      input_Arg: 'static,
{
    pub fn tpu_ids(self) -> Edge<i32> {
        let rc = Rc::new(self);
        {
            Edge::<i32>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<i32> {
        let rc = Rc::new(self);
        {
            Edge::<i32>::new(rc.clone(), 0)
        }
    }

    pub fn build(input: input_Arg) -> Self {
        Self {
            input,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(input: input_Arg) -> Edge<i32> {
        Self {
            input,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<true_classes_Arg, sampled_candidates_Arg> GraphOperation for ComputeAccidentalHits<true_classes_Arg, sampled_candidates_Arg>
where true_classes_Arg: Clone,
      true_classes_Arg: GraphEdge<i64>,
      true_classes_Arg: 'static,
      sampled_candidates_Arg: Clone,
      sampled_candidates_Arg: GraphEdge<i64>,
      sampled_candidates_Arg: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("ComputeAccidentalHits_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("ComputeAccidentalHits", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.true_classes)?
        }
        {
            new_op.add_edge(&self.sampled_candidates)?
        }
        {
            (|attr: &i64| {new_op.set_attr_int("num_true", *attr)})(&self.num_true)?
        }
        {
            match self.seed {
                None => new_op.set_attr_value_proto("seed", &vec![24_u8, 0_u8,])?,
                Some(ref value) => (|attr: &i64| {new_op.set_attr_int("seed", *attr)})(&value)?,
            };
        }
        {
            match self.seed2 {
                None => new_op.set_attr_value_proto("seed2", &vec![24_u8, 0_u8,])?,
                Some(ref value) => (|attr: &i64| {new_op.set_attr_int("seed2", *attr)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct ComputeAccidentalHits<true_classes_Arg, sampled_candidates_Arg>
where true_classes_Arg: Clone,
      true_classes_Arg: GraphEdge<i64>,
      true_classes_Arg: 'static,
      sampled_candidates_Arg: Clone,
      sampled_candidates_Arg: GraphEdge<i64>,
      sampled_candidates_Arg: 'static,
{
    true_classes: true_classes_Arg,
    sampled_candidates: sampled_candidates_Arg,
    num_true: i64,
    seed: Option<i64>,
    seed2: Option<i64>,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<true_classes_Arg, sampled_candidates_Arg> ComputeAccidentalHits<true_classes_Arg, sampled_candidates_Arg>
where true_classes_Arg: Clone,
      true_classes_Arg: GraphEdge<i64>,
      true_classes_Arg: 'static,
      sampled_candidates_Arg: Clone,
      sampled_candidates_Arg: GraphEdge<i64>,
      sampled_candidates_Arg: 'static,
{
    pub fn indices(self) -> Edge<i32> {
        let rc = Rc::new(self);
        {
            Edge::<i32>::new(rc.clone(), 0)
        }
    }

    pub fn ids(self) -> Edge<i64> {
        let rc = Rc::new(self);
        {
            Edge::<i64>::new(rc.clone(), 1)
        }
    }

    pub fn weights(self) -> Edge<f32> {
        let rc = Rc::new(self);
        {
            Edge::<f32>::new(rc.clone(), 2)
        }
    }

    pub fn seed(&mut self, seed: i64) -> Self {
        self.seed = Some(seed);
        self.clone()
    }

    pub fn seed2(&mut self, seed2: i64) -> Self {
        self.seed2 = Some(seed2);
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> (Edge<i32>, Edge<i64>, Edge<f32>) {
        let rc = Rc::new(self);
        (
        {
            Edge::<i32>::new(rc.clone(), 0)
        },
        {
            Edge::<i64>::new(rc.clone(), 1)
        },
        {
            Edge::<f32>::new(rc.clone(), 2)
        },
        )
    }

    pub fn build(true_classes: true_classes_Arg, sampled_candidates: sampled_candidates_Arg, num_true: i64) -> Self {
        Self {
            true_classes,
            sampled_candidates,
            num_true: num_true,
            seed: None,
            seed2: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(true_classes: true_classes_Arg, sampled_candidates: sampled_candidates_Arg, num_true: i64) -> (Edge<i32>, Edge<i64>, Edge<f32>) {
        Self {
            true_classes,
            sampled_candidates,
            num_true: num_true,
            seed: None,
            seed2: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<T, lhs_Arg, rhs_Arg, Tindices, window_strides_Arg, padding_Arg, lhs_dilation_Arg, rhs_dilation_Arg, feature_group_count_Arg> GraphOperation for XlaConv<T, lhs_Arg, rhs_Arg, Tindices, window_strides_Arg, padding_Arg, lhs_dilation_Arg, rhs_dilation_Arg, feature_group_count_Arg>
where T: TensorType,
      T: Clone,
      lhs_Arg: Clone,
      lhs_Arg: GraphEdge<T>,
      lhs_Arg: 'static,
      rhs_Arg: Clone,
      rhs_Arg: GraphEdge<T>,
      rhs_Arg: 'static,
      Tindices: TensorType,
      Tindices: Clone,
      window_strides_Arg: Clone,
      window_strides_Arg: GraphEdge<Tindices>,
      window_strides_Arg: 'static,
      padding_Arg: Clone,
      padding_Arg: GraphEdge<Tindices>,
      padding_Arg: 'static,
      lhs_dilation_Arg: Clone,
      lhs_dilation_Arg: GraphEdge<Tindices>,
      lhs_dilation_Arg: 'static,
      rhs_dilation_Arg: Clone,
      rhs_dilation_Arg: GraphEdge<Tindices>,
      rhs_dilation_Arg: 'static,
      feature_group_count_Arg: Clone,
      feature_group_count_Arg: GraphEdge<Tindices>,
      feature_group_count_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
      Tindices: con_or_DT_INT32_or_DT_INT64,
      Tindices: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("XlaConv_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("XlaConv", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.lhs)?
        }
        {
            new_op.add_edge(&self.rhs)?
        }
        {
            new_op.add_edge(&self.window_strides)?
        }
        {
            new_op.add_edge(&self.padding)?
        }
        {
            new_op.add_edge(&self.lhs_dilation)?
        }
        {
            new_op.add_edge(&self.rhs_dilation)?
        }
        {
            new_op.add_edge(&self.feature_group_count)?
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        {
            new_op.set_attr_type("Tindices", Tindices::data_type())?;
        }
        {
            (|attr| {new_op.set_attr_string("dimension_numbers", attr)})(&self.dimension_numbers)?
        }
        {
            (|attr| {new_op.set_attr_string("precision_config", attr)})(&self.precision_config)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct XlaConv<T, lhs_Arg, rhs_Arg, Tindices, window_strides_Arg, padding_Arg, lhs_dilation_Arg, rhs_dilation_Arg, feature_group_count_Arg>
where T: TensorType,
      T: Clone,
      lhs_Arg: Clone,
      lhs_Arg: GraphEdge<T>,
      lhs_Arg: 'static,
      rhs_Arg: Clone,
      rhs_Arg: GraphEdge<T>,
      rhs_Arg: 'static,
      Tindices: TensorType,
      Tindices: Clone,
      window_strides_Arg: Clone,
      window_strides_Arg: GraphEdge<Tindices>,
      window_strides_Arg: 'static,
      padding_Arg: Clone,
      padding_Arg: GraphEdge<Tindices>,
      padding_Arg: 'static,
      lhs_dilation_Arg: Clone,
      lhs_dilation_Arg: GraphEdge<Tindices>,
      lhs_dilation_Arg: 'static,
      rhs_dilation_Arg: Clone,
      rhs_dilation_Arg: GraphEdge<Tindices>,
      rhs_dilation_Arg: 'static,
      feature_group_count_Arg: Clone,
      feature_group_count_Arg: GraphEdge<Tindices>,
      feature_group_count_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
      Tindices: con_or_DT_INT32_or_DT_INT64,
      Tindices: 'static,
{
    phantom_T: PhantomData<T>,
    lhs: lhs_Arg,
    rhs: rhs_Arg,
    phantom_Tindices: PhantomData<Tindices>,
    window_strides: window_strides_Arg,
    padding: padding_Arg,
    lhs_dilation: lhs_dilation_Arg,
    rhs_dilation: rhs_dilation_Arg,
    feature_group_count: feature_group_count_Arg,
    dimension_numbers: String,
    precision_config: String,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<T, lhs_Arg, rhs_Arg, Tindices, window_strides_Arg, padding_Arg, lhs_dilation_Arg, rhs_dilation_Arg, feature_group_count_Arg> XlaConv<T, lhs_Arg, rhs_Arg, Tindices, window_strides_Arg, padding_Arg, lhs_dilation_Arg, rhs_dilation_Arg, feature_group_count_Arg>
where T: TensorType,
      T: Clone,
      lhs_Arg: Clone,
      lhs_Arg: GraphEdge<T>,
      lhs_Arg: 'static,
      rhs_Arg: Clone,
      rhs_Arg: GraphEdge<T>,
      rhs_Arg: 'static,
      Tindices: TensorType,
      Tindices: Clone,
      window_strides_Arg: Clone,
      window_strides_Arg: GraphEdge<Tindices>,
      window_strides_Arg: 'static,
      padding_Arg: Clone,
      padding_Arg: GraphEdge<Tindices>,
      padding_Arg: 'static,
      lhs_dilation_Arg: Clone,
      lhs_dilation_Arg: GraphEdge<Tindices>,
      lhs_dilation_Arg: 'static,
      rhs_dilation_Arg: Clone,
      rhs_dilation_Arg: GraphEdge<Tindices>,
      rhs_dilation_Arg: 'static,
      feature_group_count_Arg: Clone,
      feature_group_count_Arg: GraphEdge<Tindices>,
      feature_group_count_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
      Tindices: con_or_DT_INT32_or_DT_INT64,
      Tindices: 'static,
{
    pub fn output(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(lhs: lhs_Arg, rhs: rhs_Arg, window_strides: window_strides_Arg, padding: padding_Arg, lhs_dilation: lhs_dilation_Arg, rhs_dilation: rhs_dilation_Arg, feature_group_count: feature_group_count_Arg, dimension_numbers: &str, precision_config: &str) -> Self {
        Self {
            phantom_T: PhantomData,
            lhs,
            rhs,
            phantom_Tindices: PhantomData,
            window_strides,
            padding,
            lhs_dilation,
            rhs_dilation,
            feature_group_count,
            dimension_numbers: dimension_numbers.to_string(),
            precision_config: precision_config.to_string(),
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(lhs: lhs_Arg, rhs: rhs_Arg, window_strides: window_strides_Arg, padding: padding_Arg, lhs_dilation: lhs_dilation_Arg, rhs_dilation: rhs_dilation_Arg, feature_group_count: feature_group_count_Arg, dimension_numbers: &str, precision_config: &str) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            lhs,
            rhs,
            phantom_Tindices: PhantomData,
            window_strides,
            padding,
            lhs_dilation,
            rhs_dilation,
            feature_group_count,
            dimension_numbers: dimension_numbers.to_string(),
            precision_config: precision_config.to_string(),
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl GraphOperation for RetrieveTPUEmbeddingMomentumParameters {
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("RetrieveTPUEmbeddingMomentumParameters_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("RetrieveTPUEmbeddingMomentumParameters", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            match self.table_id {
                None => new_op.set_attr_value_proto("table_id", &vec![24_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 1_u8,])?,
                Some(ref value) => (|attr: &i64| {new_op.set_attr_int("table_id", *attr)})(&value)?,
            };
        }
        {
            match self.table_name {
                None => new_op.set_attr_value_proto("table_name", &vec![18_u8, 0_u8,])?,
                Some(ref value) => (|attr| {new_op.set_attr_string("table_name", attr)})(&value)?,
            };
        }
        {
            (|attr: &i64| {new_op.set_attr_int("num_shards", *attr)})(&self.num_shards)?
        }
        {
            (|attr: &i64| {new_op.set_attr_int("shard_id", *attr)})(&self.shard_id)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct RetrieveTPUEmbeddingMomentumParameters {
    table_id: Option<i64>,
    table_name: Option<String>,
    num_shards: i64,
    shard_id: i64,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl RetrieveTPUEmbeddingMomentumParameters {
    pub fn parameters(self) -> Edge<f32> {
        let rc = Rc::new(self);
        {
            Edge::<f32>::new(rc.clone(), 0)
        }
    }

    pub fn momenta(self) -> Edge<f32> {
        let rc = Rc::new(self);
        {
            Edge::<f32>::new(rc.clone(), 1)
        }
    }

    pub fn table_id(&mut self, table_id: i64) -> Self {
        self.table_id = Some(table_id);
        self.clone()
    }

    pub fn table_name(&mut self, table_name: &str) -> Self {
        self.table_name = Some(table_name.to_string());
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> (Edge<f32>, Edge<f32>) {
        let rc = Rc::new(self);
        (
        {
            Edge::<f32>::new(rc.clone(), 0)
        },
        {
            Edge::<f32>::new(rc.clone(), 1)
        },
        )
    }

    pub fn build(num_shards: i64, shard_id: i64) -> Self {
        Self {
            table_id: None,
            table_name: None,
            num_shards: num_shards,
            shard_id: shard_id,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(num_shards: i64, shard_id: i64) -> (Edge<f32>, Edge<f32>) {
        Self {
            table_id: None,
            table_name: None,
            num_shards: num_shards,
            shard_id: shard_id,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<dtype> GraphOperation for PlaceholderV2<dtype>
where dtype: TensorType,
      dtype: 'static,
      dtype: Clone,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("PlaceholderV2_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("PlaceholderV2", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.set_attr_type("dtype", dtype::data_type())?;
        }
        {
            (|attr| {new_op.set_attr_shape("shape", attr)})(&self.shape)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct PlaceholderV2<dtype>
where dtype: TensorType,
      dtype: 'static,
      dtype: Clone,
{
    phantom_dtype: PhantomData<dtype>,
    shape: OtherShape,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<dtype> PlaceholderV2<dtype>
where dtype: TensorType,
      dtype: 'static,
      dtype: Clone,
{
    pub fn output(self) -> Edge<dtype> {
        let rc = Rc::new(self);
        {
            Edge::<dtype>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<dtype> {
        let rc = Rc::new(self);
        {
            Edge::<dtype>::new(rc.clone(), 0)
        }
    }

    pub fn build(shape: &OtherShape) -> Self {
        Self {
            phantom_dtype: PhantomData,
            shape: shape.clone(),
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(shape: &OtherShape) -> Edge<dtype> {
        Self {
            phantom_dtype: PhantomData,
            shape: shape.clone(),
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<T, diagonal_Arg> GraphOperation for BatchMatrixDiag<T, diagonal_Arg>
where T: TensorType,
      T: Clone,
      diagonal_Arg: Clone,
      diagonal_Arg: GraphEdge<T>,
      diagonal_Arg: 'static,
      T: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("BatchMatrixDiag_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("BatchMatrixDiag", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.diagonal)?
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct BatchMatrixDiag<T, diagonal_Arg>
where T: TensorType,
      T: Clone,
      diagonal_Arg: Clone,
      diagonal_Arg: GraphEdge<T>,
      diagonal_Arg: 'static,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    diagonal: diagonal_Arg,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<T, diagonal_Arg> BatchMatrixDiag<T, diagonal_Arg>
where T: TensorType,
      T: Clone,
      diagonal_Arg: Clone,
      diagonal_Arg: GraphEdge<T>,
      diagonal_Arg: 'static,
      T: 'static,
{
    pub fn output(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(diagonal: diagonal_Arg) -> Self {
        Self {
            phantom_T: PhantomData,
            diagonal,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(diagonal: diagonal_Arg) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            diagonal,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<gradients_Arg, inputs_Arg> GraphOperation for FakeQuantWithMinMaxArgsGradient<gradients_Arg, inputs_Arg>
where gradients_Arg: Clone,
      gradients_Arg: GraphEdge<f32>,
      gradients_Arg: 'static,
      inputs_Arg: Clone,
      inputs_Arg: GraphEdge<f32>,
      inputs_Arg: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("FakeQuantWithMinMaxArgsGradient_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("FakeQuantWithMinMaxArgsGradient", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.gradients)?
        }
        {
            new_op.add_edge(&self.inputs)?
        }
        {
            match self.min {
                None => new_op.set_attr_value_proto("min", &vec![37_u8, 0_u8, 0_u8, 192_u8, 192_u8,])?,
                Some(ref value) => (|attr: &f32| {new_op.set_attr_float("min", *attr)})(&value)?,
            };
        }
        {
            match self.max {
                None => new_op.set_attr_value_proto("max", &vec![37_u8, 0_u8, 0_u8, 192_u8, 64_u8,])?,
                Some(ref value) => (|attr: &f32| {new_op.set_attr_float("max", *attr)})(&value)?,
            };
        }
        {
            match self.num_bits {
                None => new_op.set_attr_value_proto("num_bits", &vec![24_u8, 8_u8,])?,
                Some(ref value) => (|attr: &i64| {new_op.set_attr_int("num_bits", *attr)})(&value)?,
            };
        }
        {
            match self.narrow_range {
                None => new_op.set_attr_value_proto("narrow_range", &vec![40_u8, 0_u8,])?,
                Some(ref value) => (|attr: &bool| {new_op.set_attr_bool("narrow_range", *attr)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct FakeQuantWithMinMaxArgsGradient<gradients_Arg, inputs_Arg>
where gradients_Arg: Clone,
      gradients_Arg: GraphEdge<f32>,
      gradients_Arg: 'static,
      inputs_Arg: Clone,
      inputs_Arg: GraphEdge<f32>,
      inputs_Arg: 'static,
{
    gradients: gradients_Arg,
    inputs: inputs_Arg,
    min: Option<f32>,
    max: Option<f32>,
    num_bits: Option<i64>,
    narrow_range: Option<bool>,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<gradients_Arg, inputs_Arg> FakeQuantWithMinMaxArgsGradient<gradients_Arg, inputs_Arg>
where gradients_Arg: Clone,
      gradients_Arg: GraphEdge<f32>,
      gradients_Arg: 'static,
      inputs_Arg: Clone,
      inputs_Arg: GraphEdge<f32>,
      inputs_Arg: 'static,
{
    pub fn backprops(self) -> Edge<f32> {
        let rc = Rc::new(self);
        {
            Edge::<f32>::new(rc.clone(), 0)
        }
    }

    pub fn min(&mut self, min: f32) -> Self {
        self.min = Some(min);
        self.clone()
    }

    pub fn max(&mut self, max: f32) -> Self {
        self.max = Some(max);
        self.clone()
    }

    pub fn num_bits(&mut self, num_bits: i64) -> Self {
        self.num_bits = Some(num_bits);
        self.clone()
    }

    pub fn narrow_range(&mut self, narrow_range: bool) -> Self {
        self.narrow_range = Some(narrow_range);
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<f32> {
        let rc = Rc::new(self);
        {
            Edge::<f32>::new(rc.clone(), 0)
        }
    }

    pub fn build(gradients: gradients_Arg, inputs: inputs_Arg) -> Self {
        Self {
            gradients,
            inputs,
            min: None,
            max: None,
            num_bits: None,
            narrow_range: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(gradients: gradients_Arg, inputs: inputs_Arg) -> Edge<f32> {
        Self {
            gradients,
            inputs,
            min: None,
            max: None,
            num_bits: None,
            narrow_range: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<T, x_Arg, i_Arg, v_Arg> GraphOperation for InplaceUpdate<T, x_Arg, i_Arg, v_Arg>
where T: TensorType,
      T: Clone,
      x_Arg: Clone,
      x_Arg: GraphEdge<T>,
      x_Arg: 'static,
      i_Arg: Clone,
      i_Arg: GraphEdge<i32>,
      i_Arg: 'static,
      v_Arg: Clone,
      v_Arg: GraphEdge<T>,
      v_Arg: 'static,
      T: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("InplaceUpdate_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("InplaceUpdate", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.x)?
        }
        {
            new_op.add_edge(&self.i)?
        }
        {
            new_op.add_edge(&self.v)?
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct InplaceUpdate<T, x_Arg, i_Arg, v_Arg>
where T: TensorType,
      T: Clone,
      x_Arg: Clone,
      x_Arg: GraphEdge<T>,
      x_Arg: 'static,
      i_Arg: Clone,
      i_Arg: GraphEdge<i32>,
      i_Arg: 'static,
      v_Arg: Clone,
      v_Arg: GraphEdge<T>,
      v_Arg: 'static,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    x: x_Arg,
    i: i_Arg,
    v: v_Arg,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<T, x_Arg, i_Arg, v_Arg> InplaceUpdate<T, x_Arg, i_Arg, v_Arg>
where T: TensorType,
      T: Clone,
      x_Arg: Clone,
      x_Arg: GraphEdge<T>,
      x_Arg: 'static,
      i_Arg: Clone,
      i_Arg: GraphEdge<i32>,
      i_Arg: 'static,
      v_Arg: Clone,
      v_Arg: GraphEdge<T>,
      v_Arg: 'static,
      T: 'static,
{
    pub fn y(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(x: x_Arg, i: i_Arg, v: v_Arg) -> Self {
        Self {
            phantom_T: PhantomData,
            x,
            i,
            v,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(x: x_Arg, i: i_Arg, v: v_Arg) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            x,
            i,
            v,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<T, x_Arg> GraphOperation for Sigmoid<T, x_Arg>
where T: TensorType,
      T: Clone,
      x_Arg: Clone,
      x_Arg: GraphEdge<T>,
      x_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_COMPLEX64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF,
      T: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("Sigmoid_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("Sigmoid", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.x)?
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct Sigmoid<T, x_Arg>
where T: TensorType,
      T: Clone,
      x_Arg: Clone,
      x_Arg: GraphEdge<T>,
      x_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_COMPLEX64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    x: x_Arg,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<T, x_Arg> Sigmoid<T, x_Arg>
where T: TensorType,
      T: Clone,
      x_Arg: Clone,
      x_Arg: GraphEdge<T>,
      x_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_COMPLEX64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF,
      T: 'static,
{
    pub fn y(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(x: x_Arg) -> Self {
        Self {
            phantom_T: PhantomData,
            x,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(x: x_Arg) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            x,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<handle_Arg, flow_in_Arg> GraphOperation for TensorArrayGrad<handle_Arg, flow_in_Arg>
where handle_Arg: Clone,
      handle_Arg: GraphEdge<String>,
      handle_Arg: 'static,
      flow_in_Arg: Clone,
      flow_in_Arg: GraphEdge<f32>,
      flow_in_Arg: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("TensorArrayGrad_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("TensorArrayGrad", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.handle)?
        }
        {
            new_op.add_edge(&self.flow_in)?
        }
        {
            (|attr| {new_op.set_attr_string("source", attr)})(&self.source)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct TensorArrayGrad<handle_Arg, flow_in_Arg>
where handle_Arg: Clone,
      handle_Arg: GraphEdge<String>,
      handle_Arg: 'static,
      flow_in_Arg: Clone,
      flow_in_Arg: GraphEdge<f32>,
      flow_in_Arg: 'static,
{
    handle: handle_Arg,
    flow_in: flow_in_Arg,
    source: String,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<handle_Arg, flow_in_Arg> TensorArrayGrad<handle_Arg, flow_in_Arg>
where handle_Arg: Clone,
      handle_Arg: GraphEdge<String>,
      handle_Arg: 'static,
      flow_in_Arg: Clone,
      flow_in_Arg: GraphEdge<f32>,
      flow_in_Arg: 'static,
{
    pub fn grad_handle(self) -> RefEdge<String> {
        let rc = Rc::new(self);
        {
            RefEdge::<String>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> RefEdge<String> {
        let rc = Rc::new(self);
        {
            RefEdge::<String>::new(rc.clone(), 0)
        }
    }

    pub fn build(handle: handle_Arg, flow_in: flow_in_Arg, source: &str) -> Self {
        Self {
            handle,
            flow_in,
            source: source.to_string(),
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(handle: handle_Arg, flow_in: flow_in_Arg, source: &str) -> RefEdge<String> {
        Self {
            handle,
            flow_in,
            source: source.to_string(),
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<T, input_Arg> GraphOperation for Qr<T, input_Arg>
where T: TensorType,
      T: Clone,
      input_Arg: Clone,
      input_Arg: GraphEdge<T>,
      input_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_COMPLEX64_or_DT_COMPLEX128,
      T: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("Qr_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("Qr", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.input)?
        }
        {
            match self.full_matrices {
                None => new_op.set_attr_value_proto("full_matrices", &vec![40_u8, 0_u8,])?,
                Some(ref value) => (|attr: &bool| {new_op.set_attr_bool("full_matrices", *attr)})(&value)?,
            };
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct Qr<T, input_Arg>
where T: TensorType,
      T: Clone,
      input_Arg: Clone,
      input_Arg: GraphEdge<T>,
      input_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_COMPLEX64_or_DT_COMPLEX128,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    input: input_Arg,
    full_matrices: Option<bool>,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<T, input_Arg> Qr<T, input_Arg>
where T: TensorType,
      T: Clone,
      input_Arg: Clone,
      input_Arg: GraphEdge<T>,
      input_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_COMPLEX64_or_DT_COMPLEX128,
      T: 'static,
{
    pub fn q(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn r(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 1)
        }
    }

    pub fn full_matrices(&mut self, full_matrices: bool) -> Self {
        self.full_matrices = Some(full_matrices);
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> (Edge<T>, Edge<T>) {
        let rc = Rc::new(self);
        (
        {
            Edge::<T>::new(rc.clone(), 0)
        },
        {
            Edge::<T>::new(rc.clone(), 1)
        },
        )
    }

    pub fn build(input: input_Arg) -> Self {
        Self {
            phantom_T: PhantomData,
            input,
            full_matrices: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(input: input_Arg) -> (Edge<T>, Edge<T>) {
        Self {
            phantom_T: PhantomData,
            input,
            full_matrices: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<tag_Arg, tensor_Arg> GraphOperation for AudioSummary<tag_Arg, tensor_Arg>
where tag_Arg: Clone,
      tag_Arg: GraphEdge<String>,
      tag_Arg: 'static,
      tensor_Arg: Clone,
      tensor_Arg: GraphEdge<f32>,
      tensor_Arg: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("AudioSummary_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("AudioSummary", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.tag)?
        }
        {
            new_op.add_edge(&self.tensor)?
        }
        {
            (|attr: &f32| {new_op.set_attr_float("sample_rate", *attr)})(&self.sample_rate)?
        }
        {
            match self.max_outputs {
                None => new_op.set_attr_value_proto("max_outputs", &vec![24_u8, 3_u8,])?,
                Some(ref value) => (|attr: &i64| {new_op.set_attr_int("max_outputs", *attr)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct AudioSummary<tag_Arg, tensor_Arg>
where tag_Arg: Clone,
      tag_Arg: GraphEdge<String>,
      tag_Arg: 'static,
      tensor_Arg: Clone,
      tensor_Arg: GraphEdge<f32>,
      tensor_Arg: 'static,
{
    tag: tag_Arg,
    tensor: tensor_Arg,
    sample_rate: f32,
    max_outputs: Option<i64>,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<tag_Arg, tensor_Arg> AudioSummary<tag_Arg, tensor_Arg>
where tag_Arg: Clone,
      tag_Arg: GraphEdge<String>,
      tag_Arg: 'static,
      tensor_Arg: Clone,
      tensor_Arg: GraphEdge<f32>,
      tensor_Arg: 'static,
{
    pub fn summary(self) -> Edge<String> {
        let rc = Rc::new(self);
        {
            Edge::<String>::new(rc.clone(), 0)
        }
    }

    pub fn max_outputs(&mut self, max_outputs: i64) -> Self {
        self.max_outputs = Some(max_outputs);
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<String> {
        let rc = Rc::new(self);
        {
            Edge::<String>::new(rc.clone(), 0)
        }
    }

    pub fn build(tag: tag_Arg, tensor: tensor_Arg, sample_rate: f32) -> Self {
        Self {
            tag,
            tensor,
            sample_rate: sample_rate,
            max_outputs: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(tag: tag_Arg, tensor: tensor_Arg, sample_rate: f32) -> Edge<String> {
        Self {
            tag,
            tensor,
            sample_rate: sample_rate,
            max_outputs: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<T, input_Arg, source_target_pairs_Arg> GraphOperation for CollectivePermute<T, input_Arg, source_target_pairs_Arg>
where T: TensorType,
      T: Clone,
      input_Arg: Clone,
      input_Arg: GraphEdge<T>,
      input_Arg: 'static,
      source_target_pairs_Arg: Clone,
      source_target_pairs_Arg: GraphEdge<i32>,
      source_target_pairs_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("CollectivePermute_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("CollectivePermute", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.input)?
        }
        {
            new_op.add_edge(&self.source_target_pairs)?
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct CollectivePermute<T, input_Arg, source_target_pairs_Arg>
where T: TensorType,
      T: Clone,
      input_Arg: Clone,
      input_Arg: GraphEdge<T>,
      input_Arg: 'static,
      source_target_pairs_Arg: Clone,
      source_target_pairs_Arg: GraphEdge<i32>,
      source_target_pairs_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    input: input_Arg,
    source_target_pairs: source_target_pairs_Arg,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<T, input_Arg, source_target_pairs_Arg> CollectivePermute<T, input_Arg, source_target_pairs_Arg>
where T: TensorType,
      T: Clone,
      input_Arg: Clone,
      input_Arg: GraphEdge<T>,
      input_Arg: 'static,
      source_target_pairs_Arg: Clone,
      source_target_pairs_Arg: GraphEdge<i32>,
      source_target_pairs_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
{
    pub fn output(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(input: input_Arg, source_target_pairs: source_target_pairs_Arg) -> Self {
        Self {
            phantom_T: PhantomData,
            input,
            source_target_pairs,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(input: input_Arg, source_target_pairs: source_target_pairs_Arg) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            input,
            source_target_pairs,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

pub trait con_or_DT_COMPLEX64_or_DT_COMPLEX128_or_DT_VARIANT {
}

impl con_or_DT_COMPLEX64_or_DT_COMPLEX128_or_DT_VARIANT for OtherComplex<f32> {
}

impl con_or_DT_COMPLEX64_or_DT_COMPLEX128_or_DT_VARIANT for OtherComplex<f64> {
}

impl<T, input_Arg> GraphOperation for Conj<T, input_Arg>
where T: TensorType,
      T: Clone,
      input_Arg: Clone,
      input_Arg: GraphEdge<T>,
      input_Arg: 'static,
      T: con_or_DT_COMPLEX64_or_DT_COMPLEX128_or_DT_VARIANT,
      T: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("Conj_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("Conj", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.input)?
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct Conj<T, input_Arg>
where T: TensorType,
      T: Clone,
      input_Arg: Clone,
      input_Arg: GraphEdge<T>,
      input_Arg: 'static,
      T: con_or_DT_COMPLEX64_or_DT_COMPLEX128_or_DT_VARIANT,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    input: input_Arg,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<T, input_Arg> Conj<T, input_Arg>
where T: TensorType,
      T: Clone,
      input_Arg: Clone,
      input_Arg: GraphEdge<T>,
      input_Arg: 'static,
      T: con_or_DT_COMPLEX64_or_DT_COMPLEX128_or_DT_VARIANT,
      T: 'static,
{
    pub fn output(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(input: input_Arg) -> Self {
        Self {
            phantom_T: PhantomData,
            input,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(input: input_Arg) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            input,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl GraphOperation for RetrieveTPUEmbeddingAdadeltaParameters {
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("RetrieveTPUEmbeddingAdadeltaParameters_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("RetrieveTPUEmbeddingAdadeltaParameters", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            match self.table_id {
                None => new_op.set_attr_value_proto("table_id", &vec![24_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 1_u8,])?,
                Some(ref value) => (|attr: &i64| {new_op.set_attr_int("table_id", *attr)})(&value)?,
            };
        }
        {
            match self.table_name {
                None => new_op.set_attr_value_proto("table_name", &vec![18_u8, 0_u8,])?,
                Some(ref value) => (|attr| {new_op.set_attr_string("table_name", attr)})(&value)?,
            };
        }
        {
            (|attr: &i64| {new_op.set_attr_int("num_shards", *attr)})(&self.num_shards)?
        }
        {
            (|attr: &i64| {new_op.set_attr_int("shard_id", *attr)})(&self.shard_id)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct RetrieveTPUEmbeddingAdadeltaParameters {
    table_id: Option<i64>,
    table_name: Option<String>,
    num_shards: i64,
    shard_id: i64,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl RetrieveTPUEmbeddingAdadeltaParameters {
    pub fn parameters(self) -> Edge<f32> {
        let rc = Rc::new(self);
        {
            Edge::<f32>::new(rc.clone(), 0)
        }
    }

    pub fn accumulators(self) -> Edge<f32> {
        let rc = Rc::new(self);
        {
            Edge::<f32>::new(rc.clone(), 1)
        }
    }

    pub fn updates(self) -> Edge<f32> {
        let rc = Rc::new(self);
        {
            Edge::<f32>::new(rc.clone(), 2)
        }
    }

    pub fn table_id(&mut self, table_id: i64) -> Self {
        self.table_id = Some(table_id);
        self.clone()
    }

    pub fn table_name(&mut self, table_name: &str) -> Self {
        self.table_name = Some(table_name.to_string());
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> (Edge<f32>, Edge<f32>, Edge<f32>) {
        let rc = Rc::new(self);
        (
        {
            Edge::<f32>::new(rc.clone(), 0)
        },
        {
            Edge::<f32>::new(rc.clone(), 1)
        },
        {
            Edge::<f32>::new(rc.clone(), 2)
        },
        )
    }

    pub fn build(num_shards: i64, shard_id: i64) -> Self {
        Self {
            table_id: None,
            table_name: None,
            num_shards: num_shards,
            shard_id: shard_id,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(num_shards: i64, shard_id: i64) -> (Edge<f32>, Edge<f32>, Edge<f32>) {
        Self {
            table_id: None,
            table_name: None,
            num_shards: num_shards,
            shard_id: shard_id,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl GraphOperation for ConfigureDistributedTPU {
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("ConfigureDistributedTPU_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("ConfigureDistributedTPU", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            match self.embedding_config {
                None => new_op.set_attr_value_proto("embedding_config", &vec![18_u8, 0_u8,])?,
                Some(ref value) => (|attr| {new_op.set_attr_string("embedding_config", attr)})(&value)?,
            };
        }
        {
            match self.tpu_embedding_config {
                None => new_op.set_attr_value_proto("tpu_embedding_config", &vec![18_u8, 0_u8,])?,
                Some(ref value) => (|attr| {new_op.set_attr_string("tpu_embedding_config", attr)})(&value)?,
            };
        }
        {
            match self.is_global_init {
                None => new_op.set_attr_value_proto("is_global_init", &vec![40_u8, 0_u8,])?,
                Some(ref value) => (|attr: &bool| {new_op.set_attr_bool("is_global_init", *attr)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct ConfigureDistributedTPU {
    embedding_config: Option<String>,
    tpu_embedding_config: Option<String>,
    is_global_init: Option<bool>,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl ConfigureDistributedTPU {
    pub fn topology(self) -> Edge<String> {
        let rc = Rc::new(self);
        {
            Edge::<String>::new(rc.clone(), 0)
        }
    }

    pub fn embedding_config(&mut self, embedding_config: &str) -> Self {
        self.embedding_config = Some(embedding_config.to_string());
        self.clone()
    }

    pub fn tpu_embedding_config(&mut self, tpu_embedding_config: &str) -> Self {
        self.tpu_embedding_config = Some(tpu_embedding_config.to_string());
        self.clone()
    }

    pub fn is_global_init(&mut self, is_global_init: bool) -> Self {
        self.is_global_init = Some(is_global_init);
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<String> {
        let rc = Rc::new(self);
        {
            Edge::<String>::new(rc.clone(), 0)
        }
    }

    pub fn build() -> Self {
        Self {
            embedding_config: None,
            tpu_embedding_config: None,
            is_global_init: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new() -> Edge<String> {
        Self {
            embedding_config: None,
            tpu_embedding_config: None,
            is_global_init: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<float_values_Arg, example_weights_Arg, epsilon_Arg> GraphOperation for BoostedTreesMakeQuantileSummaries<float_values_Arg, example_weights_Arg, epsilon_Arg>
where float_values_Arg: Clone,
      float_values_Arg: GraphEdge<f32>,
      float_values_Arg: 'static,
      example_weights_Arg: Clone,
      example_weights_Arg: GraphEdge<f32>,
      example_weights_Arg: 'static,
      epsilon_Arg: Clone,
      epsilon_Arg: GraphEdge<f32>,
      epsilon_Arg: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("BoostedTreesMakeQuantileSummaries_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("BoostedTreesMakeQuantileSummaries", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.float_values)?
        }
        {
            new_op.add_edge(&self.example_weights)?
        }
        {
            new_op.add_edge(&self.epsilon)?
        }
        {
            (|attr: &i64| {new_op.set_attr_int("num_features", *attr)})(&self.num_features)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct BoostedTreesMakeQuantileSummaries<float_values_Arg, example_weights_Arg, epsilon_Arg>
where float_values_Arg: Clone,
      float_values_Arg: GraphEdge<f32>,
      float_values_Arg: 'static,
      example_weights_Arg: Clone,
      example_weights_Arg: GraphEdge<f32>,
      example_weights_Arg: 'static,
      epsilon_Arg: Clone,
      epsilon_Arg: GraphEdge<f32>,
      epsilon_Arg: 'static,
{
    float_values: float_values_Arg,
    example_weights: example_weights_Arg,
    epsilon: epsilon_Arg,
    num_features: i64,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<float_values_Arg, example_weights_Arg, epsilon_Arg> BoostedTreesMakeQuantileSummaries<float_values_Arg, example_weights_Arg, epsilon_Arg>
where float_values_Arg: Clone,
      float_values_Arg: GraphEdge<f32>,
      float_values_Arg: 'static,
      example_weights_Arg: Clone,
      example_weights_Arg: GraphEdge<f32>,
      example_weights_Arg: 'static,
      epsilon_Arg: Clone,
      epsilon_Arg: GraphEdge<f32>,
      epsilon_Arg: 'static,
{
    pub fn summaries(self) -> Edge<f32> {
        let rc = Rc::new(self);
        {
            Edge::<f32>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<f32> {
        let rc = Rc::new(self);
        {
            Edge::<f32>::new(rc.clone(), 0)
        }
    }

    pub fn build(float_values: float_values_Arg, example_weights: example_weights_Arg, epsilon: epsilon_Arg, num_features: i64) -> Self {
        Self {
            float_values,
            example_weights,
            epsilon,
            num_features: num_features,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(float_values: float_values_Arg, example_weights: example_weights_Arg, epsilon: epsilon_Arg, num_features: i64) -> Edge<f32> {
        Self {
            float_values,
            example_weights,
            epsilon,
            num_features: num_features,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<boxes_Arg, scores_Arg, max_output_size_Arg> GraphOperation for NonMaxSuppression<boxes_Arg, scores_Arg, max_output_size_Arg>
where boxes_Arg: Clone,
      boxes_Arg: GraphEdge<f32>,
      boxes_Arg: 'static,
      scores_Arg: Clone,
      scores_Arg: GraphEdge<f32>,
      scores_Arg: 'static,
      max_output_size_Arg: Clone,
      max_output_size_Arg: GraphEdge<i32>,
      max_output_size_Arg: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("NonMaxSuppression_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("NonMaxSuppression", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.boxes)?
        }
        {
            new_op.add_edge(&self.scores)?
        }
        {
            new_op.add_edge(&self.max_output_size)?
        }
        {
            match self.iou_threshold {
                None => new_op.set_attr_value_proto("iou_threshold", &vec![37_u8, 0_u8, 0_u8, 0_u8, 63_u8,])?,
                Some(ref value) => (|attr: &f32| {new_op.set_attr_float("iou_threshold", *attr)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct NonMaxSuppression<boxes_Arg, scores_Arg, max_output_size_Arg>
where boxes_Arg: Clone,
      boxes_Arg: GraphEdge<f32>,
      boxes_Arg: 'static,
      scores_Arg: Clone,
      scores_Arg: GraphEdge<f32>,
      scores_Arg: 'static,
      max_output_size_Arg: Clone,
      max_output_size_Arg: GraphEdge<i32>,
      max_output_size_Arg: 'static,
{
    boxes: boxes_Arg,
    scores: scores_Arg,
    max_output_size: max_output_size_Arg,
    iou_threshold: Option<f32>,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<boxes_Arg, scores_Arg, max_output_size_Arg> NonMaxSuppression<boxes_Arg, scores_Arg, max_output_size_Arg>
where boxes_Arg: Clone,
      boxes_Arg: GraphEdge<f32>,
      boxes_Arg: 'static,
      scores_Arg: Clone,
      scores_Arg: GraphEdge<f32>,
      scores_Arg: 'static,
      max_output_size_Arg: Clone,
      max_output_size_Arg: GraphEdge<i32>,
      max_output_size_Arg: 'static,
{
    pub fn selected_indices(self) -> Edge<i32> {
        let rc = Rc::new(self);
        {
            Edge::<i32>::new(rc.clone(), 0)
        }
    }

    pub fn iou_threshold(&mut self, iou_threshold: f32) -> Self {
        self.iou_threshold = Some(iou_threshold);
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<i32> {
        let rc = Rc::new(self);
        {
            Edge::<i32>::new(rc.clone(), 0)
        }
    }

    pub fn build(boxes: boxes_Arg, scores: scores_Arg, max_output_size: max_output_size_Arg) -> Self {
        Self {
            boxes,
            scores,
            max_output_size,
            iou_threshold: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(boxes: boxes_Arg, scores: scores_Arg, max_output_size: max_output_size_Arg) -> Edge<i32> {
        Self {
            boxes,
            scores,
            max_output_size,
            iou_threshold: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<parameters_Arg, accumulators_Arg, gradient_accumulators_Arg> GraphOperation for LoadTPUEmbeddingAdagradParametersGradAccumDebug<parameters_Arg, accumulators_Arg, gradient_accumulators_Arg>
where parameters_Arg: Clone,
      parameters_Arg: GraphEdge<f32>,
      parameters_Arg: 'static,
      accumulators_Arg: Clone,
      accumulators_Arg: GraphEdge<f32>,
      accumulators_Arg: 'static,
      gradient_accumulators_Arg: Clone,
      gradient_accumulators_Arg: GraphEdge<f32>,
      gradient_accumulators_Arg: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("LoadTPUEmbeddingAdagradParametersGradAccumDebug_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("LoadTPUEmbeddingAdagradParametersGradAccumDebug", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.parameters)?
        }
        {
            new_op.add_edge(&self.accumulators)?
        }
        {
            new_op.add_edge(&self.gradient_accumulators)?
        }
        {
            match self.table_id {
                None => new_op.set_attr_value_proto("table_id", &vec![24_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 1_u8,])?,
                Some(ref value) => (|attr: &i64| {new_op.set_attr_int("table_id", *attr)})(&value)?,
            };
        }
        {
            match self.table_name {
                None => new_op.set_attr_value_proto("table_name", &vec![18_u8, 0_u8,])?,
                Some(ref value) => (|attr| {new_op.set_attr_string("table_name", attr)})(&value)?,
            };
        }
        {
            (|attr: &i64| {new_op.set_attr_int("num_shards", *attr)})(&self.num_shards)?
        }
        {
            (|attr: &i64| {new_op.set_attr_int("shard_id", *attr)})(&self.shard_id)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct LoadTPUEmbeddingAdagradParametersGradAccumDebug<parameters_Arg, accumulators_Arg, gradient_accumulators_Arg>
where parameters_Arg: Clone,
      parameters_Arg: GraphEdge<f32>,
      parameters_Arg: 'static,
      accumulators_Arg: Clone,
      accumulators_Arg: GraphEdge<f32>,
      accumulators_Arg: 'static,
      gradient_accumulators_Arg: Clone,
      gradient_accumulators_Arg: GraphEdge<f32>,
      gradient_accumulators_Arg: 'static,
{
    parameters: parameters_Arg,
    accumulators: accumulators_Arg,
    gradient_accumulators: gradient_accumulators_Arg,
    table_id: Option<i64>,
    table_name: Option<String>,
    num_shards: i64,
    shard_id: i64,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<parameters_Arg, accumulators_Arg, gradient_accumulators_Arg> LoadTPUEmbeddingAdagradParametersGradAccumDebug<parameters_Arg, accumulators_Arg, gradient_accumulators_Arg>
where parameters_Arg: Clone,
      parameters_Arg: GraphEdge<f32>,
      parameters_Arg: 'static,
      accumulators_Arg: Clone,
      accumulators_Arg: GraphEdge<f32>,
      accumulators_Arg: 'static,
      gradient_accumulators_Arg: Clone,
      gradient_accumulators_Arg: GraphEdge<f32>,
      gradient_accumulators_Arg: 'static,
{
    pub fn table_id(&mut self, table_id: i64) -> Self {
        self.table_id = Some(table_id);
        self.clone()
    }

    pub fn table_name(&mut self, table_name: &str) -> Self {
        self.table_name = Some(table_name.to_string());
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> () {
        let rc = Rc::new(self);
        (
        )
    }

    pub fn build(parameters: parameters_Arg, accumulators: accumulators_Arg, gradient_accumulators: gradient_accumulators_Arg, num_shards: i64, shard_id: i64) -> Self {
        Self {
            parameters,
            accumulators,
            gradient_accumulators,
            table_id: None,
            table_name: None,
            num_shards: num_shards,
            shard_id: shard_id,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(parameters: parameters_Arg, accumulators: accumulators_Arg, gradient_accumulators: gradient_accumulators_Arg, num_shards: i64, shard_id: i64) -> () {
        Self {
            parameters,
            accumulators,
            gradient_accumulators,
            table_id: None,
            table_name: None,
            num_shards: num_shards,
            shard_id: shard_id,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl GraphOperation for RetrieveTPUEmbeddingFTRLParametersGradAccumDebug {
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("RetrieveTPUEmbeddingFTRLParametersGradAccumDebug_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("RetrieveTPUEmbeddingFTRLParametersGradAccumDebug", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            match self.table_id {
                None => new_op.set_attr_value_proto("table_id", &vec![24_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 1_u8,])?,
                Some(ref value) => (|attr: &i64| {new_op.set_attr_int("table_id", *attr)})(&value)?,
            };
        }
        {
            match self.table_name {
                None => new_op.set_attr_value_proto("table_name", &vec![18_u8, 0_u8,])?,
                Some(ref value) => (|attr| {new_op.set_attr_string("table_name", attr)})(&value)?,
            };
        }
        {
            (|attr: &i64| {new_op.set_attr_int("num_shards", *attr)})(&self.num_shards)?
        }
        {
            (|attr: &i64| {new_op.set_attr_int("shard_id", *attr)})(&self.shard_id)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct RetrieveTPUEmbeddingFTRLParametersGradAccumDebug {
    table_id: Option<i64>,
    table_name: Option<String>,
    num_shards: i64,
    shard_id: i64,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl RetrieveTPUEmbeddingFTRLParametersGradAccumDebug {
    pub fn parameters(self) -> Edge<f32> {
        let rc = Rc::new(self);
        {
            Edge::<f32>::new(rc.clone(), 0)
        }
    }

    pub fn accumulators(self) -> Edge<f32> {
        let rc = Rc::new(self);
        {
            Edge::<f32>::new(rc.clone(), 1)
        }
    }

    pub fn linears(self) -> Edge<f32> {
        let rc = Rc::new(self);
        {
            Edge::<f32>::new(rc.clone(), 2)
        }
    }

    pub fn gradient_accumulators(self) -> Edge<f32> {
        let rc = Rc::new(self);
        {
            Edge::<f32>::new(rc.clone(), 3)
        }
    }

    pub fn table_id(&mut self, table_id: i64) -> Self {
        self.table_id = Some(table_id);
        self.clone()
    }

    pub fn table_name(&mut self, table_name: &str) -> Self {
        self.table_name = Some(table_name.to_string());
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> (Edge<f32>, Edge<f32>, Edge<f32>, Edge<f32>) {
        let rc = Rc::new(self);
        (
        {
            Edge::<f32>::new(rc.clone(), 0)
        },
        {
            Edge::<f32>::new(rc.clone(), 1)
        },
        {
            Edge::<f32>::new(rc.clone(), 2)
        },
        {
            Edge::<f32>::new(rc.clone(), 3)
        },
        )
    }

    pub fn build(num_shards: i64, shard_id: i64) -> Self {
        Self {
            table_id: None,
            table_name: None,
            num_shards: num_shards,
            shard_id: shard_id,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(num_shards: i64, shard_id: i64) -> (Edge<f32>, Edge<f32>, Edge<f32>, Edge<f32>) {
        Self {
            table_id: None,
            table_name: None,
            num_shards: num_shards,
            shard_id: shard_id,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<input_Arg> GraphOperation for BatchFFT<input_Arg>
where input_Arg: Clone,
      input_Arg: GraphEdge<OtherComplex<f32>>,
      input_Arg: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("BatchFFT_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("BatchFFT", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.input)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct BatchFFT<input_Arg>
where input_Arg: Clone,
      input_Arg: GraphEdge<OtherComplex<f32>>,
      input_Arg: 'static,
{
    input: input_Arg,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<input_Arg> BatchFFT<input_Arg>
where input_Arg: Clone,
      input_Arg: GraphEdge<OtherComplex<f32>>,
      input_Arg: 'static,
{
    pub fn output(self) -> Edge<OtherComplex<f32>> {
        let rc = Rc::new(self);
        {
            Edge::<OtherComplex::<f32>>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<OtherComplex<f32>> {
        let rc = Rc::new(self);
        {
            Edge::<OtherComplex::<f32>>::new(rc.clone(), 0)
        }
    }

    pub fn build(input: input_Arg) -> Self {
        Self {
            input,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(input: input_Arg) -> Edge<OtherComplex<f32>> {
        Self {
            input,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<parameters_Arg, momenta_Arg, gradient_accumulators_Arg> GraphOperation for LoadTPUEmbeddingMomentumParametersGradAccumDebug<parameters_Arg, momenta_Arg, gradient_accumulators_Arg>
where parameters_Arg: Clone,
      parameters_Arg: GraphEdge<f32>,
      parameters_Arg: 'static,
      momenta_Arg: Clone,
      momenta_Arg: GraphEdge<f32>,
      momenta_Arg: 'static,
      gradient_accumulators_Arg: Clone,
      gradient_accumulators_Arg: GraphEdge<f32>,
      gradient_accumulators_Arg: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("LoadTPUEmbeddingMomentumParametersGradAccumDebug_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("LoadTPUEmbeddingMomentumParametersGradAccumDebug", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.parameters)?
        }
        {
            new_op.add_edge(&self.momenta)?
        }
        {
            new_op.add_edge(&self.gradient_accumulators)?
        }
        {
            match self.table_id {
                None => new_op.set_attr_value_proto("table_id", &vec![24_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 1_u8,])?,
                Some(ref value) => (|attr: &i64| {new_op.set_attr_int("table_id", *attr)})(&value)?,
            };
        }
        {
            match self.table_name {
                None => new_op.set_attr_value_proto("table_name", &vec![18_u8, 0_u8,])?,
                Some(ref value) => (|attr| {new_op.set_attr_string("table_name", attr)})(&value)?,
            };
        }
        {
            (|attr: &i64| {new_op.set_attr_int("num_shards", *attr)})(&self.num_shards)?
        }
        {
            (|attr: &i64| {new_op.set_attr_int("shard_id", *attr)})(&self.shard_id)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct LoadTPUEmbeddingMomentumParametersGradAccumDebug<parameters_Arg, momenta_Arg, gradient_accumulators_Arg>
where parameters_Arg: Clone,
      parameters_Arg: GraphEdge<f32>,
      parameters_Arg: 'static,
      momenta_Arg: Clone,
      momenta_Arg: GraphEdge<f32>,
      momenta_Arg: 'static,
      gradient_accumulators_Arg: Clone,
      gradient_accumulators_Arg: GraphEdge<f32>,
      gradient_accumulators_Arg: 'static,
{
    parameters: parameters_Arg,
    momenta: momenta_Arg,
    gradient_accumulators: gradient_accumulators_Arg,
    table_id: Option<i64>,
    table_name: Option<String>,
    num_shards: i64,
    shard_id: i64,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<parameters_Arg, momenta_Arg, gradient_accumulators_Arg> LoadTPUEmbeddingMomentumParametersGradAccumDebug<parameters_Arg, momenta_Arg, gradient_accumulators_Arg>
where parameters_Arg: Clone,
      parameters_Arg: GraphEdge<f32>,
      parameters_Arg: 'static,
      momenta_Arg: Clone,
      momenta_Arg: GraphEdge<f32>,
      momenta_Arg: 'static,
      gradient_accumulators_Arg: Clone,
      gradient_accumulators_Arg: GraphEdge<f32>,
      gradient_accumulators_Arg: 'static,
{
    pub fn table_id(&mut self, table_id: i64) -> Self {
        self.table_id = Some(table_id);
        self.clone()
    }

    pub fn table_name(&mut self, table_name: &str) -> Self {
        self.table_name = Some(table_name.to_string());
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> () {
        let rc = Rc::new(self);
        (
        )
    }

    pub fn build(parameters: parameters_Arg, momenta: momenta_Arg, gradient_accumulators: gradient_accumulators_Arg, num_shards: i64, shard_id: i64) -> Self {
        Self {
            parameters,
            momenta,
            gradient_accumulators,
            table_id: None,
            table_name: None,
            num_shards: num_shards,
            shard_id: shard_id,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(parameters: parameters_Arg, momenta: momenta_Arg, gradient_accumulators: gradient_accumulators_Arg, num_shards: i64, shard_id: i64) -> () {
        Self {
            parameters,
            momenta,
            gradient_accumulators,
            table_id: None,
            table_name: None,
            num_shards: num_shards,
            shard_id: shard_id,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<dtype> GraphOperation for HostConst<dtype>
where dtype: TensorType,
      dtype: 'static,
      dtype: Clone,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("HostConst_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("HostConst", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            (|attr: &Rc<AnyTensor>| {new_op.set_attr_tensor_owned("value", attr.clone())})(&self.value)?
        }
        {
            new_op.set_attr_type("dtype", dtype::data_type())?;
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct HostConst<dtype>
where dtype: TensorType,
      dtype: 'static,
      dtype: Clone,
{
    value: Rc<AnyTensor>,
    phantom_dtype: PhantomData<dtype>,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<dtype> HostConst<dtype>
where dtype: TensorType,
      dtype: 'static,
      dtype: Clone,
{
    pub fn output(self) -> Edge<dtype> {
        let rc = Rc::new(self);
        {
            Edge::<dtype>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<dtype> {
        let rc = Rc::new(self);
        {
            Edge::<dtype>::new(rc.clone(), 0)
        }
    }

    pub fn build<value_T, value_TensorType>(value: value_T) -> Self
    where Tensor<value_TensorType>: From<value_T>,
          value_T: 'static,
          value_TensorType: TensorType,
    {
        Self {
            value: Rc::new(Tensor::<value_TensorType>::from(value)),
            phantom_dtype: PhantomData,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new<value_T, value_TensorType>(value: value_T) -> Edge<dtype>
    where Tensor<value_TensorType>: From<value_T>,
          value_T: 'static,
          value_TensorType: TensorType,
    {
        Self {
            value: Rc::new(Tensor::<value_TensorType>::from(value)),
            phantom_dtype: PhantomData,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<T, input_Arg, Tidx, reduction_indices_Arg> GraphOperation for Sum<T, input_Arg, Tidx, reduction_indices_Arg>
where T: TensorType,
      T: Clone,
      input_Arg: Clone,
      input_Arg: GraphEdge<T>,
      input_Arg: 'static,
      Tidx: TensorType,
      Tidx: Clone,
      reduction_indices_Arg: Clone,
      reduction_indices_Arg: GraphEdge<Tidx>,
      reduction_indices_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
      Tidx: con_or_DT_INT32_or_DT_INT64,
      Tidx: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("Sum_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("Sum", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.input)?
        }
        {
            new_op.add_edge(&self.reduction_indices)?
        }
        {
            match self.keep_dims {
                None => new_op.set_attr_value_proto("keep_dims", &vec![40_u8, 0_u8,])?,
                Some(ref value) => (|attr: &bool| {new_op.set_attr_bool("keep_dims", *attr)})(&value)?,
            };
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        {
            new_op.set_attr_type("Tidx", Tidx::data_type())?;
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct Sum<T, input_Arg, Tidx, reduction_indices_Arg>
where T: TensorType,
      T: Clone,
      input_Arg: Clone,
      input_Arg: GraphEdge<T>,
      input_Arg: 'static,
      Tidx: TensorType,
      Tidx: Clone,
      reduction_indices_Arg: Clone,
      reduction_indices_Arg: GraphEdge<Tidx>,
      reduction_indices_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
      Tidx: con_or_DT_INT32_or_DT_INT64,
      Tidx: 'static,
{
    phantom_T: PhantomData<T>,
    input: input_Arg,
    phantom_Tidx: PhantomData<Tidx>,
    reduction_indices: reduction_indices_Arg,
    keep_dims: Option<bool>,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<T, input_Arg, Tidx, reduction_indices_Arg> Sum<T, input_Arg, Tidx, reduction_indices_Arg>
where T: TensorType,
      T: Clone,
      input_Arg: Clone,
      input_Arg: GraphEdge<T>,
      input_Arg: 'static,
      Tidx: TensorType,
      Tidx: Clone,
      reduction_indices_Arg: Clone,
      reduction_indices_Arg: GraphEdge<Tidx>,
      reduction_indices_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
      Tidx: con_or_DT_INT32_or_DT_INT64,
      Tidx: 'static,
{
    pub fn output(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn keep_dims(&mut self, keep_dims: bool) -> Self {
        self.keep_dims = Some(keep_dims);
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(input: input_Arg, reduction_indices: reduction_indices_Arg) -> Self {
        Self {
            phantom_T: PhantomData,
            input,
            phantom_Tidx: PhantomData,
            reduction_indices,
            keep_dims: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(input: input_Arg, reduction_indices: reduction_indices_Arg) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            input,
            phantom_Tidx: PhantomData,
            reduction_indices,
            keep_dims: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

pub trait con_or_DT_FLOAT {
}

impl con_or_DT_FLOAT for f32 {
}

impl<T, y_backprop_Arg, x_Arg, scale_Arg, U, reserve_space_1_Arg, reserve_space_2_Arg> GraphOperation for FusedBatchNormGradV2<T, y_backprop_Arg, x_Arg, scale_Arg, U, reserve_space_1_Arg, reserve_space_2_Arg>
where T: TensorType,
      T: Clone,
      y_backprop_Arg: Clone,
      y_backprop_Arg: GraphEdge<T>,
      y_backprop_Arg: 'static,
      x_Arg: Clone,
      x_Arg: GraphEdge<T>,
      x_Arg: 'static,
      scale_Arg: Clone,
      scale_Arg: GraphEdge<f32>,
      scale_Arg: 'static,
      U: TensorType,
      U: Clone,
      reserve_space_1_Arg: Clone,
      reserve_space_1_Arg: GraphEdge<U>,
      reserve_space_1_Arg: 'static,
      reserve_space_2_Arg: Clone,
      reserve_space_2_Arg: GraphEdge<U>,
      reserve_space_2_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_BFLOAT16_or_DT_HALF,
      T: 'static,
      U: con_or_DT_FLOAT,
      U: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("FusedBatchNormGradV2_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("FusedBatchNormGradV2", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.y_backprop)?
        }
        {
            new_op.add_edge(&self.x)?
        }
        {
            new_op.add_edge(&self.scale)?
        }
        {
            new_op.add_edge(&self.reserve_space_1)?
        }
        {
            new_op.add_edge(&self.reserve_space_2)?
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        {
            new_op.set_attr_type("U", U::data_type())?;
        }
        {
            match self.epsilon {
                None => new_op.set_attr_value_proto("epsilon", &vec![37_u8, 23_u8, 183_u8, 209_u8, 56_u8,])?,
                Some(ref value) => (|attr: &f32| {new_op.set_attr_float("epsilon", *attr)})(&value)?,
            };
        }
        {
            match self.data_format {
                None => new_op.set_attr_value_proto("data_format", &vec![18_u8, 4_u8, 78_u8, 72_u8, 87_u8, 67_u8,])?,
                Some(ref value) => (|attr| {new_op.set_attr_string("data_format", attr)})(&value)?,
            };
        }
        {
            match self.is_training {
                None => new_op.set_attr_value_proto("is_training", &vec![40_u8, 1_u8,])?,
                Some(ref value) => (|attr: &bool| {new_op.set_attr_bool("is_training", *attr)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct FusedBatchNormGradV2<T, y_backprop_Arg, x_Arg, scale_Arg, U, reserve_space_1_Arg, reserve_space_2_Arg>
where T: TensorType,
      T: Clone,
      y_backprop_Arg: Clone,
      y_backprop_Arg: GraphEdge<T>,
      y_backprop_Arg: 'static,
      x_Arg: Clone,
      x_Arg: GraphEdge<T>,
      x_Arg: 'static,
      scale_Arg: Clone,
      scale_Arg: GraphEdge<f32>,
      scale_Arg: 'static,
      U: TensorType,
      U: Clone,
      reserve_space_1_Arg: Clone,
      reserve_space_1_Arg: GraphEdge<U>,
      reserve_space_1_Arg: 'static,
      reserve_space_2_Arg: Clone,
      reserve_space_2_Arg: GraphEdge<U>,
      reserve_space_2_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_BFLOAT16_or_DT_HALF,
      T: 'static,
      U: con_or_DT_FLOAT,
      U: 'static,
{
    phantom_T: PhantomData<T>,
    y_backprop: y_backprop_Arg,
    x: x_Arg,
    scale: scale_Arg,
    phantom_U: PhantomData<U>,
    reserve_space_1: reserve_space_1_Arg,
    reserve_space_2: reserve_space_2_Arg,
    epsilon: Option<f32>,
    data_format: Option<String>,
    is_training: Option<bool>,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<T, y_backprop_Arg, x_Arg, scale_Arg, U, reserve_space_1_Arg, reserve_space_2_Arg> FusedBatchNormGradV2<T, y_backprop_Arg, x_Arg, scale_Arg, U, reserve_space_1_Arg, reserve_space_2_Arg>
where T: TensorType,
      T: Clone,
      y_backprop_Arg: Clone,
      y_backprop_Arg: GraphEdge<T>,
      y_backprop_Arg: 'static,
      x_Arg: Clone,
      x_Arg: GraphEdge<T>,
      x_Arg: 'static,
      scale_Arg: Clone,
      scale_Arg: GraphEdge<f32>,
      scale_Arg: 'static,
      U: TensorType,
      U: Clone,
      reserve_space_1_Arg: Clone,
      reserve_space_1_Arg: GraphEdge<U>,
      reserve_space_1_Arg: 'static,
      reserve_space_2_Arg: Clone,
      reserve_space_2_Arg: GraphEdge<U>,
      reserve_space_2_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_BFLOAT16_or_DT_HALF,
      T: 'static,
      U: con_or_DT_FLOAT,
      U: 'static,
{
    pub fn x_backprop(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn scale_backprop(self) -> Edge<U> {
        let rc = Rc::new(self);
        {
            Edge::<U>::new(rc.clone(), 1)
        }
    }

    pub fn offset_backprop(self) -> Edge<U> {
        let rc = Rc::new(self);
        {
            Edge::<U>::new(rc.clone(), 2)
        }
    }

    pub fn reserve_space_3(self) -> Edge<U> {
        let rc = Rc::new(self);
        {
            Edge::<U>::new(rc.clone(), 3)
        }
    }

    pub fn reserve_space_4(self) -> Edge<U> {
        let rc = Rc::new(self);
        {
            Edge::<U>::new(rc.clone(), 4)
        }
    }

    pub fn epsilon(&mut self, epsilon: f32) -> Self {
        self.epsilon = Some(epsilon);
        self.clone()
    }

    pub fn data_format(&mut self, data_format: &str) -> Self {
        self.data_format = Some(data_format.to_string());
        self.clone()
    }

    pub fn is_training(&mut self, is_training: bool) -> Self {
        self.is_training = Some(is_training);
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> (Edge<T>, Edge<U>, Edge<U>, Edge<U>, Edge<U>) {
        let rc = Rc::new(self);
        (
        {
            Edge::<T>::new(rc.clone(), 0)
        },
        {
            Edge::<U>::new(rc.clone(), 1)
        },
        {
            Edge::<U>::new(rc.clone(), 2)
        },
        {
            Edge::<U>::new(rc.clone(), 3)
        },
        {
            Edge::<U>::new(rc.clone(), 4)
        },
        )
    }

    pub fn build(y_backprop: y_backprop_Arg, x: x_Arg, scale: scale_Arg, reserve_space_1: reserve_space_1_Arg, reserve_space_2: reserve_space_2_Arg) -> Self {
        Self {
            phantom_T: PhantomData,
            y_backprop,
            x,
            scale,
            phantom_U: PhantomData,
            reserve_space_1,
            reserve_space_2,
            epsilon: None,
            data_format: None,
            is_training: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(y_backprop: y_backprop_Arg, x: x_Arg, scale: scale_Arg, reserve_space_1: reserve_space_1_Arg, reserve_space_2: reserve_space_2_Arg) -> (Edge<T>, Edge<U>, Edge<U>, Edge<U>, Edge<U>) {
        Self {
            phantom_T: PhantomData,
            y_backprop,
            x,
            scale,
            phantom_U: PhantomData,
            reserve_space_1,
            reserve_space_2,
            epsilon: None,
            data_format: None,
            is_training: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<elem_type> GraphOperation for Stack<elem_type>
where elem_type: TensorType,
      elem_type: 'static,
      elem_type: Clone,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("Stack_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("Stack", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.set_attr_type("elem_type", elem_type::data_type())?;
        }
        {
            match self.stack_name {
                None => new_op.set_attr_value_proto("stack_name", &vec![18_u8, 0_u8,])?,
                Some(ref value) => (|attr| {new_op.set_attr_string("stack_name", attr)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct Stack<elem_type>
where elem_type: TensorType,
      elem_type: 'static,
      elem_type: Clone,
{
    phantom_elem_type: PhantomData<elem_type>,
    stack_name: Option<String>,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<elem_type> Stack<elem_type>
where elem_type: TensorType,
      elem_type: 'static,
      elem_type: Clone,
{
    pub fn handle(self) -> RefEdge<String> {
        let rc = Rc::new(self);
        {
            RefEdge::<String>::new(rc.clone(), 0)
        }
    }

    pub fn stack_name(&mut self, stack_name: &str) -> Self {
        self.stack_name = Some(stack_name.to_string());
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> RefEdge<String> {
        let rc = Rc::new(self);
        {
            RefEdge::<String>::new(rc.clone(), 0)
        }
    }

    pub fn build() -> Self {
        Self {
            phantom_elem_type: PhantomData,
            stack_name: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new() -> RefEdge<String> {
        Self {
            phantom_elem_type: PhantomData,
            stack_name: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

pub trait con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_COMPLEX64_or_DT_COMPLEX128_or_DT_HALF {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_COMPLEX64_or_DT_COMPLEX128_or_DT_HALF for OtherComplex<f32> {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_COMPLEX64_or_DT_COMPLEX128_or_DT_HALF for OtherComplex<f64> {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_COMPLEX64_or_DT_COMPLEX128_or_DT_HALF for f32 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_COMPLEX64_or_DT_COMPLEX128_or_DT_HALF for f64 {
}

impl<T, x_Arg, y_Arg> GraphOperation for Xlogy<T, x_Arg, y_Arg>
where T: TensorType,
      T: Clone,
      x_Arg: Clone,
      x_Arg: GraphEdge<T>,
      x_Arg: 'static,
      y_Arg: Clone,
      y_Arg: GraphEdge<T>,
      y_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_COMPLEX64_or_DT_COMPLEX128_or_DT_HALF,
      T: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("Xlogy_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("Xlogy", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.x)?
        }
        {
            new_op.add_edge(&self.y)?
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct Xlogy<T, x_Arg, y_Arg>
where T: TensorType,
      T: Clone,
      x_Arg: Clone,
      x_Arg: GraphEdge<T>,
      x_Arg: 'static,
      y_Arg: Clone,
      y_Arg: GraphEdge<T>,
      y_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_COMPLEX64_or_DT_COMPLEX128_or_DT_HALF,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    x: x_Arg,
    y: y_Arg,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<T, x_Arg, y_Arg> Xlogy<T, x_Arg, y_Arg>
where T: TensorType,
      T: Clone,
      x_Arg: Clone,
      x_Arg: GraphEdge<T>,
      x_Arg: 'static,
      y_Arg: Clone,
      y_Arg: GraphEdge<T>,
      y_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_COMPLEX64_or_DT_COMPLEX128_or_DT_HALF,
      T: 'static,
{
    pub fn z(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(x: x_Arg, y: y_Arg) -> Self {
        Self {
            phantom_T: PhantomData,
            x,
            y,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(x: x_Arg, y: y_Arg) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            x,
            y,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<hypothesis_indices_Arg, T, hypothesis_values_Arg, hypothesis_shape_Arg, truth_indices_Arg, truth_values_Arg, truth_shape_Arg> GraphOperation for EditDistance<hypothesis_indices_Arg, T, hypothesis_values_Arg, hypothesis_shape_Arg, truth_indices_Arg, truth_values_Arg, truth_shape_Arg>
where hypothesis_indices_Arg: Clone,
      hypothesis_indices_Arg: GraphEdge<i64>,
      hypothesis_indices_Arg: 'static,
      T: TensorType,
      T: Clone,
      hypothesis_values_Arg: Clone,
      hypothesis_values_Arg: GraphEdge<T>,
      hypothesis_values_Arg: 'static,
      hypothesis_shape_Arg: Clone,
      hypothesis_shape_Arg: GraphEdge<i64>,
      hypothesis_shape_Arg: 'static,
      truth_indices_Arg: Clone,
      truth_indices_Arg: GraphEdge<i64>,
      truth_indices_Arg: 'static,
      truth_values_Arg: Clone,
      truth_values_Arg: GraphEdge<T>,
      truth_values_Arg: 'static,
      truth_shape_Arg: Clone,
      truth_shape_Arg: GraphEdge<i64>,
      truth_shape_Arg: 'static,
      T: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("EditDistance_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("EditDistance", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.hypothesis_indices)?
        }
        {
            new_op.add_edge(&self.hypothesis_values)?
        }
        {
            new_op.add_edge(&self.hypothesis_shape)?
        }
        {
            new_op.add_edge(&self.truth_indices)?
        }
        {
            new_op.add_edge(&self.truth_values)?
        }
        {
            new_op.add_edge(&self.truth_shape)?
        }
        {
            match self.normalize {
                None => new_op.set_attr_value_proto("normalize", &vec![40_u8, 1_u8,])?,
                Some(ref value) => (|attr: &bool| {new_op.set_attr_bool("normalize", *attr)})(&value)?,
            };
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct EditDistance<hypothesis_indices_Arg, T, hypothesis_values_Arg, hypothesis_shape_Arg, truth_indices_Arg, truth_values_Arg, truth_shape_Arg>
where hypothesis_indices_Arg: Clone,
      hypothesis_indices_Arg: GraphEdge<i64>,
      hypothesis_indices_Arg: 'static,
      T: TensorType,
      T: Clone,
      hypothesis_values_Arg: Clone,
      hypothesis_values_Arg: GraphEdge<T>,
      hypothesis_values_Arg: 'static,
      hypothesis_shape_Arg: Clone,
      hypothesis_shape_Arg: GraphEdge<i64>,
      hypothesis_shape_Arg: 'static,
      truth_indices_Arg: Clone,
      truth_indices_Arg: GraphEdge<i64>,
      truth_indices_Arg: 'static,
      truth_values_Arg: Clone,
      truth_values_Arg: GraphEdge<T>,
      truth_values_Arg: 'static,
      truth_shape_Arg: Clone,
      truth_shape_Arg: GraphEdge<i64>,
      truth_shape_Arg: 'static,
      T: 'static,
{
    hypothesis_indices: hypothesis_indices_Arg,
    phantom_T: PhantomData<T>,
    hypothesis_values: hypothesis_values_Arg,
    hypothesis_shape: hypothesis_shape_Arg,
    truth_indices: truth_indices_Arg,
    truth_values: truth_values_Arg,
    truth_shape: truth_shape_Arg,
    normalize: Option<bool>,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<hypothesis_indices_Arg, T, hypothesis_values_Arg, hypothesis_shape_Arg, truth_indices_Arg, truth_values_Arg, truth_shape_Arg> EditDistance<hypothesis_indices_Arg, T, hypothesis_values_Arg, hypothesis_shape_Arg, truth_indices_Arg, truth_values_Arg, truth_shape_Arg>
where hypothesis_indices_Arg: Clone,
      hypothesis_indices_Arg: GraphEdge<i64>,
      hypothesis_indices_Arg: 'static,
      T: TensorType,
      T: Clone,
      hypothesis_values_Arg: Clone,
      hypothesis_values_Arg: GraphEdge<T>,
      hypothesis_values_Arg: 'static,
      hypothesis_shape_Arg: Clone,
      hypothesis_shape_Arg: GraphEdge<i64>,
      hypothesis_shape_Arg: 'static,
      truth_indices_Arg: Clone,
      truth_indices_Arg: GraphEdge<i64>,
      truth_indices_Arg: 'static,
      truth_values_Arg: Clone,
      truth_values_Arg: GraphEdge<T>,
      truth_values_Arg: 'static,
      truth_shape_Arg: Clone,
      truth_shape_Arg: GraphEdge<i64>,
      truth_shape_Arg: 'static,
      T: 'static,
{
    pub fn output(self) -> Edge<f32> {
        let rc = Rc::new(self);
        {
            Edge::<f32>::new(rc.clone(), 0)
        }
    }

    pub fn normalize(&mut self, normalize: bool) -> Self {
        self.normalize = Some(normalize);
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<f32> {
        let rc = Rc::new(self);
        {
            Edge::<f32>::new(rc.clone(), 0)
        }
    }

    pub fn build(hypothesis_indices: hypothesis_indices_Arg, hypothesis_values: hypothesis_values_Arg, hypothesis_shape: hypothesis_shape_Arg, truth_indices: truth_indices_Arg, truth_values: truth_values_Arg, truth_shape: truth_shape_Arg) -> Self {
        Self {
            hypothesis_indices,
            phantom_T: PhantomData,
            hypothesis_values,
            hypothesis_shape,
            truth_indices,
            truth_values,
            truth_shape,
            normalize: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(hypothesis_indices: hypothesis_indices_Arg, hypothesis_values: hypothesis_values_Arg, hypothesis_shape: hypothesis_shape_Arg, truth_indices: truth_indices_Arg, truth_values: truth_values_Arg, truth_shape: truth_shape_Arg) -> Edge<f32> {
        Self {
            hypothesis_indices,
            phantom_T: PhantomData,
            hypothesis_values,
            hypothesis_shape,
            truth_indices,
            truth_values,
            truth_shape,
            normalize: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<handle_Arg> GraphOperation for AccumulatorNumAccumulated<handle_Arg>
where handle_Arg: Clone,
      handle_Arg: GraphRefEdge<String>,
      handle_Arg: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("AccumulatorNumAccumulated_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("AccumulatorNumAccumulated", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.handle)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct AccumulatorNumAccumulated<handle_Arg>
where handle_Arg: Clone,
      handle_Arg: GraphRefEdge<String>,
      handle_Arg: 'static,
{
    handle: handle_Arg,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<handle_Arg> AccumulatorNumAccumulated<handle_Arg>
where handle_Arg: Clone,
      handle_Arg: GraphRefEdge<String>,
      handle_Arg: 'static,
{
    pub fn num_accumulated(self) -> Edge<i32> {
        let rc = Rc::new(self);
        {
            Edge::<i32>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<i32> {
        let rc = Rc::new(self);
        {
            Edge::<i32>::new(rc.clone(), 0)
        }
    }

    pub fn build(handle: handle_Arg) -> Self {
        Self {
            handle,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(handle: handle_Arg) -> Edge<i32> {
        Self {
            handle,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

pub trait con_or_DT_INT32_or_DT_UINT8_or_DT_INT64 {
}

impl con_or_DT_INT32_or_DT_UINT8_or_DT_INT64 for i32 {
}

impl con_or_DT_INT32_or_DT_UINT8_or_DT_INT64 for i64 {
}

impl con_or_DT_INT32_or_DT_UINT8_or_DT_INT64 for u8 {
}

impl<TI, indices_Arg, depth_Arg, T, on_value_Arg, off_value_Arg> GraphOperation for OneHot<TI, indices_Arg, depth_Arg, T, on_value_Arg, off_value_Arg>
where TI: TensorType,
      TI: Clone,
      indices_Arg: Clone,
      indices_Arg: GraphEdge<TI>,
      indices_Arg: 'static,
      depth_Arg: Clone,
      depth_Arg: GraphEdge<i32>,
      depth_Arg: 'static,
      T: TensorType,
      T: Clone,
      on_value_Arg: Clone,
      on_value_Arg: GraphEdge<T>,
      on_value_Arg: 'static,
      off_value_Arg: Clone,
      off_value_Arg: GraphEdge<T>,
      off_value_Arg: 'static,
      T: 'static,
      TI: con_or_DT_INT32_or_DT_UINT8_or_DT_INT64,
      TI: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("OneHot_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("OneHot", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.indices)?
        }
        {
            new_op.add_edge(&self.depth)?
        }
        {
            new_op.add_edge(&self.on_value)?
        }
        {
            new_op.add_edge(&self.off_value)?
        }
        {
            match self.axis {
                None => new_op.set_attr_value_proto("axis", &vec![24_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 1_u8,])?,
                Some(ref value) => (|attr: &i64| {new_op.set_attr_int("axis", *attr)})(&value)?,
            };
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        {
            new_op.set_attr_type("TI", TI::data_type())?;
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct OneHot<TI, indices_Arg, depth_Arg, T, on_value_Arg, off_value_Arg>
where TI: TensorType,
      TI: Clone,
      indices_Arg: Clone,
      indices_Arg: GraphEdge<TI>,
      indices_Arg: 'static,
      depth_Arg: Clone,
      depth_Arg: GraphEdge<i32>,
      depth_Arg: 'static,
      T: TensorType,
      T: Clone,
      on_value_Arg: Clone,
      on_value_Arg: GraphEdge<T>,
      on_value_Arg: 'static,
      off_value_Arg: Clone,
      off_value_Arg: GraphEdge<T>,
      off_value_Arg: 'static,
      T: 'static,
      TI: con_or_DT_INT32_or_DT_UINT8_or_DT_INT64,
      TI: 'static,
{
    phantom_TI: PhantomData<TI>,
    indices: indices_Arg,
    depth: depth_Arg,
    phantom_T: PhantomData<T>,
    on_value: on_value_Arg,
    off_value: off_value_Arg,
    axis: Option<i64>,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<TI, indices_Arg, depth_Arg, T, on_value_Arg, off_value_Arg> OneHot<TI, indices_Arg, depth_Arg, T, on_value_Arg, off_value_Arg>
where TI: TensorType,
      TI: Clone,
      indices_Arg: Clone,
      indices_Arg: GraphEdge<TI>,
      indices_Arg: 'static,
      depth_Arg: Clone,
      depth_Arg: GraphEdge<i32>,
      depth_Arg: 'static,
      T: TensorType,
      T: Clone,
      on_value_Arg: Clone,
      on_value_Arg: GraphEdge<T>,
      on_value_Arg: 'static,
      off_value_Arg: Clone,
      off_value_Arg: GraphEdge<T>,
      off_value_Arg: 'static,
      T: 'static,
      TI: con_or_DT_INT32_or_DT_UINT8_or_DT_INT64,
      TI: 'static,
{
    pub fn output(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn axis(&mut self, axis: i64) -> Self {
        self.axis = Some(axis);
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(indices: indices_Arg, depth: depth_Arg, on_value: on_value_Arg, off_value: off_value_Arg) -> Self {
        Self {
            phantom_TI: PhantomData,
            indices,
            depth,
            phantom_T: PhantomData,
            on_value,
            off_value,
            axis: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(indices: indices_Arg, depth: depth_Arg, on_value: on_value_Arg, off_value: off_value_Arg) -> Edge<T> {
        Self {
            phantom_TI: PhantomData,
            indices,
            depth,
            phantom_T: PhantomData,
            on_value,
            off_value,
            axis: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<T, x_Arg, Tperm, perm_Arg> GraphOperation for ConjugateTranspose<T, x_Arg, Tperm, perm_Arg>
where T: TensorType,
      T: Clone,
      x_Arg: Clone,
      x_Arg: GraphEdge<T>,
      x_Arg: 'static,
      Tperm: TensorType,
      Tperm: Clone,
      perm_Arg: Clone,
      perm_Arg: GraphEdge<Tperm>,
      perm_Arg: 'static,
      T: 'static,
      Tperm: con_or_DT_INT32_or_DT_INT64,
      Tperm: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("ConjugateTranspose_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("ConjugateTranspose", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.x)?
        }
        {
            new_op.add_edge(&self.perm)?
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        {
            new_op.set_attr_type("Tperm", Tperm::data_type())?;
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct ConjugateTranspose<T, x_Arg, Tperm, perm_Arg>
where T: TensorType,
      T: Clone,
      x_Arg: Clone,
      x_Arg: GraphEdge<T>,
      x_Arg: 'static,
      Tperm: TensorType,
      Tperm: Clone,
      perm_Arg: Clone,
      perm_Arg: GraphEdge<Tperm>,
      perm_Arg: 'static,
      T: 'static,
      Tperm: con_or_DT_INT32_or_DT_INT64,
      Tperm: 'static,
{
    phantom_T: PhantomData<T>,
    x: x_Arg,
    phantom_Tperm: PhantomData<Tperm>,
    perm: perm_Arg,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<T, x_Arg, Tperm, perm_Arg> ConjugateTranspose<T, x_Arg, Tperm, perm_Arg>
where T: TensorType,
      T: Clone,
      x_Arg: Clone,
      x_Arg: GraphEdge<T>,
      x_Arg: 'static,
      Tperm: TensorType,
      Tperm: Clone,
      perm_Arg: Clone,
      perm_Arg: GraphEdge<Tperm>,
      perm_Arg: 'static,
      T: 'static,
      Tperm: con_or_DT_INT32_or_DT_INT64,
      Tperm: 'static,
{
    pub fn y(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(x: x_Arg, perm: perm_Arg) -> Self {
        Self {
            phantom_T: PhantomData,
            x,
            phantom_Tperm: PhantomData,
            perm,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(x: x_Arg, perm: perm_Arg) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            x,
            phantom_Tperm: PhantomData,
            perm,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

pub trait con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BOOL_or_DT_HALF {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BOOL_or_DT_HALF for bool {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BOOL_or_DT_HALF for f32 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BOOL_or_DT_HALF for f64 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BOOL_or_DT_HALF for i16 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BOOL_or_DT_HALF for i32 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BOOL_or_DT_HALF for i64 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BOOL_or_DT_HALF for i8 {
}

impl<T, input_Arg, threshold_Arg> GraphOperation for CompareAndBitpack<T, input_Arg, threshold_Arg>
where T: TensorType,
      T: Clone,
      input_Arg: Clone,
      input_Arg: GraphEdge<T>,
      input_Arg: 'static,
      threshold_Arg: Clone,
      threshold_Arg: GraphEdge<T>,
      threshold_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BOOL_or_DT_HALF,
      T: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("CompareAndBitpack_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("CompareAndBitpack", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.input)?
        }
        {
            new_op.add_edge(&self.threshold)?
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct CompareAndBitpack<T, input_Arg, threshold_Arg>
where T: TensorType,
      T: Clone,
      input_Arg: Clone,
      input_Arg: GraphEdge<T>,
      input_Arg: 'static,
      threshold_Arg: Clone,
      threshold_Arg: GraphEdge<T>,
      threshold_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BOOL_or_DT_HALF,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    input: input_Arg,
    threshold: threshold_Arg,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<T, input_Arg, threshold_Arg> CompareAndBitpack<T, input_Arg, threshold_Arg>
where T: TensorType,
      T: Clone,
      input_Arg: Clone,
      input_Arg: GraphEdge<T>,
      input_Arg: 'static,
      threshold_Arg: Clone,
      threshold_Arg: GraphEdge<T>,
      threshold_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BOOL_or_DT_HALF,
      T: 'static,
{
    pub fn output(self) -> Edge<u8> {
        let rc = Rc::new(self);
        {
            Edge::<u8>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<u8> {
        let rc = Rc::new(self);
        {
            Edge::<u8>::new(rc.clone(), 0)
        }
    }

    pub fn build(input: input_Arg, threshold: threshold_Arg) -> Self {
        Self {
            phantom_T: PhantomData,
            input,
            threshold,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(input: input_Arg, threshold: threshold_Arg) -> Edge<u8> {
        Self {
            phantom_T: PhantomData,
            input,
            threshold,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl GraphOperation for RetrieveTPUEmbeddingAdagradParameters {
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("RetrieveTPUEmbeddingAdagradParameters_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("RetrieveTPUEmbeddingAdagradParameters", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            match self.table_id {
                None => new_op.set_attr_value_proto("table_id", &vec![24_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 1_u8,])?,
                Some(ref value) => (|attr: &i64| {new_op.set_attr_int("table_id", *attr)})(&value)?,
            };
        }
        {
            match self.table_name {
                None => new_op.set_attr_value_proto("table_name", &vec![18_u8, 0_u8,])?,
                Some(ref value) => (|attr| {new_op.set_attr_string("table_name", attr)})(&value)?,
            };
        }
        {
            (|attr: &i64| {new_op.set_attr_int("num_shards", *attr)})(&self.num_shards)?
        }
        {
            (|attr: &i64| {new_op.set_attr_int("shard_id", *attr)})(&self.shard_id)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct RetrieveTPUEmbeddingAdagradParameters {
    table_id: Option<i64>,
    table_name: Option<String>,
    num_shards: i64,
    shard_id: i64,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl RetrieveTPUEmbeddingAdagradParameters {
    pub fn parameters(self) -> Edge<f32> {
        let rc = Rc::new(self);
        {
            Edge::<f32>::new(rc.clone(), 0)
        }
    }

    pub fn accumulators(self) -> Edge<f32> {
        let rc = Rc::new(self);
        {
            Edge::<f32>::new(rc.clone(), 1)
        }
    }

    pub fn table_id(&mut self, table_id: i64) -> Self {
        self.table_id = Some(table_id);
        self.clone()
    }

    pub fn table_name(&mut self, table_name: &str) -> Self {
        self.table_name = Some(table_name.to_string());
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> (Edge<f32>, Edge<f32>) {
        let rc = Rc::new(self);
        (
        {
            Edge::<f32>::new(rc.clone(), 0)
        },
        {
            Edge::<f32>::new(rc.clone(), 1)
        },
        )
    }

    pub fn build(num_shards: i64, shard_id: i64) -> Self {
        Self {
            table_id: None,
            table_name: None,
            num_shards: num_shards,
            shard_id: shard_id,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(num_shards: i64, shard_id: i64) -> (Edge<f32>, Edge<f32>) {
        Self {
            table_id: None,
            table_name: None,
            num_shards: num_shards,
            shard_id: shard_id,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<T, ref__Arg> GraphOperation for CountUpTo<T, ref__Arg>
where T: TensorType,
      T: Clone,
      ref__Arg: Clone,
      ref__Arg: GraphRefEdge<T>,
      ref__Arg: 'static,
      T: con_or_DT_INT32_or_DT_INT64,
      T: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("CountUpTo_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("CountUpTo", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.ref_)?
        }
        {
            (|attr: &i64| {new_op.set_attr_int("limit", *attr)})(&self.limit)?
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct CountUpTo<T, ref__Arg>
where T: TensorType,
      T: Clone,
      ref__Arg: Clone,
      ref__Arg: GraphRefEdge<T>,
      ref__Arg: 'static,
      T: con_or_DT_INT32_or_DT_INT64,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    ref_: ref__Arg,
    limit: i64,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<T, ref__Arg> CountUpTo<T, ref__Arg>
where T: TensorType,
      T: Clone,
      ref__Arg: Clone,
      ref__Arg: GraphRefEdge<T>,
      ref__Arg: 'static,
      T: con_or_DT_INT32_or_DT_INT64,
      T: 'static,
{
    pub fn output(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(ref_: ref__Arg, limit: i64) -> Self {
        Self {
            phantom_T: PhantomData,
            ref_,
            limit: limit,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(ref_: ref__Arg, limit: i64) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            ref_,
            limit: limit,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<num_layers_Arg, num_units_Arg, input_size_Arg, T, weights_Arg, biases_Arg> GraphOperation for CudnnRNNCanonicalToParams<num_layers_Arg, num_units_Arg, input_size_Arg, T, weights_Arg, biases_Arg>
where num_layers_Arg: Clone,
      num_layers_Arg: GraphEdge<i32>,
      num_layers_Arg: 'static,
      num_units_Arg: Clone,
      num_units_Arg: GraphEdge<i32>,
      num_units_Arg: 'static,
      input_size_Arg: Clone,
      input_size_Arg: GraphEdge<i32>,
      input_size_Arg: 'static,
      T: TensorType,
      T: Clone,
      weights_Arg: Clone,
      weights_Arg: GraphEdge<T>,
      weights_Arg: 'static,
      biases_Arg: Clone,
      biases_Arg: GraphEdge<T>,
      biases_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_HALF,
      T: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("CudnnRNNCanonicalToParams_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("CudnnRNNCanonicalToParams", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.num_layers)?
        }
        {
            new_op.add_edge(&self.num_units)?
        }
        {
            new_op.add_edge(&self.input_size)?
        }
        {
            new_op.add_edge(&self.weights)?
        }
        {
            new_op.add_edge(&self.biases)?
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        {
            (|attr: &i64| {new_op.set_attr_int("num_params", *attr)})(&self.num_params)?
        }
        {
            match self.rnn_mode {
                None => new_op.set_attr_value_proto("rnn_mode", &vec![18_u8, 4_u8, 108_u8, 115_u8, 116_u8, 109_u8,])?,
                Some(ref value) => (|attr| {new_op.set_attr_string("rnn_mode", attr)})(&value)?,
            };
        }
        {
            match self.input_mode {
                None => new_op.set_attr_value_proto("input_mode", &vec![18_u8, 12_u8, 108_u8, 105_u8, 110_u8, 101_u8, 97_u8, 114_u8, 95_u8, 105_u8, 110_u8, 112_u8, 117_u8, 116_u8,])?,
                Some(ref value) => (|attr| {new_op.set_attr_string("input_mode", attr)})(&value)?,
            };
        }
        {
            match self.direction {
                None => new_op.set_attr_value_proto("direction", &vec![18_u8, 14_u8, 117_u8, 110_u8, 105_u8, 100_u8, 105_u8, 114_u8, 101_u8, 99_u8, 116_u8, 105_u8, 111_u8, 110_u8, 97_u8, 108_u8,])?,
                Some(ref value) => (|attr| {new_op.set_attr_string("direction", attr)})(&value)?,
            };
        }
        {
            match self.dropout {
                None => new_op.set_attr_value_proto("dropout", &vec![37_u8, 0_u8, 0_u8, 0_u8, 0_u8,])?,
                Some(ref value) => (|attr: &f32| {new_op.set_attr_float("dropout", *attr)})(&value)?,
            };
        }
        {
            match self.seed {
                None => new_op.set_attr_value_proto("seed", &vec![24_u8, 0_u8,])?,
                Some(ref value) => (|attr: &i64| {new_op.set_attr_int("seed", *attr)})(&value)?,
            };
        }
        {
            match self.seed2 {
                None => new_op.set_attr_value_proto("seed2", &vec![24_u8, 0_u8,])?,
                Some(ref value) => (|attr: &i64| {new_op.set_attr_int("seed2", *attr)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct CudnnRNNCanonicalToParams<num_layers_Arg, num_units_Arg, input_size_Arg, T, weights_Arg, biases_Arg>
where num_layers_Arg: Clone,
      num_layers_Arg: GraphEdge<i32>,
      num_layers_Arg: 'static,
      num_units_Arg: Clone,
      num_units_Arg: GraphEdge<i32>,
      num_units_Arg: 'static,
      input_size_Arg: Clone,
      input_size_Arg: GraphEdge<i32>,
      input_size_Arg: 'static,
      T: TensorType,
      T: Clone,
      weights_Arg: Clone,
      weights_Arg: GraphEdge<T>,
      weights_Arg: 'static,
      biases_Arg: Clone,
      biases_Arg: GraphEdge<T>,
      biases_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_HALF,
      T: 'static,
{
    num_layers: num_layers_Arg,
    num_units: num_units_Arg,
    input_size: input_size_Arg,
    phantom_T: PhantomData<T>,
    weights: weights_Arg,
    biases: biases_Arg,
    num_params: i64,
    rnn_mode: Option<String>,
    input_mode: Option<String>,
    direction: Option<String>,
    dropout: Option<f32>,
    seed: Option<i64>,
    seed2: Option<i64>,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<num_layers_Arg, num_units_Arg, input_size_Arg, T, weights_Arg, biases_Arg> CudnnRNNCanonicalToParams<num_layers_Arg, num_units_Arg, input_size_Arg, T, weights_Arg, biases_Arg>
where num_layers_Arg: Clone,
      num_layers_Arg: GraphEdge<i32>,
      num_layers_Arg: 'static,
      num_units_Arg: Clone,
      num_units_Arg: GraphEdge<i32>,
      num_units_Arg: 'static,
      input_size_Arg: Clone,
      input_size_Arg: GraphEdge<i32>,
      input_size_Arg: 'static,
      T: TensorType,
      T: Clone,
      weights_Arg: Clone,
      weights_Arg: GraphEdge<T>,
      weights_Arg: 'static,
      biases_Arg: Clone,
      biases_Arg: GraphEdge<T>,
      biases_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_HALF,
      T: 'static,
{
    pub fn params(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn rnn_mode(&mut self, rnn_mode: &str) -> Self {
        self.rnn_mode = Some(rnn_mode.to_string());
        self.clone()
    }

    pub fn input_mode(&mut self, input_mode: &str) -> Self {
        self.input_mode = Some(input_mode.to_string());
        self.clone()
    }

    pub fn direction(&mut self, direction: &str) -> Self {
        self.direction = Some(direction.to_string());
        self.clone()
    }

    pub fn dropout(&mut self, dropout: f32) -> Self {
        self.dropout = Some(dropout);
        self.clone()
    }

    pub fn seed(&mut self, seed: i64) -> Self {
        self.seed = Some(seed);
        self.clone()
    }

    pub fn seed2(&mut self, seed2: i64) -> Self {
        self.seed2 = Some(seed2);
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(num_layers: num_layers_Arg, num_units: num_units_Arg, input_size: input_size_Arg, weights: weights_Arg, biases: biases_Arg, num_params: i64) -> Self {
        Self {
            num_layers,
            num_units,
            input_size,
            phantom_T: PhantomData,
            weights,
            biases,
            num_params: num_params,
            rnn_mode: None,
            input_mode: None,
            direction: None,
            dropout: None,
            seed: None,
            seed2: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(num_layers: num_layers_Arg, num_units: num_units_Arg, input_size: input_size_Arg, weights: weights_Arg, biases: biases_Arg, num_params: i64) -> Edge<T> {
        Self {
            num_layers,
            num_units,
            input_size,
            phantom_T: PhantomData,
            weights,
            biases,
            num_params: num_params,
            rnn_mode: None,
            input_mode: None,
            direction: None,
            dropout: None,
            seed: None,
            seed2: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<Ta, a_Arg, Tb, b_Arg> GraphOperation for SparseMatMul<Ta, a_Arg, Tb, b_Arg>
where Ta: TensorType,
      Ta: Clone,
      a_Arg: Clone,
      a_Arg: GraphEdge<Ta>,
      a_Arg: 'static,
      Tb: TensorType,
      Tb: Clone,
      b_Arg: Clone,
      b_Arg: GraphEdge<Tb>,
      b_Arg: 'static,
      Ta: con_or_DT_FLOAT_or_DT_BFLOAT16,
      Ta: 'static,
      Tb: con_or_DT_FLOAT_or_DT_BFLOAT16,
      Tb: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("SparseMatMul_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("SparseMatMul", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.a)?
        }
        {
            new_op.add_edge(&self.b)?
        }
        {
            match self.transpose_a {
                None => new_op.set_attr_value_proto("transpose_a", &vec![40_u8, 0_u8,])?,
                Some(ref value) => (|attr: &bool| {new_op.set_attr_bool("transpose_a", *attr)})(&value)?,
            };
        }
        {
            match self.transpose_b {
                None => new_op.set_attr_value_proto("transpose_b", &vec![40_u8, 0_u8,])?,
                Some(ref value) => (|attr: &bool| {new_op.set_attr_bool("transpose_b", *attr)})(&value)?,
            };
        }
        {
            match self.a_is_sparse {
                None => new_op.set_attr_value_proto("a_is_sparse", &vec![40_u8, 0_u8,])?,
                Some(ref value) => (|attr: &bool| {new_op.set_attr_bool("a_is_sparse", *attr)})(&value)?,
            };
        }
        {
            match self.b_is_sparse {
                None => new_op.set_attr_value_proto("b_is_sparse", &vec![40_u8, 0_u8,])?,
                Some(ref value) => (|attr: &bool| {new_op.set_attr_bool("b_is_sparse", *attr)})(&value)?,
            };
        }
        {
            new_op.set_attr_type("Ta", Ta::data_type())?;
        }
        {
            new_op.set_attr_type("Tb", Tb::data_type())?;
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct SparseMatMul<Ta, a_Arg, Tb, b_Arg>
where Ta: TensorType,
      Ta: Clone,
      a_Arg: Clone,
      a_Arg: GraphEdge<Ta>,
      a_Arg: 'static,
      Tb: TensorType,
      Tb: Clone,
      b_Arg: Clone,
      b_Arg: GraphEdge<Tb>,
      b_Arg: 'static,
      Ta: con_or_DT_FLOAT_or_DT_BFLOAT16,
      Ta: 'static,
      Tb: con_or_DT_FLOAT_or_DT_BFLOAT16,
      Tb: 'static,
{
    phantom_Ta: PhantomData<Ta>,
    a: a_Arg,
    phantom_Tb: PhantomData<Tb>,
    b: b_Arg,
    transpose_a: Option<bool>,
    transpose_b: Option<bool>,
    a_is_sparse: Option<bool>,
    b_is_sparse: Option<bool>,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<Ta, a_Arg, Tb, b_Arg> SparseMatMul<Ta, a_Arg, Tb, b_Arg>
where Ta: TensorType,
      Ta: Clone,
      a_Arg: Clone,
      a_Arg: GraphEdge<Ta>,
      a_Arg: 'static,
      Tb: TensorType,
      Tb: Clone,
      b_Arg: Clone,
      b_Arg: GraphEdge<Tb>,
      b_Arg: 'static,
      Ta: con_or_DT_FLOAT_or_DT_BFLOAT16,
      Ta: 'static,
      Tb: con_or_DT_FLOAT_or_DT_BFLOAT16,
      Tb: 'static,
{
    pub fn product(self) -> Edge<f32> {
        let rc = Rc::new(self);
        {
            Edge::<f32>::new(rc.clone(), 0)
        }
    }

    pub fn transpose_a(&mut self, transpose_a: bool) -> Self {
        self.transpose_a = Some(transpose_a);
        self.clone()
    }

    pub fn transpose_b(&mut self, transpose_b: bool) -> Self {
        self.transpose_b = Some(transpose_b);
        self.clone()
    }

    pub fn a_is_sparse(&mut self, a_is_sparse: bool) -> Self {
        self.a_is_sparse = Some(a_is_sparse);
        self.clone()
    }

    pub fn b_is_sparse(&mut self, b_is_sparse: bool) -> Self {
        self.b_is_sparse = Some(b_is_sparse);
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<f32> {
        let rc = Rc::new(self);
        {
            Edge::<f32>::new(rc.clone(), 0)
        }
    }

    pub fn build(a: a_Arg, b: b_Arg) -> Self {
        Self {
            phantom_Ta: PhantomData,
            a,
            phantom_Tb: PhantomData,
            b,
            transpose_a: None,
            transpose_b: None,
            a_is_sparse: None,
            b_is_sparse: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(a: a_Arg, b: b_Arg) -> Edge<f32> {
        Self {
            phantom_Ta: PhantomData,
            a,
            phantom_Tb: PhantomData,
            b,
            transpose_a: None,
            transpose_b: None,
            a_is_sparse: None,
            b_is_sparse: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<embedding_variable_Arg, sliced_activations_Arg> GraphOperation for TPUEmbeddingActivations<embedding_variable_Arg, sliced_activations_Arg>
where embedding_variable_Arg: Clone,
      embedding_variable_Arg: GraphEdge<f32>,
      embedding_variable_Arg: 'static,
      sliced_activations_Arg: Clone,
      sliced_activations_Arg: GraphEdge<f32>,
      sliced_activations_Arg: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("TPUEmbeddingActivations_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("TPUEmbeddingActivations", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.embedding_variable)?
        }
        {
            new_op.add_edge(&self.sliced_activations)?
        }
        {
            (|attr: &i64| {new_op.set_attr_int("table_id", *attr)})(&self.table_id)?
        }
        {
            (|attr: &i64| {new_op.set_attr_int("lookup_id", *attr)})(&self.lookup_id)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct TPUEmbeddingActivations<embedding_variable_Arg, sliced_activations_Arg>
where embedding_variable_Arg: Clone,
      embedding_variable_Arg: GraphEdge<f32>,
      embedding_variable_Arg: 'static,
      sliced_activations_Arg: Clone,
      sliced_activations_Arg: GraphEdge<f32>,
      sliced_activations_Arg: 'static,
{
    embedding_variable: embedding_variable_Arg,
    sliced_activations: sliced_activations_Arg,
    table_id: i64,
    lookup_id: i64,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<embedding_variable_Arg, sliced_activations_Arg> TPUEmbeddingActivations<embedding_variable_Arg, sliced_activations_Arg>
where embedding_variable_Arg: Clone,
      embedding_variable_Arg: GraphEdge<f32>,
      embedding_variable_Arg: 'static,
      sliced_activations_Arg: Clone,
      sliced_activations_Arg: GraphEdge<f32>,
      sliced_activations_Arg: 'static,
{
    pub fn output(self) -> Edge<f32> {
        let rc = Rc::new(self);
        {
            Edge::<f32>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<f32> {
        let rc = Rc::new(self);
        {
            Edge::<f32>::new(rc.clone(), 0)
        }
    }

    pub fn build(embedding_variable: embedding_variable_Arg, sliced_activations: sliced_activations_Arg, table_id: i64, lookup_id: i64) -> Self {
        Self {
            embedding_variable,
            sliced_activations,
            table_id: table_id,
            lookup_id: lookup_id,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(embedding_variable: embedding_variable_Arg, sliced_activations: sliced_activations_Arg, table_id: i64, lookup_id: i64) -> Edge<f32> {
        Self {
            embedding_variable,
            sliced_activations,
            table_id: table_id,
            lookup_id: lookup_id,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<T, x_Arg, i_Arg, v_Arg> GraphOperation for InplaceSub<T, x_Arg, i_Arg, v_Arg>
where T: TensorType,
      T: Clone,
      x_Arg: Clone,
      x_Arg: GraphEdge<T>,
      x_Arg: 'static,
      i_Arg: Clone,
      i_Arg: GraphEdge<i32>,
      i_Arg: 'static,
      v_Arg: Clone,
      v_Arg: GraphEdge<T>,
      v_Arg: 'static,
      T: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("InplaceSub_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("InplaceSub", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.x)?
        }
        {
            new_op.add_edge(&self.i)?
        }
        {
            new_op.add_edge(&self.v)?
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct InplaceSub<T, x_Arg, i_Arg, v_Arg>
where T: TensorType,
      T: Clone,
      x_Arg: Clone,
      x_Arg: GraphEdge<T>,
      x_Arg: 'static,
      i_Arg: Clone,
      i_Arg: GraphEdge<i32>,
      i_Arg: 'static,
      v_Arg: Clone,
      v_Arg: GraphEdge<T>,
      v_Arg: 'static,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    x: x_Arg,
    i: i_Arg,
    v: v_Arg,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<T, x_Arg, i_Arg, v_Arg> InplaceSub<T, x_Arg, i_Arg, v_Arg>
where T: TensorType,
      T: Clone,
      x_Arg: Clone,
      x_Arg: GraphEdge<T>,
      x_Arg: 'static,
      i_Arg: Clone,
      i_Arg: GraphEdge<i32>,
      i_Arg: 'static,
      v_Arg: Clone,
      v_Arg: GraphEdge<T>,
      v_Arg: 'static,
      T: 'static,
{
    pub fn y(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(x: x_Arg, i: i_Arg, v: v_Arg) -> Self {
        Self {
            phantom_T: PhantomData,
            x,
            i,
            v,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(x: x_Arg, i: i_Arg, v: v_Arg) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            x,
            i,
            v,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<parameters_Arg, ms_Arg, mom_Arg> GraphOperation for LoadTPUEmbeddingRMSPropParameters<parameters_Arg, ms_Arg, mom_Arg>
where parameters_Arg: Clone,
      parameters_Arg: GraphEdge<f32>,
      parameters_Arg: 'static,
      ms_Arg: Clone,
      ms_Arg: GraphEdge<f32>,
      ms_Arg: 'static,
      mom_Arg: Clone,
      mom_Arg: GraphEdge<f32>,
      mom_Arg: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("LoadTPUEmbeddingRMSPropParameters_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("LoadTPUEmbeddingRMSPropParameters", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.parameters)?
        }
        {
            new_op.add_edge(&self.ms)?
        }
        {
            new_op.add_edge(&self.mom)?
        }
        {
            match self.table_id {
                None => new_op.set_attr_value_proto("table_id", &vec![24_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 1_u8,])?,
                Some(ref value) => (|attr: &i64| {new_op.set_attr_int("table_id", *attr)})(&value)?,
            };
        }
        {
            match self.table_name {
                None => new_op.set_attr_value_proto("table_name", &vec![18_u8, 0_u8,])?,
                Some(ref value) => (|attr| {new_op.set_attr_string("table_name", attr)})(&value)?,
            };
        }
        {
            (|attr: &i64| {new_op.set_attr_int("num_shards", *attr)})(&self.num_shards)?
        }
        {
            (|attr: &i64| {new_op.set_attr_int("shard_id", *attr)})(&self.shard_id)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct LoadTPUEmbeddingRMSPropParameters<parameters_Arg, ms_Arg, mom_Arg>
where parameters_Arg: Clone,
      parameters_Arg: GraphEdge<f32>,
      parameters_Arg: 'static,
      ms_Arg: Clone,
      ms_Arg: GraphEdge<f32>,
      ms_Arg: 'static,
      mom_Arg: Clone,
      mom_Arg: GraphEdge<f32>,
      mom_Arg: 'static,
{
    parameters: parameters_Arg,
    ms: ms_Arg,
    mom: mom_Arg,
    table_id: Option<i64>,
    table_name: Option<String>,
    num_shards: i64,
    shard_id: i64,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<parameters_Arg, ms_Arg, mom_Arg> LoadTPUEmbeddingRMSPropParameters<parameters_Arg, ms_Arg, mom_Arg>
where parameters_Arg: Clone,
      parameters_Arg: GraphEdge<f32>,
      parameters_Arg: 'static,
      ms_Arg: Clone,
      ms_Arg: GraphEdge<f32>,
      ms_Arg: 'static,
      mom_Arg: Clone,
      mom_Arg: GraphEdge<f32>,
      mom_Arg: 'static,
{
    pub fn table_id(&mut self, table_id: i64) -> Self {
        self.table_id = Some(table_id);
        self.clone()
    }

    pub fn table_name(&mut self, table_name: &str) -> Self {
        self.table_name = Some(table_name.to_string());
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> () {
        let rc = Rc::new(self);
        (
        )
    }

    pub fn build(parameters: parameters_Arg, ms: ms_Arg, mom: mom_Arg, num_shards: i64, shard_id: i64) -> Self {
        Self {
            parameters,
            ms,
            mom,
            table_id: None,
            table_name: None,
            num_shards: num_shards,
            shard_id: shard_id,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(parameters: parameters_Arg, ms: ms_Arg, mom: mom_Arg, num_shards: i64, shard_id: i64) -> () {
        Self {
            parameters,
            ms,
            mom,
            table_id: None,
            table_name: None,
            num_shards: num_shards,
            shard_id: shard_id,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<T, input_Arg> GraphOperation for Copy<T, input_Arg>
where T: TensorType,
      T: Clone,
      input_Arg: Clone,
      input_Arg: GraphEdge<T>,
      input_Arg: 'static,
      T: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("Copy_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("Copy", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.input)?
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        {
            match self.tensor_name {
                None => new_op.set_attr_value_proto("tensor_name", &vec![18_u8, 0_u8,])?,
                Some(ref value) => (|attr| {new_op.set_attr_string("tensor_name", attr)})(&value)?,
            };
        }
        {
            match self.debug_ops_spec {
                None => new_op.set_attr_value_proto("debug_ops_spec", &vec![10_u8, 0_u8,])?,
                Some(ref value) => (|attrs| {new_op.set_attr_string_list("debug_ops_spec", attrs)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct Copy<T, input_Arg>
where T: TensorType,
      T: Clone,
      input_Arg: Clone,
      input_Arg: GraphEdge<T>,
      input_Arg: 'static,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    input: input_Arg,
    tensor_name: Option<String>,
    debug_ops_spec: Option<Vec<String>>,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<T, input_Arg> Copy<T, input_Arg>
where T: TensorType,
      T: Clone,
      input_Arg: Clone,
      input_Arg: GraphEdge<T>,
      input_Arg: 'static,
      T: 'static,
{
    pub fn output(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn tensor_name(&mut self, tensor_name: &str) -> Self {
        self.tensor_name = Some(tensor_name.to_string());
        self.clone()
    }

    pub fn debug_ops_spec(&mut self, debug_ops_spec: &[String]) -> Self {
        self.debug_ops_spec = Some(debug_ops_spec.to_vec());
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(input: input_Arg) -> Self {
        Self {
            phantom_T: PhantomData,
            input,
            tensor_name: None,
            debug_ops_spec: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(input: input_Arg) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            input,
            tensor_name: None,
            debug_ops_spec: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<Index, shape_Arg, begin_Arg, end_Arg, strides_Arg, T, dy_Arg> GraphOperation for StridedSliceGrad<Index, shape_Arg, begin_Arg, end_Arg, strides_Arg, T, dy_Arg>
where Index: TensorType,
      Index: Clone,
      shape_Arg: Clone,
      shape_Arg: GraphEdge<Index>,
      shape_Arg: 'static,
      begin_Arg: Clone,
      begin_Arg: GraphEdge<Index>,
      begin_Arg: 'static,
      end_Arg: Clone,
      end_Arg: GraphEdge<Index>,
      end_Arg: 'static,
      strides_Arg: Clone,
      strides_Arg: GraphEdge<Index>,
      strides_Arg: 'static,
      T: TensorType,
      T: Clone,
      dy_Arg: Clone,
      dy_Arg: GraphEdge<T>,
      dy_Arg: 'static,
      T: 'static,
      Index: con_or_DT_INT32_or_DT_INT64,
      Index: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("StridedSliceGrad_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("StridedSliceGrad", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.shape)?
        }
        {
            new_op.add_edge(&self.begin)?
        }
        {
            new_op.add_edge(&self.end)?
        }
        {
            new_op.add_edge(&self.strides)?
        }
        {
            new_op.add_edge(&self.dy)?
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        {
            new_op.set_attr_type("Index", Index::data_type())?;
        }
        {
            match self.begin_mask {
                None => new_op.set_attr_value_proto("begin_mask", &vec![24_u8, 0_u8,])?,
                Some(ref value) => (|attr: &i64| {new_op.set_attr_int("begin_mask", *attr)})(&value)?,
            };
        }
        {
            match self.end_mask {
                None => new_op.set_attr_value_proto("end_mask", &vec![24_u8, 0_u8,])?,
                Some(ref value) => (|attr: &i64| {new_op.set_attr_int("end_mask", *attr)})(&value)?,
            };
        }
        {
            match self.ellipsis_mask {
                None => new_op.set_attr_value_proto("ellipsis_mask", &vec![24_u8, 0_u8,])?,
                Some(ref value) => (|attr: &i64| {new_op.set_attr_int("ellipsis_mask", *attr)})(&value)?,
            };
        }
        {
            match self.new_axis_mask {
                None => new_op.set_attr_value_proto("new_axis_mask", &vec![24_u8, 0_u8,])?,
                Some(ref value) => (|attr: &i64| {new_op.set_attr_int("new_axis_mask", *attr)})(&value)?,
            };
        }
        {
            match self.shrink_axis_mask {
                None => new_op.set_attr_value_proto("shrink_axis_mask", &vec![24_u8, 0_u8,])?,
                Some(ref value) => (|attr: &i64| {new_op.set_attr_int("shrink_axis_mask", *attr)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct StridedSliceGrad<Index, shape_Arg, begin_Arg, end_Arg, strides_Arg, T, dy_Arg>
where Index: TensorType,
      Index: Clone,
      shape_Arg: Clone,
      shape_Arg: GraphEdge<Index>,
      shape_Arg: 'static,
      begin_Arg: Clone,
      begin_Arg: GraphEdge<Index>,
      begin_Arg: 'static,
      end_Arg: Clone,
      end_Arg: GraphEdge<Index>,
      end_Arg: 'static,
      strides_Arg: Clone,
      strides_Arg: GraphEdge<Index>,
      strides_Arg: 'static,
      T: TensorType,
      T: Clone,
      dy_Arg: Clone,
      dy_Arg: GraphEdge<T>,
      dy_Arg: 'static,
      T: 'static,
      Index: con_or_DT_INT32_or_DT_INT64,
      Index: 'static,
{
    phantom_Index: PhantomData<Index>,
    shape: shape_Arg,
    begin: begin_Arg,
    end: end_Arg,
    strides: strides_Arg,
    phantom_T: PhantomData<T>,
    dy: dy_Arg,
    begin_mask: Option<i64>,
    end_mask: Option<i64>,
    ellipsis_mask: Option<i64>,
    new_axis_mask: Option<i64>,
    shrink_axis_mask: Option<i64>,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<Index, shape_Arg, begin_Arg, end_Arg, strides_Arg, T, dy_Arg> StridedSliceGrad<Index, shape_Arg, begin_Arg, end_Arg, strides_Arg, T, dy_Arg>
where Index: TensorType,
      Index: Clone,
      shape_Arg: Clone,
      shape_Arg: GraphEdge<Index>,
      shape_Arg: 'static,
      begin_Arg: Clone,
      begin_Arg: GraphEdge<Index>,
      begin_Arg: 'static,
      end_Arg: Clone,
      end_Arg: GraphEdge<Index>,
      end_Arg: 'static,
      strides_Arg: Clone,
      strides_Arg: GraphEdge<Index>,
      strides_Arg: 'static,
      T: TensorType,
      T: Clone,
      dy_Arg: Clone,
      dy_Arg: GraphEdge<T>,
      dy_Arg: 'static,
      T: 'static,
      Index: con_or_DT_INT32_or_DT_INT64,
      Index: 'static,
{
    pub fn output(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn begin_mask(&mut self, begin_mask: i64) -> Self {
        self.begin_mask = Some(begin_mask);
        self.clone()
    }

    pub fn end_mask(&mut self, end_mask: i64) -> Self {
        self.end_mask = Some(end_mask);
        self.clone()
    }

    pub fn ellipsis_mask(&mut self, ellipsis_mask: i64) -> Self {
        self.ellipsis_mask = Some(ellipsis_mask);
        self.clone()
    }

    pub fn new_axis_mask(&mut self, new_axis_mask: i64) -> Self {
        self.new_axis_mask = Some(new_axis_mask);
        self.clone()
    }

    pub fn shrink_axis_mask(&mut self, shrink_axis_mask: i64) -> Self {
        self.shrink_axis_mask = Some(shrink_axis_mask);
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(shape: shape_Arg, begin: begin_Arg, end: end_Arg, strides: strides_Arg, dy: dy_Arg) -> Self {
        Self {
            phantom_Index: PhantomData,
            shape,
            begin,
            end,
            strides,
            phantom_T: PhantomData,
            dy,
            begin_mask: None,
            end_mask: None,
            ellipsis_mask: None,
            new_axis_mask: None,
            shrink_axis_mask: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(shape: shape_Arg, begin: begin_Arg, end: end_Arg, strides: strides_Arg, dy: dy_Arg) -> Edge<T> {
        Self {
            phantom_Index: PhantomData,
            shape,
            begin,
            end,
            strides,
            phantom_T: PhantomData,
            dy,
            begin_mask: None,
            end_mask: None,
            ellipsis_mask: None,
            new_axis_mask: None,
            shrink_axis_mask: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<Tidx, indices_Arg, dims_Arg> GraphOperation for UnravelIndex<Tidx, indices_Arg, dims_Arg>
where Tidx: TensorType,
      Tidx: Clone,
      indices_Arg: Clone,
      indices_Arg: GraphEdge<Tidx>,
      indices_Arg: 'static,
      dims_Arg: Clone,
      dims_Arg: GraphEdge<Tidx>,
      dims_Arg: 'static,
      Tidx: con_or_DT_INT32_or_DT_INT64,
      Tidx: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("UnravelIndex_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("UnravelIndex", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.indices)?
        }
        {
            new_op.add_edge(&self.dims)?
        }
        {
            new_op.set_attr_type("Tidx", Tidx::data_type())?;
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct UnravelIndex<Tidx, indices_Arg, dims_Arg>
where Tidx: TensorType,
      Tidx: Clone,
      indices_Arg: Clone,
      indices_Arg: GraphEdge<Tidx>,
      indices_Arg: 'static,
      dims_Arg: Clone,
      dims_Arg: GraphEdge<Tidx>,
      dims_Arg: 'static,
      Tidx: con_or_DT_INT32_or_DT_INT64,
      Tidx: 'static,
{
    phantom_Tidx: PhantomData<Tidx>,
    indices: indices_Arg,
    dims: dims_Arg,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<Tidx, indices_Arg, dims_Arg> UnravelIndex<Tidx, indices_Arg, dims_Arg>
where Tidx: TensorType,
      Tidx: Clone,
      indices_Arg: Clone,
      indices_Arg: GraphEdge<Tidx>,
      indices_Arg: 'static,
      dims_Arg: Clone,
      dims_Arg: GraphEdge<Tidx>,
      dims_Arg: 'static,
      Tidx: con_or_DT_INT32_or_DT_INT64,
      Tidx: 'static,
{
    pub fn output(self) -> Edge<Tidx> {
        let rc = Rc::new(self);
        {
            Edge::<Tidx>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<Tidx> {
        let rc = Rc::new(self);
        {
            Edge::<Tidx>::new(rc.clone(), 0)
        }
    }

    pub fn build(indices: indices_Arg, dims: dims_Arg) -> Self {
        Self {
            phantom_Tidx: PhantomData,
            indices,
            dims,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(indices: indices_Arg, dims: dims_Arg) -> Edge<Tidx> {
        Self {
            phantom_Tidx: PhantomData,
            indices,
            dims,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<T, tensor_Arg, Tindices, indices_Arg, updates_Arg> GraphOperation for TensorScatterUpdate<T, tensor_Arg, Tindices, indices_Arg, updates_Arg>
where T: TensorType,
      T: Clone,
      tensor_Arg: Clone,
      tensor_Arg: GraphEdge<T>,
      tensor_Arg: 'static,
      Tindices: TensorType,
      Tindices: Clone,
      indices_Arg: Clone,
      indices_Arg: GraphEdge<Tindices>,
      indices_Arg: 'static,
      updates_Arg: Clone,
      updates_Arg: GraphEdge<T>,
      updates_Arg: 'static,
      T: 'static,
      Tindices: con_or_DT_INT32_or_DT_INT64,
      Tindices: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("TensorScatterUpdate_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("TensorScatterUpdate", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.tensor)?
        }
        {
            new_op.add_edge(&self.indices)?
        }
        {
            new_op.add_edge(&self.updates)?
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        {
            new_op.set_attr_type("Tindices", Tindices::data_type())?;
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct TensorScatterUpdate<T, tensor_Arg, Tindices, indices_Arg, updates_Arg>
where T: TensorType,
      T: Clone,
      tensor_Arg: Clone,
      tensor_Arg: GraphEdge<T>,
      tensor_Arg: 'static,
      Tindices: TensorType,
      Tindices: Clone,
      indices_Arg: Clone,
      indices_Arg: GraphEdge<Tindices>,
      indices_Arg: 'static,
      updates_Arg: Clone,
      updates_Arg: GraphEdge<T>,
      updates_Arg: 'static,
      T: 'static,
      Tindices: con_or_DT_INT32_or_DT_INT64,
      Tindices: 'static,
{
    phantom_T: PhantomData<T>,
    tensor: tensor_Arg,
    phantom_Tindices: PhantomData<Tindices>,
    indices: indices_Arg,
    updates: updates_Arg,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<T, tensor_Arg, Tindices, indices_Arg, updates_Arg> TensorScatterUpdate<T, tensor_Arg, Tindices, indices_Arg, updates_Arg>
where T: TensorType,
      T: Clone,
      tensor_Arg: Clone,
      tensor_Arg: GraphEdge<T>,
      tensor_Arg: 'static,
      Tindices: TensorType,
      Tindices: Clone,
      indices_Arg: Clone,
      indices_Arg: GraphEdge<Tindices>,
      indices_Arg: 'static,
      updates_Arg: Clone,
      updates_Arg: GraphEdge<T>,
      updates_Arg: 'static,
      T: 'static,
      Tindices: con_or_DT_INT32_or_DT_INT64,
      Tindices: 'static,
{
    pub fn output(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(tensor: tensor_Arg, indices: indices_Arg, updates: updates_Arg) -> Self {
        Self {
            phantom_T: PhantomData,
            tensor,
            phantom_Tindices: PhantomData,
            indices,
            updates,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(tensor: tensor_Arg, indices: indices_Arg, updates: updates_Arg) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            tensor,
            phantom_Tindices: PhantomData,
            indices,
            updates,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<address_Arg, method_Arg, request_Arg> GraphOperation for Rpc<address_Arg, method_Arg, request_Arg>
where address_Arg: Clone,
      address_Arg: GraphEdge<String>,
      address_Arg: 'static,
      method_Arg: Clone,
      method_Arg: GraphEdge<String>,
      method_Arg: 'static,
      request_Arg: Clone,
      request_Arg: GraphEdge<String>,
      request_Arg: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("Rpc_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("Rpc", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.address)?
        }
        {
            new_op.add_edge(&self.method)?
        }
        {
            new_op.add_edge(&self.request)?
        }
        {
            match self.protocol {
                None => new_op.set_attr_value_proto("protocol", &vec![18_u8, 0_u8,])?,
                Some(ref value) => (|attr| {new_op.set_attr_string("protocol", attr)})(&value)?,
            };
        }
        {
            match self.fail_fast {
                None => new_op.set_attr_value_proto("fail_fast", &vec![40_u8, 1_u8,])?,
                Some(ref value) => (|attr: &bool| {new_op.set_attr_bool("fail_fast", *attr)})(&value)?,
            };
        }
        {
            match self.timeout_in_ms {
                None => new_op.set_attr_value_proto("timeout_in_ms", &vec![24_u8, 0_u8,])?,
                Some(ref value) => (|attr: &i64| {new_op.set_attr_int("timeout_in_ms", *attr)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct Rpc<address_Arg, method_Arg, request_Arg>
where address_Arg: Clone,
      address_Arg: GraphEdge<String>,
      address_Arg: 'static,
      method_Arg: Clone,
      method_Arg: GraphEdge<String>,
      method_Arg: 'static,
      request_Arg: Clone,
      request_Arg: GraphEdge<String>,
      request_Arg: 'static,
{
    address: address_Arg,
    method: method_Arg,
    request: request_Arg,
    protocol: Option<String>,
    fail_fast: Option<bool>,
    timeout_in_ms: Option<i64>,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<address_Arg, method_Arg, request_Arg> Rpc<address_Arg, method_Arg, request_Arg>
where address_Arg: Clone,
      address_Arg: GraphEdge<String>,
      address_Arg: 'static,
      method_Arg: Clone,
      method_Arg: GraphEdge<String>,
      method_Arg: 'static,
      request_Arg: Clone,
      request_Arg: GraphEdge<String>,
      request_Arg: 'static,
{
    pub fn response(self) -> Edge<String> {
        let rc = Rc::new(self);
        {
            Edge::<String>::new(rc.clone(), 0)
        }
    }

    pub fn protocol(&mut self, protocol: &str) -> Self {
        self.protocol = Some(protocol.to_string());
        self.clone()
    }

    pub fn fail_fast(&mut self, fail_fast: bool) -> Self {
        self.fail_fast = Some(fail_fast);
        self.clone()
    }

    pub fn timeout_in_ms(&mut self, timeout_in_ms: i64) -> Self {
        self.timeout_in_ms = Some(timeout_in_ms);
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<String> {
        let rc = Rc::new(self);
        {
            Edge::<String>::new(rc.clone(), 0)
        }
    }

    pub fn build(address: address_Arg, method: method_Arg, request: request_Arg) -> Self {
        Self {
            address,
            method,
            request,
            protocol: None,
            fail_fast: None,
            timeout_in_ms: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(address: address_Arg, method: method_Arg, request: request_Arg) -> Edge<String> {
        Self {
            address,
            method,
            request,
            protocol: None,
            fail_fast: None,
            timeout_in_ms: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<tags_Arg, T, values_Arg> GraphOperation for ScalarSummary<tags_Arg, T, values_Arg>
where tags_Arg: Clone,
      tags_Arg: GraphEdge<String>,
      tags_Arg: 'static,
      T: TensorType,
      T: Clone,
      values_Arg: Clone,
      values_Arg: GraphEdge<T>,
      values_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("ScalarSummary_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("ScalarSummary", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.tags)?
        }
        {
            new_op.add_edge(&self.values)?
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct ScalarSummary<tags_Arg, T, values_Arg>
where tags_Arg: Clone,
      tags_Arg: GraphEdge<String>,
      tags_Arg: 'static,
      T: TensorType,
      T: Clone,
      values_Arg: Clone,
      values_Arg: GraphEdge<T>,
      values_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
{
    tags: tags_Arg,
    phantom_T: PhantomData<T>,
    values: values_Arg,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<tags_Arg, T, values_Arg> ScalarSummary<tags_Arg, T, values_Arg>
where tags_Arg: Clone,
      tags_Arg: GraphEdge<String>,
      tags_Arg: 'static,
      T: TensorType,
      T: Clone,
      values_Arg: Clone,
      values_Arg: GraphEdge<T>,
      values_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
{
    pub fn summary(self) -> Edge<String> {
        let rc = Rc::new(self);
        {
            Edge::<String>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<String> {
        let rc = Rc::new(self);
        {
            Edge::<String>::new(rc.clone(), 0)
        }
    }

    pub fn build(tags: tags_Arg, values: values_Arg) -> Self {
        Self {
            tags,
            phantom_T: PhantomData,
            values,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(tags: tags_Arg, values: values_Arg) -> Edge<String> {
        Self {
            tags,
            phantom_T: PhantomData,
            values,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<T, y_Arg, dy_Arg> GraphOperation for TanhGrad<T, y_Arg, dy_Arg>
where T: TensorType,
      T: Clone,
      y_Arg: Clone,
      y_Arg: GraphEdge<T>,
      y_Arg: 'static,
      dy_Arg: Clone,
      dy_Arg: GraphEdge<T>,
      dy_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_COMPLEX64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF,
      T: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("TanhGrad_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("TanhGrad", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.y)?
        }
        {
            new_op.add_edge(&self.dy)?
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct TanhGrad<T, y_Arg, dy_Arg>
where T: TensorType,
      T: Clone,
      y_Arg: Clone,
      y_Arg: GraphEdge<T>,
      y_Arg: 'static,
      dy_Arg: Clone,
      dy_Arg: GraphEdge<T>,
      dy_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_COMPLEX64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    y: y_Arg,
    dy: dy_Arg,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<T, y_Arg, dy_Arg> TanhGrad<T, y_Arg, dy_Arg>
where T: TensorType,
      T: Clone,
      y_Arg: Clone,
      y_Arg: GraphEdge<T>,
      y_Arg: 'static,
      dy_Arg: Clone,
      dy_Arg: GraphEdge<T>,
      dy_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_COMPLEX64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF,
      T: 'static,
{
    pub fn z(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(y: y_Arg, dy: dy_Arg) -> Self {
        Self {
            phantom_T: PhantomData,
            y,
            dy,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(y: y_Arg, dy: dy_Arg) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            y,
            dy,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl GraphOperation for RetrieveTPUEmbeddingADAMParameters {
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("RetrieveTPUEmbeddingADAMParameters_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("RetrieveTPUEmbeddingADAMParameters", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            match self.table_id {
                None => new_op.set_attr_value_proto("table_id", &vec![24_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 1_u8,])?,
                Some(ref value) => (|attr: &i64| {new_op.set_attr_int("table_id", *attr)})(&value)?,
            };
        }
        {
            match self.table_name {
                None => new_op.set_attr_value_proto("table_name", &vec![18_u8, 0_u8,])?,
                Some(ref value) => (|attr| {new_op.set_attr_string("table_name", attr)})(&value)?,
            };
        }
        {
            (|attr: &i64| {new_op.set_attr_int("num_shards", *attr)})(&self.num_shards)?
        }
        {
            (|attr: &i64| {new_op.set_attr_int("shard_id", *attr)})(&self.shard_id)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct RetrieveTPUEmbeddingADAMParameters {
    table_id: Option<i64>,
    table_name: Option<String>,
    num_shards: i64,
    shard_id: i64,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl RetrieveTPUEmbeddingADAMParameters {
    pub fn parameters(self) -> Edge<f32> {
        let rc = Rc::new(self);
        {
            Edge::<f32>::new(rc.clone(), 0)
        }
    }

    pub fn momenta(self) -> Edge<f32> {
        let rc = Rc::new(self);
        {
            Edge::<f32>::new(rc.clone(), 1)
        }
    }

    pub fn velocities(self) -> Edge<f32> {
        let rc = Rc::new(self);
        {
            Edge::<f32>::new(rc.clone(), 2)
        }
    }

    pub fn table_id(&mut self, table_id: i64) -> Self {
        self.table_id = Some(table_id);
        self.clone()
    }

    pub fn table_name(&mut self, table_name: &str) -> Self {
        self.table_name = Some(table_name.to_string());
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> (Edge<f32>, Edge<f32>, Edge<f32>) {
        let rc = Rc::new(self);
        (
        {
            Edge::<f32>::new(rc.clone(), 0)
        },
        {
            Edge::<f32>::new(rc.clone(), 1)
        },
        {
            Edge::<f32>::new(rc.clone(), 2)
        },
        )
    }

    pub fn build(num_shards: i64, shard_id: i64) -> Self {
        Self {
            table_id: None,
            table_name: None,
            num_shards: num_shards,
            shard_id: shard_id,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(num_shards: i64, shard_id: i64) -> (Edge<f32>, Edge<f32>, Edge<f32>) {
        Self {
            table_id: None,
            table_name: None,
            num_shards: num_shards,
            shard_id: shard_id,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<concat_dim_Arg, T, values_Arg> GraphOperation for Concat<concat_dim_Arg, T, values_Arg>
where concat_dim_Arg: Clone,
      concat_dim_Arg: GraphEdge<i32>,
      concat_dim_Arg: 'static,
      T: TensorType,
      T: Clone,
      values_Arg: Clone,
      values_Arg: GraphEdge<T>,
      values_Arg: 'static,
      T: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("Concat_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("Concat", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.concat_dim)?
        }
        {
            new_op.add_edge(&self.values)?
        }
        {
            (|attr: &i64| {new_op.set_attr_int("N", *attr)})(&self.N)?
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct Concat<concat_dim_Arg, T, values_Arg>
where concat_dim_Arg: Clone,
      concat_dim_Arg: GraphEdge<i32>,
      concat_dim_Arg: 'static,
      T: TensorType,
      T: Clone,
      values_Arg: Clone,
      values_Arg: GraphEdge<T>,
      values_Arg: 'static,
      T: 'static,
{
    concat_dim: concat_dim_Arg,
    phantom_T: PhantomData<T>,
    values: values_Arg,
    N: i64,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<concat_dim_Arg, T, values_Arg> Concat<concat_dim_Arg, T, values_Arg>
where concat_dim_Arg: Clone,
      concat_dim_Arg: GraphEdge<i32>,
      concat_dim_Arg: 'static,
      T: TensorType,
      T: Clone,
      values_Arg: Clone,
      values_Arg: GraphEdge<T>,
      values_Arg: 'static,
      T: 'static,
{
    pub fn output(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(concat_dim: concat_dim_Arg, values: values_Arg, N: i64) -> Self {
        Self {
            concat_dim,
            phantom_T: PhantomData,
            values,
            N: N,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(concat_dim: concat_dim_Arg, values: values_Arg, N: i64) -> Edge<T> {
        Self {
            concat_dim,
            phantom_T: PhantomData,
            values,
            N: N,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<inputs_Arg> GraphOperation for _WaitForDistributedTPU<inputs_Arg>
where inputs_Arg: Clone,
      inputs_Arg: GraphEdge<i32>,
      inputs_Arg: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("_WaitForDistributedTPU_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("_WaitForDistributedTPU", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.inputs)?
        }
        {
            match self.startup_timeout_sec {
                None => new_op.set_attr_value_proto("startup_timeout_sec", &vec![24_u8, 20_u8,])?,
                Some(ref value) => (|attr: &i64| {new_op.set_attr_int("startup_timeout_sec", *attr)})(&value)?,
            };
        }
        {
            (|attr: &i64| {new_op.set_attr_int("N", *attr)})(&self.N)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct _WaitForDistributedTPU<inputs_Arg>
where inputs_Arg: Clone,
      inputs_Arg: GraphEdge<i32>,
      inputs_Arg: 'static,
{
    inputs: inputs_Arg,
    startup_timeout_sec: Option<i64>,
    N: i64,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<inputs_Arg> _WaitForDistributedTPU<inputs_Arg>
where inputs_Arg: Clone,
      inputs_Arg: GraphEdge<i32>,
      inputs_Arg: 'static,
{
    pub fn topology(self) -> Edge<String> {
        let rc = Rc::new(self);
        {
            Edge::<String>::new(rc.clone(), 0)
        }
    }

    pub fn startup_timeout_sec(&mut self, startup_timeout_sec: i64) -> Self {
        self.startup_timeout_sec = Some(startup_timeout_sec);
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<String> {
        let rc = Rc::new(self);
        {
            Edge::<String>::new(rc.clone(), 0)
        }
    }

    pub fn build(inputs: inputs_Arg, N: i64) -> Self {
        Self {
            inputs,
            startup_timeout_sec: None,
            N: N,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(inputs: inputs_Arg, N: i64) -> Edge<String> {
        Self {
            inputs,
            startup_timeout_sec: None,
            N: N,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

pub trait con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_STRING_or_DT_COMPLEX64_or_DT_INT64_or_DT_COMPLEX128_or_DT_HALF {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_STRING_or_DT_COMPLEX64_or_DT_INT64_or_DT_COMPLEX128_or_DT_HALF for OtherComplex<f32> {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_STRING_or_DT_COMPLEX64_or_DT_INT64_or_DT_COMPLEX128_or_DT_HALF for OtherComplex<f64> {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_STRING_or_DT_COMPLEX64_or_DT_INT64_or_DT_COMPLEX128_or_DT_HALF for String {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_STRING_or_DT_COMPLEX64_or_DT_INT64_or_DT_COMPLEX128_or_DT_HALF for f32 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_STRING_or_DT_COMPLEX64_or_DT_INT64_or_DT_COMPLEX128_or_DT_HALF for f64 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_STRING_or_DT_COMPLEX64_or_DT_INT64_or_DT_COMPLEX128_or_DT_HALF for i16 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_STRING_or_DT_COMPLEX64_or_DT_INT64_or_DT_COMPLEX128_or_DT_HALF for i32 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_STRING_or_DT_COMPLEX64_or_DT_INT64_or_DT_COMPLEX128_or_DT_HALF for i64 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_STRING_or_DT_COMPLEX64_or_DT_INT64_or_DT_COMPLEX128_or_DT_HALF for i8 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_STRING_or_DT_COMPLEX64_or_DT_INT64_or_DT_COMPLEX128_or_DT_HALF for u8 {
}

impl<T, x_Arg, y_Arg, mkl_x_Arg, mkl_y_Arg> GraphOperation for _MklAdd<T, x_Arg, y_Arg, mkl_x_Arg, mkl_y_Arg>
where T: TensorType,
      T: Clone,
      x_Arg: Clone,
      x_Arg: GraphEdge<T>,
      x_Arg: 'static,
      y_Arg: Clone,
      y_Arg: GraphEdge<T>,
      y_Arg: 'static,
      mkl_x_Arg: Clone,
      mkl_x_Arg: GraphEdge<u8>,
      mkl_x_Arg: 'static,
      mkl_y_Arg: Clone,
      mkl_y_Arg: GraphEdge<u8>,
      mkl_y_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_STRING_or_DT_COMPLEX64_or_DT_INT64_or_DT_COMPLEX128_or_DT_HALF,
      T: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("_MklAdd_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("_MklAdd", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.x)?
        }
        {
            new_op.add_edge(&self.y)?
        }
        {
            new_op.add_edge(&self.mkl_x)?
        }
        {
            new_op.add_edge(&self.mkl_y)?
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct _MklAdd<T, x_Arg, y_Arg, mkl_x_Arg, mkl_y_Arg>
where T: TensorType,
      T: Clone,
      x_Arg: Clone,
      x_Arg: GraphEdge<T>,
      x_Arg: 'static,
      y_Arg: Clone,
      y_Arg: GraphEdge<T>,
      y_Arg: 'static,
      mkl_x_Arg: Clone,
      mkl_x_Arg: GraphEdge<u8>,
      mkl_x_Arg: 'static,
      mkl_y_Arg: Clone,
      mkl_y_Arg: GraphEdge<u8>,
      mkl_y_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_STRING_or_DT_COMPLEX64_or_DT_INT64_or_DT_COMPLEX128_or_DT_HALF,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    x: x_Arg,
    y: y_Arg,
    mkl_x: mkl_x_Arg,
    mkl_y: mkl_y_Arg,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<T, x_Arg, y_Arg, mkl_x_Arg, mkl_y_Arg> _MklAdd<T, x_Arg, y_Arg, mkl_x_Arg, mkl_y_Arg>
where T: TensorType,
      T: Clone,
      x_Arg: Clone,
      x_Arg: GraphEdge<T>,
      x_Arg: 'static,
      y_Arg: Clone,
      y_Arg: GraphEdge<T>,
      y_Arg: 'static,
      mkl_x_Arg: Clone,
      mkl_x_Arg: GraphEdge<u8>,
      mkl_x_Arg: 'static,
      mkl_y_Arg: Clone,
      mkl_y_Arg: GraphEdge<u8>,
      mkl_y_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_STRING_or_DT_COMPLEX64_or_DT_INT64_or_DT_COMPLEX128_or_DT_HALF,
      T: 'static,
{
    pub fn z(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn mkl_z(self) -> Edge<u8> {
        let rc = Rc::new(self);
        {
            Edge::<u8>::new(rc.clone(), 1)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> (Edge<T>, Edge<u8>) {
        let rc = Rc::new(self);
        (
        {
            Edge::<T>::new(rc.clone(), 0)
        },
        {
            Edge::<u8>::new(rc.clone(), 1)
        },
        )
    }

    pub fn build(x: x_Arg, y: y_Arg, mkl_x: mkl_x_Arg, mkl_y: mkl_y_Arg) -> Self {
        Self {
            phantom_T: PhantomData,
            x,
            y,
            mkl_x,
            mkl_y,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(x: x_Arg, y: y_Arg, mkl_x: mkl_x_Arg, mkl_y: mkl_y_Arg) -> (Edge<T>, Edge<u8>) {
        Self {
            phantom_T: PhantomData,
            x,
            y,
            mkl_x,
            mkl_y,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<true_classes_Arg> GraphOperation for AllCandidateSampler<true_classes_Arg>
where true_classes_Arg: Clone,
      true_classes_Arg: GraphEdge<i64>,
      true_classes_Arg: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("AllCandidateSampler_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("AllCandidateSampler", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.true_classes)?
        }
        {
            (|attr: &i64| {new_op.set_attr_int("num_true", *attr)})(&self.num_true)?
        }
        {
            (|attr: &i64| {new_op.set_attr_int("num_sampled", *attr)})(&self.num_sampled)?
        }
        {
            (|attr: &bool| {new_op.set_attr_bool("unique", *attr)})(&self.unique)?
        }
        {
            match self.seed {
                None => new_op.set_attr_value_proto("seed", &vec![24_u8, 0_u8,])?,
                Some(ref value) => (|attr: &i64| {new_op.set_attr_int("seed", *attr)})(&value)?,
            };
        }
        {
            match self.seed2 {
                None => new_op.set_attr_value_proto("seed2", &vec![24_u8, 0_u8,])?,
                Some(ref value) => (|attr: &i64| {new_op.set_attr_int("seed2", *attr)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct AllCandidateSampler<true_classes_Arg>
where true_classes_Arg: Clone,
      true_classes_Arg: GraphEdge<i64>,
      true_classes_Arg: 'static,
{
    true_classes: true_classes_Arg,
    num_true: i64,
    num_sampled: i64,
    unique: bool,
    seed: Option<i64>,
    seed2: Option<i64>,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<true_classes_Arg> AllCandidateSampler<true_classes_Arg>
where true_classes_Arg: Clone,
      true_classes_Arg: GraphEdge<i64>,
      true_classes_Arg: 'static,
{
    pub fn sampled_candidates(self) -> Edge<i64> {
        let rc = Rc::new(self);
        {
            Edge::<i64>::new(rc.clone(), 0)
        }
    }

    pub fn true_expected_count(self) -> Edge<f32> {
        let rc = Rc::new(self);
        {
            Edge::<f32>::new(rc.clone(), 1)
        }
    }

    pub fn sampled_expected_count(self) -> Edge<f32> {
        let rc = Rc::new(self);
        {
            Edge::<f32>::new(rc.clone(), 2)
        }
    }

    pub fn seed(&mut self, seed: i64) -> Self {
        self.seed = Some(seed);
        self.clone()
    }

    pub fn seed2(&mut self, seed2: i64) -> Self {
        self.seed2 = Some(seed2);
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> (Edge<i64>, Edge<f32>, Edge<f32>) {
        let rc = Rc::new(self);
        (
        {
            Edge::<i64>::new(rc.clone(), 0)
        },
        {
            Edge::<f32>::new(rc.clone(), 1)
        },
        {
            Edge::<f32>::new(rc.clone(), 2)
        },
        )
    }

    pub fn build(true_classes: true_classes_Arg, num_true: i64, num_sampled: i64, unique: bool) -> Self {
        Self {
            true_classes,
            num_true: num_true,
            num_sampled: num_sampled,
            unique: unique,
            seed: None,
            seed2: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(true_classes: true_classes_Arg, num_true: i64, num_sampled: i64, unique: bool) -> (Edge<i64>, Edge<f32>, Edge<f32>) {
        Self {
            true_classes,
            num_true: num_true,
            num_sampled: num_sampled,
            unique: unique,
            seed: None,
            seed2: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<contents_Arg, crop_window_Arg> GraphOperation for DecodeAndCropJpeg<contents_Arg, crop_window_Arg>
where contents_Arg: Clone,
      contents_Arg: GraphEdge<String>,
      contents_Arg: 'static,
      crop_window_Arg: Clone,
      crop_window_Arg: GraphEdge<i32>,
      crop_window_Arg: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("DecodeAndCropJpeg_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("DecodeAndCropJpeg", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.contents)?
        }
        {
            new_op.add_edge(&self.crop_window)?
        }
        {
            match self.channels {
                None => new_op.set_attr_value_proto("channels", &vec![24_u8, 0_u8,])?,
                Some(ref value) => (|attr: &i64| {new_op.set_attr_int("channels", *attr)})(&value)?,
            };
        }
        {
            match self.ratio {
                None => new_op.set_attr_value_proto("ratio", &vec![24_u8, 1_u8,])?,
                Some(ref value) => (|attr: &i64| {new_op.set_attr_int("ratio", *attr)})(&value)?,
            };
        }
        {
            match self.fancy_upscaling {
                None => new_op.set_attr_value_proto("fancy_upscaling", &vec![40_u8, 1_u8,])?,
                Some(ref value) => (|attr: &bool| {new_op.set_attr_bool("fancy_upscaling", *attr)})(&value)?,
            };
        }
        {
            match self.try_recover_truncated {
                None => new_op.set_attr_value_proto("try_recover_truncated", &vec![40_u8, 0_u8,])?,
                Some(ref value) => (|attr: &bool| {new_op.set_attr_bool("try_recover_truncated", *attr)})(&value)?,
            };
        }
        {
            match self.acceptable_fraction {
                None => new_op.set_attr_value_proto("acceptable_fraction", &vec![37_u8, 0_u8, 0_u8, 128_u8, 63_u8,])?,
                Some(ref value) => (|attr: &f32| {new_op.set_attr_float("acceptable_fraction", *attr)})(&value)?,
            };
        }
        {
            match self.dct_method {
                None => new_op.set_attr_value_proto("dct_method", &vec![18_u8, 0_u8,])?,
                Some(ref value) => (|attr| {new_op.set_attr_string("dct_method", attr)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct DecodeAndCropJpeg<contents_Arg, crop_window_Arg>
where contents_Arg: Clone,
      contents_Arg: GraphEdge<String>,
      contents_Arg: 'static,
      crop_window_Arg: Clone,
      crop_window_Arg: GraphEdge<i32>,
      crop_window_Arg: 'static,
{
    contents: contents_Arg,
    crop_window: crop_window_Arg,
    channels: Option<i64>,
    ratio: Option<i64>,
    fancy_upscaling: Option<bool>,
    try_recover_truncated: Option<bool>,
    acceptable_fraction: Option<f32>,
    dct_method: Option<String>,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<contents_Arg, crop_window_Arg> DecodeAndCropJpeg<contents_Arg, crop_window_Arg>
where contents_Arg: Clone,
      contents_Arg: GraphEdge<String>,
      contents_Arg: 'static,
      crop_window_Arg: Clone,
      crop_window_Arg: GraphEdge<i32>,
      crop_window_Arg: 'static,
{
    pub fn image(self) -> Edge<u8> {
        let rc = Rc::new(self);
        {
            Edge::<u8>::new(rc.clone(), 0)
        }
    }

    pub fn channels(&mut self, channels: i64) -> Self {
        self.channels = Some(channels);
        self.clone()
    }

    pub fn ratio(&mut self, ratio: i64) -> Self {
        self.ratio = Some(ratio);
        self.clone()
    }

    pub fn fancy_upscaling(&mut self, fancy_upscaling: bool) -> Self {
        self.fancy_upscaling = Some(fancy_upscaling);
        self.clone()
    }

    pub fn try_recover_truncated(&mut self, try_recover_truncated: bool) -> Self {
        self.try_recover_truncated = Some(try_recover_truncated);
        self.clone()
    }

    pub fn acceptable_fraction(&mut self, acceptable_fraction: f32) -> Self {
        self.acceptable_fraction = Some(acceptable_fraction);
        self.clone()
    }

    pub fn dct_method(&mut self, dct_method: &str) -> Self {
        self.dct_method = Some(dct_method.to_string());
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<u8> {
        let rc = Rc::new(self);
        {
            Edge::<u8>::new(rc.clone(), 0)
        }
    }

    pub fn build(contents: contents_Arg, crop_window: crop_window_Arg) -> Self {
        Self {
            contents,
            crop_window,
            channels: None,
            ratio: None,
            fancy_upscaling: None,
            try_recover_truncated: None,
            acceptable_fraction: None,
            dct_method: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(contents: contents_Arg, crop_window: crop_window_Arg) -> Edge<u8> {
        Self {
            contents,
            crop_window,
            channels: None,
            ratio: None,
            fancy_upscaling: None,
            try_recover_truncated: None,
            acceptable_fraction: None,
            dct_method: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<tensor_type> GraphOperation for _Recv<tensor_type>
where tensor_type: TensorType,
      tensor_type: 'static,
      tensor_type: Clone,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("_Recv_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("_Recv", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.set_attr_type("tensor_type", tensor_type::data_type())?;
        }
        {
            (|attr| {new_op.set_attr_string("tensor_name", attr)})(&self.tensor_name)?
        }
        {
            (|attr| {new_op.set_attr_string("send_device", attr)})(&self.send_device)?
        }
        {
            (|attr: &i64| {new_op.set_attr_int("send_device_incarnation", *attr)})(&self.send_device_incarnation)?
        }
        {
            (|attr| {new_op.set_attr_string("recv_device", attr)})(&self.recv_device)?
        }
        {
            match self.client_terminated {
                None => new_op.set_attr_value_proto("client_terminated", &vec![40_u8, 0_u8,])?,
                Some(ref value) => (|attr: &bool| {new_op.set_attr_bool("client_terminated", *attr)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct _Recv<tensor_type>
where tensor_type: TensorType,
      tensor_type: 'static,
      tensor_type: Clone,
{
    phantom_tensor_type: PhantomData<tensor_type>,
    tensor_name: String,
    send_device: String,
    send_device_incarnation: i64,
    recv_device: String,
    client_terminated: Option<bool>,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<tensor_type> _Recv<tensor_type>
where tensor_type: TensorType,
      tensor_type: 'static,
      tensor_type: Clone,
{
    pub fn tensor(self) -> Edge<tensor_type> {
        let rc = Rc::new(self);
        {
            Edge::<tensor_type>::new(rc.clone(), 0)
        }
    }

    pub fn client_terminated(&mut self, client_terminated: bool) -> Self {
        self.client_terminated = Some(client_terminated);
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<tensor_type> {
        let rc = Rc::new(self);
        {
            Edge::<tensor_type>::new(rc.clone(), 0)
        }
    }

    pub fn build(tensor_name: &str, send_device: &str, send_device_incarnation: i64, recv_device: &str) -> Self {
        Self {
            phantom_tensor_type: PhantomData,
            tensor_name: tensor_name.to_string(),
            send_device: send_device.to_string(),
            send_device_incarnation: send_device_incarnation,
            recv_device: recv_device.to_string(),
            client_terminated: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(tensor_name: &str, send_device: &str, send_device_incarnation: i64, recv_device: &str) -> Edge<tensor_type> {
        Self {
            phantom_tensor_type: PhantomData,
            tensor_name: tensor_name.to_string(),
            send_device: send_device.to_string(),
            send_device_incarnation: send_device_incarnation,
            recv_device: recv_device.to_string(),
            client_terminated: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<input_Arg> GraphOperation for SdcaFprint<input_Arg>
where input_Arg: Clone,
      input_Arg: GraphEdge<String>,
      input_Arg: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("SdcaFprint_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("SdcaFprint", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.input)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct SdcaFprint<input_Arg>
where input_Arg: Clone,
      input_Arg: GraphEdge<String>,
      input_Arg: 'static,
{
    input: input_Arg,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<input_Arg> SdcaFprint<input_Arg>
where input_Arg: Clone,
      input_Arg: GraphEdge<String>,
      input_Arg: 'static,
{
    pub fn output(self) -> Edge<i64> {
        let rc = Rc::new(self);
        {
            Edge::<i64>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<i64> {
        let rc = Rc::new(self);
        {
            Edge::<i64>::new(rc.clone(), 0)
        }
    }

    pub fn build(input: input_Arg) -> Self {
        Self {
            input,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(input: input_Arg) -> Edge<i64> {
        Self {
            input,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<reader_handle_Arg, queue_handle_Arg, num_records_Arg> GraphOperation for ReaderReadUpTo<reader_handle_Arg, queue_handle_Arg, num_records_Arg>
where reader_handle_Arg: Clone,
      reader_handle_Arg: GraphRefEdge<String>,
      reader_handle_Arg: 'static,
      queue_handle_Arg: Clone,
      queue_handle_Arg: GraphRefEdge<String>,
      queue_handle_Arg: 'static,
      num_records_Arg: Clone,
      num_records_Arg: GraphEdge<i64>,
      num_records_Arg: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("ReaderReadUpTo_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("ReaderReadUpTo", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.reader_handle)?
        }
        {
            new_op.add_edge(&self.queue_handle)?
        }
        {
            new_op.add_edge(&self.num_records)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct ReaderReadUpTo<reader_handle_Arg, queue_handle_Arg, num_records_Arg>
where reader_handle_Arg: Clone,
      reader_handle_Arg: GraphRefEdge<String>,
      reader_handle_Arg: 'static,
      queue_handle_Arg: Clone,
      queue_handle_Arg: GraphRefEdge<String>,
      queue_handle_Arg: 'static,
      num_records_Arg: Clone,
      num_records_Arg: GraphEdge<i64>,
      num_records_Arg: 'static,
{
    reader_handle: reader_handle_Arg,
    queue_handle: queue_handle_Arg,
    num_records: num_records_Arg,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<reader_handle_Arg, queue_handle_Arg, num_records_Arg> ReaderReadUpTo<reader_handle_Arg, queue_handle_Arg, num_records_Arg>
where reader_handle_Arg: Clone,
      reader_handle_Arg: GraphRefEdge<String>,
      reader_handle_Arg: 'static,
      queue_handle_Arg: Clone,
      queue_handle_Arg: GraphRefEdge<String>,
      queue_handle_Arg: 'static,
      num_records_Arg: Clone,
      num_records_Arg: GraphEdge<i64>,
      num_records_Arg: 'static,
{
    pub fn keys(self) -> Edge<String> {
        let rc = Rc::new(self);
        {
            Edge::<String>::new(rc.clone(), 0)
        }
    }

    pub fn values(self) -> Edge<String> {
        let rc = Rc::new(self);
        {
            Edge::<String>::new(rc.clone(), 1)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> (Edge<String>, Edge<String>) {
        let rc = Rc::new(self);
        (
        {
            Edge::<String>::new(rc.clone(), 0)
        },
        {
            Edge::<String>::new(rc.clone(), 1)
        },
        )
    }

    pub fn build(reader_handle: reader_handle_Arg, queue_handle: queue_handle_Arg, num_records: num_records_Arg) -> Self {
        Self {
            reader_handle,
            queue_handle,
            num_records,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(reader_handle: reader_handle_Arg, queue_handle: queue_handle_Arg, num_records: num_records_Arg) -> (Edge<String>, Edge<String>) {
        Self {
            reader_handle,
            queue_handle,
            num_records,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<T, input_Arg, out_type> GraphOperation for Shape<T, input_Arg, out_type>
where T: TensorType,
      T: Clone,
      input_Arg: Clone,
      input_Arg: GraphEdge<T>,
      input_Arg: 'static,
      out_type: TensorType,
      T: 'static,
      out_type: con_or_DT_INT32_or_DT_INT64,
      out_type: 'static,
      out_type: Clone,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("Shape_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("Shape", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.input)?
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        {
            new_op.set_attr_type("out_type", out_type::data_type())?;
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct Shape<T, input_Arg, out_type>
where T: TensorType,
      T: Clone,
      input_Arg: Clone,
      input_Arg: GraphEdge<T>,
      input_Arg: 'static,
      out_type: TensorType,
      T: 'static,
      out_type: con_or_DT_INT32_or_DT_INT64,
      out_type: 'static,
      out_type: Clone,
{
    phantom_T: PhantomData<T>,
    input: input_Arg,
    phantom_out_type: PhantomData<out_type>,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<T, input_Arg, out_type> Shape<T, input_Arg, out_type>
where T: TensorType,
      T: Clone,
      input_Arg: Clone,
      input_Arg: GraphEdge<T>,
      input_Arg: 'static,
      out_type: TensorType,
      T: 'static,
      out_type: con_or_DT_INT32_or_DT_INT64,
      out_type: 'static,
      out_type: Clone,
{
    pub fn output(self) -> Edge<out_type> {
        let rc = Rc::new(self);
        {
            Edge::<out_type>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<out_type> {
        let rc = Rc::new(self);
        {
            Edge::<out_type>::new(rc.clone(), 0)
        }
    }

    pub fn build(input: input_Arg) -> Self {
        Self {
            phantom_T: PhantomData,
            input,
            phantom_out_type: PhantomData,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(input: input_Arg) -> Edge<out_type> {
        Self {
            phantom_T: PhantomData,
            input,
            phantom_out_type: PhantomData,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<T, x_Arg, y_Arg> GraphOperation for Pow<T, x_Arg, y_Arg>
where T: TensorType,
      T: Clone,
      x_Arg: Clone,
      x_Arg: GraphEdge<T>,
      x_Arg: 'static,
      y_Arg: Clone,
      y_Arg: GraphEdge<T>,
      y_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_COMPLEX64_or_DT_INT64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF,
      T: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("Pow_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("Pow", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.x)?
        }
        {
            new_op.add_edge(&self.y)?
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct Pow<T, x_Arg, y_Arg>
where T: TensorType,
      T: Clone,
      x_Arg: Clone,
      x_Arg: GraphEdge<T>,
      x_Arg: 'static,
      y_Arg: Clone,
      y_Arg: GraphEdge<T>,
      y_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_COMPLEX64_or_DT_INT64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    x: x_Arg,
    y: y_Arg,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<T, x_Arg, y_Arg> Pow<T, x_Arg, y_Arg>
where T: TensorType,
      T: Clone,
      x_Arg: Clone,
      x_Arg: GraphEdge<T>,
      x_Arg: 'static,
      y_Arg: Clone,
      y_Arg: GraphEdge<T>,
      y_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_COMPLEX64_or_DT_INT64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF,
      T: 'static,
{
    pub fn z(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(x: x_Arg, y: y_Arg) -> Self {
        Self {
            phantom_T: PhantomData,
            x,
            y,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(x: x_Arg, y: y_Arg) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            x,
            y,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<input_Arg, min_range_Arg, max_range_Arg, T> GraphOperation for QuantizeV2<input_Arg, min_range_Arg, max_range_Arg, T>
where input_Arg: Clone,
      input_Arg: GraphEdge<f32>,
      input_Arg: 'static,
      min_range_Arg: Clone,
      min_range_Arg: GraphEdge<f32>,
      min_range_Arg: 'static,
      max_range_Arg: Clone,
      max_range_Arg: GraphEdge<f32>,
      max_range_Arg: 'static,
      T: TensorType,
      T: con_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_QINT16_or_DT_QUINT16,
      T: 'static,
      T: Clone,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("QuantizeV2_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("QuantizeV2", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.input)?
        }
        {
            new_op.add_edge(&self.min_range)?
        }
        {
            new_op.add_edge(&self.max_range)?
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        {
            match self.mode {
                None => new_op.set_attr_value_proto("mode", &vec![18_u8, 12_u8, 77_u8, 73_u8, 78_u8, 95_u8, 67_u8, 79_u8, 77_u8, 66_u8, 73_u8, 78_u8, 69_u8, 68_u8,])?,
                Some(ref value) => (|attr| {new_op.set_attr_string("mode", attr)})(&value)?,
            };
        }
        {
            match self.round_mode {
                None => new_op.set_attr_value_proto("round_mode", &vec![18_u8, 19_u8, 72_u8, 65_u8, 76_u8, 70_u8, 95_u8, 65_u8, 87_u8, 65_u8, 89_u8, 95_u8, 70_u8, 82_u8, 79_u8, 77_u8, 95_u8, 90_u8, 69_u8, 82_u8, 79_u8,])?,
                Some(ref value) => (|attr| {new_op.set_attr_string("round_mode", attr)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct QuantizeV2<input_Arg, min_range_Arg, max_range_Arg, T>
where input_Arg: Clone,
      input_Arg: GraphEdge<f32>,
      input_Arg: 'static,
      min_range_Arg: Clone,
      min_range_Arg: GraphEdge<f32>,
      min_range_Arg: 'static,
      max_range_Arg: Clone,
      max_range_Arg: GraphEdge<f32>,
      max_range_Arg: 'static,
      T: TensorType,
      T: con_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_QINT16_or_DT_QUINT16,
      T: 'static,
      T: Clone,
{
    input: input_Arg,
    min_range: min_range_Arg,
    max_range: max_range_Arg,
    phantom_T: PhantomData<T>,
    mode: Option<String>,
    round_mode: Option<String>,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<input_Arg, min_range_Arg, max_range_Arg, T> QuantizeV2<input_Arg, min_range_Arg, max_range_Arg, T>
where input_Arg: Clone,
      input_Arg: GraphEdge<f32>,
      input_Arg: 'static,
      min_range_Arg: Clone,
      min_range_Arg: GraphEdge<f32>,
      min_range_Arg: 'static,
      max_range_Arg: Clone,
      max_range_Arg: GraphEdge<f32>,
      max_range_Arg: 'static,
      T: TensorType,
      T: con_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_QINT16_or_DT_QUINT16,
      T: 'static,
      T: Clone,
{
    pub fn output(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn output_min(self) -> Edge<f32> {
        let rc = Rc::new(self);
        {
            Edge::<f32>::new(rc.clone(), 1)
        }
    }

    pub fn output_max(self) -> Edge<f32> {
        let rc = Rc::new(self);
        {
            Edge::<f32>::new(rc.clone(), 2)
        }
    }

    pub fn mode(&mut self, mode: &str) -> Self {
        self.mode = Some(mode.to_string());
        self.clone()
    }

    pub fn round_mode(&mut self, round_mode: &str) -> Self {
        self.round_mode = Some(round_mode.to_string());
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> (Edge<T>, Edge<f32>, Edge<f32>) {
        let rc = Rc::new(self);
        (
        {
            Edge::<T>::new(rc.clone(), 0)
        },
        {
            Edge::<f32>::new(rc.clone(), 1)
        },
        {
            Edge::<f32>::new(rc.clone(), 2)
        },
        )
    }

    pub fn build(input: input_Arg, min_range: min_range_Arg, max_range: max_range_Arg) -> Self {
        Self {
            input,
            min_range,
            max_range,
            phantom_T: PhantomData,
            mode: None,
            round_mode: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(input: input_Arg, min_range: min_range_Arg, max_range: max_range_Arg) -> (Edge<T>, Edge<f32>, Edge<f32>) {
        Self {
            input,
            min_range,
            max_range,
            phantom_T: PhantomData,
            mode: None,
            round_mode: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<split_dim_Arg, T, value_Arg> GraphOperation for Split<split_dim_Arg, T, value_Arg>
where split_dim_Arg: Clone,
      split_dim_Arg: GraphEdge<i32>,
      split_dim_Arg: 'static,
      T: TensorType,
      T: Clone,
      value_Arg: Clone,
      value_Arg: GraphEdge<T>,
      value_Arg: 'static,
      T: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("Split_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("Split", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.split_dim)?
        }
        {
            new_op.add_edge(&self.value)?
        }
        {
            (|attr: &i64| {new_op.set_attr_int("num_split", *attr)})(&self.num_split)?
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct Split<split_dim_Arg, T, value_Arg>
where split_dim_Arg: Clone,
      split_dim_Arg: GraphEdge<i32>,
      split_dim_Arg: 'static,
      T: TensorType,
      T: Clone,
      value_Arg: Clone,
      value_Arg: GraphEdge<T>,
      value_Arg: 'static,
      T: 'static,
{
    split_dim: split_dim_Arg,
    phantom_T: PhantomData<T>,
    value: value_Arg,
    num_split: i64,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<split_dim_Arg, T, value_Arg> Split<split_dim_Arg, T, value_Arg>
where split_dim_Arg: Clone,
      split_dim_Arg: GraphEdge<i32>,
      split_dim_Arg: 'static,
      T: TensorType,
      T: Clone,
      value_Arg: Clone,
      value_Arg: GraphEdge<T>,
      value_Arg: 'static,
      T: 'static,
{
    pub fn output(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(split_dim: split_dim_Arg, value: value_Arg, num_split: i64) -> Self {
        Self {
            split_dim,
            phantom_T: PhantomData,
            value,
            num_split: num_split,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(split_dim: split_dim_Arg, value: value_Arg, num_split: i64) -> Edge<T> {
        Self {
            split_dim,
            phantom_T: PhantomData,
            value,
            num_split: num_split,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<T, real_Arg, imag_Arg, Tout> GraphOperation for Complex<T, real_Arg, imag_Arg, Tout>
where T: TensorType,
      T: Clone,
      real_Arg: Clone,
      real_Arg: GraphEdge<T>,
      real_Arg: 'static,
      imag_Arg: Clone,
      imag_Arg: GraphEdge<T>,
      imag_Arg: 'static,
      Tout: TensorType,
      T: con_or_DT_FLOAT_or_DT_DOUBLE,
      T: 'static,
      Tout: con_or_DT_COMPLEX64_or_DT_COMPLEX128,
      Tout: 'static,
      Tout: Clone,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("Complex_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("Complex", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.real)?
        }
        {
            new_op.add_edge(&self.imag)?
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        {
            new_op.set_attr_type("Tout", Tout::data_type())?;
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct Complex<T, real_Arg, imag_Arg, Tout>
where T: TensorType,
      T: Clone,
      real_Arg: Clone,
      real_Arg: GraphEdge<T>,
      real_Arg: 'static,
      imag_Arg: Clone,
      imag_Arg: GraphEdge<T>,
      imag_Arg: 'static,
      Tout: TensorType,
      T: con_or_DT_FLOAT_or_DT_DOUBLE,
      T: 'static,
      Tout: con_or_DT_COMPLEX64_or_DT_COMPLEX128,
      Tout: 'static,
      Tout: Clone,
{
    phantom_T: PhantomData<T>,
    real: real_Arg,
    imag: imag_Arg,
    phantom_Tout: PhantomData<Tout>,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<T, real_Arg, imag_Arg, Tout> Complex<T, real_Arg, imag_Arg, Tout>
where T: TensorType,
      T: Clone,
      real_Arg: Clone,
      real_Arg: GraphEdge<T>,
      real_Arg: 'static,
      imag_Arg: Clone,
      imag_Arg: GraphEdge<T>,
      imag_Arg: 'static,
      Tout: TensorType,
      T: con_or_DT_FLOAT_or_DT_DOUBLE,
      T: 'static,
      Tout: con_or_DT_COMPLEX64_or_DT_COMPLEX128,
      Tout: 'static,
      Tout: Clone,
{
    pub fn out(self) -> Edge<Tout> {
        let rc = Rc::new(self);
        {
            Edge::<Tout>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<Tout> {
        let rc = Rc::new(self);
        {
            Edge::<Tout>::new(rc.clone(), 0)
        }
    }

    pub fn build(real: real_Arg, imag: imag_Arg) -> Self {
        Self {
            phantom_T: PhantomData,
            real,
            imag,
            phantom_Tout: PhantomData,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(real: real_Arg, imag: imag_Arg) -> Edge<Tout> {
        Self {
            phantom_T: PhantomData,
            real,
            imag,
            phantom_Tout: PhantomData,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<T, input_Arg, Tout> GraphOperation for Imag<T, input_Arg, Tout>
where T: TensorType,
      T: Clone,
      input_Arg: Clone,
      input_Arg: GraphEdge<T>,
      input_Arg: 'static,
      Tout: TensorType,
      T: con_or_DT_COMPLEX64_or_DT_COMPLEX128,
      T: 'static,
      Tout: con_or_DT_FLOAT_or_DT_DOUBLE,
      Tout: 'static,
      Tout: Clone,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("Imag_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("Imag", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.input)?
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        {
            new_op.set_attr_type("Tout", Tout::data_type())?;
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct Imag<T, input_Arg, Tout>
where T: TensorType,
      T: Clone,
      input_Arg: Clone,
      input_Arg: GraphEdge<T>,
      input_Arg: 'static,
      Tout: TensorType,
      T: con_or_DT_COMPLEX64_or_DT_COMPLEX128,
      T: 'static,
      Tout: con_or_DT_FLOAT_or_DT_DOUBLE,
      Tout: 'static,
      Tout: Clone,
{
    phantom_T: PhantomData<T>,
    input: input_Arg,
    phantom_Tout: PhantomData<Tout>,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<T, input_Arg, Tout> Imag<T, input_Arg, Tout>
where T: TensorType,
      T: Clone,
      input_Arg: Clone,
      input_Arg: GraphEdge<T>,
      input_Arg: 'static,
      Tout: TensorType,
      T: con_or_DT_COMPLEX64_or_DT_COMPLEX128,
      T: 'static,
      Tout: con_or_DT_FLOAT_or_DT_DOUBLE,
      Tout: 'static,
      Tout: Clone,
{
    pub fn output(self) -> Edge<Tout> {
        let rc = Rc::new(self);
        {
            Edge::<Tout>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<Tout> {
        let rc = Rc::new(self);
        {
            Edge::<Tout>::new(rc.clone(), 0)
        }
    }

    pub fn build(input: input_Arg) -> Self {
        Self {
            phantom_T: PhantomData,
            input,
            phantom_Tout: PhantomData,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(input: input_Arg) -> Edge<Tout> {
        Self {
            phantom_T: PhantomData,
            input,
            phantom_Tout: PhantomData,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<T, data_Arg, Tidx, indices_Arg, segment_ids_Arg, Tnumsegments, num_segments_Arg> GraphOperation for SparseSegmentSumWithNumSegments<T, data_Arg, Tidx, indices_Arg, segment_ids_Arg, Tnumsegments, num_segments_Arg>
where T: TensorType,
      T: Clone,
      data_Arg: Clone,
      data_Arg: GraphEdge<T>,
      data_Arg: 'static,
      Tidx: TensorType,
      Tidx: Clone,
      indices_Arg: Clone,
      indices_Arg: GraphEdge<Tidx>,
      indices_Arg: 'static,
      segment_ids_Arg: Clone,
      segment_ids_Arg: GraphEdge<i32>,
      segment_ids_Arg: 'static,
      Tnumsegments: TensorType,
      Tnumsegments: Clone,
      num_segments_Arg: Clone,
      num_segments_Arg: GraphEdge<Tnumsegments>,
      num_segments_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
      Tidx: con_or_DT_INT32_or_DT_INT64,
      Tidx: 'static,
      Tnumsegments: con_or_DT_INT32_or_DT_INT64,
      Tnumsegments: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("SparseSegmentSumWithNumSegments_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("SparseSegmentSumWithNumSegments", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.data)?
        }
        {
            new_op.add_edge(&self.indices)?
        }
        {
            new_op.add_edge(&self.segment_ids)?
        }
        {
            new_op.add_edge(&self.num_segments)?
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        {
            new_op.set_attr_type("Tidx", Tidx::data_type())?;
        }
        {
            new_op.set_attr_type("Tnumsegments", Tnumsegments::data_type())?;
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct SparseSegmentSumWithNumSegments<T, data_Arg, Tidx, indices_Arg, segment_ids_Arg, Tnumsegments, num_segments_Arg>
where T: TensorType,
      T: Clone,
      data_Arg: Clone,
      data_Arg: GraphEdge<T>,
      data_Arg: 'static,
      Tidx: TensorType,
      Tidx: Clone,
      indices_Arg: Clone,
      indices_Arg: GraphEdge<Tidx>,
      indices_Arg: 'static,
      segment_ids_Arg: Clone,
      segment_ids_Arg: GraphEdge<i32>,
      segment_ids_Arg: 'static,
      Tnumsegments: TensorType,
      Tnumsegments: Clone,
      num_segments_Arg: Clone,
      num_segments_Arg: GraphEdge<Tnumsegments>,
      num_segments_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
      Tidx: con_or_DT_INT32_or_DT_INT64,
      Tidx: 'static,
      Tnumsegments: con_or_DT_INT32_or_DT_INT64,
      Tnumsegments: 'static,
{
    phantom_T: PhantomData<T>,
    data: data_Arg,
    phantom_Tidx: PhantomData<Tidx>,
    indices: indices_Arg,
    segment_ids: segment_ids_Arg,
    phantom_Tnumsegments: PhantomData<Tnumsegments>,
    num_segments: num_segments_Arg,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<T, data_Arg, Tidx, indices_Arg, segment_ids_Arg, Tnumsegments, num_segments_Arg> SparseSegmentSumWithNumSegments<T, data_Arg, Tidx, indices_Arg, segment_ids_Arg, Tnumsegments, num_segments_Arg>
where T: TensorType,
      T: Clone,
      data_Arg: Clone,
      data_Arg: GraphEdge<T>,
      data_Arg: 'static,
      Tidx: TensorType,
      Tidx: Clone,
      indices_Arg: Clone,
      indices_Arg: GraphEdge<Tidx>,
      indices_Arg: 'static,
      segment_ids_Arg: Clone,
      segment_ids_Arg: GraphEdge<i32>,
      segment_ids_Arg: 'static,
      Tnumsegments: TensorType,
      Tnumsegments: Clone,
      num_segments_Arg: Clone,
      num_segments_Arg: GraphEdge<Tnumsegments>,
      num_segments_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
      Tidx: con_or_DT_INT32_or_DT_INT64,
      Tidx: 'static,
      Tnumsegments: con_or_DT_INT32_or_DT_INT64,
      Tnumsegments: 'static,
{
    pub fn output(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(data: data_Arg, indices: indices_Arg, segment_ids: segment_ids_Arg, num_segments: num_segments_Arg) -> Self {
        Self {
            phantom_T: PhantomData,
            data,
            phantom_Tidx: PhantomData,
            indices,
            segment_ids,
            phantom_Tnumsegments: PhantomData,
            num_segments,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(data: data_Arg, indices: indices_Arg, segment_ids: segment_ids_Arg, num_segments: num_segments_Arg) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            data,
            phantom_Tidx: PhantomData,
            indices,
            segment_ids,
            phantom_Tnumsegments: PhantomData,
            num_segments,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<T, inputs_Arg> GraphOperation for Merge<T, inputs_Arg>
where T: TensorType,
      T: Clone,
      inputs_Arg: Clone,
      inputs_Arg: GraphEdge<T>,
      inputs_Arg: 'static,
      T: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("Merge_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("Merge", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.inputs)?
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        {
            (|attr: &i64| {new_op.set_attr_int("N", *attr)})(&self.N)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct Merge<T, inputs_Arg>
where T: TensorType,
      T: Clone,
      inputs_Arg: Clone,
      inputs_Arg: GraphEdge<T>,
      inputs_Arg: 'static,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    inputs: inputs_Arg,
    N: i64,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<T, inputs_Arg> Merge<T, inputs_Arg>
where T: TensorType,
      T: Clone,
      inputs_Arg: Clone,
      inputs_Arg: GraphEdge<T>,
      inputs_Arg: 'static,
      T: 'static,
{
    pub fn output(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn value_index(self) -> Edge<i32> {
        let rc = Rc::new(self);
        {
            Edge::<i32>::new(rc.clone(), 1)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> (Edge<T>, Edge<i32>) {
        let rc = Rc::new(self);
        (
        {
            Edge::<T>::new(rc.clone(), 0)
        },
        {
            Edge::<i32>::new(rc.clone(), 1)
        },
        )
    }

    pub fn build(inputs: inputs_Arg, N: i64) -> Self {
        Self {
            phantom_T: PhantomData,
            inputs,
            N: N,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(inputs: inputs_Arg, N: i64) -> (Edge<T>, Edge<i32>) {
        Self {
            phantom_T: PhantomData,
            inputs,
            N: N,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<index_type, dims_Arg, T, value_Arg> GraphOperation for Fill<index_type, dims_Arg, T, value_Arg>
where index_type: TensorType,
      index_type: Clone,
      dims_Arg: Clone,
      dims_Arg: GraphEdge<index_type>,
      dims_Arg: 'static,
      T: TensorType,
      T: Clone,
      value_Arg: Clone,
      value_Arg: GraphEdge<T>,
      value_Arg: 'static,
      T: 'static,
      index_type: con_or_DT_INT32_or_DT_INT64,
      index_type: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("Fill_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("Fill", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.dims)?
        }
        {
            new_op.add_edge(&self.value)?
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        {
            new_op.set_attr_type("index_type", index_type::data_type())?;
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct Fill<index_type, dims_Arg, T, value_Arg>
where index_type: TensorType,
      index_type: Clone,
      dims_Arg: Clone,
      dims_Arg: GraphEdge<index_type>,
      dims_Arg: 'static,
      T: TensorType,
      T: Clone,
      value_Arg: Clone,
      value_Arg: GraphEdge<T>,
      value_Arg: 'static,
      T: 'static,
      index_type: con_or_DT_INT32_or_DT_INT64,
      index_type: 'static,
{
    phantom_index_type: PhantomData<index_type>,
    dims: dims_Arg,
    phantom_T: PhantomData<T>,
    value: value_Arg,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<index_type, dims_Arg, T, value_Arg> Fill<index_type, dims_Arg, T, value_Arg>
where index_type: TensorType,
      index_type: Clone,
      dims_Arg: Clone,
      dims_Arg: GraphEdge<index_type>,
      dims_Arg: 'static,
      T: TensorType,
      T: Clone,
      value_Arg: Clone,
      value_Arg: GraphEdge<T>,
      value_Arg: 'static,
      T: 'static,
      index_type: con_or_DT_INT32_or_DT_INT64,
      index_type: 'static,
{
    pub fn output(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(dims: dims_Arg, value: value_Arg) -> Self {
        Self {
            phantom_index_type: PhantomData,
            dims,
            phantom_T: PhantomData,
            value,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(dims: dims_Arg, value: value_Arg) -> Edge<T> {
        Self {
            phantom_index_type: PhantomData,
            dims,
            phantom_T: PhantomData,
            value,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<T, tensor_Arg, Tindices, indices_Arg, updates_Arg> GraphOperation for TensorScatterSub<T, tensor_Arg, Tindices, indices_Arg, updates_Arg>
where T: TensorType,
      T: Clone,
      tensor_Arg: Clone,
      tensor_Arg: GraphEdge<T>,
      tensor_Arg: 'static,
      Tindices: TensorType,
      Tindices: Clone,
      indices_Arg: Clone,
      indices_Arg: GraphEdge<Tindices>,
      indices_Arg: 'static,
      updates_Arg: Clone,
      updates_Arg: GraphEdge<T>,
      updates_Arg: 'static,
      T: 'static,
      Tindices: con_or_DT_INT32_or_DT_INT64,
      Tindices: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("TensorScatterSub_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("TensorScatterSub", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.tensor)?
        }
        {
            new_op.add_edge(&self.indices)?
        }
        {
            new_op.add_edge(&self.updates)?
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        {
            new_op.set_attr_type("Tindices", Tindices::data_type())?;
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct TensorScatterSub<T, tensor_Arg, Tindices, indices_Arg, updates_Arg>
where T: TensorType,
      T: Clone,
      tensor_Arg: Clone,
      tensor_Arg: GraphEdge<T>,
      tensor_Arg: 'static,
      Tindices: TensorType,
      Tindices: Clone,
      indices_Arg: Clone,
      indices_Arg: GraphEdge<Tindices>,
      indices_Arg: 'static,
      updates_Arg: Clone,
      updates_Arg: GraphEdge<T>,
      updates_Arg: 'static,
      T: 'static,
      Tindices: con_or_DT_INT32_or_DT_INT64,
      Tindices: 'static,
{
    phantom_T: PhantomData<T>,
    tensor: tensor_Arg,
    phantom_Tindices: PhantomData<Tindices>,
    indices: indices_Arg,
    updates: updates_Arg,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<T, tensor_Arg, Tindices, indices_Arg, updates_Arg> TensorScatterSub<T, tensor_Arg, Tindices, indices_Arg, updates_Arg>
where T: TensorType,
      T: Clone,
      tensor_Arg: Clone,
      tensor_Arg: GraphEdge<T>,
      tensor_Arg: 'static,
      Tindices: TensorType,
      Tindices: Clone,
      indices_Arg: Clone,
      indices_Arg: GraphEdge<Tindices>,
      indices_Arg: 'static,
      updates_Arg: Clone,
      updates_Arg: GraphEdge<T>,
      updates_Arg: 'static,
      T: 'static,
      Tindices: con_or_DT_INT32_or_DT_INT64,
      Tindices: 'static,
{
    pub fn output(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(tensor: tensor_Arg, indices: indices_Arg, updates: updates_Arg) -> Self {
        Self {
            phantom_T: PhantomData,
            tensor,
            phantom_Tindices: PhantomData,
            indices,
            updates,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(tensor: tensor_Arg, indices: indices_Arg, updates: updates_Arg) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            tensor,
            phantom_Tindices: PhantomData,
            indices,
            updates,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<T, diagonal_Arg> GraphOperation for MatrixDiag<T, diagonal_Arg>
where T: TensorType,
      T: Clone,
      diagonal_Arg: Clone,
      diagonal_Arg: GraphEdge<T>,
      diagonal_Arg: 'static,
      T: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("MatrixDiag_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("MatrixDiag", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.diagonal)?
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct MatrixDiag<T, diagonal_Arg>
where T: TensorType,
      T: Clone,
      diagonal_Arg: Clone,
      diagonal_Arg: GraphEdge<T>,
      diagonal_Arg: 'static,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    diagonal: diagonal_Arg,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<T, diagonal_Arg> MatrixDiag<T, diagonal_Arg>
where T: TensorType,
      T: Clone,
      diagonal_Arg: Clone,
      diagonal_Arg: GraphEdge<T>,
      diagonal_Arg: 'static,
      T: 'static,
{
    pub fn output(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(diagonal: diagonal_Arg) -> Self {
        Self {
            phantom_T: PhantomData,
            diagonal,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(diagonal: diagonal_Arg) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            diagonal,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<T, x_Arg, y_Arg> GraphOperation for FloorDiv<T, x_Arg, y_Arg>
where T: TensorType,
      T: Clone,
      x_Arg: Clone,
      x_Arg: GraphEdge<T>,
      x_Arg: 'static,
      y_Arg: Clone,
      y_Arg: GraphEdge<T>,
      y_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF,
      T: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("FloorDiv_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("FloorDiv", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.x)?
        }
        {
            new_op.add_edge(&self.y)?
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct FloorDiv<T, x_Arg, y_Arg>
where T: TensorType,
      T: Clone,
      x_Arg: Clone,
      x_Arg: GraphEdge<T>,
      x_Arg: 'static,
      y_Arg: Clone,
      y_Arg: GraphEdge<T>,
      y_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    x: x_Arg,
    y: y_Arg,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<T, x_Arg, y_Arg> FloorDiv<T, x_Arg, y_Arg>
where T: TensorType,
      T: Clone,
      x_Arg: Clone,
      x_Arg: GraphEdge<T>,
      x_Arg: 'static,
      y_Arg: Clone,
      y_Arg: GraphEdge<T>,
      y_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF,
      T: 'static,
{
    pub fn z(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(x: x_Arg, y: y_Arg) -> Self {
        Self {
            phantom_T: PhantomData,
            x,
            y,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(x: x_Arg, y: y_Arg) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            x,
            y,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<T, input_Arg, init_value_Arg> GraphOperation for XlaReduce<T, input_Arg, init_value_Arg>
where T: TensorType,
      T: Clone,
      input_Arg: Clone,
      input_Arg: GraphEdge<T>,
      input_Arg: 'static,
      init_value_Arg: Clone,
      init_value_Arg: GraphEdge<T>,
      init_value_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("XlaReduce_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("XlaReduce", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.input)?
        }
        {
            new_op.add_edge(&self.init_value)?
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        {
            (|attrs| {new_op.set_attr_int_list("dimensions_to_reduce", attrs)})(&self.dimensions_to_reduce)?
        }
        {
            (|attr| {new_op.set_attr_func_name("reducer", attr)})(&self.reducer)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct XlaReduce<T, input_Arg, init_value_Arg>
where T: TensorType,
      T: Clone,
      input_Arg: Clone,
      input_Arg: GraphEdge<T>,
      input_Arg: 'static,
      init_value_Arg: Clone,
      init_value_Arg: GraphEdge<T>,
      init_value_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    input: input_Arg,
    init_value: init_value_Arg,
    dimensions_to_reduce: Vec<i64>,
    reducer: String,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<T, input_Arg, init_value_Arg> XlaReduce<T, input_Arg, init_value_Arg>
where T: TensorType,
      T: Clone,
      input_Arg: Clone,
      input_Arg: GraphEdge<T>,
      input_Arg: 'static,
      init_value_Arg: Clone,
      init_value_Arg: GraphEdge<T>,
      init_value_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
{
    pub fn output(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(input: input_Arg, init_value: init_value_Arg, dimensions_to_reduce: &[i64], reducer: &str) -> Self {
        Self {
            phantom_T: PhantomData,
            input,
            init_value,
            dimensions_to_reduce: dimensions_to_reduce.to_vec(),
            reducer: reducer.to_string(),
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(input: input_Arg, init_value: init_value_Arg, dimensions_to_reduce: &[i64], reducer: &str) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            input,
            init_value,
            dimensions_to_reduce: dimensions_to_reduce.to_vec(),
            reducer: reducer.to_string(),
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<Tparams, params_Arg, Tindices, indices_Arg> GraphOperation for Gather<Tparams, params_Arg, Tindices, indices_Arg>
where Tparams: TensorType,
      Tparams: Clone,
      params_Arg: Clone,
      params_Arg: GraphEdge<Tparams>,
      params_Arg: 'static,
      Tindices: TensorType,
      Tindices: Clone,
      indices_Arg: Clone,
      indices_Arg: GraphEdge<Tindices>,
      indices_Arg: 'static,
      Tparams: 'static,
      Tindices: con_or_DT_INT32_or_DT_INT64,
      Tindices: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("Gather_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("Gather", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.params)?
        }
        {
            new_op.add_edge(&self.indices)?
        }
        {
            match self.validate_indices {
                None => new_op.set_attr_value_proto("validate_indices", &vec![40_u8, 1_u8,])?,
                Some(ref value) => (|attr: &bool| {new_op.set_attr_bool("validate_indices", *attr)})(&value)?,
            };
        }
        {
            new_op.set_attr_type("Tparams", Tparams::data_type())?;
        }
        {
            new_op.set_attr_type("Tindices", Tindices::data_type())?;
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct Gather<Tparams, params_Arg, Tindices, indices_Arg>
where Tparams: TensorType,
      Tparams: Clone,
      params_Arg: Clone,
      params_Arg: GraphEdge<Tparams>,
      params_Arg: 'static,
      Tindices: TensorType,
      Tindices: Clone,
      indices_Arg: Clone,
      indices_Arg: GraphEdge<Tindices>,
      indices_Arg: 'static,
      Tparams: 'static,
      Tindices: con_or_DT_INT32_or_DT_INT64,
      Tindices: 'static,
{
    phantom_Tparams: PhantomData<Tparams>,
    params: params_Arg,
    phantom_Tindices: PhantomData<Tindices>,
    indices: indices_Arg,
    validate_indices: Option<bool>,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<Tparams, params_Arg, Tindices, indices_Arg> Gather<Tparams, params_Arg, Tindices, indices_Arg>
where Tparams: TensorType,
      Tparams: Clone,
      params_Arg: Clone,
      params_Arg: GraphEdge<Tparams>,
      params_Arg: 'static,
      Tindices: TensorType,
      Tindices: Clone,
      indices_Arg: Clone,
      indices_Arg: GraphEdge<Tindices>,
      indices_Arg: 'static,
      Tparams: 'static,
      Tindices: con_or_DT_INT32_or_DT_INT64,
      Tindices: 'static,
{
    pub fn output(self) -> Edge<Tparams> {
        let rc = Rc::new(self);
        {
            Edge::<Tparams>::new(rc.clone(), 0)
        }
    }

    pub fn validate_indices(&mut self, validate_indices: bool) -> Self {
        self.validate_indices = Some(validate_indices);
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<Tparams> {
        let rc = Rc::new(self);
        {
            Edge::<Tparams>::new(rc.clone(), 0)
        }
    }

    pub fn build(params: params_Arg, indices: indices_Arg) -> Self {
        Self {
            phantom_Tparams: PhantomData,
            params,
            phantom_Tindices: PhantomData,
            indices,
            validate_indices: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(params: params_Arg, indices: indices_Arg) -> Edge<Tparams> {
        Self {
            phantom_Tparams: PhantomData,
            params,
            phantom_Tindices: PhantomData,
            indices,
            validate_indices: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<Tparams, params_Arg, Tindices, indices_Arg, Taxis, axis_Arg> GraphOperation for GatherV2<Tparams, params_Arg, Tindices, indices_Arg, Taxis, axis_Arg>
where Tparams: TensorType,
      Tparams: Clone,
      params_Arg: Clone,
      params_Arg: GraphEdge<Tparams>,
      params_Arg: 'static,
      Tindices: TensorType,
      Tindices: Clone,
      indices_Arg: Clone,
      indices_Arg: GraphEdge<Tindices>,
      indices_Arg: 'static,
      Taxis: TensorType,
      Taxis: Clone,
      axis_Arg: Clone,
      axis_Arg: GraphEdge<Taxis>,
      axis_Arg: 'static,
      Tparams: 'static,
      Tindices: con_or_DT_INT32_or_DT_INT64,
      Tindices: 'static,
      Taxis: con_or_DT_INT32_or_DT_INT64,
      Taxis: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("GatherV2_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("GatherV2", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.params)?
        }
        {
            new_op.add_edge(&self.indices)?
        }
        {
            new_op.add_edge(&self.axis)?
        }
        {
            new_op.set_attr_type("Tparams", Tparams::data_type())?;
        }
        {
            new_op.set_attr_type("Tindices", Tindices::data_type())?;
        }
        {
            new_op.set_attr_type("Taxis", Taxis::data_type())?;
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct GatherV2<Tparams, params_Arg, Tindices, indices_Arg, Taxis, axis_Arg>
where Tparams: TensorType,
      Tparams: Clone,
      params_Arg: Clone,
      params_Arg: GraphEdge<Tparams>,
      params_Arg: 'static,
      Tindices: TensorType,
      Tindices: Clone,
      indices_Arg: Clone,
      indices_Arg: GraphEdge<Tindices>,
      indices_Arg: 'static,
      Taxis: TensorType,
      Taxis: Clone,
      axis_Arg: Clone,
      axis_Arg: GraphEdge<Taxis>,
      axis_Arg: 'static,
      Tparams: 'static,
      Tindices: con_or_DT_INT32_or_DT_INT64,
      Tindices: 'static,
      Taxis: con_or_DT_INT32_or_DT_INT64,
      Taxis: 'static,
{
    phantom_Tparams: PhantomData<Tparams>,
    params: params_Arg,
    phantom_Tindices: PhantomData<Tindices>,
    indices: indices_Arg,
    phantom_Taxis: PhantomData<Taxis>,
    axis: axis_Arg,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<Tparams, params_Arg, Tindices, indices_Arg, Taxis, axis_Arg> GatherV2<Tparams, params_Arg, Tindices, indices_Arg, Taxis, axis_Arg>
where Tparams: TensorType,
      Tparams: Clone,
      params_Arg: Clone,
      params_Arg: GraphEdge<Tparams>,
      params_Arg: 'static,
      Tindices: TensorType,
      Tindices: Clone,
      indices_Arg: Clone,
      indices_Arg: GraphEdge<Tindices>,
      indices_Arg: 'static,
      Taxis: TensorType,
      Taxis: Clone,
      axis_Arg: Clone,
      axis_Arg: GraphEdge<Taxis>,
      axis_Arg: 'static,
      Tparams: 'static,
      Tindices: con_or_DT_INT32_or_DT_INT64,
      Tindices: 'static,
      Taxis: con_or_DT_INT32_or_DT_INT64,
      Taxis: 'static,
{
    pub fn output(self) -> Edge<Tparams> {
        let rc = Rc::new(self);
        {
            Edge::<Tparams>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<Tparams> {
        let rc = Rc::new(self);
        {
            Edge::<Tparams>::new(rc.clone(), 0)
        }
    }

    pub fn build(params: params_Arg, indices: indices_Arg, axis: axis_Arg) -> Self {
        Self {
            phantom_Tparams: PhantomData,
            params,
            phantom_Tindices: PhantomData,
            indices,
            phantom_Taxis: PhantomData,
            axis,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(params: params_Arg, indices: indices_Arg, axis: axis_Arg) -> Edge<Tparams> {
        Self {
            phantom_Tparams: PhantomData,
            params,
            phantom_Tindices: PhantomData,
            indices,
            phantom_Taxis: PhantomData,
            axis,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<input_values_Arg, input_splits_Arg> GraphOperation for UnicodeEncode<input_values_Arg, input_splits_Arg>
where input_values_Arg: Clone,
      input_values_Arg: GraphEdge<i32>,
      input_values_Arg: 'static,
      input_splits_Arg: Clone,
      input_splits_Arg: GraphEdge<i64>,
      input_splits_Arg: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("UnicodeEncode_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("UnicodeEncode", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.input_values)?
        }
        {
            new_op.add_edge(&self.input_splits)?
        }
        {
            match self.errors {
                None => new_op.set_attr_value_proto("errors", &vec![18_u8, 7_u8, 114_u8, 101_u8, 112_u8, 108_u8, 97_u8, 99_u8, 101_u8,])?,
                Some(ref value) => (|attr| {new_op.set_attr_string("errors", attr)})(&value)?,
            };
        }
        {
            (|attr| {new_op.set_attr_string("output_encoding", attr)})(&self.output_encoding)?
        }
        {
            match self.replacement_char {
                None => new_op.set_attr_value_proto("replacement_char", &vec![24_u8, 253_u8, 255_u8, 3_u8,])?,
                Some(ref value) => (|attr: &i64| {new_op.set_attr_int("replacement_char", *attr)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct UnicodeEncode<input_values_Arg, input_splits_Arg>
where input_values_Arg: Clone,
      input_values_Arg: GraphEdge<i32>,
      input_values_Arg: 'static,
      input_splits_Arg: Clone,
      input_splits_Arg: GraphEdge<i64>,
      input_splits_Arg: 'static,
{
    input_values: input_values_Arg,
    input_splits: input_splits_Arg,
    errors: Option<String>,
    output_encoding: String,
    replacement_char: Option<i64>,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<input_values_Arg, input_splits_Arg> UnicodeEncode<input_values_Arg, input_splits_Arg>
where input_values_Arg: Clone,
      input_values_Arg: GraphEdge<i32>,
      input_values_Arg: 'static,
      input_splits_Arg: Clone,
      input_splits_Arg: GraphEdge<i64>,
      input_splits_Arg: 'static,
{
    pub fn output(self) -> Edge<String> {
        let rc = Rc::new(self);
        {
            Edge::<String>::new(rc.clone(), 0)
        }
    }

    pub fn errors(&mut self, errors: &str) -> Self {
        self.errors = Some(errors.to_string());
        self.clone()
    }

    pub fn replacement_char(&mut self, replacement_char: i64) -> Self {
        self.replacement_char = Some(replacement_char);
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<String> {
        let rc = Rc::new(self);
        {
            Edge::<String>::new(rc.clone(), 0)
        }
    }

    pub fn build(input_values: input_values_Arg, input_splits: input_splits_Arg, output_encoding: &str) -> Self {
        Self {
            input_values,
            input_splits,
            errors: None,
            output_encoding: output_encoding.to_string(),
            replacement_char: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(input_values: input_values_Arg, input_splits: input_splits_Arg, output_encoding: &str) -> Edge<String> {
        Self {
            input_values,
            input_splits,
            errors: None,
            output_encoding: output_encoding.to_string(),
            replacement_char: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<T, x_Arg> GraphOperation for Erfc<T, x_Arg>
where T: TensorType,
      T: Clone,
      x_Arg: Clone,
      x_Arg: GraphEdge<T>,
      x_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
      T: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("Erfc_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("Erfc", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.x)?
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct Erfc<T, x_Arg>
where T: TensorType,
      T: Clone,
      x_Arg: Clone,
      x_Arg: GraphEdge<T>,
      x_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    x: x_Arg,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<T, x_Arg> Erfc<T, x_Arg>
where T: TensorType,
      T: Clone,
      x_Arg: Clone,
      x_Arg: GraphEdge<T>,
      x_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
      T: 'static,
{
    pub fn y(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(x: x_Arg) -> Self {
        Self {
            phantom_T: PhantomData,
            x,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(x: x_Arg) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            x,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<T, input_Arg> GraphOperation for DiagPart<T, input_Arg>
where T: TensorType,
      T: Clone,
      input_Arg: Clone,
      input_Arg: GraphEdge<T>,
      input_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_COMPLEX64_or_DT_INT64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF,
      T: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("DiagPart_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("DiagPart", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.input)?
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct DiagPart<T, input_Arg>
where T: TensorType,
      T: Clone,
      input_Arg: Clone,
      input_Arg: GraphEdge<T>,
      input_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_COMPLEX64_or_DT_INT64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    input: input_Arg,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<T, input_Arg> DiagPart<T, input_Arg>
where T: TensorType,
      T: Clone,
      input_Arg: Clone,
      input_Arg: GraphEdge<T>,
      input_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_COMPLEX64_or_DT_INT64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF,
      T: 'static,
{
    pub fn diagonal(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(input: input_Arg) -> Self {
        Self {
            phantom_T: PhantomData,
            input,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(input: input_Arg) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            input,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<T, x_Arg, x_min_Arg, x_max_Arg> GraphOperation for QuantizedInstanceNorm<T, x_Arg, x_min_Arg, x_max_Arg>
where T: TensorType,
      T: Clone,
      x_Arg: Clone,
      x_Arg: GraphEdge<T>,
      x_Arg: 'static,
      x_min_Arg: Clone,
      x_min_Arg: GraphEdge<f32>,
      x_min_Arg: 'static,
      x_max_Arg: Clone,
      x_max_Arg: GraphEdge<f32>,
      x_max_Arg: 'static,
      T: con_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_QINT16_or_DT_QUINT16,
      T: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("QuantizedInstanceNorm_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("QuantizedInstanceNorm", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.x)?
        }
        {
            new_op.add_edge(&self.x_min)?
        }
        {
            new_op.add_edge(&self.x_max)?
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        {
            match self.output_range_given {
                None => new_op.set_attr_value_proto("output_range_given", &vec![40_u8, 0_u8,])?,
                Some(ref value) => (|attr: &bool| {new_op.set_attr_bool("output_range_given", *attr)})(&value)?,
            };
        }
        {
            match self.given_y_min {
                None => new_op.set_attr_value_proto("given_y_min", &vec![37_u8, 0_u8, 0_u8, 0_u8, 0_u8,])?,
                Some(ref value) => (|attr: &f32| {new_op.set_attr_float("given_y_min", *attr)})(&value)?,
            };
        }
        {
            match self.given_y_max {
                None => new_op.set_attr_value_proto("given_y_max", &vec![37_u8, 0_u8, 0_u8, 0_u8, 0_u8,])?,
                Some(ref value) => (|attr: &f32| {new_op.set_attr_float("given_y_max", *attr)})(&value)?,
            };
        }
        {
            match self.variance_epsilon {
                None => new_op.set_attr_value_proto("variance_epsilon", &vec![37_u8, 172_u8, 197_u8, 39_u8, 55_u8,])?,
                Some(ref value) => (|attr: &f32| {new_op.set_attr_float("variance_epsilon", *attr)})(&value)?,
            };
        }
        {
            match self.min_separation {
                None => new_op.set_attr_value_proto("min_separation", &vec![37_u8, 111_u8, 18_u8, 131_u8, 58_u8,])?,
                Some(ref value) => (|attr: &f32| {new_op.set_attr_float("min_separation", *attr)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct QuantizedInstanceNorm<T, x_Arg, x_min_Arg, x_max_Arg>
where T: TensorType,
      T: Clone,
      x_Arg: Clone,
      x_Arg: GraphEdge<T>,
      x_Arg: 'static,
      x_min_Arg: Clone,
      x_min_Arg: GraphEdge<f32>,
      x_min_Arg: 'static,
      x_max_Arg: Clone,
      x_max_Arg: GraphEdge<f32>,
      x_max_Arg: 'static,
      T: con_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_QINT16_or_DT_QUINT16,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    x: x_Arg,
    x_min: x_min_Arg,
    x_max: x_max_Arg,
    output_range_given: Option<bool>,
    given_y_min: Option<f32>,
    given_y_max: Option<f32>,
    variance_epsilon: Option<f32>,
    min_separation: Option<f32>,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<T, x_Arg, x_min_Arg, x_max_Arg> QuantizedInstanceNorm<T, x_Arg, x_min_Arg, x_max_Arg>
where T: TensorType,
      T: Clone,
      x_Arg: Clone,
      x_Arg: GraphEdge<T>,
      x_Arg: 'static,
      x_min_Arg: Clone,
      x_min_Arg: GraphEdge<f32>,
      x_min_Arg: 'static,
      x_max_Arg: Clone,
      x_max_Arg: GraphEdge<f32>,
      x_max_Arg: 'static,
      T: con_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_QINT16_or_DT_QUINT16,
      T: 'static,
{
    pub fn y(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn y_min(self) -> Edge<f32> {
        let rc = Rc::new(self);
        {
            Edge::<f32>::new(rc.clone(), 1)
        }
    }

    pub fn y_max(self) -> Edge<f32> {
        let rc = Rc::new(self);
        {
            Edge::<f32>::new(rc.clone(), 2)
        }
    }

    pub fn output_range_given(&mut self, output_range_given: bool) -> Self {
        self.output_range_given = Some(output_range_given);
        self.clone()
    }

    pub fn given_y_min(&mut self, given_y_min: f32) -> Self {
        self.given_y_min = Some(given_y_min);
        self.clone()
    }

    pub fn given_y_max(&mut self, given_y_max: f32) -> Self {
        self.given_y_max = Some(given_y_max);
        self.clone()
    }

    pub fn variance_epsilon(&mut self, variance_epsilon: f32) -> Self {
        self.variance_epsilon = Some(variance_epsilon);
        self.clone()
    }

    pub fn min_separation(&mut self, min_separation: f32) -> Self {
        self.min_separation = Some(min_separation);
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> (Edge<T>, Edge<f32>, Edge<f32>) {
        let rc = Rc::new(self);
        (
        {
            Edge::<T>::new(rc.clone(), 0)
        },
        {
            Edge::<f32>::new(rc.clone(), 1)
        },
        {
            Edge::<f32>::new(rc.clone(), 2)
        },
        )
    }

    pub fn build(x: x_Arg, x_min: x_min_Arg, x_max: x_max_Arg) -> Self {
        Self {
            phantom_T: PhantomData,
            x,
            x_min,
            x_max,
            output_range_given: None,
            given_y_min: None,
            given_y_max: None,
            variance_epsilon: None,
            min_separation: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(x: x_Arg, x_min: x_min_Arg, x_max: x_max_Arg) -> (Edge<T>, Edge<f32>, Edge<f32>) {
        Self {
            phantom_T: PhantomData,
            x,
            x_min,
            x_max,
            output_range_given: None,
            given_y_min: None,
            given_y_max: None,
            variance_epsilon: None,
            min_separation: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<T, input_Arg> GraphOperation for RefIdentity<T, input_Arg>
where T: TensorType,
      T: Clone,
      input_Arg: Clone,
      input_Arg: GraphRefEdge<T>,
      input_Arg: 'static,
      T: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("RefIdentity_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("RefIdentity", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.input)?
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct RefIdentity<T, input_Arg>
where T: TensorType,
      T: Clone,
      input_Arg: Clone,
      input_Arg: GraphRefEdge<T>,
      input_Arg: 'static,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    input: input_Arg,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<T, input_Arg> RefIdentity<T, input_Arg>
where T: TensorType,
      T: Clone,
      input_Arg: Clone,
      input_Arg: GraphRefEdge<T>,
      input_Arg: 'static,
      T: 'static,
{
    pub fn output(self) -> RefEdge<T> {
        let rc = Rc::new(self);
        {
            RefEdge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> RefEdge<T> {
        let rc = Rc::new(self);
        {
            RefEdge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(input: input_Arg) -> Self {
        Self {
            phantom_T: PhantomData,
            input,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(input: input_Arg) -> RefEdge<T> {
        Self {
            phantom_T: PhantomData,
            input,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<T, input_Arg> GraphOperation for StopGradient<T, input_Arg>
where T: TensorType,
      T: Clone,
      input_Arg: Clone,
      input_Arg: GraphEdge<T>,
      input_Arg: 'static,
      T: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("StopGradient_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("StopGradient", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.input)?
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct StopGradient<T, input_Arg>
where T: TensorType,
      T: Clone,
      input_Arg: Clone,
      input_Arg: GraphEdge<T>,
      input_Arg: 'static,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    input: input_Arg,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<T, input_Arg> StopGradient<T, input_Arg>
where T: TensorType,
      T: Clone,
      input_Arg: Clone,
      input_Arg: GraphEdge<T>,
      input_Arg: 'static,
      T: 'static,
{
    pub fn output(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(input: input_Arg) -> Self {
        Self {
            phantom_T: PhantomData,
            input,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(input: input_Arg) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            input,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<T, x_Arg> GraphOperation for Asin<T, x_Arg>
where T: TensorType,
      T: Clone,
      x_Arg: Clone,
      x_Arg: GraphEdge<T>,
      x_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_COMPLEX64_or_DT_INT64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF,
      T: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("Asin_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("Asin", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.x)?
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct Asin<T, x_Arg>
where T: TensorType,
      T: Clone,
      x_Arg: Clone,
      x_Arg: GraphEdge<T>,
      x_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_COMPLEX64_or_DT_INT64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    x: x_Arg,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<T, x_Arg> Asin<T, x_Arg>
where T: TensorType,
      T: Clone,
      x_Arg: Clone,
      x_Arg: GraphEdge<T>,
      x_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_COMPLEX64_or_DT_INT64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF,
      T: 'static,
{
    pub fn y(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(x: x_Arg) -> Self {
        Self {
            phantom_T: PhantomData,
            x,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(x: x_Arg) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            x,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<T, input_Arg> GraphOperation for PreventGradient<T, input_Arg>
where T: TensorType,
      T: Clone,
      input_Arg: Clone,
      input_Arg: GraphEdge<T>,
      input_Arg: 'static,
      T: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("PreventGradient_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("PreventGradient", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.input)?
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        {
            match self.message {
                None => new_op.set_attr_value_proto("message", &vec![18_u8, 0_u8,])?,
                Some(ref value) => (|attr| {new_op.set_attr_string("message", attr)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct PreventGradient<T, input_Arg>
where T: TensorType,
      T: Clone,
      input_Arg: Clone,
      input_Arg: GraphEdge<T>,
      input_Arg: 'static,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    input: input_Arg,
    message: Option<String>,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<T, input_Arg> PreventGradient<T, input_Arg>
where T: TensorType,
      T: Clone,
      input_Arg: Clone,
      input_Arg: GraphEdge<T>,
      input_Arg: 'static,
      T: 'static,
{
    pub fn output(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn message(&mut self, message: &str) -> Self {
        self.message = Some(message.to_string());
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(input: input_Arg) -> Self {
        Self {
            phantom_T: PhantomData,
            input,
            message: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(input: input_Arg) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            input,
            message: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<T, values_Arg, Tidx, axis_Arg> GraphOperation for ConcatV2<T, values_Arg, Tidx, axis_Arg>
where T: TensorType,
      T: Clone,
      values_Arg: Clone,
      values_Arg: GraphEdge<T>,
      values_Arg: 'static,
      Tidx: TensorType,
      Tidx: Clone,
      axis_Arg: Clone,
      axis_Arg: GraphEdge<Tidx>,
      axis_Arg: 'static,
      T: 'static,
      Tidx: con_or_DT_INT32_or_DT_INT64,
      Tidx: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("ConcatV2_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("ConcatV2", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.values)?
        }
        {
            new_op.add_edge(&self.axis)?
        }
        {
            (|attr: &i64| {new_op.set_attr_int("N", *attr)})(&self.N)?
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        {
            new_op.set_attr_type("Tidx", Tidx::data_type())?;
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct ConcatV2<T, values_Arg, Tidx, axis_Arg>
where T: TensorType,
      T: Clone,
      values_Arg: Clone,
      values_Arg: GraphEdge<T>,
      values_Arg: 'static,
      Tidx: TensorType,
      Tidx: Clone,
      axis_Arg: Clone,
      axis_Arg: GraphEdge<Tidx>,
      axis_Arg: 'static,
      T: 'static,
      Tidx: con_or_DT_INT32_or_DT_INT64,
      Tidx: 'static,
{
    phantom_T: PhantomData<T>,
    values: values_Arg,
    phantom_Tidx: PhantomData<Tidx>,
    axis: axis_Arg,
    N: i64,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<T, values_Arg, Tidx, axis_Arg> ConcatV2<T, values_Arg, Tidx, axis_Arg>
where T: TensorType,
      T: Clone,
      values_Arg: Clone,
      values_Arg: GraphEdge<T>,
      values_Arg: 'static,
      Tidx: TensorType,
      Tidx: Clone,
      axis_Arg: Clone,
      axis_Arg: GraphEdge<Tidx>,
      axis_Arg: 'static,
      T: 'static,
      Tidx: con_or_DT_INT32_or_DT_INT64,
      Tidx: 'static,
{
    pub fn output(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(values: values_Arg, axis: axis_Arg, N: i64) -> Self {
        Self {
            phantom_T: PhantomData,
            values,
            phantom_Tidx: PhantomData,
            axis,
            N: N,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(values: values_Arg, axis: axis_Arg, N: i64) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            values,
            phantom_Tidx: PhantomData,
            axis,
            N: N,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<filename_Arg> GraphOperation for ReadFile<filename_Arg>
where filename_Arg: Clone,
      filename_Arg: GraphEdge<String>,
      filename_Arg: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("ReadFile_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("ReadFile", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.filename)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct ReadFile<filename_Arg>
where filename_Arg: Clone,
      filename_Arg: GraphEdge<String>,
      filename_Arg: 'static,
{
    filename: filename_Arg,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<filename_Arg> ReadFile<filename_Arg>
where filename_Arg: Clone,
      filename_Arg: GraphEdge<String>,
      filename_Arg: 'static,
{
    pub fn contents(self) -> Edge<String> {
        let rc = Rc::new(self);
        {
            Edge::<String>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<String> {
        let rc = Rc::new(self);
        {
            Edge::<String>::new(rc.clone(), 0)
        }
    }

    pub fn build(filename: filename_Arg) -> Self {
        Self {
            filename,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(filename: filename_Arg) -> Edge<String> {
        Self {
            filename,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<dtype, input_Arg> GraphOperation for PlaceholderWithDefault<dtype, input_Arg>
where dtype: TensorType,
      dtype: Clone,
      input_Arg: Clone,
      input_Arg: GraphEdge<dtype>,
      input_Arg: 'static,
      dtype: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("PlaceholderWithDefault_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("PlaceholderWithDefault", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.input)?
        }
        {
            new_op.set_attr_type("dtype", dtype::data_type())?;
        }
        {
            (|attr| {new_op.set_attr_shape("shape", attr)})(&self.shape)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct PlaceholderWithDefault<dtype, input_Arg>
where dtype: TensorType,
      dtype: Clone,
      input_Arg: Clone,
      input_Arg: GraphEdge<dtype>,
      input_Arg: 'static,
      dtype: 'static,
{
    phantom_dtype: PhantomData<dtype>,
    input: input_Arg,
    shape: OtherShape,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<dtype, input_Arg> PlaceholderWithDefault<dtype, input_Arg>
where dtype: TensorType,
      dtype: Clone,
      input_Arg: Clone,
      input_Arg: GraphEdge<dtype>,
      input_Arg: 'static,
      dtype: 'static,
{
    pub fn output(self) -> Edge<dtype> {
        let rc = Rc::new(self);
        {
            Edge::<dtype>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<dtype> {
        let rc = Rc::new(self);
        {
            Edge::<dtype>::new(rc.clone(), 0)
        }
    }

    pub fn build(input: input_Arg, shape: &OtherShape) -> Self {
        Self {
            phantom_dtype: PhantomData,
            input,
            shape: shape.clone(),
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(input: input_Arg, shape: &OtherShape) -> Edge<dtype> {
        Self {
            phantom_dtype: PhantomData,
            input,
            shape: shape.clone(),
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<T1, a_Arg, T2, b_Arg, min_a_Arg, max_a_Arg, min_b_Arg, max_b_Arg, Toutput, Tactivation> GraphOperation for QuantizedMatMul<T1, a_Arg, T2, b_Arg, min_a_Arg, max_a_Arg, min_b_Arg, max_b_Arg, Toutput, Tactivation>
where T1: TensorType,
      T1: Clone,
      a_Arg: Clone,
      a_Arg: GraphEdge<T1>,
      a_Arg: 'static,
      T2: TensorType,
      T2: Clone,
      b_Arg: Clone,
      b_Arg: GraphEdge<T2>,
      b_Arg: 'static,
      min_a_Arg: Clone,
      min_a_Arg: GraphEdge<f32>,
      min_a_Arg: 'static,
      max_a_Arg: Clone,
      max_a_Arg: GraphEdge<f32>,
      max_a_Arg: 'static,
      min_b_Arg: Clone,
      min_b_Arg: GraphEdge<f32>,
      min_b_Arg: 'static,
      max_b_Arg: Clone,
      max_b_Arg: GraphEdge<f32>,
      max_b_Arg: 'static,
      Toutput: TensorType,
      T1: con_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_QINT16_or_DT_QUINT16,
      T1: 'static,
      T2: con_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_QINT16_or_DT_QUINT16,
      T2: 'static,
      Toutput: con_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_QINT16_or_DT_QUINT16,
      Toutput: 'static,
      Toutput: Clone,
      Tactivation: con_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_QINT16_or_DT_QUINT16,
      Tactivation: TensorType,
      Tactivation: 'static,
      Tactivation: Clone,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("QuantizedMatMul_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("QuantizedMatMul", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.a)?
        }
        {
            new_op.add_edge(&self.b)?
        }
        {
            new_op.add_edge(&self.min_a)?
        }
        {
            new_op.add_edge(&self.max_a)?
        }
        {
            new_op.add_edge(&self.min_b)?
        }
        {
            new_op.add_edge(&self.max_b)?
        }
        {
            new_op.set_attr_type("T1", T1::data_type())?;
        }
        {
            new_op.set_attr_type("T2", T2::data_type())?;
        }
        {
            new_op.set_attr_type("Toutput", Toutput::data_type())?;
        }
        {
            match self.transpose_a {
                None => new_op.set_attr_value_proto("transpose_a", &vec![40_u8, 0_u8,])?,
                Some(ref value) => (|attr: &bool| {new_op.set_attr_bool("transpose_a", *attr)})(&value)?,
            };
        }
        {
            match self.transpose_b {
                None => new_op.set_attr_value_proto("transpose_b", &vec![40_u8, 0_u8,])?,
                Some(ref value) => (|attr: &bool| {new_op.set_attr_bool("transpose_b", *attr)})(&value)?,
            };
        }
        {
            new_op.set_attr_type("Tactivation", Tactivation::data_type())?;
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct QuantizedMatMul<T1, a_Arg, T2, b_Arg, min_a_Arg, max_a_Arg, min_b_Arg, max_b_Arg, Toutput, Tactivation>
where T1: TensorType,
      T1: Clone,
      a_Arg: Clone,
      a_Arg: GraphEdge<T1>,
      a_Arg: 'static,
      T2: TensorType,
      T2: Clone,
      b_Arg: Clone,
      b_Arg: GraphEdge<T2>,
      b_Arg: 'static,
      min_a_Arg: Clone,
      min_a_Arg: GraphEdge<f32>,
      min_a_Arg: 'static,
      max_a_Arg: Clone,
      max_a_Arg: GraphEdge<f32>,
      max_a_Arg: 'static,
      min_b_Arg: Clone,
      min_b_Arg: GraphEdge<f32>,
      min_b_Arg: 'static,
      max_b_Arg: Clone,
      max_b_Arg: GraphEdge<f32>,
      max_b_Arg: 'static,
      Toutput: TensorType,
      T1: con_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_QINT16_or_DT_QUINT16,
      T1: 'static,
      T2: con_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_QINT16_or_DT_QUINT16,
      T2: 'static,
      Toutput: con_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_QINT16_or_DT_QUINT16,
      Toutput: 'static,
      Toutput: Clone,
      Tactivation: con_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_QINT16_or_DT_QUINT16,
      Tactivation: TensorType,
      Tactivation: 'static,
      Tactivation: Clone,
{
    phantom_T1: PhantomData<T1>,
    a: a_Arg,
    phantom_T2: PhantomData<T2>,
    b: b_Arg,
    min_a: min_a_Arg,
    max_a: max_a_Arg,
    min_b: min_b_Arg,
    max_b: max_b_Arg,
    phantom_Toutput: PhantomData<Toutput>,
    transpose_a: Option<bool>,
    transpose_b: Option<bool>,
    phantom_Tactivation: PhantomData<Tactivation>,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<T1, a_Arg, T2, b_Arg, min_a_Arg, max_a_Arg, min_b_Arg, max_b_Arg, Toutput, Tactivation> QuantizedMatMul<T1, a_Arg, T2, b_Arg, min_a_Arg, max_a_Arg, min_b_Arg, max_b_Arg, Toutput, Tactivation>
where T1: TensorType,
      T1: Clone,
      a_Arg: Clone,
      a_Arg: GraphEdge<T1>,
      a_Arg: 'static,
      T2: TensorType,
      T2: Clone,
      b_Arg: Clone,
      b_Arg: GraphEdge<T2>,
      b_Arg: 'static,
      min_a_Arg: Clone,
      min_a_Arg: GraphEdge<f32>,
      min_a_Arg: 'static,
      max_a_Arg: Clone,
      max_a_Arg: GraphEdge<f32>,
      max_a_Arg: 'static,
      min_b_Arg: Clone,
      min_b_Arg: GraphEdge<f32>,
      min_b_Arg: 'static,
      max_b_Arg: Clone,
      max_b_Arg: GraphEdge<f32>,
      max_b_Arg: 'static,
      Toutput: TensorType,
      T1: con_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_QINT16_or_DT_QUINT16,
      T1: 'static,
      T2: con_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_QINT16_or_DT_QUINT16,
      T2: 'static,
      Toutput: con_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_QINT16_or_DT_QUINT16,
      Toutput: 'static,
      Toutput: Clone,
      Tactivation: con_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_QINT16_or_DT_QUINT16,
      Tactivation: TensorType,
      Tactivation: 'static,
      Tactivation: Clone,
{
    pub fn out(self) -> Edge<Toutput> {
        let rc = Rc::new(self);
        {
            Edge::<Toutput>::new(rc.clone(), 0)
        }
    }

    pub fn min_out(self) -> Edge<f32> {
        let rc = Rc::new(self);
        {
            Edge::<f32>::new(rc.clone(), 1)
        }
    }

    pub fn max_out(self) -> Edge<f32> {
        let rc = Rc::new(self);
        {
            Edge::<f32>::new(rc.clone(), 2)
        }
    }

    pub fn transpose_a(&mut self, transpose_a: bool) -> Self {
        self.transpose_a = Some(transpose_a);
        self.clone()
    }

    pub fn transpose_b(&mut self, transpose_b: bool) -> Self {
        self.transpose_b = Some(transpose_b);
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> (Edge<Toutput>, Edge<f32>, Edge<f32>) {
        let rc = Rc::new(self);
        (
        {
            Edge::<Toutput>::new(rc.clone(), 0)
        },
        {
            Edge::<f32>::new(rc.clone(), 1)
        },
        {
            Edge::<f32>::new(rc.clone(), 2)
        },
        )
    }

    pub fn build(a: a_Arg, b: b_Arg, min_a: min_a_Arg, max_a: max_a_Arg, min_b: min_b_Arg, max_b: max_b_Arg) -> Self {
        Self {
            phantom_T1: PhantomData,
            a,
            phantom_T2: PhantomData,
            b,
            min_a,
            max_a,
            min_b,
            max_b,
            phantom_Toutput: PhantomData,
            transpose_a: None,
            transpose_b: None,
            phantom_Tactivation: PhantomData,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(a: a_Arg, b: b_Arg, min_a: min_a_Arg, max_a: max_a_Arg, min_b: min_b_Arg, max_b: max_b_Arg) -> (Edge<Toutput>, Edge<f32>, Edge<f32>) {
        Self {
            phantom_T1: PhantomData,
            a,
            phantom_T2: PhantomData,
            b,
            min_a,
            max_a,
            min_b,
            max_b,
            phantom_Toutput: PhantomData,
            transpose_a: None,
            transpose_b: None,
            phantom_Tactivation: PhantomData,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<T, input_Arg, diagonal_Arg> GraphOperation for BatchMatrixSetDiag<T, input_Arg, diagonal_Arg>
where T: TensorType,
      T: Clone,
      input_Arg: Clone,
      input_Arg: GraphEdge<T>,
      input_Arg: 'static,
      diagonal_Arg: Clone,
      diagonal_Arg: GraphEdge<T>,
      diagonal_Arg: 'static,
      T: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("BatchMatrixSetDiag_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("BatchMatrixSetDiag", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.input)?
        }
        {
            new_op.add_edge(&self.diagonal)?
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct BatchMatrixSetDiag<T, input_Arg, diagonal_Arg>
where T: TensorType,
      T: Clone,
      input_Arg: Clone,
      input_Arg: GraphEdge<T>,
      input_Arg: 'static,
      diagonal_Arg: Clone,
      diagonal_Arg: GraphEdge<T>,
      diagonal_Arg: 'static,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    input: input_Arg,
    diagonal: diagonal_Arg,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<T, input_Arg, diagonal_Arg> BatchMatrixSetDiag<T, input_Arg, diagonal_Arg>
where T: TensorType,
      T: Clone,
      input_Arg: Clone,
      input_Arg: GraphEdge<T>,
      input_Arg: 'static,
      diagonal_Arg: Clone,
      diagonal_Arg: GraphEdge<T>,
      diagonal_Arg: 'static,
      T: 'static,
{
    pub fn output(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(input: input_Arg, diagonal: diagonal_Arg) -> Self {
        Self {
            phantom_T: PhantomData,
            input,
            diagonal,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(input: input_Arg, diagonal: diagonal_Arg) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            input,
            diagonal,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<dtype> GraphOperation for XlaRecv<dtype>
where dtype: TensorType,
      dtype: 'static,
      dtype: Clone,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("XlaRecv_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("XlaRecv", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.set_attr_type("dtype", dtype::data_type())?;
        }
        {
            (|attr| {new_op.set_attr_string("tensor_name", attr)})(&self.tensor_name)?
        }
        {
            (|attr| {new_op.set_attr_shape("shape", attr)})(&self.shape)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct XlaRecv<dtype>
where dtype: TensorType,
      dtype: 'static,
      dtype: Clone,
{
    phantom_dtype: PhantomData<dtype>,
    tensor_name: String,
    shape: OtherShape,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<dtype> XlaRecv<dtype>
where dtype: TensorType,
      dtype: 'static,
      dtype: Clone,
{
    pub fn tensor(self) -> Edge<dtype> {
        let rc = Rc::new(self);
        {
            Edge::<dtype>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<dtype> {
        let rc = Rc::new(self);
        {
            Edge::<dtype>::new(rc.clone(), 0)
        }
    }

    pub fn build(tensor_name: &str, shape: &OtherShape) -> Self {
        Self {
            phantom_dtype: PhantomData,
            tensor_name: tensor_name.to_string(),
            shape: shape.clone(),
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(tensor_name: &str, shape: &OtherShape) -> Edge<dtype> {
        Self {
            phantom_dtype: PhantomData,
            tensor_name: tensor_name.to_string(),
            shape: shape.clone(),
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<T, images_Arg> GraphOperation for ExtractImagePatches<T, images_Arg>
where T: TensorType,
      T: Clone,
      images_Arg: Clone,
      images_Arg: GraphEdge<T>,
      images_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("ExtractImagePatches_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("ExtractImagePatches", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.images)?
        }
        {
            (|attrs| {new_op.set_attr_int_list("ksizes", attrs)})(&self.ksizes)?
        }
        {
            (|attrs| {new_op.set_attr_int_list("strides", attrs)})(&self.strides)?
        }
        {
            (|attrs| {new_op.set_attr_int_list("rates", attrs)})(&self.rates)?
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        {
            (|attr| {new_op.set_attr_string("padding", attr)})(&self.padding)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct ExtractImagePatches<T, images_Arg>
where T: TensorType,
      T: Clone,
      images_Arg: Clone,
      images_Arg: GraphEdge<T>,
      images_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    images: images_Arg,
    ksizes: Vec<i64>,
    strides: Vec<i64>,
    rates: Vec<i64>,
    padding: String,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<T, images_Arg> ExtractImagePatches<T, images_Arg>
where T: TensorType,
      T: Clone,
      images_Arg: Clone,
      images_Arg: GraphEdge<T>,
      images_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
{
    pub fn patches(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(images: images_Arg, ksizes: &[i64], strides: &[i64], rates: &[i64], padding: &str) -> Self {
        Self {
            phantom_T: PhantomData,
            images,
            ksizes: ksizes.to_vec(),
            strides: strides.to_vec(),
            rates: rates.to_vec(),
            padding: padding.to_string(),
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(images: images_Arg, ksizes: &[i64], strides: &[i64], rates: &[i64], padding: &str) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            images,
            ksizes: ksizes.to_vec(),
            strides: strides.to_vec(),
            rates: rates.to_vec(),
            padding: padding.to_string(),
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<num_layers_Arg, num_units_Arg, input_size_Arg, T, params_Arg> GraphOperation for CudnnRNNParamsToCanonical<num_layers_Arg, num_units_Arg, input_size_Arg, T, params_Arg>
where num_layers_Arg: Clone,
      num_layers_Arg: GraphEdge<i32>,
      num_layers_Arg: 'static,
      num_units_Arg: Clone,
      num_units_Arg: GraphEdge<i32>,
      num_units_Arg: 'static,
      input_size_Arg: Clone,
      input_size_Arg: GraphEdge<i32>,
      input_size_Arg: 'static,
      T: TensorType,
      T: Clone,
      params_Arg: Clone,
      params_Arg: GraphEdge<T>,
      params_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_HALF,
      T: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("CudnnRNNParamsToCanonical_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("CudnnRNNParamsToCanonical", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.num_layers)?
        }
        {
            new_op.add_edge(&self.num_units)?
        }
        {
            new_op.add_edge(&self.input_size)?
        }
        {
            new_op.add_edge(&self.params)?
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        {
            (|attr: &i64| {new_op.set_attr_int("num_params", *attr)})(&self.num_params)?
        }
        {
            match self.rnn_mode {
                None => new_op.set_attr_value_proto("rnn_mode", &vec![18_u8, 4_u8, 108_u8, 115_u8, 116_u8, 109_u8,])?,
                Some(ref value) => (|attr| {new_op.set_attr_string("rnn_mode", attr)})(&value)?,
            };
        }
        {
            match self.input_mode {
                None => new_op.set_attr_value_proto("input_mode", &vec![18_u8, 12_u8, 108_u8, 105_u8, 110_u8, 101_u8, 97_u8, 114_u8, 95_u8, 105_u8, 110_u8, 112_u8, 117_u8, 116_u8,])?,
                Some(ref value) => (|attr| {new_op.set_attr_string("input_mode", attr)})(&value)?,
            };
        }
        {
            match self.direction {
                None => new_op.set_attr_value_proto("direction", &vec![18_u8, 14_u8, 117_u8, 110_u8, 105_u8, 100_u8, 105_u8, 114_u8, 101_u8, 99_u8, 116_u8, 105_u8, 111_u8, 110_u8, 97_u8, 108_u8,])?,
                Some(ref value) => (|attr| {new_op.set_attr_string("direction", attr)})(&value)?,
            };
        }
        {
            match self.dropout {
                None => new_op.set_attr_value_proto("dropout", &vec![37_u8, 0_u8, 0_u8, 0_u8, 0_u8,])?,
                Some(ref value) => (|attr: &f32| {new_op.set_attr_float("dropout", *attr)})(&value)?,
            };
        }
        {
            match self.seed {
                None => new_op.set_attr_value_proto("seed", &vec![24_u8, 0_u8,])?,
                Some(ref value) => (|attr: &i64| {new_op.set_attr_int("seed", *attr)})(&value)?,
            };
        }
        {
            match self.seed2 {
                None => new_op.set_attr_value_proto("seed2", &vec![24_u8, 0_u8,])?,
                Some(ref value) => (|attr: &i64| {new_op.set_attr_int("seed2", *attr)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct CudnnRNNParamsToCanonical<num_layers_Arg, num_units_Arg, input_size_Arg, T, params_Arg>
where num_layers_Arg: Clone,
      num_layers_Arg: GraphEdge<i32>,
      num_layers_Arg: 'static,
      num_units_Arg: Clone,
      num_units_Arg: GraphEdge<i32>,
      num_units_Arg: 'static,
      input_size_Arg: Clone,
      input_size_Arg: GraphEdge<i32>,
      input_size_Arg: 'static,
      T: TensorType,
      T: Clone,
      params_Arg: Clone,
      params_Arg: GraphEdge<T>,
      params_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_HALF,
      T: 'static,
{
    num_layers: num_layers_Arg,
    num_units: num_units_Arg,
    input_size: input_size_Arg,
    phantom_T: PhantomData<T>,
    params: params_Arg,
    num_params: i64,
    rnn_mode: Option<String>,
    input_mode: Option<String>,
    direction: Option<String>,
    dropout: Option<f32>,
    seed: Option<i64>,
    seed2: Option<i64>,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<num_layers_Arg, num_units_Arg, input_size_Arg, T, params_Arg> CudnnRNNParamsToCanonical<num_layers_Arg, num_units_Arg, input_size_Arg, T, params_Arg>
where num_layers_Arg: Clone,
      num_layers_Arg: GraphEdge<i32>,
      num_layers_Arg: 'static,
      num_units_Arg: Clone,
      num_units_Arg: GraphEdge<i32>,
      num_units_Arg: 'static,
      input_size_Arg: Clone,
      input_size_Arg: GraphEdge<i32>,
      input_size_Arg: 'static,
      T: TensorType,
      T: Clone,
      params_Arg: Clone,
      params_Arg: GraphEdge<T>,
      params_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_HALF,
      T: 'static,
{
    pub fn weights(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn biases(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 1)
        }
    }

    pub fn rnn_mode(&mut self, rnn_mode: &str) -> Self {
        self.rnn_mode = Some(rnn_mode.to_string());
        self.clone()
    }

    pub fn input_mode(&mut self, input_mode: &str) -> Self {
        self.input_mode = Some(input_mode.to_string());
        self.clone()
    }

    pub fn direction(&mut self, direction: &str) -> Self {
        self.direction = Some(direction.to_string());
        self.clone()
    }

    pub fn dropout(&mut self, dropout: f32) -> Self {
        self.dropout = Some(dropout);
        self.clone()
    }

    pub fn seed(&mut self, seed: i64) -> Self {
        self.seed = Some(seed);
        self.clone()
    }

    pub fn seed2(&mut self, seed2: i64) -> Self {
        self.seed2 = Some(seed2);
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> (Edge<T>, Edge<T>) {
        let rc = Rc::new(self);
        (
        {
            Edge::<T>::new(rc.clone(), 0)
        },
        {
            Edge::<T>::new(rc.clone(), 1)
        },
        )
    }

    pub fn build(num_layers: num_layers_Arg, num_units: num_units_Arg, input_size: input_size_Arg, params: params_Arg, num_params: i64) -> Self {
        Self {
            num_layers,
            num_units,
            input_size,
            phantom_T: PhantomData,
            params,
            num_params: num_params,
            rnn_mode: None,
            input_mode: None,
            direction: None,
            dropout: None,
            seed: None,
            seed2: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(num_layers: num_layers_Arg, num_units: num_units_Arg, input_size: input_size_Arg, params: params_Arg, num_params: i64) -> (Edge<T>, Edge<T>) {
        Self {
            num_layers,
            num_units,
            input_size,
            phantom_T: PhantomData,
            params,
            num_params: num_params,
            rnn_mode: None,
            input_mode: None,
            direction: None,
            dropout: None,
            seed: None,
            seed2: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<T, input_Arg, out_type> GraphOperation for ShapeN<T, input_Arg, out_type>
where T: TensorType,
      T: Clone,
      input_Arg: Clone,
      input_Arg: GraphEdge<T>,
      input_Arg: 'static,
      out_type: TensorType,
      T: 'static,
      out_type: con_or_DT_INT32_or_DT_INT64,
      out_type: 'static,
      out_type: Clone,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("ShapeN_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("ShapeN", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.input)?
        }
        {
            (|attr: &i64| {new_op.set_attr_int("N", *attr)})(&self.N)?
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        {
            new_op.set_attr_type("out_type", out_type::data_type())?;
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct ShapeN<T, input_Arg, out_type>
where T: TensorType,
      T: Clone,
      input_Arg: Clone,
      input_Arg: GraphEdge<T>,
      input_Arg: 'static,
      out_type: TensorType,
      T: 'static,
      out_type: con_or_DT_INT32_or_DT_INT64,
      out_type: 'static,
      out_type: Clone,
{
    phantom_T: PhantomData<T>,
    input: input_Arg,
    N: i64,
    phantom_out_type: PhantomData<out_type>,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<T, input_Arg, out_type> ShapeN<T, input_Arg, out_type>
where T: TensorType,
      T: Clone,
      input_Arg: Clone,
      input_Arg: GraphEdge<T>,
      input_Arg: 'static,
      out_type: TensorType,
      T: 'static,
      out_type: con_or_DT_INT32_or_DT_INT64,
      out_type: 'static,
      out_type: Clone,
{
    pub fn output(self) -> Edge<out_type> {
        let rc = Rc::new(self);
        {
            Edge::<out_type>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<out_type> {
        let rc = Rc::new(self);
        {
            Edge::<out_type>::new(rc.clone(), 0)
        }
    }

    pub fn build(input: input_Arg, N: i64) -> Self {
        Self {
            phantom_T: PhantomData,
            input,
            N: N,
            phantom_out_type: PhantomData,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(input: input_Arg, N: i64) -> Edge<out_type> {
        Self {
            phantom_T: PhantomData,
            input,
            N: N,
            phantom_out_type: PhantomData,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<T, input_Arg> GraphOperation for Rank<T, input_Arg>
where T: TensorType,
      T: Clone,
      input_Arg: Clone,
      input_Arg: GraphEdge<T>,
      input_Arg: 'static,
      T: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("Rank_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("Rank", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.input)?
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct Rank<T, input_Arg>
where T: TensorType,
      T: Clone,
      input_Arg: Clone,
      input_Arg: GraphEdge<T>,
      input_Arg: 'static,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    input: input_Arg,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<T, input_Arg> Rank<T, input_Arg>
where T: TensorType,
      T: Clone,
      input_Arg: Clone,
      input_Arg: GraphEdge<T>,
      input_Arg: 'static,
      T: 'static,
{
    pub fn output(self) -> Edge<i32> {
        let rc = Rc::new(self);
        {
            Edge::<i32>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<i32> {
        let rc = Rc::new(self);
        {
            Edge::<i32>::new(rc.clone(), 0)
        }
    }

    pub fn build(input: input_Arg) -> Self {
        Self {
            phantom_T: PhantomData,
            input,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(input: input_Arg) -> Edge<i32> {
        Self {
            phantom_T: PhantomData,
            input,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<T, input_Arg, out_type> GraphOperation for Size<T, input_Arg, out_type>
where T: TensorType,
      T: Clone,
      input_Arg: Clone,
      input_Arg: GraphEdge<T>,
      input_Arg: 'static,
      out_type: TensorType,
      T: 'static,
      out_type: con_or_DT_INT32_or_DT_INT64,
      out_type: 'static,
      out_type: Clone,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("Size_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("Size", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.input)?
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        {
            new_op.set_attr_type("out_type", out_type::data_type())?;
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct Size<T, input_Arg, out_type>
where T: TensorType,
      T: Clone,
      input_Arg: Clone,
      input_Arg: GraphEdge<T>,
      input_Arg: 'static,
      out_type: TensorType,
      T: 'static,
      out_type: con_or_DT_INT32_or_DT_INT64,
      out_type: 'static,
      out_type: Clone,
{
    phantom_T: PhantomData<T>,
    input: input_Arg,
    phantom_out_type: PhantomData<out_type>,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<T, input_Arg, out_type> Size<T, input_Arg, out_type>
where T: TensorType,
      T: Clone,
      input_Arg: Clone,
      input_Arg: GraphEdge<T>,
      input_Arg: 'static,
      out_type: TensorType,
      T: 'static,
      out_type: con_or_DT_INT32_or_DT_INT64,
      out_type: 'static,
      out_type: Clone,
{
    pub fn output(self) -> Edge<out_type> {
        let rc = Rc::new(self);
        {
            Edge::<out_type>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<out_type> {
        let rc = Rc::new(self);
        {
            Edge::<out_type>::new(rc.clone(), 0)
        }
    }

    pub fn build(input: input_Arg) -> Self {
        Self {
            phantom_T: PhantomData,
            input,
            phantom_out_type: PhantomData,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(input: input_Arg) -> Edge<out_type> {
        Self {
            phantom_T: PhantomData,
            input,
            phantom_out_type: PhantomData,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl GraphOperation for _DisconnectHostFromDistributedTPUSystem {
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("_DisconnectHostFromDistributedTPUSystem_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("_DisconnectHostFromDistributedTPUSystem", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct _DisconnectHostFromDistributedTPUSystem {
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl _DisconnectHostFromDistributedTPUSystem {
    pub fn number_of_tpu_chips(self) -> Edge<i32> {
        let rc = Rc::new(self);
        {
            Edge::<i32>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<i32> {
        let rc = Rc::new(self);
        {
            Edge::<i32>::new(rc.clone(), 0)
        }
    }

    pub fn build() -> Self {
        Self {
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new() -> Edge<i32> {
        Self {
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<T, input_Arg, Index, begin_Arg, size_Arg> GraphOperation for Slice<T, input_Arg, Index, begin_Arg, size_Arg>
where T: TensorType,
      T: Clone,
      input_Arg: Clone,
      input_Arg: GraphEdge<T>,
      input_Arg: 'static,
      Index: TensorType,
      Index: Clone,
      begin_Arg: Clone,
      begin_Arg: GraphEdge<Index>,
      begin_Arg: 'static,
      size_Arg: Clone,
      size_Arg: GraphEdge<Index>,
      size_Arg: 'static,
      T: 'static,
      Index: con_or_DT_INT32_or_DT_INT64,
      Index: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("Slice_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("Slice", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.input)?
        }
        {
            new_op.add_edge(&self.begin)?
        }
        {
            new_op.add_edge(&self.size)?
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        {
            new_op.set_attr_type("Index", Index::data_type())?;
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct Slice<T, input_Arg, Index, begin_Arg, size_Arg>
where T: TensorType,
      T: Clone,
      input_Arg: Clone,
      input_Arg: GraphEdge<T>,
      input_Arg: 'static,
      Index: TensorType,
      Index: Clone,
      begin_Arg: Clone,
      begin_Arg: GraphEdge<Index>,
      begin_Arg: 'static,
      size_Arg: Clone,
      size_Arg: GraphEdge<Index>,
      size_Arg: 'static,
      T: 'static,
      Index: con_or_DT_INT32_or_DT_INT64,
      Index: 'static,
{
    phantom_T: PhantomData<T>,
    input: input_Arg,
    phantom_Index: PhantomData<Index>,
    begin: begin_Arg,
    size: size_Arg,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<T, input_Arg, Index, begin_Arg, size_Arg> Slice<T, input_Arg, Index, begin_Arg, size_Arg>
where T: TensorType,
      T: Clone,
      input_Arg: Clone,
      input_Arg: GraphEdge<T>,
      input_Arg: 'static,
      Index: TensorType,
      Index: Clone,
      begin_Arg: Clone,
      begin_Arg: GraphEdge<Index>,
      begin_Arg: 'static,
      size_Arg: Clone,
      size_Arg: GraphEdge<Index>,
      size_Arg: 'static,
      T: 'static,
      Index: con_or_DT_INT32_or_DT_INT64,
      Index: 'static,
{
    pub fn output(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(input: input_Arg, begin: begin_Arg, size: size_Arg) -> Self {
        Self {
            phantom_T: PhantomData,
            input,
            phantom_Index: PhantomData,
            begin,
            size,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(input: input_Arg, begin: begin_Arg, size: size_Arg) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            input,
            phantom_Index: PhantomData,
            begin,
            size,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<T, batched_tensor_Arg, batch_index_Arg, id_Arg> GraphOperation for Unbatch<T, batched_tensor_Arg, batch_index_Arg, id_Arg>
where T: TensorType,
      T: Clone,
      batched_tensor_Arg: Clone,
      batched_tensor_Arg: GraphEdge<T>,
      batched_tensor_Arg: 'static,
      batch_index_Arg: Clone,
      batch_index_Arg: GraphEdge<i64>,
      batch_index_Arg: 'static,
      id_Arg: Clone,
      id_Arg: GraphEdge<i64>,
      id_Arg: 'static,
      T: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("Unbatch_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("Unbatch", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.batched_tensor)?
        }
        {
            new_op.add_edge(&self.batch_index)?
        }
        {
            new_op.add_edge(&self.id)?
        }
        {
            (|attr: &i64| {new_op.set_attr_int("timeout_micros", *attr)})(&self.timeout_micros)?
        }
        {
            match self.container {
                None => new_op.set_attr_value_proto("container", &vec![18_u8, 0_u8,])?,
                Some(ref value) => (|attr| {new_op.set_attr_string("container", attr)})(&value)?,
            };
        }
        {
            match self.shared_name {
                None => new_op.set_attr_value_proto("shared_name", &vec![18_u8, 0_u8,])?,
                Some(ref value) => (|attr| {new_op.set_attr_string("shared_name", attr)})(&value)?,
            };
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct Unbatch<T, batched_tensor_Arg, batch_index_Arg, id_Arg>
where T: TensorType,
      T: Clone,
      batched_tensor_Arg: Clone,
      batched_tensor_Arg: GraphEdge<T>,
      batched_tensor_Arg: 'static,
      batch_index_Arg: Clone,
      batch_index_Arg: GraphEdge<i64>,
      batch_index_Arg: 'static,
      id_Arg: Clone,
      id_Arg: GraphEdge<i64>,
      id_Arg: 'static,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    batched_tensor: batched_tensor_Arg,
    batch_index: batch_index_Arg,
    id: id_Arg,
    timeout_micros: i64,
    container: Option<String>,
    shared_name: Option<String>,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<T, batched_tensor_Arg, batch_index_Arg, id_Arg> Unbatch<T, batched_tensor_Arg, batch_index_Arg, id_Arg>
where T: TensorType,
      T: Clone,
      batched_tensor_Arg: Clone,
      batched_tensor_Arg: GraphEdge<T>,
      batched_tensor_Arg: 'static,
      batch_index_Arg: Clone,
      batch_index_Arg: GraphEdge<i64>,
      batch_index_Arg: 'static,
      id_Arg: Clone,
      id_Arg: GraphEdge<i64>,
      id_Arg: 'static,
      T: 'static,
{
    pub fn unbatched_tensor(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn container(&mut self, container: &str) -> Self {
        self.container = Some(container.to_string());
        self.clone()
    }

    pub fn shared_name(&mut self, shared_name: &str) -> Self {
        self.shared_name = Some(shared_name.to_string());
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(batched_tensor: batched_tensor_Arg, batch_index: batch_index_Arg, id: id_Arg, timeout_micros: i64) -> Self {
        Self {
            phantom_T: PhantomData,
            batched_tensor,
            batch_index,
            id,
            timeout_micros: timeout_micros,
            container: None,
            shared_name: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(batched_tensor: batched_tensor_Arg, batch_index: batch_index_Arg, id: id_Arg, timeout_micros: i64) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            batched_tensor,
            batch_index,
            id,
            timeout_micros: timeout_micros,
            container: None,
            shared_name: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<T, value_Arg, Tlen, size_splits_Arg, split_dim_Arg> GraphOperation for SplitV<T, value_Arg, Tlen, size_splits_Arg, split_dim_Arg>
where T: TensorType,
      T: Clone,
      value_Arg: Clone,
      value_Arg: GraphEdge<T>,
      value_Arg: 'static,
      Tlen: TensorType,
      Tlen: Clone,
      size_splits_Arg: Clone,
      size_splits_Arg: GraphEdge<Tlen>,
      size_splits_Arg: 'static,
      split_dim_Arg: Clone,
      split_dim_Arg: GraphEdge<i32>,
      split_dim_Arg: 'static,
      T: 'static,
      Tlen: con_or_DT_INT32_or_DT_INT64,
      Tlen: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("SplitV_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("SplitV", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.value)?
        }
        {
            new_op.add_edge(&self.size_splits)?
        }
        {
            new_op.add_edge(&self.split_dim)?
        }
        {
            (|attr: &i64| {new_op.set_attr_int("num_split", *attr)})(&self.num_split)?
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        {
            new_op.set_attr_type("Tlen", Tlen::data_type())?;
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct SplitV<T, value_Arg, Tlen, size_splits_Arg, split_dim_Arg>
where T: TensorType,
      T: Clone,
      value_Arg: Clone,
      value_Arg: GraphEdge<T>,
      value_Arg: 'static,
      Tlen: TensorType,
      Tlen: Clone,
      size_splits_Arg: Clone,
      size_splits_Arg: GraphEdge<Tlen>,
      size_splits_Arg: 'static,
      split_dim_Arg: Clone,
      split_dim_Arg: GraphEdge<i32>,
      split_dim_Arg: 'static,
      T: 'static,
      Tlen: con_or_DT_INT32_or_DT_INT64,
      Tlen: 'static,
{
    phantom_T: PhantomData<T>,
    value: value_Arg,
    phantom_Tlen: PhantomData<Tlen>,
    size_splits: size_splits_Arg,
    split_dim: split_dim_Arg,
    num_split: i64,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<T, value_Arg, Tlen, size_splits_Arg, split_dim_Arg> SplitV<T, value_Arg, Tlen, size_splits_Arg, split_dim_Arg>
where T: TensorType,
      T: Clone,
      value_Arg: Clone,
      value_Arg: GraphEdge<T>,
      value_Arg: 'static,
      Tlen: TensorType,
      Tlen: Clone,
      size_splits_Arg: Clone,
      size_splits_Arg: GraphEdge<Tlen>,
      size_splits_Arg: 'static,
      split_dim_Arg: Clone,
      split_dim_Arg: GraphEdge<i32>,
      split_dim_Arg: 'static,
      T: 'static,
      Tlen: con_or_DT_INT32_or_DT_INT64,
      Tlen: 'static,
{
    pub fn output(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(value: value_Arg, size_splits: size_splits_Arg, split_dim: split_dim_Arg, num_split: i64) -> Self {
        Self {
            phantom_T: PhantomData,
            value,
            phantom_Tlen: PhantomData,
            size_splits,
            split_dim,
            num_split: num_split,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(value: value_Arg, size_splits: size_splits_Arg, split_dim: split_dim_Arg, num_split: i64) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            value,
            phantom_Tlen: PhantomData,
            size_splits,
            split_dim,
            num_split: num_split,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<T, ref__Arg, Index, begin_Arg, end_Arg, strides_Arg, value_Arg> GraphOperation for StridedSliceAssign<T, ref__Arg, Index, begin_Arg, end_Arg, strides_Arg, value_Arg>
where T: TensorType,
      T: Clone,
      ref__Arg: Clone,
      ref__Arg: GraphRefEdge<T>,
      ref__Arg: 'static,
      Index: TensorType,
      Index: Clone,
      begin_Arg: Clone,
      begin_Arg: GraphEdge<Index>,
      begin_Arg: 'static,
      end_Arg: Clone,
      end_Arg: GraphEdge<Index>,
      end_Arg: 'static,
      strides_Arg: Clone,
      strides_Arg: GraphEdge<Index>,
      strides_Arg: 'static,
      value_Arg: Clone,
      value_Arg: GraphEdge<T>,
      value_Arg: 'static,
      T: 'static,
      Index: con_or_DT_INT32_or_DT_INT64,
      Index: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("StridedSliceAssign_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("StridedSliceAssign", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.ref_)?
        }
        {
            new_op.add_edge(&self.begin)?
        }
        {
            new_op.add_edge(&self.end)?
        }
        {
            new_op.add_edge(&self.strides)?
        }
        {
            new_op.add_edge(&self.value)?
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        {
            new_op.set_attr_type("Index", Index::data_type())?;
        }
        {
            match self.begin_mask {
                None => new_op.set_attr_value_proto("begin_mask", &vec![24_u8, 0_u8,])?,
                Some(ref value) => (|attr: &i64| {new_op.set_attr_int("begin_mask", *attr)})(&value)?,
            };
        }
        {
            match self.end_mask {
                None => new_op.set_attr_value_proto("end_mask", &vec![24_u8, 0_u8,])?,
                Some(ref value) => (|attr: &i64| {new_op.set_attr_int("end_mask", *attr)})(&value)?,
            };
        }
        {
            match self.ellipsis_mask {
                None => new_op.set_attr_value_proto("ellipsis_mask", &vec![24_u8, 0_u8,])?,
                Some(ref value) => (|attr: &i64| {new_op.set_attr_int("ellipsis_mask", *attr)})(&value)?,
            };
        }
        {
            match self.new_axis_mask {
                None => new_op.set_attr_value_proto("new_axis_mask", &vec![24_u8, 0_u8,])?,
                Some(ref value) => (|attr: &i64| {new_op.set_attr_int("new_axis_mask", *attr)})(&value)?,
            };
        }
        {
            match self.shrink_axis_mask {
                None => new_op.set_attr_value_proto("shrink_axis_mask", &vec![24_u8, 0_u8,])?,
                Some(ref value) => (|attr: &i64| {new_op.set_attr_int("shrink_axis_mask", *attr)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct StridedSliceAssign<T, ref__Arg, Index, begin_Arg, end_Arg, strides_Arg, value_Arg>
where T: TensorType,
      T: Clone,
      ref__Arg: Clone,
      ref__Arg: GraphRefEdge<T>,
      ref__Arg: 'static,
      Index: TensorType,
      Index: Clone,
      begin_Arg: Clone,
      begin_Arg: GraphEdge<Index>,
      begin_Arg: 'static,
      end_Arg: Clone,
      end_Arg: GraphEdge<Index>,
      end_Arg: 'static,
      strides_Arg: Clone,
      strides_Arg: GraphEdge<Index>,
      strides_Arg: 'static,
      value_Arg: Clone,
      value_Arg: GraphEdge<T>,
      value_Arg: 'static,
      T: 'static,
      Index: con_or_DT_INT32_or_DT_INT64,
      Index: 'static,
{
    phantom_T: PhantomData<T>,
    ref_: ref__Arg,
    phantom_Index: PhantomData<Index>,
    begin: begin_Arg,
    end: end_Arg,
    strides: strides_Arg,
    value: value_Arg,
    begin_mask: Option<i64>,
    end_mask: Option<i64>,
    ellipsis_mask: Option<i64>,
    new_axis_mask: Option<i64>,
    shrink_axis_mask: Option<i64>,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<T, ref__Arg, Index, begin_Arg, end_Arg, strides_Arg, value_Arg> StridedSliceAssign<T, ref__Arg, Index, begin_Arg, end_Arg, strides_Arg, value_Arg>
where T: TensorType,
      T: Clone,
      ref__Arg: Clone,
      ref__Arg: GraphRefEdge<T>,
      ref__Arg: 'static,
      Index: TensorType,
      Index: Clone,
      begin_Arg: Clone,
      begin_Arg: GraphEdge<Index>,
      begin_Arg: 'static,
      end_Arg: Clone,
      end_Arg: GraphEdge<Index>,
      end_Arg: 'static,
      strides_Arg: Clone,
      strides_Arg: GraphEdge<Index>,
      strides_Arg: 'static,
      value_Arg: Clone,
      value_Arg: GraphEdge<T>,
      value_Arg: 'static,
      T: 'static,
      Index: con_or_DT_INT32_or_DT_INT64,
      Index: 'static,
{
    pub fn output_ref(self) -> RefEdge<T> {
        let rc = Rc::new(self);
        {
            RefEdge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn begin_mask(&mut self, begin_mask: i64) -> Self {
        self.begin_mask = Some(begin_mask);
        self.clone()
    }

    pub fn end_mask(&mut self, end_mask: i64) -> Self {
        self.end_mask = Some(end_mask);
        self.clone()
    }

    pub fn ellipsis_mask(&mut self, ellipsis_mask: i64) -> Self {
        self.ellipsis_mask = Some(ellipsis_mask);
        self.clone()
    }

    pub fn new_axis_mask(&mut self, new_axis_mask: i64) -> Self {
        self.new_axis_mask = Some(new_axis_mask);
        self.clone()
    }

    pub fn shrink_axis_mask(&mut self, shrink_axis_mask: i64) -> Self {
        self.shrink_axis_mask = Some(shrink_axis_mask);
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> RefEdge<T> {
        let rc = Rc::new(self);
        {
            RefEdge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(ref_: ref__Arg, begin: begin_Arg, end: end_Arg, strides: strides_Arg, value: value_Arg) -> Self {
        Self {
            phantom_T: PhantomData,
            ref_,
            phantom_Index: PhantomData,
            begin,
            end,
            strides,
            value,
            begin_mask: None,
            end_mask: None,
            ellipsis_mask: None,
            new_axis_mask: None,
            shrink_axis_mask: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(ref_: ref__Arg, begin: begin_Arg, end: end_Arg, strides: strides_Arg, value: value_Arg) -> RefEdge<T> {
        Self {
            phantom_T: PhantomData,
            ref_,
            phantom_Index: PhantomData,
            begin,
            end,
            strides,
            value,
            begin_mask: None,
            end_mask: None,
            ellipsis_mask: None,
            new_axis_mask: None,
            shrink_axis_mask: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<handle_Arg, index_Arg, T, value_Arg, flow_in_Arg> GraphOperation for TensorArrayWrite<handle_Arg, index_Arg, T, value_Arg, flow_in_Arg>
where handle_Arg: Clone,
      handle_Arg: GraphRefEdge<String>,
      handle_Arg: 'static,
      index_Arg: Clone,
      index_Arg: GraphEdge<i32>,
      index_Arg: 'static,
      T: TensorType,
      T: Clone,
      value_Arg: Clone,
      value_Arg: GraphEdge<T>,
      value_Arg: 'static,
      flow_in_Arg: Clone,
      flow_in_Arg: GraphEdge<f32>,
      flow_in_Arg: 'static,
      T: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("TensorArrayWrite_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("TensorArrayWrite", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.handle)?
        }
        {
            new_op.add_edge(&self.index)?
        }
        {
            new_op.add_edge(&self.value)?
        }
        {
            new_op.add_edge(&self.flow_in)?
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct TensorArrayWrite<handle_Arg, index_Arg, T, value_Arg, flow_in_Arg>
where handle_Arg: Clone,
      handle_Arg: GraphRefEdge<String>,
      handle_Arg: 'static,
      index_Arg: Clone,
      index_Arg: GraphEdge<i32>,
      index_Arg: 'static,
      T: TensorType,
      T: Clone,
      value_Arg: Clone,
      value_Arg: GraphEdge<T>,
      value_Arg: 'static,
      flow_in_Arg: Clone,
      flow_in_Arg: GraphEdge<f32>,
      flow_in_Arg: 'static,
      T: 'static,
{
    handle: handle_Arg,
    index: index_Arg,
    phantom_T: PhantomData<T>,
    value: value_Arg,
    flow_in: flow_in_Arg,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<handle_Arg, index_Arg, T, value_Arg, flow_in_Arg> TensorArrayWrite<handle_Arg, index_Arg, T, value_Arg, flow_in_Arg>
where handle_Arg: Clone,
      handle_Arg: GraphRefEdge<String>,
      handle_Arg: 'static,
      index_Arg: Clone,
      index_Arg: GraphEdge<i32>,
      index_Arg: 'static,
      T: TensorType,
      T: Clone,
      value_Arg: Clone,
      value_Arg: GraphEdge<T>,
      value_Arg: 'static,
      flow_in_Arg: Clone,
      flow_in_Arg: GraphEdge<f32>,
      flow_in_Arg: 'static,
      T: 'static,
{
    pub fn flow_out(self) -> Edge<f32> {
        let rc = Rc::new(self);
        {
            Edge::<f32>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<f32> {
        let rc = Rc::new(self);
        {
            Edge::<f32>::new(rc.clone(), 0)
        }
    }

    pub fn build(handle: handle_Arg, index: index_Arg, value: value_Arg, flow_in: flow_in_Arg) -> Self {
        Self {
            handle,
            index,
            phantom_T: PhantomData,
            value,
            flow_in,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(handle: handle_Arg, index: index_Arg, value: value_Arg, flow_in: flow_in_Arg) -> Edge<f32> {
        Self {
            handle,
            index,
            phantom_T: PhantomData,
            value,
            flow_in,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<T, input_Arg, multiples_Arg> GraphOperation for TileGrad<T, input_Arg, multiples_Arg>
where T: TensorType,
      T: Clone,
      input_Arg: Clone,
      input_Arg: GraphEdge<T>,
      input_Arg: 'static,
      multiples_Arg: Clone,
      multiples_Arg: GraphEdge<i32>,
      multiples_Arg: 'static,
      T: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("TileGrad_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("TileGrad", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.input)?
        }
        {
            new_op.add_edge(&self.multiples)?
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct TileGrad<T, input_Arg, multiples_Arg>
where T: TensorType,
      T: Clone,
      input_Arg: Clone,
      input_Arg: GraphEdge<T>,
      input_Arg: 'static,
      multiples_Arg: Clone,
      multiples_Arg: GraphEdge<i32>,
      multiples_Arg: 'static,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    input: input_Arg,
    multiples: multiples_Arg,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<T, input_Arg, multiples_Arg> TileGrad<T, input_Arg, multiples_Arg>
where T: TensorType,
      T: Clone,
      input_Arg: Clone,
      input_Arg: GraphEdge<T>,
      input_Arg: 'static,
      multiples_Arg: Clone,
      multiples_Arg: GraphEdge<i32>,
      multiples_Arg: 'static,
      T: 'static,
{
    pub fn output(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(input: input_Arg, multiples: multiples_Arg) -> Self {
        Self {
            phantom_T: PhantomData,
            input,
            multiples,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(input: input_Arg, multiples: multiples_Arg) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            input,
            multiples,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<inputs_Arg> GraphOperation for StringJoin<inputs_Arg>
where inputs_Arg: Clone,
      inputs_Arg: GraphEdge<String>,
      inputs_Arg: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("StringJoin_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("StringJoin", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.inputs)?
        }
        {
            (|attr: &i64| {new_op.set_attr_int("N", *attr)})(&self.N)?
        }
        {
            match self.separator {
                None => new_op.set_attr_value_proto("separator", &vec![18_u8, 0_u8,])?,
                Some(ref value) => (|attr| {new_op.set_attr_string("separator", attr)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct StringJoin<inputs_Arg>
where inputs_Arg: Clone,
      inputs_Arg: GraphEdge<String>,
      inputs_Arg: 'static,
{
    inputs: inputs_Arg,
    N: i64,
    separator: Option<String>,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<inputs_Arg> StringJoin<inputs_Arg>
where inputs_Arg: Clone,
      inputs_Arg: GraphEdge<String>,
      inputs_Arg: 'static,
{
    pub fn output(self) -> Edge<String> {
        let rc = Rc::new(self);
        {
            Edge::<String>::new(rc.clone(), 0)
        }
    }

    pub fn separator(&mut self, separator: &str) -> Self {
        self.separator = Some(separator.to_string());
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<String> {
        let rc = Rc::new(self);
        {
            Edge::<String>::new(rc.clone(), 0)
        }
    }

    pub fn build(inputs: inputs_Arg, N: i64) -> Self {
        Self {
            inputs,
            N: N,
            separator: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(inputs: inputs_Arg, N: i64) -> Edge<String> {
        Self {
            inputs,
            N: N,
            separator: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<dtype> GraphOperation for ImmutableConst<dtype>
where dtype: TensorType,
      dtype: 'static,
      dtype: Clone,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("ImmutableConst_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("ImmutableConst", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.set_attr_type("dtype", dtype::data_type())?;
        }
        {
            (|attr| {new_op.set_attr_shape("shape", attr)})(&self.shape)?
        }
        {
            (|attr| {new_op.set_attr_string("memory_region_name", attr)})(&self.memory_region_name)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct ImmutableConst<dtype>
where dtype: TensorType,
      dtype: 'static,
      dtype: Clone,
{
    phantom_dtype: PhantomData<dtype>,
    shape: OtherShape,
    memory_region_name: String,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<dtype> ImmutableConst<dtype>
where dtype: TensorType,
      dtype: 'static,
      dtype: Clone,
{
    pub fn tensor(self) -> Edge<dtype> {
        let rc = Rc::new(self);
        {
            Edge::<dtype>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<dtype> {
        let rc = Rc::new(self);
        {
            Edge::<dtype>::new(rc.clone(), 0)
        }
    }

    pub fn build(shape: &OtherShape, memory_region_name: &str) -> Self {
        Self {
            phantom_dtype: PhantomData,
            shape: shape.clone(),
            memory_region_name: memory_region_name.to_string(),
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(shape: &OtherShape, memory_region_name: &str) -> Edge<dtype> {
        Self {
            phantom_dtype: PhantomData,
            shape: shape.clone(),
            memory_region_name: memory_region_name.to_string(),
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<a_indices_Arg, T, a_values_Arg, a_shape_Arg, b_indices_Arg, b_values_Arg, b_shape_Arg> GraphOperation for SparseSparseMaximum<a_indices_Arg, T, a_values_Arg, a_shape_Arg, b_indices_Arg, b_values_Arg, b_shape_Arg>
where a_indices_Arg: Clone,
      a_indices_Arg: GraphEdge<i64>,
      a_indices_Arg: 'static,
      T: TensorType,
      T: Clone,
      a_values_Arg: Clone,
      a_values_Arg: GraphEdge<T>,
      a_values_Arg: 'static,
      a_shape_Arg: Clone,
      a_shape_Arg: GraphEdge<i64>,
      a_shape_Arg: 'static,
      b_indices_Arg: Clone,
      b_indices_Arg: GraphEdge<i64>,
      b_indices_Arg: 'static,
      b_values_Arg: Clone,
      b_values_Arg: GraphEdge<T>,
      b_values_Arg: 'static,
      b_shape_Arg: Clone,
      b_shape_Arg: GraphEdge<i64>,
      b_shape_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("SparseSparseMaximum_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("SparseSparseMaximum", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.a_indices)?
        }
        {
            new_op.add_edge(&self.a_values)?
        }
        {
            new_op.add_edge(&self.a_shape)?
        }
        {
            new_op.add_edge(&self.b_indices)?
        }
        {
            new_op.add_edge(&self.b_values)?
        }
        {
            new_op.add_edge(&self.b_shape)?
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct SparseSparseMaximum<a_indices_Arg, T, a_values_Arg, a_shape_Arg, b_indices_Arg, b_values_Arg, b_shape_Arg>
where a_indices_Arg: Clone,
      a_indices_Arg: GraphEdge<i64>,
      a_indices_Arg: 'static,
      T: TensorType,
      T: Clone,
      a_values_Arg: Clone,
      a_values_Arg: GraphEdge<T>,
      a_values_Arg: 'static,
      a_shape_Arg: Clone,
      a_shape_Arg: GraphEdge<i64>,
      a_shape_Arg: 'static,
      b_indices_Arg: Clone,
      b_indices_Arg: GraphEdge<i64>,
      b_indices_Arg: 'static,
      b_values_Arg: Clone,
      b_values_Arg: GraphEdge<T>,
      b_values_Arg: 'static,
      b_shape_Arg: Clone,
      b_shape_Arg: GraphEdge<i64>,
      b_shape_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
{
    a_indices: a_indices_Arg,
    phantom_T: PhantomData<T>,
    a_values: a_values_Arg,
    a_shape: a_shape_Arg,
    b_indices: b_indices_Arg,
    b_values: b_values_Arg,
    b_shape: b_shape_Arg,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<a_indices_Arg, T, a_values_Arg, a_shape_Arg, b_indices_Arg, b_values_Arg, b_shape_Arg> SparseSparseMaximum<a_indices_Arg, T, a_values_Arg, a_shape_Arg, b_indices_Arg, b_values_Arg, b_shape_Arg>
where a_indices_Arg: Clone,
      a_indices_Arg: GraphEdge<i64>,
      a_indices_Arg: 'static,
      T: TensorType,
      T: Clone,
      a_values_Arg: Clone,
      a_values_Arg: GraphEdge<T>,
      a_values_Arg: 'static,
      a_shape_Arg: Clone,
      a_shape_Arg: GraphEdge<i64>,
      a_shape_Arg: 'static,
      b_indices_Arg: Clone,
      b_indices_Arg: GraphEdge<i64>,
      b_indices_Arg: 'static,
      b_values_Arg: Clone,
      b_values_Arg: GraphEdge<T>,
      b_values_Arg: 'static,
      b_shape_Arg: Clone,
      b_shape_Arg: GraphEdge<i64>,
      b_shape_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
{
    pub fn output_indices(self) -> Edge<i64> {
        let rc = Rc::new(self);
        {
            Edge::<i64>::new(rc.clone(), 0)
        }
    }

    pub fn output_values(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 1)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> (Edge<i64>, Edge<T>) {
        let rc = Rc::new(self);
        (
        {
            Edge::<i64>::new(rc.clone(), 0)
        },
        {
            Edge::<T>::new(rc.clone(), 1)
        },
        )
    }

    pub fn build(a_indices: a_indices_Arg, a_values: a_values_Arg, a_shape: a_shape_Arg, b_indices: b_indices_Arg, b_values: b_values_Arg, b_shape: b_shape_Arg) -> Self {
        Self {
            a_indices,
            phantom_T: PhantomData,
            a_values,
            a_shape,
            b_indices,
            b_values,
            b_shape,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(a_indices: a_indices_Arg, a_values: a_values_Arg, a_shape: a_shape_Arg, b_indices: b_indices_Arg, b_values: b_values_Arg, b_shape: b_shape_Arg) -> (Edge<i64>, Edge<T>) {
        Self {
            a_indices,
            phantom_T: PhantomData,
            a_values,
            a_shape,
            b_indices,
            b_values,
            b_shape,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<T, input_Arg, diagonal_Arg> GraphOperation for MatrixSetDiag<T, input_Arg, diagonal_Arg>
where T: TensorType,
      T: Clone,
      input_Arg: Clone,
      input_Arg: GraphEdge<T>,
      input_Arg: 'static,
      diagonal_Arg: Clone,
      diagonal_Arg: GraphEdge<T>,
      diagonal_Arg: 'static,
      T: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("MatrixSetDiag_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("MatrixSetDiag", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.input)?
        }
        {
            new_op.add_edge(&self.diagonal)?
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct MatrixSetDiag<T, input_Arg, diagonal_Arg>
where T: TensorType,
      T: Clone,
      input_Arg: Clone,
      input_Arg: GraphEdge<T>,
      input_Arg: 'static,
      diagonal_Arg: Clone,
      diagonal_Arg: GraphEdge<T>,
      diagonal_Arg: 'static,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    input: input_Arg,
    diagonal: diagonal_Arg,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<T, input_Arg, diagonal_Arg> MatrixSetDiag<T, input_Arg, diagonal_Arg>
where T: TensorType,
      T: Clone,
      input_Arg: Clone,
      input_Arg: GraphEdge<T>,
      input_Arg: 'static,
      diagonal_Arg: Clone,
      diagonal_Arg: GraphEdge<T>,
      diagonal_Arg: 'static,
      T: 'static,
{
    pub fn output(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(input: input_Arg, diagonal: diagonal_Arg) -> Self {
        Self {
            phantom_T: PhantomData,
            input,
            diagonal,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(input: input_Arg, diagonal: diagonal_Arg) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            input,
            diagonal,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<input_Arg> GraphOperation for EncodeBase64<input_Arg>
where input_Arg: Clone,
      input_Arg: GraphEdge<String>,
      input_Arg: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("EncodeBase64_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("EncodeBase64", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.input)?
        }
        {
            match self.pad {
                None => new_op.set_attr_value_proto("pad", &vec![40_u8, 0_u8,])?,
                Some(ref value) => (|attr: &bool| {new_op.set_attr_bool("pad", *attr)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct EncodeBase64<input_Arg>
where input_Arg: Clone,
      input_Arg: GraphEdge<String>,
      input_Arg: 'static,
{
    input: input_Arg,
    pad: Option<bool>,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<input_Arg> EncodeBase64<input_Arg>
where input_Arg: Clone,
      input_Arg: GraphEdge<String>,
      input_Arg: 'static,
{
    pub fn output(self) -> Edge<String> {
        let rc = Rc::new(self);
        {
            Edge::<String>::new(rc.clone(), 0)
        }
    }

    pub fn pad(&mut self, pad: bool) -> Self {
        self.pad = Some(pad);
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<String> {
        let rc = Rc::new(self);
        {
            Edge::<String>::new(rc.clone(), 0)
        }
    }

    pub fn build(input: input_Arg) -> Self {
        Self {
            input,
            pad: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(input: input_Arg) -> Edge<String> {
        Self {
            input,
            pad: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<handle_Arg> GraphOperation for TensorArrayCloseV2<handle_Arg>
where handle_Arg: Clone,
      handle_Arg: GraphEdge<String>,
      handle_Arg: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("TensorArrayCloseV2_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("TensorArrayCloseV2", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.handle)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct TensorArrayCloseV2<handle_Arg>
where handle_Arg: Clone,
      handle_Arg: GraphEdge<String>,
      handle_Arg: 'static,
{
    handle: handle_Arg,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<handle_Arg> TensorArrayCloseV2<handle_Arg>
where handle_Arg: Clone,
      handle_Arg: GraphEdge<String>,
      handle_Arg: 'static,
{
    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> () {
        let rc = Rc::new(self);
        (
        )
    }

    pub fn build(handle: handle_Arg) -> Self {
        Self {
            handle,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(handle: handle_Arg) -> () {
        Self {
            handle,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<T, input_Arg, output_idx_type> GraphOperation for Lu<T, input_Arg, output_idx_type>
where T: TensorType,
      T: Clone,
      input_Arg: Clone,
      input_Arg: GraphEdge<T>,
      input_Arg: 'static,
      output_idx_type: TensorType,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_COMPLEX64_or_DT_COMPLEX128,
      T: 'static,
      output_idx_type: con_or_DT_INT32_or_DT_INT64,
      output_idx_type: 'static,
      output_idx_type: Clone,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("Lu_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("Lu", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.input)?
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        {
            new_op.set_attr_type("output_idx_type", output_idx_type::data_type())?;
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct Lu<T, input_Arg, output_idx_type>
where T: TensorType,
      T: Clone,
      input_Arg: Clone,
      input_Arg: GraphEdge<T>,
      input_Arg: 'static,
      output_idx_type: TensorType,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_COMPLEX64_or_DT_COMPLEX128,
      T: 'static,
      output_idx_type: con_or_DT_INT32_or_DT_INT64,
      output_idx_type: 'static,
      output_idx_type: Clone,
{
    phantom_T: PhantomData<T>,
    input: input_Arg,
    phantom_output_idx_type: PhantomData<output_idx_type>,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<T, input_Arg, output_idx_type> Lu<T, input_Arg, output_idx_type>
where T: TensorType,
      T: Clone,
      input_Arg: Clone,
      input_Arg: GraphEdge<T>,
      input_Arg: 'static,
      output_idx_type: TensorType,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_COMPLEX64_or_DT_COMPLEX128,
      T: 'static,
      output_idx_type: con_or_DT_INT32_or_DT_INT64,
      output_idx_type: 'static,
      output_idx_type: Clone,
{
    pub fn lu(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn p(self) -> Edge<output_idx_type> {
        let rc = Rc::new(self);
        {
            Edge::<output_idx_type>::new(rc.clone(), 1)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> (Edge<T>, Edge<output_idx_type>) {
        let rc = Rc::new(self);
        (
        {
            Edge::<T>::new(rc.clone(), 0)
        },
        {
            Edge::<output_idx_type>::new(rc.clone(), 1)
        },
        )
    }

    pub fn build(input: input_Arg) -> Self {
        Self {
            phantom_T: PhantomData,
            input,
            phantom_output_idx_type: PhantomData,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(input: input_Arg) -> (Edge<T>, Edge<output_idx_type>) {
        Self {
            phantom_T: PhantomData,
            input,
            phantom_output_idx_type: PhantomData,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<T, s0_Arg, s1_Arg> GraphOperation for BroadcastGradientArgs<T, s0_Arg, s1_Arg>
where T: TensorType,
      T: Clone,
      s0_Arg: Clone,
      s0_Arg: GraphEdge<T>,
      s0_Arg: 'static,
      s1_Arg: Clone,
      s1_Arg: GraphEdge<T>,
      s1_Arg: 'static,
      T: con_or_DT_INT32_or_DT_INT64,
      T: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("BroadcastGradientArgs_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("BroadcastGradientArgs", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.s0)?
        }
        {
            new_op.add_edge(&self.s1)?
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct BroadcastGradientArgs<T, s0_Arg, s1_Arg>
where T: TensorType,
      T: Clone,
      s0_Arg: Clone,
      s0_Arg: GraphEdge<T>,
      s0_Arg: 'static,
      s1_Arg: Clone,
      s1_Arg: GraphEdge<T>,
      s1_Arg: 'static,
      T: con_or_DT_INT32_or_DT_INT64,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    s0: s0_Arg,
    s1: s1_Arg,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<T, s0_Arg, s1_Arg> BroadcastGradientArgs<T, s0_Arg, s1_Arg>
where T: TensorType,
      T: Clone,
      s0_Arg: Clone,
      s0_Arg: GraphEdge<T>,
      s0_Arg: 'static,
      s1_Arg: Clone,
      s1_Arg: GraphEdge<T>,
      s1_Arg: 'static,
      T: con_or_DT_INT32_or_DT_INT64,
      T: 'static,
{
    pub fn r0(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn r1(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 1)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> (Edge<T>, Edge<T>) {
        let rc = Rc::new(self);
        (
        {
            Edge::<T>::new(rc.clone(), 0)
        },
        {
            Edge::<T>::new(rc.clone(), 1)
        },
        )
    }

    pub fn build(s0: s0_Arg, s1: s1_Arg) -> Self {
        Self {
            phantom_T: PhantomData,
            s0,
            s1,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(s0: s0_Arg, s1: s1_Arg) -> (Edge<T>, Edge<T>) {
        Self {
            phantom_T: PhantomData,
            s0,
            s1,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<T, var_Arg, accum_Arg, lr_Arg, l1_Arg, l2_Arg, grad_Arg, Tindices, indices_Arg> GraphOperation for SparseApplyProximalAdagrad<T, var_Arg, accum_Arg, lr_Arg, l1_Arg, l2_Arg, grad_Arg, Tindices, indices_Arg>
where T: TensorType,
      T: Clone,
      var_Arg: Clone,
      var_Arg: GraphRefEdge<T>,
      var_Arg: 'static,
      accum_Arg: Clone,
      accum_Arg: GraphRefEdge<T>,
      accum_Arg: 'static,
      lr_Arg: Clone,
      lr_Arg: GraphEdge<T>,
      lr_Arg: 'static,
      l1_Arg: Clone,
      l1_Arg: GraphEdge<T>,
      l1_Arg: 'static,
      l2_Arg: Clone,
      l2_Arg: GraphEdge<T>,
      l2_Arg: 'static,
      grad_Arg: Clone,
      grad_Arg: GraphEdge<T>,
      grad_Arg: 'static,
      Tindices: TensorType,
      Tindices: Clone,
      indices_Arg: Clone,
      indices_Arg: GraphEdge<Tindices>,
      indices_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
      Tindices: con_or_DT_INT32_or_DT_INT64,
      Tindices: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("SparseApplyProximalAdagrad_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("SparseApplyProximalAdagrad", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.var)?
        }
        {
            new_op.add_edge(&self.accum)?
        }
        {
            new_op.add_edge(&self.lr)?
        }
        {
            new_op.add_edge(&self.l1)?
        }
        {
            new_op.add_edge(&self.l2)?
        }
        {
            new_op.add_edge(&self.grad)?
        }
        {
            new_op.add_edge(&self.indices)?
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        {
            new_op.set_attr_type("Tindices", Tindices::data_type())?;
        }
        {
            match self.use_locking {
                None => new_op.set_attr_value_proto("use_locking", &vec![40_u8, 0_u8,])?,
                Some(ref value) => (|attr: &bool| {new_op.set_attr_bool("use_locking", *attr)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct SparseApplyProximalAdagrad<T, var_Arg, accum_Arg, lr_Arg, l1_Arg, l2_Arg, grad_Arg, Tindices, indices_Arg>
where T: TensorType,
      T: Clone,
      var_Arg: Clone,
      var_Arg: GraphRefEdge<T>,
      var_Arg: 'static,
      accum_Arg: Clone,
      accum_Arg: GraphRefEdge<T>,
      accum_Arg: 'static,
      lr_Arg: Clone,
      lr_Arg: GraphEdge<T>,
      lr_Arg: 'static,
      l1_Arg: Clone,
      l1_Arg: GraphEdge<T>,
      l1_Arg: 'static,
      l2_Arg: Clone,
      l2_Arg: GraphEdge<T>,
      l2_Arg: 'static,
      grad_Arg: Clone,
      grad_Arg: GraphEdge<T>,
      grad_Arg: 'static,
      Tindices: TensorType,
      Tindices: Clone,
      indices_Arg: Clone,
      indices_Arg: GraphEdge<Tindices>,
      indices_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
      Tindices: con_or_DT_INT32_or_DT_INT64,
      Tindices: 'static,
{
    phantom_T: PhantomData<T>,
    var: var_Arg,
    accum: accum_Arg,
    lr: lr_Arg,
    l1: l1_Arg,
    l2: l2_Arg,
    grad: grad_Arg,
    phantom_Tindices: PhantomData<Tindices>,
    indices: indices_Arg,
    use_locking: Option<bool>,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<T, var_Arg, accum_Arg, lr_Arg, l1_Arg, l2_Arg, grad_Arg, Tindices, indices_Arg> SparseApplyProximalAdagrad<T, var_Arg, accum_Arg, lr_Arg, l1_Arg, l2_Arg, grad_Arg, Tindices, indices_Arg>
where T: TensorType,
      T: Clone,
      var_Arg: Clone,
      var_Arg: GraphRefEdge<T>,
      var_Arg: 'static,
      accum_Arg: Clone,
      accum_Arg: GraphRefEdge<T>,
      accum_Arg: 'static,
      lr_Arg: Clone,
      lr_Arg: GraphEdge<T>,
      lr_Arg: 'static,
      l1_Arg: Clone,
      l1_Arg: GraphEdge<T>,
      l1_Arg: 'static,
      l2_Arg: Clone,
      l2_Arg: GraphEdge<T>,
      l2_Arg: 'static,
      grad_Arg: Clone,
      grad_Arg: GraphEdge<T>,
      grad_Arg: 'static,
      Tindices: TensorType,
      Tindices: Clone,
      indices_Arg: Clone,
      indices_Arg: GraphEdge<Tindices>,
      indices_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
      Tindices: con_or_DT_INT32_or_DT_INT64,
      Tindices: 'static,
{
    pub fn out(self) -> RefEdge<T> {
        let rc = Rc::new(self);
        {
            RefEdge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn use_locking(&mut self, use_locking: bool) -> Self {
        self.use_locking = Some(use_locking);
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> RefEdge<T> {
        let rc = Rc::new(self);
        {
            RefEdge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(var: var_Arg, accum: accum_Arg, lr: lr_Arg, l1: l1_Arg, l2: l2_Arg, grad: grad_Arg, indices: indices_Arg) -> Self {
        Self {
            phantom_T: PhantomData,
            var,
            accum,
            lr,
            l1,
            l2,
            grad,
            phantom_Tindices: PhantomData,
            indices,
            use_locking: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(var: var_Arg, accum: accum_Arg, lr: lr_Arg, l1: l1_Arg, l2: l2_Arg, grad: grad_Arg, indices: indices_Arg) -> RefEdge<T> {
        Self {
            phantom_T: PhantomData,
            var,
            accum,
            lr,
            l1,
            l2,
            grad,
            phantom_Tindices: PhantomData,
            indices,
            use_locking: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<T, tensor_Arg, Tshape, shape_Arg, input_min_Arg, input_max_Arg> GraphOperation for QuantizedReshape<T, tensor_Arg, Tshape, shape_Arg, input_min_Arg, input_max_Arg>
where T: TensorType,
      T: Clone,
      tensor_Arg: Clone,
      tensor_Arg: GraphEdge<T>,
      tensor_Arg: 'static,
      Tshape: TensorType,
      Tshape: Clone,
      shape_Arg: Clone,
      shape_Arg: GraphEdge<Tshape>,
      shape_Arg: 'static,
      input_min_Arg: Clone,
      input_min_Arg: GraphEdge<f32>,
      input_min_Arg: 'static,
      input_max_Arg: Clone,
      input_max_Arg: GraphEdge<f32>,
      input_max_Arg: 'static,
      T: 'static,
      Tshape: con_or_DT_INT32_or_DT_INT64,
      Tshape: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("QuantizedReshape_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("QuantizedReshape", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.tensor)?
        }
        {
            new_op.add_edge(&self.shape)?
        }
        {
            new_op.add_edge(&self.input_min)?
        }
        {
            new_op.add_edge(&self.input_max)?
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        {
            new_op.set_attr_type("Tshape", Tshape::data_type())?;
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct QuantizedReshape<T, tensor_Arg, Tshape, shape_Arg, input_min_Arg, input_max_Arg>
where T: TensorType,
      T: Clone,
      tensor_Arg: Clone,
      tensor_Arg: GraphEdge<T>,
      tensor_Arg: 'static,
      Tshape: TensorType,
      Tshape: Clone,
      shape_Arg: Clone,
      shape_Arg: GraphEdge<Tshape>,
      shape_Arg: 'static,
      input_min_Arg: Clone,
      input_min_Arg: GraphEdge<f32>,
      input_min_Arg: 'static,
      input_max_Arg: Clone,
      input_max_Arg: GraphEdge<f32>,
      input_max_Arg: 'static,
      T: 'static,
      Tshape: con_or_DT_INT32_or_DT_INT64,
      Tshape: 'static,
{
    phantom_T: PhantomData<T>,
    tensor: tensor_Arg,
    phantom_Tshape: PhantomData<Tshape>,
    shape: shape_Arg,
    input_min: input_min_Arg,
    input_max: input_max_Arg,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<T, tensor_Arg, Tshape, shape_Arg, input_min_Arg, input_max_Arg> QuantizedReshape<T, tensor_Arg, Tshape, shape_Arg, input_min_Arg, input_max_Arg>
where T: TensorType,
      T: Clone,
      tensor_Arg: Clone,
      tensor_Arg: GraphEdge<T>,
      tensor_Arg: 'static,
      Tshape: TensorType,
      Tshape: Clone,
      shape_Arg: Clone,
      shape_Arg: GraphEdge<Tshape>,
      shape_Arg: 'static,
      input_min_Arg: Clone,
      input_min_Arg: GraphEdge<f32>,
      input_min_Arg: 'static,
      input_max_Arg: Clone,
      input_max_Arg: GraphEdge<f32>,
      input_max_Arg: 'static,
      T: 'static,
      Tshape: con_or_DT_INT32_or_DT_INT64,
      Tshape: 'static,
{
    pub fn output(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn output_min(self) -> Edge<f32> {
        let rc = Rc::new(self);
        {
            Edge::<f32>::new(rc.clone(), 1)
        }
    }

    pub fn output_max(self) -> Edge<f32> {
        let rc = Rc::new(self);
        {
            Edge::<f32>::new(rc.clone(), 2)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> (Edge<T>, Edge<f32>, Edge<f32>) {
        let rc = Rc::new(self);
        (
        {
            Edge::<T>::new(rc.clone(), 0)
        },
        {
            Edge::<f32>::new(rc.clone(), 1)
        },
        {
            Edge::<f32>::new(rc.clone(), 2)
        },
        )
    }

    pub fn build(tensor: tensor_Arg, shape: shape_Arg, input_min: input_min_Arg, input_max: input_max_Arg) -> Self {
        Self {
            phantom_T: PhantomData,
            tensor,
            phantom_Tshape: PhantomData,
            shape,
            input_min,
            input_max,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(tensor: tensor_Arg, shape: shape_Arg, input_min: input_min_Arg, input_max: input_max_Arg) -> (Edge<T>, Edge<f32>, Edge<f32>) {
        Self {
            phantom_T: PhantomData,
            tensor,
            phantom_Tshape: PhantomData,
            shape,
            input_min,
            input_max,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<T, grad_Arg, Tidx, indices_Arg, segment_ids_Arg, output_dim0_Arg> GraphOperation for SparseSegmentSqrtNGrad<T, grad_Arg, Tidx, indices_Arg, segment_ids_Arg, output_dim0_Arg>
where T: TensorType,
      T: Clone,
      grad_Arg: Clone,
      grad_Arg: GraphEdge<T>,
      grad_Arg: 'static,
      Tidx: TensorType,
      Tidx: Clone,
      indices_Arg: Clone,
      indices_Arg: GraphEdge<Tidx>,
      indices_Arg: 'static,
      segment_ids_Arg: Clone,
      segment_ids_Arg: GraphEdge<i32>,
      segment_ids_Arg: 'static,
      output_dim0_Arg: Clone,
      output_dim0_Arg: GraphEdge<i32>,
      output_dim0_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE,
      T: 'static,
      Tidx: con_or_DT_INT32_or_DT_INT64,
      Tidx: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("SparseSegmentSqrtNGrad_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("SparseSegmentSqrtNGrad", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.grad)?
        }
        {
            new_op.add_edge(&self.indices)?
        }
        {
            new_op.add_edge(&self.segment_ids)?
        }
        {
            new_op.add_edge(&self.output_dim0)?
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        {
            new_op.set_attr_type("Tidx", Tidx::data_type())?;
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct SparseSegmentSqrtNGrad<T, grad_Arg, Tidx, indices_Arg, segment_ids_Arg, output_dim0_Arg>
where T: TensorType,
      T: Clone,
      grad_Arg: Clone,
      grad_Arg: GraphEdge<T>,
      grad_Arg: 'static,
      Tidx: TensorType,
      Tidx: Clone,
      indices_Arg: Clone,
      indices_Arg: GraphEdge<Tidx>,
      indices_Arg: 'static,
      segment_ids_Arg: Clone,
      segment_ids_Arg: GraphEdge<i32>,
      segment_ids_Arg: 'static,
      output_dim0_Arg: Clone,
      output_dim0_Arg: GraphEdge<i32>,
      output_dim0_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE,
      T: 'static,
      Tidx: con_or_DT_INT32_or_DT_INT64,
      Tidx: 'static,
{
    phantom_T: PhantomData<T>,
    grad: grad_Arg,
    phantom_Tidx: PhantomData<Tidx>,
    indices: indices_Arg,
    segment_ids: segment_ids_Arg,
    output_dim0: output_dim0_Arg,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<T, grad_Arg, Tidx, indices_Arg, segment_ids_Arg, output_dim0_Arg> SparseSegmentSqrtNGrad<T, grad_Arg, Tidx, indices_Arg, segment_ids_Arg, output_dim0_Arg>
where T: TensorType,
      T: Clone,
      grad_Arg: Clone,
      grad_Arg: GraphEdge<T>,
      grad_Arg: 'static,
      Tidx: TensorType,
      Tidx: Clone,
      indices_Arg: Clone,
      indices_Arg: GraphEdge<Tidx>,
      indices_Arg: 'static,
      segment_ids_Arg: Clone,
      segment_ids_Arg: GraphEdge<i32>,
      segment_ids_Arg: 'static,
      output_dim0_Arg: Clone,
      output_dim0_Arg: GraphEdge<i32>,
      output_dim0_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE,
      T: 'static,
      Tidx: con_or_DT_INT32_or_DT_INT64,
      Tidx: 'static,
{
    pub fn output(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(grad: grad_Arg, indices: indices_Arg, segment_ids: segment_ids_Arg, output_dim0: output_dim0_Arg) -> Self {
        Self {
            phantom_T: PhantomData,
            grad,
            phantom_Tidx: PhantomData,
            indices,
            segment_ids,
            output_dim0,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(grad: grad_Arg, indices: indices_Arg, segment_ids: segment_ids_Arg, output_dim0: output_dim0_Arg) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            grad,
            phantom_Tidx: PhantomData,
            indices,
            segment_ids,
            output_dim0,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<T, input_Arg, Tpaddings, paddings_Arg> GraphOperation for Pad<T, input_Arg, Tpaddings, paddings_Arg>
where T: TensorType,
      T: Clone,
      input_Arg: Clone,
      input_Arg: GraphEdge<T>,
      input_Arg: 'static,
      Tpaddings: TensorType,
      Tpaddings: Clone,
      paddings_Arg: Clone,
      paddings_Arg: GraphEdge<Tpaddings>,
      paddings_Arg: 'static,
      T: 'static,
      Tpaddings: con_or_DT_INT32_or_DT_INT64,
      Tpaddings: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("Pad_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("Pad", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.input)?
        }
        {
            new_op.add_edge(&self.paddings)?
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        {
            new_op.set_attr_type("Tpaddings", Tpaddings::data_type())?;
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct Pad<T, input_Arg, Tpaddings, paddings_Arg>
where T: TensorType,
      T: Clone,
      input_Arg: Clone,
      input_Arg: GraphEdge<T>,
      input_Arg: 'static,
      Tpaddings: TensorType,
      Tpaddings: Clone,
      paddings_Arg: Clone,
      paddings_Arg: GraphEdge<Tpaddings>,
      paddings_Arg: 'static,
      T: 'static,
      Tpaddings: con_or_DT_INT32_or_DT_INT64,
      Tpaddings: 'static,
{
    phantom_T: PhantomData<T>,
    input: input_Arg,
    phantom_Tpaddings: PhantomData<Tpaddings>,
    paddings: paddings_Arg,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<T, input_Arg, Tpaddings, paddings_Arg> Pad<T, input_Arg, Tpaddings, paddings_Arg>
where T: TensorType,
      T: Clone,
      input_Arg: Clone,
      input_Arg: GraphEdge<T>,
      input_Arg: 'static,
      Tpaddings: TensorType,
      Tpaddings: Clone,
      paddings_Arg: Clone,
      paddings_Arg: GraphEdge<Tpaddings>,
      paddings_Arg: 'static,
      T: 'static,
      Tpaddings: con_or_DT_INT32_or_DT_INT64,
      Tpaddings: 'static,
{
    pub fn output(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(input: input_Arg, paddings: paddings_Arg) -> Self {
        Self {
            phantom_T: PhantomData,
            input,
            phantom_Tpaddings: PhantomData,
            paddings,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(input: input_Arg, paddings: paddings_Arg) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            input,
            phantom_Tpaddings: PhantomData,
            paddings,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<T, value_Arg, update_Arg> GraphOperation for _ParallelConcatUpdate<T, value_Arg, update_Arg>
where T: TensorType,
      T: Clone,
      value_Arg: Clone,
      value_Arg: GraphEdge<T>,
      value_Arg: 'static,
      update_Arg: Clone,
      update_Arg: GraphEdge<T>,
      update_Arg: 'static,
      T: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("_ParallelConcatUpdate_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("_ParallelConcatUpdate", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.value)?
        }
        {
            new_op.add_edge(&self.update)?
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        {
            (|attr: &i64| {new_op.set_attr_int("loc", *attr)})(&self.loc)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct _ParallelConcatUpdate<T, value_Arg, update_Arg>
where T: TensorType,
      T: Clone,
      value_Arg: Clone,
      value_Arg: GraphEdge<T>,
      value_Arg: 'static,
      update_Arg: Clone,
      update_Arg: GraphEdge<T>,
      update_Arg: 'static,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    value: value_Arg,
    update: update_Arg,
    loc: i64,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<T, value_Arg, update_Arg> _ParallelConcatUpdate<T, value_Arg, update_Arg>
where T: TensorType,
      T: Clone,
      value_Arg: Clone,
      value_Arg: GraphEdge<T>,
      value_Arg: 'static,
      update_Arg: Clone,
      update_Arg: GraphEdge<T>,
      update_Arg: 'static,
      T: 'static,
{
    pub fn output(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(value: value_Arg, update: update_Arg, loc: i64) -> Self {
        Self {
            phantom_T: PhantomData,
            value,
            update,
            loc: loc,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(value: value_Arg, update: update_Arg, loc: i64) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            value,
            update,
            loc: loc,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<T, x_Arg> GraphOperation for Digamma<T, x_Arg>
where T: TensorType,
      T: Clone,
      x_Arg: Clone,
      x_Arg: GraphEdge<T>,
      x_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
      T: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("Digamma_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("Digamma", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.x)?
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct Digamma<T, x_Arg>
where T: TensorType,
      T: Clone,
      x_Arg: Clone,
      x_Arg: GraphEdge<T>,
      x_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    x: x_Arg,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<T, x_Arg> Digamma<T, x_Arg>
where T: TensorType,
      T: Clone,
      x_Arg: Clone,
      x_Arg: GraphEdge<T>,
      x_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
      T: 'static,
{
    pub fn y(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(x: x_Arg) -> Self {
        Self {
            phantom_T: PhantomData,
            x,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(x: x_Arg) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            x,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<T, input_Arg, filter_sizes_Arg, out_backprop_Arg> GraphOperation for Conv2DBackpropFilter<T, input_Arg, filter_sizes_Arg, out_backprop_Arg>
where T: TensorType,
      T: Clone,
      input_Arg: Clone,
      input_Arg: GraphEdge<T>,
      input_Arg: 'static,
      filter_sizes_Arg: Clone,
      filter_sizes_Arg: GraphEdge<i32>,
      filter_sizes_Arg: 'static,
      out_backprop_Arg: Clone,
      out_backprop_Arg: GraphEdge<T>,
      out_backprop_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
      T: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("Conv2DBackpropFilter_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("Conv2DBackpropFilter", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.input)?
        }
        {
            new_op.add_edge(&self.filter_sizes)?
        }
        {
            new_op.add_edge(&self.out_backprop)?
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        {
            (|attrs| {new_op.set_attr_int_list("strides", attrs)})(&self.strides)?
        }
        {
            match self.use_cudnn_on_gpu {
                None => new_op.set_attr_value_proto("use_cudnn_on_gpu", &vec![40_u8, 1_u8,])?,
                Some(ref value) => (|attr: &bool| {new_op.set_attr_bool("use_cudnn_on_gpu", *attr)})(&value)?,
            };
        }
        {
            (|attr| {new_op.set_attr_string("padding", attr)})(&self.padding)?
        }
        {
            match self.data_format {
                None => new_op.set_attr_value_proto("data_format", &vec![18_u8, 4_u8, 78_u8, 72_u8, 87_u8, 67_u8,])?,
                Some(ref value) => (|attr| {new_op.set_attr_string("data_format", attr)})(&value)?,
            };
        }
        {
            match self.dilations {
                None => new_op.set_attr_value_proto("dilations", &vec![10_u8, 0_u8, 26_u8, 4_u8,])?,
                Some(ref value) => (|attrs| {new_op.set_attr_int_list("dilations", attrs)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct Conv2DBackpropFilter<T, input_Arg, filter_sizes_Arg, out_backprop_Arg>
where T: TensorType,
      T: Clone,
      input_Arg: Clone,
      input_Arg: GraphEdge<T>,
      input_Arg: 'static,
      filter_sizes_Arg: Clone,
      filter_sizes_Arg: GraphEdge<i32>,
      filter_sizes_Arg: 'static,
      out_backprop_Arg: Clone,
      out_backprop_Arg: GraphEdge<T>,
      out_backprop_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    input: input_Arg,
    filter_sizes: filter_sizes_Arg,
    out_backprop: out_backprop_Arg,
    strides: Vec<i64>,
    use_cudnn_on_gpu: Option<bool>,
    padding: String,
    data_format: Option<String>,
    dilations: Option<Vec<i64>>,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<T, input_Arg, filter_sizes_Arg, out_backprop_Arg> Conv2DBackpropFilter<T, input_Arg, filter_sizes_Arg, out_backprop_Arg>
where T: TensorType,
      T: Clone,
      input_Arg: Clone,
      input_Arg: GraphEdge<T>,
      input_Arg: 'static,
      filter_sizes_Arg: Clone,
      filter_sizes_Arg: GraphEdge<i32>,
      filter_sizes_Arg: 'static,
      out_backprop_Arg: Clone,
      out_backprop_Arg: GraphEdge<T>,
      out_backprop_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
      T: 'static,
{
    pub fn output(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn use_cudnn_on_gpu(&mut self, use_cudnn_on_gpu: bool) -> Self {
        self.use_cudnn_on_gpu = Some(use_cudnn_on_gpu);
        self.clone()
    }

    pub fn data_format(&mut self, data_format: &str) -> Self {
        self.data_format = Some(data_format.to_string());
        self.clone()
    }

    pub fn dilations(&mut self, dilations: &[i64]) -> Self {
        self.dilations = Some(dilations.to_vec());
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(input: input_Arg, filter_sizes: filter_sizes_Arg, out_backprop: out_backprop_Arg, strides: &[i64], padding: &str) -> Self {
        Self {
            phantom_T: PhantomData,
            input,
            filter_sizes,
            out_backprop,
            strides: strides.to_vec(),
            use_cudnn_on_gpu: None,
            padding: padding.to_string(),
            data_format: None,
            dilations: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(input: input_Arg, filter_sizes: filter_sizes_Arg, out_backprop: out_backprop_Arg, strides: &[i64], padding: &str) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            input,
            filter_sizes,
            out_backprop,
            strides: strides.to_vec(),
            use_cudnn_on_gpu: None,
            padding: padding.to_string(),
            data_format: None,
            dilations: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<dtype> GraphOperation for Placeholder<dtype>
where dtype: TensorType,
      dtype: 'static,
      dtype: Clone,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("Placeholder_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("Placeholder", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.set_attr_type("dtype", dtype::data_type())?;
        }
        {
            match self.shape {
                None => new_op.set_attr_value_proto("shape", &vec![58_u8, 0_u8,])?,
                Some(ref value) => (|attr| {new_op.set_attr_shape("shape", attr)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct Placeholder<dtype>
where dtype: TensorType,
      dtype: 'static,
      dtype: Clone,
{
    phantom_dtype: PhantomData<dtype>,
    shape: Option<OtherShape>,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<dtype> Placeholder<dtype>
where dtype: TensorType,
      dtype: 'static,
      dtype: Clone,
{
    pub fn output(self) -> Edge<dtype> {
        let rc = Rc::new(self);
        {
            Edge::<dtype>::new(rc.clone(), 0)
        }
    }

    pub fn shape(&mut self, shape: &OtherShape) -> Self {
        self.shape = Some(shape.clone());
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<dtype> {
        let rc = Rc::new(self);
        {
            Edge::<dtype>::new(rc.clone(), 0)
        }
    }

    pub fn build() -> Self {
        Self {
            phantom_dtype: PhantomData,
            shape: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new() -> Edge<dtype> {
        Self {
            phantom_dtype: PhantomData,
            shape: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<indices_Arg, T, values_Arg, shape_Arg, start_Arg, size_Arg> GraphOperation for SparseSlice<indices_Arg, T, values_Arg, shape_Arg, start_Arg, size_Arg>
where indices_Arg: Clone,
      indices_Arg: GraphEdge<i64>,
      indices_Arg: 'static,
      T: TensorType,
      T: Clone,
      values_Arg: Clone,
      values_Arg: GraphEdge<T>,
      values_Arg: 'static,
      shape_Arg: Clone,
      shape_Arg: GraphEdge<i64>,
      shape_Arg: 'static,
      start_Arg: Clone,
      start_Arg: GraphEdge<i64>,
      start_Arg: 'static,
      size_Arg: Clone,
      size_Arg: GraphEdge<i64>,
      size_Arg: 'static,
      T: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("SparseSlice_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("SparseSlice", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.indices)?
        }
        {
            new_op.add_edge(&self.values)?
        }
        {
            new_op.add_edge(&self.shape)?
        }
        {
            new_op.add_edge(&self.start)?
        }
        {
            new_op.add_edge(&self.size)?
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct SparseSlice<indices_Arg, T, values_Arg, shape_Arg, start_Arg, size_Arg>
where indices_Arg: Clone,
      indices_Arg: GraphEdge<i64>,
      indices_Arg: 'static,
      T: TensorType,
      T: Clone,
      values_Arg: Clone,
      values_Arg: GraphEdge<T>,
      values_Arg: 'static,
      shape_Arg: Clone,
      shape_Arg: GraphEdge<i64>,
      shape_Arg: 'static,
      start_Arg: Clone,
      start_Arg: GraphEdge<i64>,
      start_Arg: 'static,
      size_Arg: Clone,
      size_Arg: GraphEdge<i64>,
      size_Arg: 'static,
      T: 'static,
{
    indices: indices_Arg,
    phantom_T: PhantomData<T>,
    values: values_Arg,
    shape: shape_Arg,
    start: start_Arg,
    size: size_Arg,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<indices_Arg, T, values_Arg, shape_Arg, start_Arg, size_Arg> SparseSlice<indices_Arg, T, values_Arg, shape_Arg, start_Arg, size_Arg>
where indices_Arg: Clone,
      indices_Arg: GraphEdge<i64>,
      indices_Arg: 'static,
      T: TensorType,
      T: Clone,
      values_Arg: Clone,
      values_Arg: GraphEdge<T>,
      values_Arg: 'static,
      shape_Arg: Clone,
      shape_Arg: GraphEdge<i64>,
      shape_Arg: 'static,
      start_Arg: Clone,
      start_Arg: GraphEdge<i64>,
      start_Arg: 'static,
      size_Arg: Clone,
      size_Arg: GraphEdge<i64>,
      size_Arg: 'static,
      T: 'static,
{
    pub fn output_indices(self) -> Edge<i64> {
        let rc = Rc::new(self);
        {
            Edge::<i64>::new(rc.clone(), 0)
        }
    }

    pub fn output_values(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 1)
        }
    }

    pub fn output_shape(self) -> Edge<i64> {
        let rc = Rc::new(self);
        {
            Edge::<i64>::new(rc.clone(), 2)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> (Edge<i64>, Edge<T>, Edge<i64>) {
        let rc = Rc::new(self);
        (
        {
            Edge::<i64>::new(rc.clone(), 0)
        },
        {
            Edge::<T>::new(rc.clone(), 1)
        },
        {
            Edge::<i64>::new(rc.clone(), 2)
        },
        )
    }

    pub fn build(indices: indices_Arg, values: values_Arg, shape: shape_Arg, start: start_Arg, size: size_Arg) -> Self {
        Self {
            indices,
            phantom_T: PhantomData,
            values,
            shape,
            start,
            size,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(indices: indices_Arg, values: values_Arg, shape: shape_Arg, start: start_Arg, size: size_Arg) -> (Edge<i64>, Edge<T>, Edge<i64>) {
        Self {
            indices,
            phantom_T: PhantomData,
            values,
            shape,
            start,
            size,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<concat_dim_Arg, T, values_Arg, input_mins_Arg, input_maxes_Arg> GraphOperation for QuantizedConcat<concat_dim_Arg, T, values_Arg, input_mins_Arg, input_maxes_Arg>
where concat_dim_Arg: Clone,
      concat_dim_Arg: GraphEdge<i32>,
      concat_dim_Arg: 'static,
      T: TensorType,
      T: Clone,
      values_Arg: Clone,
      values_Arg: GraphEdge<T>,
      values_Arg: 'static,
      input_mins_Arg: Clone,
      input_mins_Arg: GraphEdge<f32>,
      input_mins_Arg: 'static,
      input_maxes_Arg: Clone,
      input_maxes_Arg: GraphEdge<f32>,
      input_maxes_Arg: 'static,
      T: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("QuantizedConcat_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("QuantizedConcat", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.concat_dim)?
        }
        {
            new_op.add_edge(&self.values)?
        }
        {
            new_op.add_edge(&self.input_mins)?
        }
        {
            new_op.add_edge(&self.input_maxes)?
        }
        {
            (|attr: &i64| {new_op.set_attr_int("N", *attr)})(&self.N)?
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct QuantizedConcat<concat_dim_Arg, T, values_Arg, input_mins_Arg, input_maxes_Arg>
where concat_dim_Arg: Clone,
      concat_dim_Arg: GraphEdge<i32>,
      concat_dim_Arg: 'static,
      T: TensorType,
      T: Clone,
      values_Arg: Clone,
      values_Arg: GraphEdge<T>,
      values_Arg: 'static,
      input_mins_Arg: Clone,
      input_mins_Arg: GraphEdge<f32>,
      input_mins_Arg: 'static,
      input_maxes_Arg: Clone,
      input_maxes_Arg: GraphEdge<f32>,
      input_maxes_Arg: 'static,
      T: 'static,
{
    concat_dim: concat_dim_Arg,
    phantom_T: PhantomData<T>,
    values: values_Arg,
    input_mins: input_mins_Arg,
    input_maxes: input_maxes_Arg,
    N: i64,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<concat_dim_Arg, T, values_Arg, input_mins_Arg, input_maxes_Arg> QuantizedConcat<concat_dim_Arg, T, values_Arg, input_mins_Arg, input_maxes_Arg>
where concat_dim_Arg: Clone,
      concat_dim_Arg: GraphEdge<i32>,
      concat_dim_Arg: 'static,
      T: TensorType,
      T: Clone,
      values_Arg: Clone,
      values_Arg: GraphEdge<T>,
      values_Arg: 'static,
      input_mins_Arg: Clone,
      input_mins_Arg: GraphEdge<f32>,
      input_mins_Arg: 'static,
      input_maxes_Arg: Clone,
      input_maxes_Arg: GraphEdge<f32>,
      input_maxes_Arg: 'static,
      T: 'static,
{
    pub fn output(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn output_min(self) -> Edge<f32> {
        let rc = Rc::new(self);
        {
            Edge::<f32>::new(rc.clone(), 1)
        }
    }

    pub fn output_max(self) -> Edge<f32> {
        let rc = Rc::new(self);
        {
            Edge::<f32>::new(rc.clone(), 2)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> (Edge<T>, Edge<f32>, Edge<f32>) {
        let rc = Rc::new(self);
        (
        {
            Edge::<T>::new(rc.clone(), 0)
        },
        {
            Edge::<f32>::new(rc.clone(), 1)
        },
        {
            Edge::<f32>::new(rc.clone(), 2)
        },
        )
    }

    pub fn build(concat_dim: concat_dim_Arg, values: values_Arg, input_mins: input_mins_Arg, input_maxes: input_maxes_Arg, N: i64) -> Self {
        Self {
            concat_dim,
            phantom_T: PhantomData,
            values,
            input_mins,
            input_maxes,
            N: N,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(concat_dim: concat_dim_Arg, values: values_Arg, input_mins: input_mins_Arg, input_maxes: input_maxes_Arg, N: i64) -> (Edge<T>, Edge<f32>, Edge<f32>) {
        Self {
            concat_dim,
            phantom_T: PhantomData,
            values,
            input_mins,
            input_maxes,
            N: N,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<T, input_Arg, Tpaddings, paddings_Arg> GraphOperation for SpaceToBatch<T, input_Arg, Tpaddings, paddings_Arg>
where T: TensorType,
      T: Clone,
      input_Arg: Clone,
      input_Arg: GraphEdge<T>,
      input_Arg: 'static,
      Tpaddings: TensorType,
      Tpaddings: Clone,
      paddings_Arg: Clone,
      paddings_Arg: GraphEdge<Tpaddings>,
      paddings_Arg: 'static,
      T: 'static,
      Tpaddings: con_or_DT_INT32_or_DT_INT64,
      Tpaddings: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("SpaceToBatch_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("SpaceToBatch", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.input)?
        }
        {
            new_op.add_edge(&self.paddings)?
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        {
            new_op.set_attr_type("Tpaddings", Tpaddings::data_type())?;
        }
        {
            (|attr: &i64| {new_op.set_attr_int("block_size", *attr)})(&self.block_size)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct SpaceToBatch<T, input_Arg, Tpaddings, paddings_Arg>
where T: TensorType,
      T: Clone,
      input_Arg: Clone,
      input_Arg: GraphEdge<T>,
      input_Arg: 'static,
      Tpaddings: TensorType,
      Tpaddings: Clone,
      paddings_Arg: Clone,
      paddings_Arg: GraphEdge<Tpaddings>,
      paddings_Arg: 'static,
      T: 'static,
      Tpaddings: con_or_DT_INT32_or_DT_INT64,
      Tpaddings: 'static,
{
    phantom_T: PhantomData<T>,
    input: input_Arg,
    phantom_Tpaddings: PhantomData<Tpaddings>,
    paddings: paddings_Arg,
    block_size: i64,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<T, input_Arg, Tpaddings, paddings_Arg> SpaceToBatch<T, input_Arg, Tpaddings, paddings_Arg>
where T: TensorType,
      T: Clone,
      input_Arg: Clone,
      input_Arg: GraphEdge<T>,
      input_Arg: 'static,
      Tpaddings: TensorType,
      Tpaddings: Clone,
      paddings_Arg: Clone,
      paddings_Arg: GraphEdge<Tpaddings>,
      paddings_Arg: 'static,
      T: 'static,
      Tpaddings: con_or_DT_INT32_or_DT_INT64,
      Tpaddings: 'static,
{
    pub fn output(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(input: input_Arg, paddings: paddings_Arg, block_size: i64) -> Self {
        Self {
            phantom_T: PhantomData,
            input,
            phantom_Tpaddings: PhantomData,
            paddings,
            block_size: block_size,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(input: input_Arg, paddings: paddings_Arg, block_size: i64) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            input,
            phantom_Tpaddings: PhantomData,
            paddings,
            block_size: block_size,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<contents_Arg> GraphOperation for DecodeGif<contents_Arg>
where contents_Arg: Clone,
      contents_Arg: GraphEdge<String>,
      contents_Arg: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("DecodeGif_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("DecodeGif", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.contents)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct DecodeGif<contents_Arg>
where contents_Arg: Clone,
      contents_Arg: GraphEdge<String>,
      contents_Arg: 'static,
{
    contents: contents_Arg,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<contents_Arg> DecodeGif<contents_Arg>
where contents_Arg: Clone,
      contents_Arg: GraphEdge<String>,
      contents_Arg: 'static,
{
    pub fn image(self) -> Edge<u8> {
        let rc = Rc::new(self);
        {
            Edge::<u8>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<u8> {
        let rc = Rc::new(self);
        {
            Edge::<u8>::new(rc.clone(), 0)
        }
    }

    pub fn build(contents: contents_Arg) -> Self {
        Self {
            contents,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(contents: contents_Arg) -> Edge<u8> {
        Self {
            contents,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<T, value_Arg> GraphOperation for Unpack<T, value_Arg>
where T: TensorType,
      T: Clone,
      value_Arg: Clone,
      value_Arg: GraphEdge<T>,
      value_Arg: 'static,
      T: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("Unpack_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("Unpack", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.value)?
        }
        {
            (|attr: &i64| {new_op.set_attr_int("num", *attr)})(&self.num)?
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        {
            match self.axis {
                None => new_op.set_attr_value_proto("axis", &vec![24_u8, 0_u8,])?,
                Some(ref value) => (|attr: &i64| {new_op.set_attr_int("axis", *attr)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct Unpack<T, value_Arg>
where T: TensorType,
      T: Clone,
      value_Arg: Clone,
      value_Arg: GraphEdge<T>,
      value_Arg: 'static,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    value: value_Arg,
    num: i64,
    axis: Option<i64>,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<T, value_Arg> Unpack<T, value_Arg>
where T: TensorType,
      T: Clone,
      value_Arg: Clone,
      value_Arg: GraphEdge<T>,
      value_Arg: 'static,
      T: 'static,
{
    pub fn output(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn axis(&mut self, axis: i64) -> Self {
        self.axis = Some(axis);
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(value: value_Arg, num: i64) -> Self {
        Self {
            phantom_T: PhantomData,
            value,
            num: num,
            axis: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(value: value_Arg, num: i64) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            value,
            num: num,
            axis: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<T, input_Arg, Tblock_shape, block_shape_Arg, Tcrops, crops_Arg> GraphOperation for BatchToSpaceND<T, input_Arg, Tblock_shape, block_shape_Arg, Tcrops, crops_Arg>
where T: TensorType,
      T: Clone,
      input_Arg: Clone,
      input_Arg: GraphEdge<T>,
      input_Arg: 'static,
      Tblock_shape: TensorType,
      Tblock_shape: Clone,
      block_shape_Arg: Clone,
      block_shape_Arg: GraphEdge<Tblock_shape>,
      block_shape_Arg: 'static,
      Tcrops: TensorType,
      Tcrops: Clone,
      crops_Arg: Clone,
      crops_Arg: GraphEdge<Tcrops>,
      crops_Arg: 'static,
      T: 'static,
      Tblock_shape: con_or_DT_INT32_or_DT_INT64,
      Tblock_shape: 'static,
      Tcrops: con_or_DT_INT32_or_DT_INT64,
      Tcrops: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("BatchToSpaceND_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("BatchToSpaceND", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.input)?
        }
        {
            new_op.add_edge(&self.block_shape)?
        }
        {
            new_op.add_edge(&self.crops)?
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        {
            new_op.set_attr_type("Tblock_shape", Tblock_shape::data_type())?;
        }
        {
            new_op.set_attr_type("Tcrops", Tcrops::data_type())?;
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct BatchToSpaceND<T, input_Arg, Tblock_shape, block_shape_Arg, Tcrops, crops_Arg>
where T: TensorType,
      T: Clone,
      input_Arg: Clone,
      input_Arg: GraphEdge<T>,
      input_Arg: 'static,
      Tblock_shape: TensorType,
      Tblock_shape: Clone,
      block_shape_Arg: Clone,
      block_shape_Arg: GraphEdge<Tblock_shape>,
      block_shape_Arg: 'static,
      Tcrops: TensorType,
      Tcrops: Clone,
      crops_Arg: Clone,
      crops_Arg: GraphEdge<Tcrops>,
      crops_Arg: 'static,
      T: 'static,
      Tblock_shape: con_or_DT_INT32_or_DT_INT64,
      Tblock_shape: 'static,
      Tcrops: con_or_DT_INT32_or_DT_INT64,
      Tcrops: 'static,
{
    phantom_T: PhantomData<T>,
    input: input_Arg,
    phantom_Tblock_shape: PhantomData<Tblock_shape>,
    block_shape: block_shape_Arg,
    phantom_Tcrops: PhantomData<Tcrops>,
    crops: crops_Arg,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<T, input_Arg, Tblock_shape, block_shape_Arg, Tcrops, crops_Arg> BatchToSpaceND<T, input_Arg, Tblock_shape, block_shape_Arg, Tcrops, crops_Arg>
where T: TensorType,
      T: Clone,
      input_Arg: Clone,
      input_Arg: GraphEdge<T>,
      input_Arg: 'static,
      Tblock_shape: TensorType,
      Tblock_shape: Clone,
      block_shape_Arg: Clone,
      block_shape_Arg: GraphEdge<Tblock_shape>,
      block_shape_Arg: 'static,
      Tcrops: TensorType,
      Tcrops: Clone,
      crops_Arg: Clone,
      crops_Arg: GraphEdge<Tcrops>,
      crops_Arg: 'static,
      T: 'static,
      Tblock_shape: con_or_DT_INT32_or_DT_INT64,
      Tblock_shape: 'static,
      Tcrops: con_or_DT_INT32_or_DT_INT64,
      Tcrops: 'static,
{
    pub fn output(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(input: input_Arg, block_shape: block_shape_Arg, crops: crops_Arg) -> Self {
        Self {
            phantom_T: PhantomData,
            input,
            phantom_Tblock_shape: PhantomData,
            block_shape,
            phantom_Tcrops: PhantomData,
            crops,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(input: input_Arg, block_shape: block_shape_Arg, crops: crops_Arg) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            input,
            phantom_Tblock_shape: PhantomData,
            block_shape,
            phantom_Tcrops: PhantomData,
            crops,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

pub trait con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_QINT16_or_DT_QUINT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_QINT16_or_DT_QUINT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64 for BFloat16 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_QINT16_or_DT_QUINT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64 for OtherComplex<f32> {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_QINT16_or_DT_QUINT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64 for OtherComplex<f64> {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_QINT16_or_DT_QUINT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64 for f32 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_QINT16_or_DT_QUINT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64 for f64 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_QINT16_or_DT_QUINT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64 for i16 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_QINT16_or_DT_QUINT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64 for i32 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_QINT16_or_DT_QUINT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64 for i64 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_QINT16_or_DT_QUINT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64 for i8 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_QINT16_or_DT_QUINT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64 for u16 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_QINT16_or_DT_QUINT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64 for u32 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_QINT16_or_DT_QUINT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64 for u64 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_QINT16_or_DT_QUINT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64 for u8 {
}

impl<T, input_Arg, type_> GraphOperation for Bitcast<T, input_Arg, type_>
where T: TensorType,
      T: Clone,
      input_Arg: Clone,
      input_Arg: GraphEdge<T>,
      input_Arg: 'static,
      type_: TensorType,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_QINT16_or_DT_QUINT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
      type_: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_QINT16_or_DT_QUINT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      type_: 'static,
      type_: Clone,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("Bitcast_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("Bitcast", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.input)?
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        {
            new_op.set_attr_type("type_", type_::data_type())?;
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct Bitcast<T, input_Arg, type_>
where T: TensorType,
      T: Clone,
      input_Arg: Clone,
      input_Arg: GraphEdge<T>,
      input_Arg: 'static,
      type_: TensorType,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_QINT16_or_DT_QUINT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
      type_: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_QINT16_or_DT_QUINT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      type_: 'static,
      type_: Clone,
{
    phantom_T: PhantomData<T>,
    input: input_Arg,
    phantom_type_: PhantomData<type_>,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<T, input_Arg, type_> Bitcast<T, input_Arg, type_>
where T: TensorType,
      T: Clone,
      input_Arg: Clone,
      input_Arg: GraphEdge<T>,
      input_Arg: 'static,
      type_: TensorType,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_QINT16_or_DT_QUINT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
      type_: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_QINT16_or_DT_QUINT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      type_: 'static,
      type_: Clone,
{
    pub fn output(self) -> Edge<type_> {
        let rc = Rc::new(self);
        {
            Edge::<type_>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<type_> {
        let rc = Rc::new(self);
        {
            Edge::<type_>::new(rc.clone(), 0)
        }
    }

    pub fn build(input: input_Arg) -> Self {
        Self {
            phantom_T: PhantomData,
            input,
            phantom_type_: PhantomData,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(input: input_Arg) -> Edge<type_> {
        Self {
            phantom_T: PhantomData,
            input,
            phantom_type_: PhantomData,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<T, input_Arg> GraphOperation for Where<T, input_Arg>
where T: TensorType,
      T: Clone,
      input_Arg: Clone,
      input_Arg: GraphEdge<T>,
      input_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_BOOL_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("Where_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("Where", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.input)?
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct Where<T, input_Arg>
where T: TensorType,
      T: Clone,
      input_Arg: Clone,
      input_Arg: GraphEdge<T>,
      input_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_BOOL_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    input: input_Arg,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<T, input_Arg> Where<T, input_Arg>
where T: TensorType,
      T: Clone,
      input_Arg: Clone,
      input_Arg: GraphEdge<T>,
      input_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_BOOL_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
{
    pub fn index(self) -> Edge<i64> {
        let rc = Rc::new(self);
        {
            Edge::<i64>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<i64> {
        let rc = Rc::new(self);
        {
            Edge::<i64>::new(rc.clone(), 0)
        }
    }

    pub fn build(input: input_Arg) -> Self {
        Self {
            phantom_T: PhantomData,
            input,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(input: input_Arg) -> Edge<i64> {
        Self {
            phantom_T: PhantomData,
            input,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<T, input_Arg> GraphOperation for QuantizeAndDequantize<T, input_Arg>
where T: TensorType,
      T: Clone,
      input_Arg: Clone,
      input_Arg: GraphEdge<T>,
      input_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
      T: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("QuantizeAndDequantize_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("QuantizeAndDequantize", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.input)?
        }
        {
            match self.signed_input {
                None => new_op.set_attr_value_proto("signed_input", &vec![40_u8, 1_u8,])?,
                Some(ref value) => (|attr: &bool| {new_op.set_attr_bool("signed_input", *attr)})(&value)?,
            };
        }
        {
            match self.num_bits {
                None => new_op.set_attr_value_proto("num_bits", &vec![24_u8, 8_u8,])?,
                Some(ref value) => (|attr: &i64| {new_op.set_attr_int("num_bits", *attr)})(&value)?,
            };
        }
        {
            match self.range_given {
                None => new_op.set_attr_value_proto("range_given", &vec![40_u8, 0_u8,])?,
                Some(ref value) => (|attr: &bool| {new_op.set_attr_bool("range_given", *attr)})(&value)?,
            };
        }
        {
            match self.input_min {
                None => new_op.set_attr_value_proto("input_min", &vec![37_u8, 0_u8, 0_u8, 0_u8, 0_u8,])?,
                Some(ref value) => (|attr: &f32| {new_op.set_attr_float("input_min", *attr)})(&value)?,
            };
        }
        {
            match self.input_max {
                None => new_op.set_attr_value_proto("input_max", &vec![37_u8, 0_u8, 0_u8, 0_u8, 0_u8,])?,
                Some(ref value) => (|attr: &f32| {new_op.set_attr_float("input_max", *attr)})(&value)?,
            };
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct QuantizeAndDequantize<T, input_Arg>
where T: TensorType,
      T: Clone,
      input_Arg: Clone,
      input_Arg: GraphEdge<T>,
      input_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    input: input_Arg,
    signed_input: Option<bool>,
    num_bits: Option<i64>,
    range_given: Option<bool>,
    input_min: Option<f32>,
    input_max: Option<f32>,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<T, input_Arg> QuantizeAndDequantize<T, input_Arg>
where T: TensorType,
      T: Clone,
      input_Arg: Clone,
      input_Arg: GraphEdge<T>,
      input_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
      T: 'static,
{
    pub fn output(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn signed_input(&mut self, signed_input: bool) -> Self {
        self.signed_input = Some(signed_input);
        self.clone()
    }

    pub fn num_bits(&mut self, num_bits: i64) -> Self {
        self.num_bits = Some(num_bits);
        self.clone()
    }

    pub fn range_given(&mut self, range_given: bool) -> Self {
        self.range_given = Some(range_given);
        self.clone()
    }

    pub fn input_min(&mut self, input_min: f32) -> Self {
        self.input_min = Some(input_min);
        self.clone()
    }

    pub fn input_max(&mut self, input_max: f32) -> Self {
        self.input_max = Some(input_max);
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(input: input_Arg) -> Self {
        Self {
            phantom_T: PhantomData,
            input,
            signed_input: None,
            num_bits: None,
            range_given: None,
            input_min: None,
            input_max: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(input: input_Arg) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            input,
            signed_input: None,
            num_bits: None,
            range_given: None,
            input_min: None,
            input_max: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<sparse_example_indices_Arg, sparse_feature_indices_Arg, sparse_feature_values_Arg, dense_features_Arg, example_weights_Arg, example_labels_Arg, sparse_indices_Arg, sparse_weights_Arg, dense_weights_Arg, example_state_data_Arg> GraphOperation for SdcaOptimizerV2<sparse_example_indices_Arg, sparse_feature_indices_Arg, sparse_feature_values_Arg, dense_features_Arg, example_weights_Arg, example_labels_Arg, sparse_indices_Arg, sparse_weights_Arg, dense_weights_Arg, example_state_data_Arg>
where sparse_example_indices_Arg: Clone,
      sparse_example_indices_Arg: GraphEdge<i64>,
      sparse_example_indices_Arg: 'static,
      sparse_feature_indices_Arg: Clone,
      sparse_feature_indices_Arg: GraphEdge<i64>,
      sparse_feature_indices_Arg: 'static,
      sparse_feature_values_Arg: Clone,
      sparse_feature_values_Arg: GraphEdge<f32>,
      sparse_feature_values_Arg: 'static,
      dense_features_Arg: Clone,
      dense_features_Arg: GraphEdge<f32>,
      dense_features_Arg: 'static,
      example_weights_Arg: Clone,
      example_weights_Arg: GraphEdge<f32>,
      example_weights_Arg: 'static,
      example_labels_Arg: Clone,
      example_labels_Arg: GraphEdge<f32>,
      example_labels_Arg: 'static,
      sparse_indices_Arg: Clone,
      sparse_indices_Arg: GraphEdge<i64>,
      sparse_indices_Arg: 'static,
      sparse_weights_Arg: Clone,
      sparse_weights_Arg: GraphEdge<f32>,
      sparse_weights_Arg: 'static,
      dense_weights_Arg: Clone,
      dense_weights_Arg: GraphEdge<f32>,
      dense_weights_Arg: 'static,
      example_state_data_Arg: Clone,
      example_state_data_Arg: GraphEdge<f32>,
      example_state_data_Arg: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("SdcaOptimizerV2_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("SdcaOptimizerV2", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.sparse_example_indices)?
        }
        {
            new_op.add_edge(&self.sparse_feature_indices)?
        }
        {
            new_op.add_edge(&self.sparse_feature_values)?
        }
        {
            new_op.add_edge(&self.dense_features)?
        }
        {
            new_op.add_edge(&self.example_weights)?
        }
        {
            new_op.add_edge(&self.example_labels)?
        }
        {
            new_op.add_edge(&self.sparse_indices)?
        }
        {
            new_op.add_edge(&self.sparse_weights)?
        }
        {
            new_op.add_edge(&self.dense_weights)?
        }
        {
            new_op.add_edge(&self.example_state_data)?
        }
        {
            (|attr| {new_op.set_attr_string("loss_type", attr)})(&self.loss_type)?
        }
        {
            match self.adaptive {
                None => new_op.set_attr_value_proto("adaptive", &vec![40_u8, 0_u8,])?,
                Some(ref value) => (|attr: &bool| {new_op.set_attr_bool("adaptive", *attr)})(&value)?,
            };
        }
        {
            (|attr: &i64| {new_op.set_attr_int("num_sparse_features", *attr)})(&self.num_sparse_features)?
        }
        {
            (|attr: &i64| {new_op.set_attr_int("num_sparse_features_with_values", *attr)})(&self.num_sparse_features_with_values)?
        }
        {
            (|attr: &i64| {new_op.set_attr_int("num_dense_features", *attr)})(&self.num_dense_features)?
        }
        {
            (|attr: &f32| {new_op.set_attr_float("l1", *attr)})(&self.l1)?
        }
        {
            (|attr: &f32| {new_op.set_attr_float("l2", *attr)})(&self.l2)?
        }
        {
            (|attr: &i64| {new_op.set_attr_int("num_loss_partitions", *attr)})(&self.num_loss_partitions)?
        }
        {
            (|attr: &i64| {new_op.set_attr_int("num_inner_iterations", *attr)})(&self.num_inner_iterations)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct SdcaOptimizerV2<sparse_example_indices_Arg, sparse_feature_indices_Arg, sparse_feature_values_Arg, dense_features_Arg, example_weights_Arg, example_labels_Arg, sparse_indices_Arg, sparse_weights_Arg, dense_weights_Arg, example_state_data_Arg>
where sparse_example_indices_Arg: Clone,
      sparse_example_indices_Arg: GraphEdge<i64>,
      sparse_example_indices_Arg: 'static,
      sparse_feature_indices_Arg: Clone,
      sparse_feature_indices_Arg: GraphEdge<i64>,
      sparse_feature_indices_Arg: 'static,
      sparse_feature_values_Arg: Clone,
      sparse_feature_values_Arg: GraphEdge<f32>,
      sparse_feature_values_Arg: 'static,
      dense_features_Arg: Clone,
      dense_features_Arg: GraphEdge<f32>,
      dense_features_Arg: 'static,
      example_weights_Arg: Clone,
      example_weights_Arg: GraphEdge<f32>,
      example_weights_Arg: 'static,
      example_labels_Arg: Clone,
      example_labels_Arg: GraphEdge<f32>,
      example_labels_Arg: 'static,
      sparse_indices_Arg: Clone,
      sparse_indices_Arg: GraphEdge<i64>,
      sparse_indices_Arg: 'static,
      sparse_weights_Arg: Clone,
      sparse_weights_Arg: GraphEdge<f32>,
      sparse_weights_Arg: 'static,
      dense_weights_Arg: Clone,
      dense_weights_Arg: GraphEdge<f32>,
      dense_weights_Arg: 'static,
      example_state_data_Arg: Clone,
      example_state_data_Arg: GraphEdge<f32>,
      example_state_data_Arg: 'static,
{
    sparse_example_indices: sparse_example_indices_Arg,
    sparse_feature_indices: sparse_feature_indices_Arg,
    sparse_feature_values: sparse_feature_values_Arg,
    dense_features: dense_features_Arg,
    example_weights: example_weights_Arg,
    example_labels: example_labels_Arg,
    sparse_indices: sparse_indices_Arg,
    sparse_weights: sparse_weights_Arg,
    dense_weights: dense_weights_Arg,
    example_state_data: example_state_data_Arg,
    loss_type: String,
    adaptive: Option<bool>,
    num_sparse_features: i64,
    num_sparse_features_with_values: i64,
    num_dense_features: i64,
    l1: f32,
    l2: f32,
    num_loss_partitions: i64,
    num_inner_iterations: i64,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<sparse_example_indices_Arg, sparse_feature_indices_Arg, sparse_feature_values_Arg, dense_features_Arg, example_weights_Arg, example_labels_Arg, sparse_indices_Arg, sparse_weights_Arg, dense_weights_Arg, example_state_data_Arg> SdcaOptimizerV2<sparse_example_indices_Arg, sparse_feature_indices_Arg, sparse_feature_values_Arg, dense_features_Arg, example_weights_Arg, example_labels_Arg, sparse_indices_Arg, sparse_weights_Arg, dense_weights_Arg, example_state_data_Arg>
where sparse_example_indices_Arg: Clone,
      sparse_example_indices_Arg: GraphEdge<i64>,
      sparse_example_indices_Arg: 'static,
      sparse_feature_indices_Arg: Clone,
      sparse_feature_indices_Arg: GraphEdge<i64>,
      sparse_feature_indices_Arg: 'static,
      sparse_feature_values_Arg: Clone,
      sparse_feature_values_Arg: GraphEdge<f32>,
      sparse_feature_values_Arg: 'static,
      dense_features_Arg: Clone,
      dense_features_Arg: GraphEdge<f32>,
      dense_features_Arg: 'static,
      example_weights_Arg: Clone,
      example_weights_Arg: GraphEdge<f32>,
      example_weights_Arg: 'static,
      example_labels_Arg: Clone,
      example_labels_Arg: GraphEdge<f32>,
      example_labels_Arg: 'static,
      sparse_indices_Arg: Clone,
      sparse_indices_Arg: GraphEdge<i64>,
      sparse_indices_Arg: 'static,
      sparse_weights_Arg: Clone,
      sparse_weights_Arg: GraphEdge<f32>,
      sparse_weights_Arg: 'static,
      dense_weights_Arg: Clone,
      dense_weights_Arg: GraphEdge<f32>,
      dense_weights_Arg: 'static,
      example_state_data_Arg: Clone,
      example_state_data_Arg: GraphEdge<f32>,
      example_state_data_Arg: 'static,
{
    pub fn out_example_state_data(self) -> Edge<f32> {
        let rc = Rc::new(self);
        {
            Edge::<f32>::new(rc.clone(), 0)
        }
    }

    pub fn out_delta_sparse_weights(self) -> Edge<f32> {
        let rc = Rc::new(self);
        {
            Edge::<f32>::new(rc.clone(), 1)
        }
    }

    pub fn out_delta_dense_weights(self) -> Edge<f32> {
        let rc = Rc::new(self);
        {
            Edge::<f32>::new(rc.clone(), 2)
        }
    }

    pub fn adaptive(&mut self, adaptive: bool) -> Self {
        self.adaptive = Some(adaptive);
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> (Edge<f32>, Edge<f32>, Edge<f32>) {
        let rc = Rc::new(self);
        (
        {
            Edge::<f32>::new(rc.clone(), 0)
        },
        {
            Edge::<f32>::new(rc.clone(), 1)
        },
        {
            Edge::<f32>::new(rc.clone(), 2)
        },
        )
    }

    pub fn build(sparse_example_indices: sparse_example_indices_Arg, sparse_feature_indices: sparse_feature_indices_Arg, sparse_feature_values: sparse_feature_values_Arg, dense_features: dense_features_Arg, example_weights: example_weights_Arg, example_labels: example_labels_Arg, sparse_indices: sparse_indices_Arg, sparse_weights: sparse_weights_Arg, dense_weights: dense_weights_Arg, example_state_data: example_state_data_Arg, loss_type: &str, num_sparse_features: i64, num_sparse_features_with_values: i64, num_dense_features: i64, l1: f32, l2: f32, num_loss_partitions: i64, num_inner_iterations: i64) -> Self {
        Self {
            sparse_example_indices,
            sparse_feature_indices,
            sparse_feature_values,
            dense_features,
            example_weights,
            example_labels,
            sparse_indices,
            sparse_weights,
            dense_weights,
            example_state_data,
            loss_type: loss_type.to_string(),
            adaptive: None,
            num_sparse_features: num_sparse_features,
            num_sparse_features_with_values: num_sparse_features_with_values,
            num_dense_features: num_dense_features,
            l1: l1,
            l2: l2,
            num_loss_partitions: num_loss_partitions,
            num_inner_iterations: num_inner_iterations,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(sparse_example_indices: sparse_example_indices_Arg, sparse_feature_indices: sparse_feature_indices_Arg, sparse_feature_values: sparse_feature_values_Arg, dense_features: dense_features_Arg, example_weights: example_weights_Arg, example_labels: example_labels_Arg, sparse_indices: sparse_indices_Arg, sparse_weights: sparse_weights_Arg, dense_weights: dense_weights_Arg, example_state_data: example_state_data_Arg, loss_type: &str, num_sparse_features: i64, num_sparse_features_with_values: i64, num_dense_features: i64, l1: f32, l2: f32, num_loss_partitions: i64, num_inner_iterations: i64) -> (Edge<f32>, Edge<f32>, Edge<f32>) {
        Self {
            sparse_example_indices,
            sparse_feature_indices,
            sparse_feature_values,
            dense_features,
            example_weights,
            example_labels,
            sparse_indices,
            sparse_weights,
            dense_weights,
            example_state_data,
            loss_type: loss_type.to_string(),
            adaptive: None,
            num_sparse_features: num_sparse_features,
            num_sparse_features_with_values: num_sparse_features_with_values,
            num_dense_features: num_dense_features,
            l1: l1,
            l2: l2,
            num_loss_partitions: num_loss_partitions,
            num_inner_iterations: num_inner_iterations,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<T, input_Arg> GraphOperation for CopyHost<T, input_Arg>
where T: TensorType,
      T: Clone,
      input_Arg: Clone,
      input_Arg: GraphEdge<T>,
      input_Arg: 'static,
      T: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("CopyHost_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("CopyHost", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.input)?
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        {
            match self.tensor_name {
                None => new_op.set_attr_value_proto("tensor_name", &vec![18_u8, 0_u8,])?,
                Some(ref value) => (|attr| {new_op.set_attr_string("tensor_name", attr)})(&value)?,
            };
        }
        {
            match self.debug_ops_spec {
                None => new_op.set_attr_value_proto("debug_ops_spec", &vec![10_u8, 0_u8,])?,
                Some(ref value) => (|attrs| {new_op.set_attr_string_list("debug_ops_spec", attrs)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct CopyHost<T, input_Arg>
where T: TensorType,
      T: Clone,
      input_Arg: Clone,
      input_Arg: GraphEdge<T>,
      input_Arg: 'static,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    input: input_Arg,
    tensor_name: Option<String>,
    debug_ops_spec: Option<Vec<String>>,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<T, input_Arg> CopyHost<T, input_Arg>
where T: TensorType,
      T: Clone,
      input_Arg: Clone,
      input_Arg: GraphEdge<T>,
      input_Arg: 'static,
      T: 'static,
{
    pub fn output(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn tensor_name(&mut self, tensor_name: &str) -> Self {
        self.tensor_name = Some(tensor_name.to_string());
        self.clone()
    }

    pub fn debug_ops_spec(&mut self, debug_ops_spec: &[String]) -> Self {
        self.debug_ops_spec = Some(debug_ops_spec.to_vec());
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(input: input_Arg) -> Self {
        Self {
            phantom_T: PhantomData,
            input,
            tensor_name: None,
            debug_ops_spec: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(input: input_Arg) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            input,
            tensor_name: None,
            debug_ops_spec: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<T, orig_input_Arg, orig_output_Arg, out_backprop_Arg, row_pooling_sequence_Arg, col_pooling_sequence_Arg> GraphOperation for FractionalMaxPoolGrad<T, orig_input_Arg, orig_output_Arg, out_backprop_Arg, row_pooling_sequence_Arg, col_pooling_sequence_Arg>
where T: TensorType,
      T: Clone,
      orig_input_Arg: Clone,
      orig_input_Arg: GraphEdge<T>,
      orig_input_Arg: 'static,
      orig_output_Arg: Clone,
      orig_output_Arg: GraphEdge<T>,
      orig_output_Arg: 'static,
      out_backprop_Arg: Clone,
      out_backprop_Arg: GraphEdge<T>,
      out_backprop_Arg: 'static,
      row_pooling_sequence_Arg: Clone,
      row_pooling_sequence_Arg: GraphEdge<i64>,
      row_pooling_sequence_Arg: 'static,
      col_pooling_sequence_Arg: Clone,
      col_pooling_sequence_Arg: GraphEdge<i64>,
      col_pooling_sequence_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_INT64,
      T: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("FractionalMaxPoolGrad_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("FractionalMaxPoolGrad", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.orig_input)?
        }
        {
            new_op.add_edge(&self.orig_output)?
        }
        {
            new_op.add_edge(&self.out_backprop)?
        }
        {
            new_op.add_edge(&self.row_pooling_sequence)?
        }
        {
            new_op.add_edge(&self.col_pooling_sequence)?
        }
        {
            match self.overlapping {
                None => new_op.set_attr_value_proto("overlapping", &vec![40_u8, 0_u8,])?,
                Some(ref value) => (|attr: &bool| {new_op.set_attr_bool("overlapping", *attr)})(&value)?,
            };
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct FractionalMaxPoolGrad<T, orig_input_Arg, orig_output_Arg, out_backprop_Arg, row_pooling_sequence_Arg, col_pooling_sequence_Arg>
where T: TensorType,
      T: Clone,
      orig_input_Arg: Clone,
      orig_input_Arg: GraphEdge<T>,
      orig_input_Arg: 'static,
      orig_output_Arg: Clone,
      orig_output_Arg: GraphEdge<T>,
      orig_output_Arg: 'static,
      out_backprop_Arg: Clone,
      out_backprop_Arg: GraphEdge<T>,
      out_backprop_Arg: 'static,
      row_pooling_sequence_Arg: Clone,
      row_pooling_sequence_Arg: GraphEdge<i64>,
      row_pooling_sequence_Arg: 'static,
      col_pooling_sequence_Arg: Clone,
      col_pooling_sequence_Arg: GraphEdge<i64>,
      col_pooling_sequence_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_INT64,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    orig_input: orig_input_Arg,
    orig_output: orig_output_Arg,
    out_backprop: out_backprop_Arg,
    row_pooling_sequence: row_pooling_sequence_Arg,
    col_pooling_sequence: col_pooling_sequence_Arg,
    overlapping: Option<bool>,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<T, orig_input_Arg, orig_output_Arg, out_backprop_Arg, row_pooling_sequence_Arg, col_pooling_sequence_Arg> FractionalMaxPoolGrad<T, orig_input_Arg, orig_output_Arg, out_backprop_Arg, row_pooling_sequence_Arg, col_pooling_sequence_Arg>
where T: TensorType,
      T: Clone,
      orig_input_Arg: Clone,
      orig_input_Arg: GraphEdge<T>,
      orig_input_Arg: 'static,
      orig_output_Arg: Clone,
      orig_output_Arg: GraphEdge<T>,
      orig_output_Arg: 'static,
      out_backprop_Arg: Clone,
      out_backprop_Arg: GraphEdge<T>,
      out_backprop_Arg: 'static,
      row_pooling_sequence_Arg: Clone,
      row_pooling_sequence_Arg: GraphEdge<i64>,
      row_pooling_sequence_Arg: 'static,
      col_pooling_sequence_Arg: Clone,
      col_pooling_sequence_Arg: GraphEdge<i64>,
      col_pooling_sequence_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_INT64,
      T: 'static,
{
    pub fn output(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn overlapping(&mut self, overlapping: bool) -> Self {
        self.overlapping = Some(overlapping);
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(orig_input: orig_input_Arg, orig_output: orig_output_Arg, out_backprop: out_backprop_Arg, row_pooling_sequence: row_pooling_sequence_Arg, col_pooling_sequence: col_pooling_sequence_Arg) -> Self {
        Self {
            phantom_T: PhantomData,
            orig_input,
            orig_output,
            out_backprop,
            row_pooling_sequence,
            col_pooling_sequence,
            overlapping: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(orig_input: orig_input_Arg, orig_output: orig_output_Arg, out_backprop: out_backprop_Arg, row_pooling_sequence: row_pooling_sequence_Arg, col_pooling_sequence: col_pooling_sequence_Arg) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            orig_input,
            orig_output,
            out_backprop,
            row_pooling_sequence,
            col_pooling_sequence,
            overlapping: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<T, sorted_inputs_Arg, values_Arg, out_type> GraphOperation for UpperBound<T, sorted_inputs_Arg, values_Arg, out_type>
where T: TensorType,
      T: Clone,
      sorted_inputs_Arg: Clone,
      sorted_inputs_Arg: GraphEdge<T>,
      sorted_inputs_Arg: 'static,
      values_Arg: Clone,
      values_Arg: GraphEdge<T>,
      values_Arg: 'static,
      out_type: TensorType,
      T: 'static,
      out_type: con_or_DT_INT32_or_DT_INT64,
      out_type: 'static,
      out_type: Clone,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("UpperBound_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("UpperBound", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.sorted_inputs)?
        }
        {
            new_op.add_edge(&self.values)?
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        {
            new_op.set_attr_type("out_type", out_type::data_type())?;
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct UpperBound<T, sorted_inputs_Arg, values_Arg, out_type>
where T: TensorType,
      T: Clone,
      sorted_inputs_Arg: Clone,
      sorted_inputs_Arg: GraphEdge<T>,
      sorted_inputs_Arg: 'static,
      values_Arg: Clone,
      values_Arg: GraphEdge<T>,
      values_Arg: 'static,
      out_type: TensorType,
      T: 'static,
      out_type: con_or_DT_INT32_or_DT_INT64,
      out_type: 'static,
      out_type: Clone,
{
    phantom_T: PhantomData<T>,
    sorted_inputs: sorted_inputs_Arg,
    values: values_Arg,
    phantom_out_type: PhantomData<out_type>,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<T, sorted_inputs_Arg, values_Arg, out_type> UpperBound<T, sorted_inputs_Arg, values_Arg, out_type>
where T: TensorType,
      T: Clone,
      sorted_inputs_Arg: Clone,
      sorted_inputs_Arg: GraphEdge<T>,
      sorted_inputs_Arg: 'static,
      values_Arg: Clone,
      values_Arg: GraphEdge<T>,
      values_Arg: 'static,
      out_type: TensorType,
      T: 'static,
      out_type: con_or_DT_INT32_or_DT_INT64,
      out_type: 'static,
      out_type: Clone,
{
    pub fn output(self) -> Edge<out_type> {
        let rc = Rc::new(self);
        {
            Edge::<out_type>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<out_type> {
        let rc = Rc::new(self);
        {
            Edge::<out_type>::new(rc.clone(), 0)
        }
    }

    pub fn build(sorted_inputs: sorted_inputs_Arg, values: values_Arg) -> Self {
        Self {
            phantom_T: PhantomData,
            sorted_inputs,
            values,
            phantom_out_type: PhantomData,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(sorted_inputs: sorted_inputs_Arg, values: values_Arg) -> Edge<out_type> {
        Self {
            phantom_T: PhantomData,
            sorted_inputs,
            values,
            phantom_out_type: PhantomData,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl GraphOperation for RetrieveTPUEmbeddingADAMParametersGradAccumDebug {
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("RetrieveTPUEmbeddingADAMParametersGradAccumDebug_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("RetrieveTPUEmbeddingADAMParametersGradAccumDebug", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            match self.table_id {
                None => new_op.set_attr_value_proto("table_id", &vec![24_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 1_u8,])?,
                Some(ref value) => (|attr: &i64| {new_op.set_attr_int("table_id", *attr)})(&value)?,
            };
        }
        {
            match self.table_name {
                None => new_op.set_attr_value_proto("table_name", &vec![18_u8, 0_u8,])?,
                Some(ref value) => (|attr| {new_op.set_attr_string("table_name", attr)})(&value)?,
            };
        }
        {
            (|attr: &i64| {new_op.set_attr_int("num_shards", *attr)})(&self.num_shards)?
        }
        {
            (|attr: &i64| {new_op.set_attr_int("shard_id", *attr)})(&self.shard_id)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct RetrieveTPUEmbeddingADAMParametersGradAccumDebug {
    table_id: Option<i64>,
    table_name: Option<String>,
    num_shards: i64,
    shard_id: i64,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl RetrieveTPUEmbeddingADAMParametersGradAccumDebug {
    pub fn parameters(self) -> Edge<f32> {
        let rc = Rc::new(self);
        {
            Edge::<f32>::new(rc.clone(), 0)
        }
    }

    pub fn momenta(self) -> Edge<f32> {
        let rc = Rc::new(self);
        {
            Edge::<f32>::new(rc.clone(), 1)
        }
    }

    pub fn velocities(self) -> Edge<f32> {
        let rc = Rc::new(self);
        {
            Edge::<f32>::new(rc.clone(), 2)
        }
    }

    pub fn gradient_accumulators(self) -> Edge<f32> {
        let rc = Rc::new(self);
        {
            Edge::<f32>::new(rc.clone(), 3)
        }
    }

    pub fn table_id(&mut self, table_id: i64) -> Self {
        self.table_id = Some(table_id);
        self.clone()
    }

    pub fn table_name(&mut self, table_name: &str) -> Self {
        self.table_name = Some(table_name.to_string());
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> (Edge<f32>, Edge<f32>, Edge<f32>, Edge<f32>) {
        let rc = Rc::new(self);
        (
        {
            Edge::<f32>::new(rc.clone(), 0)
        },
        {
            Edge::<f32>::new(rc.clone(), 1)
        },
        {
            Edge::<f32>::new(rc.clone(), 2)
        },
        {
            Edge::<f32>::new(rc.clone(), 3)
        },
        )
    }

    pub fn build(num_shards: i64, shard_id: i64) -> Self {
        Self {
            table_id: None,
            table_name: None,
            num_shards: num_shards,
            shard_id: shard_id,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(num_shards: i64, shard_id: i64) -> (Edge<f32>, Edge<f32>, Edge<f32>, Edge<f32>) {
        Self {
            table_id: None,
            table_name: None,
            num_shards: num_shards,
            shard_id: shard_id,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<dtype> GraphOperation for _ParallelConcatStart<dtype>
where dtype: TensorType,
      dtype: 'static,
      dtype: Clone,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("_ParallelConcatStart_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("_ParallelConcatStart", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            (|attr| {new_op.set_attr_shape("shape", attr)})(&self.shape)?
        }
        {
            new_op.set_attr_type("dtype", dtype::data_type())?;
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct _ParallelConcatStart<dtype>
where dtype: TensorType,
      dtype: 'static,
      dtype: Clone,
{
    shape: OtherShape,
    phantom_dtype: PhantomData<dtype>,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<dtype> _ParallelConcatStart<dtype>
where dtype: TensorType,
      dtype: 'static,
      dtype: Clone,
{
    pub fn output(self) -> Edge<dtype> {
        let rc = Rc::new(self);
        {
            Edge::<dtype>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<dtype> {
        let rc = Rc::new(self);
        {
            Edge::<dtype>::new(rc.clone(), 0)
        }
    }

    pub fn build(shape: &OtherShape) -> Self {
        Self {
            shape: shape.clone(),
            phantom_dtype: PhantomData,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(shape: &OtherShape) -> Edge<dtype> {
        Self {
            shape: shape.clone(),
            phantom_dtype: PhantomData,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<T, sorted_inputs_Arg, values_Arg, out_type> GraphOperation for LowerBound<T, sorted_inputs_Arg, values_Arg, out_type>
where T: TensorType,
      T: Clone,
      sorted_inputs_Arg: Clone,
      sorted_inputs_Arg: GraphEdge<T>,
      sorted_inputs_Arg: 'static,
      values_Arg: Clone,
      values_Arg: GraphEdge<T>,
      values_Arg: 'static,
      out_type: TensorType,
      T: 'static,
      out_type: con_or_DT_INT32_or_DT_INT64,
      out_type: 'static,
      out_type: Clone,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("LowerBound_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("LowerBound", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.sorted_inputs)?
        }
        {
            new_op.add_edge(&self.values)?
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        {
            new_op.set_attr_type("out_type", out_type::data_type())?;
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct LowerBound<T, sorted_inputs_Arg, values_Arg, out_type>
where T: TensorType,
      T: Clone,
      sorted_inputs_Arg: Clone,
      sorted_inputs_Arg: GraphEdge<T>,
      sorted_inputs_Arg: 'static,
      values_Arg: Clone,
      values_Arg: GraphEdge<T>,
      values_Arg: 'static,
      out_type: TensorType,
      T: 'static,
      out_type: con_or_DT_INT32_or_DT_INT64,
      out_type: 'static,
      out_type: Clone,
{
    phantom_T: PhantomData<T>,
    sorted_inputs: sorted_inputs_Arg,
    values: values_Arg,
    phantom_out_type: PhantomData<out_type>,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<T, sorted_inputs_Arg, values_Arg, out_type> LowerBound<T, sorted_inputs_Arg, values_Arg, out_type>
where T: TensorType,
      T: Clone,
      sorted_inputs_Arg: Clone,
      sorted_inputs_Arg: GraphEdge<T>,
      sorted_inputs_Arg: 'static,
      values_Arg: Clone,
      values_Arg: GraphEdge<T>,
      values_Arg: 'static,
      out_type: TensorType,
      T: 'static,
      out_type: con_or_DT_INT32_or_DT_INT64,
      out_type: 'static,
      out_type: Clone,
{
    pub fn output(self) -> Edge<out_type> {
        let rc = Rc::new(self);
        {
            Edge::<out_type>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<out_type> {
        let rc = Rc::new(self);
        {
            Edge::<out_type>::new(rc.clone(), 0)
        }
    }

    pub fn build(sorted_inputs: sorted_inputs_Arg, values: values_Arg) -> Self {
        Self {
            phantom_T: PhantomData,
            sorted_inputs,
            values,
            phantom_out_type: PhantomData,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(sorted_inputs: sorted_inputs_Arg, values: values_Arg) -> Edge<out_type> {
        Self {
            phantom_T: PhantomData,
            sorted_inputs,
            values,
            phantom_out_type: PhantomData,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<T, tensor_Arg> GraphOperation for CheckNumerics<T, tensor_Arg>
where T: TensorType,
      T: Clone,
      tensor_Arg: Clone,
      tensor_Arg: GraphEdge<T>,
      tensor_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
      T: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("CheckNumerics_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("CheckNumerics", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.tensor)?
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        {
            (|attr| {new_op.set_attr_string("message", attr)})(&self.message)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct CheckNumerics<T, tensor_Arg>
where T: TensorType,
      T: Clone,
      tensor_Arg: Clone,
      tensor_Arg: GraphEdge<T>,
      tensor_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    tensor: tensor_Arg,
    message: String,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<T, tensor_Arg> CheckNumerics<T, tensor_Arg>
where T: TensorType,
      T: Clone,
      tensor_Arg: Clone,
      tensor_Arg: GraphEdge<T>,
      tensor_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
      T: 'static,
{
    pub fn output(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(tensor: tensor_Arg, message: &str) -> Self {
        Self {
            phantom_T: PhantomData,
            tensor,
            message: message.to_string(),
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(tensor: tensor_Arg, message: &str) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            tensor,
            message: message.to_string(),
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<T, x_Arg, Taxis, axis_Arg, out_idx> GraphOperation for UniqueWithCountsV2<T, x_Arg, Taxis, axis_Arg, out_idx>
where T: TensorType,
      T: Clone,
      x_Arg: Clone,
      x_Arg: GraphEdge<T>,
      x_Arg: 'static,
      Taxis: TensorType,
      Taxis: Clone,
      axis_Arg: Clone,
      axis_Arg: GraphEdge<Taxis>,
      axis_Arg: 'static,
      out_idx: TensorType,
      T: 'static,
      Taxis: con_or_DT_INT32_or_DT_INT64,
      Taxis: 'static,
      out_idx: con_or_DT_INT32_or_DT_INT64,
      out_idx: 'static,
      out_idx: Clone,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("UniqueWithCountsV2_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("UniqueWithCountsV2", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.x)?
        }
        {
            new_op.add_edge(&self.axis)?
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        {
            new_op.set_attr_type("Taxis", Taxis::data_type())?;
        }
        {
            new_op.set_attr_type("out_idx", out_idx::data_type())?;
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct UniqueWithCountsV2<T, x_Arg, Taxis, axis_Arg, out_idx>
where T: TensorType,
      T: Clone,
      x_Arg: Clone,
      x_Arg: GraphEdge<T>,
      x_Arg: 'static,
      Taxis: TensorType,
      Taxis: Clone,
      axis_Arg: Clone,
      axis_Arg: GraphEdge<Taxis>,
      axis_Arg: 'static,
      out_idx: TensorType,
      T: 'static,
      Taxis: con_or_DT_INT32_or_DT_INT64,
      Taxis: 'static,
      out_idx: con_or_DT_INT32_or_DT_INT64,
      out_idx: 'static,
      out_idx: Clone,
{
    phantom_T: PhantomData<T>,
    x: x_Arg,
    phantom_Taxis: PhantomData<Taxis>,
    axis: axis_Arg,
    phantom_out_idx: PhantomData<out_idx>,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<T, x_Arg, Taxis, axis_Arg, out_idx> UniqueWithCountsV2<T, x_Arg, Taxis, axis_Arg, out_idx>
where T: TensorType,
      T: Clone,
      x_Arg: Clone,
      x_Arg: GraphEdge<T>,
      x_Arg: 'static,
      Taxis: TensorType,
      Taxis: Clone,
      axis_Arg: Clone,
      axis_Arg: GraphEdge<Taxis>,
      axis_Arg: 'static,
      out_idx: TensorType,
      T: 'static,
      Taxis: con_or_DT_INT32_or_DT_INT64,
      Taxis: 'static,
      out_idx: con_or_DT_INT32_or_DT_INT64,
      out_idx: 'static,
      out_idx: Clone,
{
    pub fn y(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn idx(self) -> Edge<out_idx> {
        let rc = Rc::new(self);
        {
            Edge::<out_idx>::new(rc.clone(), 1)
        }
    }

    pub fn count(self) -> Edge<out_idx> {
        let rc = Rc::new(self);
        {
            Edge::<out_idx>::new(rc.clone(), 2)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> (Edge<T>, Edge<out_idx>, Edge<out_idx>) {
        let rc = Rc::new(self);
        (
        {
            Edge::<T>::new(rc.clone(), 0)
        },
        {
            Edge::<out_idx>::new(rc.clone(), 1)
        },
        {
            Edge::<out_idx>::new(rc.clone(), 2)
        },
        )
    }

    pub fn build(x: x_Arg, axis: axis_Arg) -> Self {
        Self {
            phantom_T: PhantomData,
            x,
            phantom_Taxis: PhantomData,
            axis,
            phantom_out_idx: PhantomData,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(x: x_Arg, axis: axis_Arg) -> (Edge<T>, Edge<out_idx>, Edge<out_idx>) {
        Self {
            phantom_T: PhantomData,
            x,
            phantom_Taxis: PhantomData,
            axis,
            phantom_out_idx: PhantomData,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<table_handle_Arg> GraphOperation for LookupTableSize<table_handle_Arg>
where table_handle_Arg: Clone,
      table_handle_Arg: GraphRefEdge<String>,
      table_handle_Arg: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("LookupTableSize_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("LookupTableSize", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.table_handle)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct LookupTableSize<table_handle_Arg>
where table_handle_Arg: Clone,
      table_handle_Arg: GraphRefEdge<String>,
      table_handle_Arg: 'static,
{
    table_handle: table_handle_Arg,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<table_handle_Arg> LookupTableSize<table_handle_Arg>
where table_handle_Arg: Clone,
      table_handle_Arg: GraphRefEdge<String>,
      table_handle_Arg: 'static,
{
    pub fn size(self) -> Edge<i64> {
        let rc = Rc::new(self);
        {
            Edge::<i64>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<i64> {
        let rc = Rc::new(self);
        {
            Edge::<i64>::new(rc.clone(), 0)
        }
    }

    pub fn build(table_handle: table_handle_Arg) -> Self {
        Self {
            table_handle,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(table_handle: table_handle_Arg) -> Edge<i64> {
        Self {
            table_handle,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<T, matrix_Arg, rhs_Arg> GraphOperation for MatrixTriangularSolve<T, matrix_Arg, rhs_Arg>
where T: TensorType,
      T: Clone,
      matrix_Arg: Clone,
      matrix_Arg: GraphEdge<T>,
      matrix_Arg: 'static,
      rhs_Arg: Clone,
      rhs_Arg: GraphEdge<T>,
      rhs_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_COMPLEX64_or_DT_COMPLEX128,
      T: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("MatrixTriangularSolve_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("MatrixTriangularSolve", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.matrix)?
        }
        {
            new_op.add_edge(&self.rhs)?
        }
        {
            match self.lower {
                None => new_op.set_attr_value_proto("lower", &vec![40_u8, 1_u8,])?,
                Some(ref value) => (|attr: &bool| {new_op.set_attr_bool("lower", *attr)})(&value)?,
            };
        }
        {
            match self.adjoint {
                None => new_op.set_attr_value_proto("adjoint", &vec![40_u8, 0_u8,])?,
                Some(ref value) => (|attr: &bool| {new_op.set_attr_bool("adjoint", *attr)})(&value)?,
            };
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct MatrixTriangularSolve<T, matrix_Arg, rhs_Arg>
where T: TensorType,
      T: Clone,
      matrix_Arg: Clone,
      matrix_Arg: GraphEdge<T>,
      matrix_Arg: 'static,
      rhs_Arg: Clone,
      rhs_Arg: GraphEdge<T>,
      rhs_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_COMPLEX64_or_DT_COMPLEX128,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    matrix: matrix_Arg,
    rhs: rhs_Arg,
    lower: Option<bool>,
    adjoint: Option<bool>,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<T, matrix_Arg, rhs_Arg> MatrixTriangularSolve<T, matrix_Arg, rhs_Arg>
where T: TensorType,
      T: Clone,
      matrix_Arg: Clone,
      matrix_Arg: GraphEdge<T>,
      matrix_Arg: 'static,
      rhs_Arg: Clone,
      rhs_Arg: GraphEdge<T>,
      rhs_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_COMPLEX64_or_DT_COMPLEX128,
      T: 'static,
{
    pub fn output(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn lower(&mut self, lower: bool) -> Self {
        self.lower = Some(lower);
        self.clone()
    }

    pub fn adjoint(&mut self, adjoint: bool) -> Self {
        self.adjoint = Some(adjoint);
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(matrix: matrix_Arg, rhs: rhs_Arg) -> Self {
        Self {
            phantom_T: PhantomData,
            matrix,
            rhs,
            lower: None,
            adjoint: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(matrix: matrix_Arg, rhs: rhs_Arg) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            matrix,
            rhs,
            lower: None,
            adjoint: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<handle_Arg> GraphOperation for QueueClose<handle_Arg>
where handle_Arg: Clone,
      handle_Arg: GraphRefEdge<String>,
      handle_Arg: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("QueueClose_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("QueueClose", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.handle)?
        }
        {
            match self.cancel_pending_enqueues {
                None => new_op.set_attr_value_proto("cancel_pending_enqueues", &vec![40_u8, 0_u8,])?,
                Some(ref value) => (|attr: &bool| {new_op.set_attr_bool("cancel_pending_enqueues", *attr)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct QueueClose<handle_Arg>
where handle_Arg: Clone,
      handle_Arg: GraphRefEdge<String>,
      handle_Arg: 'static,
{
    handle: handle_Arg,
    cancel_pending_enqueues: Option<bool>,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<handle_Arg> QueueClose<handle_Arg>
where handle_Arg: Clone,
      handle_Arg: GraphRefEdge<String>,
      handle_Arg: 'static,
{
    pub fn cancel_pending_enqueues(&mut self, cancel_pending_enqueues: bool) -> Self {
        self.cancel_pending_enqueues = Some(cancel_pending_enqueues);
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> () {
        let rc = Rc::new(self);
        (
        )
    }

    pub fn build(handle: handle_Arg) -> Self {
        Self {
            handle,
            cancel_pending_enqueues: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(handle: handle_Arg) -> () {
        Self {
            handle,
            cancel_pending_enqueues: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<grads_Arg, boxes_Arg, box_ind_Arg, image_size_Arg, T> GraphOperation for CropAndResizeGradImage<grads_Arg, boxes_Arg, box_ind_Arg, image_size_Arg, T>
where grads_Arg: Clone,
      grads_Arg: GraphEdge<f32>,
      grads_Arg: 'static,
      boxes_Arg: Clone,
      boxes_Arg: GraphEdge<f32>,
      boxes_Arg: 'static,
      box_ind_Arg: Clone,
      box_ind_Arg: GraphEdge<i32>,
      box_ind_Arg: 'static,
      image_size_Arg: Clone,
      image_size_Arg: GraphEdge<i32>,
      image_size_Arg: 'static,
      T: TensorType,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_HALF,
      T: 'static,
      T: Clone,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("CropAndResizeGradImage_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("CropAndResizeGradImage", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.grads)?
        }
        {
            new_op.add_edge(&self.boxes)?
        }
        {
            new_op.add_edge(&self.box_ind)?
        }
        {
            new_op.add_edge(&self.image_size)?
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        {
            match self.method {
                None => new_op.set_attr_value_proto("method", &vec![18_u8, 8_u8, 98_u8, 105_u8, 108_u8, 105_u8, 110_u8, 101_u8, 97_u8, 114_u8,])?,
                Some(ref value) => (|attr| {new_op.set_attr_string("method", attr)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct CropAndResizeGradImage<grads_Arg, boxes_Arg, box_ind_Arg, image_size_Arg, T>
where grads_Arg: Clone,
      grads_Arg: GraphEdge<f32>,
      grads_Arg: 'static,
      boxes_Arg: Clone,
      boxes_Arg: GraphEdge<f32>,
      boxes_Arg: 'static,
      box_ind_Arg: Clone,
      box_ind_Arg: GraphEdge<i32>,
      box_ind_Arg: 'static,
      image_size_Arg: Clone,
      image_size_Arg: GraphEdge<i32>,
      image_size_Arg: 'static,
      T: TensorType,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_HALF,
      T: 'static,
      T: Clone,
{
    grads: grads_Arg,
    boxes: boxes_Arg,
    box_ind: box_ind_Arg,
    image_size: image_size_Arg,
    phantom_T: PhantomData<T>,
    method: Option<String>,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<grads_Arg, boxes_Arg, box_ind_Arg, image_size_Arg, T> CropAndResizeGradImage<grads_Arg, boxes_Arg, box_ind_Arg, image_size_Arg, T>
where grads_Arg: Clone,
      grads_Arg: GraphEdge<f32>,
      grads_Arg: 'static,
      boxes_Arg: Clone,
      boxes_Arg: GraphEdge<f32>,
      boxes_Arg: 'static,
      box_ind_Arg: Clone,
      box_ind_Arg: GraphEdge<i32>,
      box_ind_Arg: 'static,
      image_size_Arg: Clone,
      image_size_Arg: GraphEdge<i32>,
      image_size_Arg: 'static,
      T: TensorType,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_HALF,
      T: 'static,
      T: Clone,
{
    pub fn output(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn method(&mut self, method: &str) -> Self {
        self.method = Some(method.to_string());
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(grads: grads_Arg, boxes: boxes_Arg, box_ind: box_ind_Arg, image_size: image_size_Arg) -> Self {
        Self {
            grads,
            boxes,
            box_ind,
            image_size,
            phantom_T: PhantomData,
            method: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(grads: grads_Arg, boxes: boxes_Arg, box_ind: box_ind_Arg, image_size: image_size_Arg) -> Edge<T> {
        Self {
            grads,
            boxes,
            box_ind,
            image_size,
            phantom_T: PhantomData,
            method: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<T, data_Arg, Tindices, segment_ids_Arg> GraphOperation for SegmentSum<T, data_Arg, Tindices, segment_ids_Arg>
where T: TensorType,
      T: Clone,
      data_Arg: Clone,
      data_Arg: GraphEdge<T>,
      data_Arg: 'static,
      Tindices: TensorType,
      Tindices: Clone,
      segment_ids_Arg: Clone,
      segment_ids_Arg: GraphEdge<Tindices>,
      segment_ids_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
      Tindices: con_or_DT_INT32_or_DT_INT64,
      Tindices: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("SegmentSum_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("SegmentSum", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.data)?
        }
        {
            new_op.add_edge(&self.segment_ids)?
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        {
            new_op.set_attr_type("Tindices", Tindices::data_type())?;
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct SegmentSum<T, data_Arg, Tindices, segment_ids_Arg>
where T: TensorType,
      T: Clone,
      data_Arg: Clone,
      data_Arg: GraphEdge<T>,
      data_Arg: 'static,
      Tindices: TensorType,
      Tindices: Clone,
      segment_ids_Arg: Clone,
      segment_ids_Arg: GraphEdge<Tindices>,
      segment_ids_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
      Tindices: con_or_DT_INT32_or_DT_INT64,
      Tindices: 'static,
{
    phantom_T: PhantomData<T>,
    data: data_Arg,
    phantom_Tindices: PhantomData<Tindices>,
    segment_ids: segment_ids_Arg,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<T, data_Arg, Tindices, segment_ids_Arg> SegmentSum<T, data_Arg, Tindices, segment_ids_Arg>
where T: TensorType,
      T: Clone,
      data_Arg: Clone,
      data_Arg: GraphEdge<T>,
      data_Arg: 'static,
      Tindices: TensorType,
      Tindices: Clone,
      segment_ids_Arg: Clone,
      segment_ids_Arg: GraphEdge<Tindices>,
      segment_ids_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
      Tindices: con_or_DT_INT32_or_DT_INT64,
      Tindices: 'static,
{
    pub fn output(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(data: data_Arg, segment_ids: segment_ids_Arg) -> Self {
        Self {
            phantom_T: PhantomData,
            data,
            phantom_Tindices: PhantomData,
            segment_ids,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(data: data_Arg, segment_ids: segment_ids_Arg) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            data,
            phantom_Tindices: PhantomData,
            segment_ids,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<T, matrix_Arg, rhs_Arg> GraphOperation for BatchMatrixTriangularSolve<T, matrix_Arg, rhs_Arg>
where T: TensorType,
      T: Clone,
      matrix_Arg: Clone,
      matrix_Arg: GraphEdge<T>,
      matrix_Arg: 'static,
      rhs_Arg: Clone,
      rhs_Arg: GraphEdge<T>,
      rhs_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE,
      T: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("BatchMatrixTriangularSolve_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("BatchMatrixTriangularSolve", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.matrix)?
        }
        {
            new_op.add_edge(&self.rhs)?
        }
        {
            match self.lower {
                None => new_op.set_attr_value_proto("lower", &vec![40_u8, 1_u8,])?,
                Some(ref value) => (|attr: &bool| {new_op.set_attr_bool("lower", *attr)})(&value)?,
            };
        }
        {
            match self.adjoint {
                None => new_op.set_attr_value_proto("adjoint", &vec![40_u8, 0_u8,])?,
                Some(ref value) => (|attr: &bool| {new_op.set_attr_bool("adjoint", *attr)})(&value)?,
            };
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct BatchMatrixTriangularSolve<T, matrix_Arg, rhs_Arg>
where T: TensorType,
      T: Clone,
      matrix_Arg: Clone,
      matrix_Arg: GraphEdge<T>,
      matrix_Arg: 'static,
      rhs_Arg: Clone,
      rhs_Arg: GraphEdge<T>,
      rhs_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    matrix: matrix_Arg,
    rhs: rhs_Arg,
    lower: Option<bool>,
    adjoint: Option<bool>,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<T, matrix_Arg, rhs_Arg> BatchMatrixTriangularSolve<T, matrix_Arg, rhs_Arg>
where T: TensorType,
      T: Clone,
      matrix_Arg: Clone,
      matrix_Arg: GraphEdge<T>,
      matrix_Arg: 'static,
      rhs_Arg: Clone,
      rhs_Arg: GraphEdge<T>,
      rhs_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE,
      T: 'static,
{
    pub fn output(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn lower(&mut self, lower: bool) -> Self {
        self.lower = Some(lower);
        self.clone()
    }

    pub fn adjoint(&mut self, adjoint: bool) -> Self {
        self.adjoint = Some(adjoint);
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(matrix: matrix_Arg, rhs: rhs_Arg) -> Self {
        Self {
            phantom_T: PhantomData,
            matrix,
            rhs,
            lower: None,
            adjoint: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(matrix: matrix_Arg, rhs: rhs_Arg) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            matrix,
            rhs,
            lower: None,
            adjoint: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<input_Arg, size_Arg, offsets_Arg> GraphOperation for ExtractGlimpse<input_Arg, size_Arg, offsets_Arg>
where input_Arg: Clone,
      input_Arg: GraphEdge<f32>,
      input_Arg: 'static,
      size_Arg: Clone,
      size_Arg: GraphEdge<i32>,
      size_Arg: 'static,
      offsets_Arg: Clone,
      offsets_Arg: GraphEdge<f32>,
      offsets_Arg: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("ExtractGlimpse_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("ExtractGlimpse", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.input)?
        }
        {
            new_op.add_edge(&self.size)?
        }
        {
            new_op.add_edge(&self.offsets)?
        }
        {
            match self.centered {
                None => new_op.set_attr_value_proto("centered", &vec![40_u8, 1_u8,])?,
                Some(ref value) => (|attr: &bool| {new_op.set_attr_bool("centered", *attr)})(&value)?,
            };
        }
        {
            match self.normalized {
                None => new_op.set_attr_value_proto("normalized", &vec![40_u8, 1_u8,])?,
                Some(ref value) => (|attr: &bool| {new_op.set_attr_bool("normalized", *attr)})(&value)?,
            };
        }
        {
            match self.uniform_noise {
                None => new_op.set_attr_value_proto("uniform_noise", &vec![40_u8, 1_u8,])?,
                Some(ref value) => (|attr: &bool| {new_op.set_attr_bool("uniform_noise", *attr)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct ExtractGlimpse<input_Arg, size_Arg, offsets_Arg>
where input_Arg: Clone,
      input_Arg: GraphEdge<f32>,
      input_Arg: 'static,
      size_Arg: Clone,
      size_Arg: GraphEdge<i32>,
      size_Arg: 'static,
      offsets_Arg: Clone,
      offsets_Arg: GraphEdge<f32>,
      offsets_Arg: 'static,
{
    input: input_Arg,
    size: size_Arg,
    offsets: offsets_Arg,
    centered: Option<bool>,
    normalized: Option<bool>,
    uniform_noise: Option<bool>,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<input_Arg, size_Arg, offsets_Arg> ExtractGlimpse<input_Arg, size_Arg, offsets_Arg>
where input_Arg: Clone,
      input_Arg: GraphEdge<f32>,
      input_Arg: 'static,
      size_Arg: Clone,
      size_Arg: GraphEdge<i32>,
      size_Arg: 'static,
      offsets_Arg: Clone,
      offsets_Arg: GraphEdge<f32>,
      offsets_Arg: 'static,
{
    pub fn glimpse(self) -> Edge<f32> {
        let rc = Rc::new(self);
        {
            Edge::<f32>::new(rc.clone(), 0)
        }
    }

    pub fn centered(&mut self, centered: bool) -> Self {
        self.centered = Some(centered);
        self.clone()
    }

    pub fn normalized(&mut self, normalized: bool) -> Self {
        self.normalized = Some(normalized);
        self.clone()
    }

    pub fn uniform_noise(&mut self, uniform_noise: bool) -> Self {
        self.uniform_noise = Some(uniform_noise);
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<f32> {
        let rc = Rc::new(self);
        {
            Edge::<f32>::new(rc.clone(), 0)
        }
    }

    pub fn build(input: input_Arg, size: size_Arg, offsets: offsets_Arg) -> Self {
        Self {
            input,
            size,
            offsets,
            centered: None,
            normalized: None,
            uniform_noise: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(input: input_Arg, size: size_Arg, offsets: offsets_Arg) -> Edge<f32> {
        Self {
            input,
            size,
            offsets,
            centered: None,
            normalized: None,
            uniform_noise: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<T, lhs_Arg, rhs_Arg, Tindices, broadcast_dims_Arg> GraphOperation for XlaBroadcastHelper<T, lhs_Arg, rhs_Arg, Tindices, broadcast_dims_Arg>
where T: TensorType,
      T: Clone,
      lhs_Arg: Clone,
      lhs_Arg: GraphEdge<T>,
      lhs_Arg: 'static,
      rhs_Arg: Clone,
      rhs_Arg: GraphEdge<T>,
      rhs_Arg: 'static,
      Tindices: TensorType,
      Tindices: Clone,
      broadcast_dims_Arg: Clone,
      broadcast_dims_Arg: GraphEdge<Tindices>,
      broadcast_dims_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
      Tindices: con_or_DT_INT32_or_DT_INT64,
      Tindices: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("XlaBroadcastHelper_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("XlaBroadcastHelper", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.lhs)?
        }
        {
            new_op.add_edge(&self.rhs)?
        }
        {
            new_op.add_edge(&self.broadcast_dims)?
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        {
            new_op.set_attr_type("Tindices", Tindices::data_type())?;
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct XlaBroadcastHelper<T, lhs_Arg, rhs_Arg, Tindices, broadcast_dims_Arg>
where T: TensorType,
      T: Clone,
      lhs_Arg: Clone,
      lhs_Arg: GraphEdge<T>,
      lhs_Arg: 'static,
      rhs_Arg: Clone,
      rhs_Arg: GraphEdge<T>,
      rhs_Arg: 'static,
      Tindices: TensorType,
      Tindices: Clone,
      broadcast_dims_Arg: Clone,
      broadcast_dims_Arg: GraphEdge<Tindices>,
      broadcast_dims_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
      Tindices: con_or_DT_INT32_or_DT_INT64,
      Tindices: 'static,
{
    phantom_T: PhantomData<T>,
    lhs: lhs_Arg,
    rhs: rhs_Arg,
    phantom_Tindices: PhantomData<Tindices>,
    broadcast_dims: broadcast_dims_Arg,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<T, lhs_Arg, rhs_Arg, Tindices, broadcast_dims_Arg> XlaBroadcastHelper<T, lhs_Arg, rhs_Arg, Tindices, broadcast_dims_Arg>
where T: TensorType,
      T: Clone,
      lhs_Arg: Clone,
      lhs_Arg: GraphEdge<T>,
      lhs_Arg: 'static,
      rhs_Arg: Clone,
      rhs_Arg: GraphEdge<T>,
      rhs_Arg: 'static,
      Tindices: TensorType,
      Tindices: Clone,
      broadcast_dims_Arg: Clone,
      broadcast_dims_Arg: GraphEdge<Tindices>,
      broadcast_dims_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
      Tindices: con_or_DT_INT32_or_DT_INT64,
      Tindices: 'static,
{
    pub fn lhs_output(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn rhs_output(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 1)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> (Edge<T>, Edge<T>) {
        let rc = Rc::new(self);
        (
        {
            Edge::<T>::new(rc.clone(), 0)
        },
        {
            Edge::<T>::new(rc.clone(), 1)
        },
        )
    }

    pub fn build(lhs: lhs_Arg, rhs: rhs_Arg, broadcast_dims: broadcast_dims_Arg) -> Self {
        Self {
            phantom_T: PhantomData,
            lhs,
            rhs,
            phantom_Tindices: PhantomData,
            broadcast_dims,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(lhs: lhs_Arg, rhs: rhs_Arg, broadcast_dims: broadcast_dims_Arg) -> (Edge<T>, Edge<T>) {
        Self {
            phantom_T: PhantomData,
            lhs,
            rhs,
            phantom_Tindices: PhantomData,
            broadcast_dims,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<T, y_Arg, dy_Arg> GraphOperation for InvGrad<T, y_Arg, dy_Arg>
where T: TensorType,
      T: Clone,
      y_Arg: Clone,
      y_Arg: GraphEdge<T>,
      y_Arg: 'static,
      dy_Arg: Clone,
      dy_Arg: GraphEdge<T>,
      dy_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_COMPLEX64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF,
      T: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("InvGrad_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("InvGrad", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.y)?
        }
        {
            new_op.add_edge(&self.dy)?
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct InvGrad<T, y_Arg, dy_Arg>
where T: TensorType,
      T: Clone,
      y_Arg: Clone,
      y_Arg: GraphEdge<T>,
      y_Arg: 'static,
      dy_Arg: Clone,
      dy_Arg: GraphEdge<T>,
      dy_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_COMPLEX64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    y: y_Arg,
    dy: dy_Arg,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<T, y_Arg, dy_Arg> InvGrad<T, y_Arg, dy_Arg>
where T: TensorType,
      T: Clone,
      y_Arg: Clone,
      y_Arg: GraphEdge<T>,
      y_Arg: 'static,
      dy_Arg: Clone,
      dy_Arg: GraphEdge<T>,
      dy_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_COMPLEX64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF,
      T: 'static,
{
    pub fn z(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(y: y_Arg, dy: dy_Arg) -> Self {
        Self {
            phantom_T: PhantomData,
            y,
            dy,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(y: y_Arg, dy: dy_Arg) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            y,
            dy,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<component_types> GraphOperation for RandomShuffleQueue<component_types>
where component_types: TensorType,
      component_types: 'static,
      component_types: Clone,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("RandomShuffleQueue_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("RandomShuffleQueue", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.set_attr_type("component_types", component_types::data_type())?;
        }
        {
            match self.shapes {
                None => new_op.set_attr_value_proto("shapes", &vec![10_u8, 0_u8,])?,
                Some(ref value) => (|attrs| {new_op.set_attr_shape_list("shapes", attrs)})(&value)?,
            };
        }
        {
            match self.capacity {
                None => new_op.set_attr_value_proto("capacity", &vec![24_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 1_u8,])?,
                Some(ref value) => (|attr: &i64| {new_op.set_attr_int("capacity", *attr)})(&value)?,
            };
        }
        {
            match self.min_after_dequeue {
                None => new_op.set_attr_value_proto("min_after_dequeue", &vec![24_u8, 0_u8,])?,
                Some(ref value) => (|attr: &i64| {new_op.set_attr_int("min_after_dequeue", *attr)})(&value)?,
            };
        }
        {
            match self.seed {
                None => new_op.set_attr_value_proto("seed", &vec![24_u8, 0_u8,])?,
                Some(ref value) => (|attr: &i64| {new_op.set_attr_int("seed", *attr)})(&value)?,
            };
        }
        {
            match self.seed2 {
                None => new_op.set_attr_value_proto("seed2", &vec![24_u8, 0_u8,])?,
                Some(ref value) => (|attr: &i64| {new_op.set_attr_int("seed2", *attr)})(&value)?,
            };
        }
        {
            match self.container {
                None => new_op.set_attr_value_proto("container", &vec![18_u8, 0_u8,])?,
                Some(ref value) => (|attr| {new_op.set_attr_string("container", attr)})(&value)?,
            };
        }
        {
            match self.shared_name {
                None => new_op.set_attr_value_proto("shared_name", &vec![18_u8, 0_u8,])?,
                Some(ref value) => (|attr| {new_op.set_attr_string("shared_name", attr)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct RandomShuffleQueue<component_types>
where component_types: TensorType,
      component_types: 'static,
      component_types: Clone,
{
    phantom_component_types: PhantomData<component_types>,
    shapes: Option<Vec<OtherShape>>,
    capacity: Option<i64>,
    min_after_dequeue: Option<i64>,
    seed: Option<i64>,
    seed2: Option<i64>,
    container: Option<String>,
    shared_name: Option<String>,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<component_types> RandomShuffleQueue<component_types>
where component_types: TensorType,
      component_types: 'static,
      component_types: Clone,
{
    pub fn handle(self) -> RefEdge<String> {
        let rc = Rc::new(self);
        {
            RefEdge::<String>::new(rc.clone(), 0)
        }
    }

    pub fn shapes(&mut self, shapes: &[OtherShape]) -> Self {
        self.shapes = Some(shapes.to_vec());
        self.clone()
    }

    pub fn capacity(&mut self, capacity: i64) -> Self {
        self.capacity = Some(capacity);
        self.clone()
    }

    pub fn min_after_dequeue(&mut self, min_after_dequeue: i64) -> Self {
        self.min_after_dequeue = Some(min_after_dequeue);
        self.clone()
    }

    pub fn seed(&mut self, seed: i64) -> Self {
        self.seed = Some(seed);
        self.clone()
    }

    pub fn seed2(&mut self, seed2: i64) -> Self {
        self.seed2 = Some(seed2);
        self.clone()
    }

    pub fn container(&mut self, container: &str) -> Self {
        self.container = Some(container.to_string());
        self.clone()
    }

    pub fn shared_name(&mut self, shared_name: &str) -> Self {
        self.shared_name = Some(shared_name.to_string());
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> RefEdge<String> {
        let rc = Rc::new(self);
        {
            RefEdge::<String>::new(rc.clone(), 0)
        }
    }

    pub fn build() -> Self {
        Self {
            phantom_component_types: PhantomData,
            shapes: None,
            capacity: None,
            min_after_dequeue: None,
            seed: None,
            seed2: None,
            container: None,
            shared_name: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new() -> RefEdge<String> {
        Self {
            phantom_component_types: PhantomData,
            shapes: None,
            capacity: None,
            min_after_dequeue: None,
            seed: None,
            seed2: None,
            container: None,
            shared_name: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<parameters_Arg, accumulators_Arg, weights_Arg, benefits_Arg> GraphOperation for LoadTPUEmbeddingMDLAdagradLightParameters<parameters_Arg, accumulators_Arg, weights_Arg, benefits_Arg>
where parameters_Arg: Clone,
      parameters_Arg: GraphEdge<f32>,
      parameters_Arg: 'static,
      accumulators_Arg: Clone,
      accumulators_Arg: GraphEdge<f32>,
      accumulators_Arg: 'static,
      weights_Arg: Clone,
      weights_Arg: GraphEdge<f32>,
      weights_Arg: 'static,
      benefits_Arg: Clone,
      benefits_Arg: GraphEdge<f32>,
      benefits_Arg: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("LoadTPUEmbeddingMDLAdagradLightParameters_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("LoadTPUEmbeddingMDLAdagradLightParameters", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.parameters)?
        }
        {
            new_op.add_edge(&self.accumulators)?
        }
        {
            new_op.add_edge(&self.weights)?
        }
        {
            new_op.add_edge(&self.benefits)?
        }
        {
            match self.table_id {
                None => new_op.set_attr_value_proto("table_id", &vec![24_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 1_u8,])?,
                Some(ref value) => (|attr: &i64| {new_op.set_attr_int("table_id", *attr)})(&value)?,
            };
        }
        {
            match self.table_name {
                None => new_op.set_attr_value_proto("table_name", &vec![18_u8, 0_u8,])?,
                Some(ref value) => (|attr| {new_op.set_attr_string("table_name", attr)})(&value)?,
            };
        }
        {
            (|attr: &i64| {new_op.set_attr_int("num_shards", *attr)})(&self.num_shards)?
        }
        {
            (|attr: &i64| {new_op.set_attr_int("shard_id", *attr)})(&self.shard_id)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct LoadTPUEmbeddingMDLAdagradLightParameters<parameters_Arg, accumulators_Arg, weights_Arg, benefits_Arg>
where parameters_Arg: Clone,
      parameters_Arg: GraphEdge<f32>,
      parameters_Arg: 'static,
      accumulators_Arg: Clone,
      accumulators_Arg: GraphEdge<f32>,
      accumulators_Arg: 'static,
      weights_Arg: Clone,
      weights_Arg: GraphEdge<f32>,
      weights_Arg: 'static,
      benefits_Arg: Clone,
      benefits_Arg: GraphEdge<f32>,
      benefits_Arg: 'static,
{
    parameters: parameters_Arg,
    accumulators: accumulators_Arg,
    weights: weights_Arg,
    benefits: benefits_Arg,
    table_id: Option<i64>,
    table_name: Option<String>,
    num_shards: i64,
    shard_id: i64,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<parameters_Arg, accumulators_Arg, weights_Arg, benefits_Arg> LoadTPUEmbeddingMDLAdagradLightParameters<parameters_Arg, accumulators_Arg, weights_Arg, benefits_Arg>
where parameters_Arg: Clone,
      parameters_Arg: GraphEdge<f32>,
      parameters_Arg: 'static,
      accumulators_Arg: Clone,
      accumulators_Arg: GraphEdge<f32>,
      accumulators_Arg: 'static,
      weights_Arg: Clone,
      weights_Arg: GraphEdge<f32>,
      weights_Arg: 'static,
      benefits_Arg: Clone,
      benefits_Arg: GraphEdge<f32>,
      benefits_Arg: 'static,
{
    pub fn table_id(&mut self, table_id: i64) -> Self {
        self.table_id = Some(table_id);
        self.clone()
    }

    pub fn table_name(&mut self, table_name: &str) -> Self {
        self.table_name = Some(table_name.to_string());
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> () {
        let rc = Rc::new(self);
        (
        )
    }

    pub fn build(parameters: parameters_Arg, accumulators: accumulators_Arg, weights: weights_Arg, benefits: benefits_Arg, num_shards: i64, shard_id: i64) -> Self {
        Self {
            parameters,
            accumulators,
            weights,
            benefits,
            table_id: None,
            table_name: None,
            num_shards: num_shards,
            shard_id: shard_id,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(parameters: parameters_Arg, accumulators: accumulators_Arg, weights: weights_Arg, benefits: benefits_Arg, num_shards: i64, shard_id: i64) -> () {
        Self {
            parameters,
            accumulators,
            weights,
            benefits,
            table_id: None,
            table_name: None,
            num_shards: num_shards,
            shard_id: shard_id,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

pub trait con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT8_or_DT_HALF {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT8_or_DT_HALF for f32 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT8_or_DT_HALF for f64 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT8_or_DT_HALF for i32 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT8_or_DT_HALF for i8 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT8_or_DT_HALF for u8 {
}

impl<T, grads_Arg, size_Arg> GraphOperation for ResizeNearestNeighborGrad<T, grads_Arg, size_Arg>
where T: TensorType,
      T: Clone,
      grads_Arg: Clone,
      grads_Arg: GraphEdge<T>,
      grads_Arg: 'static,
      size_Arg: Clone,
      size_Arg: GraphEdge<i32>,
      size_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT8_or_DT_HALF,
      T: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("ResizeNearestNeighborGrad_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("ResizeNearestNeighborGrad", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.grads)?
        }
        {
            new_op.add_edge(&self.size)?
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        {
            match self.align_corners {
                None => new_op.set_attr_value_proto("align_corners", &vec![40_u8, 0_u8,])?,
                Some(ref value) => (|attr: &bool| {new_op.set_attr_bool("align_corners", *attr)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct ResizeNearestNeighborGrad<T, grads_Arg, size_Arg>
where T: TensorType,
      T: Clone,
      grads_Arg: Clone,
      grads_Arg: GraphEdge<T>,
      grads_Arg: 'static,
      size_Arg: Clone,
      size_Arg: GraphEdge<i32>,
      size_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT8_or_DT_HALF,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    grads: grads_Arg,
    size: size_Arg,
    align_corners: Option<bool>,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<T, grads_Arg, size_Arg> ResizeNearestNeighborGrad<T, grads_Arg, size_Arg>
where T: TensorType,
      T: Clone,
      grads_Arg: Clone,
      grads_Arg: GraphEdge<T>,
      grads_Arg: 'static,
      size_Arg: Clone,
      size_Arg: GraphEdge<i32>,
      size_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT8_or_DT_HALF,
      T: 'static,
{
    pub fn output(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn align_corners(&mut self, align_corners: bool) -> Self {
        self.align_corners = Some(align_corners);
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(grads: grads_Arg, size: size_Arg) -> Self {
        Self {
            phantom_T: PhantomData,
            grads,
            size,
            align_corners: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(grads: grads_Arg, size: size_Arg) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            grads,
            size,
            align_corners: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl GraphOperation for RetrieveTPUEmbeddingMomentumParametersGradAccumDebug {
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("RetrieveTPUEmbeddingMomentumParametersGradAccumDebug_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("RetrieveTPUEmbeddingMomentumParametersGradAccumDebug", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            match self.table_id {
                None => new_op.set_attr_value_proto("table_id", &vec![24_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 1_u8,])?,
                Some(ref value) => (|attr: &i64| {new_op.set_attr_int("table_id", *attr)})(&value)?,
            };
        }
        {
            match self.table_name {
                None => new_op.set_attr_value_proto("table_name", &vec![18_u8, 0_u8,])?,
                Some(ref value) => (|attr| {new_op.set_attr_string("table_name", attr)})(&value)?,
            };
        }
        {
            (|attr: &i64| {new_op.set_attr_int("num_shards", *attr)})(&self.num_shards)?
        }
        {
            (|attr: &i64| {new_op.set_attr_int("shard_id", *attr)})(&self.shard_id)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct RetrieveTPUEmbeddingMomentumParametersGradAccumDebug {
    table_id: Option<i64>,
    table_name: Option<String>,
    num_shards: i64,
    shard_id: i64,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl RetrieveTPUEmbeddingMomentumParametersGradAccumDebug {
    pub fn parameters(self) -> Edge<f32> {
        let rc = Rc::new(self);
        {
            Edge::<f32>::new(rc.clone(), 0)
        }
    }

    pub fn momenta(self) -> Edge<f32> {
        let rc = Rc::new(self);
        {
            Edge::<f32>::new(rc.clone(), 1)
        }
    }

    pub fn gradient_accumulators(self) -> Edge<f32> {
        let rc = Rc::new(self);
        {
            Edge::<f32>::new(rc.clone(), 2)
        }
    }

    pub fn table_id(&mut self, table_id: i64) -> Self {
        self.table_id = Some(table_id);
        self.clone()
    }

    pub fn table_name(&mut self, table_name: &str) -> Self {
        self.table_name = Some(table_name.to_string());
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> (Edge<f32>, Edge<f32>, Edge<f32>) {
        let rc = Rc::new(self);
        (
        {
            Edge::<f32>::new(rc.clone(), 0)
        },
        {
            Edge::<f32>::new(rc.clone(), 1)
        },
        {
            Edge::<f32>::new(rc.clone(), 2)
        },
        )
    }

    pub fn build(num_shards: i64, shard_id: i64) -> Self {
        Self {
            table_id: None,
            table_name: None,
            num_shards: num_shards,
            shard_id: shard_id,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(num_shards: i64, shard_id: i64) -> (Edge<f32>, Edge<f32>, Edge<f32>) {
        Self {
            table_id: None,
            table_name: None,
            num_shards: num_shards,
            shard_id: shard_id,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<T, x_Arg> GraphOperation for IsNan<T, x_Arg>
where T: TensorType,
      T: Clone,
      x_Arg: Clone,
      x_Arg: GraphEdge<T>,
      x_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
      T: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("IsNan_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("IsNan", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.x)?
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct IsNan<T, x_Arg>
where T: TensorType,
      T: Clone,
      x_Arg: Clone,
      x_Arg: GraphEdge<T>,
      x_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    x: x_Arg,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<T, x_Arg> IsNan<T, x_Arg>
where T: TensorType,
      T: Clone,
      x_Arg: Clone,
      x_Arg: GraphEdge<T>,
      x_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
      T: 'static,
{
    pub fn y(self) -> Edge<bool> {
        let rc = Rc::new(self);
        {
            Edge::<bool>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<bool> {
        let rc = Rc::new(self);
        {
            Edge::<bool>::new(rc.clone(), 0)
        }
    }

    pub fn build(x: x_Arg) -> Self {
        Self {
            phantom_T: PhantomData,
            x,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(x: x_Arg) -> Edge<bool> {
        Self {
            phantom_T: PhantomData,
            x,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<images_Arg, scale_Arg> GraphOperation for AdjustSaturation<images_Arg, scale_Arg>
where images_Arg: Clone,
      images_Arg: GraphEdge<f32>,
      images_Arg: 'static,
      scale_Arg: Clone,
      scale_Arg: GraphEdge<f32>,
      scale_Arg: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("AdjustSaturation_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("AdjustSaturation", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.images)?
        }
        {
            new_op.add_edge(&self.scale)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct AdjustSaturation<images_Arg, scale_Arg>
where images_Arg: Clone,
      images_Arg: GraphEdge<f32>,
      images_Arg: 'static,
      scale_Arg: Clone,
      scale_Arg: GraphEdge<f32>,
      scale_Arg: 'static,
{
    images: images_Arg,
    scale: scale_Arg,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<images_Arg, scale_Arg> AdjustSaturation<images_Arg, scale_Arg>
where images_Arg: Clone,
      images_Arg: GraphEdge<f32>,
      images_Arg: 'static,
      scale_Arg: Clone,
      scale_Arg: GraphEdge<f32>,
      scale_Arg: 'static,
{
    pub fn output(self) -> Edge<f32> {
        let rc = Rc::new(self);
        {
            Edge::<f32>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<f32> {
        let rc = Rc::new(self);
        {
            Edge::<f32>::new(rc.clone(), 0)
        }
    }

    pub fn build(images: images_Arg, scale: scale_Arg) -> Self {
        Self {
            images,
            scale,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(images: images_Arg, scale: scale_Arg) -> Edge<f32> {
        Self {
            images,
            scale,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<T, gradients_Arg, features_Arg> GraphOperation for SoftplusGrad<T, gradients_Arg, features_Arg>
where T: TensorType,
      T: Clone,
      gradients_Arg: Clone,
      gradients_Arg: GraphEdge<T>,
      gradients_Arg: 'static,
      features_Arg: Clone,
      features_Arg: GraphEdge<T>,
      features_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
      T: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("SoftplusGrad_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("SoftplusGrad", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.gradients)?
        }
        {
            new_op.add_edge(&self.features)?
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct SoftplusGrad<T, gradients_Arg, features_Arg>
where T: TensorType,
      T: Clone,
      gradients_Arg: Clone,
      gradients_Arg: GraphEdge<T>,
      gradients_Arg: 'static,
      features_Arg: Clone,
      features_Arg: GraphEdge<T>,
      features_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    gradients: gradients_Arg,
    features: features_Arg,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<T, gradients_Arg, features_Arg> SoftplusGrad<T, gradients_Arg, features_Arg>
where T: TensorType,
      T: Clone,
      gradients_Arg: Clone,
      gradients_Arg: GraphEdge<T>,
      gradients_Arg: 'static,
      features_Arg: Clone,
      features_Arg: GraphEdge<T>,
      features_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
      T: 'static,
{
    pub fn backprops(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(gradients: gradients_Arg, features: features_Arg) -> Self {
        Self {
            phantom_T: PhantomData,
            gradients,
            features,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(gradients: gradients_Arg, features: features_Arg) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            gradients,
            features,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<T, input_Arg> GraphOperation for SelfAdjointEigV2<T, input_Arg>
where T: TensorType,
      T: Clone,
      input_Arg: Clone,
      input_Arg: GraphEdge<T>,
      input_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_COMPLEX64_or_DT_COMPLEX128,
      T: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("SelfAdjointEigV2_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("SelfAdjointEigV2", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.input)?
        }
        {
            match self.compute_v {
                None => new_op.set_attr_value_proto("compute_v", &vec![40_u8, 1_u8,])?,
                Some(ref value) => (|attr: &bool| {new_op.set_attr_bool("compute_v", *attr)})(&value)?,
            };
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct SelfAdjointEigV2<T, input_Arg>
where T: TensorType,
      T: Clone,
      input_Arg: Clone,
      input_Arg: GraphEdge<T>,
      input_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_COMPLEX64_or_DT_COMPLEX128,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    input: input_Arg,
    compute_v: Option<bool>,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<T, input_Arg> SelfAdjointEigV2<T, input_Arg>
where T: TensorType,
      T: Clone,
      input_Arg: Clone,
      input_Arg: GraphEdge<T>,
      input_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_COMPLEX64_or_DT_COMPLEX128,
      T: 'static,
{
    pub fn e(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn v(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 1)
        }
    }

    pub fn compute_v(&mut self, compute_v: bool) -> Self {
        self.compute_v = Some(compute_v);
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> (Edge<T>, Edge<T>) {
        let rc = Rc::new(self);
        (
        {
            Edge::<T>::new(rc.clone(), 0)
        },
        {
            Edge::<T>::new(rc.clone(), 1)
        },
        )
    }

    pub fn build(input: input_Arg) -> Self {
        Self {
            phantom_T: PhantomData,
            input,
            compute_v: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(input: input_Arg) -> (Edge<T>, Edge<T>) {
        Self {
            phantom_T: PhantomData,
            input,
            compute_v: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<Tcomplex, input_Arg> GraphOperation for FFT<Tcomplex, input_Arg>
where Tcomplex: TensorType,
      Tcomplex: Clone,
      input_Arg: Clone,
      input_Arg: GraphEdge<Tcomplex>,
      input_Arg: 'static,
      Tcomplex: con_or_DT_COMPLEX64_or_DT_COMPLEX128,
      Tcomplex: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("FFT_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("FFT", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.input)?
        }
        {
            new_op.set_attr_type("Tcomplex", Tcomplex::data_type())?;
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct FFT<Tcomplex, input_Arg>
where Tcomplex: TensorType,
      Tcomplex: Clone,
      input_Arg: Clone,
      input_Arg: GraphEdge<Tcomplex>,
      input_Arg: 'static,
      Tcomplex: con_or_DT_COMPLEX64_or_DT_COMPLEX128,
      Tcomplex: 'static,
{
    phantom_Tcomplex: PhantomData<Tcomplex>,
    input: input_Arg,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<Tcomplex, input_Arg> FFT<Tcomplex, input_Arg>
where Tcomplex: TensorType,
      Tcomplex: Clone,
      input_Arg: Clone,
      input_Arg: GraphEdge<Tcomplex>,
      input_Arg: 'static,
      Tcomplex: con_or_DT_COMPLEX64_or_DT_COMPLEX128,
      Tcomplex: 'static,
{
    pub fn output(self) -> Edge<Tcomplex> {
        let rc = Rc::new(self);
        {
            Edge::<Tcomplex>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<Tcomplex> {
        let rc = Rc::new(self);
        {
            Edge::<Tcomplex>::new(rc.clone(), 0)
        }
    }

    pub fn build(input: input_Arg) -> Self {
        Self {
            phantom_Tcomplex: PhantomData,
            input,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(input: input_Arg) -> Edge<Tcomplex> {
        Self {
            phantom_Tcomplex: PhantomData,
            input,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<T, input_Arg, Tindex, num_lower_Arg, num_upper_Arg> GraphOperation for MatrixBandPart<T, input_Arg, Tindex, num_lower_Arg, num_upper_Arg>
where T: TensorType,
      T: Clone,
      input_Arg: Clone,
      input_Arg: GraphEdge<T>,
      input_Arg: 'static,
      Tindex: TensorType,
      Tindex: Clone,
      num_lower_Arg: Clone,
      num_lower_Arg: GraphEdge<Tindex>,
      num_lower_Arg: 'static,
      num_upper_Arg: Clone,
      num_upper_Arg: GraphEdge<Tindex>,
      num_upper_Arg: 'static,
      T: 'static,
      Tindex: con_or_DT_INT32_or_DT_INT64,
      Tindex: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("MatrixBandPart_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("MatrixBandPart", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.input)?
        }
        {
            new_op.add_edge(&self.num_lower)?
        }
        {
            new_op.add_edge(&self.num_upper)?
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        {
            new_op.set_attr_type("Tindex", Tindex::data_type())?;
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct MatrixBandPart<T, input_Arg, Tindex, num_lower_Arg, num_upper_Arg>
where T: TensorType,
      T: Clone,
      input_Arg: Clone,
      input_Arg: GraphEdge<T>,
      input_Arg: 'static,
      Tindex: TensorType,
      Tindex: Clone,
      num_lower_Arg: Clone,
      num_lower_Arg: GraphEdge<Tindex>,
      num_lower_Arg: 'static,
      num_upper_Arg: Clone,
      num_upper_Arg: GraphEdge<Tindex>,
      num_upper_Arg: 'static,
      T: 'static,
      Tindex: con_or_DT_INT32_or_DT_INT64,
      Tindex: 'static,
{
    phantom_T: PhantomData<T>,
    input: input_Arg,
    phantom_Tindex: PhantomData<Tindex>,
    num_lower: num_lower_Arg,
    num_upper: num_upper_Arg,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<T, input_Arg, Tindex, num_lower_Arg, num_upper_Arg> MatrixBandPart<T, input_Arg, Tindex, num_lower_Arg, num_upper_Arg>
where T: TensorType,
      T: Clone,
      input_Arg: Clone,
      input_Arg: GraphEdge<T>,
      input_Arg: 'static,
      Tindex: TensorType,
      Tindex: Clone,
      num_lower_Arg: Clone,
      num_lower_Arg: GraphEdge<Tindex>,
      num_lower_Arg: 'static,
      num_upper_Arg: Clone,
      num_upper_Arg: GraphEdge<Tindex>,
      num_upper_Arg: 'static,
      T: 'static,
      Tindex: con_or_DT_INT32_or_DT_INT64,
      Tindex: 'static,
{
    pub fn band(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(input: input_Arg, num_lower: num_lower_Arg, num_upper: num_upper_Arg) -> Self {
        Self {
            phantom_T: PhantomData,
            input,
            phantom_Tindex: PhantomData,
            num_lower,
            num_upper,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(input: input_Arg, num_lower: num_lower_Arg, num_upper: num_upper_Arg) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            input,
            phantom_Tindex: PhantomData,
            num_lower,
            num_upper,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<T, tensor_Arg, Tindices, indices_Arg, updates_Arg> GraphOperation for TensorScatterAdd<T, tensor_Arg, Tindices, indices_Arg, updates_Arg>
where T: TensorType,
      T: Clone,
      tensor_Arg: Clone,
      tensor_Arg: GraphEdge<T>,
      tensor_Arg: 'static,
      Tindices: TensorType,
      Tindices: Clone,
      indices_Arg: Clone,
      indices_Arg: GraphEdge<Tindices>,
      indices_Arg: 'static,
      updates_Arg: Clone,
      updates_Arg: GraphEdge<T>,
      updates_Arg: 'static,
      T: 'static,
      Tindices: con_or_DT_INT32_or_DT_INT64,
      Tindices: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("TensorScatterAdd_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("TensorScatterAdd", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.tensor)?
        }
        {
            new_op.add_edge(&self.indices)?
        }
        {
            new_op.add_edge(&self.updates)?
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        {
            new_op.set_attr_type("Tindices", Tindices::data_type())?;
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct TensorScatterAdd<T, tensor_Arg, Tindices, indices_Arg, updates_Arg>
where T: TensorType,
      T: Clone,
      tensor_Arg: Clone,
      tensor_Arg: GraphEdge<T>,
      tensor_Arg: 'static,
      Tindices: TensorType,
      Tindices: Clone,
      indices_Arg: Clone,
      indices_Arg: GraphEdge<Tindices>,
      indices_Arg: 'static,
      updates_Arg: Clone,
      updates_Arg: GraphEdge<T>,
      updates_Arg: 'static,
      T: 'static,
      Tindices: con_or_DT_INT32_or_DT_INT64,
      Tindices: 'static,
{
    phantom_T: PhantomData<T>,
    tensor: tensor_Arg,
    phantom_Tindices: PhantomData<Tindices>,
    indices: indices_Arg,
    updates: updates_Arg,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<T, tensor_Arg, Tindices, indices_Arg, updates_Arg> TensorScatterAdd<T, tensor_Arg, Tindices, indices_Arg, updates_Arg>
where T: TensorType,
      T: Clone,
      tensor_Arg: Clone,
      tensor_Arg: GraphEdge<T>,
      tensor_Arg: 'static,
      Tindices: TensorType,
      Tindices: Clone,
      indices_Arg: Clone,
      indices_Arg: GraphEdge<Tindices>,
      indices_Arg: 'static,
      updates_Arg: Clone,
      updates_Arg: GraphEdge<T>,
      updates_Arg: 'static,
      T: 'static,
      Tindices: con_or_DT_INT32_or_DT_INT64,
      Tindices: 'static,
{
    pub fn output(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(tensor: tensor_Arg, indices: indices_Arg, updates: updates_Arg) -> Self {
        Self {
            phantom_T: PhantomData,
            tensor,
            phantom_Tindices: PhantomData,
            indices,
            updates,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(tensor: tensor_Arg, indices: indices_Arg, updates: updates_Arg) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            tensor,
            phantom_Tindices: PhantomData,
            indices,
            updates,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<T, input_Arg> GraphOperation for LogMatrixDeterminant<T, input_Arg>
where T: TensorType,
      T: Clone,
      input_Arg: Clone,
      input_Arg: GraphEdge<T>,
      input_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_COMPLEX64_or_DT_COMPLEX128,
      T: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("LogMatrixDeterminant_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("LogMatrixDeterminant", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.input)?
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct LogMatrixDeterminant<T, input_Arg>
where T: TensorType,
      T: Clone,
      input_Arg: Clone,
      input_Arg: GraphEdge<T>,
      input_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_COMPLEX64_or_DT_COMPLEX128,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    input: input_Arg,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<T, input_Arg> LogMatrixDeterminant<T, input_Arg>
where T: TensorType,
      T: Clone,
      input_Arg: Clone,
      input_Arg: GraphEdge<T>,
      input_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_COMPLEX64_or_DT_COMPLEX128,
      T: 'static,
{
    pub fn sign(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn log_abs_determinant(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 1)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> (Edge<T>, Edge<T>) {
        let rc = Rc::new(self);
        (
        {
            Edge::<T>::new(rc.clone(), 0)
        },
        {
            Edge::<T>::new(rc.clone(), 1)
        },
        )
    }

    pub fn build(input: input_Arg) -> Self {
        Self {
            phantom_T: PhantomData,
            input,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(input: input_Arg) -> (Edge<T>, Edge<T>) {
        Self {
            phantom_T: PhantomData,
            input,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

pub trait con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF for BFloat16 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF for OtherComplex<f32> {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF for OtherComplex<f64> {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF for f32 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF for f64 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF for i16 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF for i32 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF for i64 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF for i8 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF for u8 {
}

impl<T, x_Arg, y_Arg> GraphOperation for AddV2<T, x_Arg, y_Arg>
where T: TensorType,
      T: Clone,
      x_Arg: Clone,
      x_Arg: GraphEdge<T>,
      x_Arg: 'static,
      y_Arg: Clone,
      y_Arg: GraphEdge<T>,
      y_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF,
      T: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("AddV2_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("AddV2", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.x)?
        }
        {
            new_op.add_edge(&self.y)?
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct AddV2<T, x_Arg, y_Arg>
where T: TensorType,
      T: Clone,
      x_Arg: Clone,
      x_Arg: GraphEdge<T>,
      x_Arg: 'static,
      y_Arg: Clone,
      y_Arg: GraphEdge<T>,
      y_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    x: x_Arg,
    y: y_Arg,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<T, x_Arg, y_Arg> AddV2<T, x_Arg, y_Arg>
where T: TensorType,
      T: Clone,
      x_Arg: Clone,
      x_Arg: GraphEdge<T>,
      x_Arg: 'static,
      y_Arg: Clone,
      y_Arg: GraphEdge<T>,
      y_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF,
      T: 'static,
{
    pub fn z(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(x: x_Arg, y: y_Arg) -> Self {
        Self {
            phantom_T: PhantomData,
            x,
            y,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(x: x_Arg, y: y_Arg) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            x,
            y,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<T, tensor_Arg> GraphOperation for TensorSummary<T, tensor_Arg>
where T: TensorType,
      T: Clone,
      tensor_Arg: Clone,
      tensor_Arg: GraphEdge<T>,
      tensor_Arg: 'static,
      T: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("TensorSummary_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("TensorSummary", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.tensor)?
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        {
            match self.description {
                None => new_op.set_attr_value_proto("description", &vec![18_u8, 0_u8,])?,
                Some(ref value) => (|attr| {new_op.set_attr_string("description", attr)})(&value)?,
            };
        }
        {
            match self.labels {
                None => new_op.set_attr_value_proto("labels", &vec![10_u8, 0_u8,])?,
                Some(ref value) => (|attrs| {new_op.set_attr_string_list("labels", attrs)})(&value)?,
            };
        }
        {
            match self.display_name {
                None => new_op.set_attr_value_proto("display_name", &vec![18_u8, 0_u8,])?,
                Some(ref value) => (|attr| {new_op.set_attr_string("display_name", attr)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct TensorSummary<T, tensor_Arg>
where T: TensorType,
      T: Clone,
      tensor_Arg: Clone,
      tensor_Arg: GraphEdge<T>,
      tensor_Arg: 'static,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    tensor: tensor_Arg,
    description: Option<String>,
    labels: Option<Vec<String>>,
    display_name: Option<String>,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<T, tensor_Arg> TensorSummary<T, tensor_Arg>
where T: TensorType,
      T: Clone,
      tensor_Arg: Clone,
      tensor_Arg: GraphEdge<T>,
      tensor_Arg: 'static,
      T: 'static,
{
    pub fn summary(self) -> Edge<String> {
        let rc = Rc::new(self);
        {
            Edge::<String>::new(rc.clone(), 0)
        }
    }

    pub fn description(&mut self, description: &str) -> Self {
        self.description = Some(description.to_string());
        self.clone()
    }

    pub fn labels(&mut self, labels: &[String]) -> Self {
        self.labels = Some(labels.to_vec());
        self.clone()
    }

    pub fn display_name(&mut self, display_name: &str) -> Self {
        self.display_name = Some(display_name.to_string());
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<String> {
        let rc = Rc::new(self);
        {
            Edge::<String>::new(rc.clone(), 0)
        }
    }

    pub fn build(tensor: tensor_Arg) -> Self {
        Self {
            phantom_T: PhantomData,
            tensor,
            description: None,
            labels: None,
            display_name: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(tensor: tensor_Arg) -> Edge<String> {
        Self {
            phantom_T: PhantomData,
            tensor,
            description: None,
            labels: None,
            display_name: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<T, shape_Arg, Tout, minval_Arg, maxval_Arg> GraphOperation for RandomUniformInt<T, shape_Arg, Tout, minval_Arg, maxval_Arg>
where T: TensorType,
      T: Clone,
      shape_Arg: Clone,
      shape_Arg: GraphEdge<T>,
      shape_Arg: 'static,
      Tout: TensorType,
      Tout: Clone,
      minval_Arg: Clone,
      minval_Arg: GraphEdge<Tout>,
      minval_Arg: 'static,
      maxval_Arg: Clone,
      maxval_Arg: GraphEdge<Tout>,
      maxval_Arg: 'static,
      Tout: con_or_DT_INT32_or_DT_INT64,
      Tout: 'static,
      T: con_or_DT_INT32_or_DT_INT64,
      T: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("RandomUniformInt_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("RandomUniformInt", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.shape)?
        }
        {
            new_op.add_edge(&self.minval)?
        }
        {
            new_op.add_edge(&self.maxval)?
        }
        {
            match self.seed {
                None => new_op.set_attr_value_proto("seed", &vec![24_u8, 0_u8,])?,
                Some(ref value) => (|attr: &i64| {new_op.set_attr_int("seed", *attr)})(&value)?,
            };
        }
        {
            match self.seed2 {
                None => new_op.set_attr_value_proto("seed2", &vec![24_u8, 0_u8,])?,
                Some(ref value) => (|attr: &i64| {new_op.set_attr_int("seed2", *attr)})(&value)?,
            };
        }
        {
            new_op.set_attr_type("Tout", Tout::data_type())?;
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct RandomUniformInt<T, shape_Arg, Tout, minval_Arg, maxval_Arg>
where T: TensorType,
      T: Clone,
      shape_Arg: Clone,
      shape_Arg: GraphEdge<T>,
      shape_Arg: 'static,
      Tout: TensorType,
      Tout: Clone,
      minval_Arg: Clone,
      minval_Arg: GraphEdge<Tout>,
      minval_Arg: 'static,
      maxval_Arg: Clone,
      maxval_Arg: GraphEdge<Tout>,
      maxval_Arg: 'static,
      Tout: con_or_DT_INT32_or_DT_INT64,
      Tout: 'static,
      T: con_or_DT_INT32_or_DT_INT64,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    shape: shape_Arg,
    phantom_Tout: PhantomData<Tout>,
    minval: minval_Arg,
    maxval: maxval_Arg,
    seed: Option<i64>,
    seed2: Option<i64>,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<T, shape_Arg, Tout, minval_Arg, maxval_Arg> RandomUniformInt<T, shape_Arg, Tout, minval_Arg, maxval_Arg>
where T: TensorType,
      T: Clone,
      shape_Arg: Clone,
      shape_Arg: GraphEdge<T>,
      shape_Arg: 'static,
      Tout: TensorType,
      Tout: Clone,
      minval_Arg: Clone,
      minval_Arg: GraphEdge<Tout>,
      minval_Arg: 'static,
      maxval_Arg: Clone,
      maxval_Arg: GraphEdge<Tout>,
      maxval_Arg: 'static,
      Tout: con_or_DT_INT32_or_DT_INT64,
      Tout: 'static,
      T: con_or_DT_INT32_or_DT_INT64,
      T: 'static,
{
    pub fn output(self) -> Edge<Tout> {
        let rc = Rc::new(self);
        {
            Edge::<Tout>::new(rc.clone(), 0)
        }
    }

    pub fn seed(&mut self, seed: i64) -> Self {
        self.seed = Some(seed);
        self.clone()
    }

    pub fn seed2(&mut self, seed2: i64) -> Self {
        self.seed2 = Some(seed2);
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<Tout> {
        let rc = Rc::new(self);
        {
            Edge::<Tout>::new(rc.clone(), 0)
        }
    }

    pub fn build(shape: shape_Arg, minval: minval_Arg, maxval: maxval_Arg) -> Self {
        Self {
            phantom_T: PhantomData,
            shape,
            phantom_Tout: PhantomData,
            minval,
            maxval,
            seed: None,
            seed2: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(shape: shape_Arg, minval: minval_Arg, maxval: maxval_Arg) -> Edge<Tout> {
        Self {
            phantom_T: PhantomData,
            shape,
            phantom_Tout: PhantomData,
            minval,
            maxval,
            seed: None,
            seed2: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<T, x_Arg> GraphOperation for DataFormatDimMap<T, x_Arg>
where T: TensorType,
      T: Clone,
      x_Arg: Clone,
      x_Arg: GraphEdge<T>,
      x_Arg: 'static,
      T: con_or_DT_INT32_or_DT_INT64,
      T: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("DataFormatDimMap_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("DataFormatDimMap", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.x)?
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        {
            match self.src_format {
                None => new_op.set_attr_value_proto("src_format", &vec![18_u8, 4_u8, 78_u8, 72_u8, 87_u8, 67_u8,])?,
                Some(ref value) => (|attr| {new_op.set_attr_string("src_format", attr)})(&value)?,
            };
        }
        {
            match self.dst_format {
                None => new_op.set_attr_value_proto("dst_format", &vec![18_u8, 4_u8, 78_u8, 67_u8, 72_u8, 87_u8,])?,
                Some(ref value) => (|attr| {new_op.set_attr_string("dst_format", attr)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct DataFormatDimMap<T, x_Arg>
where T: TensorType,
      T: Clone,
      x_Arg: Clone,
      x_Arg: GraphEdge<T>,
      x_Arg: 'static,
      T: con_or_DT_INT32_or_DT_INT64,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    x: x_Arg,
    src_format: Option<String>,
    dst_format: Option<String>,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<T, x_Arg> DataFormatDimMap<T, x_Arg>
where T: TensorType,
      T: Clone,
      x_Arg: Clone,
      x_Arg: GraphEdge<T>,
      x_Arg: 'static,
      T: con_or_DT_INT32_or_DT_INT64,
      T: 'static,
{
    pub fn y(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn src_format(&mut self, src_format: &str) -> Self {
        self.src_format = Some(src_format.to_string());
        self.clone()
    }

    pub fn dst_format(&mut self, dst_format: &str) -> Self {
        self.dst_format = Some(dst_format.to_string());
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(x: x_Arg) -> Self {
        Self {
            phantom_T: PhantomData,
            x,
            src_format: None,
            dst_format: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(x: x_Arg) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            x,
            src_format: None,
            dst_format: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<T, s0_Arg, s1_Arg> GraphOperation for BroadcastArgs<T, s0_Arg, s1_Arg>
where T: TensorType,
      T: Clone,
      s0_Arg: Clone,
      s0_Arg: GraphEdge<T>,
      s0_Arg: 'static,
      s1_Arg: Clone,
      s1_Arg: GraphEdge<T>,
      s1_Arg: 'static,
      T: con_or_DT_INT32_or_DT_INT64,
      T: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("BroadcastArgs_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("BroadcastArgs", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.s0)?
        }
        {
            new_op.add_edge(&self.s1)?
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct BroadcastArgs<T, s0_Arg, s1_Arg>
where T: TensorType,
      T: Clone,
      s0_Arg: Clone,
      s0_Arg: GraphEdge<T>,
      s0_Arg: 'static,
      s1_Arg: Clone,
      s1_Arg: GraphEdge<T>,
      s1_Arg: 'static,
      T: con_or_DT_INT32_or_DT_INT64,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    s0: s0_Arg,
    s1: s1_Arg,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<T, s0_Arg, s1_Arg> BroadcastArgs<T, s0_Arg, s1_Arg>
where T: TensorType,
      T: Clone,
      s0_Arg: Clone,
      s0_Arg: GraphEdge<T>,
      s0_Arg: 'static,
      s1_Arg: Clone,
      s1_Arg: GraphEdge<T>,
      s1_Arg: 'static,
      T: con_or_DT_INT32_or_DT_INT64,
      T: 'static,
{
    pub fn r0(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(s0: s0_Arg, s1: s1_Arg) -> Self {
        Self {
            phantom_T: PhantomData,
            s0,
            s1,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(s0: s0_Arg, s1: s1_Arg) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            s0,
            s1,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<T, x_Arg, Tidx, axis_Arg> GraphOperation for Cumsum<T, x_Arg, Tidx, axis_Arg>
where T: TensorType,
      T: Clone,
      x_Arg: Clone,
      x_Arg: GraphEdge<T>,
      x_Arg: 'static,
      Tidx: TensorType,
      Tidx: Clone,
      axis_Arg: Clone,
      axis_Arg: GraphEdge<Tidx>,
      axis_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
      Tidx: con_or_DT_INT32_or_DT_INT64,
      Tidx: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("Cumsum_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("Cumsum", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.x)?
        }
        {
            new_op.add_edge(&self.axis)?
        }
        {
            match self.exclusive {
                None => new_op.set_attr_value_proto("exclusive", &vec![40_u8, 0_u8,])?,
                Some(ref value) => (|attr: &bool| {new_op.set_attr_bool("exclusive", *attr)})(&value)?,
            };
        }
        {
            match self.reverse {
                None => new_op.set_attr_value_proto("reverse", &vec![40_u8, 0_u8,])?,
                Some(ref value) => (|attr: &bool| {new_op.set_attr_bool("reverse", *attr)})(&value)?,
            };
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        {
            new_op.set_attr_type("Tidx", Tidx::data_type())?;
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct Cumsum<T, x_Arg, Tidx, axis_Arg>
where T: TensorType,
      T: Clone,
      x_Arg: Clone,
      x_Arg: GraphEdge<T>,
      x_Arg: 'static,
      Tidx: TensorType,
      Tidx: Clone,
      axis_Arg: Clone,
      axis_Arg: GraphEdge<Tidx>,
      axis_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
      Tidx: con_or_DT_INT32_or_DT_INT64,
      Tidx: 'static,
{
    phantom_T: PhantomData<T>,
    x: x_Arg,
    phantom_Tidx: PhantomData<Tidx>,
    axis: axis_Arg,
    exclusive: Option<bool>,
    reverse: Option<bool>,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<T, x_Arg, Tidx, axis_Arg> Cumsum<T, x_Arg, Tidx, axis_Arg>
where T: TensorType,
      T: Clone,
      x_Arg: Clone,
      x_Arg: GraphEdge<T>,
      x_Arg: 'static,
      Tidx: TensorType,
      Tidx: Clone,
      axis_Arg: Clone,
      axis_Arg: GraphEdge<Tidx>,
      axis_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
      Tidx: con_or_DT_INT32_or_DT_INT64,
      Tidx: 'static,
{
    pub fn out(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn exclusive(&mut self, exclusive: bool) -> Self {
        self.exclusive = Some(exclusive);
        self.clone()
    }

    pub fn reverse(&mut self, reverse: bool) -> Self {
        self.reverse = Some(reverse);
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(x: x_Arg, axis: axis_Arg) -> Self {
        Self {
            phantom_T: PhantomData,
            x,
            phantom_Tidx: PhantomData,
            axis,
            exclusive: None,
            reverse: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(x: x_Arg, axis: axis_Arg) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            x,
            phantom_Tidx: PhantomData,
            axis,
            exclusive: None,
            reverse: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<sparse_example_indices_Arg, sparse_feature_indices_Arg, sparse_feature_values_Arg, dense_features_Arg, example_weights_Arg, example_labels_Arg, sparse_indices_Arg, sparse_weights_Arg, dense_weights_Arg, example_state_data_Arg> GraphOperation for SdcaOptimizer<sparse_example_indices_Arg, sparse_feature_indices_Arg, sparse_feature_values_Arg, dense_features_Arg, example_weights_Arg, example_labels_Arg, sparse_indices_Arg, sparse_weights_Arg, dense_weights_Arg, example_state_data_Arg>
where sparse_example_indices_Arg: Clone,
      sparse_example_indices_Arg: GraphEdge<i64>,
      sparse_example_indices_Arg: 'static,
      sparse_feature_indices_Arg: Clone,
      sparse_feature_indices_Arg: GraphEdge<i64>,
      sparse_feature_indices_Arg: 'static,
      sparse_feature_values_Arg: Clone,
      sparse_feature_values_Arg: GraphEdge<f32>,
      sparse_feature_values_Arg: 'static,
      dense_features_Arg: Clone,
      dense_features_Arg: GraphEdge<f32>,
      dense_features_Arg: 'static,
      example_weights_Arg: Clone,
      example_weights_Arg: GraphEdge<f32>,
      example_weights_Arg: 'static,
      example_labels_Arg: Clone,
      example_labels_Arg: GraphEdge<f32>,
      example_labels_Arg: 'static,
      sparse_indices_Arg: Clone,
      sparse_indices_Arg: GraphEdge<i64>,
      sparse_indices_Arg: 'static,
      sparse_weights_Arg: Clone,
      sparse_weights_Arg: GraphEdge<f32>,
      sparse_weights_Arg: 'static,
      dense_weights_Arg: Clone,
      dense_weights_Arg: GraphEdge<f32>,
      dense_weights_Arg: 'static,
      example_state_data_Arg: Clone,
      example_state_data_Arg: GraphEdge<f32>,
      example_state_data_Arg: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("SdcaOptimizer_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("SdcaOptimizer", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.sparse_example_indices)?
        }
        {
            new_op.add_edge(&self.sparse_feature_indices)?
        }
        {
            new_op.add_edge(&self.sparse_feature_values)?
        }
        {
            new_op.add_edge(&self.dense_features)?
        }
        {
            new_op.add_edge(&self.example_weights)?
        }
        {
            new_op.add_edge(&self.example_labels)?
        }
        {
            new_op.add_edge(&self.sparse_indices)?
        }
        {
            new_op.add_edge(&self.sparse_weights)?
        }
        {
            new_op.add_edge(&self.dense_weights)?
        }
        {
            new_op.add_edge(&self.example_state_data)?
        }
        {
            (|attr| {new_op.set_attr_string("loss_type", attr)})(&self.loss_type)?
        }
        {
            match self.adaptative {
                None => new_op.set_attr_value_proto("adaptative", &vec![40_u8, 0_u8,])?,
                Some(ref value) => (|attr: &bool| {new_op.set_attr_bool("adaptative", *attr)})(&value)?,
            };
        }
        {
            (|attr: &i64| {new_op.set_attr_int("num_sparse_features", *attr)})(&self.num_sparse_features)?
        }
        {
            (|attr: &i64| {new_op.set_attr_int("num_sparse_features_with_values", *attr)})(&self.num_sparse_features_with_values)?
        }
        {
            (|attr: &i64| {new_op.set_attr_int("num_dense_features", *attr)})(&self.num_dense_features)?
        }
        {
            (|attr: &f32| {new_op.set_attr_float("l1", *attr)})(&self.l1)?
        }
        {
            (|attr: &f32| {new_op.set_attr_float("l2", *attr)})(&self.l2)?
        }
        {
            (|attr: &i64| {new_op.set_attr_int("num_loss_partitions", *attr)})(&self.num_loss_partitions)?
        }
        {
            (|attr: &i64| {new_op.set_attr_int("num_inner_iterations", *attr)})(&self.num_inner_iterations)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct SdcaOptimizer<sparse_example_indices_Arg, sparse_feature_indices_Arg, sparse_feature_values_Arg, dense_features_Arg, example_weights_Arg, example_labels_Arg, sparse_indices_Arg, sparse_weights_Arg, dense_weights_Arg, example_state_data_Arg>
where sparse_example_indices_Arg: Clone,
      sparse_example_indices_Arg: GraphEdge<i64>,
      sparse_example_indices_Arg: 'static,
      sparse_feature_indices_Arg: Clone,
      sparse_feature_indices_Arg: GraphEdge<i64>,
      sparse_feature_indices_Arg: 'static,
      sparse_feature_values_Arg: Clone,
      sparse_feature_values_Arg: GraphEdge<f32>,
      sparse_feature_values_Arg: 'static,
      dense_features_Arg: Clone,
      dense_features_Arg: GraphEdge<f32>,
      dense_features_Arg: 'static,
      example_weights_Arg: Clone,
      example_weights_Arg: GraphEdge<f32>,
      example_weights_Arg: 'static,
      example_labels_Arg: Clone,
      example_labels_Arg: GraphEdge<f32>,
      example_labels_Arg: 'static,
      sparse_indices_Arg: Clone,
      sparse_indices_Arg: GraphEdge<i64>,
      sparse_indices_Arg: 'static,
      sparse_weights_Arg: Clone,
      sparse_weights_Arg: GraphEdge<f32>,
      sparse_weights_Arg: 'static,
      dense_weights_Arg: Clone,
      dense_weights_Arg: GraphEdge<f32>,
      dense_weights_Arg: 'static,
      example_state_data_Arg: Clone,
      example_state_data_Arg: GraphEdge<f32>,
      example_state_data_Arg: 'static,
{
    sparse_example_indices: sparse_example_indices_Arg,
    sparse_feature_indices: sparse_feature_indices_Arg,
    sparse_feature_values: sparse_feature_values_Arg,
    dense_features: dense_features_Arg,
    example_weights: example_weights_Arg,
    example_labels: example_labels_Arg,
    sparse_indices: sparse_indices_Arg,
    sparse_weights: sparse_weights_Arg,
    dense_weights: dense_weights_Arg,
    example_state_data: example_state_data_Arg,
    loss_type: String,
    adaptative: Option<bool>,
    num_sparse_features: i64,
    num_sparse_features_with_values: i64,
    num_dense_features: i64,
    l1: f32,
    l2: f32,
    num_loss_partitions: i64,
    num_inner_iterations: i64,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<sparse_example_indices_Arg, sparse_feature_indices_Arg, sparse_feature_values_Arg, dense_features_Arg, example_weights_Arg, example_labels_Arg, sparse_indices_Arg, sparse_weights_Arg, dense_weights_Arg, example_state_data_Arg> SdcaOptimizer<sparse_example_indices_Arg, sparse_feature_indices_Arg, sparse_feature_values_Arg, dense_features_Arg, example_weights_Arg, example_labels_Arg, sparse_indices_Arg, sparse_weights_Arg, dense_weights_Arg, example_state_data_Arg>
where sparse_example_indices_Arg: Clone,
      sparse_example_indices_Arg: GraphEdge<i64>,
      sparse_example_indices_Arg: 'static,
      sparse_feature_indices_Arg: Clone,
      sparse_feature_indices_Arg: GraphEdge<i64>,
      sparse_feature_indices_Arg: 'static,
      sparse_feature_values_Arg: Clone,
      sparse_feature_values_Arg: GraphEdge<f32>,
      sparse_feature_values_Arg: 'static,
      dense_features_Arg: Clone,
      dense_features_Arg: GraphEdge<f32>,
      dense_features_Arg: 'static,
      example_weights_Arg: Clone,
      example_weights_Arg: GraphEdge<f32>,
      example_weights_Arg: 'static,
      example_labels_Arg: Clone,
      example_labels_Arg: GraphEdge<f32>,
      example_labels_Arg: 'static,
      sparse_indices_Arg: Clone,
      sparse_indices_Arg: GraphEdge<i64>,
      sparse_indices_Arg: 'static,
      sparse_weights_Arg: Clone,
      sparse_weights_Arg: GraphEdge<f32>,
      sparse_weights_Arg: 'static,
      dense_weights_Arg: Clone,
      dense_weights_Arg: GraphEdge<f32>,
      dense_weights_Arg: 'static,
      example_state_data_Arg: Clone,
      example_state_data_Arg: GraphEdge<f32>,
      example_state_data_Arg: 'static,
{
    pub fn out_example_state_data(self) -> Edge<f32> {
        let rc = Rc::new(self);
        {
            Edge::<f32>::new(rc.clone(), 0)
        }
    }

    pub fn out_delta_sparse_weights(self) -> Edge<f32> {
        let rc = Rc::new(self);
        {
            Edge::<f32>::new(rc.clone(), 1)
        }
    }

    pub fn out_delta_dense_weights(self) -> Edge<f32> {
        let rc = Rc::new(self);
        {
            Edge::<f32>::new(rc.clone(), 2)
        }
    }

    pub fn adaptative(&mut self, adaptative: bool) -> Self {
        self.adaptative = Some(adaptative);
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> (Edge<f32>, Edge<f32>, Edge<f32>) {
        let rc = Rc::new(self);
        (
        {
            Edge::<f32>::new(rc.clone(), 0)
        },
        {
            Edge::<f32>::new(rc.clone(), 1)
        },
        {
            Edge::<f32>::new(rc.clone(), 2)
        },
        )
    }

    pub fn build(sparse_example_indices: sparse_example_indices_Arg, sparse_feature_indices: sparse_feature_indices_Arg, sparse_feature_values: sparse_feature_values_Arg, dense_features: dense_features_Arg, example_weights: example_weights_Arg, example_labels: example_labels_Arg, sparse_indices: sparse_indices_Arg, sparse_weights: sparse_weights_Arg, dense_weights: dense_weights_Arg, example_state_data: example_state_data_Arg, loss_type: &str, num_sparse_features: i64, num_sparse_features_with_values: i64, num_dense_features: i64, l1: f32, l2: f32, num_loss_partitions: i64, num_inner_iterations: i64) -> Self {
        Self {
            sparse_example_indices,
            sparse_feature_indices,
            sparse_feature_values,
            dense_features,
            example_weights,
            example_labels,
            sparse_indices,
            sparse_weights,
            dense_weights,
            example_state_data,
            loss_type: loss_type.to_string(),
            adaptative: None,
            num_sparse_features: num_sparse_features,
            num_sparse_features_with_values: num_sparse_features_with_values,
            num_dense_features: num_dense_features,
            l1: l1,
            l2: l2,
            num_loss_partitions: num_loss_partitions,
            num_inner_iterations: num_inner_iterations,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(sparse_example_indices: sparse_example_indices_Arg, sparse_feature_indices: sparse_feature_indices_Arg, sparse_feature_values: sparse_feature_values_Arg, dense_features: dense_features_Arg, example_weights: example_weights_Arg, example_labels: example_labels_Arg, sparse_indices: sparse_indices_Arg, sparse_weights: sparse_weights_Arg, dense_weights: dense_weights_Arg, example_state_data: example_state_data_Arg, loss_type: &str, num_sparse_features: i64, num_sparse_features_with_values: i64, num_dense_features: i64, l1: f32, l2: f32, num_loss_partitions: i64, num_inner_iterations: i64) -> (Edge<f32>, Edge<f32>, Edge<f32>) {
        Self {
            sparse_example_indices,
            sparse_feature_indices,
            sparse_feature_values,
            dense_features,
            example_weights,
            example_labels,
            sparse_indices,
            sparse_weights,
            dense_weights,
            example_state_data,
            loss_type: loss_type.to_string(),
            adaptative: None,
            num_sparse_features: num_sparse_features,
            num_sparse_features_with_values: num_sparse_features_with_values,
            num_dense_features: num_dense_features,
            l1: l1,
            l2: l2,
            num_loss_partitions: num_loss_partitions,
            num_inner_iterations: num_inner_iterations,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<T, ref__Arg, Tindices, indices_Arg, updates_Arg> GraphOperation for ScatterAdd<T, ref__Arg, Tindices, indices_Arg, updates_Arg>
where T: TensorType,
      T: Clone,
      ref__Arg: Clone,
      ref__Arg: GraphRefEdge<T>,
      ref__Arg: 'static,
      Tindices: TensorType,
      Tindices: Clone,
      indices_Arg: Clone,
      indices_Arg: GraphEdge<Tindices>,
      indices_Arg: 'static,
      updates_Arg: Clone,
      updates_Arg: GraphEdge<T>,
      updates_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
      Tindices: con_or_DT_INT32_or_DT_INT64,
      Tindices: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("ScatterAdd_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("ScatterAdd", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.ref_)?
        }
        {
            new_op.add_edge(&self.indices)?
        }
        {
            new_op.add_edge(&self.updates)?
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        {
            new_op.set_attr_type("Tindices", Tindices::data_type())?;
        }
        {
            match self.use_locking {
                None => new_op.set_attr_value_proto("use_locking", &vec![40_u8, 0_u8,])?,
                Some(ref value) => (|attr: &bool| {new_op.set_attr_bool("use_locking", *attr)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct ScatterAdd<T, ref__Arg, Tindices, indices_Arg, updates_Arg>
where T: TensorType,
      T: Clone,
      ref__Arg: Clone,
      ref__Arg: GraphRefEdge<T>,
      ref__Arg: 'static,
      Tindices: TensorType,
      Tindices: Clone,
      indices_Arg: Clone,
      indices_Arg: GraphEdge<Tindices>,
      indices_Arg: 'static,
      updates_Arg: Clone,
      updates_Arg: GraphEdge<T>,
      updates_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
      Tindices: con_or_DT_INT32_or_DT_INT64,
      Tindices: 'static,
{
    phantom_T: PhantomData<T>,
    ref_: ref__Arg,
    phantom_Tindices: PhantomData<Tindices>,
    indices: indices_Arg,
    updates: updates_Arg,
    use_locking: Option<bool>,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<T, ref__Arg, Tindices, indices_Arg, updates_Arg> ScatterAdd<T, ref__Arg, Tindices, indices_Arg, updates_Arg>
where T: TensorType,
      T: Clone,
      ref__Arg: Clone,
      ref__Arg: GraphRefEdge<T>,
      ref__Arg: 'static,
      Tindices: TensorType,
      Tindices: Clone,
      indices_Arg: Clone,
      indices_Arg: GraphEdge<Tindices>,
      indices_Arg: 'static,
      updates_Arg: Clone,
      updates_Arg: GraphEdge<T>,
      updates_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
      Tindices: con_or_DT_INT32_or_DT_INT64,
      Tindices: 'static,
{
    pub fn output_ref(self) -> RefEdge<T> {
        let rc = Rc::new(self);
        {
            RefEdge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn use_locking(&mut self, use_locking: bool) -> Self {
        self.use_locking = Some(use_locking);
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> RefEdge<T> {
        let rc = Rc::new(self);
        {
            RefEdge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(ref_: ref__Arg, indices: indices_Arg, updates: updates_Arg) -> Self {
        Self {
            phantom_T: PhantomData,
            ref_,
            phantom_Tindices: PhantomData,
            indices,
            updates,
            use_locking: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(ref_: ref__Arg, indices: indices_Arg, updates: updates_Arg) -> RefEdge<T> {
        Self {
            phantom_T: PhantomData,
            ref_,
            phantom_Tindices: PhantomData,
            indices,
            updates,
            use_locking: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl GraphOperation for TextLineReader {
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("TextLineReader_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("TextLineReader", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            match self.skip_header_lines {
                None => new_op.set_attr_value_proto("skip_header_lines", &vec![24_u8, 0_u8,])?,
                Some(ref value) => (|attr: &i64| {new_op.set_attr_int("skip_header_lines", *attr)})(&value)?,
            };
        }
        {
            match self.container {
                None => new_op.set_attr_value_proto("container", &vec![18_u8, 0_u8,])?,
                Some(ref value) => (|attr| {new_op.set_attr_string("container", attr)})(&value)?,
            };
        }
        {
            match self.shared_name {
                None => new_op.set_attr_value_proto("shared_name", &vec![18_u8, 0_u8,])?,
                Some(ref value) => (|attr| {new_op.set_attr_string("shared_name", attr)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct TextLineReader {
    skip_header_lines: Option<i64>,
    container: Option<String>,
    shared_name: Option<String>,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl TextLineReader {
    pub fn reader_handle(self) -> RefEdge<String> {
        let rc = Rc::new(self);
        {
            RefEdge::<String>::new(rc.clone(), 0)
        }
    }

    pub fn skip_header_lines(&mut self, skip_header_lines: i64) -> Self {
        self.skip_header_lines = Some(skip_header_lines);
        self.clone()
    }

    pub fn container(&mut self, container: &str) -> Self {
        self.container = Some(container.to_string());
        self.clone()
    }

    pub fn shared_name(&mut self, shared_name: &str) -> Self {
        self.shared_name = Some(shared_name.to_string());
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> RefEdge<String> {
        let rc = Rc::new(self);
        {
            RefEdge::<String>::new(rc.clone(), 0)
        }
    }

    pub fn build() -> Self {
        Self {
            skip_header_lines: None,
            container: None,
            shared_name: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new() -> RefEdge<String> {
        Self {
            skip_header_lines: None,
            container: None,
            shared_name: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<T, x_Arg> GraphOperation for Sign<T, x_Arg>
where T: TensorType,
      T: Clone,
      x_Arg: Clone,
      x_Arg: GraphEdge<T>,
      x_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_COMPLEX64_or_DT_INT64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF,
      T: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("Sign_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("Sign", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.x)?
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct Sign<T, x_Arg>
where T: TensorType,
      T: Clone,
      x_Arg: Clone,
      x_Arg: GraphEdge<T>,
      x_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_COMPLEX64_or_DT_INT64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    x: x_Arg,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<T, x_Arg> Sign<T, x_Arg>
where T: TensorType,
      T: Clone,
      x_Arg: Clone,
      x_Arg: GraphEdge<T>,
      x_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_COMPLEX64_or_DT_INT64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF,
      T: 'static,
{
    pub fn y(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(x: x_Arg) -> Self {
        Self {
            phantom_T: PhantomData,
            x,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(x: x_Arg) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            x,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<T, input_Arg, Tidx, crops_Arg> GraphOperation for BatchToSpace<T, input_Arg, Tidx, crops_Arg>
where T: TensorType,
      T: Clone,
      input_Arg: Clone,
      input_Arg: GraphEdge<T>,
      input_Arg: 'static,
      Tidx: TensorType,
      Tidx: Clone,
      crops_Arg: Clone,
      crops_Arg: GraphEdge<Tidx>,
      crops_Arg: 'static,
      T: 'static,
      Tidx: con_or_DT_INT32_or_DT_INT64,
      Tidx: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("BatchToSpace_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("BatchToSpace", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.input)?
        }
        {
            new_op.add_edge(&self.crops)?
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        {
            (|attr: &i64| {new_op.set_attr_int("block_size", *attr)})(&self.block_size)?
        }
        {
            new_op.set_attr_type("Tidx", Tidx::data_type())?;
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct BatchToSpace<T, input_Arg, Tidx, crops_Arg>
where T: TensorType,
      T: Clone,
      input_Arg: Clone,
      input_Arg: GraphEdge<T>,
      input_Arg: 'static,
      Tidx: TensorType,
      Tidx: Clone,
      crops_Arg: Clone,
      crops_Arg: GraphEdge<Tidx>,
      crops_Arg: 'static,
      T: 'static,
      Tidx: con_or_DT_INT32_or_DT_INT64,
      Tidx: 'static,
{
    phantom_T: PhantomData<T>,
    input: input_Arg,
    phantom_Tidx: PhantomData<Tidx>,
    crops: crops_Arg,
    block_size: i64,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<T, input_Arg, Tidx, crops_Arg> BatchToSpace<T, input_Arg, Tidx, crops_Arg>
where T: TensorType,
      T: Clone,
      input_Arg: Clone,
      input_Arg: GraphEdge<T>,
      input_Arg: 'static,
      Tidx: TensorType,
      Tidx: Clone,
      crops_Arg: Clone,
      crops_Arg: GraphEdge<Tidx>,
      crops_Arg: 'static,
      T: 'static,
      Tidx: con_or_DT_INT32_or_DT_INT64,
      Tidx: 'static,
{
    pub fn output(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(input: input_Arg, crops: crops_Arg, block_size: i64) -> Self {
        Self {
            phantom_T: PhantomData,
            input,
            phantom_Tidx: PhantomData,
            crops,
            block_size: block_size,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(input: input_Arg, crops: crops_Arg, block_size: i64) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            input,
            phantom_Tidx: PhantomData,
            crops,
            block_size: block_size,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<T, matrix_Arg, rhs_Arg> GraphOperation for MatrixSolve<T, matrix_Arg, rhs_Arg>
where T: TensorType,
      T: Clone,
      matrix_Arg: Clone,
      matrix_Arg: GraphEdge<T>,
      matrix_Arg: 'static,
      rhs_Arg: Clone,
      rhs_Arg: GraphEdge<T>,
      rhs_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_COMPLEX64_or_DT_COMPLEX128,
      T: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("MatrixSolve_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("MatrixSolve", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.matrix)?
        }
        {
            new_op.add_edge(&self.rhs)?
        }
        {
            match self.adjoint {
                None => new_op.set_attr_value_proto("adjoint", &vec![40_u8, 0_u8,])?,
                Some(ref value) => (|attr: &bool| {new_op.set_attr_bool("adjoint", *attr)})(&value)?,
            };
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct MatrixSolve<T, matrix_Arg, rhs_Arg>
where T: TensorType,
      T: Clone,
      matrix_Arg: Clone,
      matrix_Arg: GraphEdge<T>,
      matrix_Arg: 'static,
      rhs_Arg: Clone,
      rhs_Arg: GraphEdge<T>,
      rhs_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_COMPLEX64_or_DT_COMPLEX128,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    matrix: matrix_Arg,
    rhs: rhs_Arg,
    adjoint: Option<bool>,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<T, matrix_Arg, rhs_Arg> MatrixSolve<T, matrix_Arg, rhs_Arg>
where T: TensorType,
      T: Clone,
      matrix_Arg: Clone,
      matrix_Arg: GraphEdge<T>,
      matrix_Arg: 'static,
      rhs_Arg: Clone,
      rhs_Arg: GraphEdge<T>,
      rhs_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_COMPLEX64_or_DT_COMPLEX128,
      T: 'static,
{
    pub fn output(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn adjoint(&mut self, adjoint: bool) -> Self {
        self.adjoint = Some(adjoint);
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(matrix: matrix_Arg, rhs: rhs_Arg) -> Self {
        Self {
            phantom_T: PhantomData,
            matrix,
            rhs,
            adjoint: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(matrix: matrix_Arg, rhs: rhs_Arg) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            matrix,
            rhs,
            adjoint: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<dtype> GraphOperation for VariableV2<dtype>
where dtype: TensorType,
      dtype: 'static,
      dtype: Clone,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("VariableV2_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("VariableV2", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            (|attr| {new_op.set_attr_shape("shape", attr)})(&self.shape)?
        }
        {
            new_op.set_attr_type("dtype", dtype::data_type())?;
        }
        {
            match self.container {
                None => new_op.set_attr_value_proto("container", &vec![18_u8, 0_u8,])?,
                Some(ref value) => (|attr| {new_op.set_attr_string("container", attr)})(&value)?,
            };
        }
        {
            match self.shared_name {
                None => new_op.set_attr_value_proto("shared_name", &vec![18_u8, 0_u8,])?,
                Some(ref value) => (|attr| {new_op.set_attr_string("shared_name", attr)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct VariableV2<dtype>
where dtype: TensorType,
      dtype: 'static,
      dtype: Clone,
{
    shape: OtherShape,
    phantom_dtype: PhantomData<dtype>,
    container: Option<String>,
    shared_name: Option<String>,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<dtype> VariableV2<dtype>
where dtype: TensorType,
      dtype: 'static,
      dtype: Clone,
{
    pub fn ref_(self) -> RefEdge<dtype> {
        let rc = Rc::new(self);
        {
            RefEdge::<dtype>::new(rc.clone(), 0)
        }
    }

    pub fn container(&mut self, container: &str) -> Self {
        self.container = Some(container.to_string());
        self.clone()
    }

    pub fn shared_name(&mut self, shared_name: &str) -> Self {
        self.shared_name = Some(shared_name.to_string());
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> RefEdge<dtype> {
        let rc = Rc::new(self);
        {
            RefEdge::<dtype>::new(rc.clone(), 0)
        }
    }

    pub fn build(shape: &OtherShape) -> Self {
        Self {
            shape: shape.clone(),
            phantom_dtype: PhantomData,
            container: None,
            shared_name: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(shape: &OtherShape) -> RefEdge<dtype> {
        Self {
            shape: shape.clone(),
            phantom_dtype: PhantomData,
            container: None,
            shared_name: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<T, input_Arg, Tidx, reduction_indices_Arg> GraphOperation for Max<T, input_Arg, Tidx, reduction_indices_Arg>
where T: TensorType,
      T: Clone,
      input_Arg: Clone,
      input_Arg: GraphEdge<T>,
      input_Arg: 'static,
      Tidx: TensorType,
      Tidx: Clone,
      reduction_indices_Arg: Clone,
      reduction_indices_Arg: GraphEdge<Tidx>,
      reduction_indices_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
      Tidx: con_or_DT_INT32_or_DT_INT64,
      Tidx: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("Max_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("Max", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.input)?
        }
        {
            new_op.add_edge(&self.reduction_indices)?
        }
        {
            match self.keep_dims {
                None => new_op.set_attr_value_proto("keep_dims", &vec![40_u8, 0_u8,])?,
                Some(ref value) => (|attr: &bool| {new_op.set_attr_bool("keep_dims", *attr)})(&value)?,
            };
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        {
            new_op.set_attr_type("Tidx", Tidx::data_type())?;
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct Max<T, input_Arg, Tidx, reduction_indices_Arg>
where T: TensorType,
      T: Clone,
      input_Arg: Clone,
      input_Arg: GraphEdge<T>,
      input_Arg: 'static,
      Tidx: TensorType,
      Tidx: Clone,
      reduction_indices_Arg: Clone,
      reduction_indices_Arg: GraphEdge<Tidx>,
      reduction_indices_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
      Tidx: con_or_DT_INT32_or_DT_INT64,
      Tidx: 'static,
{
    phantom_T: PhantomData<T>,
    input: input_Arg,
    phantom_Tidx: PhantomData<Tidx>,
    reduction_indices: reduction_indices_Arg,
    keep_dims: Option<bool>,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<T, input_Arg, Tidx, reduction_indices_Arg> Max<T, input_Arg, Tidx, reduction_indices_Arg>
where T: TensorType,
      T: Clone,
      input_Arg: Clone,
      input_Arg: GraphEdge<T>,
      input_Arg: 'static,
      Tidx: TensorType,
      Tidx: Clone,
      reduction_indices_Arg: Clone,
      reduction_indices_Arg: GraphEdge<Tidx>,
      reduction_indices_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
      Tidx: con_or_DT_INT32_or_DT_INT64,
      Tidx: 'static,
{
    pub fn output(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn keep_dims(&mut self, keep_dims: bool) -> Self {
        self.keep_dims = Some(keep_dims);
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(input: input_Arg, reduction_indices: reduction_indices_Arg) -> Self {
        Self {
            phantom_T: PhantomData,
            input,
            phantom_Tidx: PhantomData,
            reduction_indices,
            keep_dims: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(input: input_Arg, reduction_indices: reduction_indices_Arg) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            input,
            phantom_Tidx: PhantomData,
            reduction_indices,
            keep_dims: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<input_Arg, sep_Arg> GraphOperation for StringSplitV2<input_Arg, sep_Arg>
where input_Arg: Clone,
      input_Arg: GraphEdge<String>,
      input_Arg: 'static,
      sep_Arg: Clone,
      sep_Arg: GraphEdge<String>,
      sep_Arg: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("StringSplitV2_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("StringSplitV2", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.input)?
        }
        {
            new_op.add_edge(&self.sep)?
        }
        {
            match self.maxsplit {
                None => new_op.set_attr_value_proto("maxsplit", &vec![24_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 1_u8,])?,
                Some(ref value) => (|attr: &i64| {new_op.set_attr_int("maxsplit", *attr)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct StringSplitV2<input_Arg, sep_Arg>
where input_Arg: Clone,
      input_Arg: GraphEdge<String>,
      input_Arg: 'static,
      sep_Arg: Clone,
      sep_Arg: GraphEdge<String>,
      sep_Arg: 'static,
{
    input: input_Arg,
    sep: sep_Arg,
    maxsplit: Option<i64>,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<input_Arg, sep_Arg> StringSplitV2<input_Arg, sep_Arg>
where input_Arg: Clone,
      input_Arg: GraphEdge<String>,
      input_Arg: 'static,
      sep_Arg: Clone,
      sep_Arg: GraphEdge<String>,
      sep_Arg: 'static,
{
    pub fn indices(self) -> Edge<i64> {
        let rc = Rc::new(self);
        {
            Edge::<i64>::new(rc.clone(), 0)
        }
    }

    pub fn values(self) -> Edge<String> {
        let rc = Rc::new(self);
        {
            Edge::<String>::new(rc.clone(), 1)
        }
    }

    pub fn shape(self) -> Edge<i64> {
        let rc = Rc::new(self);
        {
            Edge::<i64>::new(rc.clone(), 2)
        }
    }

    pub fn maxsplit(&mut self, maxsplit: i64) -> Self {
        self.maxsplit = Some(maxsplit);
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> (Edge<i64>, Edge<String>, Edge<i64>) {
        let rc = Rc::new(self);
        (
        {
            Edge::<i64>::new(rc.clone(), 0)
        },
        {
            Edge::<String>::new(rc.clone(), 1)
        },
        {
            Edge::<i64>::new(rc.clone(), 2)
        },
        )
    }

    pub fn build(input: input_Arg, sep: sep_Arg) -> Self {
        Self {
            input,
            sep,
            maxsplit: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(input: input_Arg, sep: sep_Arg) -> (Edge<i64>, Edge<String>, Edge<i64>) {
        Self {
            input,
            sep,
            maxsplit: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<T> GraphOperation for _ScopedAllocator<T>
where T: TensorType,
      T: 'static,
      T: Clone,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("_ScopedAllocator_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("_ScopedAllocator", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            (|attrs| {new_op.set_attr_shape_list("shapes", attrs)})(&self.shapes)?
        }
        {
            (|attr| {new_op.set_attr_shape("shape", attr)})(&self.shape)?
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        {
            (|attr| {new_op.set_attr_string("sa_name", attr)})(&self.sa_name)?
        }
        {
            (|attr: &i64| {new_op.set_attr_int("id", *attr)})(&self.id)?
        }
        {
            (|attr: &i64| {new_op.set_attr_int("expected_call_count", *attr)})(&self.expected_call_count)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct _ScopedAllocator<T>
where T: TensorType,
      T: 'static,
      T: Clone,
{
    shapes: Vec<OtherShape>,
    shape: OtherShape,
    phantom_T: PhantomData<T>,
    sa_name: String,
    id: i64,
    expected_call_count: i64,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<T> _ScopedAllocator<T>
where T: TensorType,
      T: 'static,
      T: Clone,
{
    pub fn output(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(shapes: &[OtherShape], shape: &OtherShape, sa_name: &str, id: i64, expected_call_count: i64) -> Self {
        Self {
            shapes: shapes.to_vec(),
            shape: shape.clone(),
            phantom_T: PhantomData,
            sa_name: sa_name.to_string(),
            id: id,
            expected_call_count: expected_call_count,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(shapes: &[OtherShape], shape: &OtherShape, sa_name: &str, id: i64, expected_call_count: i64) -> Edge<T> {
        Self {
            shapes: shapes.to_vec(),
            shape: shape.clone(),
            phantom_T: PhantomData,
            sa_name: sa_name.to_string(),
            id: id,
            expected_call_count: expected_call_count,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<T, input_Arg> GraphOperation for MatrixLogarithm<T, input_Arg>
where T: TensorType,
      T: Clone,
      input_Arg: Clone,
      input_Arg: GraphEdge<T>,
      input_Arg: 'static,
      T: con_or_DT_COMPLEX64_or_DT_COMPLEX128,
      T: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("MatrixLogarithm_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("MatrixLogarithm", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.input)?
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct MatrixLogarithm<T, input_Arg>
where T: TensorType,
      T: Clone,
      input_Arg: Clone,
      input_Arg: GraphEdge<T>,
      input_Arg: 'static,
      T: con_or_DT_COMPLEX64_or_DT_COMPLEX128,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    input: input_Arg,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<T, input_Arg> MatrixLogarithm<T, input_Arg>
where T: TensorType,
      T: Clone,
      input_Arg: Clone,
      input_Arg: GraphEdge<T>,
      input_Arg: 'static,
      T: con_or_DT_COMPLEX64_or_DT_COMPLEX128,
      T: 'static,
{
    pub fn output(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(input: input_Arg) -> Self {
        Self {
            phantom_T: PhantomData,
            input,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(input: input_Arg) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            input,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<dtype> GraphOperation for FakeParam<dtype>
where dtype: TensorType,
      dtype: 'static,
      dtype: Clone,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("FakeParam_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("FakeParam", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.set_attr_type("dtype", dtype::data_type())?;
        }
        {
            (|attr| {new_op.set_attr_shape("shape", attr)})(&self.shape)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct FakeParam<dtype>
where dtype: TensorType,
      dtype: 'static,
      dtype: Clone,
{
    phantom_dtype: PhantomData<dtype>,
    shape: OtherShape,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<dtype> FakeParam<dtype>
where dtype: TensorType,
      dtype: 'static,
      dtype: Clone,
{
    pub fn output(self) -> Edge<dtype> {
        let rc = Rc::new(self);
        {
            Edge::<dtype>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<dtype> {
        let rc = Rc::new(self);
        {
            Edge::<dtype>::new(rc.clone(), 0)
        }
    }

    pub fn build(shape: &OtherShape) -> Self {
        Self {
            phantom_dtype: PhantomData,
            shape: shape.clone(),
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(shape: &OtherShape) -> Edge<dtype> {
        Self {
            phantom_dtype: PhantomData,
            shape: shape.clone(),
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<T, lhs_Arg, rhs_Arg> GraphOperation for XlaDot<T, lhs_Arg, rhs_Arg>
where T: TensorType,
      T: Clone,
      lhs_Arg: Clone,
      lhs_Arg: GraphEdge<T>,
      lhs_Arg: 'static,
      rhs_Arg: Clone,
      rhs_Arg: GraphEdge<T>,
      rhs_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("XlaDot_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("XlaDot", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.lhs)?
        }
        {
            new_op.add_edge(&self.rhs)?
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        {
            (|attr| {new_op.set_attr_string("dimension_numbers", attr)})(&self.dimension_numbers)?
        }
        {
            (|attr| {new_op.set_attr_string("precision_config", attr)})(&self.precision_config)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct XlaDot<T, lhs_Arg, rhs_Arg>
where T: TensorType,
      T: Clone,
      lhs_Arg: Clone,
      lhs_Arg: GraphEdge<T>,
      lhs_Arg: 'static,
      rhs_Arg: Clone,
      rhs_Arg: GraphEdge<T>,
      rhs_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    lhs: lhs_Arg,
    rhs: rhs_Arg,
    dimension_numbers: String,
    precision_config: String,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<T, lhs_Arg, rhs_Arg> XlaDot<T, lhs_Arg, rhs_Arg>
where T: TensorType,
      T: Clone,
      lhs_Arg: Clone,
      lhs_Arg: GraphEdge<T>,
      lhs_Arg: 'static,
      rhs_Arg: Clone,
      rhs_Arg: GraphEdge<T>,
      rhs_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
{
    pub fn output(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(lhs: lhs_Arg, rhs: rhs_Arg, dimension_numbers: &str, precision_config: &str) -> Self {
        Self {
            phantom_T: PhantomData,
            lhs,
            rhs,
            dimension_numbers: dimension_numbers.to_string(),
            precision_config: precision_config.to_string(),
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(lhs: lhs_Arg, rhs: rhs_Arg, dimension_numbers: &str, precision_config: &str) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            lhs,
            rhs,
            dimension_numbers: dimension_numbers.to_string(),
            precision_config: precision_config.to_string(),
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<T, features_Arg> GraphOperation for Softsign<T, features_Arg>
where T: TensorType,
      T: Clone,
      features_Arg: Clone,
      features_Arg: GraphEdge<T>,
      features_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
      T: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("Softsign_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("Softsign", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.features)?
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct Softsign<T, features_Arg>
where T: TensorType,
      T: Clone,
      features_Arg: Clone,
      features_Arg: GraphEdge<T>,
      features_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    features: features_Arg,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<T, features_Arg> Softsign<T, features_Arg>
where T: TensorType,
      T: Clone,
      features_Arg: Clone,
      features_Arg: GraphEdge<T>,
      features_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
      T: 'static,
{
    pub fn activations(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(features: features_Arg) -> Self {
        Self {
            phantom_T: PhantomData,
            features,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(features: features_Arg) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            features,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<T, boxes_Arg, scores_Arg, max_output_size_Arg, iou_threshold_Arg, score_threshold_Arg> GraphOperation for NonMaxSuppressionV4<T, boxes_Arg, scores_Arg, max_output_size_Arg, iou_threshold_Arg, score_threshold_Arg>
where T: TensorType,
      T: Clone,
      boxes_Arg: Clone,
      boxes_Arg: GraphEdge<T>,
      boxes_Arg: 'static,
      scores_Arg: Clone,
      scores_Arg: GraphEdge<T>,
      scores_Arg: 'static,
      max_output_size_Arg: Clone,
      max_output_size_Arg: GraphEdge<i32>,
      max_output_size_Arg: 'static,
      iou_threshold_Arg: Clone,
      iou_threshold_Arg: GraphEdge<f32>,
      iou_threshold_Arg: 'static,
      score_threshold_Arg: Clone,
      score_threshold_Arg: GraphEdge<f32>,
      score_threshold_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_HALF,
      T: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("NonMaxSuppressionV4_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("NonMaxSuppressionV4", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.boxes)?
        }
        {
            new_op.add_edge(&self.scores)?
        }
        {
            new_op.add_edge(&self.max_output_size)?
        }
        {
            new_op.add_edge(&self.iou_threshold)?
        }
        {
            new_op.add_edge(&self.score_threshold)?
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        {
            match self.pad_to_max_output_size {
                None => new_op.set_attr_value_proto("pad_to_max_output_size", &vec![40_u8, 0_u8,])?,
                Some(ref value) => (|attr: &bool| {new_op.set_attr_bool("pad_to_max_output_size", *attr)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct NonMaxSuppressionV4<T, boxes_Arg, scores_Arg, max_output_size_Arg, iou_threshold_Arg, score_threshold_Arg>
where T: TensorType,
      T: Clone,
      boxes_Arg: Clone,
      boxes_Arg: GraphEdge<T>,
      boxes_Arg: 'static,
      scores_Arg: Clone,
      scores_Arg: GraphEdge<T>,
      scores_Arg: 'static,
      max_output_size_Arg: Clone,
      max_output_size_Arg: GraphEdge<i32>,
      max_output_size_Arg: 'static,
      iou_threshold_Arg: Clone,
      iou_threshold_Arg: GraphEdge<f32>,
      iou_threshold_Arg: 'static,
      score_threshold_Arg: Clone,
      score_threshold_Arg: GraphEdge<f32>,
      score_threshold_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_HALF,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    boxes: boxes_Arg,
    scores: scores_Arg,
    max_output_size: max_output_size_Arg,
    iou_threshold: iou_threshold_Arg,
    score_threshold: score_threshold_Arg,
    pad_to_max_output_size: Option<bool>,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<T, boxes_Arg, scores_Arg, max_output_size_Arg, iou_threshold_Arg, score_threshold_Arg> NonMaxSuppressionV4<T, boxes_Arg, scores_Arg, max_output_size_Arg, iou_threshold_Arg, score_threshold_Arg>
where T: TensorType,
      T: Clone,
      boxes_Arg: Clone,
      boxes_Arg: GraphEdge<T>,
      boxes_Arg: 'static,
      scores_Arg: Clone,
      scores_Arg: GraphEdge<T>,
      scores_Arg: 'static,
      max_output_size_Arg: Clone,
      max_output_size_Arg: GraphEdge<i32>,
      max_output_size_Arg: 'static,
      iou_threshold_Arg: Clone,
      iou_threshold_Arg: GraphEdge<f32>,
      iou_threshold_Arg: 'static,
      score_threshold_Arg: Clone,
      score_threshold_Arg: GraphEdge<f32>,
      score_threshold_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_HALF,
      T: 'static,
{
    pub fn selected_indices(self) -> Edge<i32> {
        let rc = Rc::new(self);
        {
            Edge::<i32>::new(rc.clone(), 0)
        }
    }

    pub fn valid_outputs(self) -> Edge<i32> {
        let rc = Rc::new(self);
        {
            Edge::<i32>::new(rc.clone(), 1)
        }
    }

    pub fn pad_to_max_output_size(&mut self, pad_to_max_output_size: bool) -> Self {
        self.pad_to_max_output_size = Some(pad_to_max_output_size);
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> (Edge<i32>, Edge<i32>) {
        let rc = Rc::new(self);
        (
        {
            Edge::<i32>::new(rc.clone(), 0)
        },
        {
            Edge::<i32>::new(rc.clone(), 1)
        },
        )
    }

    pub fn build(boxes: boxes_Arg, scores: scores_Arg, max_output_size: max_output_size_Arg, iou_threshold: iou_threshold_Arg, score_threshold: score_threshold_Arg) -> Self {
        Self {
            phantom_T: PhantomData,
            boxes,
            scores,
            max_output_size,
            iou_threshold,
            score_threshold,
            pad_to_max_output_size: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(boxes: boxes_Arg, scores: scores_Arg, max_output_size: max_output_size_Arg, iou_threshold: iou_threshold_Arg, score_threshold: score_threshold_Arg) -> (Edge<i32>, Edge<i32>) {
        Self {
            phantom_T: PhantomData,
            boxes,
            scores,
            max_output_size,
            iou_threshold,
            score_threshold,
            pad_to_max_output_size: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<T> GraphOperation for _Arg<T>
where T: TensorType,
      T: 'static,
      T: Clone,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("_Arg_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("_Arg", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        {
            (|attr: &i64| {new_op.set_attr_int("index", *attr)})(&self.index)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct _Arg<T>
where T: TensorType,
      T: 'static,
      T: Clone,
{
    phantom_T: PhantomData<T>,
    index: i64,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<T> _Arg<T>
where T: TensorType,
      T: 'static,
      T: Clone,
{
    pub fn output(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(index: i64) -> Self {
        Self {
            phantom_T: PhantomData,
            index: index,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(index: i64) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            index: index,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<T, x_Arg, y_Arg> GraphOperation for TruncateDiv<T, x_Arg, y_Arg>
where T: TensorType,
      T: Clone,
      x_Arg: Clone,
      x_Arg: GraphEdge<T>,
      x_Arg: 'static,
      y_Arg: Clone,
      y_Arg: GraphEdge<T>,
      y_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF,
      T: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("TruncateDiv_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("TruncateDiv", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.x)?
        }
        {
            new_op.add_edge(&self.y)?
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct TruncateDiv<T, x_Arg, y_Arg>
where T: TensorType,
      T: Clone,
      x_Arg: Clone,
      x_Arg: GraphEdge<T>,
      x_Arg: 'static,
      y_Arg: Clone,
      y_Arg: GraphEdge<T>,
      y_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    x: x_Arg,
    y: y_Arg,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<T, x_Arg, y_Arg> TruncateDiv<T, x_Arg, y_Arg>
where T: TensorType,
      T: Clone,
      x_Arg: Clone,
      x_Arg: GraphEdge<T>,
      x_Arg: 'static,
      y_Arg: Clone,
      y_Arg: GraphEdge<T>,
      y_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF,
      T: 'static,
{
    pub fn z(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(x: x_Arg, y: y_Arg) -> Self {
        Self {
            phantom_T: PhantomData,
            x,
            y,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(x: x_Arg, y: y_Arg) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            x,
            y,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<T> GraphOperation for _DeviceArg<T>
where T: TensorType,
      T: 'static,
      T: Clone,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("_DeviceArg_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("_DeviceArg", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        {
            (|attr: &i64| {new_op.set_attr_int("index", *attr)})(&self.index)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct _DeviceArg<T>
where T: TensorType,
      T: 'static,
      T: Clone,
{
    phantom_T: PhantomData<T>,
    index: i64,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<T> _DeviceArg<T>
where T: TensorType,
      T: 'static,
      T: Clone,
{
    pub fn output(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(index: i64) -> Self {
        Self {
            phantom_T: PhantomData,
            index: index,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(index: i64) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            index: index,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<input_Arg, fft_length_Arg> GraphOperation for RFFT3D<input_Arg, fft_length_Arg>
where input_Arg: Clone,
      input_Arg: GraphEdge<f32>,
      input_Arg: 'static,
      fft_length_Arg: Clone,
      fft_length_Arg: GraphEdge<i32>,
      fft_length_Arg: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("RFFT3D_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("RFFT3D", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.input)?
        }
        {
            new_op.add_edge(&self.fft_length)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct RFFT3D<input_Arg, fft_length_Arg>
where input_Arg: Clone,
      input_Arg: GraphEdge<f32>,
      input_Arg: 'static,
      fft_length_Arg: Clone,
      fft_length_Arg: GraphEdge<i32>,
      fft_length_Arg: 'static,
{
    input: input_Arg,
    fft_length: fft_length_Arg,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<input_Arg, fft_length_Arg> RFFT3D<input_Arg, fft_length_Arg>
where input_Arg: Clone,
      input_Arg: GraphEdge<f32>,
      input_Arg: 'static,
      fft_length_Arg: Clone,
      fft_length_Arg: GraphEdge<i32>,
      fft_length_Arg: 'static,
{
    pub fn output(self) -> Edge<OtherComplex<f32>> {
        let rc = Rc::new(self);
        {
            Edge::<OtherComplex::<f32>>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<OtherComplex<f32>> {
        let rc = Rc::new(self);
        {
            Edge::<OtherComplex::<f32>>::new(rc.clone(), 0)
        }
    }

    pub fn build(input: input_Arg, fft_length: fft_length_Arg) -> Self {
        Self {
            input,
            fft_length,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(input: input_Arg, fft_length: fft_length_Arg) -> Edge<OtherComplex<f32>> {
        Self {
            input,
            fft_length,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<x_Arg> GraphOperation for LogicalNot<x_Arg>
where x_Arg: Clone,
      x_Arg: GraphEdge<bool>,
      x_Arg: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("LogicalNot_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("LogicalNot", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.x)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct LogicalNot<x_Arg>
where x_Arg: Clone,
      x_Arg: GraphEdge<bool>,
      x_Arg: 'static,
{
    x: x_Arg,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<x_Arg> LogicalNot<x_Arg>
where x_Arg: Clone,
      x_Arg: GraphEdge<bool>,
      x_Arg: 'static,
{
    pub fn y(self) -> Edge<bool> {
        let rc = Rc::new(self);
        {
            Edge::<bool>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<bool> {
        let rc = Rc::new(self);
        {
            Edge::<bool>::new(rc.clone(), 0)
        }
    }

    pub fn build(x: x_Arg) -> Self {
        Self {
            x,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(x: x_Arg) -> Edge<bool> {
        Self {
            x,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<T, var_Arg, accum_Arg, linear_Arg, grad_Arg, lr_Arg, l1_Arg, l2_Arg, lr_power_Arg> GraphOperation for ApplyFtrl<T, var_Arg, accum_Arg, linear_Arg, grad_Arg, lr_Arg, l1_Arg, l2_Arg, lr_power_Arg>
where T: TensorType,
      T: Clone,
      var_Arg: Clone,
      var_Arg: GraphRefEdge<T>,
      var_Arg: 'static,
      accum_Arg: Clone,
      accum_Arg: GraphRefEdge<T>,
      accum_Arg: 'static,
      linear_Arg: Clone,
      linear_Arg: GraphRefEdge<T>,
      linear_Arg: 'static,
      grad_Arg: Clone,
      grad_Arg: GraphEdge<T>,
      grad_Arg: 'static,
      lr_Arg: Clone,
      lr_Arg: GraphEdge<T>,
      lr_Arg: 'static,
      l1_Arg: Clone,
      l1_Arg: GraphEdge<T>,
      l1_Arg: 'static,
      l2_Arg: Clone,
      l2_Arg: GraphEdge<T>,
      l2_Arg: 'static,
      lr_power_Arg: Clone,
      lr_power_Arg: GraphEdge<T>,
      lr_power_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("ApplyFtrl_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("ApplyFtrl", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.var)?
        }
        {
            new_op.add_edge(&self.accum)?
        }
        {
            new_op.add_edge(&self.linear)?
        }
        {
            new_op.add_edge(&self.grad)?
        }
        {
            new_op.add_edge(&self.lr)?
        }
        {
            new_op.add_edge(&self.l1)?
        }
        {
            new_op.add_edge(&self.l2)?
        }
        {
            new_op.add_edge(&self.lr_power)?
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        {
            match self.use_locking {
                None => new_op.set_attr_value_proto("use_locking", &vec![40_u8, 0_u8,])?,
                Some(ref value) => (|attr: &bool| {new_op.set_attr_bool("use_locking", *attr)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct ApplyFtrl<T, var_Arg, accum_Arg, linear_Arg, grad_Arg, lr_Arg, l1_Arg, l2_Arg, lr_power_Arg>
where T: TensorType,
      T: Clone,
      var_Arg: Clone,
      var_Arg: GraphRefEdge<T>,
      var_Arg: 'static,
      accum_Arg: Clone,
      accum_Arg: GraphRefEdge<T>,
      accum_Arg: 'static,
      linear_Arg: Clone,
      linear_Arg: GraphRefEdge<T>,
      linear_Arg: 'static,
      grad_Arg: Clone,
      grad_Arg: GraphEdge<T>,
      grad_Arg: 'static,
      lr_Arg: Clone,
      lr_Arg: GraphEdge<T>,
      lr_Arg: 'static,
      l1_Arg: Clone,
      l1_Arg: GraphEdge<T>,
      l1_Arg: 'static,
      l2_Arg: Clone,
      l2_Arg: GraphEdge<T>,
      l2_Arg: 'static,
      lr_power_Arg: Clone,
      lr_power_Arg: GraphEdge<T>,
      lr_power_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    var: var_Arg,
    accum: accum_Arg,
    linear: linear_Arg,
    grad: grad_Arg,
    lr: lr_Arg,
    l1: l1_Arg,
    l2: l2_Arg,
    lr_power: lr_power_Arg,
    use_locking: Option<bool>,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<T, var_Arg, accum_Arg, linear_Arg, grad_Arg, lr_Arg, l1_Arg, l2_Arg, lr_power_Arg> ApplyFtrl<T, var_Arg, accum_Arg, linear_Arg, grad_Arg, lr_Arg, l1_Arg, l2_Arg, lr_power_Arg>
where T: TensorType,
      T: Clone,
      var_Arg: Clone,
      var_Arg: GraphRefEdge<T>,
      var_Arg: 'static,
      accum_Arg: Clone,
      accum_Arg: GraphRefEdge<T>,
      accum_Arg: 'static,
      linear_Arg: Clone,
      linear_Arg: GraphRefEdge<T>,
      linear_Arg: 'static,
      grad_Arg: Clone,
      grad_Arg: GraphEdge<T>,
      grad_Arg: 'static,
      lr_Arg: Clone,
      lr_Arg: GraphEdge<T>,
      lr_Arg: 'static,
      l1_Arg: Clone,
      l1_Arg: GraphEdge<T>,
      l1_Arg: 'static,
      l2_Arg: Clone,
      l2_Arg: GraphEdge<T>,
      l2_Arg: 'static,
      lr_power_Arg: Clone,
      lr_power_Arg: GraphEdge<T>,
      lr_power_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
{
    pub fn out(self) -> RefEdge<T> {
        let rc = Rc::new(self);
        {
            RefEdge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn use_locking(&mut self, use_locking: bool) -> Self {
        self.use_locking = Some(use_locking);
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> RefEdge<T> {
        let rc = Rc::new(self);
        {
            RefEdge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(var: var_Arg, accum: accum_Arg, linear: linear_Arg, grad: grad_Arg, lr: lr_Arg, l1: l1_Arg, l2: l2_Arg, lr_power: lr_power_Arg) -> Self {
        Self {
            phantom_T: PhantomData,
            var,
            accum,
            linear,
            grad,
            lr,
            l1,
            l2,
            lr_power,
            use_locking: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(var: var_Arg, accum: accum_Arg, linear: linear_Arg, grad: grad_Arg, lr: lr_Arg, l1: l1_Arg, l2: l2_Arg, lr_power: lr_power_Arg) -> RefEdge<T> {
        Self {
            phantom_T: PhantomData,
            var,
            accum,
            linear,
            grad,
            lr,
            l1,
            l2,
            lr_power,
            use_locking: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<T, input_Arg> GraphOperation for _Retval<T, input_Arg>
where T: TensorType,
      T: Clone,
      input_Arg: Clone,
      input_Arg: GraphEdge<T>,
      input_Arg: 'static,
      T: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("_Retval_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("_Retval", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.input)?
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        {
            (|attr: &i64| {new_op.set_attr_int("index", *attr)})(&self.index)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct _Retval<T, input_Arg>
where T: TensorType,
      T: Clone,
      input_Arg: Clone,
      input_Arg: GraphEdge<T>,
      input_Arg: 'static,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    input: input_Arg,
    index: i64,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<T, input_Arg> _Retval<T, input_Arg>
where T: TensorType,
      T: Clone,
      input_Arg: Clone,
      input_Arg: GraphEdge<T>,
      input_Arg: 'static,
      T: 'static,
{
    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> () {
        let rc = Rc::new(self);
        (
        )
    }

    pub fn build(input: input_Arg, index: i64) -> Self {
        Self {
            phantom_T: PhantomData,
            input,
            index: index,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(input: input_Arg, index: i64) -> () {
        Self {
            phantom_T: PhantomData,
            input,
            index: index,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<T, input_Arg> GraphOperation for _DeviceRetval<T, input_Arg>
where T: TensorType,
      T: Clone,
      input_Arg: Clone,
      input_Arg: GraphEdge<T>,
      input_Arg: 'static,
      T: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("_DeviceRetval_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("_DeviceRetval", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.input)?
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        {
            (|attr: &i64| {new_op.set_attr_int("index", *attr)})(&self.index)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct _DeviceRetval<T, input_Arg>
where T: TensorType,
      T: Clone,
      input_Arg: Clone,
      input_Arg: GraphEdge<T>,
      input_Arg: 'static,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    input: input_Arg,
    index: i64,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<T, input_Arg> _DeviceRetval<T, input_Arg>
where T: TensorType,
      T: Clone,
      input_Arg: Clone,
      input_Arg: GraphEdge<T>,
      input_Arg: 'static,
      T: 'static,
{
    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> () {
        let rc = Rc::new(self);
        (
        )
    }

    pub fn build(input: input_Arg, index: i64) -> Self {
        Self {
            phantom_T: PhantomData,
            input,
            index: index,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(input: input_Arg, index: i64) -> () {
        Self {
            phantom_T: PhantomData,
            input,
            index: index,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<T, x_Arg, y_Arg> GraphOperation for Xdivy<T, x_Arg, y_Arg>
where T: TensorType,
      T: Clone,
      x_Arg: Clone,
      x_Arg: GraphEdge<T>,
      x_Arg: 'static,
      y_Arg: Clone,
      y_Arg: GraphEdge<T>,
      y_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_COMPLEX64_or_DT_COMPLEX128_or_DT_HALF,
      T: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("Xdivy_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("Xdivy", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.x)?
        }
        {
            new_op.add_edge(&self.y)?
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct Xdivy<T, x_Arg, y_Arg>
where T: TensorType,
      T: Clone,
      x_Arg: Clone,
      x_Arg: GraphEdge<T>,
      x_Arg: 'static,
      y_Arg: Clone,
      y_Arg: GraphEdge<T>,
      y_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_COMPLEX64_or_DT_COMPLEX128_or_DT_HALF,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    x: x_Arg,
    y: y_Arg,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<T, x_Arg, y_Arg> Xdivy<T, x_Arg, y_Arg>
where T: TensorType,
      T: Clone,
      x_Arg: Clone,
      x_Arg: GraphEdge<T>,
      x_Arg: 'static,
      y_Arg: Clone,
      y_Arg: GraphEdge<T>,
      y_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_COMPLEX64_or_DT_COMPLEX128_or_DT_HALF,
      T: 'static,
{
    pub fn z(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(x: x_Arg, y: y_Arg) -> Self {
        Self {
            phantom_T: PhantomData,
            x,
            y,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(x: x_Arg, y: y_Arg) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            x,
            y,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<T, a_Arg, b_Arg> GraphOperation for Cross<T, a_Arg, b_Arg>
where T: TensorType,
      T: Clone,
      a_Arg: Clone,
      a_Arg: GraphEdge<T>,
      a_Arg: 'static,
      b_Arg: Clone,
      b_Arg: GraphEdge<T>,
      b_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("Cross_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("Cross", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.a)?
        }
        {
            new_op.add_edge(&self.b)?
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct Cross<T, a_Arg, b_Arg>
where T: TensorType,
      T: Clone,
      a_Arg: Clone,
      a_Arg: GraphEdge<T>,
      a_Arg: 'static,
      b_Arg: Clone,
      b_Arg: GraphEdge<T>,
      b_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    a: a_Arg,
    b: b_Arg,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<T, a_Arg, b_Arg> Cross<T, a_Arg, b_Arg>
where T: TensorType,
      T: Clone,
      a_Arg: Clone,
      a_Arg: GraphEdge<T>,
      a_Arg: 'static,
      b_Arg: Clone,
      b_Arg: GraphEdge<T>,
      b_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
{
    pub fn product(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(a: a_Arg, b: b_Arg) -> Self {
        Self {
            phantom_T: PhantomData,
            a,
            b,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(a: a_Arg, b: b_Arg) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            a,
            b,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<handle_Arg, indices_Arg, flow_in_Arg, dtype> GraphOperation for TensorArrayGather<handle_Arg, indices_Arg, flow_in_Arg, dtype>
where handle_Arg: Clone,
      handle_Arg: GraphRefEdge<String>,
      handle_Arg: 'static,
      indices_Arg: Clone,
      indices_Arg: GraphEdge<i32>,
      indices_Arg: 'static,
      flow_in_Arg: Clone,
      flow_in_Arg: GraphEdge<f32>,
      flow_in_Arg: 'static,
      dtype: TensorType,
      dtype: 'static,
      dtype: Clone,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("TensorArrayGather_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("TensorArrayGather", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.handle)?
        }
        {
            new_op.add_edge(&self.indices)?
        }
        {
            new_op.add_edge(&self.flow_in)?
        }
        {
            new_op.set_attr_type("dtype", dtype::data_type())?;
        }
        {
            match self.element_shape {
                None => new_op.set_attr_value_proto("element_shape", &vec![58_u8, 0_u8,])?,
                Some(ref value) => (|attr| {new_op.set_attr_shape("element_shape", attr)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct TensorArrayGather<handle_Arg, indices_Arg, flow_in_Arg, dtype>
where handle_Arg: Clone,
      handle_Arg: GraphRefEdge<String>,
      handle_Arg: 'static,
      indices_Arg: Clone,
      indices_Arg: GraphEdge<i32>,
      indices_Arg: 'static,
      flow_in_Arg: Clone,
      flow_in_Arg: GraphEdge<f32>,
      flow_in_Arg: 'static,
      dtype: TensorType,
      dtype: 'static,
      dtype: Clone,
{
    handle: handle_Arg,
    indices: indices_Arg,
    flow_in: flow_in_Arg,
    phantom_dtype: PhantomData<dtype>,
    element_shape: Option<OtherShape>,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<handle_Arg, indices_Arg, flow_in_Arg, dtype> TensorArrayGather<handle_Arg, indices_Arg, flow_in_Arg, dtype>
where handle_Arg: Clone,
      handle_Arg: GraphRefEdge<String>,
      handle_Arg: 'static,
      indices_Arg: Clone,
      indices_Arg: GraphEdge<i32>,
      indices_Arg: 'static,
      flow_in_Arg: Clone,
      flow_in_Arg: GraphEdge<f32>,
      flow_in_Arg: 'static,
      dtype: TensorType,
      dtype: 'static,
      dtype: Clone,
{
    pub fn value(self) -> Edge<dtype> {
        let rc = Rc::new(self);
        {
            Edge::<dtype>::new(rc.clone(), 0)
        }
    }

    pub fn element_shape(&mut self, element_shape: &OtherShape) -> Self {
        self.element_shape = Some(element_shape.clone());
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<dtype> {
        let rc = Rc::new(self);
        {
            Edge::<dtype>::new(rc.clone(), 0)
        }
    }

    pub fn build(handle: handle_Arg, indices: indices_Arg, flow_in: flow_in_Arg) -> Self {
        Self {
            handle,
            indices,
            flow_in,
            phantom_dtype: PhantomData,
            element_shape: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(handle: handle_Arg, indices: indices_Arg, flow_in: flow_in_Arg) -> Edge<dtype> {
        Self {
            handle,
            indices,
            flow_in,
            phantom_dtype: PhantomData,
            element_shape: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<T, data_Arg, Tindices, segment_ids_Arg> GraphOperation for SegmentProd<T, data_Arg, Tindices, segment_ids_Arg>
where T: TensorType,
      T: Clone,
      data_Arg: Clone,
      data_Arg: GraphEdge<T>,
      data_Arg: 'static,
      Tindices: TensorType,
      Tindices: Clone,
      segment_ids_Arg: Clone,
      segment_ids_Arg: GraphEdge<Tindices>,
      segment_ids_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
      Tindices: con_or_DT_INT32_or_DT_INT64,
      Tindices: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("SegmentProd_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("SegmentProd", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.data)?
        }
        {
            new_op.add_edge(&self.segment_ids)?
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        {
            new_op.set_attr_type("Tindices", Tindices::data_type())?;
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct SegmentProd<T, data_Arg, Tindices, segment_ids_Arg>
where T: TensorType,
      T: Clone,
      data_Arg: Clone,
      data_Arg: GraphEdge<T>,
      data_Arg: 'static,
      Tindices: TensorType,
      Tindices: Clone,
      segment_ids_Arg: Clone,
      segment_ids_Arg: GraphEdge<Tindices>,
      segment_ids_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
      Tindices: con_or_DT_INT32_or_DT_INT64,
      Tindices: 'static,
{
    phantom_T: PhantomData<T>,
    data: data_Arg,
    phantom_Tindices: PhantomData<Tindices>,
    segment_ids: segment_ids_Arg,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<T, data_Arg, Tindices, segment_ids_Arg> SegmentProd<T, data_Arg, Tindices, segment_ids_Arg>
where T: TensorType,
      T: Clone,
      data_Arg: Clone,
      data_Arg: GraphEdge<T>,
      data_Arg: 'static,
      Tindices: TensorType,
      Tindices: Clone,
      segment_ids_Arg: Clone,
      segment_ids_Arg: GraphEdge<Tindices>,
      segment_ids_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
      Tindices: con_or_DT_INT32_or_DT_INT64,
      Tindices: 'static,
{
    pub fn output(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(data: data_Arg, segment_ids: segment_ids_Arg) -> Self {
        Self {
            phantom_T: PhantomData,
            data,
            phantom_Tindices: PhantomData,
            segment_ids,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(data: data_Arg, segment_ids: segment_ids_Arg) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            data,
            phantom_Tindices: PhantomData,
            segment_ids,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<table_handle_Arg, Tin, keys_Arg, Tout, values_Arg> GraphOperation for LookupTableInsert<table_handle_Arg, Tin, keys_Arg, Tout, values_Arg>
where table_handle_Arg: Clone,
      table_handle_Arg: GraphRefEdge<String>,
      table_handle_Arg: 'static,
      Tin: TensorType,
      Tin: Clone,
      keys_Arg: Clone,
      keys_Arg: GraphEdge<Tin>,
      keys_Arg: 'static,
      Tout: TensorType,
      Tout: Clone,
      values_Arg: Clone,
      values_Arg: GraphEdge<Tout>,
      values_Arg: 'static,
      Tin: 'static,
      Tout: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("LookupTableInsert_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("LookupTableInsert", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.table_handle)?
        }
        {
            new_op.add_edge(&self.keys)?
        }
        {
            new_op.add_edge(&self.values)?
        }
        {
            new_op.set_attr_type("Tin", Tin::data_type())?;
        }
        {
            new_op.set_attr_type("Tout", Tout::data_type())?;
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct LookupTableInsert<table_handle_Arg, Tin, keys_Arg, Tout, values_Arg>
where table_handle_Arg: Clone,
      table_handle_Arg: GraphRefEdge<String>,
      table_handle_Arg: 'static,
      Tin: TensorType,
      Tin: Clone,
      keys_Arg: Clone,
      keys_Arg: GraphEdge<Tin>,
      keys_Arg: 'static,
      Tout: TensorType,
      Tout: Clone,
      values_Arg: Clone,
      values_Arg: GraphEdge<Tout>,
      values_Arg: 'static,
      Tin: 'static,
      Tout: 'static,
{
    table_handle: table_handle_Arg,
    phantom_Tin: PhantomData<Tin>,
    keys: keys_Arg,
    phantom_Tout: PhantomData<Tout>,
    values: values_Arg,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<table_handle_Arg, Tin, keys_Arg, Tout, values_Arg> LookupTableInsert<table_handle_Arg, Tin, keys_Arg, Tout, values_Arg>
where table_handle_Arg: Clone,
      table_handle_Arg: GraphRefEdge<String>,
      table_handle_Arg: 'static,
      Tin: TensorType,
      Tin: Clone,
      keys_Arg: Clone,
      keys_Arg: GraphEdge<Tin>,
      keys_Arg: 'static,
      Tout: TensorType,
      Tout: Clone,
      values_Arg: Clone,
      values_Arg: GraphEdge<Tout>,
      values_Arg: 'static,
      Tin: 'static,
      Tout: 'static,
{
    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> () {
        let rc = Rc::new(self);
        (
        )
    }

    pub fn build(table_handle: table_handle_Arg, keys: keys_Arg, values: values_Arg) -> Self {
        Self {
            table_handle,
            phantom_Tin: PhantomData,
            keys,
            phantom_Tout: PhantomData,
            values,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(table_handle: table_handle_Arg, keys: keys_Arg, values: values_Arg) -> () {
        Self {
            table_handle,
            phantom_Tin: PhantomData,
            keys,
            phantom_Tout: PhantomData,
            values,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<T, input_Arg> GraphOperation for Bucketize<T, input_Arg>
where T: TensorType,
      T: Clone,
      input_Arg: Clone,
      input_Arg: GraphEdge<T>,
      input_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_INT64,
      T: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("Bucketize_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("Bucketize", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.input)?
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        {
            (|attrs| {new_op.set_attr_float_list("boundaries", attrs)})(&self.boundaries)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct Bucketize<T, input_Arg>
where T: TensorType,
      T: Clone,
      input_Arg: Clone,
      input_Arg: GraphEdge<T>,
      input_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_INT64,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    input: input_Arg,
    boundaries: Vec<f32>,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<T, input_Arg> Bucketize<T, input_Arg>
where T: TensorType,
      T: Clone,
      input_Arg: Clone,
      input_Arg: GraphEdge<T>,
      input_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_INT64,
      T: 'static,
{
    pub fn output(self) -> Edge<i32> {
        let rc = Rc::new(self);
        {
            Edge::<i32>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<i32> {
        let rc = Rc::new(self);
        {
            Edge::<i32>::new(rc.clone(), 0)
        }
    }

    pub fn build(input: input_Arg, boundaries: &[f32]) -> Self {
        Self {
            phantom_T: PhantomData,
            input,
            boundaries: boundaries.to_vec(),
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(input: input_Arg, boundaries: &[f32]) -> Edge<i32> {
        Self {
            phantom_T: PhantomData,
            input,
            boundaries: boundaries.to_vec(),
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<file_pattern_Arg, tensor_name_Arg, shape_and_slice_Arg, dt> GraphOperation for RestoreSlice<file_pattern_Arg, tensor_name_Arg, shape_and_slice_Arg, dt>
where file_pattern_Arg: Clone,
      file_pattern_Arg: GraphEdge<String>,
      file_pattern_Arg: 'static,
      tensor_name_Arg: Clone,
      tensor_name_Arg: GraphEdge<String>,
      tensor_name_Arg: 'static,
      shape_and_slice_Arg: Clone,
      shape_and_slice_Arg: GraphEdge<String>,
      shape_and_slice_Arg: 'static,
      dt: TensorType,
      dt: 'static,
      dt: Clone,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("RestoreSlice_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("RestoreSlice", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.file_pattern)?
        }
        {
            new_op.add_edge(&self.tensor_name)?
        }
        {
            new_op.add_edge(&self.shape_and_slice)?
        }
        {
            new_op.set_attr_type("dt", dt::data_type())?;
        }
        {
            match self.preferred_shard {
                None => new_op.set_attr_value_proto("preferred_shard", &vec![24_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 1_u8,])?,
                Some(ref value) => (|attr: &i64| {new_op.set_attr_int("preferred_shard", *attr)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct RestoreSlice<file_pattern_Arg, tensor_name_Arg, shape_and_slice_Arg, dt>
where file_pattern_Arg: Clone,
      file_pattern_Arg: GraphEdge<String>,
      file_pattern_Arg: 'static,
      tensor_name_Arg: Clone,
      tensor_name_Arg: GraphEdge<String>,
      tensor_name_Arg: 'static,
      shape_and_slice_Arg: Clone,
      shape_and_slice_Arg: GraphEdge<String>,
      shape_and_slice_Arg: 'static,
      dt: TensorType,
      dt: 'static,
      dt: Clone,
{
    file_pattern: file_pattern_Arg,
    tensor_name: tensor_name_Arg,
    shape_and_slice: shape_and_slice_Arg,
    phantom_dt: PhantomData<dt>,
    preferred_shard: Option<i64>,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<file_pattern_Arg, tensor_name_Arg, shape_and_slice_Arg, dt> RestoreSlice<file_pattern_Arg, tensor_name_Arg, shape_and_slice_Arg, dt>
where file_pattern_Arg: Clone,
      file_pattern_Arg: GraphEdge<String>,
      file_pattern_Arg: 'static,
      tensor_name_Arg: Clone,
      tensor_name_Arg: GraphEdge<String>,
      tensor_name_Arg: 'static,
      shape_and_slice_Arg: Clone,
      shape_and_slice_Arg: GraphEdge<String>,
      shape_and_slice_Arg: 'static,
      dt: TensorType,
      dt: 'static,
      dt: Clone,
{
    pub fn tensor(self) -> Edge<dt> {
        let rc = Rc::new(self);
        {
            Edge::<dt>::new(rc.clone(), 0)
        }
    }

    pub fn preferred_shard(&mut self, preferred_shard: i64) -> Self {
        self.preferred_shard = Some(preferred_shard);
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<dt> {
        let rc = Rc::new(self);
        {
            Edge::<dt>::new(rc.clone(), 0)
        }
    }

    pub fn build(file_pattern: file_pattern_Arg, tensor_name: tensor_name_Arg, shape_and_slice: shape_and_slice_Arg) -> Self {
        Self {
            file_pattern,
            tensor_name,
            shape_and_slice,
            phantom_dt: PhantomData,
            preferred_shard: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(file_pattern: file_pattern_Arg, tensor_name: tensor_name_Arg, shape_and_slice: shape_and_slice_Arg) -> Edge<dt> {
        Self {
            file_pattern,
            tensor_name,
            shape_and_slice,
            phantom_dt: PhantomData,
            preferred_shard: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl GraphOperation for RetrieveTPUEmbeddingStochasticGradientDescentParameters {
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("RetrieveTPUEmbeddingStochasticGradientDescentParameters_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("RetrieveTPUEmbeddingStochasticGradientDescentParameters", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            match self.table_id {
                None => new_op.set_attr_value_proto("table_id", &vec![24_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 1_u8,])?,
                Some(ref value) => (|attr: &i64| {new_op.set_attr_int("table_id", *attr)})(&value)?,
            };
        }
        {
            match self.table_name {
                None => new_op.set_attr_value_proto("table_name", &vec![18_u8, 0_u8,])?,
                Some(ref value) => (|attr| {new_op.set_attr_string("table_name", attr)})(&value)?,
            };
        }
        {
            (|attr: &i64| {new_op.set_attr_int("num_shards", *attr)})(&self.num_shards)?
        }
        {
            (|attr: &i64| {new_op.set_attr_int("shard_id", *attr)})(&self.shard_id)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct RetrieveTPUEmbeddingStochasticGradientDescentParameters {
    table_id: Option<i64>,
    table_name: Option<String>,
    num_shards: i64,
    shard_id: i64,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl RetrieveTPUEmbeddingStochasticGradientDescentParameters {
    pub fn parameters(self) -> Edge<f32> {
        let rc = Rc::new(self);
        {
            Edge::<f32>::new(rc.clone(), 0)
        }
    }

    pub fn table_id(&mut self, table_id: i64) -> Self {
        self.table_id = Some(table_id);
        self.clone()
    }

    pub fn table_name(&mut self, table_name: &str) -> Self {
        self.table_name = Some(table_name.to_string());
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<f32> {
        let rc = Rc::new(self);
        {
            Edge::<f32>::new(rc.clone(), 0)
        }
    }

    pub fn build(num_shards: i64, shard_id: i64) -> Self {
        Self {
            table_id: None,
            table_name: None,
            num_shards: num_shards,
            shard_id: shard_id,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(num_shards: i64, shard_id: i64) -> Edge<f32> {
        Self {
            table_id: None,
            table_name: None,
            num_shards: num_shards,
            shard_id: shard_id,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<T, x_Arg, Tidx, axis_Arg> GraphOperation for Cumprod<T, x_Arg, Tidx, axis_Arg>
where T: TensorType,
      T: Clone,
      x_Arg: Clone,
      x_Arg: GraphEdge<T>,
      x_Arg: 'static,
      Tidx: TensorType,
      Tidx: Clone,
      axis_Arg: Clone,
      axis_Arg: GraphEdge<Tidx>,
      axis_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
      Tidx: con_or_DT_INT32_or_DT_INT64,
      Tidx: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("Cumprod_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("Cumprod", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.x)?
        }
        {
            new_op.add_edge(&self.axis)?
        }
        {
            match self.exclusive {
                None => new_op.set_attr_value_proto("exclusive", &vec![40_u8, 0_u8,])?,
                Some(ref value) => (|attr: &bool| {new_op.set_attr_bool("exclusive", *attr)})(&value)?,
            };
        }
        {
            match self.reverse {
                None => new_op.set_attr_value_proto("reverse", &vec![40_u8, 0_u8,])?,
                Some(ref value) => (|attr: &bool| {new_op.set_attr_bool("reverse", *attr)})(&value)?,
            };
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        {
            new_op.set_attr_type("Tidx", Tidx::data_type())?;
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct Cumprod<T, x_Arg, Tidx, axis_Arg>
where T: TensorType,
      T: Clone,
      x_Arg: Clone,
      x_Arg: GraphEdge<T>,
      x_Arg: 'static,
      Tidx: TensorType,
      Tidx: Clone,
      axis_Arg: Clone,
      axis_Arg: GraphEdge<Tidx>,
      axis_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
      Tidx: con_or_DT_INT32_or_DT_INT64,
      Tidx: 'static,
{
    phantom_T: PhantomData<T>,
    x: x_Arg,
    phantom_Tidx: PhantomData<Tidx>,
    axis: axis_Arg,
    exclusive: Option<bool>,
    reverse: Option<bool>,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<T, x_Arg, Tidx, axis_Arg> Cumprod<T, x_Arg, Tidx, axis_Arg>
where T: TensorType,
      T: Clone,
      x_Arg: Clone,
      x_Arg: GraphEdge<T>,
      x_Arg: 'static,
      Tidx: TensorType,
      Tidx: Clone,
      axis_Arg: Clone,
      axis_Arg: GraphEdge<Tidx>,
      axis_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
      Tidx: con_or_DT_INT32_or_DT_INT64,
      Tidx: 'static,
{
    pub fn out(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn exclusive(&mut self, exclusive: bool) -> Self {
        self.exclusive = Some(exclusive);
        self.clone()
    }

    pub fn reverse(&mut self, reverse: bool) -> Self {
        self.reverse = Some(reverse);
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(x: x_Arg, axis: axis_Arg) -> Self {
        Self {
            phantom_T: PhantomData,
            x,
            phantom_Tidx: PhantomData,
            axis,
            exclusive: None,
            reverse: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(x: x_Arg, axis: axis_Arg) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            x,
            phantom_Tidx: PhantomData,
            axis,
            exclusive: None,
            reverse: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<T, images_Arg, size_Arg> GraphOperation for ResizeBicubic<T, images_Arg, size_Arg>
where T: TensorType,
      T: Clone,
      images_Arg: Clone,
      images_Arg: GraphEdge<T>,
      images_Arg: 'static,
      size_Arg: Clone,
      size_Arg: GraphEdge<i32>,
      size_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_UINT16_or_DT_HALF,
      T: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("ResizeBicubic_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("ResizeBicubic", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.images)?
        }
        {
            new_op.add_edge(&self.size)?
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        {
            match self.align_corners {
                None => new_op.set_attr_value_proto("align_corners", &vec![40_u8, 0_u8,])?,
                Some(ref value) => (|attr: &bool| {new_op.set_attr_bool("align_corners", *attr)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct ResizeBicubic<T, images_Arg, size_Arg>
where T: TensorType,
      T: Clone,
      images_Arg: Clone,
      images_Arg: GraphEdge<T>,
      images_Arg: 'static,
      size_Arg: Clone,
      size_Arg: GraphEdge<i32>,
      size_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_UINT16_or_DT_HALF,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    images: images_Arg,
    size: size_Arg,
    align_corners: Option<bool>,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<T, images_Arg, size_Arg> ResizeBicubic<T, images_Arg, size_Arg>
where T: TensorType,
      T: Clone,
      images_Arg: Clone,
      images_Arg: GraphEdge<T>,
      images_Arg: 'static,
      size_Arg: Clone,
      size_Arg: GraphEdge<i32>,
      size_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_UINT16_or_DT_HALF,
      T: 'static,
{
    pub fn resized_images(self) -> Edge<f32> {
        let rc = Rc::new(self);
        {
            Edge::<f32>::new(rc.clone(), 0)
        }
    }

    pub fn align_corners(&mut self, align_corners: bool) -> Self {
        self.align_corners = Some(align_corners);
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<f32> {
        let rc = Rc::new(self);
        {
            Edge::<f32>::new(rc.clone(), 0)
        }
    }

    pub fn build(images: images_Arg, size: size_Arg) -> Self {
        Self {
            phantom_T: PhantomData,
            images,
            size,
            align_corners: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(images: images_Arg, size: size_Arg) -> Edge<f32> {
        Self {
            phantom_T: PhantomData,
            images,
            size,
            align_corners: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<T, x_Arg> GraphOperation for Log1p<T, x_Arg>
where T: TensorType,
      T: Clone,
      x_Arg: Clone,
      x_Arg: GraphEdge<T>,
      x_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_COMPLEX64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF,
      T: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("Log1p_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("Log1p", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.x)?
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct Log1p<T, x_Arg>
where T: TensorType,
      T: Clone,
      x_Arg: Clone,
      x_Arg: GraphEdge<T>,
      x_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_COMPLEX64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    x: x_Arg,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<T, x_Arg> Log1p<T, x_Arg>
where T: TensorType,
      T: Clone,
      x_Arg: Clone,
      x_Arg: GraphEdge<T>,
      x_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_COMPLEX64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF,
      T: 'static,
{
    pub fn y(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(x: x_Arg) -> Self {
        Self {
            phantom_T: PhantomData,
            x,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(x: x_Arg) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            x,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

pub trait con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF for BFloat16 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF for f32 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF for f64 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF for i16 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF for i32 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF for i64 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF for i8 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF for u16 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF for u8 {
}

impl<T, images_Arg, size_Arg> GraphOperation for ResizeBilinear<T, images_Arg, size_Arg>
where T: TensorType,
      T: Clone,
      images_Arg: Clone,
      images_Arg: GraphEdge<T>,
      images_Arg: 'static,
      size_Arg: Clone,
      size_Arg: GraphEdge<i32>,
      size_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF,
      T: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("ResizeBilinear_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("ResizeBilinear", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.images)?
        }
        {
            new_op.add_edge(&self.size)?
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        {
            match self.align_corners {
                None => new_op.set_attr_value_proto("align_corners", &vec![40_u8, 0_u8,])?,
                Some(ref value) => (|attr: &bool| {new_op.set_attr_bool("align_corners", *attr)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct ResizeBilinear<T, images_Arg, size_Arg>
where T: TensorType,
      T: Clone,
      images_Arg: Clone,
      images_Arg: GraphEdge<T>,
      images_Arg: 'static,
      size_Arg: Clone,
      size_Arg: GraphEdge<i32>,
      size_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    images: images_Arg,
    size: size_Arg,
    align_corners: Option<bool>,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<T, images_Arg, size_Arg> ResizeBilinear<T, images_Arg, size_Arg>
where T: TensorType,
      T: Clone,
      images_Arg: Clone,
      images_Arg: GraphEdge<T>,
      images_Arg: 'static,
      size_Arg: Clone,
      size_Arg: GraphEdge<i32>,
      size_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF,
      T: 'static,
{
    pub fn resized_images(self) -> Edge<f32> {
        let rc = Rc::new(self);
        {
            Edge::<f32>::new(rc.clone(), 0)
        }
    }

    pub fn align_corners(&mut self, align_corners: bool) -> Self {
        self.align_corners = Some(align_corners);
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<f32> {
        let rc = Rc::new(self);
        {
            Edge::<f32>::new(rc.clone(), 0)
        }
    }

    pub fn build(images: images_Arg, size: size_Arg) -> Self {
        Self {
            phantom_T: PhantomData,
            images,
            size,
            align_corners: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(images: images_Arg, size: size_Arg) -> Edge<f32> {
        Self {
            phantom_T: PhantomData,
            images,
            size,
            align_corners: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<T, input_Arg, Tidx, reduction_indices_Arg> GraphOperation for Prod<T, input_Arg, Tidx, reduction_indices_Arg>
where T: TensorType,
      T: Clone,
      input_Arg: Clone,
      input_Arg: GraphEdge<T>,
      input_Arg: 'static,
      Tidx: TensorType,
      Tidx: Clone,
      reduction_indices_Arg: Clone,
      reduction_indices_Arg: GraphEdge<Tidx>,
      reduction_indices_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
      Tidx: con_or_DT_INT32_or_DT_INT64,
      Tidx: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("Prod_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("Prod", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.input)?
        }
        {
            new_op.add_edge(&self.reduction_indices)?
        }
        {
            match self.keep_dims {
                None => new_op.set_attr_value_proto("keep_dims", &vec![40_u8, 0_u8,])?,
                Some(ref value) => (|attr: &bool| {new_op.set_attr_bool("keep_dims", *attr)})(&value)?,
            };
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        {
            new_op.set_attr_type("Tidx", Tidx::data_type())?;
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct Prod<T, input_Arg, Tidx, reduction_indices_Arg>
where T: TensorType,
      T: Clone,
      input_Arg: Clone,
      input_Arg: GraphEdge<T>,
      input_Arg: 'static,
      Tidx: TensorType,
      Tidx: Clone,
      reduction_indices_Arg: Clone,
      reduction_indices_Arg: GraphEdge<Tidx>,
      reduction_indices_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
      Tidx: con_or_DT_INT32_or_DT_INT64,
      Tidx: 'static,
{
    phantom_T: PhantomData<T>,
    input: input_Arg,
    phantom_Tidx: PhantomData<Tidx>,
    reduction_indices: reduction_indices_Arg,
    keep_dims: Option<bool>,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<T, input_Arg, Tidx, reduction_indices_Arg> Prod<T, input_Arg, Tidx, reduction_indices_Arg>
where T: TensorType,
      T: Clone,
      input_Arg: Clone,
      input_Arg: GraphEdge<T>,
      input_Arg: 'static,
      Tidx: TensorType,
      Tidx: Clone,
      reduction_indices_Arg: Clone,
      reduction_indices_Arg: GraphEdge<Tidx>,
      reduction_indices_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
      Tidx: con_or_DT_INT32_or_DT_INT64,
      Tidx: 'static,
{
    pub fn output(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn keep_dims(&mut self, keep_dims: bool) -> Self {
        self.keep_dims = Some(keep_dims);
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(input: input_Arg, reduction_indices: reduction_indices_Arg) -> Self {
        Self {
            phantom_T: PhantomData,
            input,
            phantom_Tidx: PhantomData,
            reduction_indices,
            keep_dims: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(input: input_Arg, reduction_indices: reduction_indices_Arg) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            input,
            phantom_Tidx: PhantomData,
            reduction_indices,
            keep_dims: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<component_types> GraphOperation for PaddingFIFOQueue<component_types>
where component_types: TensorType,
      component_types: 'static,
      component_types: Clone,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("PaddingFIFOQueue_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("PaddingFIFOQueue", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.set_attr_type("component_types", component_types::data_type())?;
        }
        {
            match self.shapes {
                None => new_op.set_attr_value_proto("shapes", &vec![10_u8, 0_u8,])?,
                Some(ref value) => (|attrs| {new_op.set_attr_shape_list("shapes", attrs)})(&value)?,
            };
        }
        {
            match self.capacity {
                None => new_op.set_attr_value_proto("capacity", &vec![24_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 1_u8,])?,
                Some(ref value) => (|attr: &i64| {new_op.set_attr_int("capacity", *attr)})(&value)?,
            };
        }
        {
            match self.container {
                None => new_op.set_attr_value_proto("container", &vec![18_u8, 0_u8,])?,
                Some(ref value) => (|attr| {new_op.set_attr_string("container", attr)})(&value)?,
            };
        }
        {
            match self.shared_name {
                None => new_op.set_attr_value_proto("shared_name", &vec![18_u8, 0_u8,])?,
                Some(ref value) => (|attr| {new_op.set_attr_string("shared_name", attr)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct PaddingFIFOQueue<component_types>
where component_types: TensorType,
      component_types: 'static,
      component_types: Clone,
{
    phantom_component_types: PhantomData<component_types>,
    shapes: Option<Vec<OtherShape>>,
    capacity: Option<i64>,
    container: Option<String>,
    shared_name: Option<String>,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<component_types> PaddingFIFOQueue<component_types>
where component_types: TensorType,
      component_types: 'static,
      component_types: Clone,
{
    pub fn handle(self) -> RefEdge<String> {
        let rc = Rc::new(self);
        {
            RefEdge::<String>::new(rc.clone(), 0)
        }
    }

    pub fn shapes(&mut self, shapes: &[OtherShape]) -> Self {
        self.shapes = Some(shapes.to_vec());
        self.clone()
    }

    pub fn capacity(&mut self, capacity: i64) -> Self {
        self.capacity = Some(capacity);
        self.clone()
    }

    pub fn container(&mut self, container: &str) -> Self {
        self.container = Some(container.to_string());
        self.clone()
    }

    pub fn shared_name(&mut self, shared_name: &str) -> Self {
        self.shared_name = Some(shared_name.to_string());
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> RefEdge<String> {
        let rc = Rc::new(self);
        {
            RefEdge::<String>::new(rc.clone(), 0)
        }
    }

    pub fn build() -> Self {
        Self {
            phantom_component_types: PhantomData,
            shapes: None,
            capacity: None,
            container: None,
            shared_name: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new() -> RefEdge<String> {
        Self {
            phantom_component_types: PhantomData,
            shapes: None,
            capacity: None,
            container: None,
            shared_name: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

pub trait con_or_DT_FLOAT_or_DT_QUINT8_or_DT_QINT32 {
}

impl con_or_DT_FLOAT_or_DT_QUINT8_or_DT_QINT32 for f32 {
}

impl con_or_DT_FLOAT_or_DT_QUINT8_or_DT_QINT32 for i32 {
}

impl con_or_DT_FLOAT_or_DT_QUINT8_or_DT_QINT32 for u8 {
}

impl<T, images_Arg, size_Arg, min_Arg, max_Arg> GraphOperation for QuantizedResizeBilinear<T, images_Arg, size_Arg, min_Arg, max_Arg>
where T: TensorType,
      T: Clone,
      images_Arg: Clone,
      images_Arg: GraphEdge<T>,
      images_Arg: 'static,
      size_Arg: Clone,
      size_Arg: GraphEdge<i32>,
      size_Arg: 'static,
      min_Arg: Clone,
      min_Arg: GraphEdge<f32>,
      min_Arg: 'static,
      max_Arg: Clone,
      max_Arg: GraphEdge<f32>,
      max_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_QUINT8_or_DT_QINT32,
      T: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("QuantizedResizeBilinear_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("QuantizedResizeBilinear", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.images)?
        }
        {
            new_op.add_edge(&self.size)?
        }
        {
            new_op.add_edge(&self.min)?
        }
        {
            new_op.add_edge(&self.max)?
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        {
            match self.align_corners {
                None => new_op.set_attr_value_proto("align_corners", &vec![40_u8, 0_u8,])?,
                Some(ref value) => (|attr: &bool| {new_op.set_attr_bool("align_corners", *attr)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct QuantizedResizeBilinear<T, images_Arg, size_Arg, min_Arg, max_Arg>
where T: TensorType,
      T: Clone,
      images_Arg: Clone,
      images_Arg: GraphEdge<T>,
      images_Arg: 'static,
      size_Arg: Clone,
      size_Arg: GraphEdge<i32>,
      size_Arg: 'static,
      min_Arg: Clone,
      min_Arg: GraphEdge<f32>,
      min_Arg: 'static,
      max_Arg: Clone,
      max_Arg: GraphEdge<f32>,
      max_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_QUINT8_or_DT_QINT32,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    images: images_Arg,
    size: size_Arg,
    min: min_Arg,
    max: max_Arg,
    align_corners: Option<bool>,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<T, images_Arg, size_Arg, min_Arg, max_Arg> QuantizedResizeBilinear<T, images_Arg, size_Arg, min_Arg, max_Arg>
where T: TensorType,
      T: Clone,
      images_Arg: Clone,
      images_Arg: GraphEdge<T>,
      images_Arg: 'static,
      size_Arg: Clone,
      size_Arg: GraphEdge<i32>,
      size_Arg: 'static,
      min_Arg: Clone,
      min_Arg: GraphEdge<f32>,
      min_Arg: 'static,
      max_Arg: Clone,
      max_Arg: GraphEdge<f32>,
      max_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_QUINT8_or_DT_QINT32,
      T: 'static,
{
    pub fn resized_images(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn out_min(self) -> Edge<f32> {
        let rc = Rc::new(self);
        {
            Edge::<f32>::new(rc.clone(), 1)
        }
    }

    pub fn out_max(self) -> Edge<f32> {
        let rc = Rc::new(self);
        {
            Edge::<f32>::new(rc.clone(), 2)
        }
    }

    pub fn align_corners(&mut self, align_corners: bool) -> Self {
        self.align_corners = Some(align_corners);
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> (Edge<T>, Edge<f32>, Edge<f32>) {
        let rc = Rc::new(self);
        (
        {
            Edge::<T>::new(rc.clone(), 0)
        },
        {
            Edge::<f32>::new(rc.clone(), 1)
        },
        {
            Edge::<f32>::new(rc.clone(), 2)
        },
        )
    }

    pub fn build(images: images_Arg, size: size_Arg, min: min_Arg, max: max_Arg) -> Self {
        Self {
            phantom_T: PhantomData,
            images,
            size,
            min,
            max,
            align_corners: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(images: images_Arg, size: size_Arg, min: min_Arg, max: max_Arg) -> (Edge<T>, Edge<f32>, Edge<f32>) {
        Self {
            phantom_T: PhantomData,
            images,
            size,
            min,
            max,
            align_corners: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<file_pattern_Arg, tensor_name_Arg, dt> GraphOperation for Restore<file_pattern_Arg, tensor_name_Arg, dt>
where file_pattern_Arg: Clone,
      file_pattern_Arg: GraphEdge<String>,
      file_pattern_Arg: 'static,
      tensor_name_Arg: Clone,
      tensor_name_Arg: GraphEdge<String>,
      tensor_name_Arg: 'static,
      dt: TensorType,
      dt: 'static,
      dt: Clone,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("Restore_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("Restore", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.file_pattern)?
        }
        {
            new_op.add_edge(&self.tensor_name)?
        }
        {
            new_op.set_attr_type("dt", dt::data_type())?;
        }
        {
            match self.preferred_shard {
                None => new_op.set_attr_value_proto("preferred_shard", &vec![24_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 1_u8,])?,
                Some(ref value) => (|attr: &i64| {new_op.set_attr_int("preferred_shard", *attr)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct Restore<file_pattern_Arg, tensor_name_Arg, dt>
where file_pattern_Arg: Clone,
      file_pattern_Arg: GraphEdge<String>,
      file_pattern_Arg: 'static,
      tensor_name_Arg: Clone,
      tensor_name_Arg: GraphEdge<String>,
      tensor_name_Arg: 'static,
      dt: TensorType,
      dt: 'static,
      dt: Clone,
{
    file_pattern: file_pattern_Arg,
    tensor_name: tensor_name_Arg,
    phantom_dt: PhantomData<dt>,
    preferred_shard: Option<i64>,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<file_pattern_Arg, tensor_name_Arg, dt> Restore<file_pattern_Arg, tensor_name_Arg, dt>
where file_pattern_Arg: Clone,
      file_pattern_Arg: GraphEdge<String>,
      file_pattern_Arg: 'static,
      tensor_name_Arg: Clone,
      tensor_name_Arg: GraphEdge<String>,
      tensor_name_Arg: 'static,
      dt: TensorType,
      dt: 'static,
      dt: Clone,
{
    pub fn tensor(self) -> Edge<dt> {
        let rc = Rc::new(self);
        {
            Edge::<dt>::new(rc.clone(), 0)
        }
    }

    pub fn preferred_shard(&mut self, preferred_shard: i64) -> Self {
        self.preferred_shard = Some(preferred_shard);
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<dt> {
        let rc = Rc::new(self);
        {
            Edge::<dt>::new(rc.clone(), 0)
        }
    }

    pub fn build(file_pattern: file_pattern_Arg, tensor_name: tensor_name_Arg) -> Self {
        Self {
            file_pattern,
            tensor_name,
            phantom_dt: PhantomData,
            preferred_shard: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(file_pattern: file_pattern_Arg, tensor_name: tensor_name_Arg) -> Edge<dt> {
        Self {
            file_pattern,
            tensor_name,
            phantom_dt: PhantomData,
            preferred_shard: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<grads_Arg, T, original_image_Arg> GraphOperation for ResizeBilinearGrad<grads_Arg, T, original_image_Arg>
where grads_Arg: Clone,
      grads_Arg: GraphEdge<f32>,
      grads_Arg: 'static,
      T: TensorType,
      T: Clone,
      original_image_Arg: Clone,
      original_image_Arg: GraphEdge<T>,
      original_image_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
      T: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("ResizeBilinearGrad_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("ResizeBilinearGrad", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.grads)?
        }
        {
            new_op.add_edge(&self.original_image)?
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        {
            match self.align_corners {
                None => new_op.set_attr_value_proto("align_corners", &vec![40_u8, 0_u8,])?,
                Some(ref value) => (|attr: &bool| {new_op.set_attr_bool("align_corners", *attr)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct ResizeBilinearGrad<grads_Arg, T, original_image_Arg>
where grads_Arg: Clone,
      grads_Arg: GraphEdge<f32>,
      grads_Arg: 'static,
      T: TensorType,
      T: Clone,
      original_image_Arg: Clone,
      original_image_Arg: GraphEdge<T>,
      original_image_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
      T: 'static,
{
    grads: grads_Arg,
    phantom_T: PhantomData<T>,
    original_image: original_image_Arg,
    align_corners: Option<bool>,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<grads_Arg, T, original_image_Arg> ResizeBilinearGrad<grads_Arg, T, original_image_Arg>
where grads_Arg: Clone,
      grads_Arg: GraphEdge<f32>,
      grads_Arg: 'static,
      T: TensorType,
      T: Clone,
      original_image_Arg: Clone,
      original_image_Arg: GraphEdge<T>,
      original_image_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
      T: 'static,
{
    pub fn output(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn align_corners(&mut self, align_corners: bool) -> Self {
        self.align_corners = Some(align_corners);
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(grads: grads_Arg, original_image: original_image_Arg) -> Self {
        Self {
            grads,
            phantom_T: PhantomData,
            original_image,
            align_corners: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(grads: grads_Arg, original_image: original_image_Arg) -> Edge<T> {
        Self {
            grads,
            phantom_T: PhantomData,
            original_image,
            align_corners: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<T, x_Arg> GraphOperation for Ceil<T, x_Arg>
where T: TensorType,
      T: Clone,
      x_Arg: Clone,
      x_Arg: GraphEdge<T>,
      x_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
      T: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("Ceil_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("Ceil", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.x)?
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct Ceil<T, x_Arg>
where T: TensorType,
      T: Clone,
      x_Arg: Clone,
      x_Arg: GraphEdge<T>,
      x_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    x: x_Arg,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<T, x_Arg> Ceil<T, x_Arg>
where T: TensorType,
      T: Clone,
      x_Arg: Clone,
      x_Arg: GraphEdge<T>,
      x_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
      T: 'static,
{
    pub fn y(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(x: x_Arg) -> Self {
        Self {
            phantom_T: PhantomData,
            x,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(x: x_Arg) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            x,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<T, images_Arg, size_Arg> GraphOperation for ResizeNearestNeighbor<T, images_Arg, size_Arg>
where T: TensorType,
      T: Clone,
      images_Arg: Clone,
      images_Arg: GraphEdge<T>,
      images_Arg: 'static,
      size_Arg: Clone,
      size_Arg: GraphEdge<i32>,
      size_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_UINT16_or_DT_HALF,
      T: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("ResizeNearestNeighbor_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("ResizeNearestNeighbor", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.images)?
        }
        {
            new_op.add_edge(&self.size)?
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        {
            match self.align_corners {
                None => new_op.set_attr_value_proto("align_corners", &vec![40_u8, 0_u8,])?,
                Some(ref value) => (|attr: &bool| {new_op.set_attr_bool("align_corners", *attr)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct ResizeNearestNeighbor<T, images_Arg, size_Arg>
where T: TensorType,
      T: Clone,
      images_Arg: Clone,
      images_Arg: GraphEdge<T>,
      images_Arg: 'static,
      size_Arg: Clone,
      size_Arg: GraphEdge<i32>,
      size_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_UINT16_or_DT_HALF,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    images: images_Arg,
    size: size_Arg,
    align_corners: Option<bool>,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<T, images_Arg, size_Arg> ResizeNearestNeighbor<T, images_Arg, size_Arg>
where T: TensorType,
      T: Clone,
      images_Arg: Clone,
      images_Arg: GraphEdge<T>,
      images_Arg: 'static,
      size_Arg: Clone,
      size_Arg: GraphEdge<i32>,
      size_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_UINT16_or_DT_HALF,
      T: 'static,
{
    pub fn resized_images(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn align_corners(&mut self, align_corners: bool) -> Self {
        self.align_corners = Some(align_corners);
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(images: images_Arg, size: size_Arg) -> Self {
        Self {
            phantom_T: PhantomData,
            images,
            size,
            align_corners: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(images: images_Arg, size: size_Arg) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            images,
            size,
            align_corners: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

pub trait con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64 for f32 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64 for f64 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64 for i16 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64 for i32 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64 for i64 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64 for i8 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64 for u8 {
}

impl<T, image_Arg, size_Arg> GraphOperation for RandomCrop<T, image_Arg, size_Arg>
where T: TensorType,
      T: Clone,
      image_Arg: Clone,
      image_Arg: GraphEdge<T>,
      image_Arg: 'static,
      size_Arg: Clone,
      size_Arg: GraphEdge<i64>,
      size_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64,
      T: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("RandomCrop_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("RandomCrop", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.image)?
        }
        {
            new_op.add_edge(&self.size)?
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        {
            match self.seed {
                None => new_op.set_attr_value_proto("seed", &vec![24_u8, 0_u8,])?,
                Some(ref value) => (|attr: &i64| {new_op.set_attr_int("seed", *attr)})(&value)?,
            };
        }
        {
            match self.seed2 {
                None => new_op.set_attr_value_proto("seed2", &vec![24_u8, 0_u8,])?,
                Some(ref value) => (|attr: &i64| {new_op.set_attr_int("seed2", *attr)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct RandomCrop<T, image_Arg, size_Arg>
where T: TensorType,
      T: Clone,
      image_Arg: Clone,
      image_Arg: GraphEdge<T>,
      image_Arg: 'static,
      size_Arg: Clone,
      size_Arg: GraphEdge<i64>,
      size_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    image: image_Arg,
    size: size_Arg,
    seed: Option<i64>,
    seed2: Option<i64>,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<T, image_Arg, size_Arg> RandomCrop<T, image_Arg, size_Arg>
where T: TensorType,
      T: Clone,
      image_Arg: Clone,
      image_Arg: GraphEdge<T>,
      image_Arg: 'static,
      size_Arg: Clone,
      size_Arg: GraphEdge<i64>,
      size_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64,
      T: 'static,
{
    pub fn output(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn seed(&mut self, seed: i64) -> Self {
        self.seed = Some(seed);
        self.clone()
    }

    pub fn seed2(&mut self, seed2: i64) -> Self {
        self.seed2 = Some(seed2);
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(image: image_Arg, size: size_Arg) -> Self {
        Self {
            phantom_T: PhantomData,
            image,
            size,
            seed: None,
            seed2: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(image: image_Arg, size: size_Arg) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            image,
            size,
            seed: None,
            seed2: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<T, tensor_Arg> GraphOperation for SerializeTensor<T, tensor_Arg>
where T: TensorType,
      T: Clone,
      tensor_Arg: Clone,
      tensor_Arg: GraphEdge<T>,
      tensor_Arg: 'static,
      T: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("SerializeTensor_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("SerializeTensor", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.tensor)?
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct SerializeTensor<T, tensor_Arg>
where T: TensorType,
      T: Clone,
      tensor_Arg: Clone,
      tensor_Arg: GraphEdge<T>,
      tensor_Arg: 'static,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    tensor: tensor_Arg,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<T, tensor_Arg> SerializeTensor<T, tensor_Arg>
where T: TensorType,
      T: Clone,
      tensor_Arg: Clone,
      tensor_Arg: GraphEdge<T>,
      tensor_Arg: 'static,
      T: 'static,
{
    pub fn serialized(self) -> Edge<String> {
        let rc = Rc::new(self);
        {
            Edge::<String>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<String> {
        let rc = Rc::new(self);
        {
            Edge::<String>::new(rc.clone(), 0)
        }
    }

    pub fn build(tensor: tensor_Arg) -> Self {
        Self {
            phantom_T: PhantomData,
            tensor,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(tensor: tensor_Arg) -> Edge<String> {
        Self {
            phantom_T: PhantomData,
            tensor,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<SrcT, x_Arg, DstT> GraphOperation for _HostCast<SrcT, x_Arg, DstT>
where SrcT: TensorType,
      SrcT: Clone,
      x_Arg: Clone,
      x_Arg: GraphEdge<SrcT>,
      x_Arg: 'static,
      DstT: TensorType,
      SrcT: 'static,
      DstT: 'static,
      DstT: Clone,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("_HostCast_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("_HostCast", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.x)?
        }
        {
            new_op.set_attr_type("SrcT", SrcT::data_type())?;
        }
        {
            new_op.set_attr_type("DstT", DstT::data_type())?;
        }
        {
            match self.Truncate {
                None => new_op.set_attr_value_proto("Truncate", &vec![40_u8, 0_u8,])?,
                Some(ref value) => (|attr: &bool| {new_op.set_attr_bool("Truncate", *attr)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct _HostCast<SrcT, x_Arg, DstT>
where SrcT: TensorType,
      SrcT: Clone,
      x_Arg: Clone,
      x_Arg: GraphEdge<SrcT>,
      x_Arg: 'static,
      DstT: TensorType,
      SrcT: 'static,
      DstT: 'static,
      DstT: Clone,
{
    phantom_SrcT: PhantomData<SrcT>,
    x: x_Arg,
    phantom_DstT: PhantomData<DstT>,
    Truncate: Option<bool>,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<SrcT, x_Arg, DstT> _HostCast<SrcT, x_Arg, DstT>
where SrcT: TensorType,
      SrcT: Clone,
      x_Arg: Clone,
      x_Arg: GraphEdge<SrcT>,
      x_Arg: 'static,
      DstT: TensorType,
      SrcT: 'static,
      DstT: 'static,
      DstT: Clone,
{
    pub fn y(self) -> Edge<DstT> {
        let rc = Rc::new(self);
        {
            Edge::<DstT>::new(rc.clone(), 0)
        }
    }

    pub fn Truncate(&mut self, Truncate: bool) -> Self {
        self.Truncate = Some(Truncate);
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<DstT> {
        let rc = Rc::new(self);
        {
            Edge::<DstT>::new(rc.clone(), 0)
        }
    }

    pub fn build(x: x_Arg) -> Self {
        Self {
            phantom_SrcT: PhantomData,
            x,
            phantom_DstT: PhantomData,
            Truncate: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(x: x_Arg) -> Edge<DstT> {
        Self {
            phantom_SrcT: PhantomData,
            x,
            phantom_DstT: PhantomData,
            Truncate: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<T, logits_Arg, num_samples_Arg, output_dtype> GraphOperation for Multinomial<T, logits_Arg, num_samples_Arg, output_dtype>
where T: TensorType,
      T: Clone,
      logits_Arg: Clone,
      logits_Arg: GraphEdge<T>,
      logits_Arg: 'static,
      num_samples_Arg: Clone,
      num_samples_Arg: GraphEdge<i32>,
      num_samples_Arg: 'static,
      output_dtype: TensorType,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
      output_dtype: con_or_DT_INT32_or_DT_INT64,
      output_dtype: 'static,
      output_dtype: Clone,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("Multinomial_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("Multinomial", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.logits)?
        }
        {
            new_op.add_edge(&self.num_samples)?
        }
        {
            match self.seed {
                None => new_op.set_attr_value_proto("seed", &vec![24_u8, 0_u8,])?,
                Some(ref value) => (|attr: &i64| {new_op.set_attr_int("seed", *attr)})(&value)?,
            };
        }
        {
            match self.seed2 {
                None => new_op.set_attr_value_proto("seed2", &vec![24_u8, 0_u8,])?,
                Some(ref value) => (|attr: &i64| {new_op.set_attr_int("seed2", *attr)})(&value)?,
            };
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        {
            new_op.set_attr_type("output_dtype", output_dtype::data_type())?;
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct Multinomial<T, logits_Arg, num_samples_Arg, output_dtype>
where T: TensorType,
      T: Clone,
      logits_Arg: Clone,
      logits_Arg: GraphEdge<T>,
      logits_Arg: 'static,
      num_samples_Arg: Clone,
      num_samples_Arg: GraphEdge<i32>,
      num_samples_Arg: 'static,
      output_dtype: TensorType,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
      output_dtype: con_or_DT_INT32_or_DT_INT64,
      output_dtype: 'static,
      output_dtype: Clone,
{
    phantom_T: PhantomData<T>,
    logits: logits_Arg,
    num_samples: num_samples_Arg,
    seed: Option<i64>,
    seed2: Option<i64>,
    phantom_output_dtype: PhantomData<output_dtype>,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<T, logits_Arg, num_samples_Arg, output_dtype> Multinomial<T, logits_Arg, num_samples_Arg, output_dtype>
where T: TensorType,
      T: Clone,
      logits_Arg: Clone,
      logits_Arg: GraphEdge<T>,
      logits_Arg: 'static,
      num_samples_Arg: Clone,
      num_samples_Arg: GraphEdge<i32>,
      num_samples_Arg: 'static,
      output_dtype: TensorType,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
      output_dtype: con_or_DT_INT32_or_DT_INT64,
      output_dtype: 'static,
      output_dtype: Clone,
{
    pub fn output(self) -> Edge<output_dtype> {
        let rc = Rc::new(self);
        {
            Edge::<output_dtype>::new(rc.clone(), 0)
        }
    }

    pub fn seed(&mut self, seed: i64) -> Self {
        self.seed = Some(seed);
        self.clone()
    }

    pub fn seed2(&mut self, seed2: i64) -> Self {
        self.seed2 = Some(seed2);
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<output_dtype> {
        let rc = Rc::new(self);
        {
            Edge::<output_dtype>::new(rc.clone(), 0)
        }
    }

    pub fn build(logits: logits_Arg, num_samples: num_samples_Arg) -> Self {
        Self {
            phantom_T: PhantomData,
            logits,
            num_samples,
            seed: None,
            seed2: None,
            phantom_output_dtype: PhantomData,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(logits: logits_Arg, num_samples: num_samples_Arg) -> Edge<output_dtype> {
        Self {
            phantom_T: PhantomData,
            logits,
            num_samples,
            seed: None,
            seed2: None,
            phantom_output_dtype: PhantomData,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<image_Arg> GraphOperation for EncodeJpeg<image_Arg>
where image_Arg: Clone,
      image_Arg: GraphEdge<u8>,
      image_Arg: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("EncodeJpeg_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("EncodeJpeg", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.image)?
        }
        {
            match self.format {
                None => new_op.set_attr_value_proto("format", &vec![18_u8, 0_u8,])?,
                Some(ref value) => (|attr| {new_op.set_attr_string("format", attr)})(&value)?,
            };
        }
        {
            match self.quality {
                None => new_op.set_attr_value_proto("quality", &vec![24_u8, 95_u8,])?,
                Some(ref value) => (|attr: &i64| {new_op.set_attr_int("quality", *attr)})(&value)?,
            };
        }
        {
            match self.progressive {
                None => new_op.set_attr_value_proto("progressive", &vec![40_u8, 0_u8,])?,
                Some(ref value) => (|attr: &bool| {new_op.set_attr_bool("progressive", *attr)})(&value)?,
            };
        }
        {
            match self.optimize_size {
                None => new_op.set_attr_value_proto("optimize_size", &vec![40_u8, 0_u8,])?,
                Some(ref value) => (|attr: &bool| {new_op.set_attr_bool("optimize_size", *attr)})(&value)?,
            };
        }
        {
            match self.chroma_downsampling {
                None => new_op.set_attr_value_proto("chroma_downsampling", &vec![40_u8, 1_u8,])?,
                Some(ref value) => (|attr: &bool| {new_op.set_attr_bool("chroma_downsampling", *attr)})(&value)?,
            };
        }
        {
            match self.density_unit {
                None => new_op.set_attr_value_proto("density_unit", &vec![18_u8, 2_u8, 105_u8, 110_u8,])?,
                Some(ref value) => (|attr| {new_op.set_attr_string("density_unit", attr)})(&value)?,
            };
        }
        {
            match self.x_density {
                None => new_op.set_attr_value_proto("x_density", &vec![24_u8, 172_u8, 2_u8,])?,
                Some(ref value) => (|attr: &i64| {new_op.set_attr_int("x_density", *attr)})(&value)?,
            };
        }
        {
            match self.y_density {
                None => new_op.set_attr_value_proto("y_density", &vec![24_u8, 172_u8, 2_u8,])?,
                Some(ref value) => (|attr: &i64| {new_op.set_attr_int("y_density", *attr)})(&value)?,
            };
        }
        {
            match self.xmp_metadata {
                None => new_op.set_attr_value_proto("xmp_metadata", &vec![18_u8, 0_u8,])?,
                Some(ref value) => (|attr| {new_op.set_attr_string("xmp_metadata", attr)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct EncodeJpeg<image_Arg>
where image_Arg: Clone,
      image_Arg: GraphEdge<u8>,
      image_Arg: 'static,
{
    image: image_Arg,
    format: Option<String>,
    quality: Option<i64>,
    progressive: Option<bool>,
    optimize_size: Option<bool>,
    chroma_downsampling: Option<bool>,
    density_unit: Option<String>,
    x_density: Option<i64>,
    y_density: Option<i64>,
    xmp_metadata: Option<String>,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<image_Arg> EncodeJpeg<image_Arg>
where image_Arg: Clone,
      image_Arg: GraphEdge<u8>,
      image_Arg: 'static,
{
    pub fn contents(self) -> Edge<String> {
        let rc = Rc::new(self);
        {
            Edge::<String>::new(rc.clone(), 0)
        }
    }

    pub fn format(&mut self, format: &str) -> Self {
        self.format = Some(format.to_string());
        self.clone()
    }

    pub fn quality(&mut self, quality: i64) -> Self {
        self.quality = Some(quality);
        self.clone()
    }

    pub fn progressive(&mut self, progressive: bool) -> Self {
        self.progressive = Some(progressive);
        self.clone()
    }

    pub fn optimize_size(&mut self, optimize_size: bool) -> Self {
        self.optimize_size = Some(optimize_size);
        self.clone()
    }

    pub fn chroma_downsampling(&mut self, chroma_downsampling: bool) -> Self {
        self.chroma_downsampling = Some(chroma_downsampling);
        self.clone()
    }

    pub fn density_unit(&mut self, density_unit: &str) -> Self {
        self.density_unit = Some(density_unit.to_string());
        self.clone()
    }

    pub fn x_density(&mut self, x_density: i64) -> Self {
        self.x_density = Some(x_density);
        self.clone()
    }

    pub fn y_density(&mut self, y_density: i64) -> Self {
        self.y_density = Some(y_density);
        self.clone()
    }

    pub fn xmp_metadata(&mut self, xmp_metadata: &str) -> Self {
        self.xmp_metadata = Some(xmp_metadata.to_string());
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<String> {
        let rc = Rc::new(self);
        {
            Edge::<String>::new(rc.clone(), 0)
        }
    }

    pub fn build(image: image_Arg) -> Self {
        Self {
            image,
            format: None,
            quality: None,
            progressive: None,
            optimize_size: None,
            chroma_downsampling: None,
            density_unit: None,
            x_density: None,
            y_density: None,
            xmp_metadata: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(image: image_Arg) -> Edge<String> {
        Self {
            image,
            format: None,
            quality: None,
            progressive: None,
            optimize_size: None,
            chroma_downsampling: None,
            density_unit: None,
            x_density: None,
            y_density: None,
            xmp_metadata: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<T, t_Arg, m_Arg, v_Arg, gamma_Arg, backprop_Arg> GraphOperation for BatchNormWithGlobalNormalizationGrad<T, t_Arg, m_Arg, v_Arg, gamma_Arg, backprop_Arg>
where T: TensorType,
      T: Clone,
      t_Arg: Clone,
      t_Arg: GraphEdge<T>,
      t_Arg: 'static,
      m_Arg: Clone,
      m_Arg: GraphEdge<T>,
      m_Arg: 'static,
      v_Arg: Clone,
      v_Arg: GraphEdge<T>,
      v_Arg: 'static,
      gamma_Arg: Clone,
      gamma_Arg: GraphEdge<T>,
      gamma_Arg: 'static,
      backprop_Arg: Clone,
      backprop_Arg: GraphEdge<T>,
      backprop_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("BatchNormWithGlobalNormalizationGrad_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("BatchNormWithGlobalNormalizationGrad", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.t)?
        }
        {
            new_op.add_edge(&self.m)?
        }
        {
            new_op.add_edge(&self.v)?
        }
        {
            new_op.add_edge(&self.gamma)?
        }
        {
            new_op.add_edge(&self.backprop)?
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        {
            (|attr: &f32| {new_op.set_attr_float("variance_epsilon", *attr)})(&self.variance_epsilon)?
        }
        {
            (|attr: &bool| {new_op.set_attr_bool("scale_after_normalization", *attr)})(&self.scale_after_normalization)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct BatchNormWithGlobalNormalizationGrad<T, t_Arg, m_Arg, v_Arg, gamma_Arg, backprop_Arg>
where T: TensorType,
      T: Clone,
      t_Arg: Clone,
      t_Arg: GraphEdge<T>,
      t_Arg: 'static,
      m_Arg: Clone,
      m_Arg: GraphEdge<T>,
      m_Arg: 'static,
      v_Arg: Clone,
      v_Arg: GraphEdge<T>,
      v_Arg: 'static,
      gamma_Arg: Clone,
      gamma_Arg: GraphEdge<T>,
      gamma_Arg: 'static,
      backprop_Arg: Clone,
      backprop_Arg: GraphEdge<T>,
      backprop_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    t: t_Arg,
    m: m_Arg,
    v: v_Arg,
    gamma: gamma_Arg,
    backprop: backprop_Arg,
    variance_epsilon: f32,
    scale_after_normalization: bool,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<T, t_Arg, m_Arg, v_Arg, gamma_Arg, backprop_Arg> BatchNormWithGlobalNormalizationGrad<T, t_Arg, m_Arg, v_Arg, gamma_Arg, backprop_Arg>
where T: TensorType,
      T: Clone,
      t_Arg: Clone,
      t_Arg: GraphEdge<T>,
      t_Arg: 'static,
      m_Arg: Clone,
      m_Arg: GraphEdge<T>,
      m_Arg: 'static,
      v_Arg: Clone,
      v_Arg: GraphEdge<T>,
      v_Arg: 'static,
      gamma_Arg: Clone,
      gamma_Arg: GraphEdge<T>,
      gamma_Arg: 'static,
      backprop_Arg: Clone,
      backprop_Arg: GraphEdge<T>,
      backprop_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
{
    pub fn dx(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn dm(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 1)
        }
    }

    pub fn dv(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 2)
        }
    }

    pub fn db(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 3)
        }
    }

    pub fn dg(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 4)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> (Edge<T>, Edge<T>, Edge<T>, Edge<T>, Edge<T>) {
        let rc = Rc::new(self);
        (
        {
            Edge::<T>::new(rc.clone(), 0)
        },
        {
            Edge::<T>::new(rc.clone(), 1)
        },
        {
            Edge::<T>::new(rc.clone(), 2)
        },
        {
            Edge::<T>::new(rc.clone(), 3)
        },
        {
            Edge::<T>::new(rc.clone(), 4)
        },
        )
    }

    pub fn build(t: t_Arg, m: m_Arg, v: v_Arg, gamma: gamma_Arg, backprop: backprop_Arg, variance_epsilon: f32, scale_after_normalization: bool) -> Self {
        Self {
            phantom_T: PhantomData,
            t,
            m,
            v,
            gamma,
            backprop,
            variance_epsilon: variance_epsilon,
            scale_after_normalization: scale_after_normalization,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(t: t_Arg, m: m_Arg, v: v_Arg, gamma: gamma_Arg, backprop: backprop_Arg, variance_epsilon: f32, scale_after_normalization: bool) -> (Edge<T>, Edge<T>, Edge<T>, Edge<T>, Edge<T>) {
        Self {
            phantom_T: PhantomData,
            t,
            m,
            v,
            gamma,
            backprop,
            variance_epsilon: variance_epsilon,
            scale_after_normalization: scale_after_normalization,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<images_Arg, contrast_factor_Arg> GraphOperation for AdjustContrastv2<images_Arg, contrast_factor_Arg>
where images_Arg: Clone,
      images_Arg: GraphEdge<f32>,
      images_Arg: 'static,
      contrast_factor_Arg: Clone,
      contrast_factor_Arg: GraphEdge<f32>,
      contrast_factor_Arg: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("AdjustContrastv2_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("AdjustContrastv2", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.images)?
        }
        {
            new_op.add_edge(&self.contrast_factor)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct AdjustContrastv2<images_Arg, contrast_factor_Arg>
where images_Arg: Clone,
      images_Arg: GraphEdge<f32>,
      images_Arg: 'static,
      contrast_factor_Arg: Clone,
      contrast_factor_Arg: GraphEdge<f32>,
      contrast_factor_Arg: 'static,
{
    images: images_Arg,
    contrast_factor: contrast_factor_Arg,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<images_Arg, contrast_factor_Arg> AdjustContrastv2<images_Arg, contrast_factor_Arg>
where images_Arg: Clone,
      images_Arg: GraphEdge<f32>,
      images_Arg: 'static,
      contrast_factor_Arg: Clone,
      contrast_factor_Arg: GraphEdge<f32>,
      contrast_factor_Arg: 'static,
{
    pub fn output(self) -> Edge<f32> {
        let rc = Rc::new(self);
        {
            Edge::<f32>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<f32> {
        let rc = Rc::new(self);
        {
            Edge::<f32>::new(rc.clone(), 0)
        }
    }

    pub fn build(images: images_Arg, contrast_factor: contrast_factor_Arg) -> Self {
        Self {
            images,
            contrast_factor,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(images: images_Arg, contrast_factor: contrast_factor_Arg) -> Edge<f32> {
        Self {
            images,
            contrast_factor,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

pub trait con_or_DT_UINT8_or_DT_UINT16 {
}

impl con_or_DT_UINT8_or_DT_UINT16 for u16 {
}

impl con_or_DT_UINT8_or_DT_UINT16 for u8 {
}

impl<contents_Arg, dtype> GraphOperation for DecodePng<contents_Arg, dtype>
where contents_Arg: Clone,
      contents_Arg: GraphEdge<String>,
      contents_Arg: 'static,
      dtype: TensorType,
      dtype: con_or_DT_UINT8_or_DT_UINT16,
      dtype: 'static,
      dtype: Clone,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("DecodePng_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("DecodePng", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.contents)?
        }
        {
            match self.channels {
                None => new_op.set_attr_value_proto("channels", &vec![24_u8, 0_u8,])?,
                Some(ref value) => (|attr: &i64| {new_op.set_attr_int("channels", *attr)})(&value)?,
            };
        }
        {
            new_op.set_attr_type("dtype", dtype::data_type())?;
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct DecodePng<contents_Arg, dtype>
where contents_Arg: Clone,
      contents_Arg: GraphEdge<String>,
      contents_Arg: 'static,
      dtype: TensorType,
      dtype: con_or_DT_UINT8_or_DT_UINT16,
      dtype: 'static,
      dtype: Clone,
{
    contents: contents_Arg,
    channels: Option<i64>,
    phantom_dtype: PhantomData<dtype>,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<contents_Arg, dtype> DecodePng<contents_Arg, dtype>
where contents_Arg: Clone,
      contents_Arg: GraphEdge<String>,
      contents_Arg: 'static,
      dtype: TensorType,
      dtype: con_or_DT_UINT8_or_DT_UINT16,
      dtype: 'static,
      dtype: Clone,
{
    pub fn image(self) -> Edge<dtype> {
        let rc = Rc::new(self);
        {
            Edge::<dtype>::new(rc.clone(), 0)
        }
    }

    pub fn channels(&mut self, channels: i64) -> Self {
        self.channels = Some(channels);
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<dtype> {
        let rc = Rc::new(self);
        {
            Edge::<dtype>::new(rc.clone(), 0)
        }
    }

    pub fn build(contents: contents_Arg) -> Self {
        Self {
            contents,
            channels: None,
            phantom_dtype: PhantomData,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(contents: contents_Arg) -> Edge<dtype> {
        Self {
            contents,
            channels: None,
            phantom_dtype: PhantomData,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<T, var_Arg, accum_Arg, lr_Arg, l1_Arg, l2_Arg, grad_Arg> GraphOperation for ApplyProximalAdagrad<T, var_Arg, accum_Arg, lr_Arg, l1_Arg, l2_Arg, grad_Arg>
where T: TensorType,
      T: Clone,
      var_Arg: Clone,
      var_Arg: GraphRefEdge<T>,
      var_Arg: 'static,
      accum_Arg: Clone,
      accum_Arg: GraphRefEdge<T>,
      accum_Arg: 'static,
      lr_Arg: Clone,
      lr_Arg: GraphEdge<T>,
      lr_Arg: 'static,
      l1_Arg: Clone,
      l1_Arg: GraphEdge<T>,
      l1_Arg: 'static,
      l2_Arg: Clone,
      l2_Arg: GraphEdge<T>,
      l2_Arg: 'static,
      grad_Arg: Clone,
      grad_Arg: GraphEdge<T>,
      grad_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("ApplyProximalAdagrad_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("ApplyProximalAdagrad", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.var)?
        }
        {
            new_op.add_edge(&self.accum)?
        }
        {
            new_op.add_edge(&self.lr)?
        }
        {
            new_op.add_edge(&self.l1)?
        }
        {
            new_op.add_edge(&self.l2)?
        }
        {
            new_op.add_edge(&self.grad)?
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        {
            match self.use_locking {
                None => new_op.set_attr_value_proto("use_locking", &vec![40_u8, 0_u8,])?,
                Some(ref value) => (|attr: &bool| {new_op.set_attr_bool("use_locking", *attr)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct ApplyProximalAdagrad<T, var_Arg, accum_Arg, lr_Arg, l1_Arg, l2_Arg, grad_Arg>
where T: TensorType,
      T: Clone,
      var_Arg: Clone,
      var_Arg: GraphRefEdge<T>,
      var_Arg: 'static,
      accum_Arg: Clone,
      accum_Arg: GraphRefEdge<T>,
      accum_Arg: 'static,
      lr_Arg: Clone,
      lr_Arg: GraphEdge<T>,
      lr_Arg: 'static,
      l1_Arg: Clone,
      l1_Arg: GraphEdge<T>,
      l1_Arg: 'static,
      l2_Arg: Clone,
      l2_Arg: GraphEdge<T>,
      l2_Arg: 'static,
      grad_Arg: Clone,
      grad_Arg: GraphEdge<T>,
      grad_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    var: var_Arg,
    accum: accum_Arg,
    lr: lr_Arg,
    l1: l1_Arg,
    l2: l2_Arg,
    grad: grad_Arg,
    use_locking: Option<bool>,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<T, var_Arg, accum_Arg, lr_Arg, l1_Arg, l2_Arg, grad_Arg> ApplyProximalAdagrad<T, var_Arg, accum_Arg, lr_Arg, l1_Arg, l2_Arg, grad_Arg>
where T: TensorType,
      T: Clone,
      var_Arg: Clone,
      var_Arg: GraphRefEdge<T>,
      var_Arg: 'static,
      accum_Arg: Clone,
      accum_Arg: GraphRefEdge<T>,
      accum_Arg: 'static,
      lr_Arg: Clone,
      lr_Arg: GraphEdge<T>,
      lr_Arg: 'static,
      l1_Arg: Clone,
      l1_Arg: GraphEdge<T>,
      l1_Arg: 'static,
      l2_Arg: Clone,
      l2_Arg: GraphEdge<T>,
      l2_Arg: 'static,
      grad_Arg: Clone,
      grad_Arg: GraphEdge<T>,
      grad_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
{
    pub fn out(self) -> RefEdge<T> {
        let rc = Rc::new(self);
        {
            RefEdge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn use_locking(&mut self, use_locking: bool) -> Self {
        self.use_locking = Some(use_locking);
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> RefEdge<T> {
        let rc = Rc::new(self);
        {
            RefEdge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(var: var_Arg, accum: accum_Arg, lr: lr_Arg, l1: l1_Arg, l2: l2_Arg, grad: grad_Arg) -> Self {
        Self {
            phantom_T: PhantomData,
            var,
            accum,
            lr,
            l1,
            l2,
            grad,
            use_locking: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(var: var_Arg, accum: accum_Arg, lr: lr_Arg, l1: l1_Arg, l2: l2_Arg, grad: grad_Arg) -> RefEdge<T> {
        Self {
            phantom_T: PhantomData,
            var,
            accum,
            lr,
            l1,
            l2,
            grad,
            use_locking: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<T, x_Arg, y_Arg> GraphOperation for BitwiseOr<T, x_Arg, y_Arg>
where T: TensorType,
      T: Clone,
      x_Arg: Clone,
      x_Arg: GraphEdge<T>,
      x_Arg: 'static,
      y_Arg: Clone,
      y_Arg: GraphEdge<T>,
      y_Arg: 'static,
      T: con_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_UINT16_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("BitwiseOr_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("BitwiseOr", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.x)?
        }
        {
            new_op.add_edge(&self.y)?
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct BitwiseOr<T, x_Arg, y_Arg>
where T: TensorType,
      T: Clone,
      x_Arg: Clone,
      x_Arg: GraphEdge<T>,
      x_Arg: 'static,
      y_Arg: Clone,
      y_Arg: GraphEdge<T>,
      y_Arg: 'static,
      T: con_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_UINT16_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    x: x_Arg,
    y: y_Arg,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<T, x_Arg, y_Arg> BitwiseOr<T, x_Arg, y_Arg>
where T: TensorType,
      T: Clone,
      x_Arg: Clone,
      x_Arg: GraphEdge<T>,
      x_Arg: 'static,
      y_Arg: Clone,
      y_Arg: GraphEdge<T>,
      y_Arg: 'static,
      T: con_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_UINT16_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
{
    pub fn z(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(x: x_Arg, y: y_Arg) -> Self {
        Self {
            phantom_T: PhantomData,
            x,
            y,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(x: x_Arg, y: y_Arg) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            x,
            y,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<T, matrix_Arg, rhs_Arg, l2_regularizer_Arg> GraphOperation for MatrixSolveLs<T, matrix_Arg, rhs_Arg, l2_regularizer_Arg>
where T: TensorType,
      T: Clone,
      matrix_Arg: Clone,
      matrix_Arg: GraphEdge<T>,
      matrix_Arg: 'static,
      rhs_Arg: Clone,
      rhs_Arg: GraphEdge<T>,
      rhs_Arg: 'static,
      l2_regularizer_Arg: Clone,
      l2_regularizer_Arg: GraphEdge<f64>,
      l2_regularizer_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_COMPLEX64_or_DT_COMPLEX128,
      T: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("MatrixSolveLs_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("MatrixSolveLs", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.matrix)?
        }
        {
            new_op.add_edge(&self.rhs)?
        }
        {
            new_op.add_edge(&self.l2_regularizer)?
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        {
            match self.fast {
                None => new_op.set_attr_value_proto("fast", &vec![40_u8, 1_u8,])?,
                Some(ref value) => (|attr: &bool| {new_op.set_attr_bool("fast", *attr)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct MatrixSolveLs<T, matrix_Arg, rhs_Arg, l2_regularizer_Arg>
where T: TensorType,
      T: Clone,
      matrix_Arg: Clone,
      matrix_Arg: GraphEdge<T>,
      matrix_Arg: 'static,
      rhs_Arg: Clone,
      rhs_Arg: GraphEdge<T>,
      rhs_Arg: 'static,
      l2_regularizer_Arg: Clone,
      l2_regularizer_Arg: GraphEdge<f64>,
      l2_regularizer_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_COMPLEX64_or_DT_COMPLEX128,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    matrix: matrix_Arg,
    rhs: rhs_Arg,
    l2_regularizer: l2_regularizer_Arg,
    fast: Option<bool>,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<T, matrix_Arg, rhs_Arg, l2_regularizer_Arg> MatrixSolveLs<T, matrix_Arg, rhs_Arg, l2_regularizer_Arg>
where T: TensorType,
      T: Clone,
      matrix_Arg: Clone,
      matrix_Arg: GraphEdge<T>,
      matrix_Arg: 'static,
      rhs_Arg: Clone,
      rhs_Arg: GraphEdge<T>,
      rhs_Arg: 'static,
      l2_regularizer_Arg: Clone,
      l2_regularizer_Arg: GraphEdge<f64>,
      l2_regularizer_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_COMPLEX64_or_DT_COMPLEX128,
      T: 'static,
{
    pub fn output(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn fast(&mut self, fast: bool) -> Self {
        self.fast = Some(fast);
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(matrix: matrix_Arg, rhs: rhs_Arg, l2_regularizer: l2_regularizer_Arg) -> Self {
        Self {
            phantom_T: PhantomData,
            matrix,
            rhs,
            l2_regularizer,
            fast: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(matrix: matrix_Arg, rhs: rhs_Arg, l2_regularizer: l2_regularizer_Arg) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            matrix,
            rhs,
            l2_regularizer,
            fast: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

pub trait con_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64 {
}

impl con_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64 for i16 {
}

impl con_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64 for i32 {
}

impl con_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64 for i64 {
}

impl con_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64 for i8 {
}

impl con_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64 for u8 {
}

impl<T, image_size_Arg, bounding_boxes_Arg> GraphOperation for SampleDistortedBoundingBox<T, image_size_Arg, bounding_boxes_Arg>
where T: TensorType,
      T: Clone,
      image_size_Arg: Clone,
      image_size_Arg: GraphEdge<T>,
      image_size_Arg: 'static,
      bounding_boxes_Arg: Clone,
      bounding_boxes_Arg: GraphEdge<f32>,
      bounding_boxes_Arg: 'static,
      T: con_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64,
      T: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("SampleDistortedBoundingBox_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("SampleDistortedBoundingBox", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.image_size)?
        }
        {
            new_op.add_edge(&self.bounding_boxes)?
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        {
            match self.seed {
                None => new_op.set_attr_value_proto("seed", &vec![24_u8, 0_u8,])?,
                Some(ref value) => (|attr: &i64| {new_op.set_attr_int("seed", *attr)})(&value)?,
            };
        }
        {
            match self.seed2 {
                None => new_op.set_attr_value_proto("seed2", &vec![24_u8, 0_u8,])?,
                Some(ref value) => (|attr: &i64| {new_op.set_attr_int("seed2", *attr)})(&value)?,
            };
        }
        {
            match self.min_object_covered {
                None => new_op.set_attr_value_proto("min_object_covered", &vec![37_u8, 205_u8, 204_u8, 204_u8, 61_u8,])?,
                Some(ref value) => (|attr: &f32| {new_op.set_attr_float("min_object_covered", *attr)})(&value)?,
            };
        }
        {
            match self.aspect_ratio_range {
                None => new_op.set_attr_value_proto("aspect_ratio_range", &vec![10_u8, 0_u8, 34_u8, 8_u8, 0_u8, 0_u8, 64_u8, 63_u8,])?,
                Some(ref value) => (|attrs| {new_op.set_attr_float_list("aspect_ratio_range", attrs)})(&value)?,
            };
        }
        {
            match self.area_range {
                None => new_op.set_attr_value_proto("area_range", &vec![10_u8, 0_u8, 34_u8, 8_u8, 205_u8, 204_u8, 76_u8, 61_u8,])?,
                Some(ref value) => (|attrs| {new_op.set_attr_float_list("area_range", attrs)})(&value)?,
            };
        }
        {
            match self.max_attempts {
                None => new_op.set_attr_value_proto("max_attempts", &vec![24_u8, 100_u8,])?,
                Some(ref value) => (|attr: &i64| {new_op.set_attr_int("max_attempts", *attr)})(&value)?,
            };
        }
        {
            match self.use_image_if_no_bounding_boxes {
                None => new_op.set_attr_value_proto("use_image_if_no_bounding_boxes", &vec![40_u8, 0_u8,])?,
                Some(ref value) => (|attr: &bool| {new_op.set_attr_bool("use_image_if_no_bounding_boxes", *attr)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct SampleDistortedBoundingBox<T, image_size_Arg, bounding_boxes_Arg>
where T: TensorType,
      T: Clone,
      image_size_Arg: Clone,
      image_size_Arg: GraphEdge<T>,
      image_size_Arg: 'static,
      bounding_boxes_Arg: Clone,
      bounding_boxes_Arg: GraphEdge<f32>,
      bounding_boxes_Arg: 'static,
      T: con_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    image_size: image_size_Arg,
    bounding_boxes: bounding_boxes_Arg,
    seed: Option<i64>,
    seed2: Option<i64>,
    min_object_covered: Option<f32>,
    aspect_ratio_range: Option<Vec<f32>>,
    area_range: Option<Vec<f32>>,
    max_attempts: Option<i64>,
    use_image_if_no_bounding_boxes: Option<bool>,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<T, image_size_Arg, bounding_boxes_Arg> SampleDistortedBoundingBox<T, image_size_Arg, bounding_boxes_Arg>
where T: TensorType,
      T: Clone,
      image_size_Arg: Clone,
      image_size_Arg: GraphEdge<T>,
      image_size_Arg: 'static,
      bounding_boxes_Arg: Clone,
      bounding_boxes_Arg: GraphEdge<f32>,
      bounding_boxes_Arg: 'static,
      T: con_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64,
      T: 'static,
{
    pub fn begin(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn size(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 1)
        }
    }

    pub fn bboxes(self) -> Edge<f32> {
        let rc = Rc::new(self);
        {
            Edge::<f32>::new(rc.clone(), 2)
        }
    }

    pub fn seed(&mut self, seed: i64) -> Self {
        self.seed = Some(seed);
        self.clone()
    }

    pub fn seed2(&mut self, seed2: i64) -> Self {
        self.seed2 = Some(seed2);
        self.clone()
    }

    pub fn min_object_covered(&mut self, min_object_covered: f32) -> Self {
        self.min_object_covered = Some(min_object_covered);
        self.clone()
    }

    pub fn aspect_ratio_range(&mut self, aspect_ratio_range: &[f32]) -> Self {
        self.aspect_ratio_range = Some(aspect_ratio_range.to_vec());
        self.clone()
    }

    pub fn area_range(&mut self, area_range: &[f32]) -> Self {
        self.area_range = Some(area_range.to_vec());
        self.clone()
    }

    pub fn max_attempts(&mut self, max_attempts: i64) -> Self {
        self.max_attempts = Some(max_attempts);
        self.clone()
    }

    pub fn use_image_if_no_bounding_boxes(&mut self, use_image_if_no_bounding_boxes: bool) -> Self {
        self.use_image_if_no_bounding_boxes = Some(use_image_if_no_bounding_boxes);
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> (Edge<T>, Edge<T>, Edge<f32>) {
        let rc = Rc::new(self);
        (
        {
            Edge::<T>::new(rc.clone(), 0)
        },
        {
            Edge::<T>::new(rc.clone(), 1)
        },
        {
            Edge::<f32>::new(rc.clone(), 2)
        },
        )
    }

    pub fn build(image_size: image_size_Arg, bounding_boxes: bounding_boxes_Arg) -> Self {
        Self {
            phantom_T: PhantomData,
            image_size,
            bounding_boxes,
            seed: None,
            seed2: None,
            min_object_covered: None,
            aspect_ratio_range: None,
            area_range: None,
            max_attempts: None,
            use_image_if_no_bounding_boxes: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(image_size: image_size_Arg, bounding_boxes: bounding_boxes_Arg) -> (Edge<T>, Edge<T>, Edge<f32>) {
        Self {
            phantom_T: PhantomData,
            image_size,
            bounding_boxes,
            seed: None,
            seed2: None,
            min_object_covered: None,
            aspect_ratio_range: None,
            area_range: None,
            max_attempts: None,
            use_image_if_no_bounding_boxes: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<T, x_Arg, y_Arg> GraphOperation for Greater<T, x_Arg, y_Arg>
where T: TensorType,
      T: Clone,
      x_Arg: Clone,
      x_Arg: GraphEdge<T>,
      x_Arg: 'static,
      y_Arg: Clone,
      y_Arg: GraphEdge<T>,
      y_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("Greater_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("Greater", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.x)?
        }
        {
            new_op.add_edge(&self.y)?
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct Greater<T, x_Arg, y_Arg>
where T: TensorType,
      T: Clone,
      x_Arg: Clone,
      x_Arg: GraphEdge<T>,
      x_Arg: 'static,
      y_Arg: Clone,
      y_Arg: GraphEdge<T>,
      y_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    x: x_Arg,
    y: y_Arg,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<T, x_Arg, y_Arg> Greater<T, x_Arg, y_Arg>
where T: TensorType,
      T: Clone,
      x_Arg: Clone,
      x_Arg: GraphEdge<T>,
      x_Arg: 'static,
      y_Arg: Clone,
      y_Arg: GraphEdge<T>,
      y_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
{
    pub fn z(self) -> Edge<bool> {
        let rc = Rc::new(self);
        {
            Edge::<bool>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<bool> {
        let rc = Rc::new(self);
        {
            Edge::<bool>::new(rc.clone(), 0)
        }
    }

    pub fn build(x: x_Arg, y: y_Arg) -> Self {
        Self {
            phantom_T: PhantomData,
            x,
            y,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(x: x_Arg, y: y_Arg) -> Edge<bool> {
        Self {
            phantom_T: PhantomData,
            x,
            y,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<T, image_size_Arg, bounding_boxes_Arg, min_object_covered_Arg> GraphOperation for SampleDistortedBoundingBoxV2<T, image_size_Arg, bounding_boxes_Arg, min_object_covered_Arg>
where T: TensorType,
      T: Clone,
      image_size_Arg: Clone,
      image_size_Arg: GraphEdge<T>,
      image_size_Arg: 'static,
      bounding_boxes_Arg: Clone,
      bounding_boxes_Arg: GraphEdge<f32>,
      bounding_boxes_Arg: 'static,
      min_object_covered_Arg: Clone,
      min_object_covered_Arg: GraphEdge<f32>,
      min_object_covered_Arg: 'static,
      T: con_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64,
      T: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("SampleDistortedBoundingBoxV2_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("SampleDistortedBoundingBoxV2", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.image_size)?
        }
        {
            new_op.add_edge(&self.bounding_boxes)?
        }
        {
            new_op.add_edge(&self.min_object_covered)?
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        {
            match self.seed {
                None => new_op.set_attr_value_proto("seed", &vec![24_u8, 0_u8,])?,
                Some(ref value) => (|attr: &i64| {new_op.set_attr_int("seed", *attr)})(&value)?,
            };
        }
        {
            match self.seed2 {
                None => new_op.set_attr_value_proto("seed2", &vec![24_u8, 0_u8,])?,
                Some(ref value) => (|attr: &i64| {new_op.set_attr_int("seed2", *attr)})(&value)?,
            };
        }
        {
            match self.aspect_ratio_range {
                None => new_op.set_attr_value_proto("aspect_ratio_range", &vec![10_u8, 0_u8, 34_u8, 8_u8, 0_u8, 0_u8, 64_u8, 63_u8,])?,
                Some(ref value) => (|attrs| {new_op.set_attr_float_list("aspect_ratio_range", attrs)})(&value)?,
            };
        }
        {
            match self.area_range {
                None => new_op.set_attr_value_proto("area_range", &vec![10_u8, 0_u8, 34_u8, 8_u8, 205_u8, 204_u8, 76_u8, 61_u8,])?,
                Some(ref value) => (|attrs| {new_op.set_attr_float_list("area_range", attrs)})(&value)?,
            };
        }
        {
            match self.max_attempts {
                None => new_op.set_attr_value_proto("max_attempts", &vec![24_u8, 100_u8,])?,
                Some(ref value) => (|attr: &i64| {new_op.set_attr_int("max_attempts", *attr)})(&value)?,
            };
        }
        {
            match self.use_image_if_no_bounding_boxes {
                None => new_op.set_attr_value_proto("use_image_if_no_bounding_boxes", &vec![40_u8, 0_u8,])?,
                Some(ref value) => (|attr: &bool| {new_op.set_attr_bool("use_image_if_no_bounding_boxes", *attr)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct SampleDistortedBoundingBoxV2<T, image_size_Arg, bounding_boxes_Arg, min_object_covered_Arg>
where T: TensorType,
      T: Clone,
      image_size_Arg: Clone,
      image_size_Arg: GraphEdge<T>,
      image_size_Arg: 'static,
      bounding_boxes_Arg: Clone,
      bounding_boxes_Arg: GraphEdge<f32>,
      bounding_boxes_Arg: 'static,
      min_object_covered_Arg: Clone,
      min_object_covered_Arg: GraphEdge<f32>,
      min_object_covered_Arg: 'static,
      T: con_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    image_size: image_size_Arg,
    bounding_boxes: bounding_boxes_Arg,
    min_object_covered: min_object_covered_Arg,
    seed: Option<i64>,
    seed2: Option<i64>,
    aspect_ratio_range: Option<Vec<f32>>,
    area_range: Option<Vec<f32>>,
    max_attempts: Option<i64>,
    use_image_if_no_bounding_boxes: Option<bool>,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<T, image_size_Arg, bounding_boxes_Arg, min_object_covered_Arg> SampleDistortedBoundingBoxV2<T, image_size_Arg, bounding_boxes_Arg, min_object_covered_Arg>
where T: TensorType,
      T: Clone,
      image_size_Arg: Clone,
      image_size_Arg: GraphEdge<T>,
      image_size_Arg: 'static,
      bounding_boxes_Arg: Clone,
      bounding_boxes_Arg: GraphEdge<f32>,
      bounding_boxes_Arg: 'static,
      min_object_covered_Arg: Clone,
      min_object_covered_Arg: GraphEdge<f32>,
      min_object_covered_Arg: 'static,
      T: con_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64,
      T: 'static,
{
    pub fn begin(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn size(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 1)
        }
    }

    pub fn bboxes(self) -> Edge<f32> {
        let rc = Rc::new(self);
        {
            Edge::<f32>::new(rc.clone(), 2)
        }
    }

    pub fn seed(&mut self, seed: i64) -> Self {
        self.seed = Some(seed);
        self.clone()
    }

    pub fn seed2(&mut self, seed2: i64) -> Self {
        self.seed2 = Some(seed2);
        self.clone()
    }

    pub fn aspect_ratio_range(&mut self, aspect_ratio_range: &[f32]) -> Self {
        self.aspect_ratio_range = Some(aspect_ratio_range.to_vec());
        self.clone()
    }

    pub fn area_range(&mut self, area_range: &[f32]) -> Self {
        self.area_range = Some(area_range.to_vec());
        self.clone()
    }

    pub fn max_attempts(&mut self, max_attempts: i64) -> Self {
        self.max_attempts = Some(max_attempts);
        self.clone()
    }

    pub fn use_image_if_no_bounding_boxes(&mut self, use_image_if_no_bounding_boxes: bool) -> Self {
        self.use_image_if_no_bounding_boxes = Some(use_image_if_no_bounding_boxes);
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> (Edge<T>, Edge<T>, Edge<f32>) {
        let rc = Rc::new(self);
        (
        {
            Edge::<T>::new(rc.clone(), 0)
        },
        {
            Edge::<T>::new(rc.clone(), 1)
        },
        {
            Edge::<f32>::new(rc.clone(), 2)
        },
        )
    }

    pub fn build(image_size: image_size_Arg, bounding_boxes: bounding_boxes_Arg, min_object_covered: min_object_covered_Arg) -> Self {
        Self {
            phantom_T: PhantomData,
            image_size,
            bounding_boxes,
            min_object_covered,
            seed: None,
            seed2: None,
            aspect_ratio_range: None,
            area_range: None,
            max_attempts: None,
            use_image_if_no_bounding_boxes: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(image_size: image_size_Arg, bounding_boxes: bounding_boxes_Arg, min_object_covered: min_object_covered_Arg) -> (Edge<T>, Edge<T>, Edge<f32>) {
        Self {
            phantom_T: PhantomData,
            image_size,
            bounding_boxes,
            min_object_covered,
            seed: None,
            seed2: None,
            aspect_ratio_range: None,
            area_range: None,
            max_attempts: None,
            use_image_if_no_bounding_boxes: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<T, image_Arg, boxes_Arg, box_ind_Arg, crop_size_Arg> GraphOperation for CropAndResize<T, image_Arg, boxes_Arg, box_ind_Arg, crop_size_Arg>
where T: TensorType,
      T: Clone,
      image_Arg: Clone,
      image_Arg: GraphEdge<T>,
      image_Arg: 'static,
      boxes_Arg: Clone,
      boxes_Arg: GraphEdge<f32>,
      boxes_Arg: 'static,
      box_ind_Arg: Clone,
      box_ind_Arg: GraphEdge<i32>,
      box_ind_Arg: 'static,
      crop_size_Arg: Clone,
      crop_size_Arg: GraphEdge<i32>,
      crop_size_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_UINT16_or_DT_HALF,
      T: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("CropAndResize_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("CropAndResize", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.image)?
        }
        {
            new_op.add_edge(&self.boxes)?
        }
        {
            new_op.add_edge(&self.box_ind)?
        }
        {
            new_op.add_edge(&self.crop_size)?
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        {
            match self.method {
                None => new_op.set_attr_value_proto("method", &vec![18_u8, 8_u8, 98_u8, 105_u8, 108_u8, 105_u8, 110_u8, 101_u8, 97_u8, 114_u8,])?,
                Some(ref value) => (|attr| {new_op.set_attr_string("method", attr)})(&value)?,
            };
        }
        {
            match self.extrapolation_value {
                None => new_op.set_attr_value_proto("extrapolation_value", &vec![37_u8, 0_u8, 0_u8, 0_u8, 0_u8,])?,
                Some(ref value) => (|attr: &f32| {new_op.set_attr_float("extrapolation_value", *attr)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct CropAndResize<T, image_Arg, boxes_Arg, box_ind_Arg, crop_size_Arg>
where T: TensorType,
      T: Clone,
      image_Arg: Clone,
      image_Arg: GraphEdge<T>,
      image_Arg: 'static,
      boxes_Arg: Clone,
      boxes_Arg: GraphEdge<f32>,
      boxes_Arg: 'static,
      box_ind_Arg: Clone,
      box_ind_Arg: GraphEdge<i32>,
      box_ind_Arg: 'static,
      crop_size_Arg: Clone,
      crop_size_Arg: GraphEdge<i32>,
      crop_size_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_UINT16_or_DT_HALF,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    image: image_Arg,
    boxes: boxes_Arg,
    box_ind: box_ind_Arg,
    crop_size: crop_size_Arg,
    method: Option<String>,
    extrapolation_value: Option<f32>,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<T, image_Arg, boxes_Arg, box_ind_Arg, crop_size_Arg> CropAndResize<T, image_Arg, boxes_Arg, box_ind_Arg, crop_size_Arg>
where T: TensorType,
      T: Clone,
      image_Arg: Clone,
      image_Arg: GraphEdge<T>,
      image_Arg: 'static,
      boxes_Arg: Clone,
      boxes_Arg: GraphEdge<f32>,
      boxes_Arg: 'static,
      box_ind_Arg: Clone,
      box_ind_Arg: GraphEdge<i32>,
      box_ind_Arg: 'static,
      crop_size_Arg: Clone,
      crop_size_Arg: GraphEdge<i32>,
      crop_size_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_UINT16_or_DT_HALF,
      T: 'static,
{
    pub fn crops(self) -> Edge<f32> {
        let rc = Rc::new(self);
        {
            Edge::<f32>::new(rc.clone(), 0)
        }
    }

    pub fn method(&mut self, method: &str) -> Self {
        self.method = Some(method.to_string());
        self.clone()
    }

    pub fn extrapolation_value(&mut self, extrapolation_value: f32) -> Self {
        self.extrapolation_value = Some(extrapolation_value);
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<f32> {
        let rc = Rc::new(self);
        {
            Edge::<f32>::new(rc.clone(), 0)
        }
    }

    pub fn build(image: image_Arg, boxes: boxes_Arg, box_ind: box_ind_Arg, crop_size: crop_size_Arg) -> Self {
        Self {
            phantom_T: PhantomData,
            image,
            boxes,
            box_ind,
            crop_size,
            method: None,
            extrapolation_value: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(image: image_Arg, boxes: boxes_Arg, box_ind: box_ind_Arg, crop_size: crop_size_Arg) -> Edge<f32> {
        Self {
            phantom_T: PhantomData,
            image,
            boxes,
            box_ind,
            crop_size,
            method: None,
            extrapolation_value: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<Tcomplex, input_Arg> GraphOperation for FFT3D<Tcomplex, input_Arg>
where Tcomplex: TensorType,
      Tcomplex: Clone,
      input_Arg: Clone,
      input_Arg: GraphEdge<Tcomplex>,
      input_Arg: 'static,
      Tcomplex: con_or_DT_COMPLEX64_or_DT_COMPLEX128,
      Tcomplex: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("FFT3D_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("FFT3D", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.input)?
        }
        {
            new_op.set_attr_type("Tcomplex", Tcomplex::data_type())?;
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct FFT3D<Tcomplex, input_Arg>
where Tcomplex: TensorType,
      Tcomplex: Clone,
      input_Arg: Clone,
      input_Arg: GraphEdge<Tcomplex>,
      input_Arg: 'static,
      Tcomplex: con_or_DT_COMPLEX64_or_DT_COMPLEX128,
      Tcomplex: 'static,
{
    phantom_Tcomplex: PhantomData<Tcomplex>,
    input: input_Arg,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<Tcomplex, input_Arg> FFT3D<Tcomplex, input_Arg>
where Tcomplex: TensorType,
      Tcomplex: Clone,
      input_Arg: Clone,
      input_Arg: GraphEdge<Tcomplex>,
      input_Arg: 'static,
      Tcomplex: con_or_DT_COMPLEX64_or_DT_COMPLEX128,
      Tcomplex: 'static,
{
    pub fn output(self) -> Edge<Tcomplex> {
        let rc = Rc::new(self);
        {
            Edge::<Tcomplex>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<Tcomplex> {
        let rc = Rc::new(self);
        {
            Edge::<Tcomplex>::new(rc.clone(), 0)
        }
    }

    pub fn build(input: input_Arg) -> Self {
        Self {
            phantom_Tcomplex: PhantomData,
            input,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(input: input_Arg) -> Edge<Tcomplex> {
        Self {
            phantom_Tcomplex: PhantomData,
            input,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<grads_Arg, T, image_Arg, boxes_Arg, box_ind_Arg> GraphOperation for CropAndResizeGradBoxes<grads_Arg, T, image_Arg, boxes_Arg, box_ind_Arg>
where grads_Arg: Clone,
      grads_Arg: GraphEdge<f32>,
      grads_Arg: 'static,
      T: TensorType,
      T: Clone,
      image_Arg: Clone,
      image_Arg: GraphEdge<T>,
      image_Arg: 'static,
      boxes_Arg: Clone,
      boxes_Arg: GraphEdge<f32>,
      boxes_Arg: 'static,
      box_ind_Arg: Clone,
      box_ind_Arg: GraphEdge<i32>,
      box_ind_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_UINT16_or_DT_HALF,
      T: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("CropAndResizeGradBoxes_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("CropAndResizeGradBoxes", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.grads)?
        }
        {
            new_op.add_edge(&self.image)?
        }
        {
            new_op.add_edge(&self.boxes)?
        }
        {
            new_op.add_edge(&self.box_ind)?
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        {
            match self.method {
                None => new_op.set_attr_value_proto("method", &vec![18_u8, 8_u8, 98_u8, 105_u8, 108_u8, 105_u8, 110_u8, 101_u8, 97_u8, 114_u8,])?,
                Some(ref value) => (|attr| {new_op.set_attr_string("method", attr)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct CropAndResizeGradBoxes<grads_Arg, T, image_Arg, boxes_Arg, box_ind_Arg>
where grads_Arg: Clone,
      grads_Arg: GraphEdge<f32>,
      grads_Arg: 'static,
      T: TensorType,
      T: Clone,
      image_Arg: Clone,
      image_Arg: GraphEdge<T>,
      image_Arg: 'static,
      boxes_Arg: Clone,
      boxes_Arg: GraphEdge<f32>,
      boxes_Arg: 'static,
      box_ind_Arg: Clone,
      box_ind_Arg: GraphEdge<i32>,
      box_ind_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_UINT16_or_DT_HALF,
      T: 'static,
{
    grads: grads_Arg,
    phantom_T: PhantomData<T>,
    image: image_Arg,
    boxes: boxes_Arg,
    box_ind: box_ind_Arg,
    method: Option<String>,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<grads_Arg, T, image_Arg, boxes_Arg, box_ind_Arg> CropAndResizeGradBoxes<grads_Arg, T, image_Arg, boxes_Arg, box_ind_Arg>
where grads_Arg: Clone,
      grads_Arg: GraphEdge<f32>,
      grads_Arg: 'static,
      T: TensorType,
      T: Clone,
      image_Arg: Clone,
      image_Arg: GraphEdge<T>,
      image_Arg: 'static,
      boxes_Arg: Clone,
      boxes_Arg: GraphEdge<f32>,
      boxes_Arg: 'static,
      box_ind_Arg: Clone,
      box_ind_Arg: GraphEdge<i32>,
      box_ind_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_UINT16_or_DT_HALF,
      T: 'static,
{
    pub fn output(self) -> Edge<f32> {
        let rc = Rc::new(self);
        {
            Edge::<f32>::new(rc.clone(), 0)
        }
    }

    pub fn method(&mut self, method: &str) -> Self {
        self.method = Some(method.to_string());
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<f32> {
        let rc = Rc::new(self);
        {
            Edge::<f32>::new(rc.clone(), 0)
        }
    }

    pub fn build(grads: grads_Arg, image: image_Arg, boxes: boxes_Arg, box_ind: box_ind_Arg) -> Self {
        Self {
            grads,
            phantom_T: PhantomData,
            image,
            boxes,
            box_ind,
            method: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(grads: grads_Arg, image: image_Arg, boxes: boxes_Arg, box_ind: box_ind_Arg) -> Edge<f32> {
        Self {
            grads,
            phantom_T: PhantomData,
            image,
            boxes,
            box_ind,
            method: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<T, boxes_Arg, scores_Arg, max_output_size_Arg, iou_threshold_Arg, score_threshold_Arg> GraphOperation for NonMaxSuppressionV3<T, boxes_Arg, scores_Arg, max_output_size_Arg, iou_threshold_Arg, score_threshold_Arg>
where T: TensorType,
      T: Clone,
      boxes_Arg: Clone,
      boxes_Arg: GraphEdge<T>,
      boxes_Arg: 'static,
      scores_Arg: Clone,
      scores_Arg: GraphEdge<T>,
      scores_Arg: 'static,
      max_output_size_Arg: Clone,
      max_output_size_Arg: GraphEdge<i32>,
      max_output_size_Arg: 'static,
      iou_threshold_Arg: Clone,
      iou_threshold_Arg: GraphEdge<f32>,
      iou_threshold_Arg: 'static,
      score_threshold_Arg: Clone,
      score_threshold_Arg: GraphEdge<f32>,
      score_threshold_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_HALF,
      T: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("NonMaxSuppressionV3_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("NonMaxSuppressionV3", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.boxes)?
        }
        {
            new_op.add_edge(&self.scores)?
        }
        {
            new_op.add_edge(&self.max_output_size)?
        }
        {
            new_op.add_edge(&self.iou_threshold)?
        }
        {
            new_op.add_edge(&self.score_threshold)?
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct NonMaxSuppressionV3<T, boxes_Arg, scores_Arg, max_output_size_Arg, iou_threshold_Arg, score_threshold_Arg>
where T: TensorType,
      T: Clone,
      boxes_Arg: Clone,
      boxes_Arg: GraphEdge<T>,
      boxes_Arg: 'static,
      scores_Arg: Clone,
      scores_Arg: GraphEdge<T>,
      scores_Arg: 'static,
      max_output_size_Arg: Clone,
      max_output_size_Arg: GraphEdge<i32>,
      max_output_size_Arg: 'static,
      iou_threshold_Arg: Clone,
      iou_threshold_Arg: GraphEdge<f32>,
      iou_threshold_Arg: 'static,
      score_threshold_Arg: Clone,
      score_threshold_Arg: GraphEdge<f32>,
      score_threshold_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_HALF,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    boxes: boxes_Arg,
    scores: scores_Arg,
    max_output_size: max_output_size_Arg,
    iou_threshold: iou_threshold_Arg,
    score_threshold: score_threshold_Arg,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<T, boxes_Arg, scores_Arg, max_output_size_Arg, iou_threshold_Arg, score_threshold_Arg> NonMaxSuppressionV3<T, boxes_Arg, scores_Arg, max_output_size_Arg, iou_threshold_Arg, score_threshold_Arg>
where T: TensorType,
      T: Clone,
      boxes_Arg: Clone,
      boxes_Arg: GraphEdge<T>,
      boxes_Arg: 'static,
      scores_Arg: Clone,
      scores_Arg: GraphEdge<T>,
      scores_Arg: 'static,
      max_output_size_Arg: Clone,
      max_output_size_Arg: GraphEdge<i32>,
      max_output_size_Arg: 'static,
      iou_threshold_Arg: Clone,
      iou_threshold_Arg: GraphEdge<f32>,
      iou_threshold_Arg: 'static,
      score_threshold_Arg: Clone,
      score_threshold_Arg: GraphEdge<f32>,
      score_threshold_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_HALF,
      T: 'static,
{
    pub fn selected_indices(self) -> Edge<i32> {
        let rc = Rc::new(self);
        {
            Edge::<i32>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<i32> {
        let rc = Rc::new(self);
        {
            Edge::<i32>::new(rc.clone(), 0)
        }
    }

    pub fn build(boxes: boxes_Arg, scores: scores_Arg, max_output_size: max_output_size_Arg, iou_threshold: iou_threshold_Arg, score_threshold: score_threshold_Arg) -> Self {
        Self {
            phantom_T: PhantomData,
            boxes,
            scores,
            max_output_size,
            iou_threshold,
            score_threshold,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(boxes: boxes_Arg, scores: scores_Arg, max_output_size: max_output_size_Arg, iou_threshold: iou_threshold_Arg, score_threshold: score_threshold_Arg) -> Edge<i32> {
        Self {
            phantom_T: PhantomData,
            boxes,
            scores,
            max_output_size,
            iou_threshold,
            score_threshold,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl GraphOperation for NoOp {
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("NoOp_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("NoOp", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct NoOp {
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl NoOp {
    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> () {
        let rc = Rc::new(self);
        (
        )
    }

    pub fn build() -> Self {
        Self {
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new() -> () {
        Self {
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<checkpoint_prefixes_Arg, destination_prefix_Arg> GraphOperation for MergeV2Checkpoints<checkpoint_prefixes_Arg, destination_prefix_Arg>
where checkpoint_prefixes_Arg: Clone,
      checkpoint_prefixes_Arg: GraphEdge<String>,
      checkpoint_prefixes_Arg: 'static,
      destination_prefix_Arg: Clone,
      destination_prefix_Arg: GraphEdge<String>,
      destination_prefix_Arg: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("MergeV2Checkpoints_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("MergeV2Checkpoints", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.checkpoint_prefixes)?
        }
        {
            new_op.add_edge(&self.destination_prefix)?
        }
        {
            match self.delete_old_dirs {
                None => new_op.set_attr_value_proto("delete_old_dirs", &vec![40_u8, 1_u8,])?,
                Some(ref value) => (|attr: &bool| {new_op.set_attr_bool("delete_old_dirs", *attr)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct MergeV2Checkpoints<checkpoint_prefixes_Arg, destination_prefix_Arg>
where checkpoint_prefixes_Arg: Clone,
      checkpoint_prefixes_Arg: GraphEdge<String>,
      checkpoint_prefixes_Arg: 'static,
      destination_prefix_Arg: Clone,
      destination_prefix_Arg: GraphEdge<String>,
      destination_prefix_Arg: 'static,
{
    checkpoint_prefixes: checkpoint_prefixes_Arg,
    destination_prefix: destination_prefix_Arg,
    delete_old_dirs: Option<bool>,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<checkpoint_prefixes_Arg, destination_prefix_Arg> MergeV2Checkpoints<checkpoint_prefixes_Arg, destination_prefix_Arg>
where checkpoint_prefixes_Arg: Clone,
      checkpoint_prefixes_Arg: GraphEdge<String>,
      checkpoint_prefixes_Arg: 'static,
      destination_prefix_Arg: Clone,
      destination_prefix_Arg: GraphEdge<String>,
      destination_prefix_Arg: 'static,
{
    pub fn delete_old_dirs(&mut self, delete_old_dirs: bool) -> Self {
        self.delete_old_dirs = Some(delete_old_dirs);
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> () {
        let rc = Rc::new(self);
        (
        )
    }

    pub fn build(checkpoint_prefixes: checkpoint_prefixes_Arg, destination_prefix: destination_prefix_Arg) -> Self {
        Self {
            checkpoint_prefixes,
            destination_prefix,
            delete_old_dirs: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(checkpoint_prefixes: checkpoint_prefixes_Arg, destination_prefix: destination_prefix_Arg) -> () {
        Self {
            checkpoint_prefixes,
            destination_prefix,
            delete_old_dirs: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<basename_Arg, num_shards_Arg> GraphOperation for ShardedFilespec<basename_Arg, num_shards_Arg>
where basename_Arg: Clone,
      basename_Arg: GraphEdge<String>,
      basename_Arg: 'static,
      num_shards_Arg: Clone,
      num_shards_Arg: GraphEdge<i32>,
      num_shards_Arg: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("ShardedFilespec_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("ShardedFilespec", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.basename)?
        }
        {
            new_op.add_edge(&self.num_shards)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct ShardedFilespec<basename_Arg, num_shards_Arg>
where basename_Arg: Clone,
      basename_Arg: GraphEdge<String>,
      basename_Arg: 'static,
      num_shards_Arg: Clone,
      num_shards_Arg: GraphEdge<i32>,
      num_shards_Arg: 'static,
{
    basename: basename_Arg,
    num_shards: num_shards_Arg,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<basename_Arg, num_shards_Arg> ShardedFilespec<basename_Arg, num_shards_Arg>
where basename_Arg: Clone,
      basename_Arg: GraphEdge<String>,
      basename_Arg: 'static,
      num_shards_Arg: Clone,
      num_shards_Arg: GraphEdge<i32>,
      num_shards_Arg: 'static,
{
    pub fn filename(self) -> Edge<String> {
        let rc = Rc::new(self);
        {
            Edge::<String>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<String> {
        let rc = Rc::new(self);
        {
            Edge::<String>::new(rc.clone(), 0)
        }
    }

    pub fn build(basename: basename_Arg, num_shards: num_shards_Arg) -> Self {
        Self {
            basename,
            num_shards,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(basename: basename_Arg, num_shards: num_shards_Arg) -> Edge<String> {
        Self {
            basename,
            num_shards,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl GraphOperation for WholeFileReader {
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("WholeFileReader_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("WholeFileReader", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            match self.container {
                None => new_op.set_attr_value_proto("container", &vec![18_u8, 0_u8,])?,
                Some(ref value) => (|attr| {new_op.set_attr_string("container", attr)})(&value)?,
            };
        }
        {
            match self.shared_name {
                None => new_op.set_attr_value_proto("shared_name", &vec![18_u8, 0_u8,])?,
                Some(ref value) => (|attr| {new_op.set_attr_string("shared_name", attr)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct WholeFileReader {
    container: Option<String>,
    shared_name: Option<String>,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl WholeFileReader {
    pub fn reader_handle(self) -> RefEdge<String> {
        let rc = Rc::new(self);
        {
            RefEdge::<String>::new(rc.clone(), 0)
        }
    }

    pub fn container(&mut self, container: &str) -> Self {
        self.container = Some(container.to_string());
        self.clone()
    }

    pub fn shared_name(&mut self, shared_name: &str) -> Self {
        self.shared_name = Some(shared_name.to_string());
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> RefEdge<String> {
        let rc = Rc::new(self);
        {
            RefEdge::<String>::new(rc.clone(), 0)
        }
    }

    pub fn build() -> Self {
        Self {
            container: None,
            shared_name: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new() -> RefEdge<String> {
        Self {
            container: None,
            shared_name: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<ckpt_path_Arg, old_tensor_name_Arg, row_remapping_Arg, col_remapping_Arg, initializing_values_Arg> GraphOperation for LoadAndRemapMatrix<ckpt_path_Arg, old_tensor_name_Arg, row_remapping_Arg, col_remapping_Arg, initializing_values_Arg>
where ckpt_path_Arg: Clone,
      ckpt_path_Arg: GraphEdge<String>,
      ckpt_path_Arg: 'static,
      old_tensor_name_Arg: Clone,
      old_tensor_name_Arg: GraphEdge<String>,
      old_tensor_name_Arg: 'static,
      row_remapping_Arg: Clone,
      row_remapping_Arg: GraphEdge<i64>,
      row_remapping_Arg: 'static,
      col_remapping_Arg: Clone,
      col_remapping_Arg: GraphEdge<i64>,
      col_remapping_Arg: 'static,
      initializing_values_Arg: Clone,
      initializing_values_Arg: GraphEdge<f32>,
      initializing_values_Arg: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("LoadAndRemapMatrix_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("LoadAndRemapMatrix", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.ckpt_path)?
        }
        {
            new_op.add_edge(&self.old_tensor_name)?
        }
        {
            new_op.add_edge(&self.row_remapping)?
        }
        {
            new_op.add_edge(&self.col_remapping)?
        }
        {
            new_op.add_edge(&self.initializing_values)?
        }
        {
            (|attr: &i64| {new_op.set_attr_int("num_rows", *attr)})(&self.num_rows)?
        }
        {
            (|attr: &i64| {new_op.set_attr_int("num_cols", *attr)})(&self.num_cols)?
        }
        {
            match self.max_rows_in_memory {
                None => new_op.set_attr_value_proto("max_rows_in_memory", &vec![24_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 1_u8,])?,
                Some(ref value) => (|attr: &i64| {new_op.set_attr_int("max_rows_in_memory", *attr)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct LoadAndRemapMatrix<ckpt_path_Arg, old_tensor_name_Arg, row_remapping_Arg, col_remapping_Arg, initializing_values_Arg>
where ckpt_path_Arg: Clone,
      ckpt_path_Arg: GraphEdge<String>,
      ckpt_path_Arg: 'static,
      old_tensor_name_Arg: Clone,
      old_tensor_name_Arg: GraphEdge<String>,
      old_tensor_name_Arg: 'static,
      row_remapping_Arg: Clone,
      row_remapping_Arg: GraphEdge<i64>,
      row_remapping_Arg: 'static,
      col_remapping_Arg: Clone,
      col_remapping_Arg: GraphEdge<i64>,
      col_remapping_Arg: 'static,
      initializing_values_Arg: Clone,
      initializing_values_Arg: GraphEdge<f32>,
      initializing_values_Arg: 'static,
{
    ckpt_path: ckpt_path_Arg,
    old_tensor_name: old_tensor_name_Arg,
    row_remapping: row_remapping_Arg,
    col_remapping: col_remapping_Arg,
    initializing_values: initializing_values_Arg,
    num_rows: i64,
    num_cols: i64,
    max_rows_in_memory: Option<i64>,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<ckpt_path_Arg, old_tensor_name_Arg, row_remapping_Arg, col_remapping_Arg, initializing_values_Arg> LoadAndRemapMatrix<ckpt_path_Arg, old_tensor_name_Arg, row_remapping_Arg, col_remapping_Arg, initializing_values_Arg>
where ckpt_path_Arg: Clone,
      ckpt_path_Arg: GraphEdge<String>,
      ckpt_path_Arg: 'static,
      old_tensor_name_Arg: Clone,
      old_tensor_name_Arg: GraphEdge<String>,
      old_tensor_name_Arg: 'static,
      row_remapping_Arg: Clone,
      row_remapping_Arg: GraphEdge<i64>,
      row_remapping_Arg: 'static,
      col_remapping_Arg: Clone,
      col_remapping_Arg: GraphEdge<i64>,
      col_remapping_Arg: 'static,
      initializing_values_Arg: Clone,
      initializing_values_Arg: GraphEdge<f32>,
      initializing_values_Arg: 'static,
{
    pub fn output_matrix(self) -> Edge<f32> {
        let rc = Rc::new(self);
        {
            Edge::<f32>::new(rc.clone(), 0)
        }
    }

    pub fn max_rows_in_memory(&mut self, max_rows_in_memory: i64) -> Self {
        self.max_rows_in_memory = Some(max_rows_in_memory);
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<f32> {
        let rc = Rc::new(self);
        {
            Edge::<f32>::new(rc.clone(), 0)
        }
    }

    pub fn build(ckpt_path: ckpt_path_Arg, old_tensor_name: old_tensor_name_Arg, row_remapping: row_remapping_Arg, col_remapping: col_remapping_Arg, initializing_values: initializing_values_Arg, num_rows: i64, num_cols: i64) -> Self {
        Self {
            ckpt_path,
            old_tensor_name,
            row_remapping,
            col_remapping,
            initializing_values,
            num_rows: num_rows,
            num_cols: num_cols,
            max_rows_in_memory: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(ckpt_path: ckpt_path_Arg, old_tensor_name: old_tensor_name_Arg, row_remapping: row_remapping_Arg, col_remapping: col_remapping_Arg, initializing_values: initializing_values_Arg, num_rows: i64, num_cols: i64) -> Edge<f32> {
        Self {
            ckpt_path,
            old_tensor_name,
            row_remapping,
            col_remapping,
            initializing_values,
            num_rows: num_rows,
            num_cols: num_cols,
            max_rows_in_memory: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl GraphOperation for FixedLengthRecordReader {
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("FixedLengthRecordReader_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("FixedLengthRecordReader", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            match self.header_bytes {
                None => new_op.set_attr_value_proto("header_bytes", &vec![24_u8, 0_u8,])?,
                Some(ref value) => (|attr: &i64| {new_op.set_attr_int("header_bytes", *attr)})(&value)?,
            };
        }
        {
            (|attr: &i64| {new_op.set_attr_int("record_bytes", *attr)})(&self.record_bytes)?
        }
        {
            match self.footer_bytes {
                None => new_op.set_attr_value_proto("footer_bytes", &vec![24_u8, 0_u8,])?,
                Some(ref value) => (|attr: &i64| {new_op.set_attr_int("footer_bytes", *attr)})(&value)?,
            };
        }
        {
            match self.hop_bytes {
                None => new_op.set_attr_value_proto("hop_bytes", &vec![24_u8, 0_u8,])?,
                Some(ref value) => (|attr: &i64| {new_op.set_attr_int("hop_bytes", *attr)})(&value)?,
            };
        }
        {
            match self.container {
                None => new_op.set_attr_value_proto("container", &vec![18_u8, 0_u8,])?,
                Some(ref value) => (|attr| {new_op.set_attr_string("container", attr)})(&value)?,
            };
        }
        {
            match self.shared_name {
                None => new_op.set_attr_value_proto("shared_name", &vec![18_u8, 0_u8,])?,
                Some(ref value) => (|attr| {new_op.set_attr_string("shared_name", attr)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct FixedLengthRecordReader {
    header_bytes: Option<i64>,
    record_bytes: i64,
    footer_bytes: Option<i64>,
    hop_bytes: Option<i64>,
    container: Option<String>,
    shared_name: Option<String>,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl FixedLengthRecordReader {
    pub fn reader_handle(self) -> RefEdge<String> {
        let rc = Rc::new(self);
        {
            RefEdge::<String>::new(rc.clone(), 0)
        }
    }

    pub fn header_bytes(&mut self, header_bytes: i64) -> Self {
        self.header_bytes = Some(header_bytes);
        self.clone()
    }

    pub fn footer_bytes(&mut self, footer_bytes: i64) -> Self {
        self.footer_bytes = Some(footer_bytes);
        self.clone()
    }

    pub fn hop_bytes(&mut self, hop_bytes: i64) -> Self {
        self.hop_bytes = Some(hop_bytes);
        self.clone()
    }

    pub fn container(&mut self, container: &str) -> Self {
        self.container = Some(container.to_string());
        self.clone()
    }

    pub fn shared_name(&mut self, shared_name: &str) -> Self {
        self.shared_name = Some(shared_name.to_string());
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> RefEdge<String> {
        let rc = Rc::new(self);
        {
            RefEdge::<String>::new(rc.clone(), 0)
        }
    }

    pub fn build(record_bytes: i64) -> Self {
        Self {
            header_bytes: None,
            record_bytes: record_bytes,
            footer_bytes: None,
            hop_bytes: None,
            container: None,
            shared_name: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(record_bytes: i64) -> RefEdge<String> {
        Self {
            header_bytes: None,
            record_bytes: record_bytes,
            footer_bytes: None,
            hop_bytes: None,
            container: None,
            shared_name: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<SrcT, x_Arg, DstT> GraphOperation for Cast<SrcT, x_Arg, DstT>
where SrcT: TensorType,
      SrcT: Clone,
      x_Arg: Clone,
      x_Arg: GraphEdge<SrcT>,
      x_Arg: 'static,
      DstT: TensorType,
      SrcT: 'static,
      DstT: 'static,
      DstT: Clone,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("Cast_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("Cast", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.x)?
        }
        {
            new_op.set_attr_type("SrcT", SrcT::data_type())?;
        }
        {
            new_op.set_attr_type("DstT", DstT::data_type())?;
        }
        {
            match self.Truncate {
                None => new_op.set_attr_value_proto("Truncate", &vec![40_u8, 0_u8,])?,
                Some(ref value) => (|attr: &bool| {new_op.set_attr_bool("Truncate", *attr)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct Cast<SrcT, x_Arg, DstT>
where SrcT: TensorType,
      SrcT: Clone,
      x_Arg: Clone,
      x_Arg: GraphEdge<SrcT>,
      x_Arg: 'static,
      DstT: TensorType,
      SrcT: 'static,
      DstT: 'static,
      DstT: Clone,
{
    phantom_SrcT: PhantomData<SrcT>,
    x: x_Arg,
    phantom_DstT: PhantomData<DstT>,
    Truncate: Option<bool>,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<SrcT, x_Arg, DstT> Cast<SrcT, x_Arg, DstT>
where SrcT: TensorType,
      SrcT: Clone,
      x_Arg: Clone,
      x_Arg: GraphEdge<SrcT>,
      x_Arg: 'static,
      DstT: TensorType,
      SrcT: 'static,
      DstT: 'static,
      DstT: Clone,
{
    pub fn y(self) -> Edge<DstT> {
        let rc = Rc::new(self);
        {
            Edge::<DstT>::new(rc.clone(), 0)
        }
    }

    pub fn Truncate(&mut self, Truncate: bool) -> Self {
        self.Truncate = Some(Truncate);
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<DstT> {
        let rc = Rc::new(self);
        {
            Edge::<DstT>::new(rc.clone(), 0)
        }
    }

    pub fn build(x: x_Arg) -> Self {
        Self {
            phantom_SrcT: PhantomData,
            x,
            phantom_DstT: PhantomData,
            Truncate: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(x: x_Arg) -> Edge<DstT> {
        Self {
            phantom_SrcT: PhantomData,
            x,
            phantom_DstT: PhantomData,
            Truncate: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl GraphOperation for TFRecordReader {
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("TFRecordReader_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("TFRecordReader", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            match self.container {
                None => new_op.set_attr_value_proto("container", &vec![18_u8, 0_u8,])?,
                Some(ref value) => (|attr| {new_op.set_attr_string("container", attr)})(&value)?,
            };
        }
        {
            match self.shared_name {
                None => new_op.set_attr_value_proto("shared_name", &vec![18_u8, 0_u8,])?,
                Some(ref value) => (|attr| {new_op.set_attr_string("shared_name", attr)})(&value)?,
            };
        }
        {
            match self.compression_type {
                None => new_op.set_attr_value_proto("compression_type", &vec![18_u8, 0_u8,])?,
                Some(ref value) => (|attr| {new_op.set_attr_string("compression_type", attr)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct TFRecordReader {
    container: Option<String>,
    shared_name: Option<String>,
    compression_type: Option<String>,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl TFRecordReader {
    pub fn reader_handle(self) -> RefEdge<String> {
        let rc = Rc::new(self);
        {
            RefEdge::<String>::new(rc.clone(), 0)
        }
    }

    pub fn container(&mut self, container: &str) -> Self {
        self.container = Some(container.to_string());
        self.clone()
    }

    pub fn shared_name(&mut self, shared_name: &str) -> Self {
        self.shared_name = Some(shared_name.to_string());
        self.clone()
    }

    pub fn compression_type(&mut self, compression_type: &str) -> Self {
        self.compression_type = Some(compression_type.to_string());
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> RefEdge<String> {
        let rc = Rc::new(self);
        {
            RefEdge::<String>::new(rc.clone(), 0)
        }
    }

    pub fn build() -> Self {
        Self {
            container: None,
            shared_name: None,
            compression_type: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new() -> RefEdge<String> {
        Self {
            container: None,
            shared_name: None,
            compression_type: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<T, x_Arg> GraphOperation for Sinh<T, x_Arg>
where T: TensorType,
      T: Clone,
      x_Arg: Clone,
      x_Arg: GraphEdge<T>,
      x_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_COMPLEX64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF,
      T: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("Sinh_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("Sinh", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.x)?
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct Sinh<T, x_Arg>
where T: TensorType,
      T: Clone,
      x_Arg: Clone,
      x_Arg: GraphEdge<T>,
      x_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_COMPLEX64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    x: x_Arg,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<T, x_Arg> Sinh<T, x_Arg>
where T: TensorType,
      T: Clone,
      x_Arg: Clone,
      x_Arg: GraphEdge<T>,
      x_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_COMPLEX64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF,
      T: 'static,
{
    pub fn y(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(x: x_Arg) -> Self {
        Self {
            phantom_T: PhantomData,
            x,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(x: x_Arg) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            x,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<T, data_Arg, Tidx, indices_Arg, segment_ids_Arg> GraphOperation for SparseSegmentSum<T, data_Arg, Tidx, indices_Arg, segment_ids_Arg>
where T: TensorType,
      T: Clone,
      data_Arg: Clone,
      data_Arg: GraphEdge<T>,
      data_Arg: 'static,
      Tidx: TensorType,
      Tidx: Clone,
      indices_Arg: Clone,
      indices_Arg: GraphEdge<Tidx>,
      indices_Arg: 'static,
      segment_ids_Arg: Clone,
      segment_ids_Arg: GraphEdge<i32>,
      segment_ids_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
      Tidx: con_or_DT_INT32_or_DT_INT64,
      Tidx: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("SparseSegmentSum_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("SparseSegmentSum", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.data)?
        }
        {
            new_op.add_edge(&self.indices)?
        }
        {
            new_op.add_edge(&self.segment_ids)?
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        {
            new_op.set_attr_type("Tidx", Tidx::data_type())?;
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct SparseSegmentSum<T, data_Arg, Tidx, indices_Arg, segment_ids_Arg>
where T: TensorType,
      T: Clone,
      data_Arg: Clone,
      data_Arg: GraphEdge<T>,
      data_Arg: 'static,
      Tidx: TensorType,
      Tidx: Clone,
      indices_Arg: Clone,
      indices_Arg: GraphEdge<Tidx>,
      indices_Arg: 'static,
      segment_ids_Arg: Clone,
      segment_ids_Arg: GraphEdge<i32>,
      segment_ids_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
      Tidx: con_or_DT_INT32_or_DT_INT64,
      Tidx: 'static,
{
    phantom_T: PhantomData<T>,
    data: data_Arg,
    phantom_Tidx: PhantomData<Tidx>,
    indices: indices_Arg,
    segment_ids: segment_ids_Arg,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<T, data_Arg, Tidx, indices_Arg, segment_ids_Arg> SparseSegmentSum<T, data_Arg, Tidx, indices_Arg, segment_ids_Arg>
where T: TensorType,
      T: Clone,
      data_Arg: Clone,
      data_Arg: GraphEdge<T>,
      data_Arg: 'static,
      Tidx: TensorType,
      Tidx: Clone,
      indices_Arg: Clone,
      indices_Arg: GraphEdge<Tidx>,
      indices_Arg: 'static,
      segment_ids_Arg: Clone,
      segment_ids_Arg: GraphEdge<i32>,
      segment_ids_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
      Tidx: con_or_DT_INT32_or_DT_INT64,
      Tidx: 'static,
{
    pub fn output(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(data: data_Arg, indices: indices_Arg, segment_ids: segment_ids_Arg) -> Self {
        Self {
            phantom_T: PhantomData,
            data,
            phantom_Tidx: PhantomData,
            indices,
            segment_ids,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(data: data_Arg, indices: indices_Arg, segment_ids: segment_ids_Arg) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            data,
            phantom_Tidx: PhantomData,
            indices,
            segment_ids,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl GraphOperation for LMDBReader {
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("LMDBReader_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("LMDBReader", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            match self.container {
                None => new_op.set_attr_value_proto("container", &vec![18_u8, 0_u8,])?,
                Some(ref value) => (|attr| {new_op.set_attr_string("container", attr)})(&value)?,
            };
        }
        {
            match self.shared_name {
                None => new_op.set_attr_value_proto("shared_name", &vec![18_u8, 0_u8,])?,
                Some(ref value) => (|attr| {new_op.set_attr_string("shared_name", attr)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct LMDBReader {
    container: Option<String>,
    shared_name: Option<String>,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl LMDBReader {
    pub fn reader_handle(self) -> RefEdge<String> {
        let rc = Rc::new(self);
        {
            RefEdge::<String>::new(rc.clone(), 0)
        }
    }

    pub fn container(&mut self, container: &str) -> Self {
        self.container = Some(container.to_string());
        self.clone()
    }

    pub fn shared_name(&mut self, shared_name: &str) -> Self {
        self.shared_name = Some(shared_name.to_string());
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> RefEdge<String> {
        let rc = Rc::new(self);
        {
            RefEdge::<String>::new(rc.clone(), 0)
        }
    }

    pub fn build() -> Self {
        Self {
            container: None,
            shared_name: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new() -> RefEdge<String> {
        Self {
            container: None,
            shared_name: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<S, shape_Arg, R, rate_Arg, dtype> GraphOperation for RandomPoissonV2<S, shape_Arg, R, rate_Arg, dtype>
where S: TensorType,
      S: Clone,
      shape_Arg: Clone,
      shape_Arg: GraphEdge<S>,
      shape_Arg: 'static,
      R: TensorType,
      R: Clone,
      rate_Arg: Clone,
      rate_Arg: GraphEdge<R>,
      rate_Arg: 'static,
      dtype: TensorType,
      S: con_or_DT_INT32_or_DT_INT64,
      S: 'static,
      R: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_INT64_or_DT_HALF,
      R: 'static,
      dtype: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_INT64_or_DT_HALF,
      dtype: 'static,
      dtype: Clone,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("RandomPoissonV2_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("RandomPoissonV2", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.shape)?
        }
        {
            new_op.add_edge(&self.rate)?
        }
        {
            match self.seed {
                None => new_op.set_attr_value_proto("seed", &vec![24_u8, 0_u8,])?,
                Some(ref value) => (|attr: &i64| {new_op.set_attr_int("seed", *attr)})(&value)?,
            };
        }
        {
            match self.seed2 {
                None => new_op.set_attr_value_proto("seed2", &vec![24_u8, 0_u8,])?,
                Some(ref value) => (|attr: &i64| {new_op.set_attr_int("seed2", *attr)})(&value)?,
            };
        }
        {
            new_op.set_attr_type("S", S::data_type())?;
        }
        {
            new_op.set_attr_type("R", R::data_type())?;
        }
        {
            new_op.set_attr_type("dtype", dtype::data_type())?;
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct RandomPoissonV2<S, shape_Arg, R, rate_Arg, dtype>
where S: TensorType,
      S: Clone,
      shape_Arg: Clone,
      shape_Arg: GraphEdge<S>,
      shape_Arg: 'static,
      R: TensorType,
      R: Clone,
      rate_Arg: Clone,
      rate_Arg: GraphEdge<R>,
      rate_Arg: 'static,
      dtype: TensorType,
      S: con_or_DT_INT32_or_DT_INT64,
      S: 'static,
      R: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_INT64_or_DT_HALF,
      R: 'static,
      dtype: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_INT64_or_DT_HALF,
      dtype: 'static,
      dtype: Clone,
{
    phantom_S: PhantomData<S>,
    shape: shape_Arg,
    phantom_R: PhantomData<R>,
    rate: rate_Arg,
    seed: Option<i64>,
    seed2: Option<i64>,
    phantom_dtype: PhantomData<dtype>,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<S, shape_Arg, R, rate_Arg, dtype> RandomPoissonV2<S, shape_Arg, R, rate_Arg, dtype>
where S: TensorType,
      S: Clone,
      shape_Arg: Clone,
      shape_Arg: GraphEdge<S>,
      shape_Arg: 'static,
      R: TensorType,
      R: Clone,
      rate_Arg: Clone,
      rate_Arg: GraphEdge<R>,
      rate_Arg: 'static,
      dtype: TensorType,
      S: con_or_DT_INT32_or_DT_INT64,
      S: 'static,
      R: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_INT64_or_DT_HALF,
      R: 'static,
      dtype: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_INT64_or_DT_HALF,
      dtype: 'static,
      dtype: Clone,
{
    pub fn output(self) -> Edge<dtype> {
        let rc = Rc::new(self);
        {
            Edge::<dtype>::new(rc.clone(), 0)
        }
    }

    pub fn seed(&mut self, seed: i64) -> Self {
        self.seed = Some(seed);
        self.clone()
    }

    pub fn seed2(&mut self, seed2: i64) -> Self {
        self.seed2 = Some(seed2);
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<dtype> {
        let rc = Rc::new(self);
        {
            Edge::<dtype>::new(rc.clone(), 0)
        }
    }

    pub fn build(shape: shape_Arg, rate: rate_Arg) -> Self {
        Self {
            phantom_S: PhantomData,
            shape,
            phantom_R: PhantomData,
            rate,
            seed: None,
            seed2: None,
            phantom_dtype: PhantomData,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(shape: shape_Arg, rate: rate_Arg) -> Edge<dtype> {
        Self {
            phantom_S: PhantomData,
            shape,
            phantom_R: PhantomData,
            rate,
            seed: None,
            seed2: None,
            phantom_dtype: PhantomData,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl GraphOperation for RetrieveTPUEmbeddingRMSPropParametersGradAccumDebug {
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("RetrieveTPUEmbeddingRMSPropParametersGradAccumDebug_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("RetrieveTPUEmbeddingRMSPropParametersGradAccumDebug", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            match self.table_id {
                None => new_op.set_attr_value_proto("table_id", &vec![24_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 1_u8,])?,
                Some(ref value) => (|attr: &i64| {new_op.set_attr_int("table_id", *attr)})(&value)?,
            };
        }
        {
            match self.table_name {
                None => new_op.set_attr_value_proto("table_name", &vec![18_u8, 0_u8,])?,
                Some(ref value) => (|attr| {new_op.set_attr_string("table_name", attr)})(&value)?,
            };
        }
        {
            (|attr: &i64| {new_op.set_attr_int("num_shards", *attr)})(&self.num_shards)?
        }
        {
            (|attr: &i64| {new_op.set_attr_int("shard_id", *attr)})(&self.shard_id)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct RetrieveTPUEmbeddingRMSPropParametersGradAccumDebug {
    table_id: Option<i64>,
    table_name: Option<String>,
    num_shards: i64,
    shard_id: i64,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl RetrieveTPUEmbeddingRMSPropParametersGradAccumDebug {
    pub fn parameters(self) -> Edge<f32> {
        let rc = Rc::new(self);
        {
            Edge::<f32>::new(rc.clone(), 0)
        }
    }

    pub fn ms(self) -> Edge<f32> {
        let rc = Rc::new(self);
        {
            Edge::<f32>::new(rc.clone(), 1)
        }
    }

    pub fn mom(self) -> Edge<f32> {
        let rc = Rc::new(self);
        {
            Edge::<f32>::new(rc.clone(), 2)
        }
    }

    pub fn gradient_accumulators(self) -> Edge<f32> {
        let rc = Rc::new(self);
        {
            Edge::<f32>::new(rc.clone(), 3)
        }
    }

    pub fn table_id(&mut self, table_id: i64) -> Self {
        self.table_id = Some(table_id);
        self.clone()
    }

    pub fn table_name(&mut self, table_name: &str) -> Self {
        self.table_name = Some(table_name.to_string());
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> (Edge<f32>, Edge<f32>, Edge<f32>, Edge<f32>) {
        let rc = Rc::new(self);
        (
        {
            Edge::<f32>::new(rc.clone(), 0)
        },
        {
            Edge::<f32>::new(rc.clone(), 1)
        },
        {
            Edge::<f32>::new(rc.clone(), 2)
        },
        {
            Edge::<f32>::new(rc.clone(), 3)
        },
        )
    }

    pub fn build(num_shards: i64, shard_id: i64) -> Self {
        Self {
            table_id: None,
            table_name: None,
            num_shards: num_shards,
            shard_id: shard_id,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(num_shards: i64, shard_id: i64) -> (Edge<f32>, Edge<f32>, Edge<f32>, Edge<f32>) {
        Self {
            table_id: None,
            table_name: None,
            num_shards: num_shards,
            shard_id: shard_id,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl GraphOperation for IdentityReader {
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("IdentityReader_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("IdentityReader", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            match self.container {
                None => new_op.set_attr_value_proto("container", &vec![18_u8, 0_u8,])?,
                Some(ref value) => (|attr| {new_op.set_attr_string("container", attr)})(&value)?,
            };
        }
        {
            match self.shared_name {
                None => new_op.set_attr_value_proto("shared_name", &vec![18_u8, 0_u8,])?,
                Some(ref value) => (|attr| {new_op.set_attr_string("shared_name", attr)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct IdentityReader {
    container: Option<String>,
    shared_name: Option<String>,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl IdentityReader {
    pub fn reader_handle(self) -> RefEdge<String> {
        let rc = Rc::new(self);
        {
            RefEdge::<String>::new(rc.clone(), 0)
        }
    }

    pub fn container(&mut self, container: &str) -> Self {
        self.container = Some(container.to_string());
        self.clone()
    }

    pub fn shared_name(&mut self, shared_name: &str) -> Self {
        self.shared_name = Some(shared_name.to_string());
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> RefEdge<String> {
        let rc = Rc::new(self);
        {
            RefEdge::<String>::new(rc.clone(), 0)
        }
    }

    pub fn build() -> Self {
        Self {
            container: None,
            shared_name: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new() -> RefEdge<String> {
        Self {
            container: None,
            shared_name: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<T, input_Arg, input_min_Arg, input_max_Arg, num_bits_Arg> GraphOperation for QuantizeAndDequantizeV3<T, input_Arg, input_min_Arg, input_max_Arg, num_bits_Arg>
where T: TensorType,
      T: Clone,
      input_Arg: Clone,
      input_Arg: GraphEdge<T>,
      input_Arg: 'static,
      input_min_Arg: Clone,
      input_min_Arg: GraphEdge<T>,
      input_min_Arg: 'static,
      input_max_Arg: Clone,
      input_max_Arg: GraphEdge<T>,
      input_max_Arg: 'static,
      num_bits_Arg: Clone,
      num_bits_Arg: GraphEdge<i32>,
      num_bits_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
      T: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("QuantizeAndDequantizeV3_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("QuantizeAndDequantizeV3", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.input)?
        }
        {
            new_op.add_edge(&self.input_min)?
        }
        {
            new_op.add_edge(&self.input_max)?
        }
        {
            new_op.add_edge(&self.num_bits)?
        }
        {
            match self.signed_input {
                None => new_op.set_attr_value_proto("signed_input", &vec![40_u8, 1_u8,])?,
                Some(ref value) => (|attr: &bool| {new_op.set_attr_bool("signed_input", *attr)})(&value)?,
            };
        }
        {
            match self.range_given {
                None => new_op.set_attr_value_proto("range_given", &vec![40_u8, 1_u8,])?,
                Some(ref value) => (|attr: &bool| {new_op.set_attr_bool("range_given", *attr)})(&value)?,
            };
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct QuantizeAndDequantizeV3<T, input_Arg, input_min_Arg, input_max_Arg, num_bits_Arg>
where T: TensorType,
      T: Clone,
      input_Arg: Clone,
      input_Arg: GraphEdge<T>,
      input_Arg: 'static,
      input_min_Arg: Clone,
      input_min_Arg: GraphEdge<T>,
      input_min_Arg: 'static,
      input_max_Arg: Clone,
      input_max_Arg: GraphEdge<T>,
      input_max_Arg: 'static,
      num_bits_Arg: Clone,
      num_bits_Arg: GraphEdge<i32>,
      num_bits_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    input: input_Arg,
    input_min: input_min_Arg,
    input_max: input_max_Arg,
    num_bits: num_bits_Arg,
    signed_input: Option<bool>,
    range_given: Option<bool>,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<T, input_Arg, input_min_Arg, input_max_Arg, num_bits_Arg> QuantizeAndDequantizeV3<T, input_Arg, input_min_Arg, input_max_Arg, num_bits_Arg>
where T: TensorType,
      T: Clone,
      input_Arg: Clone,
      input_Arg: GraphEdge<T>,
      input_Arg: 'static,
      input_min_Arg: Clone,
      input_min_Arg: GraphEdge<T>,
      input_min_Arg: 'static,
      input_max_Arg: Clone,
      input_max_Arg: GraphEdge<T>,
      input_max_Arg: 'static,
      num_bits_Arg: Clone,
      num_bits_Arg: GraphEdge<i32>,
      num_bits_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
      T: 'static,
{
    pub fn output(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn signed_input(&mut self, signed_input: bool) -> Self {
        self.signed_input = Some(signed_input);
        self.clone()
    }

    pub fn range_given(&mut self, range_given: bool) -> Self {
        self.range_given = Some(range_given);
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(input: input_Arg, input_min: input_min_Arg, input_max: input_max_Arg, num_bits: num_bits_Arg) -> Self {
        Self {
            phantom_T: PhantomData,
            input,
            input_min,
            input_max,
            num_bits,
            signed_input: None,
            range_given: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(input: input_Arg, input_min: input_min_Arg, input_max: input_max_Arg, num_bits: num_bits_Arg) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            input,
            input_min,
            input_max,
            num_bits,
            signed_input: None,
            range_given: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<reader_handle_Arg, queue_handle_Arg> GraphOperation for ReaderRead<reader_handle_Arg, queue_handle_Arg>
where reader_handle_Arg: Clone,
      reader_handle_Arg: GraphRefEdge<String>,
      reader_handle_Arg: 'static,
      queue_handle_Arg: Clone,
      queue_handle_Arg: GraphRefEdge<String>,
      queue_handle_Arg: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("ReaderRead_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("ReaderRead", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.reader_handle)?
        }
        {
            new_op.add_edge(&self.queue_handle)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct ReaderRead<reader_handle_Arg, queue_handle_Arg>
where reader_handle_Arg: Clone,
      reader_handle_Arg: GraphRefEdge<String>,
      reader_handle_Arg: 'static,
      queue_handle_Arg: Clone,
      queue_handle_Arg: GraphRefEdge<String>,
      queue_handle_Arg: 'static,
{
    reader_handle: reader_handle_Arg,
    queue_handle: queue_handle_Arg,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<reader_handle_Arg, queue_handle_Arg> ReaderRead<reader_handle_Arg, queue_handle_Arg>
where reader_handle_Arg: Clone,
      reader_handle_Arg: GraphRefEdge<String>,
      reader_handle_Arg: 'static,
      queue_handle_Arg: Clone,
      queue_handle_Arg: GraphRefEdge<String>,
      queue_handle_Arg: 'static,
{
    pub fn key(self) -> Edge<String> {
        let rc = Rc::new(self);
        {
            Edge::<String>::new(rc.clone(), 0)
        }
    }

    pub fn value(self) -> Edge<String> {
        let rc = Rc::new(self);
        {
            Edge::<String>::new(rc.clone(), 1)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> (Edge<String>, Edge<String>) {
        let rc = Rc::new(self);
        (
        {
            Edge::<String>::new(rc.clone(), 0)
        },
        {
            Edge::<String>::new(rc.clone(), 1)
        },
        )
    }

    pub fn build(reader_handle: reader_handle_Arg, queue_handle: queue_handle_Arg) -> Self {
        Self {
            reader_handle,
            queue_handle,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(reader_handle: reader_handle_Arg, queue_handle: queue_handle_Arg) -> (Edge<String>, Edge<String>) {
        Self {
            reader_handle,
            queue_handle,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<reader_handle_Arg> GraphOperation for ReaderNumRecordsProduced<reader_handle_Arg>
where reader_handle_Arg: Clone,
      reader_handle_Arg: GraphRefEdge<String>,
      reader_handle_Arg: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("ReaderNumRecordsProduced_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("ReaderNumRecordsProduced", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.reader_handle)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct ReaderNumRecordsProduced<reader_handle_Arg>
where reader_handle_Arg: Clone,
      reader_handle_Arg: GraphRefEdge<String>,
      reader_handle_Arg: 'static,
{
    reader_handle: reader_handle_Arg,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<reader_handle_Arg> ReaderNumRecordsProduced<reader_handle_Arg>
where reader_handle_Arg: Clone,
      reader_handle_Arg: GraphRefEdge<String>,
      reader_handle_Arg: 'static,
{
    pub fn records_produced(self) -> Edge<i64> {
        let rc = Rc::new(self);
        {
            Edge::<i64>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<i64> {
        let rc = Rc::new(self);
        {
            Edge::<i64>::new(rc.clone(), 0)
        }
    }

    pub fn build(reader_handle: reader_handle_Arg) -> Self {
        Self {
            reader_handle,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(reader_handle: reader_handle_Arg) -> Edge<i64> {
        Self {
            reader_handle,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<T, x_Arg> GraphOperation for Tan<T, x_Arg>
where T: TensorType,
      T: Clone,
      x_Arg: Clone,
      x_Arg: GraphEdge<T>,
      x_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_COMPLEX64_or_DT_INT64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF,
      T: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("Tan_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("Tan", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.x)?
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct Tan<T, x_Arg>
where T: TensorType,
      T: Clone,
      x_Arg: Clone,
      x_Arg: GraphEdge<T>,
      x_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_COMPLEX64_or_DT_INT64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    x: x_Arg,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<T, x_Arg> Tan<T, x_Arg>
where T: TensorType,
      T: Clone,
      x_Arg: Clone,
      x_Arg: GraphEdge<T>,
      x_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_COMPLEX64_or_DT_INT64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF,
      T: 'static,
{
    pub fn y(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(x: x_Arg) -> Self {
        Self {
            phantom_T: PhantomData,
            x,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(x: x_Arg) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            x,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<reader_handle_Arg> GraphOperation for ReaderSerializeState<reader_handle_Arg>
where reader_handle_Arg: Clone,
      reader_handle_Arg: GraphRefEdge<String>,
      reader_handle_Arg: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("ReaderSerializeState_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("ReaderSerializeState", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.reader_handle)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct ReaderSerializeState<reader_handle_Arg>
where reader_handle_Arg: Clone,
      reader_handle_Arg: GraphRefEdge<String>,
      reader_handle_Arg: 'static,
{
    reader_handle: reader_handle_Arg,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<reader_handle_Arg> ReaderSerializeState<reader_handle_Arg>
where reader_handle_Arg: Clone,
      reader_handle_Arg: GraphRefEdge<String>,
      reader_handle_Arg: 'static,
{
    pub fn state(self) -> Edge<String> {
        let rc = Rc::new(self);
        {
            Edge::<String>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<String> {
        let rc = Rc::new(self);
        {
            Edge::<String>::new(rc.clone(), 0)
        }
    }

    pub fn build(reader_handle: reader_handle_Arg) -> Self {
        Self {
            reader_handle,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(reader_handle: reader_handle_Arg) -> Edge<String> {
        Self {
            reader_handle,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<T, data_Arg> GraphOperation for Exit<T, data_Arg>
where T: TensorType,
      T: Clone,
      data_Arg: Clone,
      data_Arg: GraphEdge<T>,
      data_Arg: 'static,
      T: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("Exit_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("Exit", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.data)?
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct Exit<T, data_Arg>
where T: TensorType,
      T: Clone,
      data_Arg: Clone,
      data_Arg: GraphEdge<T>,
      data_Arg: 'static,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    data: data_Arg,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<T, data_Arg> Exit<T, data_Arg>
where T: TensorType,
      T: Clone,
      data_Arg: Clone,
      data_Arg: GraphEdge<T>,
      data_Arg: 'static,
      T: 'static,
{
    pub fn output(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(data: data_Arg) -> Self {
        Self {
            phantom_T: PhantomData,
            data,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(data: data_Arg) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            data,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl GraphOperation for RetrieveTPUEmbeddingProximalAdagradParameters {
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("RetrieveTPUEmbeddingProximalAdagradParameters_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("RetrieveTPUEmbeddingProximalAdagradParameters", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            match self.table_id {
                None => new_op.set_attr_value_proto("table_id", &vec![24_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 1_u8,])?,
                Some(ref value) => (|attr: &i64| {new_op.set_attr_int("table_id", *attr)})(&value)?,
            };
        }
        {
            match self.table_name {
                None => new_op.set_attr_value_proto("table_name", &vec![18_u8, 0_u8,])?,
                Some(ref value) => (|attr| {new_op.set_attr_string("table_name", attr)})(&value)?,
            };
        }
        {
            (|attr: &i64| {new_op.set_attr_int("num_shards", *attr)})(&self.num_shards)?
        }
        {
            (|attr: &i64| {new_op.set_attr_int("shard_id", *attr)})(&self.shard_id)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct RetrieveTPUEmbeddingProximalAdagradParameters {
    table_id: Option<i64>,
    table_name: Option<String>,
    num_shards: i64,
    shard_id: i64,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl RetrieveTPUEmbeddingProximalAdagradParameters {
    pub fn parameters(self) -> Edge<f32> {
        let rc = Rc::new(self);
        {
            Edge::<f32>::new(rc.clone(), 0)
        }
    }

    pub fn accumulators(self) -> Edge<f32> {
        let rc = Rc::new(self);
        {
            Edge::<f32>::new(rc.clone(), 1)
        }
    }

    pub fn table_id(&mut self, table_id: i64) -> Self {
        self.table_id = Some(table_id);
        self.clone()
    }

    pub fn table_name(&mut self, table_name: &str) -> Self {
        self.table_name = Some(table_name.to_string());
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> (Edge<f32>, Edge<f32>) {
        let rc = Rc::new(self);
        (
        {
            Edge::<f32>::new(rc.clone(), 0)
        },
        {
            Edge::<f32>::new(rc.clone(), 1)
        },
        )
    }

    pub fn build(num_shards: i64, shard_id: i64) -> Self {
        Self {
            table_id: None,
            table_name: None,
            num_shards: num_shards,
            shard_id: shard_id,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(num_shards: i64, shard_id: i64) -> (Edge<f32>, Edge<f32>) {
        Self {
            table_id: None,
            table_name: None,
            num_shards: num_shards,
            shard_id: shard_id,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<T, orig_input_Arg, orig_output_Arg, grad_Arg, ksize_Arg, strides_Arg> GraphOperation for MaxPoolGradV2<T, orig_input_Arg, orig_output_Arg, grad_Arg, ksize_Arg, strides_Arg>
where T: TensorType,
      T: Clone,
      orig_input_Arg: Clone,
      orig_input_Arg: GraphEdge<T>,
      orig_input_Arg: 'static,
      orig_output_Arg: Clone,
      orig_output_Arg: GraphEdge<T>,
      orig_output_Arg: 'static,
      grad_Arg: Clone,
      grad_Arg: GraphEdge<T>,
      grad_Arg: 'static,
      ksize_Arg: Clone,
      ksize_Arg: GraphEdge<i32>,
      ksize_Arg: 'static,
      strides_Arg: Clone,
      strides_Arg: GraphEdge<i32>,
      strides_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("MaxPoolGradV2_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("MaxPoolGradV2", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.orig_input)?
        }
        {
            new_op.add_edge(&self.orig_output)?
        }
        {
            new_op.add_edge(&self.grad)?
        }
        {
            new_op.add_edge(&self.ksize)?
        }
        {
            new_op.add_edge(&self.strides)?
        }
        {
            (|attr| {new_op.set_attr_string("padding", attr)})(&self.padding)?
        }
        {
            match self.data_format {
                None => new_op.set_attr_value_proto("data_format", &vec![18_u8, 4_u8, 78_u8, 72_u8, 87_u8, 67_u8,])?,
                Some(ref value) => (|attr| {new_op.set_attr_string("data_format", attr)})(&value)?,
            };
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct MaxPoolGradV2<T, orig_input_Arg, orig_output_Arg, grad_Arg, ksize_Arg, strides_Arg>
where T: TensorType,
      T: Clone,
      orig_input_Arg: Clone,
      orig_input_Arg: GraphEdge<T>,
      orig_input_Arg: 'static,
      orig_output_Arg: Clone,
      orig_output_Arg: GraphEdge<T>,
      orig_output_Arg: 'static,
      grad_Arg: Clone,
      grad_Arg: GraphEdge<T>,
      grad_Arg: 'static,
      ksize_Arg: Clone,
      ksize_Arg: GraphEdge<i32>,
      ksize_Arg: 'static,
      strides_Arg: Clone,
      strides_Arg: GraphEdge<i32>,
      strides_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    orig_input: orig_input_Arg,
    orig_output: orig_output_Arg,
    grad: grad_Arg,
    ksize: ksize_Arg,
    strides: strides_Arg,
    padding: String,
    data_format: Option<String>,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<T, orig_input_Arg, orig_output_Arg, grad_Arg, ksize_Arg, strides_Arg> MaxPoolGradV2<T, orig_input_Arg, orig_output_Arg, grad_Arg, ksize_Arg, strides_Arg>
where T: TensorType,
      T: Clone,
      orig_input_Arg: Clone,
      orig_input_Arg: GraphEdge<T>,
      orig_input_Arg: 'static,
      orig_output_Arg: Clone,
      orig_output_Arg: GraphEdge<T>,
      orig_output_Arg: 'static,
      grad_Arg: Clone,
      grad_Arg: GraphEdge<T>,
      grad_Arg: 'static,
      ksize_Arg: Clone,
      ksize_Arg: GraphEdge<i32>,
      ksize_Arg: 'static,
      strides_Arg: Clone,
      strides_Arg: GraphEdge<i32>,
      strides_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
{
    pub fn output(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn data_format(&mut self, data_format: &str) -> Self {
        self.data_format = Some(data_format.to_string());
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(orig_input: orig_input_Arg, orig_output: orig_output_Arg, grad: grad_Arg, ksize: ksize_Arg, strides: strides_Arg, padding: &str) -> Self {
        Self {
            phantom_T: PhantomData,
            orig_input,
            orig_output,
            grad,
            ksize,
            strides,
            padding: padding.to_string(),
            data_format: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(orig_input: orig_input_Arg, orig_output: orig_output_Arg, grad: grad_Arg, ksize: ksize_Arg, strides: strides_Arg, padding: &str) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            orig_input,
            orig_output,
            grad,
            ksize,
            strides,
            padding: padding.to_string(),
            data_format: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<handle_Arg, local_step_Arg, dtype, gradient_Arg> GraphOperation for AccumulatorApplyGradient<handle_Arg, local_step_Arg, dtype, gradient_Arg>
where handle_Arg: Clone,
      handle_Arg: GraphRefEdge<String>,
      handle_Arg: 'static,
      local_step_Arg: Clone,
      local_step_Arg: GraphEdge<i64>,
      local_step_Arg: 'static,
      dtype: TensorType,
      dtype: Clone,
      gradient_Arg: Clone,
      gradient_Arg: GraphEdge<dtype>,
      gradient_Arg: 'static,
      dtype: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      dtype: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("AccumulatorApplyGradient_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("AccumulatorApplyGradient", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.handle)?
        }
        {
            new_op.add_edge(&self.local_step)?
        }
        {
            new_op.add_edge(&self.gradient)?
        }
        {
            new_op.set_attr_type("dtype", dtype::data_type())?;
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct AccumulatorApplyGradient<handle_Arg, local_step_Arg, dtype, gradient_Arg>
where handle_Arg: Clone,
      handle_Arg: GraphRefEdge<String>,
      handle_Arg: 'static,
      local_step_Arg: Clone,
      local_step_Arg: GraphEdge<i64>,
      local_step_Arg: 'static,
      dtype: TensorType,
      dtype: Clone,
      gradient_Arg: Clone,
      gradient_Arg: GraphEdge<dtype>,
      gradient_Arg: 'static,
      dtype: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      dtype: 'static,
{
    handle: handle_Arg,
    local_step: local_step_Arg,
    phantom_dtype: PhantomData<dtype>,
    gradient: gradient_Arg,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<handle_Arg, local_step_Arg, dtype, gradient_Arg> AccumulatorApplyGradient<handle_Arg, local_step_Arg, dtype, gradient_Arg>
where handle_Arg: Clone,
      handle_Arg: GraphRefEdge<String>,
      handle_Arg: 'static,
      local_step_Arg: Clone,
      local_step_Arg: GraphEdge<i64>,
      local_step_Arg: 'static,
      dtype: TensorType,
      dtype: Clone,
      gradient_Arg: Clone,
      gradient_Arg: GraphEdge<dtype>,
      gradient_Arg: 'static,
      dtype: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      dtype: 'static,
{
    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> () {
        let rc = Rc::new(self);
        (
        )
    }

    pub fn build(handle: handle_Arg, local_step: local_step_Arg, gradient: gradient_Arg) -> Self {
        Self {
            handle,
            local_step,
            phantom_dtype: PhantomData,
            gradient,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(handle: handle_Arg, local_step: local_step_Arg, gradient: gradient_Arg) -> () {
        Self {
            handle,
            local_step,
            phantom_dtype: PhantomData,
            gradient,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<T, x_Arg> GraphOperation for Abs<T, x_Arg>
where T: TensorType,
      T: Clone,
      x_Arg: Clone,
      x_Arg: GraphEdge<T>,
      x_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_INT64_or_DT_BFLOAT16_or_DT_HALF,
      T: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("Abs_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("Abs", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.x)?
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct Abs<T, x_Arg>
where T: TensorType,
      T: Clone,
      x_Arg: Clone,
      x_Arg: GraphEdge<T>,
      x_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_INT64_or_DT_BFLOAT16_or_DT_HALF,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    x: x_Arg,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<T, x_Arg> Abs<T, x_Arg>
where T: TensorType,
      T: Clone,
      x_Arg: Clone,
      x_Arg: GraphEdge<T>,
      x_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_INT64_or_DT_BFLOAT16_or_DT_HALF,
      T: 'static,
{
    pub fn y(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(x: x_Arg) -> Self {
        Self {
            phantom_T: PhantomData,
            x,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(x: x_Arg) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            x,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<T, input_Arg> GraphOperation for Cholesky<T, input_Arg>
where T: TensorType,
      T: Clone,
      input_Arg: Clone,
      input_Arg: GraphEdge<T>,
      input_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_COMPLEX64_or_DT_COMPLEX128,
      T: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("Cholesky_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("Cholesky", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.input)?
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct Cholesky<T, input_Arg>
where T: TensorType,
      T: Clone,
      input_Arg: Clone,
      input_Arg: GraphEdge<T>,
      input_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_COMPLEX64_or_DT_COMPLEX128,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    input: input_Arg,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<T, input_Arg> Cholesky<T, input_Arg>
where T: TensorType,
      T: Clone,
      input_Arg: Clone,
      input_Arg: GraphEdge<T>,
      input_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_COMPLEX64_or_DT_COMPLEX128,
      T: 'static,
{
    pub fn output(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(input: input_Arg) -> Self {
        Self {
            phantom_T: PhantomData,
            input,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(input: input_Arg) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            input,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<T, var_Arg, alpha_Arg, l1_Arg, l2_Arg, grad_Arg, Tindices, indices_Arg> GraphOperation for SparseApplyProximalGradientDescent<T, var_Arg, alpha_Arg, l1_Arg, l2_Arg, grad_Arg, Tindices, indices_Arg>
where T: TensorType,
      T: Clone,
      var_Arg: Clone,
      var_Arg: GraphRefEdge<T>,
      var_Arg: 'static,
      alpha_Arg: Clone,
      alpha_Arg: GraphEdge<T>,
      alpha_Arg: 'static,
      l1_Arg: Clone,
      l1_Arg: GraphEdge<T>,
      l1_Arg: 'static,
      l2_Arg: Clone,
      l2_Arg: GraphEdge<T>,
      l2_Arg: 'static,
      grad_Arg: Clone,
      grad_Arg: GraphEdge<T>,
      grad_Arg: 'static,
      Tindices: TensorType,
      Tindices: Clone,
      indices_Arg: Clone,
      indices_Arg: GraphEdge<Tindices>,
      indices_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
      Tindices: con_or_DT_INT32_or_DT_INT64,
      Tindices: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("SparseApplyProximalGradientDescent_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("SparseApplyProximalGradientDescent", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.var)?
        }
        {
            new_op.add_edge(&self.alpha)?
        }
        {
            new_op.add_edge(&self.l1)?
        }
        {
            new_op.add_edge(&self.l2)?
        }
        {
            new_op.add_edge(&self.grad)?
        }
        {
            new_op.add_edge(&self.indices)?
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        {
            new_op.set_attr_type("Tindices", Tindices::data_type())?;
        }
        {
            match self.use_locking {
                None => new_op.set_attr_value_proto("use_locking", &vec![40_u8, 0_u8,])?,
                Some(ref value) => (|attr: &bool| {new_op.set_attr_bool("use_locking", *attr)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct SparseApplyProximalGradientDescent<T, var_Arg, alpha_Arg, l1_Arg, l2_Arg, grad_Arg, Tindices, indices_Arg>
where T: TensorType,
      T: Clone,
      var_Arg: Clone,
      var_Arg: GraphRefEdge<T>,
      var_Arg: 'static,
      alpha_Arg: Clone,
      alpha_Arg: GraphEdge<T>,
      alpha_Arg: 'static,
      l1_Arg: Clone,
      l1_Arg: GraphEdge<T>,
      l1_Arg: 'static,
      l2_Arg: Clone,
      l2_Arg: GraphEdge<T>,
      l2_Arg: 'static,
      grad_Arg: Clone,
      grad_Arg: GraphEdge<T>,
      grad_Arg: 'static,
      Tindices: TensorType,
      Tindices: Clone,
      indices_Arg: Clone,
      indices_Arg: GraphEdge<Tindices>,
      indices_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
      Tindices: con_or_DT_INT32_or_DT_INT64,
      Tindices: 'static,
{
    phantom_T: PhantomData<T>,
    var: var_Arg,
    alpha: alpha_Arg,
    l1: l1_Arg,
    l2: l2_Arg,
    grad: grad_Arg,
    phantom_Tindices: PhantomData<Tindices>,
    indices: indices_Arg,
    use_locking: Option<bool>,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<T, var_Arg, alpha_Arg, l1_Arg, l2_Arg, grad_Arg, Tindices, indices_Arg> SparseApplyProximalGradientDescent<T, var_Arg, alpha_Arg, l1_Arg, l2_Arg, grad_Arg, Tindices, indices_Arg>
where T: TensorType,
      T: Clone,
      var_Arg: Clone,
      var_Arg: GraphRefEdge<T>,
      var_Arg: 'static,
      alpha_Arg: Clone,
      alpha_Arg: GraphEdge<T>,
      alpha_Arg: 'static,
      l1_Arg: Clone,
      l1_Arg: GraphEdge<T>,
      l1_Arg: 'static,
      l2_Arg: Clone,
      l2_Arg: GraphEdge<T>,
      l2_Arg: 'static,
      grad_Arg: Clone,
      grad_Arg: GraphEdge<T>,
      grad_Arg: 'static,
      Tindices: TensorType,
      Tindices: Clone,
      indices_Arg: Clone,
      indices_Arg: GraphEdge<Tindices>,
      indices_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
      Tindices: con_or_DT_INT32_or_DT_INT64,
      Tindices: 'static,
{
    pub fn out(self) -> RefEdge<T> {
        let rc = Rc::new(self);
        {
            RefEdge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn use_locking(&mut self, use_locking: bool) -> Self {
        self.use_locking = Some(use_locking);
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> RefEdge<T> {
        let rc = Rc::new(self);
        {
            RefEdge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(var: var_Arg, alpha: alpha_Arg, l1: l1_Arg, l2: l2_Arg, grad: grad_Arg, indices: indices_Arg) -> Self {
        Self {
            phantom_T: PhantomData,
            var,
            alpha,
            l1,
            l2,
            grad,
            phantom_Tindices: PhantomData,
            indices,
            use_locking: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(var: var_Arg, alpha: alpha_Arg, l1: l1_Arg, l2: l2_Arg, grad: grad_Arg, indices: indices_Arg) -> RefEdge<T> {
        Self {
            phantom_T: PhantomData,
            var,
            alpha,
            l1,
            l2,
            grad,
            phantom_Tindices: PhantomData,
            indices,
            use_locking: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<pattern_Arg> GraphOperation for MatchingFiles<pattern_Arg>
where pattern_Arg: Clone,
      pattern_Arg: GraphEdge<String>,
      pattern_Arg: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("MatchingFiles_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("MatchingFiles", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.pattern)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct MatchingFiles<pattern_Arg>
where pattern_Arg: Clone,
      pattern_Arg: GraphEdge<String>,
      pattern_Arg: 'static,
{
    pattern: pattern_Arg,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<pattern_Arg> MatchingFiles<pattern_Arg>
where pattern_Arg: Clone,
      pattern_Arg: GraphEdge<String>,
      pattern_Arg: 'static,
{
    pub fn filenames(self) -> Edge<String> {
        let rc = Rc::new(self);
        {
            Edge::<String>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<String> {
        let rc = Rc::new(self);
        {
            Edge::<String>::new(rc.clone(), 0)
        }
    }

    pub fn build(pattern: pattern_Arg) -> Self {
        Self {
            pattern,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(pattern: pattern_Arg) -> Edge<String> {
        Self {
            pattern,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl GraphOperation for BigQueryReader {
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("BigQueryReader_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("BigQueryReader", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            match self.container {
                None => new_op.set_attr_value_proto("container", &vec![18_u8, 0_u8,])?,
                Some(ref value) => (|attr| {new_op.set_attr_string("container", attr)})(&value)?,
            };
        }
        {
            match self.shared_name {
                None => new_op.set_attr_value_proto("shared_name", &vec![18_u8, 0_u8,])?,
                Some(ref value) => (|attr| {new_op.set_attr_string("shared_name", attr)})(&value)?,
            };
        }
        {
            (|attr| {new_op.set_attr_string("project_id", attr)})(&self.project_id)?
        }
        {
            (|attr| {new_op.set_attr_string("dataset_id", attr)})(&self.dataset_id)?
        }
        {
            (|attr| {new_op.set_attr_string("table_id", attr)})(&self.table_id)?
        }
        {
            (|attrs| {new_op.set_attr_string_list("columns", attrs)})(&self.columns)?
        }
        {
            (|attr: &i64| {new_op.set_attr_int("timestamp_millis", *attr)})(&self.timestamp_millis)?
        }
        {
            match self.test_end_point {
                None => new_op.set_attr_value_proto("test_end_point", &vec![18_u8, 0_u8,])?,
                Some(ref value) => (|attr| {new_op.set_attr_string("test_end_point", attr)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct BigQueryReader {
    container: Option<String>,
    shared_name: Option<String>,
    project_id: String,
    dataset_id: String,
    table_id: String,
    columns: Vec<String>,
    timestamp_millis: i64,
    test_end_point: Option<String>,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl BigQueryReader {
    pub fn reader_handle(self) -> RefEdge<String> {
        let rc = Rc::new(self);
        {
            RefEdge::<String>::new(rc.clone(), 0)
        }
    }

    pub fn container(&mut self, container: &str) -> Self {
        self.container = Some(container.to_string());
        self.clone()
    }

    pub fn shared_name(&mut self, shared_name: &str) -> Self {
        self.shared_name = Some(shared_name.to_string());
        self.clone()
    }

    pub fn test_end_point(&mut self, test_end_point: &str) -> Self {
        self.test_end_point = Some(test_end_point.to_string());
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> RefEdge<String> {
        let rc = Rc::new(self);
        {
            RefEdge::<String>::new(rc.clone(), 0)
        }
    }

    pub fn build(project_id: &str, dataset_id: &str, table_id: &str, columns: &[String], timestamp_millis: i64) -> Self {
        Self {
            container: None,
            shared_name: None,
            project_id: project_id.to_string(),
            dataset_id: dataset_id.to_string(),
            table_id: table_id.to_string(),
            columns: columns.to_vec(),
            timestamp_millis: timestamp_millis,
            test_end_point: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(project_id: &str, dataset_id: &str, table_id: &str, columns: &[String], timestamp_millis: i64) -> RefEdge<String> {
        Self {
            container: None,
            shared_name: None,
            project_id: project_id.to_string(),
            dataset_id: dataset_id.to_string(),
            table_id: table_id.to_string(),
            columns: columns.to_vec(),
            timestamp_millis: timestamp_millis,
            test_end_point: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<T, input_Arg> GraphOperation for MatrixDeterminant<T, input_Arg>
where T: TensorType,
      T: Clone,
      input_Arg: Clone,
      input_Arg: GraphEdge<T>,
      input_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_COMPLEX64_or_DT_COMPLEX128,
      T: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("MatrixDeterminant_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("MatrixDeterminant", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.input)?
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct MatrixDeterminant<T, input_Arg>
where T: TensorType,
      T: Clone,
      input_Arg: Clone,
      input_Arg: GraphEdge<T>,
      input_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_COMPLEX64_or_DT_COMPLEX128,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    input: input_Arg,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<T, input_Arg> MatrixDeterminant<T, input_Arg>
where T: TensorType,
      T: Clone,
      input_Arg: Clone,
      input_Arg: GraphEdge<T>,
      input_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_COMPLEX64_or_DT_COMPLEX128,
      T: 'static,
{
    pub fn output(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(input: input_Arg) -> Self {
        Self {
            phantom_T: PhantomData,
            input,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(input: input_Arg) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            input,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<T, input_Arg> GraphOperation for MatrixInverse<T, input_Arg>
where T: TensorType,
      T: Clone,
      input_Arg: Clone,
      input_Arg: GraphEdge<T>,
      input_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_COMPLEX64_or_DT_COMPLEX128,
      T: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("MatrixInverse_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("MatrixInverse", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.input)?
        }
        {
            match self.adjoint {
                None => new_op.set_attr_value_proto("adjoint", &vec![40_u8, 0_u8,])?,
                Some(ref value) => (|attr: &bool| {new_op.set_attr_bool("adjoint", *attr)})(&value)?,
            };
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct MatrixInverse<T, input_Arg>
where T: TensorType,
      T: Clone,
      input_Arg: Clone,
      input_Arg: GraphEdge<T>,
      input_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_COMPLEX64_or_DT_COMPLEX128,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    input: input_Arg,
    adjoint: Option<bool>,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<T, input_Arg> MatrixInverse<T, input_Arg>
where T: TensorType,
      T: Clone,
      input_Arg: Clone,
      input_Arg: GraphEdge<T>,
      input_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_COMPLEX64_or_DT_COMPLEX128,
      T: 'static,
{
    pub fn output(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn adjoint(&mut self, adjoint: bool) -> Self {
        self.adjoint = Some(adjoint);
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(input: input_Arg) -> Self {
        Self {
            phantom_T: PhantomData,
            input,
            adjoint: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(input: input_Arg) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            input,
            adjoint: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<handle_Arg, dtype> GraphOperation for GetSessionTensor<handle_Arg, dtype>
where handle_Arg: Clone,
      handle_Arg: GraphEdge<String>,
      handle_Arg: 'static,
      dtype: TensorType,
      dtype: 'static,
      dtype: Clone,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("GetSessionTensor_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("GetSessionTensor", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.handle)?
        }
        {
            new_op.set_attr_type("dtype", dtype::data_type())?;
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct GetSessionTensor<handle_Arg, dtype>
where handle_Arg: Clone,
      handle_Arg: GraphEdge<String>,
      handle_Arg: 'static,
      dtype: TensorType,
      dtype: 'static,
      dtype: Clone,
{
    handle: handle_Arg,
    phantom_dtype: PhantomData<dtype>,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<handle_Arg, dtype> GetSessionTensor<handle_Arg, dtype>
where handle_Arg: Clone,
      handle_Arg: GraphEdge<String>,
      handle_Arg: 'static,
      dtype: TensorType,
      dtype: 'static,
      dtype: Clone,
{
    pub fn value(self) -> Edge<dtype> {
        let rc = Rc::new(self);
        {
            Edge::<dtype>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<dtype> {
        let rc = Rc::new(self);
        {
            Edge::<dtype>::new(rc.clone(), 0)
        }
    }

    pub fn build(handle: handle_Arg) -> Self {
        Self {
            handle,
            phantom_dtype: PhantomData,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(handle: handle_Arg) -> Edge<dtype> {
        Self {
            handle,
            phantom_dtype: PhantomData,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<T, y_Arg, dy_Arg> GraphOperation for SqrtGrad<T, y_Arg, dy_Arg>
where T: TensorType,
      T: Clone,
      y_Arg: Clone,
      y_Arg: GraphEdge<T>,
      y_Arg: 'static,
      dy_Arg: Clone,
      dy_Arg: GraphEdge<T>,
      dy_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_COMPLEX64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF,
      T: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("SqrtGrad_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("SqrtGrad", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.y)?
        }
        {
            new_op.add_edge(&self.dy)?
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct SqrtGrad<T, y_Arg, dy_Arg>
where T: TensorType,
      T: Clone,
      y_Arg: Clone,
      y_Arg: GraphEdge<T>,
      y_Arg: 'static,
      dy_Arg: Clone,
      dy_Arg: GraphEdge<T>,
      dy_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_COMPLEX64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    y: y_Arg,
    dy: dy_Arg,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<T, y_Arg, dy_Arg> SqrtGrad<T, y_Arg, dy_Arg>
where T: TensorType,
      T: Clone,
      y_Arg: Clone,
      y_Arg: GraphEdge<T>,
      y_Arg: 'static,
      dy_Arg: Clone,
      dy_Arg: GraphEdge<T>,
      dy_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_COMPLEX64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF,
      T: 'static,
{
    pub fn z(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(y: y_Arg, dy: dy_Arg) -> Self {
        Self {
            phantom_T: PhantomData,
            y,
            dy,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(y: y_Arg, dy: dy_Arg) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            y,
            dy,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

pub trait con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_INT64_or_DT_BFLOAT16 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_INT64_or_DT_BFLOAT16 for BFloat16 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_INT64_or_DT_BFLOAT16 for f32 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_INT64_or_DT_BFLOAT16 for f64 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_INT64_or_DT_BFLOAT16 for i32 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_INT64_or_DT_BFLOAT16 for i64 {
}

impl<T, starts_Arg, limits_Arg, deltas_Arg> GraphOperation for RaggedRange<T, starts_Arg, limits_Arg, deltas_Arg>
where T: TensorType,
      T: Clone,
      starts_Arg: Clone,
      starts_Arg: GraphEdge<T>,
      starts_Arg: 'static,
      limits_Arg: Clone,
      limits_Arg: GraphEdge<T>,
      limits_Arg: 'static,
      deltas_Arg: Clone,
      deltas_Arg: GraphEdge<T>,
      deltas_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_INT64_or_DT_BFLOAT16,
      T: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("RaggedRange_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("RaggedRange", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.starts)?
        }
        {
            new_op.add_edge(&self.limits)?
        }
        {
            new_op.add_edge(&self.deltas)?
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct RaggedRange<T, starts_Arg, limits_Arg, deltas_Arg>
where T: TensorType,
      T: Clone,
      starts_Arg: Clone,
      starts_Arg: GraphEdge<T>,
      starts_Arg: 'static,
      limits_Arg: Clone,
      limits_Arg: GraphEdge<T>,
      limits_Arg: 'static,
      deltas_Arg: Clone,
      deltas_Arg: GraphEdge<T>,
      deltas_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_INT64_or_DT_BFLOAT16,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    starts: starts_Arg,
    limits: limits_Arg,
    deltas: deltas_Arg,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<T, starts_Arg, limits_Arg, deltas_Arg> RaggedRange<T, starts_Arg, limits_Arg, deltas_Arg>
where T: TensorType,
      T: Clone,
      starts_Arg: Clone,
      starts_Arg: GraphEdge<T>,
      starts_Arg: 'static,
      limits_Arg: Clone,
      limits_Arg: GraphEdge<T>,
      limits_Arg: 'static,
      deltas_Arg: Clone,
      deltas_Arg: GraphEdge<T>,
      deltas_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_INT64_or_DT_BFLOAT16,
      T: 'static,
{
    pub fn rt_nested_splits(self) -> Edge<i64> {
        let rc = Rc::new(self);
        {
            Edge::<i64>::new(rc.clone(), 0)
        }
    }

    pub fn rt_dense_values(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 1)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> (Edge<i64>, Edge<T>) {
        let rc = Rc::new(self);
        (
        {
            Edge::<i64>::new(rc.clone(), 0)
        },
        {
            Edge::<T>::new(rc.clone(), 1)
        },
        )
    }

    pub fn build(starts: starts_Arg, limits: limits_Arg, deltas: deltas_Arg) -> Self {
        Self {
            phantom_T: PhantomData,
            starts,
            limits,
            deltas,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(starts: starts_Arg, limits: limits_Arg, deltas: deltas_Arg) -> (Edge<i64>, Edge<T>) {
        Self {
            phantom_T: PhantomData,
            starts,
            limits,
            deltas,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<T, input_Arg> GraphOperation for MatrixExponential<T, input_Arg>
where T: TensorType,
      T: Clone,
      input_Arg: Clone,
      input_Arg: GraphEdge<T>,
      input_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_COMPLEX64_or_DT_COMPLEX128,
      T: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("MatrixExponential_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("MatrixExponential", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.input)?
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct MatrixExponential<T, input_Arg>
where T: TensorType,
      T: Clone,
      input_Arg: Clone,
      input_Arg: GraphEdge<T>,
      input_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_COMPLEX64_or_DT_COMPLEX128,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    input: input_Arg,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<T, input_Arg> MatrixExponential<T, input_Arg>
where T: TensorType,
      T: Clone,
      input_Arg: Clone,
      input_Arg: GraphEdge<T>,
      input_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_COMPLEX64_or_DT_COMPLEX128,
      T: 'static,
{
    pub fn output(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(input: input_Arg) -> Self {
        Self {
            phantom_T: PhantomData,
            input,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(input: input_Arg) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            input,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<input_Arg, Tidx, reduction_indices_Arg> GraphOperation for All<input_Arg, Tidx, reduction_indices_Arg>
where input_Arg: Clone,
      input_Arg: GraphEdge<bool>,
      input_Arg: 'static,
      Tidx: TensorType,
      Tidx: Clone,
      reduction_indices_Arg: Clone,
      reduction_indices_Arg: GraphEdge<Tidx>,
      reduction_indices_Arg: 'static,
      Tidx: con_or_DT_INT32_or_DT_INT64,
      Tidx: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("All_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("All", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.input)?
        }
        {
            new_op.add_edge(&self.reduction_indices)?
        }
        {
            match self.keep_dims {
                None => new_op.set_attr_value_proto("keep_dims", &vec![40_u8, 0_u8,])?,
                Some(ref value) => (|attr: &bool| {new_op.set_attr_bool("keep_dims", *attr)})(&value)?,
            };
        }
        {
            new_op.set_attr_type("Tidx", Tidx::data_type())?;
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct All<input_Arg, Tidx, reduction_indices_Arg>
where input_Arg: Clone,
      input_Arg: GraphEdge<bool>,
      input_Arg: 'static,
      Tidx: TensorType,
      Tidx: Clone,
      reduction_indices_Arg: Clone,
      reduction_indices_Arg: GraphEdge<Tidx>,
      reduction_indices_Arg: 'static,
      Tidx: con_or_DT_INT32_or_DT_INT64,
      Tidx: 'static,
{
    input: input_Arg,
    phantom_Tidx: PhantomData<Tidx>,
    reduction_indices: reduction_indices_Arg,
    keep_dims: Option<bool>,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<input_Arg, Tidx, reduction_indices_Arg> All<input_Arg, Tidx, reduction_indices_Arg>
where input_Arg: Clone,
      input_Arg: GraphEdge<bool>,
      input_Arg: 'static,
      Tidx: TensorType,
      Tidx: Clone,
      reduction_indices_Arg: Clone,
      reduction_indices_Arg: GraphEdge<Tidx>,
      reduction_indices_Arg: 'static,
      Tidx: con_or_DT_INT32_or_DT_INT64,
      Tidx: 'static,
{
    pub fn output(self) -> Edge<bool> {
        let rc = Rc::new(self);
        {
            Edge::<bool>::new(rc.clone(), 0)
        }
    }

    pub fn keep_dims(&mut self, keep_dims: bool) -> Self {
        self.keep_dims = Some(keep_dims);
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<bool> {
        let rc = Rc::new(self);
        {
            Edge::<bool>::new(rc.clone(), 0)
        }
    }

    pub fn build(input: input_Arg, reduction_indices: reduction_indices_Arg) -> Self {
        Self {
            input,
            phantom_Tidx: PhantomData,
            reduction_indices,
            keep_dims: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(input: input_Arg, reduction_indices: reduction_indices_Arg) -> Edge<bool> {
        Self {
            input,
            phantom_Tidx: PhantomData,
            reduction_indices,
            keep_dims: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<T, input_Arg> GraphOperation for SelfAdjointEig<T, input_Arg>
where T: TensorType,
      T: Clone,
      input_Arg: Clone,
      input_Arg: GraphEdge<T>,
      input_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE,
      T: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("SelfAdjointEig_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("SelfAdjointEig", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.input)?
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct SelfAdjointEig<T, input_Arg>
where T: TensorType,
      T: Clone,
      input_Arg: Clone,
      input_Arg: GraphEdge<T>,
      input_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    input: input_Arg,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<T, input_Arg> SelfAdjointEig<T, input_Arg>
where T: TensorType,
      T: Clone,
      input_Arg: Clone,
      input_Arg: GraphEdge<T>,
      input_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE,
      T: 'static,
{
    pub fn output(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(input: input_Arg) -> Self {
        Self {
            phantom_T: PhantomData,
            input,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(input: input_Arg) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            input,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<T, input_Arg> GraphOperation for BatchSelfAdjointEigV2<T, input_Arg>
where T: TensorType,
      T: Clone,
      input_Arg: Clone,
      input_Arg: GraphEdge<T>,
      input_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE,
      T: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("BatchSelfAdjointEigV2_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("BatchSelfAdjointEigV2", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.input)?
        }
        {
            match self.compute_v {
                None => new_op.set_attr_value_proto("compute_v", &vec![40_u8, 1_u8,])?,
                Some(ref value) => (|attr: &bool| {new_op.set_attr_bool("compute_v", *attr)})(&value)?,
            };
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct BatchSelfAdjointEigV2<T, input_Arg>
where T: TensorType,
      T: Clone,
      input_Arg: Clone,
      input_Arg: GraphEdge<T>,
      input_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    input: input_Arg,
    compute_v: Option<bool>,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<T, input_Arg> BatchSelfAdjointEigV2<T, input_Arg>
where T: TensorType,
      T: Clone,
      input_Arg: Clone,
      input_Arg: GraphEdge<T>,
      input_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE,
      T: 'static,
{
    pub fn e(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn v(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 1)
        }
    }

    pub fn compute_v(&mut self, compute_v: bool) -> Self {
        self.compute_v = Some(compute_v);
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> (Edge<T>, Edge<T>) {
        let rc = Rc::new(self);
        (
        {
            Edge::<T>::new(rc.clone(), 0)
        },
        {
            Edge::<T>::new(rc.clone(), 1)
        },
        )
    }

    pub fn build(input: input_Arg) -> Self {
        Self {
            phantom_T: PhantomData,
            input,
            compute_v: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(input: input_Arg) -> (Edge<T>, Edge<T>) {
        Self {
            phantom_T: PhantomData,
            input,
            compute_v: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<T, input_Arg> GraphOperation for Svd<T, input_Arg>
where T: TensorType,
      T: Clone,
      input_Arg: Clone,
      input_Arg: GraphEdge<T>,
      input_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_COMPLEX64_or_DT_COMPLEX128,
      T: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("Svd_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("Svd", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.input)?
        }
        {
            match self.compute_uv {
                None => new_op.set_attr_value_proto("compute_uv", &vec![40_u8, 1_u8,])?,
                Some(ref value) => (|attr: &bool| {new_op.set_attr_bool("compute_uv", *attr)})(&value)?,
            };
        }
        {
            match self.full_matrices {
                None => new_op.set_attr_value_proto("full_matrices", &vec![40_u8, 0_u8,])?,
                Some(ref value) => (|attr: &bool| {new_op.set_attr_bool("full_matrices", *attr)})(&value)?,
            };
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct Svd<T, input_Arg>
where T: TensorType,
      T: Clone,
      input_Arg: Clone,
      input_Arg: GraphEdge<T>,
      input_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_COMPLEX64_or_DT_COMPLEX128,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    input: input_Arg,
    compute_uv: Option<bool>,
    full_matrices: Option<bool>,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<T, input_Arg> Svd<T, input_Arg>
where T: TensorType,
      T: Clone,
      input_Arg: Clone,
      input_Arg: GraphEdge<T>,
      input_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_COMPLEX64_or_DT_COMPLEX128,
      T: 'static,
{
    pub fn s(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn u(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 1)
        }
    }

    pub fn v(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 2)
        }
    }

    pub fn compute_uv(&mut self, compute_uv: bool) -> Self {
        self.compute_uv = Some(compute_uv);
        self.clone()
    }

    pub fn full_matrices(&mut self, full_matrices: bool) -> Self {
        self.full_matrices = Some(full_matrices);
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> (Edge<T>, Edge<T>, Edge<T>) {
        let rc = Rc::new(self);
        (
        {
            Edge::<T>::new(rc.clone(), 0)
        },
        {
            Edge::<T>::new(rc.clone(), 1)
        },
        {
            Edge::<T>::new(rc.clone(), 2)
        },
        )
    }

    pub fn build(input: input_Arg) -> Self {
        Self {
            phantom_T: PhantomData,
            input,
            compute_uv: None,
            full_matrices: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(input: input_Arg) -> (Edge<T>, Edge<T>, Edge<T>) {
        Self {
            phantom_T: PhantomData,
            input,
            compute_uv: None,
            full_matrices: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<T, input_Arg> GraphOperation for BatchSelfAdjointEig<T, input_Arg>
where T: TensorType,
      T: Clone,
      input_Arg: Clone,
      input_Arg: GraphEdge<T>,
      input_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE,
      T: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("BatchSelfAdjointEig_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("BatchSelfAdjointEig", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.input)?
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct BatchSelfAdjointEig<T, input_Arg>
where T: TensorType,
      T: Clone,
      input_Arg: Clone,
      input_Arg: GraphEdge<T>,
      input_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    input: input_Arg,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<T, input_Arg> BatchSelfAdjointEig<T, input_Arg>
where T: TensorType,
      T: Clone,
      input_Arg: Clone,
      input_Arg: GraphEdge<T>,
      input_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE,
      T: 'static,
{
    pub fn output(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(input: input_Arg) -> Self {
        Self {
            phantom_T: PhantomData,
            input,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(input: input_Arg) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            input,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<T, matrix_Arg, rhs_Arg> GraphOperation for BatchMatrixSolve<T, matrix_Arg, rhs_Arg>
where T: TensorType,
      T: Clone,
      matrix_Arg: Clone,
      matrix_Arg: GraphEdge<T>,
      matrix_Arg: 'static,
      rhs_Arg: Clone,
      rhs_Arg: GraphEdge<T>,
      rhs_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE,
      T: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("BatchMatrixSolve_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("BatchMatrixSolve", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.matrix)?
        }
        {
            new_op.add_edge(&self.rhs)?
        }
        {
            match self.adjoint {
                None => new_op.set_attr_value_proto("adjoint", &vec![40_u8, 0_u8,])?,
                Some(ref value) => (|attr: &bool| {new_op.set_attr_bool("adjoint", *attr)})(&value)?,
            };
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct BatchMatrixSolve<T, matrix_Arg, rhs_Arg>
where T: TensorType,
      T: Clone,
      matrix_Arg: Clone,
      matrix_Arg: GraphEdge<T>,
      matrix_Arg: 'static,
      rhs_Arg: Clone,
      rhs_Arg: GraphEdge<T>,
      rhs_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    matrix: matrix_Arg,
    rhs: rhs_Arg,
    adjoint: Option<bool>,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<T, matrix_Arg, rhs_Arg> BatchMatrixSolve<T, matrix_Arg, rhs_Arg>
where T: TensorType,
      T: Clone,
      matrix_Arg: Clone,
      matrix_Arg: GraphEdge<T>,
      matrix_Arg: 'static,
      rhs_Arg: Clone,
      rhs_Arg: GraphEdge<T>,
      rhs_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE,
      T: 'static,
{
    pub fn output(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn adjoint(&mut self, adjoint: bool) -> Self {
        self.adjoint = Some(adjoint);
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(matrix: matrix_Arg, rhs: rhs_Arg) -> Self {
        Self {
            phantom_T: PhantomData,
            matrix,
            rhs,
            adjoint: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(matrix: matrix_Arg, rhs: rhs_Arg) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            matrix,
            rhs,
            adjoint: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<T, matrix_Arg, rhs_Arg, l2_regularizer_Arg> GraphOperation for BatchMatrixSolveLs<T, matrix_Arg, rhs_Arg, l2_regularizer_Arg>
where T: TensorType,
      T: Clone,
      matrix_Arg: Clone,
      matrix_Arg: GraphEdge<T>,
      matrix_Arg: 'static,
      rhs_Arg: Clone,
      rhs_Arg: GraphEdge<T>,
      rhs_Arg: 'static,
      l2_regularizer_Arg: Clone,
      l2_regularizer_Arg: GraphEdge<f64>,
      l2_regularizer_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE,
      T: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("BatchMatrixSolveLs_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("BatchMatrixSolveLs", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.matrix)?
        }
        {
            new_op.add_edge(&self.rhs)?
        }
        {
            new_op.add_edge(&self.l2_regularizer)?
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        {
            match self.fast {
                None => new_op.set_attr_value_proto("fast", &vec![40_u8, 1_u8,])?,
                Some(ref value) => (|attr: &bool| {new_op.set_attr_bool("fast", *attr)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct BatchMatrixSolveLs<T, matrix_Arg, rhs_Arg, l2_regularizer_Arg>
where T: TensorType,
      T: Clone,
      matrix_Arg: Clone,
      matrix_Arg: GraphEdge<T>,
      matrix_Arg: 'static,
      rhs_Arg: Clone,
      rhs_Arg: GraphEdge<T>,
      rhs_Arg: 'static,
      l2_regularizer_Arg: Clone,
      l2_regularizer_Arg: GraphEdge<f64>,
      l2_regularizer_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    matrix: matrix_Arg,
    rhs: rhs_Arg,
    l2_regularizer: l2_regularizer_Arg,
    fast: Option<bool>,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<T, matrix_Arg, rhs_Arg, l2_regularizer_Arg> BatchMatrixSolveLs<T, matrix_Arg, rhs_Arg, l2_regularizer_Arg>
where T: TensorType,
      T: Clone,
      matrix_Arg: Clone,
      matrix_Arg: GraphEdge<T>,
      matrix_Arg: 'static,
      rhs_Arg: Clone,
      rhs_Arg: GraphEdge<T>,
      rhs_Arg: 'static,
      l2_regularizer_Arg: Clone,
      l2_regularizer_Arg: GraphEdge<f64>,
      l2_regularizer_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE,
      T: 'static,
{
    pub fn output(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn fast(&mut self, fast: bool) -> Self {
        self.fast = Some(fast);
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(matrix: matrix_Arg, rhs: rhs_Arg, l2_regularizer: l2_regularizer_Arg) -> Self {
        Self {
            phantom_T: PhantomData,
            matrix,
            rhs,
            l2_regularizer,
            fast: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(matrix: matrix_Arg, rhs: rhs_Arg, l2_regularizer: l2_regularizer_Arg) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            matrix,
            rhs,
            l2_regularizer,
            fast: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<T, images_Arg> GraphOperation for RGBToHSV<T, images_Arg>
where T: TensorType,
      T: Clone,
      images_Arg: Clone,
      images_Arg: GraphEdge<T>,
      images_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
      T: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("RGBToHSV_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("RGBToHSV", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.images)?
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct RGBToHSV<T, images_Arg>
where T: TensorType,
      T: Clone,
      images_Arg: Clone,
      images_Arg: GraphEdge<T>,
      images_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    images: images_Arg,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<T, images_Arg> RGBToHSV<T, images_Arg>
where T: TensorType,
      T: Clone,
      images_Arg: Clone,
      images_Arg: GraphEdge<T>,
      images_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
      T: 'static,
{
    pub fn output(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(images: images_Arg) -> Self {
        Self {
            phantom_T: PhantomData,
            images,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(images: images_Arg) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            images,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<T, input_Arg> GraphOperation for BatchSvd<T, input_Arg>
where T: TensorType,
      T: Clone,
      input_Arg: Clone,
      input_Arg: GraphEdge<T>,
      input_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_COMPLEX64_or_DT_COMPLEX128,
      T: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("BatchSvd_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("BatchSvd", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.input)?
        }
        {
            match self.compute_uv {
                None => new_op.set_attr_value_proto("compute_uv", &vec![40_u8, 1_u8,])?,
                Some(ref value) => (|attr: &bool| {new_op.set_attr_bool("compute_uv", *attr)})(&value)?,
            };
        }
        {
            match self.full_matrices {
                None => new_op.set_attr_value_proto("full_matrices", &vec![40_u8, 0_u8,])?,
                Some(ref value) => (|attr: &bool| {new_op.set_attr_bool("full_matrices", *attr)})(&value)?,
            };
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct BatchSvd<T, input_Arg>
where T: TensorType,
      T: Clone,
      input_Arg: Clone,
      input_Arg: GraphEdge<T>,
      input_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_COMPLEX64_or_DT_COMPLEX128,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    input: input_Arg,
    compute_uv: Option<bool>,
    full_matrices: Option<bool>,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<T, input_Arg> BatchSvd<T, input_Arg>
where T: TensorType,
      T: Clone,
      input_Arg: Clone,
      input_Arg: GraphEdge<T>,
      input_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_COMPLEX64_or_DT_COMPLEX128,
      T: 'static,
{
    pub fn s(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn u(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 1)
        }
    }

    pub fn v(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 2)
        }
    }

    pub fn compute_uv(&mut self, compute_uv: bool) -> Self {
        self.compute_uv = Some(compute_uv);
        self.clone()
    }

    pub fn full_matrices(&mut self, full_matrices: bool) -> Self {
        self.full_matrices = Some(full_matrices);
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> (Edge<T>, Edge<T>, Edge<T>) {
        let rc = Rc::new(self);
        (
        {
            Edge::<T>::new(rc.clone(), 0)
        },
        {
            Edge::<T>::new(rc.clone(), 1)
        },
        {
            Edge::<T>::new(rc.clone(), 2)
        },
        )
    }

    pub fn build(input: input_Arg) -> Self {
        Self {
            phantom_T: PhantomData,
            input,
            compute_uv: None,
            full_matrices: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(input: input_Arg) -> (Edge<T>, Edge<T>, Edge<T>) {
        Self {
            phantom_T: PhantomData,
            input,
            compute_uv: None,
            full_matrices: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<Tcomplex, input_Arg> GraphOperation for IFFT3D<Tcomplex, input_Arg>
where Tcomplex: TensorType,
      Tcomplex: Clone,
      input_Arg: Clone,
      input_Arg: GraphEdge<Tcomplex>,
      input_Arg: 'static,
      Tcomplex: con_or_DT_COMPLEX64_or_DT_COMPLEX128,
      Tcomplex: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("IFFT3D_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("IFFT3D", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.input)?
        }
        {
            new_op.set_attr_type("Tcomplex", Tcomplex::data_type())?;
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct IFFT3D<Tcomplex, input_Arg>
where Tcomplex: TensorType,
      Tcomplex: Clone,
      input_Arg: Clone,
      input_Arg: GraphEdge<Tcomplex>,
      input_Arg: 'static,
      Tcomplex: con_or_DT_COMPLEX64_or_DT_COMPLEX128,
      Tcomplex: 'static,
{
    phantom_Tcomplex: PhantomData<Tcomplex>,
    input: input_Arg,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<Tcomplex, input_Arg> IFFT3D<Tcomplex, input_Arg>
where Tcomplex: TensorType,
      Tcomplex: Clone,
      input_Arg: Clone,
      input_Arg: GraphEdge<Tcomplex>,
      input_Arg: 'static,
      Tcomplex: con_or_DT_COMPLEX64_or_DT_COMPLEX128,
      Tcomplex: 'static,
{
    pub fn output(self) -> Edge<Tcomplex> {
        let rc = Rc::new(self);
        {
            Edge::<Tcomplex>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<Tcomplex> {
        let rc = Rc::new(self);
        {
            Edge::<Tcomplex>::new(rc.clone(), 0)
        }
    }

    pub fn build(input: input_Arg) -> Self {
        Self {
            phantom_Tcomplex: PhantomData,
            input,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(input: input_Arg) -> Edge<Tcomplex> {
        Self {
            phantom_Tcomplex: PhantomData,
            input,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<T, x_Arg> GraphOperation for Invert<T, x_Arg>
where T: TensorType,
      T: Clone,
      x_Arg: Clone,
      x_Arg: GraphEdge<T>,
      x_Arg: 'static,
      T: con_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_UINT16_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("Invert_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("Invert", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.x)?
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct Invert<T, x_Arg>
where T: TensorType,
      T: Clone,
      x_Arg: Clone,
      x_Arg: GraphEdge<T>,
      x_Arg: 'static,
      T: con_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_UINT16_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    x: x_Arg,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<T, x_Arg> Invert<T, x_Arg>
where T: TensorType,
      T: Clone,
      x_Arg: Clone,
      x_Arg: GraphEdge<T>,
      x_Arg: 'static,
      T: con_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_UINT16_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
{
    pub fn y(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(x: x_Arg) -> Self {
        Self {
            phantom_T: PhantomData,
            x,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(x: x_Arg) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            x,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<T, input_Arg, min_range_Arg, max_range_Arg> GraphOperation for Dequantize<T, input_Arg, min_range_Arg, max_range_Arg>
where T: TensorType,
      T: Clone,
      input_Arg: Clone,
      input_Arg: GraphEdge<T>,
      input_Arg: 'static,
      min_range_Arg: Clone,
      min_range_Arg: GraphEdge<f32>,
      min_range_Arg: 'static,
      max_range_Arg: Clone,
      max_range_Arg: GraphEdge<f32>,
      max_range_Arg: 'static,
      T: con_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_QINT16_or_DT_QUINT16,
      T: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("Dequantize_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("Dequantize", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.input)?
        }
        {
            new_op.add_edge(&self.min_range)?
        }
        {
            new_op.add_edge(&self.max_range)?
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        {
            match self.mode {
                None => new_op.set_attr_value_proto("mode", &vec![18_u8, 12_u8, 77_u8, 73_u8, 78_u8, 95_u8, 67_u8, 79_u8, 77_u8, 66_u8, 73_u8, 78_u8, 69_u8, 68_u8,])?,
                Some(ref value) => (|attr| {new_op.set_attr_string("mode", attr)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct Dequantize<T, input_Arg, min_range_Arg, max_range_Arg>
where T: TensorType,
      T: Clone,
      input_Arg: Clone,
      input_Arg: GraphEdge<T>,
      input_Arg: 'static,
      min_range_Arg: Clone,
      min_range_Arg: GraphEdge<f32>,
      min_range_Arg: 'static,
      max_range_Arg: Clone,
      max_range_Arg: GraphEdge<f32>,
      max_range_Arg: 'static,
      T: con_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_QINT16_or_DT_QUINT16,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    input: input_Arg,
    min_range: min_range_Arg,
    max_range: max_range_Arg,
    mode: Option<String>,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<T, input_Arg, min_range_Arg, max_range_Arg> Dequantize<T, input_Arg, min_range_Arg, max_range_Arg>
where T: TensorType,
      T: Clone,
      input_Arg: Clone,
      input_Arg: GraphEdge<T>,
      input_Arg: 'static,
      min_range_Arg: Clone,
      min_range_Arg: GraphEdge<f32>,
      min_range_Arg: 'static,
      max_range_Arg: Clone,
      max_range_Arg: GraphEdge<f32>,
      max_range_Arg: 'static,
      T: con_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_QINT16_or_DT_QUINT16,
      T: 'static,
{
    pub fn output(self) -> Edge<f32> {
        let rc = Rc::new(self);
        {
            Edge::<f32>::new(rc.clone(), 0)
        }
    }

    pub fn mode(&mut self, mode: &str) -> Self {
        self.mode = Some(mode.to_string());
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<f32> {
        let rc = Rc::new(self);
        {
            Edge::<f32>::new(rc.clone(), 0)
        }
    }

    pub fn build(input: input_Arg, min_range: min_range_Arg, max_range: max_range_Arg) -> Self {
        Self {
            phantom_T: PhantomData,
            input,
            min_range,
            max_range,
            mode: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(input: input_Arg, min_range: min_range_Arg, max_range: max_range_Arg) -> Edge<f32> {
        Self {
            phantom_T: PhantomData,
            input,
            min_range,
            max_range,
            mode: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<key_dtype, value_dtype> GraphOperation for MutableHashTableOfTensors<key_dtype, value_dtype>
where key_dtype: TensorType,
      key_dtype: 'static,
      key_dtype: Clone,
      value_dtype: TensorType,
      value_dtype: 'static,
      value_dtype: Clone,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("MutableHashTableOfTensors_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("MutableHashTableOfTensors", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            match self.container {
                None => new_op.set_attr_value_proto("container", &vec![18_u8, 0_u8,])?,
                Some(ref value) => (|attr| {new_op.set_attr_string("container", attr)})(&value)?,
            };
        }
        {
            match self.shared_name {
                None => new_op.set_attr_value_proto("shared_name", &vec![18_u8, 0_u8,])?,
                Some(ref value) => (|attr| {new_op.set_attr_string("shared_name", attr)})(&value)?,
            };
        }
        {
            match self.use_node_name_sharing {
                None => new_op.set_attr_value_proto("use_node_name_sharing", &vec![40_u8, 0_u8,])?,
                Some(ref value) => (|attr: &bool| {new_op.set_attr_bool("use_node_name_sharing", *attr)})(&value)?,
            };
        }
        {
            new_op.set_attr_type("key_dtype", key_dtype::data_type())?;
        }
        {
            new_op.set_attr_type("value_dtype", value_dtype::data_type())?;
        }
        {
            match self.value_shape {
                None => new_op.set_attr_value_proto("value_shape", &vec![58_u8, 0_u8,])?,
                Some(ref value) => (|attr| {new_op.set_attr_shape("value_shape", attr)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct MutableHashTableOfTensors<key_dtype, value_dtype>
where key_dtype: TensorType,
      key_dtype: 'static,
      key_dtype: Clone,
      value_dtype: TensorType,
      value_dtype: 'static,
      value_dtype: Clone,
{
    container: Option<String>,
    shared_name: Option<String>,
    use_node_name_sharing: Option<bool>,
    phantom_key_dtype: PhantomData<key_dtype>,
    phantom_value_dtype: PhantomData<value_dtype>,
    value_shape: Option<OtherShape>,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<key_dtype, value_dtype> MutableHashTableOfTensors<key_dtype, value_dtype>
where key_dtype: TensorType,
      key_dtype: 'static,
      key_dtype: Clone,
      value_dtype: TensorType,
      value_dtype: 'static,
      value_dtype: Clone,
{
    pub fn table_handle(self) -> RefEdge<String> {
        let rc = Rc::new(self);
        {
            RefEdge::<String>::new(rc.clone(), 0)
        }
    }

    pub fn container(&mut self, container: &str) -> Self {
        self.container = Some(container.to_string());
        self.clone()
    }

    pub fn shared_name(&mut self, shared_name: &str) -> Self {
        self.shared_name = Some(shared_name.to_string());
        self.clone()
    }

    pub fn use_node_name_sharing(&mut self, use_node_name_sharing: bool) -> Self {
        self.use_node_name_sharing = Some(use_node_name_sharing);
        self.clone()
    }

    pub fn value_shape(&mut self, value_shape: &OtherShape) -> Self {
        self.value_shape = Some(value_shape.clone());
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> RefEdge<String> {
        let rc = Rc::new(self);
        {
            RefEdge::<String>::new(rc.clone(), 0)
        }
    }

    pub fn build() -> Self {
        Self {
            container: None,
            shared_name: None,
            use_node_name_sharing: None,
            phantom_key_dtype: PhantomData,
            phantom_value_dtype: PhantomData,
            value_shape: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new() -> RefEdge<String> {
        Self {
            container: None,
            shared_name: None,
            use_node_name_sharing: None,
            phantom_key_dtype: PhantomData,
            phantom_value_dtype: PhantomData,
            value_shape: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<T, orig_input_Arg, orig_output_Arg, grad_Arg> GraphOperation for MaxPoolGradGrad<T, orig_input_Arg, orig_output_Arg, grad_Arg>
where T: TensorType,
      T: Clone,
      orig_input_Arg: Clone,
      orig_input_Arg: GraphEdge<T>,
      orig_input_Arg: 'static,
      orig_output_Arg: Clone,
      orig_output_Arg: GraphEdge<T>,
      orig_output_Arg: 'static,
      grad_Arg: Clone,
      grad_Arg: GraphEdge<T>,
      grad_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("MaxPoolGradGrad_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("MaxPoolGradGrad", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.orig_input)?
        }
        {
            new_op.add_edge(&self.orig_output)?
        }
        {
            new_op.add_edge(&self.grad)?
        }
        {
            (|attrs| {new_op.set_attr_int_list("ksize", attrs)})(&self.ksize)?
        }
        {
            (|attrs| {new_op.set_attr_int_list("strides", attrs)})(&self.strides)?
        }
        {
            (|attr| {new_op.set_attr_string("padding", attr)})(&self.padding)?
        }
        {
            match self.data_format {
                None => new_op.set_attr_value_proto("data_format", &vec![18_u8, 4_u8, 78_u8, 72_u8, 87_u8, 67_u8,])?,
                Some(ref value) => (|attr| {new_op.set_attr_string("data_format", attr)})(&value)?,
            };
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct MaxPoolGradGrad<T, orig_input_Arg, orig_output_Arg, grad_Arg>
where T: TensorType,
      T: Clone,
      orig_input_Arg: Clone,
      orig_input_Arg: GraphEdge<T>,
      orig_input_Arg: 'static,
      orig_output_Arg: Clone,
      orig_output_Arg: GraphEdge<T>,
      orig_output_Arg: 'static,
      grad_Arg: Clone,
      grad_Arg: GraphEdge<T>,
      grad_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    orig_input: orig_input_Arg,
    orig_output: orig_output_Arg,
    grad: grad_Arg,
    ksize: Vec<i64>,
    strides: Vec<i64>,
    padding: String,
    data_format: Option<String>,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<T, orig_input_Arg, orig_output_Arg, grad_Arg> MaxPoolGradGrad<T, orig_input_Arg, orig_output_Arg, grad_Arg>
where T: TensorType,
      T: Clone,
      orig_input_Arg: Clone,
      orig_input_Arg: GraphEdge<T>,
      orig_input_Arg: 'static,
      orig_output_Arg: Clone,
      orig_output_Arg: GraphEdge<T>,
      orig_output_Arg: 'static,
      grad_Arg: Clone,
      grad_Arg: GraphEdge<T>,
      grad_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
{
    pub fn output(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn data_format(&mut self, data_format: &str) -> Self {
        self.data_format = Some(data_format.to_string());
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(orig_input: orig_input_Arg, orig_output: orig_output_Arg, grad: grad_Arg, ksize: &[i64], strides: &[i64], padding: &str) -> Self {
        Self {
            phantom_T: PhantomData,
            orig_input,
            orig_output,
            grad,
            ksize: ksize.to_vec(),
            strides: strides.to_vec(),
            padding: padding.to_string(),
            data_format: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(orig_input: orig_input_Arg, orig_output: orig_output_Arg, grad: grad_Arg, ksize: &[i64], strides: &[i64], padding: &str) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            orig_input,
            orig_output,
            grad,
            ksize: ksize.to_vec(),
            strides: strides.to_vec(),
            padding: padding.to_string(),
            data_format: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<T, x_Arg, y_Arg> GraphOperation for RightShift<T, x_Arg, y_Arg>
where T: TensorType,
      T: Clone,
      x_Arg: Clone,
      x_Arg: GraphEdge<T>,
      x_Arg: 'static,
      y_Arg: Clone,
      y_Arg: GraphEdge<T>,
      y_Arg: 'static,
      T: con_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_UINT16_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("RightShift_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("RightShift", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.x)?
        }
        {
            new_op.add_edge(&self.y)?
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct RightShift<T, x_Arg, y_Arg>
where T: TensorType,
      T: Clone,
      x_Arg: Clone,
      x_Arg: GraphEdge<T>,
      x_Arg: 'static,
      y_Arg: Clone,
      y_Arg: GraphEdge<T>,
      y_Arg: 'static,
      T: con_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_UINT16_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    x: x_Arg,
    y: y_Arg,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<T, x_Arg, y_Arg> RightShift<T, x_Arg, y_Arg>
where T: TensorType,
      T: Clone,
      x_Arg: Clone,
      x_Arg: GraphEdge<T>,
      x_Arg: 'static,
      y_Arg: Clone,
      y_Arg: GraphEdge<T>,
      y_Arg: 'static,
      T: con_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_UINT16_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
{
    pub fn z(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(x: x_Arg, y: y_Arg) -> Self {
        Self {
            phantom_T: PhantomData,
            x,
            y,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(x: x_Arg, y: y_Arg) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            x,
            y,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<T, var_Arg, accum_Arg, lr_Arg, grad_Arg> GraphOperation for ApplyAdagrad<T, var_Arg, accum_Arg, lr_Arg, grad_Arg>
where T: TensorType,
      T: Clone,
      var_Arg: Clone,
      var_Arg: GraphRefEdge<T>,
      var_Arg: 'static,
      accum_Arg: Clone,
      accum_Arg: GraphRefEdge<T>,
      accum_Arg: 'static,
      lr_Arg: Clone,
      lr_Arg: GraphEdge<T>,
      lr_Arg: 'static,
      grad_Arg: Clone,
      grad_Arg: GraphEdge<T>,
      grad_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("ApplyAdagrad_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("ApplyAdagrad", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.var)?
        }
        {
            new_op.add_edge(&self.accum)?
        }
        {
            new_op.add_edge(&self.lr)?
        }
        {
            new_op.add_edge(&self.grad)?
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        {
            match self.use_locking {
                None => new_op.set_attr_value_proto("use_locking", &vec![40_u8, 0_u8,])?,
                Some(ref value) => (|attr: &bool| {new_op.set_attr_bool("use_locking", *attr)})(&value)?,
            };
        }
        {
            match self.update_slots {
                None => new_op.set_attr_value_proto("update_slots", &vec![40_u8, 1_u8,])?,
                Some(ref value) => (|attr: &bool| {new_op.set_attr_bool("update_slots", *attr)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct ApplyAdagrad<T, var_Arg, accum_Arg, lr_Arg, grad_Arg>
where T: TensorType,
      T: Clone,
      var_Arg: Clone,
      var_Arg: GraphRefEdge<T>,
      var_Arg: 'static,
      accum_Arg: Clone,
      accum_Arg: GraphRefEdge<T>,
      accum_Arg: 'static,
      lr_Arg: Clone,
      lr_Arg: GraphEdge<T>,
      lr_Arg: 'static,
      grad_Arg: Clone,
      grad_Arg: GraphEdge<T>,
      grad_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    var: var_Arg,
    accum: accum_Arg,
    lr: lr_Arg,
    grad: grad_Arg,
    use_locking: Option<bool>,
    update_slots: Option<bool>,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<T, var_Arg, accum_Arg, lr_Arg, grad_Arg> ApplyAdagrad<T, var_Arg, accum_Arg, lr_Arg, grad_Arg>
where T: TensorType,
      T: Clone,
      var_Arg: Clone,
      var_Arg: GraphRefEdge<T>,
      var_Arg: 'static,
      accum_Arg: Clone,
      accum_Arg: GraphRefEdge<T>,
      accum_Arg: 'static,
      lr_Arg: Clone,
      lr_Arg: GraphEdge<T>,
      lr_Arg: 'static,
      grad_Arg: Clone,
      grad_Arg: GraphEdge<T>,
      grad_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
{
    pub fn out(self) -> RefEdge<T> {
        let rc = Rc::new(self);
        {
            RefEdge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn use_locking(&mut self, use_locking: bool) -> Self {
        self.use_locking = Some(use_locking);
        self.clone()
    }

    pub fn update_slots(&mut self, update_slots: bool) -> Self {
        self.update_slots = Some(update_slots);
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> RefEdge<T> {
        let rc = Rc::new(self);
        {
            RefEdge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(var: var_Arg, accum: accum_Arg, lr: lr_Arg, grad: grad_Arg) -> Self {
        Self {
            phantom_T: PhantomData,
            var,
            accum,
            lr,
            grad,
            use_locking: None,
            update_slots: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(var: var_Arg, accum: accum_Arg, lr: lr_Arg, grad: grad_Arg) -> RefEdge<T> {
        Self {
            phantom_T: PhantomData,
            var,
            accum,
            lr,
            grad,
            use_locking: None,
            update_slots: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<tag_Arg, tensor_Arg, sample_rate_Arg> GraphOperation for AudioSummaryV2<tag_Arg, tensor_Arg, sample_rate_Arg>
where tag_Arg: Clone,
      tag_Arg: GraphEdge<String>,
      tag_Arg: 'static,
      tensor_Arg: Clone,
      tensor_Arg: GraphEdge<f32>,
      tensor_Arg: 'static,
      sample_rate_Arg: Clone,
      sample_rate_Arg: GraphEdge<f32>,
      sample_rate_Arg: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("AudioSummaryV2_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("AudioSummaryV2", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.tag)?
        }
        {
            new_op.add_edge(&self.tensor)?
        }
        {
            new_op.add_edge(&self.sample_rate)?
        }
        {
            match self.max_outputs {
                None => new_op.set_attr_value_proto("max_outputs", &vec![24_u8, 3_u8,])?,
                Some(ref value) => (|attr: &i64| {new_op.set_attr_int("max_outputs", *attr)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct AudioSummaryV2<tag_Arg, tensor_Arg, sample_rate_Arg>
where tag_Arg: Clone,
      tag_Arg: GraphEdge<String>,
      tag_Arg: 'static,
      tensor_Arg: Clone,
      tensor_Arg: GraphEdge<f32>,
      tensor_Arg: 'static,
      sample_rate_Arg: Clone,
      sample_rate_Arg: GraphEdge<f32>,
      sample_rate_Arg: 'static,
{
    tag: tag_Arg,
    tensor: tensor_Arg,
    sample_rate: sample_rate_Arg,
    max_outputs: Option<i64>,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<tag_Arg, tensor_Arg, sample_rate_Arg> AudioSummaryV2<tag_Arg, tensor_Arg, sample_rate_Arg>
where tag_Arg: Clone,
      tag_Arg: GraphEdge<String>,
      tag_Arg: 'static,
      tensor_Arg: Clone,
      tensor_Arg: GraphEdge<f32>,
      tensor_Arg: 'static,
      sample_rate_Arg: Clone,
      sample_rate_Arg: GraphEdge<f32>,
      sample_rate_Arg: 'static,
{
    pub fn summary(self) -> Edge<String> {
        let rc = Rc::new(self);
        {
            Edge::<String>::new(rc.clone(), 0)
        }
    }

    pub fn max_outputs(&mut self, max_outputs: i64) -> Self {
        self.max_outputs = Some(max_outputs);
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<String> {
        let rc = Rc::new(self);
        {
            Edge::<String>::new(rc.clone(), 0)
        }
    }

    pub fn build(tag: tag_Arg, tensor: tensor_Arg, sample_rate: sample_rate_Arg) -> Self {
        Self {
            tag,
            tensor,
            sample_rate,
            max_outputs: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(tag: tag_Arg, tensor: tensor_Arg, sample_rate: sample_rate_Arg) -> Edge<String> {
        Self {
            tag,
            tensor,
            sample_rate,
            max_outputs: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<T, shape_Arg, dtype, means_Arg, stdevs_Arg, minvals_Arg, maxvals_Arg> GraphOperation for ParameterizedTruncatedNormal<T, shape_Arg, dtype, means_Arg, stdevs_Arg, minvals_Arg, maxvals_Arg>
where T: TensorType,
      T: Clone,
      shape_Arg: Clone,
      shape_Arg: GraphEdge<T>,
      shape_Arg: 'static,
      dtype: TensorType,
      dtype: Clone,
      means_Arg: Clone,
      means_Arg: GraphEdge<dtype>,
      means_Arg: 'static,
      stdevs_Arg: Clone,
      stdevs_Arg: GraphEdge<dtype>,
      stdevs_Arg: 'static,
      minvals_Arg: Clone,
      minvals_Arg: GraphEdge<dtype>,
      minvals_Arg: 'static,
      maxvals_Arg: Clone,
      maxvals_Arg: GraphEdge<dtype>,
      maxvals_Arg: 'static,
      dtype: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
      dtype: 'static,
      T: con_or_DT_INT32_or_DT_INT64,
      T: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("ParameterizedTruncatedNormal_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("ParameterizedTruncatedNormal", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.shape)?
        }
        {
            new_op.add_edge(&self.means)?
        }
        {
            new_op.add_edge(&self.stdevs)?
        }
        {
            new_op.add_edge(&self.minvals)?
        }
        {
            new_op.add_edge(&self.maxvals)?
        }
        {
            match self.seed {
                None => new_op.set_attr_value_proto("seed", &vec![24_u8, 0_u8,])?,
                Some(ref value) => (|attr: &i64| {new_op.set_attr_int("seed", *attr)})(&value)?,
            };
        }
        {
            match self.seed2 {
                None => new_op.set_attr_value_proto("seed2", &vec![24_u8, 0_u8,])?,
                Some(ref value) => (|attr: &i64| {new_op.set_attr_int("seed2", *attr)})(&value)?,
            };
        }
        {
            new_op.set_attr_type("dtype", dtype::data_type())?;
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct ParameterizedTruncatedNormal<T, shape_Arg, dtype, means_Arg, stdevs_Arg, minvals_Arg, maxvals_Arg>
where T: TensorType,
      T: Clone,
      shape_Arg: Clone,
      shape_Arg: GraphEdge<T>,
      shape_Arg: 'static,
      dtype: TensorType,
      dtype: Clone,
      means_Arg: Clone,
      means_Arg: GraphEdge<dtype>,
      means_Arg: 'static,
      stdevs_Arg: Clone,
      stdevs_Arg: GraphEdge<dtype>,
      stdevs_Arg: 'static,
      minvals_Arg: Clone,
      minvals_Arg: GraphEdge<dtype>,
      minvals_Arg: 'static,
      maxvals_Arg: Clone,
      maxvals_Arg: GraphEdge<dtype>,
      maxvals_Arg: 'static,
      dtype: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
      dtype: 'static,
      T: con_or_DT_INT32_or_DT_INT64,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    shape: shape_Arg,
    phantom_dtype: PhantomData<dtype>,
    means: means_Arg,
    stdevs: stdevs_Arg,
    minvals: minvals_Arg,
    maxvals: maxvals_Arg,
    seed: Option<i64>,
    seed2: Option<i64>,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<T, shape_Arg, dtype, means_Arg, stdevs_Arg, minvals_Arg, maxvals_Arg> ParameterizedTruncatedNormal<T, shape_Arg, dtype, means_Arg, stdevs_Arg, minvals_Arg, maxvals_Arg>
where T: TensorType,
      T: Clone,
      shape_Arg: Clone,
      shape_Arg: GraphEdge<T>,
      shape_Arg: 'static,
      dtype: TensorType,
      dtype: Clone,
      means_Arg: Clone,
      means_Arg: GraphEdge<dtype>,
      means_Arg: 'static,
      stdevs_Arg: Clone,
      stdevs_Arg: GraphEdge<dtype>,
      stdevs_Arg: 'static,
      minvals_Arg: Clone,
      minvals_Arg: GraphEdge<dtype>,
      minvals_Arg: 'static,
      maxvals_Arg: Clone,
      maxvals_Arg: GraphEdge<dtype>,
      maxvals_Arg: 'static,
      dtype: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
      dtype: 'static,
      T: con_or_DT_INT32_or_DT_INT64,
      T: 'static,
{
    pub fn output(self) -> Edge<dtype> {
        let rc = Rc::new(self);
        {
            Edge::<dtype>::new(rc.clone(), 0)
        }
    }

    pub fn seed(&mut self, seed: i64) -> Self {
        self.seed = Some(seed);
        self.clone()
    }

    pub fn seed2(&mut self, seed2: i64) -> Self {
        self.seed2 = Some(seed2);
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<dtype> {
        let rc = Rc::new(self);
        {
            Edge::<dtype>::new(rc.clone(), 0)
        }
    }

    pub fn build(shape: shape_Arg, means: means_Arg, stdevs: stdevs_Arg, minvals: minvals_Arg, maxvals: maxvals_Arg) -> Self {
        Self {
            phantom_T: PhantomData,
            shape,
            phantom_dtype: PhantomData,
            means,
            stdevs,
            minvals,
            maxvals,
            seed: None,
            seed2: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(shape: shape_Arg, means: means_Arg, stdevs: stdevs_Arg, minvals: minvals_Arg, maxvals: maxvals_Arg) -> Edge<dtype> {
        Self {
            phantom_T: PhantomData,
            shape,
            phantom_dtype: PhantomData,
            means,
            stdevs,
            minvals,
            maxvals,
            seed: None,
            seed2: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<T, diagonal_Arg> GraphOperation for Diag<T, diagonal_Arg>
where T: TensorType,
      T: Clone,
      diagonal_Arg: Clone,
      diagonal_Arg: GraphEdge<T>,
      diagonal_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_COMPLEX64_or_DT_INT64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF,
      T: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("Diag_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("Diag", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.diagonal)?
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct Diag<T, diagonal_Arg>
where T: TensorType,
      T: Clone,
      diagonal_Arg: Clone,
      diagonal_Arg: GraphEdge<T>,
      diagonal_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_COMPLEX64_or_DT_INT64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    diagonal: diagonal_Arg,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<T, diagonal_Arg> Diag<T, diagonal_Arg>
where T: TensorType,
      T: Clone,
      diagonal_Arg: Clone,
      diagonal_Arg: GraphEdge<T>,
      diagonal_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_COMPLEX64_or_DT_INT64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF,
      T: 'static,
{
    pub fn output(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(diagonal: diagonal_Arg) -> Self {
        Self {
            phantom_T: PhantomData,
            diagonal,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(diagonal: diagonal_Arg) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            diagonal,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

pub trait con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_BOOL_or_DT_COMPLEX128 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_BOOL_or_DT_COMPLEX128 for OtherComplex<f32> {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_BOOL_or_DT_COMPLEX128 for OtherComplex<f64> {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_BOOL_or_DT_COMPLEX128 for bool {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_BOOL_or_DT_COMPLEX128 for f32 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_BOOL_or_DT_COMPLEX128 for f64 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_BOOL_or_DT_COMPLEX128 for i16 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_BOOL_or_DT_COMPLEX128 for i32 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_BOOL_or_DT_COMPLEX128 for i64 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_BOOL_or_DT_COMPLEX128 for i8 {
}

impl<T, input_Arg> GraphOperation for AsString<T, input_Arg>
where T: TensorType,
      T: Clone,
      input_Arg: Clone,
      input_Arg: GraphEdge<T>,
      input_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_BOOL_or_DT_COMPLEX128,
      T: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("AsString_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("AsString", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.input)?
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        {
            match self.precision {
                None => new_op.set_attr_value_proto("precision", &vec![24_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 1_u8,])?,
                Some(ref value) => (|attr: &i64| {new_op.set_attr_int("precision", *attr)})(&value)?,
            };
        }
        {
            match self.scientific {
                None => new_op.set_attr_value_proto("scientific", &vec![40_u8, 0_u8,])?,
                Some(ref value) => (|attr: &bool| {new_op.set_attr_bool("scientific", *attr)})(&value)?,
            };
        }
        {
            match self.shortest {
                None => new_op.set_attr_value_proto("shortest", &vec![40_u8, 0_u8,])?,
                Some(ref value) => (|attr: &bool| {new_op.set_attr_bool("shortest", *attr)})(&value)?,
            };
        }
        {
            match self.width {
                None => new_op.set_attr_value_proto("width", &vec![24_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 1_u8,])?,
                Some(ref value) => (|attr: &i64| {new_op.set_attr_int("width", *attr)})(&value)?,
            };
        }
        {
            match self.fill {
                None => new_op.set_attr_value_proto("fill", &vec![18_u8, 0_u8,])?,
                Some(ref value) => (|attr| {new_op.set_attr_string("fill", attr)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct AsString<T, input_Arg>
where T: TensorType,
      T: Clone,
      input_Arg: Clone,
      input_Arg: GraphEdge<T>,
      input_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_BOOL_or_DT_COMPLEX128,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    input: input_Arg,
    precision: Option<i64>,
    scientific: Option<bool>,
    shortest: Option<bool>,
    width: Option<i64>,
    fill: Option<String>,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<T, input_Arg> AsString<T, input_Arg>
where T: TensorType,
      T: Clone,
      input_Arg: Clone,
      input_Arg: GraphEdge<T>,
      input_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_BOOL_or_DT_COMPLEX128,
      T: 'static,
{
    pub fn output(self) -> Edge<String> {
        let rc = Rc::new(self);
        {
            Edge::<String>::new(rc.clone(), 0)
        }
    }

    pub fn precision(&mut self, precision: i64) -> Self {
        self.precision = Some(precision);
        self.clone()
    }

    pub fn scientific(&mut self, scientific: bool) -> Self {
        self.scientific = Some(scientific);
        self.clone()
    }

    pub fn shortest(&mut self, shortest: bool) -> Self {
        self.shortest = Some(shortest);
        self.clone()
    }

    pub fn width(&mut self, width: i64) -> Self {
        self.width = Some(width);
        self.clone()
    }

    pub fn fill(&mut self, fill: &str) -> Self {
        self.fill = Some(fill.to_string());
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<String> {
        let rc = Rc::new(self);
        {
            Edge::<String>::new(rc.clone(), 0)
        }
    }

    pub fn build(input: input_Arg) -> Self {
        Self {
            phantom_T: PhantomData,
            input,
            precision: None,
            scientific: None,
            shortest: None,
            width: None,
            fill: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(input: input_Arg) -> Edge<String> {
        Self {
            phantom_T: PhantomData,
            input,
            precision: None,
            scientific: None,
            shortest: None,
            width: None,
            fill: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<handle_Arg, indices_Arg, T, value_Arg, flow_in_Arg> GraphOperation for TensorArrayScatterV2<handle_Arg, indices_Arg, T, value_Arg, flow_in_Arg>
where handle_Arg: Clone,
      handle_Arg: GraphEdge<String>,
      handle_Arg: 'static,
      indices_Arg: Clone,
      indices_Arg: GraphEdge<i32>,
      indices_Arg: 'static,
      T: TensorType,
      T: Clone,
      value_Arg: Clone,
      value_Arg: GraphEdge<T>,
      value_Arg: 'static,
      flow_in_Arg: Clone,
      flow_in_Arg: GraphEdge<f32>,
      flow_in_Arg: 'static,
      T: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("TensorArrayScatterV2_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("TensorArrayScatterV2", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.handle)?
        }
        {
            new_op.add_edge(&self.indices)?
        }
        {
            new_op.add_edge(&self.value)?
        }
        {
            new_op.add_edge(&self.flow_in)?
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct TensorArrayScatterV2<handle_Arg, indices_Arg, T, value_Arg, flow_in_Arg>
where handle_Arg: Clone,
      handle_Arg: GraphEdge<String>,
      handle_Arg: 'static,
      indices_Arg: Clone,
      indices_Arg: GraphEdge<i32>,
      indices_Arg: 'static,
      T: TensorType,
      T: Clone,
      value_Arg: Clone,
      value_Arg: GraphEdge<T>,
      value_Arg: 'static,
      flow_in_Arg: Clone,
      flow_in_Arg: GraphEdge<f32>,
      flow_in_Arg: 'static,
      T: 'static,
{
    handle: handle_Arg,
    indices: indices_Arg,
    phantom_T: PhantomData<T>,
    value: value_Arg,
    flow_in: flow_in_Arg,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<handle_Arg, indices_Arg, T, value_Arg, flow_in_Arg> TensorArrayScatterV2<handle_Arg, indices_Arg, T, value_Arg, flow_in_Arg>
where handle_Arg: Clone,
      handle_Arg: GraphEdge<String>,
      handle_Arg: 'static,
      indices_Arg: Clone,
      indices_Arg: GraphEdge<i32>,
      indices_Arg: 'static,
      T: TensorType,
      T: Clone,
      value_Arg: Clone,
      value_Arg: GraphEdge<T>,
      value_Arg: 'static,
      flow_in_Arg: Clone,
      flow_in_Arg: GraphEdge<f32>,
      flow_in_Arg: 'static,
      T: 'static,
{
    pub fn flow_out(self) -> Edge<f32> {
        let rc = Rc::new(self);
        {
            Edge::<f32>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<f32> {
        let rc = Rc::new(self);
        {
            Edge::<f32>::new(rc.clone(), 0)
        }
    }

    pub fn build(handle: handle_Arg, indices: indices_Arg, value: value_Arg, flow_in: flow_in_Arg) -> Self {
        Self {
            handle,
            indices,
            phantom_T: PhantomData,
            value,
            flow_in,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(handle: handle_Arg, indices: indices_Arg, value: value_Arg, flow_in: flow_in_Arg) -> Edge<f32> {
        Self {
            handle,
            indices,
            phantom_T: PhantomData,
            value,
            flow_in,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

pub trait con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_UINT8_or_DT_HALF {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_UINT8_or_DT_HALF for f32 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_UINT8_or_DT_HALF for f64 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_UINT8_or_DT_HALF for u8 {
}

impl<tag_Arg, T, tensor_Arg> GraphOperation for ImageSummary<tag_Arg, T, tensor_Arg>
where tag_Arg: Clone,
      tag_Arg: GraphEdge<String>,
      tag_Arg: 'static,
      T: TensorType,
      T: Clone,
      tensor_Arg: Clone,
      tensor_Arg: GraphEdge<T>,
      tensor_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_UINT8_or_DT_HALF,
      T: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("ImageSummary_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("ImageSummary", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.tag)?
        }
        {
            new_op.add_edge(&self.tensor)?
        }
        {
            match self.max_images {
                None => new_op.set_attr_value_proto("max_images", &vec![24_u8, 3_u8,])?,
                Some(ref value) => (|attr: &i64| {new_op.set_attr_int("max_images", *attr)})(&value)?,
            };
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        {
            match self.bad_color {
                None => new_op.set_attr_value_proto("bad_color", &vec![66_u8, 0_u8, 8_u8, 4_u8, 18_u8, 0_u8, 18_u8, 0_u8, 8_u8, 4_u8, 58_u8, 6_u8, 255_u8, 1_u8, 0_u8, 0_u8,])?,
                Some(ref value) => (|attr: &Rc<AnyTensor>| {new_op.set_attr_tensor_owned("bad_color", attr.clone())})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct ImageSummary<tag_Arg, T, tensor_Arg>
where tag_Arg: Clone,
      tag_Arg: GraphEdge<String>,
      tag_Arg: 'static,
      T: TensorType,
      T: Clone,
      tensor_Arg: Clone,
      tensor_Arg: GraphEdge<T>,
      tensor_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_UINT8_or_DT_HALF,
      T: 'static,
{
    tag: tag_Arg,
    phantom_T: PhantomData<T>,
    tensor: tensor_Arg,
    max_images: Option<i64>,
    bad_color: Option<Rc<AnyTensor>>,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<tag_Arg, T, tensor_Arg> ImageSummary<tag_Arg, T, tensor_Arg>
where tag_Arg: Clone,
      tag_Arg: GraphEdge<String>,
      tag_Arg: 'static,
      T: TensorType,
      T: Clone,
      tensor_Arg: Clone,
      tensor_Arg: GraphEdge<T>,
      tensor_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_UINT8_or_DT_HALF,
      T: 'static,
{
    pub fn summary(self) -> Edge<String> {
        let rc = Rc::new(self);
        {
            Edge::<String>::new(rc.clone(), 0)
        }
    }

    pub fn max_images(&mut self, max_images: i64) -> Self {
        self.max_images = Some(max_images);
        self.clone()
    }

    pub fn bad_color<bad_color_T, bad_color_TensorType>(&mut self, bad_color: bad_color_T) -> Self
    where Tensor<bad_color_TensorType>: From<bad_color_T>,
          bad_color_T: 'static,
          bad_color_TensorType: TensorType,
    {
        self.bad_color = Some(Rc::new(Tensor::<bad_color_TensorType>::from(bad_color)));
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<String> {
        let rc = Rc::new(self);
        {
            Edge::<String>::new(rc.clone(), 0)
        }
    }

    pub fn build(tag: tag_Arg, tensor: tensor_Arg) -> Self {
        Self {
            tag,
            phantom_T: PhantomData,
            tensor,
            max_images: None,
            bad_color: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(tag: tag_Arg, tensor: tensor_Arg) -> Edge<String> {
        Self {
            tag,
            phantom_T: PhantomData,
            tensor,
            max_images: None,
            bad_color: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<T, value_Arg> GraphOperation for AvgPool<T, value_Arg>
where T: TensorType,
      T: Clone,
      value_Arg: Clone,
      value_Arg: GraphEdge<T>,
      value_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
      T: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("AvgPool_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("AvgPool", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.value)?
        }
        {
            (|attrs| {new_op.set_attr_int_list("ksize", attrs)})(&self.ksize)?
        }
        {
            (|attrs| {new_op.set_attr_int_list("strides", attrs)})(&self.strides)?
        }
        {
            (|attr| {new_op.set_attr_string("padding", attr)})(&self.padding)?
        }
        {
            match self.data_format {
                None => new_op.set_attr_value_proto("data_format", &vec![18_u8, 4_u8, 78_u8, 72_u8, 87_u8, 67_u8,])?,
                Some(ref value) => (|attr| {new_op.set_attr_string("data_format", attr)})(&value)?,
            };
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct AvgPool<T, value_Arg>
where T: TensorType,
      T: Clone,
      value_Arg: Clone,
      value_Arg: GraphEdge<T>,
      value_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    value: value_Arg,
    ksize: Vec<i64>,
    strides: Vec<i64>,
    padding: String,
    data_format: Option<String>,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<T, value_Arg> AvgPool<T, value_Arg>
where T: TensorType,
      T: Clone,
      value_Arg: Clone,
      value_Arg: GraphEdge<T>,
      value_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
      T: 'static,
{
    pub fn output(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn data_format(&mut self, data_format: &str) -> Self {
        self.data_format = Some(data_format.to_string());
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(value: value_Arg, ksize: &[i64], strides: &[i64], padding: &str) -> Self {
        Self {
            phantom_T: PhantomData,
            value,
            ksize: ksize.to_vec(),
            strides: strides.to_vec(),
            padding: padding.to_string(),
            data_format: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(value: value_Arg, ksize: &[i64], strides: &[i64], padding: &str) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            value,
            ksize: ksize.to_vec(),
            strides: strides.to_vec(),
            padding: padding.to_string(),
            data_format: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<inputs_Arg> GraphOperation for MergeSummary<inputs_Arg>
where inputs_Arg: Clone,
      inputs_Arg: GraphEdge<String>,
      inputs_Arg: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("MergeSummary_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("MergeSummary", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.inputs)?
        }
        {
            (|attr: &i64| {new_op.set_attr_int("N", *attr)})(&self.N)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct MergeSummary<inputs_Arg>
where inputs_Arg: Clone,
      inputs_Arg: GraphEdge<String>,
      inputs_Arg: 'static,
{
    inputs: inputs_Arg,
    N: i64,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<inputs_Arg> MergeSummary<inputs_Arg>
where inputs_Arg: Clone,
      inputs_Arg: GraphEdge<String>,
      inputs_Arg: 'static,
{
    pub fn summary(self) -> Edge<String> {
        let rc = Rc::new(self);
        {
            Edge::<String>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<String> {
        let rc = Rc::new(self);
        {
            Edge::<String>::new(rc.clone(), 0)
        }
    }

    pub fn build(inputs: inputs_Arg, N: i64) -> Self {
        Self {
            inputs,
            N: N,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(inputs: inputs_Arg, N: i64) -> Edge<String> {
        Self {
            inputs,
            N: N,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl GraphOperation for Timestamp {
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("Timestamp_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("Timestamp", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct Timestamp {
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl Timestamp {
    pub fn ts(self) -> Edge<f64> {
        let rc = Rc::new(self);
        {
            Edge::<f64>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<f64> {
        let rc = Rc::new(self);
        {
            Edge::<f64>::new(rc.clone(), 0)
        }
    }

    pub fn build() -> Self {
        Self {
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new() -> Edge<f64> {
        Self {
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<T, input_Arg> GraphOperation for BatchMatrixDiagPart<T, input_Arg>
where T: TensorType,
      T: Clone,
      input_Arg: Clone,
      input_Arg: GraphEdge<T>,
      input_Arg: 'static,
      T: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("BatchMatrixDiagPart_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("BatchMatrixDiagPart", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.input)?
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct BatchMatrixDiagPart<T, input_Arg>
where T: TensorType,
      T: Clone,
      input_Arg: Clone,
      input_Arg: GraphEdge<T>,
      input_Arg: 'static,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    input: input_Arg,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<T, input_Arg> BatchMatrixDiagPart<T, input_Arg>
where T: TensorType,
      T: Clone,
      input_Arg: Clone,
      input_Arg: GraphEdge<T>,
      input_Arg: 'static,
      T: 'static,
{
    pub fn diagonal(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(input: input_Arg) -> Self {
        Self {
            phantom_T: PhantomData,
            input,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(input: input_Arg) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            input,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<T, data_Arg, Tindices, segment_ids_Arg> GraphOperation for SegmentMin<T, data_Arg, Tindices, segment_ids_Arg>
where T: TensorType,
      T: Clone,
      data_Arg: Clone,
      data_Arg: GraphEdge<T>,
      data_Arg: 'static,
      Tindices: TensorType,
      Tindices: Clone,
      segment_ids_Arg: Clone,
      segment_ids_Arg: GraphEdge<Tindices>,
      segment_ids_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
      Tindices: con_or_DT_INT32_or_DT_INT64,
      Tindices: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("SegmentMin_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("SegmentMin", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.data)?
        }
        {
            new_op.add_edge(&self.segment_ids)?
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        {
            new_op.set_attr_type("Tindices", Tindices::data_type())?;
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct SegmentMin<T, data_Arg, Tindices, segment_ids_Arg>
where T: TensorType,
      T: Clone,
      data_Arg: Clone,
      data_Arg: GraphEdge<T>,
      data_Arg: 'static,
      Tindices: TensorType,
      Tindices: Clone,
      segment_ids_Arg: Clone,
      segment_ids_Arg: GraphEdge<Tindices>,
      segment_ids_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
      Tindices: con_or_DT_INT32_or_DT_INT64,
      Tindices: 'static,
{
    phantom_T: PhantomData<T>,
    data: data_Arg,
    phantom_Tindices: PhantomData<Tindices>,
    segment_ids: segment_ids_Arg,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<T, data_Arg, Tindices, segment_ids_Arg> SegmentMin<T, data_Arg, Tindices, segment_ids_Arg>
where T: TensorType,
      T: Clone,
      data_Arg: Clone,
      data_Arg: GraphEdge<T>,
      data_Arg: 'static,
      Tindices: TensorType,
      Tindices: Clone,
      segment_ids_Arg: Clone,
      segment_ids_Arg: GraphEdge<Tindices>,
      segment_ids_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
      Tindices: con_or_DT_INT32_or_DT_INT64,
      Tindices: 'static,
{
    pub fn output(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(data: data_Arg, segment_ids: segment_ids_Arg) -> Self {
        Self {
            phantom_T: PhantomData,
            data,
            phantom_Tindices: PhantomData,
            segment_ids,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(data: data_Arg, segment_ids: segment_ids_Arg) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            data,
            phantom_Tindices: PhantomData,
            segment_ids,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<grads_Arg, T, original_image_Arg> GraphOperation for ResizeBicubicGrad<grads_Arg, T, original_image_Arg>
where grads_Arg: Clone,
      grads_Arg: GraphEdge<f32>,
      grads_Arg: 'static,
      T: TensorType,
      T: Clone,
      original_image_Arg: Clone,
      original_image_Arg: GraphEdge<T>,
      original_image_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE,
      T: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("ResizeBicubicGrad_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("ResizeBicubicGrad", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.grads)?
        }
        {
            new_op.add_edge(&self.original_image)?
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        {
            match self.align_corners {
                None => new_op.set_attr_value_proto("align_corners", &vec![40_u8, 0_u8,])?,
                Some(ref value) => (|attr: &bool| {new_op.set_attr_bool("align_corners", *attr)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct ResizeBicubicGrad<grads_Arg, T, original_image_Arg>
where grads_Arg: Clone,
      grads_Arg: GraphEdge<f32>,
      grads_Arg: 'static,
      T: TensorType,
      T: Clone,
      original_image_Arg: Clone,
      original_image_Arg: GraphEdge<T>,
      original_image_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE,
      T: 'static,
{
    grads: grads_Arg,
    phantom_T: PhantomData<T>,
    original_image: original_image_Arg,
    align_corners: Option<bool>,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<grads_Arg, T, original_image_Arg> ResizeBicubicGrad<grads_Arg, T, original_image_Arg>
where grads_Arg: Clone,
      grads_Arg: GraphEdge<f32>,
      grads_Arg: 'static,
      T: TensorType,
      T: Clone,
      original_image_Arg: Clone,
      original_image_Arg: GraphEdge<T>,
      original_image_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE,
      T: 'static,
{
    pub fn output(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn align_corners(&mut self, align_corners: bool) -> Self {
        self.align_corners = Some(align_corners);
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(grads: grads_Arg, original_image: original_image_Arg) -> Self {
        Self {
            grads,
            phantom_T: PhantomData,
            original_image,
            align_corners: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(grads: grads_Arg, original_image: original_image_Arg) -> Edge<T> {
        Self {
            grads,
            phantom_T: PhantomData,
            original_image,
            align_corners: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<key_dtype, value_dtype> GraphOperation for HashTable<key_dtype, value_dtype>
where key_dtype: TensorType,
      key_dtype: 'static,
      key_dtype: Clone,
      value_dtype: TensorType,
      value_dtype: 'static,
      value_dtype: Clone,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("HashTable_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("HashTable", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            match self.container {
                None => new_op.set_attr_value_proto("container", &vec![18_u8, 0_u8,])?,
                Some(ref value) => (|attr| {new_op.set_attr_string("container", attr)})(&value)?,
            };
        }
        {
            match self.shared_name {
                None => new_op.set_attr_value_proto("shared_name", &vec![18_u8, 0_u8,])?,
                Some(ref value) => (|attr| {new_op.set_attr_string("shared_name", attr)})(&value)?,
            };
        }
        {
            match self.use_node_name_sharing {
                None => new_op.set_attr_value_proto("use_node_name_sharing", &vec![40_u8, 0_u8,])?,
                Some(ref value) => (|attr: &bool| {new_op.set_attr_bool("use_node_name_sharing", *attr)})(&value)?,
            };
        }
        {
            new_op.set_attr_type("key_dtype", key_dtype::data_type())?;
        }
        {
            new_op.set_attr_type("value_dtype", value_dtype::data_type())?;
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct HashTable<key_dtype, value_dtype>
where key_dtype: TensorType,
      key_dtype: 'static,
      key_dtype: Clone,
      value_dtype: TensorType,
      value_dtype: 'static,
      value_dtype: Clone,
{
    container: Option<String>,
    shared_name: Option<String>,
    use_node_name_sharing: Option<bool>,
    phantom_key_dtype: PhantomData<key_dtype>,
    phantom_value_dtype: PhantomData<value_dtype>,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<key_dtype, value_dtype> HashTable<key_dtype, value_dtype>
where key_dtype: TensorType,
      key_dtype: 'static,
      key_dtype: Clone,
      value_dtype: TensorType,
      value_dtype: 'static,
      value_dtype: Clone,
{
    pub fn table_handle(self) -> RefEdge<String> {
        let rc = Rc::new(self);
        {
            RefEdge::<String>::new(rc.clone(), 0)
        }
    }

    pub fn container(&mut self, container: &str) -> Self {
        self.container = Some(container.to_string());
        self.clone()
    }

    pub fn shared_name(&mut self, shared_name: &str) -> Self {
        self.shared_name = Some(shared_name.to_string());
        self.clone()
    }

    pub fn use_node_name_sharing(&mut self, use_node_name_sharing: bool) -> Self {
        self.use_node_name_sharing = Some(use_node_name_sharing);
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> RefEdge<String> {
        let rc = Rc::new(self);
        {
            RefEdge::<String>::new(rc.clone(), 0)
        }
    }

    pub fn build() -> Self {
        Self {
            container: None,
            shared_name: None,
            use_node_name_sharing: None,
            phantom_key_dtype: PhantomData,
            phantom_value_dtype: PhantomData,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new() -> RefEdge<String> {
        Self {
            container: None,
            shared_name: None,
            use_node_name_sharing: None,
            phantom_key_dtype: PhantomData,
            phantom_value_dtype: PhantomData,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<key_dtype, value_dtype> GraphOperation for MutableHashTable<key_dtype, value_dtype>
where key_dtype: TensorType,
      key_dtype: 'static,
      key_dtype: Clone,
      value_dtype: TensorType,
      value_dtype: 'static,
      value_dtype: Clone,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("MutableHashTable_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("MutableHashTable", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            match self.container {
                None => new_op.set_attr_value_proto("container", &vec![18_u8, 0_u8,])?,
                Some(ref value) => (|attr| {new_op.set_attr_string("container", attr)})(&value)?,
            };
        }
        {
            match self.shared_name {
                None => new_op.set_attr_value_proto("shared_name", &vec![18_u8, 0_u8,])?,
                Some(ref value) => (|attr| {new_op.set_attr_string("shared_name", attr)})(&value)?,
            };
        }
        {
            match self.use_node_name_sharing {
                None => new_op.set_attr_value_proto("use_node_name_sharing", &vec![40_u8, 0_u8,])?,
                Some(ref value) => (|attr: &bool| {new_op.set_attr_bool("use_node_name_sharing", *attr)})(&value)?,
            };
        }
        {
            new_op.set_attr_type("key_dtype", key_dtype::data_type())?;
        }
        {
            new_op.set_attr_type("value_dtype", value_dtype::data_type())?;
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct MutableHashTable<key_dtype, value_dtype>
where key_dtype: TensorType,
      key_dtype: 'static,
      key_dtype: Clone,
      value_dtype: TensorType,
      value_dtype: 'static,
      value_dtype: Clone,
{
    container: Option<String>,
    shared_name: Option<String>,
    use_node_name_sharing: Option<bool>,
    phantom_key_dtype: PhantomData<key_dtype>,
    phantom_value_dtype: PhantomData<value_dtype>,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<key_dtype, value_dtype> MutableHashTable<key_dtype, value_dtype>
where key_dtype: TensorType,
      key_dtype: 'static,
      key_dtype: Clone,
      value_dtype: TensorType,
      value_dtype: 'static,
      value_dtype: Clone,
{
    pub fn table_handle(self) -> RefEdge<String> {
        let rc = Rc::new(self);
        {
            RefEdge::<String>::new(rc.clone(), 0)
        }
    }

    pub fn container(&mut self, container: &str) -> Self {
        self.container = Some(container.to_string());
        self.clone()
    }

    pub fn shared_name(&mut self, shared_name: &str) -> Self {
        self.shared_name = Some(shared_name.to_string());
        self.clone()
    }

    pub fn use_node_name_sharing(&mut self, use_node_name_sharing: bool) -> Self {
        self.use_node_name_sharing = Some(use_node_name_sharing);
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> RefEdge<String> {
        let rc = Rc::new(self);
        {
            RefEdge::<String>::new(rc.clone(), 0)
        }
    }

    pub fn build() -> Self {
        Self {
            container: None,
            shared_name: None,
            use_node_name_sharing: None,
            phantom_key_dtype: PhantomData,
            phantom_value_dtype: PhantomData,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new() -> RefEdge<String> {
        Self {
            container: None,
            shared_name: None,
            use_node_name_sharing: None,
            phantom_key_dtype: PhantomData,
            phantom_value_dtype: PhantomData,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<table_handle_Arg, Tkey, keys_Arg, Tval, values_Arg> GraphOperation for InitializeTable<table_handle_Arg, Tkey, keys_Arg, Tval, values_Arg>
where table_handle_Arg: Clone,
      table_handle_Arg: GraphRefEdge<String>,
      table_handle_Arg: 'static,
      Tkey: TensorType,
      Tkey: Clone,
      keys_Arg: Clone,
      keys_Arg: GraphEdge<Tkey>,
      keys_Arg: 'static,
      Tval: TensorType,
      Tval: Clone,
      values_Arg: Clone,
      values_Arg: GraphEdge<Tval>,
      values_Arg: 'static,
      Tkey: 'static,
      Tval: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("InitializeTable_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("InitializeTable", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.table_handle)?
        }
        {
            new_op.add_edge(&self.keys)?
        }
        {
            new_op.add_edge(&self.values)?
        }
        {
            new_op.set_attr_type("Tkey", Tkey::data_type())?;
        }
        {
            new_op.set_attr_type("Tval", Tval::data_type())?;
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct InitializeTable<table_handle_Arg, Tkey, keys_Arg, Tval, values_Arg>
where table_handle_Arg: Clone,
      table_handle_Arg: GraphRefEdge<String>,
      table_handle_Arg: 'static,
      Tkey: TensorType,
      Tkey: Clone,
      keys_Arg: Clone,
      keys_Arg: GraphEdge<Tkey>,
      keys_Arg: 'static,
      Tval: TensorType,
      Tval: Clone,
      values_Arg: Clone,
      values_Arg: GraphEdge<Tval>,
      values_Arg: 'static,
      Tkey: 'static,
      Tval: 'static,
{
    table_handle: table_handle_Arg,
    phantom_Tkey: PhantomData<Tkey>,
    keys: keys_Arg,
    phantom_Tval: PhantomData<Tval>,
    values: values_Arg,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<table_handle_Arg, Tkey, keys_Arg, Tval, values_Arg> InitializeTable<table_handle_Arg, Tkey, keys_Arg, Tval, values_Arg>
where table_handle_Arg: Clone,
      table_handle_Arg: GraphRefEdge<String>,
      table_handle_Arg: 'static,
      Tkey: TensorType,
      Tkey: Clone,
      keys_Arg: Clone,
      keys_Arg: GraphEdge<Tkey>,
      keys_Arg: 'static,
      Tval: TensorType,
      Tval: Clone,
      values_Arg: Clone,
      values_Arg: GraphEdge<Tval>,
      values_Arg: 'static,
      Tkey: 'static,
      Tval: 'static,
{
    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> () {
        let rc = Rc::new(self);
        (
        )
    }

    pub fn build(table_handle: table_handle_Arg, keys: keys_Arg, values: values_Arg) -> Self {
        Self {
            table_handle,
            phantom_Tkey: PhantomData,
            keys,
            phantom_Tval: PhantomData,
            values,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(table_handle: table_handle_Arg, keys: keys_Arg, values: values_Arg) -> () {
        Self {
            table_handle,
            phantom_Tkey: PhantomData,
            keys,
            phantom_Tval: PhantomData,
            values,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl GraphOperation for ShutdownDistributedTPU {
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("ShutdownDistributedTPU_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("ShutdownDistributedTPU", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct ShutdownDistributedTPU {
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl ShutdownDistributedTPU {
    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> () {
        let rc = Rc::new(self);
        (
        )
    }

    pub fn build() -> Self {
        Self {
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new() -> () {
        Self {
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<T, images_Arg, contrast_factor_Arg, min_value_Arg, max_value_Arg> GraphOperation for AdjustContrast<T, images_Arg, contrast_factor_Arg, min_value_Arg, max_value_Arg>
where T: TensorType,
      T: Clone,
      images_Arg: Clone,
      images_Arg: GraphEdge<T>,
      images_Arg: 'static,
      contrast_factor_Arg: Clone,
      contrast_factor_Arg: GraphEdge<f32>,
      contrast_factor_Arg: 'static,
      min_value_Arg: Clone,
      min_value_Arg: GraphEdge<f32>,
      min_value_Arg: 'static,
      max_value_Arg: Clone,
      max_value_Arg: GraphEdge<f32>,
      max_value_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64,
      T: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("AdjustContrast_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("AdjustContrast", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.images)?
        }
        {
            new_op.add_edge(&self.contrast_factor)?
        }
        {
            new_op.add_edge(&self.min_value)?
        }
        {
            new_op.add_edge(&self.max_value)?
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct AdjustContrast<T, images_Arg, contrast_factor_Arg, min_value_Arg, max_value_Arg>
where T: TensorType,
      T: Clone,
      images_Arg: Clone,
      images_Arg: GraphEdge<T>,
      images_Arg: 'static,
      contrast_factor_Arg: Clone,
      contrast_factor_Arg: GraphEdge<f32>,
      contrast_factor_Arg: 'static,
      min_value_Arg: Clone,
      min_value_Arg: GraphEdge<f32>,
      min_value_Arg: 'static,
      max_value_Arg: Clone,
      max_value_Arg: GraphEdge<f32>,
      max_value_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    images: images_Arg,
    contrast_factor: contrast_factor_Arg,
    min_value: min_value_Arg,
    max_value: max_value_Arg,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<T, images_Arg, contrast_factor_Arg, min_value_Arg, max_value_Arg> AdjustContrast<T, images_Arg, contrast_factor_Arg, min_value_Arg, max_value_Arg>
where T: TensorType,
      T: Clone,
      images_Arg: Clone,
      images_Arg: GraphEdge<T>,
      images_Arg: 'static,
      contrast_factor_Arg: Clone,
      contrast_factor_Arg: GraphEdge<f32>,
      contrast_factor_Arg: 'static,
      min_value_Arg: Clone,
      min_value_Arg: GraphEdge<f32>,
      min_value_Arg: 'static,
      max_value_Arg: Clone,
      max_value_Arg: GraphEdge<f32>,
      max_value_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64,
      T: 'static,
{
    pub fn output(self) -> Edge<f32> {
        let rc = Rc::new(self);
        {
            Edge::<f32>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<f32> {
        let rc = Rc::new(self);
        {
            Edge::<f32>::new(rc.clone(), 0)
        }
    }

    pub fn build(images: images_Arg, contrast_factor: contrast_factor_Arg, min_value: min_value_Arg, max_value: max_value_Arg) -> Self {
        Self {
            phantom_T: PhantomData,
            images,
            contrast_factor,
            min_value,
            max_value,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(images: images_Arg, contrast_factor: contrast_factor_Arg, min_value: min_value_Arg, max_value: max_value_Arg) -> Edge<f32> {
        Self {
            phantom_T: PhantomData,
            images,
            contrast_factor,
            min_value,
            max_value,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<address_Arg, method_Arg, request_Arg> GraphOperation for TryRpc<address_Arg, method_Arg, request_Arg>
where address_Arg: Clone,
      address_Arg: GraphEdge<String>,
      address_Arg: 'static,
      method_Arg: Clone,
      method_Arg: GraphEdge<String>,
      method_Arg: 'static,
      request_Arg: Clone,
      request_Arg: GraphEdge<String>,
      request_Arg: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("TryRpc_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("TryRpc", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.address)?
        }
        {
            new_op.add_edge(&self.method)?
        }
        {
            new_op.add_edge(&self.request)?
        }
        {
            match self.protocol {
                None => new_op.set_attr_value_proto("protocol", &vec![18_u8, 0_u8,])?,
                Some(ref value) => (|attr| {new_op.set_attr_string("protocol", attr)})(&value)?,
            };
        }
        {
            match self.fail_fast {
                None => new_op.set_attr_value_proto("fail_fast", &vec![40_u8, 1_u8,])?,
                Some(ref value) => (|attr: &bool| {new_op.set_attr_bool("fail_fast", *attr)})(&value)?,
            };
        }
        {
            match self.timeout_in_ms {
                None => new_op.set_attr_value_proto("timeout_in_ms", &vec![24_u8, 0_u8,])?,
                Some(ref value) => (|attr: &i64| {new_op.set_attr_int("timeout_in_ms", *attr)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct TryRpc<address_Arg, method_Arg, request_Arg>
where address_Arg: Clone,
      address_Arg: GraphEdge<String>,
      address_Arg: 'static,
      method_Arg: Clone,
      method_Arg: GraphEdge<String>,
      method_Arg: 'static,
      request_Arg: Clone,
      request_Arg: GraphEdge<String>,
      request_Arg: 'static,
{
    address: address_Arg,
    method: method_Arg,
    request: request_Arg,
    protocol: Option<String>,
    fail_fast: Option<bool>,
    timeout_in_ms: Option<i64>,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<address_Arg, method_Arg, request_Arg> TryRpc<address_Arg, method_Arg, request_Arg>
where address_Arg: Clone,
      address_Arg: GraphEdge<String>,
      address_Arg: 'static,
      method_Arg: Clone,
      method_Arg: GraphEdge<String>,
      method_Arg: 'static,
      request_Arg: Clone,
      request_Arg: GraphEdge<String>,
      request_Arg: 'static,
{
    pub fn response(self) -> Edge<String> {
        let rc = Rc::new(self);
        {
            Edge::<String>::new(rc.clone(), 0)
        }
    }

    pub fn status_code(self) -> Edge<i32> {
        let rc = Rc::new(self);
        {
            Edge::<i32>::new(rc.clone(), 1)
        }
    }

    pub fn status_message(self) -> Edge<String> {
        let rc = Rc::new(self);
        {
            Edge::<String>::new(rc.clone(), 2)
        }
    }

    pub fn protocol(&mut self, protocol: &str) -> Self {
        self.protocol = Some(protocol.to_string());
        self.clone()
    }

    pub fn fail_fast(&mut self, fail_fast: bool) -> Self {
        self.fail_fast = Some(fail_fast);
        self.clone()
    }

    pub fn timeout_in_ms(&mut self, timeout_in_ms: i64) -> Self {
        self.timeout_in_ms = Some(timeout_in_ms);
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> (Edge<String>, Edge<i32>, Edge<String>) {
        let rc = Rc::new(self);
        (
        {
            Edge::<String>::new(rc.clone(), 0)
        },
        {
            Edge::<i32>::new(rc.clone(), 1)
        },
        {
            Edge::<String>::new(rc.clone(), 2)
        },
        )
    }

    pub fn build(address: address_Arg, method: method_Arg, request: request_Arg) -> Self {
        Self {
            address,
            method,
            request,
            protocol: None,
            fail_fast: None,
            timeout_in_ms: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(address: address_Arg, method: method_Arg, request: request_Arg) -> (Edge<String>, Edge<i32>, Edge<String>) {
        Self {
            address,
            method,
            request,
            protocol: None,
            fail_fast: None,
            timeout_in_ms: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<T, data_Arg> GraphOperation for Enter<T, data_Arg>
where T: TensorType,
      T: Clone,
      data_Arg: Clone,
      data_Arg: GraphEdge<T>,
      data_Arg: 'static,
      T: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("Enter_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("Enter", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.data)?
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        {
            (|attr| {new_op.set_attr_string("frame_name", attr)})(&self.frame_name)?
        }
        {
            match self.is_constant {
                None => new_op.set_attr_value_proto("is_constant", &vec![40_u8, 0_u8,])?,
                Some(ref value) => (|attr: &bool| {new_op.set_attr_bool("is_constant", *attr)})(&value)?,
            };
        }
        {
            match self.parallel_iterations {
                None => new_op.set_attr_value_proto("parallel_iterations", &vec![24_u8, 10_u8,])?,
                Some(ref value) => (|attr: &i64| {new_op.set_attr_int("parallel_iterations", *attr)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct Enter<T, data_Arg>
where T: TensorType,
      T: Clone,
      data_Arg: Clone,
      data_Arg: GraphEdge<T>,
      data_Arg: 'static,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    data: data_Arg,
    frame_name: String,
    is_constant: Option<bool>,
    parallel_iterations: Option<i64>,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<T, data_Arg> Enter<T, data_Arg>
where T: TensorType,
      T: Clone,
      data_Arg: Clone,
      data_Arg: GraphEdge<T>,
      data_Arg: 'static,
      T: 'static,
{
    pub fn output(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn is_constant(&mut self, is_constant: bool) -> Self {
        self.is_constant = Some(is_constant);
        self.clone()
    }

    pub fn parallel_iterations(&mut self, parallel_iterations: i64) -> Self {
        self.parallel_iterations = Some(parallel_iterations);
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(data: data_Arg, frame_name: &str) -> Self {
        Self {
            phantom_T: PhantomData,
            data,
            frame_name: frame_name.to_string(),
            is_constant: None,
            parallel_iterations: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(data: data_Arg, frame_name: &str) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            data,
            frame_name: frame_name.to_string(),
            is_constant: None,
            parallel_iterations: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<T, input_Arg> GraphOperation for BatchMatrixDeterminant<T, input_Arg>
where T: TensorType,
      T: Clone,
      input_Arg: Clone,
      input_Arg: GraphEdge<T>,
      input_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_COMPLEX64_or_DT_COMPLEX128,
      T: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("BatchMatrixDeterminant_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("BatchMatrixDeterminant", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.input)?
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct BatchMatrixDeterminant<T, input_Arg>
where T: TensorType,
      T: Clone,
      input_Arg: Clone,
      input_Arg: GraphEdge<T>,
      input_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_COMPLEX64_or_DT_COMPLEX128,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    input: input_Arg,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<T, input_Arg> BatchMatrixDeterminant<T, input_Arg>
where T: TensorType,
      T: Clone,
      input_Arg: Clone,
      input_Arg: GraphEdge<T>,
      input_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_COMPLEX64_or_DT_COMPLEX128,
      T: 'static,
{
    pub fn output(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(input: input_Arg) -> Self {
        Self {
            phantom_T: PhantomData,
            input,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(input: input_Arg) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            input,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

pub trait con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_VARIANT_or_DT_UINT32_or_DT_UINT64 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_VARIANT_or_DT_UINT32_or_DT_UINT64 for BFloat16 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_VARIANT_or_DT_UINT32_or_DT_UINT64 for OtherComplex<f32> {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_VARIANT_or_DT_UINT32_or_DT_UINT64 for OtherComplex<f64> {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_VARIANT_or_DT_UINT32_or_DT_UINT64 for f32 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_VARIANT_or_DT_UINT32_or_DT_UINT64 for f64 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_VARIANT_or_DT_UINT32_or_DT_UINT64 for i16 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_VARIANT_or_DT_UINT32_or_DT_UINT64 for i32 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_VARIANT_or_DT_UINT32_or_DT_UINT64 for i64 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_VARIANT_or_DT_UINT32_or_DT_UINT64 for i8 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_VARIANT_or_DT_UINT32_or_DT_UINT64 for u16 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_VARIANT_or_DT_UINT32_or_DT_UINT64 for u32 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_VARIANT_or_DT_UINT32_or_DT_UINT64 for u64 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_VARIANT_or_DT_UINT32_or_DT_UINT64 for u8 {
}

impl<T, inputs_Arg> GraphOperation for AddN<T, inputs_Arg>
where T: TensorType,
      T: Clone,
      inputs_Arg: Clone,
      inputs_Arg: GraphEdge<T>,
      inputs_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_VARIANT_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("AddN_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("AddN", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.inputs)?
        }
        {
            (|attr: &i64| {new_op.set_attr_int("N", *attr)})(&self.N)?
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct AddN<T, inputs_Arg>
where T: TensorType,
      T: Clone,
      inputs_Arg: Clone,
      inputs_Arg: GraphEdge<T>,
      inputs_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_VARIANT_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    inputs: inputs_Arg,
    N: i64,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<T, inputs_Arg> AddN<T, inputs_Arg>
where T: TensorType,
      T: Clone,
      inputs_Arg: Clone,
      inputs_Arg: GraphEdge<T>,
      inputs_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_VARIANT_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
{
    pub fn sum(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(inputs: inputs_Arg, N: i64) -> Self {
        Self {
            phantom_T: PhantomData,
            inputs,
            N: N,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(inputs: inputs_Arg, N: i64) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            inputs,
            N: N,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<T, x_Arg, y_Arg> GraphOperation for BatchMatMul<T, x_Arg, y_Arg>
where T: TensorType,
      T: Clone,
      x_Arg: Clone,
      x_Arg: GraphEdge<T>,
      x_Arg: 'static,
      y_Arg: Clone,
      y_Arg: GraphEdge<T>,
      y_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_COMPLEX64_or_DT_INT64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF,
      T: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("BatchMatMul_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("BatchMatMul", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.x)?
        }
        {
            new_op.add_edge(&self.y)?
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        {
            match self.adj_x {
                None => new_op.set_attr_value_proto("adj_x", &vec![40_u8, 0_u8,])?,
                Some(ref value) => (|attr: &bool| {new_op.set_attr_bool("adj_x", *attr)})(&value)?,
            };
        }
        {
            match self.adj_y {
                None => new_op.set_attr_value_proto("adj_y", &vec![40_u8, 0_u8,])?,
                Some(ref value) => (|attr: &bool| {new_op.set_attr_bool("adj_y", *attr)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct BatchMatMul<T, x_Arg, y_Arg>
where T: TensorType,
      T: Clone,
      x_Arg: Clone,
      x_Arg: GraphEdge<T>,
      x_Arg: 'static,
      y_Arg: Clone,
      y_Arg: GraphEdge<T>,
      y_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_COMPLEX64_or_DT_INT64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    x: x_Arg,
    y: y_Arg,
    adj_x: Option<bool>,
    adj_y: Option<bool>,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<T, x_Arg, y_Arg> BatchMatMul<T, x_Arg, y_Arg>
where T: TensorType,
      T: Clone,
      x_Arg: Clone,
      x_Arg: GraphEdge<T>,
      x_Arg: 'static,
      y_Arg: Clone,
      y_Arg: GraphEdge<T>,
      y_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_COMPLEX64_or_DT_INT64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF,
      T: 'static,
{
    pub fn output(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn adj_x(&mut self, adj_x: bool) -> Self {
        self.adj_x = Some(adj_x);
        self.clone()
    }

    pub fn adj_y(&mut self, adj_y: bool) -> Self {
        self.adj_y = Some(adj_y);
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(x: x_Arg, y: y_Arg) -> Self {
        Self {
            phantom_T: PhantomData,
            x,
            y,
            adj_x: None,
            adj_y: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(x: x_Arg, y: y_Arg) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            x,
            y,
            adj_x: None,
            adj_y: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<T, x_Arg> GraphOperation for Square<T, x_Arg>
where T: TensorType,
      T: Clone,
      x_Arg: Clone,
      x_Arg: GraphEdge<T>,
      x_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_COMPLEX64_or_DT_INT64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF,
      T: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("Square_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("Square", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.x)?
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct Square<T, x_Arg>
where T: TensorType,
      T: Clone,
      x_Arg: Clone,
      x_Arg: GraphEdge<T>,
      x_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_COMPLEX64_or_DT_INT64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    x: x_Arg,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<T, x_Arg> Square<T, x_Arg>
where T: TensorType,
      T: Clone,
      x_Arg: Clone,
      x_Arg: GraphEdge<T>,
      x_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_COMPLEX64_or_DT_INT64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF,
      T: 'static,
{
    pub fn y(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(x: x_Arg) -> Self {
        Self {
            phantom_T: PhantomData,
            x,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(x: x_Arg) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            x,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<T, input_Arg, filter_Arg, out_backprop_Arg> GraphOperation for Conv3DBackpropFilter<T, input_Arg, filter_Arg, out_backprop_Arg>
where T: TensorType,
      T: Clone,
      input_Arg: Clone,
      input_Arg: GraphEdge<T>,
      input_Arg: 'static,
      filter_Arg: Clone,
      filter_Arg: GraphEdge<T>,
      filter_Arg: 'static,
      out_backprop_Arg: Clone,
      out_backprop_Arg: GraphEdge<T>,
      out_backprop_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_HALF,
      T: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("Conv3DBackpropFilter_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("Conv3DBackpropFilter", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.input)?
        }
        {
            new_op.add_edge(&self.filter)?
        }
        {
            new_op.add_edge(&self.out_backprop)?
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        {
            (|attrs| {new_op.set_attr_int_list("strides", attrs)})(&self.strides)?
        }
        {
            (|attr| {new_op.set_attr_string("padding", attr)})(&self.padding)?
        }
        {
            match self.dilations {
                None => new_op.set_attr_value_proto("dilations", &vec![10_u8, 0_u8, 26_u8, 5_u8, 1_u8, 1_u8, 1_u8, 1_u8,])?,
                Some(ref value) => (|attrs| {new_op.set_attr_int_list("dilations", attrs)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct Conv3DBackpropFilter<T, input_Arg, filter_Arg, out_backprop_Arg>
where T: TensorType,
      T: Clone,
      input_Arg: Clone,
      input_Arg: GraphEdge<T>,
      input_Arg: 'static,
      filter_Arg: Clone,
      filter_Arg: GraphEdge<T>,
      filter_Arg: 'static,
      out_backprop_Arg: Clone,
      out_backprop_Arg: GraphEdge<T>,
      out_backprop_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_HALF,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    input: input_Arg,
    filter: filter_Arg,
    out_backprop: out_backprop_Arg,
    strides: Vec<i64>,
    padding: String,
    dilations: Option<Vec<i64>>,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<T, input_Arg, filter_Arg, out_backprop_Arg> Conv3DBackpropFilter<T, input_Arg, filter_Arg, out_backprop_Arg>
where T: TensorType,
      T: Clone,
      input_Arg: Clone,
      input_Arg: GraphEdge<T>,
      input_Arg: 'static,
      filter_Arg: Clone,
      filter_Arg: GraphEdge<T>,
      filter_Arg: 'static,
      out_backprop_Arg: Clone,
      out_backprop_Arg: GraphEdge<T>,
      out_backprop_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_HALF,
      T: 'static,
{
    pub fn output(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn dilations(&mut self, dilations: &[i64]) -> Self {
        self.dilations = Some(dilations.to_vec());
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(input: input_Arg, filter: filter_Arg, out_backprop: out_backprop_Arg, strides: &[i64], padding: &str) -> Self {
        Self {
            phantom_T: PhantomData,
            input,
            filter,
            out_backprop,
            strides: strides.to_vec(),
            padding: padding.to_string(),
            dilations: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(input: input_Arg, filter: filter_Arg, out_backprop: out_backprop_Arg, strides: &[i64], padding: &str) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            input,
            filter,
            out_backprop,
            strides: strides.to_vec(),
            padding: padding.to_string(),
            dilations: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<T, x_Arg> GraphOperation for Sqrt<T, x_Arg>
where T: TensorType,
      T: Clone,
      x_Arg: Clone,
      x_Arg: GraphEdge<T>,
      x_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_COMPLEX64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF,
      T: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("Sqrt_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("Sqrt", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.x)?
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct Sqrt<T, x_Arg>
where T: TensorType,
      T: Clone,
      x_Arg: Clone,
      x_Arg: GraphEdge<T>,
      x_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_COMPLEX64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    x: x_Arg,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<T, x_Arg> Sqrt<T, x_Arg>
where T: TensorType,
      T: Clone,
      x_Arg: Clone,
      x_Arg: GraphEdge<T>,
      x_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_COMPLEX64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF,
      T: 'static,
{
    pub fn y(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(x: x_Arg) -> Self {
        Self {
            phantom_T: PhantomData,
            x,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(x: x_Arg) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            x,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<T, x_Arg> GraphOperation for Exp<T, x_Arg>
where T: TensorType,
      T: Clone,
      x_Arg: Clone,
      x_Arg: GraphEdge<T>,
      x_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_COMPLEX64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF,
      T: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("Exp_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("Exp", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.x)?
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct Exp<T, x_Arg>
where T: TensorType,
      T: Clone,
      x_Arg: Clone,
      x_Arg: GraphEdge<T>,
      x_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_COMPLEX64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    x: x_Arg,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<T, x_Arg> Exp<T, x_Arg>
where T: TensorType,
      T: Clone,
      x_Arg: Clone,
      x_Arg: GraphEdge<T>,
      x_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_COMPLEX64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF,
      T: 'static,
{
    pub fn y(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(x: x_Arg) -> Self {
        Self {
            phantom_T: PhantomData,
            x,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(x: x_Arg) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            x,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<T, input_Arg, n_Arg> GraphOperation for NthElement<T, input_Arg, n_Arg>
where T: TensorType,
      T: Clone,
      input_Arg: Clone,
      input_Arg: GraphEdge<T>,
      input_Arg: 'static,
      n_Arg: Clone,
      n_Arg: GraphEdge<i32>,
      n_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("NthElement_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("NthElement", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.input)?
        }
        {
            new_op.add_edge(&self.n)?
        }
        {
            match self.reverse {
                None => new_op.set_attr_value_proto("reverse", &vec![40_u8, 0_u8,])?,
                Some(ref value) => (|attr: &bool| {new_op.set_attr_bool("reverse", *attr)})(&value)?,
            };
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct NthElement<T, input_Arg, n_Arg>
where T: TensorType,
      T: Clone,
      input_Arg: Clone,
      input_Arg: GraphEdge<T>,
      input_Arg: 'static,
      n_Arg: Clone,
      n_Arg: GraphEdge<i32>,
      n_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    input: input_Arg,
    n: n_Arg,
    reverse: Option<bool>,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<T, input_Arg, n_Arg> NthElement<T, input_Arg, n_Arg>
where T: TensorType,
      T: Clone,
      input_Arg: Clone,
      input_Arg: GraphEdge<T>,
      input_Arg: 'static,
      n_Arg: Clone,
      n_Arg: GraphEdge<i32>,
      n_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
{
    pub fn values(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn reverse(&mut self, reverse: bool) -> Self {
        self.reverse = Some(reverse);
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(input: input_Arg, n: n_Arg) -> Self {
        Self {
            phantom_T: PhantomData,
            input,
            n,
            reverse: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(input: input_Arg, n: n_Arg) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            input,
            n,
            reverse: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<T, data_Arg, Tindices, segment_ids_Arg, Tnumsegments, num_segments_Arg> GraphOperation for UnsortedSegmentMax<T, data_Arg, Tindices, segment_ids_Arg, Tnumsegments, num_segments_Arg>
where T: TensorType,
      T: Clone,
      data_Arg: Clone,
      data_Arg: GraphEdge<T>,
      data_Arg: 'static,
      Tindices: TensorType,
      Tindices: Clone,
      segment_ids_Arg: Clone,
      segment_ids_Arg: GraphEdge<Tindices>,
      segment_ids_Arg: 'static,
      Tnumsegments: TensorType,
      Tnumsegments: Clone,
      num_segments_Arg: Clone,
      num_segments_Arg: GraphEdge<Tnumsegments>,
      num_segments_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
      Tindices: con_or_DT_INT32_or_DT_INT64,
      Tindices: 'static,
      Tnumsegments: con_or_DT_INT32_or_DT_INT64,
      Tnumsegments: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("UnsortedSegmentMax_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("UnsortedSegmentMax", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.data)?
        }
        {
            new_op.add_edge(&self.segment_ids)?
        }
        {
            new_op.add_edge(&self.num_segments)?
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        {
            new_op.set_attr_type("Tindices", Tindices::data_type())?;
        }
        {
            new_op.set_attr_type("Tnumsegments", Tnumsegments::data_type())?;
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct UnsortedSegmentMax<T, data_Arg, Tindices, segment_ids_Arg, Tnumsegments, num_segments_Arg>
where T: TensorType,
      T: Clone,
      data_Arg: Clone,
      data_Arg: GraphEdge<T>,
      data_Arg: 'static,
      Tindices: TensorType,
      Tindices: Clone,
      segment_ids_Arg: Clone,
      segment_ids_Arg: GraphEdge<Tindices>,
      segment_ids_Arg: 'static,
      Tnumsegments: TensorType,
      Tnumsegments: Clone,
      num_segments_Arg: Clone,
      num_segments_Arg: GraphEdge<Tnumsegments>,
      num_segments_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
      Tindices: con_or_DT_INT32_or_DT_INT64,
      Tindices: 'static,
      Tnumsegments: con_or_DT_INT32_or_DT_INT64,
      Tnumsegments: 'static,
{
    phantom_T: PhantomData<T>,
    data: data_Arg,
    phantom_Tindices: PhantomData<Tindices>,
    segment_ids: segment_ids_Arg,
    phantom_Tnumsegments: PhantomData<Tnumsegments>,
    num_segments: num_segments_Arg,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<T, data_Arg, Tindices, segment_ids_Arg, Tnumsegments, num_segments_Arg> UnsortedSegmentMax<T, data_Arg, Tindices, segment_ids_Arg, Tnumsegments, num_segments_Arg>
where T: TensorType,
      T: Clone,
      data_Arg: Clone,
      data_Arg: GraphEdge<T>,
      data_Arg: 'static,
      Tindices: TensorType,
      Tindices: Clone,
      segment_ids_Arg: Clone,
      segment_ids_Arg: GraphEdge<Tindices>,
      segment_ids_Arg: 'static,
      Tnumsegments: TensorType,
      Tnumsegments: Clone,
      num_segments_Arg: Clone,
      num_segments_Arg: GraphEdge<Tnumsegments>,
      num_segments_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
      Tindices: con_or_DT_INT32_or_DT_INT64,
      Tindices: 'static,
      Tnumsegments: con_or_DT_INT32_or_DT_INT64,
      Tnumsegments: 'static,
{
    pub fn output(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(data: data_Arg, segment_ids: segment_ids_Arg, num_segments: num_segments_Arg) -> Self {
        Self {
            phantom_T: PhantomData,
            data,
            phantom_Tindices: PhantomData,
            segment_ids,
            phantom_Tnumsegments: PhantomData,
            num_segments,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(data: data_Arg, segment_ids: segment_ids_Arg, num_segments: num_segments_Arg) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            data,
            phantom_Tindices: PhantomData,
            segment_ids,
            phantom_Tnumsegments: PhantomData,
            num_segments,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<T, features_Arg> GraphOperation for Softplus<T, features_Arg>
where T: TensorType,
      T: Clone,
      features_Arg: Clone,
      features_Arg: GraphEdge<T>,
      features_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
      T: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("Softplus_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("Softplus", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.features)?
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct Softplus<T, features_Arg>
where T: TensorType,
      T: Clone,
      features_Arg: Clone,
      features_Arg: GraphEdge<T>,
      features_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    features: features_Arg,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<T, features_Arg> Softplus<T, features_Arg>
where T: TensorType,
      T: Clone,
      features_Arg: Clone,
      features_Arg: GraphEdge<T>,
      features_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
      T: 'static,
{
    pub fn activations(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(features: features_Arg) -> Self {
        Self {
            phantom_T: PhantomData,
            features,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(features: features_Arg) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            features,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<T, x_Arg> GraphOperation for Expm1<T, x_Arg>
where T: TensorType,
      T: Clone,
      x_Arg: Clone,
      x_Arg: GraphEdge<T>,
      x_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_COMPLEX64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF,
      T: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("Expm1_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("Expm1", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.x)?
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct Expm1<T, x_Arg>
where T: TensorType,
      T: Clone,
      x_Arg: Clone,
      x_Arg: GraphEdge<T>,
      x_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_COMPLEX64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    x: x_Arg,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<T, x_Arg> Expm1<T, x_Arg>
where T: TensorType,
      T: Clone,
      x_Arg: Clone,
      x_Arg: GraphEdge<T>,
      x_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_COMPLEX64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF,
      T: 'static,
{
    pub fn y(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(x: x_Arg) -> Self {
        Self {
            phantom_T: PhantomData,
            x,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(x: x_Arg) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            x,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<T, x_Arg> GraphOperation for Log<T, x_Arg>
where T: TensorType,
      T: Clone,
      x_Arg: Clone,
      x_Arg: GraphEdge<T>,
      x_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_COMPLEX64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF,
      T: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("Log_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("Log", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.x)?
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct Log<T, x_Arg>
where T: TensorType,
      T: Clone,
      x_Arg: Clone,
      x_Arg: GraphEdge<T>,
      x_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_COMPLEX64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    x: x_Arg,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<T, x_Arg> Log<T, x_Arg>
where T: TensorType,
      T: Clone,
      x_Arg: Clone,
      x_Arg: GraphEdge<T>,
      x_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_COMPLEX64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF,
      T: 'static,
{
    pub fn y(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(x: x_Arg) -> Self {
        Self {
            phantom_T: PhantomData,
            x,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(x: x_Arg) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            x,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<T, data_Arg, Tidx, indices_Arg, segment_ids_Arg, Tnumsegments, num_segments_Arg> GraphOperation for SparseSegmentMeanWithNumSegments<T, data_Arg, Tidx, indices_Arg, segment_ids_Arg, Tnumsegments, num_segments_Arg>
where T: TensorType,
      T: Clone,
      data_Arg: Clone,
      data_Arg: GraphEdge<T>,
      data_Arg: 'static,
      Tidx: TensorType,
      Tidx: Clone,
      indices_Arg: Clone,
      indices_Arg: GraphEdge<Tidx>,
      indices_Arg: 'static,
      segment_ids_Arg: Clone,
      segment_ids_Arg: GraphEdge<i32>,
      segment_ids_Arg: 'static,
      Tnumsegments: TensorType,
      Tnumsegments: Clone,
      num_segments_Arg: Clone,
      num_segments_Arg: GraphEdge<Tnumsegments>,
      num_segments_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE,
      T: 'static,
      Tidx: con_or_DT_INT32_or_DT_INT64,
      Tidx: 'static,
      Tnumsegments: con_or_DT_INT32_or_DT_INT64,
      Tnumsegments: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("SparseSegmentMeanWithNumSegments_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("SparseSegmentMeanWithNumSegments", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.data)?
        }
        {
            new_op.add_edge(&self.indices)?
        }
        {
            new_op.add_edge(&self.segment_ids)?
        }
        {
            new_op.add_edge(&self.num_segments)?
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        {
            new_op.set_attr_type("Tidx", Tidx::data_type())?;
        }
        {
            new_op.set_attr_type("Tnumsegments", Tnumsegments::data_type())?;
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct SparseSegmentMeanWithNumSegments<T, data_Arg, Tidx, indices_Arg, segment_ids_Arg, Tnumsegments, num_segments_Arg>
where T: TensorType,
      T: Clone,
      data_Arg: Clone,
      data_Arg: GraphEdge<T>,
      data_Arg: 'static,
      Tidx: TensorType,
      Tidx: Clone,
      indices_Arg: Clone,
      indices_Arg: GraphEdge<Tidx>,
      indices_Arg: 'static,
      segment_ids_Arg: Clone,
      segment_ids_Arg: GraphEdge<i32>,
      segment_ids_Arg: 'static,
      Tnumsegments: TensorType,
      Tnumsegments: Clone,
      num_segments_Arg: Clone,
      num_segments_Arg: GraphEdge<Tnumsegments>,
      num_segments_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE,
      T: 'static,
      Tidx: con_or_DT_INT32_or_DT_INT64,
      Tidx: 'static,
      Tnumsegments: con_or_DT_INT32_or_DT_INT64,
      Tnumsegments: 'static,
{
    phantom_T: PhantomData<T>,
    data: data_Arg,
    phantom_Tidx: PhantomData<Tidx>,
    indices: indices_Arg,
    segment_ids: segment_ids_Arg,
    phantom_Tnumsegments: PhantomData<Tnumsegments>,
    num_segments: num_segments_Arg,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<T, data_Arg, Tidx, indices_Arg, segment_ids_Arg, Tnumsegments, num_segments_Arg> SparseSegmentMeanWithNumSegments<T, data_Arg, Tidx, indices_Arg, segment_ids_Arg, Tnumsegments, num_segments_Arg>
where T: TensorType,
      T: Clone,
      data_Arg: Clone,
      data_Arg: GraphEdge<T>,
      data_Arg: 'static,
      Tidx: TensorType,
      Tidx: Clone,
      indices_Arg: Clone,
      indices_Arg: GraphEdge<Tidx>,
      indices_Arg: 'static,
      segment_ids_Arg: Clone,
      segment_ids_Arg: GraphEdge<i32>,
      segment_ids_Arg: 'static,
      Tnumsegments: TensorType,
      Tnumsegments: Clone,
      num_segments_Arg: Clone,
      num_segments_Arg: GraphEdge<Tnumsegments>,
      num_segments_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE,
      T: 'static,
      Tidx: con_or_DT_INT32_or_DT_INT64,
      Tidx: 'static,
      Tnumsegments: con_or_DT_INT32_or_DT_INT64,
      Tnumsegments: 'static,
{
    pub fn output(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(data: data_Arg, indices: indices_Arg, segment_ids: segment_ids_Arg, num_segments: num_segments_Arg) -> Self {
        Self {
            phantom_T: PhantomData,
            data,
            phantom_Tidx: PhantomData,
            indices,
            segment_ids,
            phantom_Tnumsegments: PhantomData,
            num_segments,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(data: data_Arg, indices: indices_Arg, segment_ids: segment_ids_Arg, num_segments: num_segments_Arg) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            data,
            phantom_Tidx: PhantomData,
            indices,
            segment_ids,
            phantom_Tnumsegments: PhantomData,
            num_segments,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<T, x_Arg> GraphOperation for Cosh<T, x_Arg>
where T: TensorType,
      T: Clone,
      x_Arg: Clone,
      x_Arg: GraphEdge<T>,
      x_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_COMPLEX64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF,
      T: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("Cosh_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("Cosh", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.x)?
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct Cosh<T, x_Arg>
where T: TensorType,
      T: Clone,
      x_Arg: Clone,
      x_Arg: GraphEdge<T>,
      x_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_COMPLEX64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    x: x_Arg,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<T, x_Arg> Cosh<T, x_Arg>
where T: TensorType,
      T: Clone,
      x_Arg: Clone,
      x_Arg: GraphEdge<T>,
      x_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_COMPLEX64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF,
      T: 'static,
{
    pub fn y(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(x: x_Arg) -> Self {
        Self {
            phantom_T: PhantomData,
            x,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(x: x_Arg) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            x,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<T, data_Arg, Tindices, segment_ids_Arg> GraphOperation for SegmentMax<T, data_Arg, Tindices, segment_ids_Arg>
where T: TensorType,
      T: Clone,
      data_Arg: Clone,
      data_Arg: GraphEdge<T>,
      data_Arg: 'static,
      Tindices: TensorType,
      Tindices: Clone,
      segment_ids_Arg: Clone,
      segment_ids_Arg: GraphEdge<Tindices>,
      segment_ids_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
      Tindices: con_or_DT_INT32_or_DT_INT64,
      Tindices: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("SegmentMax_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("SegmentMax", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.data)?
        }
        {
            new_op.add_edge(&self.segment_ids)?
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        {
            new_op.set_attr_type("Tindices", Tindices::data_type())?;
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct SegmentMax<T, data_Arg, Tindices, segment_ids_Arg>
where T: TensorType,
      T: Clone,
      data_Arg: Clone,
      data_Arg: GraphEdge<T>,
      data_Arg: 'static,
      Tindices: TensorType,
      Tindices: Clone,
      segment_ids_Arg: Clone,
      segment_ids_Arg: GraphEdge<Tindices>,
      segment_ids_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
      Tindices: con_or_DT_INT32_or_DT_INT64,
      Tindices: 'static,
{
    phantom_T: PhantomData<T>,
    data: data_Arg,
    phantom_Tindices: PhantomData<Tindices>,
    segment_ids: segment_ids_Arg,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<T, data_Arg, Tindices, segment_ids_Arg> SegmentMax<T, data_Arg, Tindices, segment_ids_Arg>
where T: TensorType,
      T: Clone,
      data_Arg: Clone,
      data_Arg: GraphEdge<T>,
      data_Arg: 'static,
      Tindices: TensorType,
      Tindices: Clone,
      segment_ids_Arg: Clone,
      segment_ids_Arg: GraphEdge<Tindices>,
      segment_ids_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
      Tindices: con_or_DT_INT32_or_DT_INT64,
      Tindices: 'static,
{
    pub fn output(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(data: data_Arg, segment_ids: segment_ids_Arg) -> Self {
        Self {
            phantom_T: PhantomData,
            data,
            phantom_Tindices: PhantomData,
            segment_ids,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(data: data_Arg, segment_ids: segment_ids_Arg) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            data,
            phantom_Tindices: PhantomData,
            segment_ids,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<T, x_Arg> GraphOperation for Tanh<T, x_Arg>
where T: TensorType,
      T: Clone,
      x_Arg: Clone,
      x_Arg: GraphEdge<T>,
      x_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_COMPLEX64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF,
      T: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("Tanh_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("Tanh", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.x)?
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct Tanh<T, x_Arg>
where T: TensorType,
      T: Clone,
      x_Arg: Clone,
      x_Arg: GraphEdge<T>,
      x_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_COMPLEX64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    x: x_Arg,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<T, x_Arg> Tanh<T, x_Arg>
where T: TensorType,
      T: Clone,
      x_Arg: Clone,
      x_Arg: GraphEdge<T>,
      x_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_COMPLEX64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF,
      T: 'static,
{
    pub fn y(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(x: x_Arg) -> Self {
        Self {
            phantom_T: PhantomData,
            x,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(x: x_Arg) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            x,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<input_Arg> GraphOperation for UnicodeTranscode<input_Arg>
where input_Arg: Clone,
      input_Arg: GraphEdge<String>,
      input_Arg: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("UnicodeTranscode_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("UnicodeTranscode", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.input)?
        }
        {
            (|attr| {new_op.set_attr_string("input_encoding", attr)})(&self.input_encoding)?
        }
        {
            (|attr| {new_op.set_attr_string("output_encoding", attr)})(&self.output_encoding)?
        }
        {
            match self.errors {
                None => new_op.set_attr_value_proto("errors", &vec![18_u8, 7_u8, 114_u8, 101_u8, 112_u8, 108_u8, 97_u8, 99_u8, 101_u8,])?,
                Some(ref value) => (|attr| {new_op.set_attr_string("errors", attr)})(&value)?,
            };
        }
        {
            match self.replacement_char {
                None => new_op.set_attr_value_proto("replacement_char", &vec![24_u8, 253_u8, 255_u8, 3_u8,])?,
                Some(ref value) => (|attr: &i64| {new_op.set_attr_int("replacement_char", *attr)})(&value)?,
            };
        }
        {
            match self.replace_control_characters {
                None => new_op.set_attr_value_proto("replace_control_characters", &vec![40_u8, 0_u8,])?,
                Some(ref value) => (|attr: &bool| {new_op.set_attr_bool("replace_control_characters", *attr)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct UnicodeTranscode<input_Arg>
where input_Arg: Clone,
      input_Arg: GraphEdge<String>,
      input_Arg: 'static,
{
    input: input_Arg,
    input_encoding: String,
    output_encoding: String,
    errors: Option<String>,
    replacement_char: Option<i64>,
    replace_control_characters: Option<bool>,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<input_Arg> UnicodeTranscode<input_Arg>
where input_Arg: Clone,
      input_Arg: GraphEdge<String>,
      input_Arg: 'static,
{
    pub fn output(self) -> Edge<String> {
        let rc = Rc::new(self);
        {
            Edge::<String>::new(rc.clone(), 0)
        }
    }

    pub fn errors(&mut self, errors: &str) -> Self {
        self.errors = Some(errors.to_string());
        self.clone()
    }

    pub fn replacement_char(&mut self, replacement_char: i64) -> Self {
        self.replacement_char = Some(replacement_char);
        self.clone()
    }

    pub fn replace_control_characters(&mut self, replace_control_characters: bool) -> Self {
        self.replace_control_characters = Some(replace_control_characters);
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<String> {
        let rc = Rc::new(self);
        {
            Edge::<String>::new(rc.clone(), 0)
        }
    }

    pub fn build(input: input_Arg, input_encoding: &str, output_encoding: &str) -> Self {
        Self {
            input,
            input_encoding: input_encoding.to_string(),
            output_encoding: output_encoding.to_string(),
            errors: None,
            replacement_char: None,
            replace_control_characters: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(input: input_Arg, input_encoding: &str, output_encoding: &str) -> Edge<String> {
        Self {
            input,
            input_encoding: input_encoding.to_string(),
            output_encoding: output_encoding.to_string(),
            errors: None,
            replacement_char: None,
            replace_control_characters: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<T, x_Arg> GraphOperation for Asinh<T, x_Arg>
where T: TensorType,
      T: Clone,
      x_Arg: Clone,
      x_Arg: GraphEdge<T>,
      x_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_COMPLEX64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF,
      T: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("Asinh_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("Asinh", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.x)?
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct Asinh<T, x_Arg>
where T: TensorType,
      T: Clone,
      x_Arg: Clone,
      x_Arg: GraphEdge<T>,
      x_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_COMPLEX64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    x: x_Arg,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<T, x_Arg> Asinh<T, x_Arg>
where T: TensorType,
      T: Clone,
      x_Arg: Clone,
      x_Arg: GraphEdge<T>,
      x_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_COMPLEX64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF,
      T: 'static,
{
    pub fn y(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(x: x_Arg) -> Self {
        Self {
            phantom_T: PhantomData,
            x,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(x: x_Arg) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            x,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<T, images_Arg> GraphOperation for HSVToRGB<T, images_Arg>
where T: TensorType,
      T: Clone,
      images_Arg: Clone,
      images_Arg: GraphEdge<T>,
      images_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
      T: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("HSVToRGB_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("HSVToRGB", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.images)?
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct HSVToRGB<T, images_Arg>
where T: TensorType,
      T: Clone,
      images_Arg: Clone,
      images_Arg: GraphEdge<T>,
      images_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    images: images_Arg,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<T, images_Arg> HSVToRGB<T, images_Arg>
where T: TensorType,
      T: Clone,
      images_Arg: Clone,
      images_Arg: GraphEdge<T>,
      images_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
      T: 'static,
{
    pub fn output(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(images: images_Arg) -> Self {
        Self {
            phantom_T: PhantomData,
            images,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(images: images_Arg) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            images,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<T, y_Arg, dy_Arg> GraphOperation for SigmoidGrad<T, y_Arg, dy_Arg>
where T: TensorType,
      T: Clone,
      y_Arg: Clone,
      y_Arg: GraphEdge<T>,
      y_Arg: 'static,
      dy_Arg: Clone,
      dy_Arg: GraphEdge<T>,
      dy_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_COMPLEX64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF,
      T: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("SigmoidGrad_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("SigmoidGrad", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.y)?
        }
        {
            new_op.add_edge(&self.dy)?
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct SigmoidGrad<T, y_Arg, dy_Arg>
where T: TensorType,
      T: Clone,
      y_Arg: Clone,
      y_Arg: GraphEdge<T>,
      y_Arg: 'static,
      dy_Arg: Clone,
      dy_Arg: GraphEdge<T>,
      dy_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_COMPLEX64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    y: y_Arg,
    dy: dy_Arg,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<T, y_Arg, dy_Arg> SigmoidGrad<T, y_Arg, dy_Arg>
where T: TensorType,
      T: Clone,
      y_Arg: Clone,
      y_Arg: GraphEdge<T>,
      y_Arg: 'static,
      dy_Arg: Clone,
      dy_Arg: GraphEdge<T>,
      dy_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_COMPLEX64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF,
      T: 'static,
{
    pub fn z(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(y: y_Arg, dy: dy_Arg) -> Self {
        Self {
            phantom_T: PhantomData,
            y,
            dy,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(y: y_Arg, dy: dy_Arg) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            y,
            dy,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<T, x_Arg> GraphOperation for Sin<T, x_Arg>
where T: TensorType,
      T: Clone,
      x_Arg: Clone,
      x_Arg: GraphEdge<T>,
      x_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_COMPLEX64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF,
      T: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("Sin_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("Sin", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.x)?
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct Sin<T, x_Arg>
where T: TensorType,
      T: Clone,
      x_Arg: Clone,
      x_Arg: GraphEdge<T>,
      x_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_COMPLEX64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    x: x_Arg,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<T, x_Arg> Sin<T, x_Arg>
where T: TensorType,
      T: Clone,
      x_Arg: Clone,
      x_Arg: GraphEdge<T>,
      x_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_COMPLEX64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF,
      T: 'static,
{
    pub fn y(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(x: x_Arg) -> Self {
        Self {
            phantom_T: PhantomData,
            x,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(x: x_Arg) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            x,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<T, x_Arg> GraphOperation for Acos<T, x_Arg>
where T: TensorType,
      T: Clone,
      x_Arg: Clone,
      x_Arg: GraphEdge<T>,
      x_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_COMPLEX64_or_DT_INT64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF,
      T: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("Acos_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("Acos", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.x)?
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct Acos<T, x_Arg>
where T: TensorType,
      T: Clone,
      x_Arg: Clone,
      x_Arg: GraphEdge<T>,
      x_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_COMPLEX64_or_DT_INT64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    x: x_Arg,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<T, x_Arg> Acos<T, x_Arg>
where T: TensorType,
      T: Clone,
      x_Arg: Clone,
      x_Arg: GraphEdge<T>,
      x_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_COMPLEX64_or_DT_INT64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF,
      T: 'static,
{
    pub fn y(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(x: x_Arg) -> Self {
        Self {
            phantom_T: PhantomData,
            x,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(x: x_Arg) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            x,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<T, x_Arg> GraphOperation for BesselI0e<T, x_Arg>
where T: TensorType,
      T: Clone,
      x_Arg: Clone,
      x_Arg: GraphEdge<T>,
      x_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
      T: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("BesselI0e_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("BesselI0e", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.x)?
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct BesselI0e<T, x_Arg>
where T: TensorType,
      T: Clone,
      x_Arg: Clone,
      x_Arg: GraphEdge<T>,
      x_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    x: x_Arg,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<T, x_Arg> BesselI0e<T, x_Arg>
where T: TensorType,
      T: Clone,
      x_Arg: Clone,
      x_Arg: GraphEdge<T>,
      x_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
      T: 'static,
{
    pub fn y(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(x: x_Arg) -> Self {
        Self {
            phantom_T: PhantomData,
            x,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(x: x_Arg) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            x,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<T, x_Arg, Tperm, perm_Arg> GraphOperation for Transpose<T, x_Arg, Tperm, perm_Arg>
where T: TensorType,
      T: Clone,
      x_Arg: Clone,
      x_Arg: GraphEdge<T>,
      x_Arg: 'static,
      Tperm: TensorType,
      Tperm: Clone,
      perm_Arg: Clone,
      perm_Arg: GraphEdge<Tperm>,
      perm_Arg: 'static,
      T: 'static,
      Tperm: con_or_DT_INT32_or_DT_INT64,
      Tperm: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("Transpose_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("Transpose", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.x)?
        }
        {
            new_op.add_edge(&self.perm)?
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        {
            new_op.set_attr_type("Tperm", Tperm::data_type())?;
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct Transpose<T, x_Arg, Tperm, perm_Arg>
where T: TensorType,
      T: Clone,
      x_Arg: Clone,
      x_Arg: GraphEdge<T>,
      x_Arg: 'static,
      Tperm: TensorType,
      Tperm: Clone,
      perm_Arg: Clone,
      perm_Arg: GraphEdge<Tperm>,
      perm_Arg: 'static,
      T: 'static,
      Tperm: con_or_DT_INT32_or_DT_INT64,
      Tperm: 'static,
{
    phantom_T: PhantomData<T>,
    x: x_Arg,
    phantom_Tperm: PhantomData<Tperm>,
    perm: perm_Arg,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<T, x_Arg, Tperm, perm_Arg> Transpose<T, x_Arg, Tperm, perm_Arg>
where T: TensorType,
      T: Clone,
      x_Arg: Clone,
      x_Arg: GraphEdge<T>,
      x_Arg: 'static,
      Tperm: TensorType,
      Tperm: Clone,
      perm_Arg: Clone,
      perm_Arg: GraphEdge<Tperm>,
      perm_Arg: 'static,
      T: 'static,
      Tperm: con_or_DT_INT32_or_DT_INT64,
      Tperm: 'static,
{
    pub fn y(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(x: x_Arg, perm: perm_Arg) -> Self {
        Self {
            phantom_T: PhantomData,
            x,
            phantom_Tperm: PhantomData,
            perm,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(x: x_Arg, perm: perm_Arg) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            x,
            phantom_Tperm: PhantomData,
            perm,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<T, input_Arg, Tidx, reduction_indices_Arg> GraphOperation for Min<T, input_Arg, Tidx, reduction_indices_Arg>
where T: TensorType,
      T: Clone,
      input_Arg: Clone,
      input_Arg: GraphEdge<T>,
      input_Arg: 'static,
      Tidx: TensorType,
      Tidx: Clone,
      reduction_indices_Arg: Clone,
      reduction_indices_Arg: GraphEdge<Tidx>,
      reduction_indices_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
      Tidx: con_or_DT_INT32_or_DT_INT64,
      Tidx: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("Min_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("Min", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.input)?
        }
        {
            new_op.add_edge(&self.reduction_indices)?
        }
        {
            match self.keep_dims {
                None => new_op.set_attr_value_proto("keep_dims", &vec![40_u8, 0_u8,])?,
                Some(ref value) => (|attr: &bool| {new_op.set_attr_bool("keep_dims", *attr)})(&value)?,
            };
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        {
            new_op.set_attr_type("Tidx", Tidx::data_type())?;
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct Min<T, input_Arg, Tidx, reduction_indices_Arg>
where T: TensorType,
      T: Clone,
      input_Arg: Clone,
      input_Arg: GraphEdge<T>,
      input_Arg: 'static,
      Tidx: TensorType,
      Tidx: Clone,
      reduction_indices_Arg: Clone,
      reduction_indices_Arg: GraphEdge<Tidx>,
      reduction_indices_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
      Tidx: con_or_DT_INT32_or_DT_INT64,
      Tidx: 'static,
{
    phantom_T: PhantomData<T>,
    input: input_Arg,
    phantom_Tidx: PhantomData<Tidx>,
    reduction_indices: reduction_indices_Arg,
    keep_dims: Option<bool>,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<T, input_Arg, Tidx, reduction_indices_Arg> Min<T, input_Arg, Tidx, reduction_indices_Arg>
where T: TensorType,
      T: Clone,
      input_Arg: Clone,
      input_Arg: GraphEdge<T>,
      input_Arg: 'static,
      Tidx: TensorType,
      Tidx: Clone,
      reduction_indices_Arg: Clone,
      reduction_indices_Arg: GraphEdge<Tidx>,
      reduction_indices_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
      Tidx: con_or_DT_INT32_or_DT_INT64,
      Tidx: 'static,
{
    pub fn output(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn keep_dims(&mut self, keep_dims: bool) -> Self {
        self.keep_dims = Some(keep_dims);
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(input: input_Arg, reduction_indices: reduction_indices_Arg) -> Self {
        Self {
            phantom_T: PhantomData,
            input,
            phantom_Tidx: PhantomData,
            reduction_indices,
            keep_dims: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(input: input_Arg, reduction_indices: reduction_indices_Arg) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            input,
            phantom_Tidx: PhantomData,
            reduction_indices,
            keep_dims: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<T, x_Arg> GraphOperation for BesselI1e<T, x_Arg>
where T: TensorType,
      T: Clone,
      x_Arg: Clone,
      x_Arg: GraphEdge<T>,
      x_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
      T: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("BesselI1e_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("BesselI1e", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.x)?
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct BesselI1e<T, x_Arg>
where T: TensorType,
      T: Clone,
      x_Arg: Clone,
      x_Arg: GraphEdge<T>,
      x_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    x: x_Arg,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<T, x_Arg> BesselI1e<T, x_Arg>
where T: TensorType,
      T: Clone,
      x_Arg: Clone,
      x_Arg: GraphEdge<T>,
      x_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
      T: 'static,
{
    pub fn y(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(x: x_Arg) -> Self {
        Self {
            phantom_T: PhantomData,
            x,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(x: x_Arg) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            x,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<T, x_Arg> GraphOperation for _UnaryOpsComposition<T, x_Arg>
where T: TensorType,
      T: Clone,
      x_Arg: Clone,
      x_Arg: GraphEdge<T>,
      x_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_HALF,
      T: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("_UnaryOpsComposition_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("_UnaryOpsComposition", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.x)?
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        {
            (|attrs| {new_op.set_attr_string_list("op_names", attrs)})(&self.op_names)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct _UnaryOpsComposition<T, x_Arg>
where T: TensorType,
      T: Clone,
      x_Arg: Clone,
      x_Arg: GraphEdge<T>,
      x_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_HALF,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    x: x_Arg,
    op_names: Vec<String>,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<T, x_Arg> _UnaryOpsComposition<T, x_Arg>
where T: TensorType,
      T: Clone,
      x_Arg: Clone,
      x_Arg: GraphEdge<T>,
      x_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_HALF,
      T: 'static,
{
    pub fn y(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(x: x_Arg, op_names: &[String]) -> Self {
        Self {
            phantom_T: PhantomData,
            x,
            op_names: op_names.to_vec(),
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(x: x_Arg, op_names: &[String]) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            x,
            op_names: op_names.to_vec(),
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<T, x_Arg> GraphOperation for IsInf<T, x_Arg>
where T: TensorType,
      T: Clone,
      x_Arg: Clone,
      x_Arg: GraphEdge<T>,
      x_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
      T: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("IsInf_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("IsInf", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.x)?
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct IsInf<T, x_Arg>
where T: TensorType,
      T: Clone,
      x_Arg: Clone,
      x_Arg: GraphEdge<T>,
      x_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    x: x_Arg,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<T, x_Arg> IsInf<T, x_Arg>
where T: TensorType,
      T: Clone,
      x_Arg: Clone,
      x_Arg: GraphEdge<T>,
      x_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
      T: 'static,
{
    pub fn y(self) -> Edge<bool> {
        let rc = Rc::new(self);
        {
            Edge::<bool>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<bool> {
        let rc = Rc::new(self);
        {
            Edge::<bool>::new(rc.clone(), 0)
        }
    }

    pub fn build(x: x_Arg) -> Self {
        Self {
            phantom_T: PhantomData,
            x,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(x: x_Arg) -> Edge<bool> {
        Self {
            phantom_T: PhantomData,
            x,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<T, x_Arg> GraphOperation for Rint<T, x_Arg>
where T: TensorType,
      T: Clone,
      x_Arg: Clone,
      x_Arg: GraphEdge<T>,
      x_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
      T: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("Rint_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("Rint", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.x)?
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct Rint<T, x_Arg>
where T: TensorType,
      T: Clone,
      x_Arg: Clone,
      x_Arg: GraphEdge<T>,
      x_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    x: x_Arg,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<T, x_Arg> Rint<T, x_Arg>
where T: TensorType,
      T: Clone,
      x_Arg: Clone,
      x_Arg: GraphEdge<T>,
      x_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
      T: 'static,
{
    pub fn y(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(x: x_Arg) -> Self {
        Self {
            phantom_T: PhantomData,
            x,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(x: x_Arg) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            x,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<T, x_Arg, y_Arg> GraphOperation for Sub<T, x_Arg, y_Arg>
where T: TensorType,
      T: Clone,
      x_Arg: Clone,
      x_Arg: GraphEdge<T>,
      x_Arg: 'static,
      y_Arg: Clone,
      y_Arg: GraphEdge<T>,
      y_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF,
      T: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("Sub_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("Sub", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.x)?
        }
        {
            new_op.add_edge(&self.y)?
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct Sub<T, x_Arg, y_Arg>
where T: TensorType,
      T: Clone,
      x_Arg: Clone,
      x_Arg: GraphEdge<T>,
      x_Arg: 'static,
      y_Arg: Clone,
      y_Arg: GraphEdge<T>,
      y_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    x: x_Arg,
    y: y_Arg,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<T, x_Arg, y_Arg> Sub<T, x_Arg, y_Arg>
where T: TensorType,
      T: Clone,
      x_Arg: Clone,
      x_Arg: GraphEdge<T>,
      x_Arg: 'static,
      y_Arg: Clone,
      y_Arg: GraphEdge<T>,
      y_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF,
      T: 'static,
{
    pub fn z(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(x: x_Arg, y: y_Arg) -> Self {
        Self {
            phantom_T: PhantomData,
            x,
            y,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(x: x_Arg, y: y_Arg) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            x,
            y,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<T, x_Arg, y_Arg, mkl_x_Arg, mkl_y_Arg> GraphOperation for _MklSub<T, x_Arg, y_Arg, mkl_x_Arg, mkl_y_Arg>
where T: TensorType,
      T: Clone,
      x_Arg: Clone,
      x_Arg: GraphEdge<T>,
      x_Arg: 'static,
      y_Arg: Clone,
      y_Arg: GraphEdge<T>,
      y_Arg: 'static,
      mkl_x_Arg: Clone,
      mkl_x_Arg: GraphEdge<u8>,
      mkl_x_Arg: 'static,
      mkl_y_Arg: Clone,
      mkl_y_Arg: GraphEdge<u8>,
      mkl_y_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_COMPLEX64_or_DT_INT64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF,
      T: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("_MklSub_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("_MklSub", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.x)?
        }
        {
            new_op.add_edge(&self.y)?
        }
        {
            new_op.add_edge(&self.mkl_x)?
        }
        {
            new_op.add_edge(&self.mkl_y)?
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct _MklSub<T, x_Arg, y_Arg, mkl_x_Arg, mkl_y_Arg>
where T: TensorType,
      T: Clone,
      x_Arg: Clone,
      x_Arg: GraphEdge<T>,
      x_Arg: 'static,
      y_Arg: Clone,
      y_Arg: GraphEdge<T>,
      y_Arg: 'static,
      mkl_x_Arg: Clone,
      mkl_x_Arg: GraphEdge<u8>,
      mkl_x_Arg: 'static,
      mkl_y_Arg: Clone,
      mkl_y_Arg: GraphEdge<u8>,
      mkl_y_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_COMPLEX64_or_DT_INT64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    x: x_Arg,
    y: y_Arg,
    mkl_x: mkl_x_Arg,
    mkl_y: mkl_y_Arg,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<T, x_Arg, y_Arg, mkl_x_Arg, mkl_y_Arg> _MklSub<T, x_Arg, y_Arg, mkl_x_Arg, mkl_y_Arg>
where T: TensorType,
      T: Clone,
      x_Arg: Clone,
      x_Arg: GraphEdge<T>,
      x_Arg: 'static,
      y_Arg: Clone,
      y_Arg: GraphEdge<T>,
      y_Arg: 'static,
      mkl_x_Arg: Clone,
      mkl_x_Arg: GraphEdge<u8>,
      mkl_x_Arg: 'static,
      mkl_y_Arg: Clone,
      mkl_y_Arg: GraphEdge<u8>,
      mkl_y_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_COMPLEX64_or_DT_INT64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF,
      T: 'static,
{
    pub fn z(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn mkl_z(self) -> Edge<u8> {
        let rc = Rc::new(self);
        {
            Edge::<u8>::new(rc.clone(), 1)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> (Edge<T>, Edge<u8>) {
        let rc = Rc::new(self);
        (
        {
            Edge::<T>::new(rc.clone(), 0)
        },
        {
            Edge::<u8>::new(rc.clone(), 1)
        },
        )
    }

    pub fn build(x: x_Arg, y: y_Arg, mkl_x: mkl_x_Arg, mkl_y: mkl_y_Arg) -> Self {
        Self {
            phantom_T: PhantomData,
            x,
            y,
            mkl_x,
            mkl_y,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(x: x_Arg, y: y_Arg, mkl_x: mkl_x_Arg, mkl_y: mkl_y_Arg) -> (Edge<T>, Edge<u8>) {
        Self {
            phantom_T: PhantomData,
            x,
            y,
            mkl_x,
            mkl_y,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<node_id_range_Arg, stats_summary_list_Arg, l1_Arg, l2_Arg, tree_complexity_Arg, min_node_weight_Arg> GraphOperation for BoostedTreesCalculateBestGainsPerFeature<node_id_range_Arg, stats_summary_list_Arg, l1_Arg, l2_Arg, tree_complexity_Arg, min_node_weight_Arg>
where node_id_range_Arg: Clone,
      node_id_range_Arg: GraphEdge<i32>,
      node_id_range_Arg: 'static,
      stats_summary_list_Arg: Clone,
      stats_summary_list_Arg: GraphEdge<f32>,
      stats_summary_list_Arg: 'static,
      l1_Arg: Clone,
      l1_Arg: GraphEdge<f32>,
      l1_Arg: 'static,
      l2_Arg: Clone,
      l2_Arg: GraphEdge<f32>,
      l2_Arg: 'static,
      tree_complexity_Arg: Clone,
      tree_complexity_Arg: GraphEdge<f32>,
      tree_complexity_Arg: 'static,
      min_node_weight_Arg: Clone,
      min_node_weight_Arg: GraphEdge<f32>,
      min_node_weight_Arg: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("BoostedTreesCalculateBestGainsPerFeature_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("BoostedTreesCalculateBestGainsPerFeature", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.node_id_range)?
        }
        {
            new_op.add_edge(&self.stats_summary_list)?
        }
        {
            new_op.add_edge(&self.l1)?
        }
        {
            new_op.add_edge(&self.l2)?
        }
        {
            new_op.add_edge(&self.tree_complexity)?
        }
        {
            new_op.add_edge(&self.min_node_weight)?
        }
        {
            (|attr: &i64| {new_op.set_attr_int("max_splits", *attr)})(&self.max_splits)?
        }
        {
            (|attr: &i64| {new_op.set_attr_int("num_features", *attr)})(&self.num_features)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct BoostedTreesCalculateBestGainsPerFeature<node_id_range_Arg, stats_summary_list_Arg, l1_Arg, l2_Arg, tree_complexity_Arg, min_node_weight_Arg>
where node_id_range_Arg: Clone,
      node_id_range_Arg: GraphEdge<i32>,
      node_id_range_Arg: 'static,
      stats_summary_list_Arg: Clone,
      stats_summary_list_Arg: GraphEdge<f32>,
      stats_summary_list_Arg: 'static,
      l1_Arg: Clone,
      l1_Arg: GraphEdge<f32>,
      l1_Arg: 'static,
      l2_Arg: Clone,
      l2_Arg: GraphEdge<f32>,
      l2_Arg: 'static,
      tree_complexity_Arg: Clone,
      tree_complexity_Arg: GraphEdge<f32>,
      tree_complexity_Arg: 'static,
      min_node_weight_Arg: Clone,
      min_node_weight_Arg: GraphEdge<f32>,
      min_node_weight_Arg: 'static,
{
    node_id_range: node_id_range_Arg,
    stats_summary_list: stats_summary_list_Arg,
    l1: l1_Arg,
    l2: l2_Arg,
    tree_complexity: tree_complexity_Arg,
    min_node_weight: min_node_weight_Arg,
    max_splits: i64,
    num_features: i64,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<node_id_range_Arg, stats_summary_list_Arg, l1_Arg, l2_Arg, tree_complexity_Arg, min_node_weight_Arg> BoostedTreesCalculateBestGainsPerFeature<node_id_range_Arg, stats_summary_list_Arg, l1_Arg, l2_Arg, tree_complexity_Arg, min_node_weight_Arg>
where node_id_range_Arg: Clone,
      node_id_range_Arg: GraphEdge<i32>,
      node_id_range_Arg: 'static,
      stats_summary_list_Arg: Clone,
      stats_summary_list_Arg: GraphEdge<f32>,
      stats_summary_list_Arg: 'static,
      l1_Arg: Clone,
      l1_Arg: GraphEdge<f32>,
      l1_Arg: 'static,
      l2_Arg: Clone,
      l2_Arg: GraphEdge<f32>,
      l2_Arg: 'static,
      tree_complexity_Arg: Clone,
      tree_complexity_Arg: GraphEdge<f32>,
      tree_complexity_Arg: 'static,
      min_node_weight_Arg: Clone,
      min_node_weight_Arg: GraphEdge<f32>,
      min_node_weight_Arg: 'static,
{
    pub fn node_ids_list(self) -> Edge<i32> {
        let rc = Rc::new(self);
        {
            Edge::<i32>::new(rc.clone(), 0)
        }
    }

    pub fn gains_list(self) -> Edge<f32> {
        let rc = Rc::new(self);
        {
            Edge::<f32>::new(rc.clone(), 1)
        }
    }

    pub fn thresholds_list(self) -> Edge<i32> {
        let rc = Rc::new(self);
        {
            Edge::<i32>::new(rc.clone(), 2)
        }
    }

    pub fn left_node_contribs_list(self) -> Edge<f32> {
        let rc = Rc::new(self);
        {
            Edge::<f32>::new(rc.clone(), 3)
        }
    }

    pub fn right_node_contribs_list(self) -> Edge<f32> {
        let rc = Rc::new(self);
        {
            Edge::<f32>::new(rc.clone(), 4)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> (Edge<i32>, Edge<f32>, Edge<i32>, Edge<f32>, Edge<f32>) {
        let rc = Rc::new(self);
        (
        {
            Edge::<i32>::new(rc.clone(), 0)
        },
        {
            Edge::<f32>::new(rc.clone(), 1)
        },
        {
            Edge::<i32>::new(rc.clone(), 2)
        },
        {
            Edge::<f32>::new(rc.clone(), 3)
        },
        {
            Edge::<f32>::new(rc.clone(), 4)
        },
        )
    }

    pub fn build(node_id_range: node_id_range_Arg, stats_summary_list: stats_summary_list_Arg, l1: l1_Arg, l2: l2_Arg, tree_complexity: tree_complexity_Arg, min_node_weight: min_node_weight_Arg, max_splits: i64, num_features: i64) -> Self {
        Self {
            node_id_range,
            stats_summary_list,
            l1,
            l2,
            tree_complexity,
            min_node_weight,
            max_splits: max_splits,
            num_features: num_features,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(node_id_range: node_id_range_Arg, stats_summary_list: stats_summary_list_Arg, l1: l1_Arg, l2: l2_Arg, tree_complexity: tree_complexity_Arg, min_node_weight: min_node_weight_Arg, max_splits: i64, num_features: i64) -> (Edge<i32>, Edge<f32>, Edge<i32>, Edge<f32>, Edge<f32>) {
        Self {
            node_id_range,
            stats_summary_list,
            l1,
            l2,
            tree_complexity,
            min_node_weight,
            max_splits: max_splits,
            num_features: num_features,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<T, image_Arg> GraphOperation for EncodePng<T, image_Arg>
where T: TensorType,
      T: Clone,
      image_Arg: Clone,
      image_Arg: GraphEdge<T>,
      image_Arg: 'static,
      T: con_or_DT_UINT8_or_DT_UINT16,
      T: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("EncodePng_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("EncodePng", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.image)?
        }
        {
            match self.compression {
                None => new_op.set_attr_value_proto("compression", &vec![24_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 1_u8,])?,
                Some(ref value) => (|attr: &i64| {new_op.set_attr_int("compression", *attr)})(&value)?,
            };
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct EncodePng<T, image_Arg>
where T: TensorType,
      T: Clone,
      image_Arg: Clone,
      image_Arg: GraphEdge<T>,
      image_Arg: 'static,
      T: con_or_DT_UINT8_or_DT_UINT16,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    image: image_Arg,
    compression: Option<i64>,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<T, image_Arg> EncodePng<T, image_Arg>
where T: TensorType,
      T: Clone,
      image_Arg: Clone,
      image_Arg: GraphEdge<T>,
      image_Arg: 'static,
      T: con_or_DT_UINT8_or_DT_UINT16,
      T: 'static,
{
    pub fn contents(self) -> Edge<String> {
        let rc = Rc::new(self);
        {
            Edge::<String>::new(rc.clone(), 0)
        }
    }

    pub fn compression(&mut self, compression: i64) -> Self {
        self.compression = Some(compression);
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<String> {
        let rc = Rc::new(self);
        {
            Edge::<String>::new(rc.clone(), 0)
        }
    }

    pub fn build(image: image_Arg) -> Self {
        Self {
            phantom_T: PhantomData,
            image,
            compression: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(image: image_Arg) -> Edge<String> {
        Self {
            phantom_T: PhantomData,
            image,
            compression: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<T, x_Arg, y_Arg, mkl_x_Arg, mkl_y_Arg> GraphOperation for _MklMul<T, x_Arg, y_Arg, mkl_x_Arg, mkl_y_Arg>
where T: TensorType,
      T: Clone,
      x_Arg: Clone,
      x_Arg: GraphEdge<T>,
      x_Arg: 'static,
      y_Arg: Clone,
      y_Arg: GraphEdge<T>,
      y_Arg: 'static,
      mkl_x_Arg: Clone,
      mkl_x_Arg: GraphEdge<u8>,
      mkl_x_Arg: 'static,
      mkl_y_Arg: Clone,
      mkl_y_Arg: GraphEdge<u8>,
      mkl_y_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF,
      T: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("_MklMul_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("_MklMul", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.x)?
        }
        {
            new_op.add_edge(&self.y)?
        }
        {
            new_op.add_edge(&self.mkl_x)?
        }
        {
            new_op.add_edge(&self.mkl_y)?
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct _MklMul<T, x_Arg, y_Arg, mkl_x_Arg, mkl_y_Arg>
where T: TensorType,
      T: Clone,
      x_Arg: Clone,
      x_Arg: GraphEdge<T>,
      x_Arg: 'static,
      y_Arg: Clone,
      y_Arg: GraphEdge<T>,
      y_Arg: 'static,
      mkl_x_Arg: Clone,
      mkl_x_Arg: GraphEdge<u8>,
      mkl_x_Arg: 'static,
      mkl_y_Arg: Clone,
      mkl_y_Arg: GraphEdge<u8>,
      mkl_y_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    x: x_Arg,
    y: y_Arg,
    mkl_x: mkl_x_Arg,
    mkl_y: mkl_y_Arg,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<T, x_Arg, y_Arg, mkl_x_Arg, mkl_y_Arg> _MklMul<T, x_Arg, y_Arg, mkl_x_Arg, mkl_y_Arg>
where T: TensorType,
      T: Clone,
      x_Arg: Clone,
      x_Arg: GraphEdge<T>,
      x_Arg: 'static,
      y_Arg: Clone,
      y_Arg: GraphEdge<T>,
      y_Arg: 'static,
      mkl_x_Arg: Clone,
      mkl_x_Arg: GraphEdge<u8>,
      mkl_x_Arg: 'static,
      mkl_y_Arg: Clone,
      mkl_y_Arg: GraphEdge<u8>,
      mkl_y_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF,
      T: 'static,
{
    pub fn z(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn mkl_z(self) -> Edge<u8> {
        let rc = Rc::new(self);
        {
            Edge::<u8>::new(rc.clone(), 1)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> (Edge<T>, Edge<u8>) {
        let rc = Rc::new(self);
        (
        {
            Edge::<T>::new(rc.clone(), 0)
        },
        {
            Edge::<u8>::new(rc.clone(), 1)
        },
        )
    }

    pub fn build(x: x_Arg, y: y_Arg, mkl_x: mkl_x_Arg, mkl_y: mkl_y_Arg) -> Self {
        Self {
            phantom_T: PhantomData,
            x,
            y,
            mkl_x,
            mkl_y,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(x: x_Arg, y: y_Arg, mkl_x: mkl_x_Arg, mkl_y: mkl_y_Arg) -> (Edge<T>, Edge<u8>) {
        Self {
            phantom_T: PhantomData,
            x,
            y,
            mkl_x,
            mkl_y,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<T, x_Arg, y_Arg> GraphOperation for Div<T, x_Arg, y_Arg>
where T: TensorType,
      T: Clone,
      x_Arg: Clone,
      x_Arg: GraphEdge<T>,
      x_Arg: 'static,
      y_Arg: Clone,
      y_Arg: GraphEdge<T>,
      y_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF,
      T: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("Div_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("Div", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.x)?
        }
        {
            new_op.add_edge(&self.y)?
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct Div<T, x_Arg, y_Arg>
where T: TensorType,
      T: Clone,
      x_Arg: Clone,
      x_Arg: GraphEdge<T>,
      x_Arg: 'static,
      y_Arg: Clone,
      y_Arg: GraphEdge<T>,
      y_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    x: x_Arg,
    y: y_Arg,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<T, x_Arg, y_Arg> Div<T, x_Arg, y_Arg>
where T: TensorType,
      T: Clone,
      x_Arg: Clone,
      x_Arg: GraphEdge<T>,
      x_Arg: 'static,
      y_Arg: Clone,
      y_Arg: GraphEdge<T>,
      y_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF,
      T: 'static,
{
    pub fn z(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(x: x_Arg, y: y_Arg) -> Self {
        Self {
            phantom_T: PhantomData,
            x,
            y,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(x: x_Arg, y: y_Arg) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            x,
            y,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<handle_Arg, flow_in_Arg, dtype> GraphOperation for TensorArrayPack<handle_Arg, flow_in_Arg, dtype>
where handle_Arg: Clone,
      handle_Arg: GraphRefEdge<String>,
      handle_Arg: 'static,
      flow_in_Arg: Clone,
      flow_in_Arg: GraphEdge<f32>,
      flow_in_Arg: 'static,
      dtype: TensorType,
      dtype: 'static,
      dtype: Clone,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("TensorArrayPack_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("TensorArrayPack", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.handle)?
        }
        {
            new_op.add_edge(&self.flow_in)?
        }
        {
            new_op.set_attr_type("dtype", dtype::data_type())?;
        }
        {
            match self.element_shape {
                None => new_op.set_attr_value_proto("element_shape", &vec![58_u8, 0_u8,])?,
                Some(ref value) => (|attr| {new_op.set_attr_shape("element_shape", attr)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct TensorArrayPack<handle_Arg, flow_in_Arg, dtype>
where handle_Arg: Clone,
      handle_Arg: GraphRefEdge<String>,
      handle_Arg: 'static,
      flow_in_Arg: Clone,
      flow_in_Arg: GraphEdge<f32>,
      flow_in_Arg: 'static,
      dtype: TensorType,
      dtype: 'static,
      dtype: Clone,
{
    handle: handle_Arg,
    flow_in: flow_in_Arg,
    phantom_dtype: PhantomData<dtype>,
    element_shape: Option<OtherShape>,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<handle_Arg, flow_in_Arg, dtype> TensorArrayPack<handle_Arg, flow_in_Arg, dtype>
where handle_Arg: Clone,
      handle_Arg: GraphRefEdge<String>,
      handle_Arg: 'static,
      flow_in_Arg: Clone,
      flow_in_Arg: GraphEdge<f32>,
      flow_in_Arg: 'static,
      dtype: TensorType,
      dtype: 'static,
      dtype: Clone,
{
    pub fn value(self) -> Edge<dtype> {
        let rc = Rc::new(self);
        {
            Edge::<dtype>::new(rc.clone(), 0)
        }
    }

    pub fn element_shape(&mut self, element_shape: &OtherShape) -> Self {
        self.element_shape = Some(element_shape.clone());
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<dtype> {
        let rc = Rc::new(self);
        {
            Edge::<dtype>::new(rc.clone(), 0)
        }
    }

    pub fn build(handle: handle_Arg, flow_in: flow_in_Arg) -> Self {
        Self {
            handle,
            flow_in,
            phantom_dtype: PhantomData,
            element_shape: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(handle: handle_Arg, flow_in: flow_in_Arg) -> Edge<dtype> {
        Self {
            handle,
            flow_in,
            phantom_dtype: PhantomData,
            element_shape: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<T, x_Arg, y_Arg> GraphOperation for Maximum<T, x_Arg, y_Arg>
where T: TensorType,
      T: Clone,
      x_Arg: Clone,
      x_Arg: GraphEdge<T>,
      x_Arg: 'static,
      y_Arg: Clone,
      y_Arg: GraphEdge<T>,
      y_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_INT64_or_DT_BFLOAT16_or_DT_HALF,
      T: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("Maximum_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("Maximum", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.x)?
        }
        {
            new_op.add_edge(&self.y)?
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct Maximum<T, x_Arg, y_Arg>
where T: TensorType,
      T: Clone,
      x_Arg: Clone,
      x_Arg: GraphEdge<T>,
      x_Arg: 'static,
      y_Arg: Clone,
      y_Arg: GraphEdge<T>,
      y_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_INT64_or_DT_BFLOAT16_or_DT_HALF,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    x: x_Arg,
    y: y_Arg,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<T, x_Arg, y_Arg> Maximum<T, x_Arg, y_Arg>
where T: TensorType,
      T: Clone,
      x_Arg: Clone,
      x_Arg: GraphEdge<T>,
      x_Arg: 'static,
      y_Arg: Clone,
      y_Arg: GraphEdge<T>,
      y_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_INT64_or_DT_BFLOAT16_or_DT_HALF,
      T: 'static,
{
    pub fn z(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(x: x_Arg, y: y_Arg) -> Self {
        Self {
            phantom_T: PhantomData,
            x,
            y,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(x: x_Arg, y: y_Arg) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            x,
            y,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<filename_Arg, contents_Arg> GraphOperation for WriteFile<filename_Arg, contents_Arg>
where filename_Arg: Clone,
      filename_Arg: GraphEdge<String>,
      filename_Arg: 'static,
      contents_Arg: Clone,
      contents_Arg: GraphEdge<String>,
      contents_Arg: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("WriteFile_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("WriteFile", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.filename)?
        }
        {
            new_op.add_edge(&self.contents)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct WriteFile<filename_Arg, contents_Arg>
where filename_Arg: Clone,
      filename_Arg: GraphEdge<String>,
      filename_Arg: 'static,
      contents_Arg: Clone,
      contents_Arg: GraphEdge<String>,
      contents_Arg: 'static,
{
    filename: filename_Arg,
    contents: contents_Arg,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<filename_Arg, contents_Arg> WriteFile<filename_Arg, contents_Arg>
where filename_Arg: Clone,
      filename_Arg: GraphEdge<String>,
      filename_Arg: 'static,
      contents_Arg: Clone,
      contents_Arg: GraphEdge<String>,
      contents_Arg: 'static,
{
    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> () {
        let rc = Rc::new(self);
        (
        )
    }

    pub fn build(filename: filename_Arg, contents: contents_Arg) -> Self {
        Self {
            filename,
            contents,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(filename: filename_Arg, contents: contents_Arg) -> () {
        Self {
            filename,
            contents,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<T, x_Arg, y_Arg, mkl_x_Arg, mkl_y_Arg> GraphOperation for _MklMaximum<T, x_Arg, y_Arg, mkl_x_Arg, mkl_y_Arg>
where T: TensorType,
      T: Clone,
      x_Arg: Clone,
      x_Arg: GraphEdge<T>,
      x_Arg: 'static,
      y_Arg: Clone,
      y_Arg: GraphEdge<T>,
      y_Arg: 'static,
      mkl_x_Arg: Clone,
      mkl_x_Arg: GraphEdge<u8>,
      mkl_x_Arg: 'static,
      mkl_y_Arg: Clone,
      mkl_y_Arg: GraphEdge<u8>,
      mkl_y_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_INT64_or_DT_HALF,
      T: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("_MklMaximum_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("_MklMaximum", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.x)?
        }
        {
            new_op.add_edge(&self.y)?
        }
        {
            new_op.add_edge(&self.mkl_x)?
        }
        {
            new_op.add_edge(&self.mkl_y)?
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct _MklMaximum<T, x_Arg, y_Arg, mkl_x_Arg, mkl_y_Arg>
where T: TensorType,
      T: Clone,
      x_Arg: Clone,
      x_Arg: GraphEdge<T>,
      x_Arg: 'static,
      y_Arg: Clone,
      y_Arg: GraphEdge<T>,
      y_Arg: 'static,
      mkl_x_Arg: Clone,
      mkl_x_Arg: GraphEdge<u8>,
      mkl_x_Arg: 'static,
      mkl_y_Arg: Clone,
      mkl_y_Arg: GraphEdge<u8>,
      mkl_y_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_INT64_or_DT_HALF,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    x: x_Arg,
    y: y_Arg,
    mkl_x: mkl_x_Arg,
    mkl_y: mkl_y_Arg,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<T, x_Arg, y_Arg, mkl_x_Arg, mkl_y_Arg> _MklMaximum<T, x_Arg, y_Arg, mkl_x_Arg, mkl_y_Arg>
where T: TensorType,
      T: Clone,
      x_Arg: Clone,
      x_Arg: GraphEdge<T>,
      x_Arg: 'static,
      y_Arg: Clone,
      y_Arg: GraphEdge<T>,
      y_Arg: 'static,
      mkl_x_Arg: Clone,
      mkl_x_Arg: GraphEdge<u8>,
      mkl_x_Arg: 'static,
      mkl_y_Arg: Clone,
      mkl_y_Arg: GraphEdge<u8>,
      mkl_y_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_INT64_or_DT_HALF,
      T: 'static,
{
    pub fn z(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn mkl_z(self) -> Edge<u8> {
        let rc = Rc::new(self);
        {
            Edge::<u8>::new(rc.clone(), 1)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> (Edge<T>, Edge<u8>) {
        let rc = Rc::new(self);
        (
        {
            Edge::<T>::new(rc.clone(), 0)
        },
        {
            Edge::<u8>::new(rc.clone(), 1)
        },
        )
    }

    pub fn build(x: x_Arg, y: y_Arg, mkl_x: mkl_x_Arg, mkl_y: mkl_y_Arg) -> Self {
        Self {
            phantom_T: PhantomData,
            x,
            y,
            mkl_x,
            mkl_y,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(x: x_Arg, y: y_Arg, mkl_x: mkl_x_Arg, mkl_y: mkl_y_Arg) -> (Edge<T>, Edge<u8>) {
        Self {
            phantom_T: PhantomData,
            x,
            y,
            mkl_x,
            mkl_y,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<handle_Arg, num_required_Arg, dtype> GraphOperation for SparseAccumulatorTakeGradient<handle_Arg, num_required_Arg, dtype>
where handle_Arg: Clone,
      handle_Arg: GraphRefEdge<String>,
      handle_Arg: 'static,
      num_required_Arg: Clone,
      num_required_Arg: GraphEdge<i32>,
      num_required_Arg: 'static,
      dtype: TensorType,
      dtype: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      dtype: 'static,
      dtype: Clone,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("SparseAccumulatorTakeGradient_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("SparseAccumulatorTakeGradient", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.handle)?
        }
        {
            new_op.add_edge(&self.num_required)?
        }
        {
            new_op.set_attr_type("dtype", dtype::data_type())?;
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct SparseAccumulatorTakeGradient<handle_Arg, num_required_Arg, dtype>
where handle_Arg: Clone,
      handle_Arg: GraphRefEdge<String>,
      handle_Arg: 'static,
      num_required_Arg: Clone,
      num_required_Arg: GraphEdge<i32>,
      num_required_Arg: 'static,
      dtype: TensorType,
      dtype: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      dtype: 'static,
      dtype: Clone,
{
    handle: handle_Arg,
    num_required: num_required_Arg,
    phantom_dtype: PhantomData<dtype>,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<handle_Arg, num_required_Arg, dtype> SparseAccumulatorTakeGradient<handle_Arg, num_required_Arg, dtype>
where handle_Arg: Clone,
      handle_Arg: GraphRefEdge<String>,
      handle_Arg: 'static,
      num_required_Arg: Clone,
      num_required_Arg: GraphEdge<i32>,
      num_required_Arg: 'static,
      dtype: TensorType,
      dtype: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      dtype: 'static,
      dtype: Clone,
{
    pub fn indices(self) -> Edge<i64> {
        let rc = Rc::new(self);
        {
            Edge::<i64>::new(rc.clone(), 0)
        }
    }

    pub fn values(self) -> Edge<dtype> {
        let rc = Rc::new(self);
        {
            Edge::<dtype>::new(rc.clone(), 1)
        }
    }

    pub fn shape(self) -> Edge<i64> {
        let rc = Rc::new(self);
        {
            Edge::<i64>::new(rc.clone(), 2)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> (Edge<i64>, Edge<dtype>, Edge<i64>) {
        let rc = Rc::new(self);
        (
        {
            Edge::<i64>::new(rc.clone(), 0)
        },
        {
            Edge::<dtype>::new(rc.clone(), 1)
        },
        {
            Edge::<i64>::new(rc.clone(), 2)
        },
        )
    }

    pub fn build(handle: handle_Arg, num_required: num_required_Arg) -> Self {
        Self {
            handle,
            num_required,
            phantom_dtype: PhantomData,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(handle: handle_Arg, num_required: num_required_Arg) -> (Edge<i64>, Edge<dtype>, Edge<i64>) {
        Self {
            handle,
            num_required,
            phantom_dtype: PhantomData,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<T, x_Arg, y_Arg> GraphOperation for FloorMod<T, x_Arg, y_Arg>
where T: TensorType,
      T: Clone,
      x_Arg: Clone,
      x_Arg: GraphEdge<T>,
      x_Arg: 'static,
      y_Arg: Clone,
      y_Arg: GraphEdge<T>,
      y_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_INT64_or_DT_BFLOAT16_or_DT_HALF,
      T: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("FloorMod_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("FloorMod", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.x)?
        }
        {
            new_op.add_edge(&self.y)?
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct FloorMod<T, x_Arg, y_Arg>
where T: TensorType,
      T: Clone,
      x_Arg: Clone,
      x_Arg: GraphEdge<T>,
      x_Arg: 'static,
      y_Arg: Clone,
      y_Arg: GraphEdge<T>,
      y_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_INT64_or_DT_BFLOAT16_or_DT_HALF,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    x: x_Arg,
    y: y_Arg,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<T, x_Arg, y_Arg> FloorMod<T, x_Arg, y_Arg>
where T: TensorType,
      T: Clone,
      x_Arg: Clone,
      x_Arg: GraphEdge<T>,
      x_Arg: 'static,
      y_Arg: Clone,
      y_Arg: GraphEdge<T>,
      y_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_INT64_or_DT_BFLOAT16_or_DT_HALF,
      T: 'static,
{
    pub fn z(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(x: x_Arg, y: y_Arg) -> Self {
        Self {
            phantom_T: PhantomData,
            x,
            y,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(x: x_Arg, y: y_Arg) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            x,
            y,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<T, x_Arg, y_Arg> GraphOperation for TruncateMod<T, x_Arg, y_Arg>
where T: TensorType,
      T: Clone,
      x_Arg: Clone,
      x_Arg: GraphEdge<T>,
      x_Arg: 'static,
      y_Arg: Clone,
      y_Arg: GraphEdge<T>,
      y_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_INT64_or_DT_BFLOAT16_or_DT_HALF,
      T: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("TruncateMod_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("TruncateMod", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.x)?
        }
        {
            new_op.add_edge(&self.y)?
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct TruncateMod<T, x_Arg, y_Arg>
where T: TensorType,
      T: Clone,
      x_Arg: Clone,
      x_Arg: GraphEdge<T>,
      x_Arg: 'static,
      y_Arg: Clone,
      y_Arg: GraphEdge<T>,
      y_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_INT64_or_DT_BFLOAT16_or_DT_HALF,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    x: x_Arg,
    y: y_Arg,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<T, x_Arg, y_Arg> TruncateMod<T, x_Arg, y_Arg>
where T: TensorType,
      T: Clone,
      x_Arg: Clone,
      x_Arg: GraphEdge<T>,
      x_Arg: 'static,
      y_Arg: Clone,
      y_Arg: GraphEdge<T>,
      y_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_INT64_or_DT_BFLOAT16_or_DT_HALF,
      T: 'static,
{
    pub fn z(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(x: x_Arg, y: y_Arg) -> Self {
        Self {
            phantom_T: PhantomData,
            x,
            y,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(x: x_Arg, y: y_Arg) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            x,
            y,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<parameters_Arg, ms_Arg, mom_Arg, gradient_accumulators_Arg> GraphOperation for LoadTPUEmbeddingRMSPropParametersGradAccumDebug<parameters_Arg, ms_Arg, mom_Arg, gradient_accumulators_Arg>
where parameters_Arg: Clone,
      parameters_Arg: GraphEdge<f32>,
      parameters_Arg: 'static,
      ms_Arg: Clone,
      ms_Arg: GraphEdge<f32>,
      ms_Arg: 'static,
      mom_Arg: Clone,
      mom_Arg: GraphEdge<f32>,
      mom_Arg: 'static,
      gradient_accumulators_Arg: Clone,
      gradient_accumulators_Arg: GraphEdge<f32>,
      gradient_accumulators_Arg: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("LoadTPUEmbeddingRMSPropParametersGradAccumDebug_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("LoadTPUEmbeddingRMSPropParametersGradAccumDebug", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.parameters)?
        }
        {
            new_op.add_edge(&self.ms)?
        }
        {
            new_op.add_edge(&self.mom)?
        }
        {
            new_op.add_edge(&self.gradient_accumulators)?
        }
        {
            match self.table_id {
                None => new_op.set_attr_value_proto("table_id", &vec![24_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 1_u8,])?,
                Some(ref value) => (|attr: &i64| {new_op.set_attr_int("table_id", *attr)})(&value)?,
            };
        }
        {
            match self.table_name {
                None => new_op.set_attr_value_proto("table_name", &vec![18_u8, 0_u8,])?,
                Some(ref value) => (|attr| {new_op.set_attr_string("table_name", attr)})(&value)?,
            };
        }
        {
            (|attr: &i64| {new_op.set_attr_int("num_shards", *attr)})(&self.num_shards)?
        }
        {
            (|attr: &i64| {new_op.set_attr_int("shard_id", *attr)})(&self.shard_id)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct LoadTPUEmbeddingRMSPropParametersGradAccumDebug<parameters_Arg, ms_Arg, mom_Arg, gradient_accumulators_Arg>
where parameters_Arg: Clone,
      parameters_Arg: GraphEdge<f32>,
      parameters_Arg: 'static,
      ms_Arg: Clone,
      ms_Arg: GraphEdge<f32>,
      ms_Arg: 'static,
      mom_Arg: Clone,
      mom_Arg: GraphEdge<f32>,
      mom_Arg: 'static,
      gradient_accumulators_Arg: Clone,
      gradient_accumulators_Arg: GraphEdge<f32>,
      gradient_accumulators_Arg: 'static,
{
    parameters: parameters_Arg,
    ms: ms_Arg,
    mom: mom_Arg,
    gradient_accumulators: gradient_accumulators_Arg,
    table_id: Option<i64>,
    table_name: Option<String>,
    num_shards: i64,
    shard_id: i64,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<parameters_Arg, ms_Arg, mom_Arg, gradient_accumulators_Arg> LoadTPUEmbeddingRMSPropParametersGradAccumDebug<parameters_Arg, ms_Arg, mom_Arg, gradient_accumulators_Arg>
where parameters_Arg: Clone,
      parameters_Arg: GraphEdge<f32>,
      parameters_Arg: 'static,
      ms_Arg: Clone,
      ms_Arg: GraphEdge<f32>,
      ms_Arg: 'static,
      mom_Arg: Clone,
      mom_Arg: GraphEdge<f32>,
      mom_Arg: 'static,
      gradient_accumulators_Arg: Clone,
      gradient_accumulators_Arg: GraphEdge<f32>,
      gradient_accumulators_Arg: 'static,
{
    pub fn table_id(&mut self, table_id: i64) -> Self {
        self.table_id = Some(table_id);
        self.clone()
    }

    pub fn table_name(&mut self, table_name: &str) -> Self {
        self.table_name = Some(table_name.to_string());
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> () {
        let rc = Rc::new(self);
        (
        )
    }

    pub fn build(parameters: parameters_Arg, ms: ms_Arg, mom: mom_Arg, gradient_accumulators: gradient_accumulators_Arg, num_shards: i64, shard_id: i64) -> Self {
        Self {
            parameters,
            ms,
            mom,
            gradient_accumulators,
            table_id: None,
            table_name: None,
            num_shards: num_shards,
            shard_id: shard_id,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(parameters: parameters_Arg, ms: ms_Arg, mom: mom_Arg, gradient_accumulators: gradient_accumulators_Arg, num_shards: i64, shard_id: i64) -> () {
        Self {
            parameters,
            ms,
            mom,
            gradient_accumulators,
            table_id: None,
            table_name: None,
            num_shards: num_shards,
            shard_id: shard_id,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<concat_dim_Arg, shape_Arg> GraphOperation for ConcatOffset<concat_dim_Arg, shape_Arg>
where concat_dim_Arg: Clone,
      concat_dim_Arg: GraphEdge<i32>,
      concat_dim_Arg: 'static,
      shape_Arg: Clone,
      shape_Arg: GraphEdge<i32>,
      shape_Arg: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("ConcatOffset_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("ConcatOffset", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.concat_dim)?
        }
        {
            new_op.add_edge(&self.shape)?
        }
        {
            (|attr: &i64| {new_op.set_attr_int("N", *attr)})(&self.N)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct ConcatOffset<concat_dim_Arg, shape_Arg>
where concat_dim_Arg: Clone,
      concat_dim_Arg: GraphEdge<i32>,
      concat_dim_Arg: 'static,
      shape_Arg: Clone,
      shape_Arg: GraphEdge<i32>,
      shape_Arg: 'static,
{
    concat_dim: concat_dim_Arg,
    shape: shape_Arg,
    N: i64,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<concat_dim_Arg, shape_Arg> ConcatOffset<concat_dim_Arg, shape_Arg>
where concat_dim_Arg: Clone,
      concat_dim_Arg: GraphEdge<i32>,
      concat_dim_Arg: 'static,
      shape_Arg: Clone,
      shape_Arg: GraphEdge<i32>,
      shape_Arg: 'static,
{
    pub fn offset(self) -> Edge<i32> {
        let rc = Rc::new(self);
        {
            Edge::<i32>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<i32> {
        let rc = Rc::new(self);
        {
            Edge::<i32>::new(rc.clone(), 0)
        }
    }

    pub fn build(concat_dim: concat_dim_Arg, shape: shape_Arg, N: i64) -> Self {
        Self {
            concat_dim,
            shape,
            N: N,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(concat_dim: concat_dim_Arg, shape: shape_Arg, N: i64) -> Edge<i32> {
        Self {
            concat_dim,
            shape,
            N: N,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<T, a_Arg, x_Arg> GraphOperation for Igamma<T, a_Arg, x_Arg>
where T: TensorType,
      T: Clone,
      a_Arg: Clone,
      a_Arg: GraphEdge<T>,
      a_Arg: 'static,
      x_Arg: Clone,
      x_Arg: GraphEdge<T>,
      x_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE,
      T: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("Igamma_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("Igamma", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.a)?
        }
        {
            new_op.add_edge(&self.x)?
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct Igamma<T, a_Arg, x_Arg>
where T: TensorType,
      T: Clone,
      a_Arg: Clone,
      a_Arg: GraphEdge<T>,
      a_Arg: 'static,
      x_Arg: Clone,
      x_Arg: GraphEdge<T>,
      x_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    a: a_Arg,
    x: x_Arg,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<T, a_Arg, x_Arg> Igamma<T, a_Arg, x_Arg>
where T: TensorType,
      T: Clone,
      a_Arg: Clone,
      a_Arg: GraphEdge<T>,
      a_Arg: 'static,
      x_Arg: Clone,
      x_Arg: GraphEdge<T>,
      x_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE,
      T: 'static,
{
    pub fn z(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(a: a_Arg, x: x_Arg) -> Self {
        Self {
            phantom_T: PhantomData,
            a,
            x,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(a: a_Arg, x: x_Arg) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            a,
            x,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<T, a_Arg, x_Arg> GraphOperation for Polygamma<T, a_Arg, x_Arg>
where T: TensorType,
      T: Clone,
      a_Arg: Clone,
      a_Arg: GraphEdge<T>,
      a_Arg: 'static,
      x_Arg: Clone,
      x_Arg: GraphEdge<T>,
      x_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE,
      T: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("Polygamma_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("Polygamma", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.a)?
        }
        {
            new_op.add_edge(&self.x)?
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct Polygamma<T, a_Arg, x_Arg>
where T: TensorType,
      T: Clone,
      a_Arg: Clone,
      a_Arg: GraphEdge<T>,
      a_Arg: 'static,
      x_Arg: Clone,
      x_Arg: GraphEdge<T>,
      x_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    a: a_Arg,
    x: x_Arg,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<T, a_Arg, x_Arg> Polygamma<T, a_Arg, x_Arg>
where T: TensorType,
      T: Clone,
      a_Arg: Clone,
      a_Arg: GraphEdge<T>,
      a_Arg: 'static,
      x_Arg: Clone,
      x_Arg: GraphEdge<T>,
      x_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE,
      T: 'static,
{
    pub fn z(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(a: a_Arg, x: x_Arg) -> Self {
        Self {
            phantom_T: PhantomData,
            a,
            x,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(a: a_Arg, x: x_Arg) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            a,
            x,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<T, input_Arg> GraphOperation for Identity<T, input_Arg>
where T: TensorType,
      T: Clone,
      input_Arg: Clone,
      input_Arg: GraphEdge<T>,
      input_Arg: 'static,
      T: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("Identity_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("Identity", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.input)?
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct Identity<T, input_Arg>
where T: TensorType,
      T: Clone,
      input_Arg: Clone,
      input_Arg: GraphEdge<T>,
      input_Arg: 'static,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    input: input_Arg,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<T, input_Arg> Identity<T, input_Arg>
where T: TensorType,
      T: Clone,
      input_Arg: Clone,
      input_Arg: GraphEdge<T>,
      input_Arg: 'static,
      T: 'static,
{
    pub fn output(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(input: input_Arg) -> Self {
        Self {
            phantom_T: PhantomData,
            input,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(input: input_Arg) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            input,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<T, y_Arg, x_Arg> GraphOperation for Atan2<T, y_Arg, x_Arg>
where T: TensorType,
      T: Clone,
      y_Arg: Clone,
      y_Arg: GraphEdge<T>,
      y_Arg: 'static,
      x_Arg: Clone,
      x_Arg: GraphEdge<T>,
      x_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
      T: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("Atan2_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("Atan2", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.y)?
        }
        {
            new_op.add_edge(&self.x)?
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct Atan2<T, y_Arg, x_Arg>
where T: TensorType,
      T: Clone,
      y_Arg: Clone,
      y_Arg: GraphEdge<T>,
      y_Arg: 'static,
      x_Arg: Clone,
      x_Arg: GraphEdge<T>,
      x_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    y: y_Arg,
    x: x_Arg,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<T, y_Arg, x_Arg> Atan2<T, y_Arg, x_Arg>
where T: TensorType,
      T: Clone,
      y_Arg: Clone,
      y_Arg: GraphEdge<T>,
      y_Arg: 'static,
      x_Arg: Clone,
      x_Arg: GraphEdge<T>,
      x_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
      T: 'static,
{
    pub fn z(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(y: y_Arg, x: x_Arg) -> Self {
        Self {
            phantom_T: PhantomData,
            y,
            x,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(y: y_Arg, x: x_Arg) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            y,
            x,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<batch_Arg, mode_override_Arg> GraphOperation for EnqueueTPUEmbeddingIntegerBatch<batch_Arg, mode_override_Arg>
where batch_Arg: Clone,
      batch_Arg: GraphEdge<i32>,
      batch_Arg: 'static,
      mode_override_Arg: Clone,
      mode_override_Arg: GraphEdge<String>,
      mode_override_Arg: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("EnqueueTPUEmbeddingIntegerBatch_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("EnqueueTPUEmbeddingIntegerBatch", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.batch)?
        }
        {
            new_op.add_edge(&self.mode_override)?
        }
        {
            (|attr: &i64| {new_op.set_attr_int("N", *attr)})(&self.N)?
        }
        {
            match self.device_ordinal {
                None => new_op.set_attr_value_proto("device_ordinal", &vec![24_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 255_u8, 1_u8,])?,
                Some(ref value) => (|attr: &i64| {new_op.set_attr_int("device_ordinal", *attr)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct EnqueueTPUEmbeddingIntegerBatch<batch_Arg, mode_override_Arg>
where batch_Arg: Clone,
      batch_Arg: GraphEdge<i32>,
      batch_Arg: 'static,
      mode_override_Arg: Clone,
      mode_override_Arg: GraphEdge<String>,
      mode_override_Arg: 'static,
{
    batch: batch_Arg,
    mode_override: mode_override_Arg,
    N: i64,
    device_ordinal: Option<i64>,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<batch_Arg, mode_override_Arg> EnqueueTPUEmbeddingIntegerBatch<batch_Arg, mode_override_Arg>
where batch_Arg: Clone,
      batch_Arg: GraphEdge<i32>,
      batch_Arg: 'static,
      mode_override_Arg: Clone,
      mode_override_Arg: GraphEdge<String>,
      mode_override_Arg: 'static,
{
    pub fn device_ordinal(&mut self, device_ordinal: i64) -> Self {
        self.device_ordinal = Some(device_ordinal);
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> () {
        let rc = Rc::new(self);
        (
        )
    }

    pub fn build(batch: batch_Arg, mode_override: mode_override_Arg, N: i64) -> Self {
        Self {
            batch,
            mode_override,
            N: N,
            device_ordinal: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(batch: batch_Arg, mode_override: mode_override_Arg, N: i64) -> () {
        Self {
            batch,
            mode_override,
            N: N,
            device_ordinal: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<T, x_Arg, y_Arg> GraphOperation for LessEqual<T, x_Arg, y_Arg>
where T: TensorType,
      T: Clone,
      x_Arg: Clone,
      x_Arg: GraphEdge<T>,
      x_Arg: 'static,
      y_Arg: Clone,
      y_Arg: GraphEdge<T>,
      y_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("LessEqual_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("LessEqual", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.x)?
        }
        {
            new_op.add_edge(&self.y)?
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct LessEqual<T, x_Arg, y_Arg>
where T: TensorType,
      T: Clone,
      x_Arg: Clone,
      x_Arg: GraphEdge<T>,
      x_Arg: 'static,
      y_Arg: Clone,
      y_Arg: GraphEdge<T>,
      y_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    x: x_Arg,
    y: y_Arg,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<T, x_Arg, y_Arg> LessEqual<T, x_Arg, y_Arg>
where T: TensorType,
      T: Clone,
      x_Arg: Clone,
      x_Arg: GraphEdge<T>,
      x_Arg: 'static,
      y_Arg: Clone,
      y_Arg: GraphEdge<T>,
      y_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
{
    pub fn z(self) -> Edge<bool> {
        let rc = Rc::new(self);
        {
            Edge::<bool>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<bool> {
        let rc = Rc::new(self);
        {
            Edge::<bool>::new(rc.clone(), 0)
        }
    }

    pub fn build(x: x_Arg, y: y_Arg) -> Self {
        Self {
            phantom_T: PhantomData,
            x,
            y,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(x: x_Arg, y: y_Arg) -> Edge<bool> {
        Self {
            phantom_T: PhantomData,
            x,
            y,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<T, x_Arg, y_Arg> GraphOperation for GreaterEqual<T, x_Arg, y_Arg>
where T: TensorType,
      T: Clone,
      x_Arg: Clone,
      x_Arg: GraphEdge<T>,
      x_Arg: 'static,
      y_Arg: Clone,
      y_Arg: GraphEdge<T>,
      y_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("GreaterEqual_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("GreaterEqual", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.x)?
        }
        {
            new_op.add_edge(&self.y)?
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct GreaterEqual<T, x_Arg, y_Arg>
where T: TensorType,
      T: Clone,
      x_Arg: Clone,
      x_Arg: GraphEdge<T>,
      x_Arg: 'static,
      y_Arg: Clone,
      y_Arg: GraphEdge<T>,
      y_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    x: x_Arg,
    y: y_Arg,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<T, x_Arg, y_Arg> GreaterEqual<T, x_Arg, y_Arg>
where T: TensorType,
      T: Clone,
      x_Arg: Clone,
      x_Arg: GraphEdge<T>,
      x_Arg: 'static,
      y_Arg: Clone,
      y_Arg: GraphEdge<T>,
      y_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
{
    pub fn z(self) -> Edge<bool> {
        let rc = Rc::new(self);
        {
            Edge::<bool>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<bool> {
        let rc = Rc::new(self);
        {
            Edge::<bool>::new(rc.clone(), 0)
        }
    }

    pub fn build(x: x_Arg, y: y_Arg) -> Self {
        Self {
            phantom_T: PhantomData,
            x,
            y,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(x: x_Arg, y: y_Arg) -> Edge<bool> {
        Self {
            phantom_T: PhantomData,
            x,
            y,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<handle_Arg, indices_Arg, flow_in_Arg, dtype> GraphOperation for TensorArrayGatherV2<handle_Arg, indices_Arg, flow_in_Arg, dtype>
where handle_Arg: Clone,
      handle_Arg: GraphEdge<String>,
      handle_Arg: 'static,
      indices_Arg: Clone,
      indices_Arg: GraphEdge<i32>,
      indices_Arg: 'static,
      flow_in_Arg: Clone,
      flow_in_Arg: GraphEdge<f32>,
      flow_in_Arg: 'static,
      dtype: TensorType,
      dtype: 'static,
      dtype: Clone,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("TensorArrayGatherV2_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("TensorArrayGatherV2", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.handle)?
        }
        {
            new_op.add_edge(&self.indices)?
        }
        {
            new_op.add_edge(&self.flow_in)?
        }
        {
            new_op.set_attr_type("dtype", dtype::data_type())?;
        }
        {
            match self.element_shape {
                None => new_op.set_attr_value_proto("element_shape", &vec![58_u8, 0_u8,])?,
                Some(ref value) => (|attr| {new_op.set_attr_shape("element_shape", attr)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct TensorArrayGatherV2<handle_Arg, indices_Arg, flow_in_Arg, dtype>
where handle_Arg: Clone,
      handle_Arg: GraphEdge<String>,
      handle_Arg: 'static,
      indices_Arg: Clone,
      indices_Arg: GraphEdge<i32>,
      indices_Arg: 'static,
      flow_in_Arg: Clone,
      flow_in_Arg: GraphEdge<f32>,
      flow_in_Arg: 'static,
      dtype: TensorType,
      dtype: 'static,
      dtype: Clone,
{
    handle: handle_Arg,
    indices: indices_Arg,
    flow_in: flow_in_Arg,
    phantom_dtype: PhantomData<dtype>,
    element_shape: Option<OtherShape>,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<handle_Arg, indices_Arg, flow_in_Arg, dtype> TensorArrayGatherV2<handle_Arg, indices_Arg, flow_in_Arg, dtype>
where handle_Arg: Clone,
      handle_Arg: GraphEdge<String>,
      handle_Arg: 'static,
      indices_Arg: Clone,
      indices_Arg: GraphEdge<i32>,
      indices_Arg: 'static,
      flow_in_Arg: Clone,
      flow_in_Arg: GraphEdge<f32>,
      flow_in_Arg: 'static,
      dtype: TensorType,
      dtype: 'static,
      dtype: Clone,
{
    pub fn value(self) -> Edge<dtype> {
        let rc = Rc::new(self);
        {
            Edge::<dtype>::new(rc.clone(), 0)
        }
    }

    pub fn element_shape(&mut self, element_shape: &OtherShape) -> Self {
        self.element_shape = Some(element_shape.clone());
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<dtype> {
        let rc = Rc::new(self);
        {
            Edge::<dtype>::new(rc.clone(), 0)
        }
    }

    pub fn build(handle: handle_Arg, indices: indices_Arg, flow_in: flow_in_Arg) -> Self {
        Self {
            handle,
            indices,
            flow_in,
            phantom_dtype: PhantomData,
            element_shape: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(handle: handle_Arg, indices: indices_Arg, flow_in: flow_in_Arg) -> Edge<dtype> {
        Self {
            handle,
            indices,
            flow_in,
            phantom_dtype: PhantomData,
            element_shape: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

pub trait con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_STRING_or_DT_COMPLEX64_or_DT_INT64_or_DT_BOOL_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_STRING_or_DT_COMPLEX64_or_DT_INT64_or_DT_BOOL_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF for BFloat16 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_STRING_or_DT_COMPLEX64_or_DT_INT64_or_DT_BOOL_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF for OtherComplex<f32> {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_STRING_or_DT_COMPLEX64_or_DT_INT64_or_DT_BOOL_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF for OtherComplex<f64> {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_STRING_or_DT_COMPLEX64_or_DT_INT64_or_DT_BOOL_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF for String {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_STRING_or_DT_COMPLEX64_or_DT_INT64_or_DT_BOOL_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF for bool {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_STRING_or_DT_COMPLEX64_or_DT_INT64_or_DT_BOOL_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF for f32 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_STRING_or_DT_COMPLEX64_or_DT_INT64_or_DT_BOOL_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF for f64 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_STRING_or_DT_COMPLEX64_or_DT_INT64_or_DT_BOOL_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF for i16 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_STRING_or_DT_COMPLEX64_or_DT_INT64_or_DT_BOOL_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF for i32 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_STRING_or_DT_COMPLEX64_or_DT_INT64_or_DT_BOOL_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF for i64 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_STRING_or_DT_COMPLEX64_or_DT_INT64_or_DT_BOOL_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF for i8 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_STRING_or_DT_COMPLEX64_or_DT_INT64_or_DT_BOOL_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF for u8 {
}

impl<T, x_Arg, y_Arg> GraphOperation for Equal<T, x_Arg, y_Arg>
where T: TensorType,
      T: Clone,
      x_Arg: Clone,
      x_Arg: GraphEdge<T>,
      x_Arg: 'static,
      y_Arg: Clone,
      y_Arg: GraphEdge<T>,
      y_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_STRING_or_DT_COMPLEX64_or_DT_INT64_or_DT_BOOL_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF,
      T: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("Equal_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("Equal", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.x)?
        }
        {
            new_op.add_edge(&self.y)?
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct Equal<T, x_Arg, y_Arg>
where T: TensorType,
      T: Clone,
      x_Arg: Clone,
      x_Arg: GraphEdge<T>,
      x_Arg: 'static,
      y_Arg: Clone,
      y_Arg: GraphEdge<T>,
      y_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_STRING_or_DT_COMPLEX64_or_DT_INT64_or_DT_BOOL_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    x: x_Arg,
    y: y_Arg,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<T, x_Arg, y_Arg> Equal<T, x_Arg, y_Arg>
where T: TensorType,
      T: Clone,
      x_Arg: Clone,
      x_Arg: GraphEdge<T>,
      x_Arg: 'static,
      y_Arg: Clone,
      y_Arg: GraphEdge<T>,
      y_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_STRING_or_DT_COMPLEX64_or_DT_INT64_or_DT_BOOL_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF,
      T: 'static,
{
    pub fn z(self) -> Edge<bool> {
        let rc = Rc::new(self);
        {
            Edge::<bool>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<bool> {
        let rc = Rc::new(self);
        {
            Edge::<bool>::new(rc.clone(), 0)
        }
    }

    pub fn build(x: x_Arg, y: y_Arg) -> Self {
        Self {
            phantom_T: PhantomData,
            x,
            y,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(x: x_Arg, y: y_Arg) -> Edge<bool> {
        Self {
            phantom_T: PhantomData,
            x,
            y,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<T, x_Arg, y_Arg> GraphOperation for NotEqual<T, x_Arg, y_Arg>
where T: TensorType,
      T: Clone,
      x_Arg: Clone,
      x_Arg: GraphEdge<T>,
      x_Arg: 'static,
      y_Arg: Clone,
      y_Arg: GraphEdge<T>,
      y_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_STRING_or_DT_COMPLEX64_or_DT_INT64_or_DT_BOOL_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF,
      T: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("NotEqual_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("NotEqual", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.x)?
        }
        {
            new_op.add_edge(&self.y)?
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct NotEqual<T, x_Arg, y_Arg>
where T: TensorType,
      T: Clone,
      x_Arg: Clone,
      x_Arg: GraphEdge<T>,
      x_Arg: 'static,
      y_Arg: Clone,
      y_Arg: GraphEdge<T>,
      y_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_STRING_or_DT_COMPLEX64_or_DT_INT64_or_DT_BOOL_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    x: x_Arg,
    y: y_Arg,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<T, x_Arg, y_Arg> NotEqual<T, x_Arg, y_Arg>
where T: TensorType,
      T: Clone,
      x_Arg: Clone,
      x_Arg: GraphEdge<T>,
      x_Arg: 'static,
      y_Arg: Clone,
      y_Arg: GraphEdge<T>,
      y_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_STRING_or_DT_COMPLEX64_or_DT_INT64_or_DT_BOOL_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF,
      T: 'static,
{
    pub fn z(self) -> Edge<bool> {
        let rc = Rc::new(self);
        {
            Edge::<bool>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<bool> {
        let rc = Rc::new(self);
        {
            Edge::<bool>::new(rc.clone(), 0)
        }
    }

    pub fn build(x: x_Arg, y: y_Arg) -> Self {
        Self {
            phantom_T: PhantomData,
            x,
            y,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(x: x_Arg, y: y_Arg) -> Edge<bool> {
        Self {
            phantom_T: PhantomData,
            x,
            y,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<T, x_Arg, y_Arg> GraphOperation for ApproximateEqual<T, x_Arg, y_Arg>
where T: TensorType,
      T: Clone,
      x_Arg: Clone,
      x_Arg: GraphEdge<T>,
      x_Arg: 'static,
      y_Arg: Clone,
      y_Arg: GraphEdge<T>,
      y_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("ApproximateEqual_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("ApproximateEqual", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.x)?
        }
        {
            new_op.add_edge(&self.y)?
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        {
            match self.tolerance {
                None => new_op.set_attr_value_proto("tolerance", &vec![37_u8, 172_u8, 197_u8, 39_u8, 55_u8,])?,
                Some(ref value) => (|attr: &f32| {new_op.set_attr_float("tolerance", *attr)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct ApproximateEqual<T, x_Arg, y_Arg>
where T: TensorType,
      T: Clone,
      x_Arg: Clone,
      x_Arg: GraphEdge<T>,
      x_Arg: 'static,
      y_Arg: Clone,
      y_Arg: GraphEdge<T>,
      y_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    x: x_Arg,
    y: y_Arg,
    tolerance: Option<f32>,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<T, x_Arg, y_Arg> ApproximateEqual<T, x_Arg, y_Arg>
where T: TensorType,
      T: Clone,
      x_Arg: Clone,
      x_Arg: GraphEdge<T>,
      x_Arg: 'static,
      y_Arg: Clone,
      y_Arg: GraphEdge<T>,
      y_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
{
    pub fn z(self) -> Edge<bool> {
        let rc = Rc::new(self);
        {
            Edge::<bool>::new(rc.clone(), 0)
        }
    }

    pub fn tolerance(&mut self, tolerance: f32) -> Self {
        self.tolerance = Some(tolerance);
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<bool> {
        let rc = Rc::new(self);
        {
            Edge::<bool>::new(rc.clone(), 0)
        }
    }

    pub fn build(x: x_Arg, y: y_Arg) -> Self {
        Self {
            phantom_T: PhantomData,
            x,
            y,
            tolerance: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(x: x_Arg, y: y_Arg) -> Edge<bool> {
        Self {
            phantom_T: PhantomData,
            x,
            y,
            tolerance: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<T, a_Arg, b_Arg> GraphOperation for MatMul<T, a_Arg, b_Arg>
where T: TensorType,
      T: Clone,
      a_Arg: Clone,
      a_Arg: GraphEdge<T>,
      a_Arg: 'static,
      b_Arg: Clone,
      b_Arg: GraphEdge<T>,
      b_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_COMPLEX64_or_DT_INT64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF,
      T: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("MatMul_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("MatMul", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.a)?
        }
        {
            new_op.add_edge(&self.b)?
        }
        {
            match self.transpose_a {
                None => new_op.set_attr_value_proto("transpose_a", &vec![40_u8, 0_u8,])?,
                Some(ref value) => (|attr: &bool| {new_op.set_attr_bool("transpose_a", *attr)})(&value)?,
            };
        }
        {
            match self.transpose_b {
                None => new_op.set_attr_value_proto("transpose_b", &vec![40_u8, 0_u8,])?,
                Some(ref value) => (|attr: &bool| {new_op.set_attr_bool("transpose_b", *attr)})(&value)?,
            };
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct MatMul<T, a_Arg, b_Arg>
where T: TensorType,
      T: Clone,
      a_Arg: Clone,
      a_Arg: GraphEdge<T>,
      a_Arg: 'static,
      b_Arg: Clone,
      b_Arg: GraphEdge<T>,
      b_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_COMPLEX64_or_DT_INT64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    a: a_Arg,
    b: b_Arg,
    transpose_a: Option<bool>,
    transpose_b: Option<bool>,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<T, a_Arg, b_Arg> MatMul<T, a_Arg, b_Arg>
where T: TensorType,
      T: Clone,
      a_Arg: Clone,
      a_Arg: GraphEdge<T>,
      a_Arg: 'static,
      b_Arg: Clone,
      b_Arg: GraphEdge<T>,
      b_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_COMPLEX64_or_DT_INT64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF,
      T: 'static,
{
    pub fn product(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn transpose_a(&mut self, transpose_a: bool) -> Self {
        self.transpose_a = Some(transpose_a);
        self.clone()
    }

    pub fn transpose_b(&mut self, transpose_b: bool) -> Self {
        self.transpose_b = Some(transpose_b);
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(a: a_Arg, b: b_Arg) -> Self {
        Self {
            phantom_T: PhantomData,
            a,
            b,
            transpose_a: None,
            transpose_b: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(a: a_Arg, b: b_Arg) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            a,
            b,
            transpose_a: None,
            transpose_b: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<T, input_Arg, Tidx, reduction_indices_Arg> GraphOperation for Mean<T, input_Arg, Tidx, reduction_indices_Arg>
where T: TensorType,
      T: Clone,
      input_Arg: Clone,
      input_Arg: GraphEdge<T>,
      input_Arg: 'static,
      Tidx: TensorType,
      Tidx: Clone,
      reduction_indices_Arg: Clone,
      reduction_indices_Arg: GraphEdge<Tidx>,
      reduction_indices_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
      Tidx: con_or_DT_INT32_or_DT_INT64,
      Tidx: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("Mean_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("Mean", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.input)?
        }
        {
            new_op.add_edge(&self.reduction_indices)?
        }
        {
            match self.keep_dims {
                None => new_op.set_attr_value_proto("keep_dims", &vec![40_u8, 0_u8,])?,
                Some(ref value) => (|attr: &bool| {new_op.set_attr_bool("keep_dims", *attr)})(&value)?,
            };
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        {
            new_op.set_attr_type("Tidx", Tidx::data_type())?;
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct Mean<T, input_Arg, Tidx, reduction_indices_Arg>
where T: TensorType,
      T: Clone,
      input_Arg: Clone,
      input_Arg: GraphEdge<T>,
      input_Arg: 'static,
      Tidx: TensorType,
      Tidx: Clone,
      reduction_indices_Arg: Clone,
      reduction_indices_Arg: GraphEdge<Tidx>,
      reduction_indices_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
      Tidx: con_or_DT_INT32_or_DT_INT64,
      Tidx: 'static,
{
    phantom_T: PhantomData<T>,
    input: input_Arg,
    phantom_Tidx: PhantomData<Tidx>,
    reduction_indices: reduction_indices_Arg,
    keep_dims: Option<bool>,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<T, input_Arg, Tidx, reduction_indices_Arg> Mean<T, input_Arg, Tidx, reduction_indices_Arg>
where T: TensorType,
      T: Clone,
      input_Arg: Clone,
      input_Arg: GraphEdge<T>,
      input_Arg: 'static,
      Tidx: TensorType,
      Tidx: Clone,
      reduction_indices_Arg: Clone,
      reduction_indices_Arg: GraphEdge<Tidx>,
      reduction_indices_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
      Tidx: con_or_DT_INT32_or_DT_INT64,
      Tidx: 'static,
{
    pub fn output(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn keep_dims(&mut self, keep_dims: bool) -> Self {
        self.keep_dims = Some(keep_dims);
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(input: input_Arg, reduction_indices: reduction_indices_Arg) -> Self {
        Self {
            phantom_T: PhantomData,
            input,
            phantom_Tidx: PhantomData,
            reduction_indices,
            keep_dims: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(input: input_Arg, reduction_indices: reduction_indices_Arg) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            input,
            phantom_Tidx: PhantomData,
            reduction_indices,
            keep_dims: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<T, input_Arg, Tidx, dimension_Arg, output_type> GraphOperation for ArgMin<T, input_Arg, Tidx, dimension_Arg, output_type>
where T: TensorType,
      T: Clone,
      input_Arg: Clone,
      input_Arg: GraphEdge<T>,
      input_Arg: 'static,
      Tidx: TensorType,
      Tidx: Clone,
      dimension_Arg: Clone,
      dimension_Arg: GraphEdge<Tidx>,
      dimension_Arg: 'static,
      output_type: TensorType,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
      Tidx: con_or_DT_INT32_or_DT_INT64,
      Tidx: 'static,
      output_type: con_or_DT_INT32_or_DT_INT64,
      output_type: 'static,
      output_type: Clone,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("ArgMin_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("ArgMin", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.input)?
        }
        {
            new_op.add_edge(&self.dimension)?
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        {
            new_op.set_attr_type("Tidx", Tidx::data_type())?;
        }
        {
            new_op.set_attr_type("output_type", output_type::data_type())?;
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct ArgMin<T, input_Arg, Tidx, dimension_Arg, output_type>
where T: TensorType,
      T: Clone,
      input_Arg: Clone,
      input_Arg: GraphEdge<T>,
      input_Arg: 'static,
      Tidx: TensorType,
      Tidx: Clone,
      dimension_Arg: Clone,
      dimension_Arg: GraphEdge<Tidx>,
      dimension_Arg: 'static,
      output_type: TensorType,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
      Tidx: con_or_DT_INT32_or_DT_INT64,
      Tidx: 'static,
      output_type: con_or_DT_INT32_or_DT_INT64,
      output_type: 'static,
      output_type: Clone,
{
    phantom_T: PhantomData<T>,
    input: input_Arg,
    phantom_Tidx: PhantomData<Tidx>,
    dimension: dimension_Arg,
    phantom_output_type: PhantomData<output_type>,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<T, input_Arg, Tidx, dimension_Arg, output_type> ArgMin<T, input_Arg, Tidx, dimension_Arg, output_type>
where T: TensorType,
      T: Clone,
      input_Arg: Clone,
      input_Arg: GraphEdge<T>,
      input_Arg: 'static,
      Tidx: TensorType,
      Tidx: Clone,
      dimension_Arg: Clone,
      dimension_Arg: GraphEdge<Tidx>,
      dimension_Arg: 'static,
      output_type: TensorType,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
      Tidx: con_or_DT_INT32_or_DT_INT64,
      Tidx: 'static,
      output_type: con_or_DT_INT32_or_DT_INT64,
      output_type: 'static,
      output_type: Clone,
{
    pub fn output(self) -> Edge<output_type> {
        let rc = Rc::new(self);
        {
            Edge::<output_type>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<output_type> {
        let rc = Rc::new(self);
        {
            Edge::<output_type>::new(rc.clone(), 0)
        }
    }

    pub fn build(input: input_Arg, dimension: dimension_Arg) -> Self {
        Self {
            phantom_T: PhantomData,
            input,
            phantom_Tidx: PhantomData,
            dimension,
            phantom_output_type: PhantomData,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(input: input_Arg, dimension: dimension_Arg) -> Edge<output_type> {
        Self {
            phantom_T: PhantomData,
            input,
            phantom_Tidx: PhantomData,
            dimension,
            phantom_output_type: PhantomData,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<Tinput, input_Arg, input_min_Arg, input_max_Arg, requested_output_min_Arg, requested_output_max_Arg, out_type> GraphOperation for Requantize<Tinput, input_Arg, input_min_Arg, input_max_Arg, requested_output_min_Arg, requested_output_max_Arg, out_type>
where Tinput: TensorType,
      Tinput: Clone,
      input_Arg: Clone,
      input_Arg: GraphEdge<Tinput>,
      input_Arg: 'static,
      input_min_Arg: Clone,
      input_min_Arg: GraphEdge<f32>,
      input_min_Arg: 'static,
      input_max_Arg: Clone,
      input_max_Arg: GraphEdge<f32>,
      input_max_Arg: 'static,
      requested_output_min_Arg: Clone,
      requested_output_min_Arg: GraphEdge<f32>,
      requested_output_min_Arg: 'static,
      requested_output_max_Arg: Clone,
      requested_output_max_Arg: GraphEdge<f32>,
      requested_output_max_Arg: 'static,
      out_type: TensorType,
      Tinput: con_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_QINT16_or_DT_QUINT16,
      Tinput: 'static,
      out_type: con_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_QINT16_or_DT_QUINT16,
      out_type: 'static,
      out_type: Clone,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("Requantize_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("Requantize", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.input)?
        }
        {
            new_op.add_edge(&self.input_min)?
        }
        {
            new_op.add_edge(&self.input_max)?
        }
        {
            new_op.add_edge(&self.requested_output_min)?
        }
        {
            new_op.add_edge(&self.requested_output_max)?
        }
        {
            new_op.set_attr_type("Tinput", Tinput::data_type())?;
        }
        {
            new_op.set_attr_type("out_type", out_type::data_type())?;
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct Requantize<Tinput, input_Arg, input_min_Arg, input_max_Arg, requested_output_min_Arg, requested_output_max_Arg, out_type>
where Tinput: TensorType,
      Tinput: Clone,
      input_Arg: Clone,
      input_Arg: GraphEdge<Tinput>,
      input_Arg: 'static,
      input_min_Arg: Clone,
      input_min_Arg: GraphEdge<f32>,
      input_min_Arg: 'static,
      input_max_Arg: Clone,
      input_max_Arg: GraphEdge<f32>,
      input_max_Arg: 'static,
      requested_output_min_Arg: Clone,
      requested_output_min_Arg: GraphEdge<f32>,
      requested_output_min_Arg: 'static,
      requested_output_max_Arg: Clone,
      requested_output_max_Arg: GraphEdge<f32>,
      requested_output_max_Arg: 'static,
      out_type: TensorType,
      Tinput: con_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_QINT16_or_DT_QUINT16,
      Tinput: 'static,
      out_type: con_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_QINT16_or_DT_QUINT16,
      out_type: 'static,
      out_type: Clone,
{
    phantom_Tinput: PhantomData<Tinput>,
    input: input_Arg,
    input_min: input_min_Arg,
    input_max: input_max_Arg,
    requested_output_min: requested_output_min_Arg,
    requested_output_max: requested_output_max_Arg,
    phantom_out_type: PhantomData<out_type>,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<Tinput, input_Arg, input_min_Arg, input_max_Arg, requested_output_min_Arg, requested_output_max_Arg, out_type> Requantize<Tinput, input_Arg, input_min_Arg, input_max_Arg, requested_output_min_Arg, requested_output_max_Arg, out_type>
where Tinput: TensorType,
      Tinput: Clone,
      input_Arg: Clone,
      input_Arg: GraphEdge<Tinput>,
      input_Arg: 'static,
      input_min_Arg: Clone,
      input_min_Arg: GraphEdge<f32>,
      input_min_Arg: 'static,
      input_max_Arg: Clone,
      input_max_Arg: GraphEdge<f32>,
      input_max_Arg: 'static,
      requested_output_min_Arg: Clone,
      requested_output_min_Arg: GraphEdge<f32>,
      requested_output_min_Arg: 'static,
      requested_output_max_Arg: Clone,
      requested_output_max_Arg: GraphEdge<f32>,
      requested_output_max_Arg: 'static,
      out_type: TensorType,
      Tinput: con_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_QINT16_or_DT_QUINT16,
      Tinput: 'static,
      out_type: con_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_QINT16_or_DT_QUINT16,
      out_type: 'static,
      out_type: Clone,
{
    pub fn output(self) -> Edge<out_type> {
        let rc = Rc::new(self);
        {
            Edge::<out_type>::new(rc.clone(), 0)
        }
    }

    pub fn output_min(self) -> Edge<f32> {
        let rc = Rc::new(self);
        {
            Edge::<f32>::new(rc.clone(), 1)
        }
    }

    pub fn output_max(self) -> Edge<f32> {
        let rc = Rc::new(self);
        {
            Edge::<f32>::new(rc.clone(), 2)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> (Edge<out_type>, Edge<f32>, Edge<f32>) {
        let rc = Rc::new(self);
        (
        {
            Edge::<out_type>::new(rc.clone(), 0)
        },
        {
            Edge::<f32>::new(rc.clone(), 1)
        },
        {
            Edge::<f32>::new(rc.clone(), 2)
        },
        )
    }

    pub fn build(input: input_Arg, input_min: input_min_Arg, input_max: input_max_Arg, requested_output_min: requested_output_min_Arg, requested_output_max: requested_output_max_Arg) -> Self {
        Self {
            phantom_Tinput: PhantomData,
            input,
            input_min,
            input_max,
            requested_output_min,
            requested_output_max,
            phantom_out_type: PhantomData,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(input: input_Arg, input_min: input_min_Arg, input_max: input_max_Arg, requested_output_min: requested_output_min_Arg, requested_output_max: requested_output_max_Arg) -> (Edge<out_type>, Edge<f32>, Edge<f32>) {
        Self {
            phantom_Tinput: PhantomData,
            input,
            input_min,
            input_max,
            requested_output_min,
            requested_output_max,
            phantom_out_type: PhantomData,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<T, data_Arg, Tindices, segment_ids_Arg, Tnumsegments, num_segments_Arg> GraphOperation for UnsortedSegmentSum<T, data_Arg, Tindices, segment_ids_Arg, Tnumsegments, num_segments_Arg>
where T: TensorType,
      T: Clone,
      data_Arg: Clone,
      data_Arg: GraphEdge<T>,
      data_Arg: 'static,
      Tindices: TensorType,
      Tindices: Clone,
      segment_ids_Arg: Clone,
      segment_ids_Arg: GraphEdge<Tindices>,
      segment_ids_Arg: 'static,
      Tnumsegments: TensorType,
      Tnumsegments: Clone,
      num_segments_Arg: Clone,
      num_segments_Arg: GraphEdge<Tnumsegments>,
      num_segments_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
      Tindices: con_or_DT_INT32_or_DT_INT64,
      Tindices: 'static,
      Tnumsegments: con_or_DT_INT32_or_DT_INT64,
      Tnumsegments: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("UnsortedSegmentSum_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("UnsortedSegmentSum", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.data)?
        }
        {
            new_op.add_edge(&self.segment_ids)?
        }
        {
            new_op.add_edge(&self.num_segments)?
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        {
            new_op.set_attr_type("Tindices", Tindices::data_type())?;
        }
        {
            new_op.set_attr_type("Tnumsegments", Tnumsegments::data_type())?;
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct UnsortedSegmentSum<T, data_Arg, Tindices, segment_ids_Arg, Tnumsegments, num_segments_Arg>
where T: TensorType,
      T: Clone,
      data_Arg: Clone,
      data_Arg: GraphEdge<T>,
      data_Arg: 'static,
      Tindices: TensorType,
      Tindices: Clone,
      segment_ids_Arg: Clone,
      segment_ids_Arg: GraphEdge<Tindices>,
      segment_ids_Arg: 'static,
      Tnumsegments: TensorType,
      Tnumsegments: Clone,
      num_segments_Arg: Clone,
      num_segments_Arg: GraphEdge<Tnumsegments>,
      num_segments_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
      Tindices: con_or_DT_INT32_or_DT_INT64,
      Tindices: 'static,
      Tnumsegments: con_or_DT_INT32_or_DT_INT64,
      Tnumsegments: 'static,
{
    phantom_T: PhantomData<T>,
    data: data_Arg,
    phantom_Tindices: PhantomData<Tindices>,
    segment_ids: segment_ids_Arg,
    phantom_Tnumsegments: PhantomData<Tnumsegments>,
    num_segments: num_segments_Arg,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<T, data_Arg, Tindices, segment_ids_Arg, Tnumsegments, num_segments_Arg> UnsortedSegmentSum<T, data_Arg, Tindices, segment_ids_Arg, Tnumsegments, num_segments_Arg>
where T: TensorType,
      T: Clone,
      data_Arg: Clone,
      data_Arg: GraphEdge<T>,
      data_Arg: 'static,
      Tindices: TensorType,
      Tindices: Clone,
      segment_ids_Arg: Clone,
      segment_ids_Arg: GraphEdge<Tindices>,
      segment_ids_Arg: 'static,
      Tnumsegments: TensorType,
      Tnumsegments: Clone,
      num_segments_Arg: Clone,
      num_segments_Arg: GraphEdge<Tnumsegments>,
      num_segments_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
      Tindices: con_or_DT_INT32_or_DT_INT64,
      Tindices: 'static,
      Tnumsegments: con_or_DT_INT32_or_DT_INT64,
      Tnumsegments: 'static,
{
    pub fn output(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(data: data_Arg, segment_ids: segment_ids_Arg, num_segments: num_segments_Arg) -> Self {
        Self {
            phantom_T: PhantomData,
            data,
            phantom_Tindices: PhantomData,
            segment_ids,
            phantom_Tnumsegments: PhantomData,
            num_segments,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(data: data_Arg, segment_ids: segment_ids_Arg, num_segments: num_segments_Arg) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            data,
            phantom_Tindices: PhantomData,
            segment_ids,
            phantom_Tnumsegments: PhantomData,
            num_segments,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<T, data_Arg, Tindices, segment_ids_Arg, Tnumsegments, num_segments_Arg> GraphOperation for UnsortedSegmentMin<T, data_Arg, Tindices, segment_ids_Arg, Tnumsegments, num_segments_Arg>
where T: TensorType,
      T: Clone,
      data_Arg: Clone,
      data_Arg: GraphEdge<T>,
      data_Arg: 'static,
      Tindices: TensorType,
      Tindices: Clone,
      segment_ids_Arg: Clone,
      segment_ids_Arg: GraphEdge<Tindices>,
      segment_ids_Arg: 'static,
      Tnumsegments: TensorType,
      Tnumsegments: Clone,
      num_segments_Arg: Clone,
      num_segments_Arg: GraphEdge<Tnumsegments>,
      num_segments_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
      Tindices: con_or_DT_INT32_or_DT_INT64,
      Tindices: 'static,
      Tnumsegments: con_or_DT_INT32_or_DT_INT64,
      Tnumsegments: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("UnsortedSegmentMin_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("UnsortedSegmentMin", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.data)?
        }
        {
            new_op.add_edge(&self.segment_ids)?
        }
        {
            new_op.add_edge(&self.num_segments)?
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        {
            new_op.set_attr_type("Tindices", Tindices::data_type())?;
        }
        {
            new_op.set_attr_type("Tnumsegments", Tnumsegments::data_type())?;
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct UnsortedSegmentMin<T, data_Arg, Tindices, segment_ids_Arg, Tnumsegments, num_segments_Arg>
where T: TensorType,
      T: Clone,
      data_Arg: Clone,
      data_Arg: GraphEdge<T>,
      data_Arg: 'static,
      Tindices: TensorType,
      Tindices: Clone,
      segment_ids_Arg: Clone,
      segment_ids_Arg: GraphEdge<Tindices>,
      segment_ids_Arg: 'static,
      Tnumsegments: TensorType,
      Tnumsegments: Clone,
      num_segments_Arg: Clone,
      num_segments_Arg: GraphEdge<Tnumsegments>,
      num_segments_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
      Tindices: con_or_DT_INT32_or_DT_INT64,
      Tindices: 'static,
      Tnumsegments: con_or_DT_INT32_or_DT_INT64,
      Tnumsegments: 'static,
{
    phantom_T: PhantomData<T>,
    data: data_Arg,
    phantom_Tindices: PhantomData<Tindices>,
    segment_ids: segment_ids_Arg,
    phantom_Tnumsegments: PhantomData<Tnumsegments>,
    num_segments: num_segments_Arg,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<T, data_Arg, Tindices, segment_ids_Arg, Tnumsegments, num_segments_Arg> UnsortedSegmentMin<T, data_Arg, Tindices, segment_ids_Arg, Tnumsegments, num_segments_Arg>
where T: TensorType,
      T: Clone,
      data_Arg: Clone,
      data_Arg: GraphEdge<T>,
      data_Arg: 'static,
      Tindices: TensorType,
      Tindices: Clone,
      segment_ids_Arg: Clone,
      segment_ids_Arg: GraphEdge<Tindices>,
      segment_ids_Arg: 'static,
      Tnumsegments: TensorType,
      Tnumsegments: Clone,
      num_segments_Arg: Clone,
      num_segments_Arg: GraphEdge<Tnumsegments>,
      num_segments_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_BFLOAT16_or_DT_UINT16_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
      Tindices: con_or_DT_INT32_or_DT_INT64,
      Tindices: 'static,
      Tnumsegments: con_or_DT_INT32_or_DT_INT64,
      Tnumsegments: 'static,
{
    pub fn output(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(data: data_Arg, segment_ids: segment_ids_Arg, num_segments: num_segments_Arg) -> Self {
        Self {
            phantom_T: PhantomData,
            data,
            phantom_Tindices: PhantomData,
            segment_ids,
            phantom_Tnumsegments: PhantomData,
            num_segments,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(data: data_Arg, segment_ids: segment_ids_Arg, num_segments: num_segments_Arg) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            data,
            phantom_Tindices: PhantomData,
            segment_ids,
            phantom_Tnumsegments: PhantomData,
            num_segments,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<T, data_Arg, Tindices, segment_ids_Arg, Tnumsegments, num_segments_Arg> GraphOperation for UnsortedSegmentProd<T, data_Arg, Tindices, segment_ids_Arg, Tnumsegments, num_segments_Arg>
where T: TensorType,
      T: Clone,
      data_Arg: Clone,
      data_Arg: GraphEdge<T>,
      data_Arg: 'static,
      Tindices: TensorType,
      Tindices: Clone,
      segment_ids_Arg: Clone,
      segment_ids_Arg: GraphEdge<Tindices>,
      segment_ids_Arg: 'static,
      Tnumsegments: TensorType,
      Tnumsegments: Clone,
      num_segments_Arg: Clone,
      num_segments_Arg: GraphEdge<Tnumsegments>,
      num_segments_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
      Tindices: con_or_DT_INT32_or_DT_INT64,
      Tindices: 'static,
      Tnumsegments: con_or_DT_INT32_or_DT_INT64,
      Tnumsegments: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("UnsortedSegmentProd_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("UnsortedSegmentProd", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.data)?
        }
        {
            new_op.add_edge(&self.segment_ids)?
        }
        {
            new_op.add_edge(&self.num_segments)?
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        {
            new_op.set_attr_type("Tindices", Tindices::data_type())?;
        }
        {
            new_op.set_attr_type("Tnumsegments", Tnumsegments::data_type())?;
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct UnsortedSegmentProd<T, data_Arg, Tindices, segment_ids_Arg, Tnumsegments, num_segments_Arg>
where T: TensorType,
      T: Clone,
      data_Arg: Clone,
      data_Arg: GraphEdge<T>,
      data_Arg: 'static,
      Tindices: TensorType,
      Tindices: Clone,
      segment_ids_Arg: Clone,
      segment_ids_Arg: GraphEdge<Tindices>,
      segment_ids_Arg: 'static,
      Tnumsegments: TensorType,
      Tnumsegments: Clone,
      num_segments_Arg: Clone,
      num_segments_Arg: GraphEdge<Tnumsegments>,
      num_segments_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
      Tindices: con_or_DT_INT32_or_DT_INT64,
      Tindices: 'static,
      Tnumsegments: con_or_DT_INT32_or_DT_INT64,
      Tnumsegments: 'static,
{
    phantom_T: PhantomData<T>,
    data: data_Arg,
    phantom_Tindices: PhantomData<Tindices>,
    segment_ids: segment_ids_Arg,
    phantom_Tnumsegments: PhantomData<Tnumsegments>,
    num_segments: num_segments_Arg,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<T, data_Arg, Tindices, segment_ids_Arg, Tnumsegments, num_segments_Arg> UnsortedSegmentProd<T, data_Arg, Tindices, segment_ids_Arg, Tnumsegments, num_segments_Arg>
where T: TensorType,
      T: Clone,
      data_Arg: Clone,
      data_Arg: GraphEdge<T>,
      data_Arg: 'static,
      Tindices: TensorType,
      Tindices: Clone,
      segment_ids_Arg: Clone,
      segment_ids_Arg: GraphEdge<Tindices>,
      segment_ids_Arg: 'static,
      Tnumsegments: TensorType,
      Tnumsegments: Clone,
      num_segments_Arg: Clone,
      num_segments_Arg: GraphEdge<Tnumsegments>,
      num_segments_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
      Tindices: con_or_DT_INT32_or_DT_INT64,
      Tindices: 'static,
      Tnumsegments: con_or_DT_INT32_or_DT_INT64,
      Tnumsegments: 'static,
{
    pub fn output(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(data: data_Arg, segment_ids: segment_ids_Arg, num_segments: num_segments_Arg) -> Self {
        Self {
            phantom_T: PhantomData,
            data,
            phantom_Tindices: PhantomData,
            segment_ids,
            phantom_Tnumsegments: PhantomData,
            num_segments,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(data: data_Arg, segment_ids: segment_ids_Arg, num_segments: num_segments_Arg) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            data,
            phantom_Tindices: PhantomData,
            segment_ids,
            phantom_Tnumsegments: PhantomData,
            num_segments,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<num_layers_Arg, num_units_Arg, input_size_Arg, S, T> GraphOperation for CudnnRNNParamsSize<num_layers_Arg, num_units_Arg, input_size_Arg, S, T>
where num_layers_Arg: Clone,
      num_layers_Arg: GraphEdge<i32>,
      num_layers_Arg: 'static,
      num_units_Arg: Clone,
      num_units_Arg: GraphEdge<i32>,
      num_units_Arg: 'static,
      input_size_Arg: Clone,
      input_size_Arg: GraphEdge<i32>,
      input_size_Arg: 'static,
      S: TensorType,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_HALF,
      T: TensorType,
      T: 'static,
      T: Clone,
      S: con_or_DT_INT32_or_DT_INT64,
      S: 'static,
      S: Clone,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("CudnnRNNParamsSize_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("CudnnRNNParamsSize", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.num_layers)?
        }
        {
            new_op.add_edge(&self.num_units)?
        }
        {
            new_op.add_edge(&self.input_size)?
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        {
            new_op.set_attr_type("S", S::data_type())?;
        }
        {
            match self.rnn_mode {
                None => new_op.set_attr_value_proto("rnn_mode", &vec![18_u8, 4_u8, 108_u8, 115_u8, 116_u8, 109_u8,])?,
                Some(ref value) => (|attr| {new_op.set_attr_string("rnn_mode", attr)})(&value)?,
            };
        }
        {
            match self.input_mode {
                None => new_op.set_attr_value_proto("input_mode", &vec![18_u8, 12_u8, 108_u8, 105_u8, 110_u8, 101_u8, 97_u8, 114_u8, 95_u8, 105_u8, 110_u8, 112_u8, 117_u8, 116_u8,])?,
                Some(ref value) => (|attr| {new_op.set_attr_string("input_mode", attr)})(&value)?,
            };
        }
        {
            match self.direction {
                None => new_op.set_attr_value_proto("direction", &vec![18_u8, 14_u8, 117_u8, 110_u8, 105_u8, 100_u8, 105_u8, 114_u8, 101_u8, 99_u8, 116_u8, 105_u8, 111_u8, 110_u8, 97_u8, 108_u8,])?,
                Some(ref value) => (|attr| {new_op.set_attr_string("direction", attr)})(&value)?,
            };
        }
        {
            match self.dropout {
                None => new_op.set_attr_value_proto("dropout", &vec![37_u8, 0_u8, 0_u8, 0_u8, 0_u8,])?,
                Some(ref value) => (|attr: &f32| {new_op.set_attr_float("dropout", *attr)})(&value)?,
            };
        }
        {
            match self.seed {
                None => new_op.set_attr_value_proto("seed", &vec![24_u8, 0_u8,])?,
                Some(ref value) => (|attr: &i64| {new_op.set_attr_int("seed", *attr)})(&value)?,
            };
        }
        {
            match self.seed2 {
                None => new_op.set_attr_value_proto("seed2", &vec![24_u8, 0_u8,])?,
                Some(ref value) => (|attr: &i64| {new_op.set_attr_int("seed2", *attr)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct CudnnRNNParamsSize<num_layers_Arg, num_units_Arg, input_size_Arg, S, T>
where num_layers_Arg: Clone,
      num_layers_Arg: GraphEdge<i32>,
      num_layers_Arg: 'static,
      num_units_Arg: Clone,
      num_units_Arg: GraphEdge<i32>,
      num_units_Arg: 'static,
      input_size_Arg: Clone,
      input_size_Arg: GraphEdge<i32>,
      input_size_Arg: 'static,
      S: TensorType,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_HALF,
      T: TensorType,
      T: 'static,
      T: Clone,
      S: con_or_DT_INT32_or_DT_INT64,
      S: 'static,
      S: Clone,
{
    num_layers: num_layers_Arg,
    num_units: num_units_Arg,
    input_size: input_size_Arg,
    phantom_T: PhantomData<T>,
    phantom_S: PhantomData<S>,
    rnn_mode: Option<String>,
    input_mode: Option<String>,
    direction: Option<String>,
    dropout: Option<f32>,
    seed: Option<i64>,
    seed2: Option<i64>,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<num_layers_Arg, num_units_Arg, input_size_Arg, S, T> CudnnRNNParamsSize<num_layers_Arg, num_units_Arg, input_size_Arg, S, T>
where num_layers_Arg: Clone,
      num_layers_Arg: GraphEdge<i32>,
      num_layers_Arg: 'static,
      num_units_Arg: Clone,
      num_units_Arg: GraphEdge<i32>,
      num_units_Arg: 'static,
      input_size_Arg: Clone,
      input_size_Arg: GraphEdge<i32>,
      input_size_Arg: 'static,
      S: TensorType,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_HALF,
      T: TensorType,
      T: 'static,
      T: Clone,
      S: con_or_DT_INT32_or_DT_INT64,
      S: 'static,
      S: Clone,
{
    pub fn params_size(self) -> Edge<S> {
        let rc = Rc::new(self);
        {
            Edge::<S>::new(rc.clone(), 0)
        }
    }

    pub fn rnn_mode(&mut self, rnn_mode: &str) -> Self {
        self.rnn_mode = Some(rnn_mode.to_string());
        self.clone()
    }

    pub fn input_mode(&mut self, input_mode: &str) -> Self {
        self.input_mode = Some(input_mode.to_string());
        self.clone()
    }

    pub fn direction(&mut self, direction: &str) -> Self {
        self.direction = Some(direction.to_string());
        self.clone()
    }

    pub fn dropout(&mut self, dropout: f32) -> Self {
        self.dropout = Some(dropout);
        self.clone()
    }

    pub fn seed(&mut self, seed: i64) -> Self {
        self.seed = Some(seed);
        self.clone()
    }

    pub fn seed2(&mut self, seed2: i64) -> Self {
        self.seed2 = Some(seed2);
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<S> {
        let rc = Rc::new(self);
        {
            Edge::<S>::new(rc.clone(), 0)
        }
    }

    pub fn build(num_layers: num_layers_Arg, num_units: num_units_Arg, input_size: input_size_Arg) -> Self {
        Self {
            num_layers,
            num_units,
            input_size,
            phantom_T: PhantomData,
            phantom_S: PhantomData,
            rnn_mode: None,
            input_mode: None,
            direction: None,
            dropout: None,
            seed: None,
            seed2: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(num_layers: num_layers_Arg, num_units: num_units_Arg, input_size: input_size_Arg) -> Edge<S> {
        Self {
            num_layers,
            num_units,
            input_size,
            phantom_T: PhantomData,
            phantom_S: PhantomData,
            rnn_mode: None,
            input_mode: None,
            direction: None,
            dropout: None,
            seed: None,
            seed2: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<T, grad_Arg, Tidx, indices_Arg, segment_ids_Arg, output_dim0_Arg> GraphOperation for SparseSegmentMeanGrad<T, grad_Arg, Tidx, indices_Arg, segment_ids_Arg, output_dim0_Arg>
where T: TensorType,
      T: Clone,
      grad_Arg: Clone,
      grad_Arg: GraphEdge<T>,
      grad_Arg: 'static,
      Tidx: TensorType,
      Tidx: Clone,
      indices_Arg: Clone,
      indices_Arg: GraphEdge<Tidx>,
      indices_Arg: 'static,
      segment_ids_Arg: Clone,
      segment_ids_Arg: GraphEdge<i32>,
      segment_ids_Arg: 'static,
      output_dim0_Arg: Clone,
      output_dim0_Arg: GraphEdge<i32>,
      output_dim0_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE,
      T: 'static,
      Tidx: con_or_DT_INT32_or_DT_INT64,
      Tidx: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("SparseSegmentMeanGrad_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("SparseSegmentMeanGrad", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.grad)?
        }
        {
            new_op.add_edge(&self.indices)?
        }
        {
            new_op.add_edge(&self.segment_ids)?
        }
        {
            new_op.add_edge(&self.output_dim0)?
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        {
            new_op.set_attr_type("Tidx", Tidx::data_type())?;
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct SparseSegmentMeanGrad<T, grad_Arg, Tidx, indices_Arg, segment_ids_Arg, output_dim0_Arg>
where T: TensorType,
      T: Clone,
      grad_Arg: Clone,
      grad_Arg: GraphEdge<T>,
      grad_Arg: 'static,
      Tidx: TensorType,
      Tidx: Clone,
      indices_Arg: Clone,
      indices_Arg: GraphEdge<Tidx>,
      indices_Arg: 'static,
      segment_ids_Arg: Clone,
      segment_ids_Arg: GraphEdge<i32>,
      segment_ids_Arg: 'static,
      output_dim0_Arg: Clone,
      output_dim0_Arg: GraphEdge<i32>,
      output_dim0_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE,
      T: 'static,
      Tidx: con_or_DT_INT32_or_DT_INT64,
      Tidx: 'static,
{
    phantom_T: PhantomData<T>,
    grad: grad_Arg,
    phantom_Tidx: PhantomData<Tidx>,
    indices: indices_Arg,
    segment_ids: segment_ids_Arg,
    output_dim0: output_dim0_Arg,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<T, grad_Arg, Tidx, indices_Arg, segment_ids_Arg, output_dim0_Arg> SparseSegmentMeanGrad<T, grad_Arg, Tidx, indices_Arg, segment_ids_Arg, output_dim0_Arg>
where T: TensorType,
      T: Clone,
      grad_Arg: Clone,
      grad_Arg: GraphEdge<T>,
      grad_Arg: 'static,
      Tidx: TensorType,
      Tidx: Clone,
      indices_Arg: Clone,
      indices_Arg: GraphEdge<Tidx>,
      indices_Arg: 'static,
      segment_ids_Arg: Clone,
      segment_ids_Arg: GraphEdge<i32>,
      segment_ids_Arg: 'static,
      output_dim0_Arg: Clone,
      output_dim0_Arg: GraphEdge<i32>,
      output_dim0_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE,
      T: 'static,
      Tidx: con_or_DT_INT32_or_DT_INT64,
      Tidx: 'static,
{
    pub fn output(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(grad: grad_Arg, indices: indices_Arg, segment_ids: segment_ids_Arg, output_dim0: output_dim0_Arg) -> Self {
        Self {
            phantom_T: PhantomData,
            grad,
            phantom_Tidx: PhantomData,
            indices,
            segment_ids,
            output_dim0,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(grad: grad_Arg, indices: indices_Arg, segment_ids: segment_ids_Arg, output_dim0: output_dim0_Arg) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            grad,
            phantom_Tidx: PhantomData,
            indices,
            segment_ids,
            output_dim0,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<T, data_Arg, Tidx, indices_Arg, segment_ids_Arg> GraphOperation for SparseSegmentSqrtN<T, data_Arg, Tidx, indices_Arg, segment_ids_Arg>
where T: TensorType,
      T: Clone,
      data_Arg: Clone,
      data_Arg: GraphEdge<T>,
      data_Arg: 'static,
      Tidx: TensorType,
      Tidx: Clone,
      indices_Arg: Clone,
      indices_Arg: GraphEdge<Tidx>,
      indices_Arg: 'static,
      segment_ids_Arg: Clone,
      segment_ids_Arg: GraphEdge<i32>,
      segment_ids_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE,
      T: 'static,
      Tidx: con_or_DT_INT32_or_DT_INT64,
      Tidx: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("SparseSegmentSqrtN_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("SparseSegmentSqrtN", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.data)?
        }
        {
            new_op.add_edge(&self.indices)?
        }
        {
            new_op.add_edge(&self.segment_ids)?
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        {
            new_op.set_attr_type("Tidx", Tidx::data_type())?;
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct SparseSegmentSqrtN<T, data_Arg, Tidx, indices_Arg, segment_ids_Arg>
where T: TensorType,
      T: Clone,
      data_Arg: Clone,
      data_Arg: GraphEdge<T>,
      data_Arg: 'static,
      Tidx: TensorType,
      Tidx: Clone,
      indices_Arg: Clone,
      indices_Arg: GraphEdge<Tidx>,
      indices_Arg: 'static,
      segment_ids_Arg: Clone,
      segment_ids_Arg: GraphEdge<i32>,
      segment_ids_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE,
      T: 'static,
      Tidx: con_or_DT_INT32_or_DT_INT64,
      Tidx: 'static,
{
    phantom_T: PhantomData<T>,
    data: data_Arg,
    phantom_Tidx: PhantomData<Tidx>,
    indices: indices_Arg,
    segment_ids: segment_ids_Arg,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<T, data_Arg, Tidx, indices_Arg, segment_ids_Arg> SparseSegmentSqrtN<T, data_Arg, Tidx, indices_Arg, segment_ids_Arg>
where T: TensorType,
      T: Clone,
      data_Arg: Clone,
      data_Arg: GraphEdge<T>,
      data_Arg: 'static,
      Tidx: TensorType,
      Tidx: Clone,
      indices_Arg: Clone,
      indices_Arg: GraphEdge<Tidx>,
      indices_Arg: 'static,
      segment_ids_Arg: Clone,
      segment_ids_Arg: GraphEdge<i32>,
      segment_ids_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE,
      T: 'static,
      Tidx: con_or_DT_INT32_or_DT_INT64,
      Tidx: 'static,
{
    pub fn output(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(data: data_Arg, indices: indices_Arg, segment_ids: segment_ids_Arg) -> Self {
        Self {
            phantom_T: PhantomData,
            data,
            phantom_Tidx: PhantomData,
            indices,
            segment_ids,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(data: data_Arg, indices: indices_Arg, segment_ids: segment_ids_Arg) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            data,
            phantom_Tidx: PhantomData,
            indices,
            segment_ids,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<T, a_Arg, x_Arg> GraphOperation for Igammac<T, a_Arg, x_Arg>
where T: TensorType,
      T: Clone,
      a_Arg: Clone,
      a_Arg: GraphEdge<T>,
      a_Arg: 'static,
      x_Arg: Clone,
      x_Arg: GraphEdge<T>,
      x_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE,
      T: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("Igammac_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("Igammac", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.a)?
        }
        {
            new_op.add_edge(&self.x)?
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct Igammac<T, a_Arg, x_Arg>
where T: TensorType,
      T: Clone,
      a_Arg: Clone,
      a_Arg: GraphEdge<T>,
      a_Arg: 'static,
      x_Arg: Clone,
      x_Arg: GraphEdge<T>,
      x_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    a: a_Arg,
    x: x_Arg,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<T, a_Arg, x_Arg> Igammac<T, a_Arg, x_Arg>
where T: TensorType,
      T: Clone,
      a_Arg: Clone,
      a_Arg: GraphEdge<T>,
      a_Arg: 'static,
      x_Arg: Clone,
      x_Arg: GraphEdge<T>,
      x_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE,
      T: 'static,
{
    pub fn z(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(a: a_Arg, x: x_Arg) -> Self {
        Self {
            phantom_T: PhantomData,
            a,
            x,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(a: a_Arg, x: x_Arg) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            a,
            x,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<T, data_Arg, Tidx, indices_Arg, segment_ids_Arg, Tnumsegments, num_segments_Arg> GraphOperation for SparseSegmentSqrtNWithNumSegments<T, data_Arg, Tidx, indices_Arg, segment_ids_Arg, Tnumsegments, num_segments_Arg>
where T: TensorType,
      T: Clone,
      data_Arg: Clone,
      data_Arg: GraphEdge<T>,
      data_Arg: 'static,
      Tidx: TensorType,
      Tidx: Clone,
      indices_Arg: Clone,
      indices_Arg: GraphEdge<Tidx>,
      indices_Arg: 'static,
      segment_ids_Arg: Clone,
      segment_ids_Arg: GraphEdge<i32>,
      segment_ids_Arg: 'static,
      Tnumsegments: TensorType,
      Tnumsegments: Clone,
      num_segments_Arg: Clone,
      num_segments_Arg: GraphEdge<Tnumsegments>,
      num_segments_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE,
      T: 'static,
      Tidx: con_or_DT_INT32_or_DT_INT64,
      Tidx: 'static,
      Tnumsegments: con_or_DT_INT32_or_DT_INT64,
      Tnumsegments: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("SparseSegmentSqrtNWithNumSegments_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("SparseSegmentSqrtNWithNumSegments", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.data)?
        }
        {
            new_op.add_edge(&self.indices)?
        }
        {
            new_op.add_edge(&self.segment_ids)?
        }
        {
            new_op.add_edge(&self.num_segments)?
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        {
            new_op.set_attr_type("Tidx", Tidx::data_type())?;
        }
        {
            new_op.set_attr_type("Tnumsegments", Tnumsegments::data_type())?;
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct SparseSegmentSqrtNWithNumSegments<T, data_Arg, Tidx, indices_Arg, segment_ids_Arg, Tnumsegments, num_segments_Arg>
where T: TensorType,
      T: Clone,
      data_Arg: Clone,
      data_Arg: GraphEdge<T>,
      data_Arg: 'static,
      Tidx: TensorType,
      Tidx: Clone,
      indices_Arg: Clone,
      indices_Arg: GraphEdge<Tidx>,
      indices_Arg: 'static,
      segment_ids_Arg: Clone,
      segment_ids_Arg: GraphEdge<i32>,
      segment_ids_Arg: 'static,
      Tnumsegments: TensorType,
      Tnumsegments: Clone,
      num_segments_Arg: Clone,
      num_segments_Arg: GraphEdge<Tnumsegments>,
      num_segments_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE,
      T: 'static,
      Tidx: con_or_DT_INT32_or_DT_INT64,
      Tidx: 'static,
      Tnumsegments: con_or_DT_INT32_or_DT_INT64,
      Tnumsegments: 'static,
{
    phantom_T: PhantomData<T>,
    data: data_Arg,
    phantom_Tidx: PhantomData<Tidx>,
    indices: indices_Arg,
    segment_ids: segment_ids_Arg,
    phantom_Tnumsegments: PhantomData<Tnumsegments>,
    num_segments: num_segments_Arg,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<T, data_Arg, Tidx, indices_Arg, segment_ids_Arg, Tnumsegments, num_segments_Arg> SparseSegmentSqrtNWithNumSegments<T, data_Arg, Tidx, indices_Arg, segment_ids_Arg, Tnumsegments, num_segments_Arg>
where T: TensorType,
      T: Clone,
      data_Arg: Clone,
      data_Arg: GraphEdge<T>,
      data_Arg: 'static,
      Tidx: TensorType,
      Tidx: Clone,
      indices_Arg: Clone,
      indices_Arg: GraphEdge<Tidx>,
      indices_Arg: 'static,
      segment_ids_Arg: Clone,
      segment_ids_Arg: GraphEdge<i32>,
      segment_ids_Arg: 'static,
      Tnumsegments: TensorType,
      Tnumsegments: Clone,
      num_segments_Arg: Clone,
      num_segments_Arg: GraphEdge<Tnumsegments>,
      num_segments_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE,
      T: 'static,
      Tidx: con_or_DT_INT32_or_DT_INT64,
      Tidx: 'static,
      Tnumsegments: con_or_DT_INT32_or_DT_INT64,
      Tnumsegments: 'static,
{
    pub fn output(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(data: data_Arg, indices: indices_Arg, segment_ids: segment_ids_Arg, num_segments: num_segments_Arg) -> Self {
        Self {
            phantom_T: PhantomData,
            data,
            phantom_Tidx: PhantomData,
            indices,
            segment_ids,
            phantom_Tnumsegments: PhantomData,
            num_segments,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(data: data_Arg, indices: indices_Arg, segment_ids: segment_ids_Arg, num_segments: num_segments_Arg) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            data,
            phantom_Tidx: PhantomData,
            indices,
            segment_ids,
            phantom_Tnumsegments: PhantomData,
            num_segments,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<T, input_grads_Arg, input_image_Arg, output_image_Arg> GraphOperation for LRNGrad<T, input_grads_Arg, input_image_Arg, output_image_Arg>
where T: TensorType,
      T: Clone,
      input_grads_Arg: Clone,
      input_grads_Arg: GraphEdge<T>,
      input_grads_Arg: 'static,
      input_image_Arg: Clone,
      input_image_Arg: GraphEdge<T>,
      input_image_Arg: 'static,
      output_image_Arg: Clone,
      output_image_Arg: GraphEdge<T>,
      output_image_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_BFLOAT16_or_DT_HALF,
      T: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("LRNGrad_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("LRNGrad", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.input_grads)?
        }
        {
            new_op.add_edge(&self.input_image)?
        }
        {
            new_op.add_edge(&self.output_image)?
        }
        {
            match self.depth_radius {
                None => new_op.set_attr_value_proto("depth_radius", &vec![24_u8, 5_u8,])?,
                Some(ref value) => (|attr: &i64| {new_op.set_attr_int("depth_radius", *attr)})(&value)?,
            };
        }
        {
            match self.bias {
                None => new_op.set_attr_value_proto("bias", &vec![37_u8, 0_u8, 0_u8, 128_u8, 63_u8,])?,
                Some(ref value) => (|attr: &f32| {new_op.set_attr_float("bias", *attr)})(&value)?,
            };
        }
        {
            match self.alpha {
                None => new_op.set_attr_value_proto("alpha", &vec![37_u8, 0_u8, 0_u8, 128_u8, 63_u8,])?,
                Some(ref value) => (|attr: &f32| {new_op.set_attr_float("alpha", *attr)})(&value)?,
            };
        }
        {
            match self.beta {
                None => new_op.set_attr_value_proto("beta", &vec![37_u8, 0_u8, 0_u8, 0_u8, 63_u8,])?,
                Some(ref value) => (|attr: &f32| {new_op.set_attr_float("beta", *attr)})(&value)?,
            };
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct LRNGrad<T, input_grads_Arg, input_image_Arg, output_image_Arg>
where T: TensorType,
      T: Clone,
      input_grads_Arg: Clone,
      input_grads_Arg: GraphEdge<T>,
      input_grads_Arg: 'static,
      input_image_Arg: Clone,
      input_image_Arg: GraphEdge<T>,
      input_image_Arg: 'static,
      output_image_Arg: Clone,
      output_image_Arg: GraphEdge<T>,
      output_image_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_BFLOAT16_or_DT_HALF,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    input_grads: input_grads_Arg,
    input_image: input_image_Arg,
    output_image: output_image_Arg,
    depth_radius: Option<i64>,
    bias: Option<f32>,
    alpha: Option<f32>,
    beta: Option<f32>,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<T, input_grads_Arg, input_image_Arg, output_image_Arg> LRNGrad<T, input_grads_Arg, input_image_Arg, output_image_Arg>
where T: TensorType,
      T: Clone,
      input_grads_Arg: Clone,
      input_grads_Arg: GraphEdge<T>,
      input_grads_Arg: 'static,
      input_image_Arg: Clone,
      input_image_Arg: GraphEdge<T>,
      input_image_Arg: 'static,
      output_image_Arg: Clone,
      output_image_Arg: GraphEdge<T>,
      output_image_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_BFLOAT16_or_DT_HALF,
      T: 'static,
{
    pub fn output(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn depth_radius(&mut self, depth_radius: i64) -> Self {
        self.depth_radius = Some(depth_radius);
        self.clone()
    }

    pub fn bias(&mut self, bias: f32) -> Self {
        self.bias = Some(bias);
        self.clone()
    }

    pub fn alpha(&mut self, alpha: f32) -> Self {
        self.alpha = Some(alpha);
        self.clone()
    }

    pub fn beta(&mut self, beta: f32) -> Self {
        self.beta = Some(beta);
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(input_grads: input_grads_Arg, input_image: input_image_Arg, output_image: output_image_Arg) -> Self {
        Self {
            phantom_T: PhantomData,
            input_grads,
            input_image,
            output_image,
            depth_radius: None,
            bias: None,
            alpha: None,
            beta: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(input_grads: input_grads_Arg, input_image: input_image_Arg, output_image: output_image_Arg) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            input_grads,
            input_image,
            output_image,
            depth_radius: None,
            bias: None,
            alpha: None,
            beta: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<input_Arg, Tidx, reduction_indices_Arg> GraphOperation for Any<input_Arg, Tidx, reduction_indices_Arg>
where input_Arg: Clone,
      input_Arg: GraphEdge<bool>,
      input_Arg: 'static,
      Tidx: TensorType,
      Tidx: Clone,
      reduction_indices_Arg: Clone,
      reduction_indices_Arg: GraphEdge<Tidx>,
      reduction_indices_Arg: 'static,
      Tidx: con_or_DT_INT32_or_DT_INT64,
      Tidx: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("Any_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("Any", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.input)?
        }
        {
            new_op.add_edge(&self.reduction_indices)?
        }
        {
            match self.keep_dims {
                None => new_op.set_attr_value_proto("keep_dims", &vec![40_u8, 0_u8,])?,
                Some(ref value) => (|attr: &bool| {new_op.set_attr_bool("keep_dims", *attr)})(&value)?,
            };
        }
        {
            new_op.set_attr_type("Tidx", Tidx::data_type())?;
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct Any<input_Arg, Tidx, reduction_indices_Arg>
where input_Arg: Clone,
      input_Arg: GraphEdge<bool>,
      input_Arg: 'static,
      Tidx: TensorType,
      Tidx: Clone,
      reduction_indices_Arg: Clone,
      reduction_indices_Arg: GraphEdge<Tidx>,
      reduction_indices_Arg: 'static,
      Tidx: con_or_DT_INT32_or_DT_INT64,
      Tidx: 'static,
{
    input: input_Arg,
    phantom_Tidx: PhantomData<Tidx>,
    reduction_indices: reduction_indices_Arg,
    keep_dims: Option<bool>,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<input_Arg, Tidx, reduction_indices_Arg> Any<input_Arg, Tidx, reduction_indices_Arg>
where input_Arg: Clone,
      input_Arg: GraphEdge<bool>,
      input_Arg: 'static,
      Tidx: TensorType,
      Tidx: Clone,
      reduction_indices_Arg: Clone,
      reduction_indices_Arg: GraphEdge<Tidx>,
      reduction_indices_Arg: 'static,
      Tidx: con_or_DT_INT32_or_DT_INT64,
      Tidx: 'static,
{
    pub fn output(self) -> Edge<bool> {
        let rc = Rc::new(self);
        {
            Edge::<bool>::new(rc.clone(), 0)
        }
    }

    pub fn keep_dims(&mut self, keep_dims: bool) -> Self {
        self.keep_dims = Some(keep_dims);
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<bool> {
        let rc = Rc::new(self);
        {
            Edge::<bool>::new(rc.clone(), 0)
        }
    }

    pub fn build(input: input_Arg, reduction_indices: reduction_indices_Arg) -> Self {
        Self {
            input,
            phantom_Tidx: PhantomData,
            reduction_indices,
            keep_dims: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(input: input_Arg, reduction_indices: reduction_indices_Arg) -> Edge<bool> {
        Self {
            input,
            phantom_Tidx: PhantomData,
            reduction_indices,
            keep_dims: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<Tidx, start_Arg, limit_Arg, delta_Arg> GraphOperation for Range<Tidx, start_Arg, limit_Arg, delta_Arg>
where Tidx: TensorType,
      Tidx: Clone,
      start_Arg: Clone,
      start_Arg: GraphEdge<Tidx>,
      start_Arg: 'static,
      limit_Arg: Clone,
      limit_Arg: GraphEdge<Tidx>,
      limit_Arg: 'static,
      delta_Arg: Clone,
      delta_Arg: GraphEdge<Tidx>,
      delta_Arg: 'static,
      Tidx: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_INT64_or_DT_BFLOAT16,
      Tidx: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("Range_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("Range", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.start)?
        }
        {
            new_op.add_edge(&self.limit)?
        }
        {
            new_op.add_edge(&self.delta)?
        }
        {
            new_op.set_attr_type("Tidx", Tidx::data_type())?;
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct Range<Tidx, start_Arg, limit_Arg, delta_Arg>
where Tidx: TensorType,
      Tidx: Clone,
      start_Arg: Clone,
      start_Arg: GraphEdge<Tidx>,
      start_Arg: 'static,
      limit_Arg: Clone,
      limit_Arg: GraphEdge<Tidx>,
      limit_Arg: 'static,
      delta_Arg: Clone,
      delta_Arg: GraphEdge<Tidx>,
      delta_Arg: 'static,
      Tidx: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_INT64_or_DT_BFLOAT16,
      Tidx: 'static,
{
    phantom_Tidx: PhantomData<Tidx>,
    start: start_Arg,
    limit: limit_Arg,
    delta: delta_Arg,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<Tidx, start_Arg, limit_Arg, delta_Arg> Range<Tidx, start_Arg, limit_Arg, delta_Arg>
where Tidx: TensorType,
      Tidx: Clone,
      start_Arg: Clone,
      start_Arg: GraphEdge<Tidx>,
      start_Arg: 'static,
      limit_Arg: Clone,
      limit_Arg: GraphEdge<Tidx>,
      limit_Arg: 'static,
      delta_Arg: Clone,
      delta_Arg: GraphEdge<Tidx>,
      delta_Arg: 'static,
      Tidx: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_INT64_or_DT_BFLOAT16,
      Tidx: 'static,
{
    pub fn output(self) -> Edge<Tidx> {
        let rc = Rc::new(self);
        {
            Edge::<Tidx>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<Tidx> {
        let rc = Rc::new(self);
        {
            Edge::<Tidx>::new(rc.clone(), 0)
        }
    }

    pub fn build(start: start_Arg, limit: limit_Arg, delta: delta_Arg) -> Self {
        Self {
            phantom_Tidx: PhantomData,
            start,
            limit,
            delta,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(start: start_Arg, limit: limit_Arg, delta: delta_Arg) -> Edge<Tidx> {
        Self {
            phantom_Tidx: PhantomData,
            start,
            limit,
            delta,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

pub trait con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16 for BFloat16 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16 for f32 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16 for f64 {
}

impl<T, start_Arg, stop_Arg, Tidx, num_Arg> GraphOperation for LinSpace<T, start_Arg, stop_Arg, Tidx, num_Arg>
where T: TensorType,
      T: Clone,
      start_Arg: Clone,
      start_Arg: GraphEdge<T>,
      start_Arg: 'static,
      stop_Arg: Clone,
      stop_Arg: GraphEdge<T>,
      stop_Arg: 'static,
      Tidx: TensorType,
      Tidx: Clone,
      num_Arg: Clone,
      num_Arg: GraphEdge<Tidx>,
      num_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16,
      T: 'static,
      Tidx: con_or_DT_INT32_or_DT_INT64,
      Tidx: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("LinSpace_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("LinSpace", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.start)?
        }
        {
            new_op.add_edge(&self.stop)?
        }
        {
            new_op.add_edge(&self.num)?
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        {
            new_op.set_attr_type("Tidx", Tidx::data_type())?;
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct LinSpace<T, start_Arg, stop_Arg, Tidx, num_Arg>
where T: TensorType,
      T: Clone,
      start_Arg: Clone,
      start_Arg: GraphEdge<T>,
      start_Arg: 'static,
      stop_Arg: Clone,
      stop_Arg: GraphEdge<T>,
      stop_Arg: 'static,
      Tidx: TensorType,
      Tidx: Clone,
      num_Arg: Clone,
      num_Arg: GraphEdge<Tidx>,
      num_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16,
      T: 'static,
      Tidx: con_or_DT_INT32_or_DT_INT64,
      Tidx: 'static,
{
    phantom_T: PhantomData<T>,
    start: start_Arg,
    stop: stop_Arg,
    phantom_Tidx: PhantomData<Tidx>,
    num: num_Arg,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<T, start_Arg, stop_Arg, Tidx, num_Arg> LinSpace<T, start_Arg, stop_Arg, Tidx, num_Arg>
where T: TensorType,
      T: Clone,
      start_Arg: Clone,
      start_Arg: GraphEdge<T>,
      start_Arg: 'static,
      stop_Arg: Clone,
      stop_Arg: GraphEdge<T>,
      stop_Arg: 'static,
      Tidx: TensorType,
      Tidx: Clone,
      num_Arg: Clone,
      num_Arg: GraphEdge<Tidx>,
      num_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16,
      T: 'static,
      Tidx: con_or_DT_INT32_or_DT_INT64,
      Tidx: 'static,
{
    pub fn output(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(start: start_Arg, stop: stop_Arg, num: num_Arg) -> Self {
        Self {
            phantom_T: PhantomData,
            start,
            stop,
            phantom_Tidx: PhantomData,
            num,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(start: start_Arg, stop: stop_Arg, num: num_Arg) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            start,
            stop,
            phantom_Tidx: PhantomData,
            num,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<T, input_Arg, Tout> GraphOperation for Angle<T, input_Arg, Tout>
where T: TensorType,
      T: Clone,
      input_Arg: Clone,
      input_Arg: GraphEdge<T>,
      input_Arg: 'static,
      Tout: TensorType,
      T: con_or_DT_COMPLEX64_or_DT_COMPLEX128,
      T: 'static,
      Tout: con_or_DT_FLOAT_or_DT_DOUBLE,
      Tout: 'static,
      Tout: Clone,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("Angle_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("Angle", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.input)?
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        {
            new_op.set_attr_type("Tout", Tout::data_type())?;
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct Angle<T, input_Arg, Tout>
where T: TensorType,
      T: Clone,
      input_Arg: Clone,
      input_Arg: GraphEdge<T>,
      input_Arg: 'static,
      Tout: TensorType,
      T: con_or_DT_COMPLEX64_or_DT_COMPLEX128,
      T: 'static,
      Tout: con_or_DT_FLOAT_or_DT_DOUBLE,
      Tout: 'static,
      Tout: Clone,
{
    phantom_T: PhantomData<T>,
    input: input_Arg,
    phantom_Tout: PhantomData<Tout>,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<T, input_Arg, Tout> Angle<T, input_Arg, Tout>
where T: TensorType,
      T: Clone,
      input_Arg: Clone,
      input_Arg: GraphEdge<T>,
      input_Arg: 'static,
      Tout: TensorType,
      T: con_or_DT_COMPLEX64_or_DT_COMPLEX128,
      T: 'static,
      Tout: con_or_DT_FLOAT_or_DT_DOUBLE,
      Tout: 'static,
      Tout: Clone,
{
    pub fn output(self) -> Edge<Tout> {
        let rc = Rc::new(self);
        {
            Edge::<Tout>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<Tout> {
        let rc = Rc::new(self);
        {
            Edge::<Tout>::new(rc.clone(), 0)
        }
    }

    pub fn build(input: input_Arg) -> Self {
        Self {
            phantom_T: PhantomData,
            input,
            phantom_Tout: PhantomData,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(input: input_Arg) -> Edge<Tout> {
        Self {
            phantom_T: PhantomData,
            input,
            phantom_Tout: PhantomData,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<T, t_Arg, clip_value_min_Arg, clip_value_max_Arg> GraphOperation for ClipByValue<T, t_Arg, clip_value_min_Arg, clip_value_max_Arg>
where T: TensorType,
      T: Clone,
      t_Arg: Clone,
      t_Arg: GraphEdge<T>,
      t_Arg: 'static,
      clip_value_min_Arg: Clone,
      clip_value_min_Arg: GraphEdge<T>,
      clip_value_min_Arg: 'static,
      clip_value_max_Arg: Clone,
      clip_value_max_Arg: GraphEdge<T>,
      clip_value_max_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("ClipByValue_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("ClipByValue", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.t)?
        }
        {
            new_op.add_edge(&self.clip_value_min)?
        }
        {
            new_op.add_edge(&self.clip_value_max)?
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct ClipByValue<T, t_Arg, clip_value_min_Arg, clip_value_max_Arg>
where T: TensorType,
      T: Clone,
      t_Arg: Clone,
      t_Arg: GraphEdge<T>,
      t_Arg: 'static,
      clip_value_min_Arg: Clone,
      clip_value_min_Arg: GraphEdge<T>,
      clip_value_min_Arg: 'static,
      clip_value_max_Arg: Clone,
      clip_value_max_Arg: GraphEdge<T>,
      clip_value_max_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    t: t_Arg,
    clip_value_min: clip_value_min_Arg,
    clip_value_max: clip_value_max_Arg,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<T, t_Arg, clip_value_min_Arg, clip_value_max_Arg> ClipByValue<T, t_Arg, clip_value_min_Arg, clip_value_max_Arg>
where T: TensorType,
      T: Clone,
      t_Arg: Clone,
      t_Arg: GraphEdge<T>,
      t_Arg: 'static,
      clip_value_min_Arg: Clone,
      clip_value_min_Arg: GraphEdge<T>,
      clip_value_min_Arg: 'static,
      clip_value_max_Arg: Clone,
      clip_value_max_Arg: GraphEdge<T>,
      clip_value_max_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
{
    pub fn output(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(t: t_Arg, clip_value_min: clip_value_min_Arg, clip_value_max: clip_value_max_Arg) -> Self {
        Self {
            phantom_T: PhantomData,
            t,
            clip_value_min,
            clip_value_max,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(t: t_Arg, clip_value_min: clip_value_min_Arg, clip_value_max: clip_value_max_Arg) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            t,
            clip_value_min,
            clip_value_max,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<T, values_Arg, value_range_Arg, nbins_Arg, dtype> GraphOperation for HistogramFixedWidth<T, values_Arg, value_range_Arg, nbins_Arg, dtype>
where T: TensorType,
      T: Clone,
      values_Arg: Clone,
      values_Arg: GraphEdge<T>,
      values_Arg: 'static,
      value_range_Arg: Clone,
      value_range_Arg: GraphEdge<T>,
      value_range_Arg: 'static,
      nbins_Arg: Clone,
      nbins_Arg: GraphEdge<i32>,
      nbins_Arg: 'static,
      dtype: TensorType,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_INT64,
      T: 'static,
      dtype: con_or_DT_INT32_or_DT_INT64,
      dtype: 'static,
      dtype: Clone,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("HistogramFixedWidth_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("HistogramFixedWidth", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.values)?
        }
        {
            new_op.add_edge(&self.value_range)?
        }
        {
            new_op.add_edge(&self.nbins)?
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        {
            new_op.set_attr_type("dtype", dtype::data_type())?;
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct HistogramFixedWidth<T, values_Arg, value_range_Arg, nbins_Arg, dtype>
where T: TensorType,
      T: Clone,
      values_Arg: Clone,
      values_Arg: GraphEdge<T>,
      values_Arg: 'static,
      value_range_Arg: Clone,
      value_range_Arg: GraphEdge<T>,
      value_range_Arg: 'static,
      nbins_Arg: Clone,
      nbins_Arg: GraphEdge<i32>,
      nbins_Arg: 'static,
      dtype: TensorType,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_INT64,
      T: 'static,
      dtype: con_or_DT_INT32_or_DT_INT64,
      dtype: 'static,
      dtype: Clone,
{
    phantom_T: PhantomData<T>,
    values: values_Arg,
    value_range: value_range_Arg,
    nbins: nbins_Arg,
    phantom_dtype: PhantomData<dtype>,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<T, values_Arg, value_range_Arg, nbins_Arg, dtype> HistogramFixedWidth<T, values_Arg, value_range_Arg, nbins_Arg, dtype>
where T: TensorType,
      T: Clone,
      values_Arg: Clone,
      values_Arg: GraphEdge<T>,
      values_Arg: 'static,
      value_range_Arg: Clone,
      value_range_Arg: GraphEdge<T>,
      value_range_Arg: 'static,
      nbins_Arg: Clone,
      nbins_Arg: GraphEdge<i32>,
      nbins_Arg: 'static,
      dtype: TensorType,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_INT64,
      T: 'static,
      dtype: con_or_DT_INT32_or_DT_INT64,
      dtype: 'static,
      dtype: Clone,
{
    pub fn out(self) -> Edge<dtype> {
        let rc = Rc::new(self);
        {
            Edge::<dtype>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<dtype> {
        let rc = Rc::new(self);
        {
            Edge::<dtype>::new(rc.clone(), 0)
        }
    }

    pub fn build(values: values_Arg, value_range: value_range_Arg, nbins: nbins_Arg) -> Self {
        Self {
            phantom_T: PhantomData,
            values,
            value_range,
            nbins,
            phantom_dtype: PhantomData,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(values: values_Arg, value_range: value_range_Arg, nbins: nbins_Arg) -> Edge<dtype> {
        Self {
            phantom_T: PhantomData,
            values,
            value_range,
            nbins,
            phantom_dtype: PhantomData,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<arr_Arg, size_Arg, T, weights_Arg> GraphOperation for Bincount<arr_Arg, size_Arg, T, weights_Arg>
where arr_Arg: Clone,
      arr_Arg: GraphEdge<i32>,
      arr_Arg: 'static,
      size_Arg: Clone,
      size_Arg: GraphEdge<i32>,
      size_Arg: 'static,
      T: TensorType,
      T: Clone,
      weights_Arg: Clone,
      weights_Arg: GraphEdge<T>,
      weights_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_INT64,
      T: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("Bincount_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("Bincount", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.arr)?
        }
        {
            new_op.add_edge(&self.size)?
        }
        {
            new_op.add_edge(&self.weights)?
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct Bincount<arr_Arg, size_Arg, T, weights_Arg>
where arr_Arg: Clone,
      arr_Arg: GraphEdge<i32>,
      arr_Arg: 'static,
      size_Arg: Clone,
      size_Arg: GraphEdge<i32>,
      size_Arg: 'static,
      T: TensorType,
      T: Clone,
      weights_Arg: Clone,
      weights_Arg: GraphEdge<T>,
      weights_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_INT64,
      T: 'static,
{
    arr: arr_Arg,
    size: size_Arg,
    phantom_T: PhantomData<T>,
    weights: weights_Arg,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<arr_Arg, size_Arg, T, weights_Arg> Bincount<arr_Arg, size_Arg, T, weights_Arg>
where arr_Arg: Clone,
      arr_Arg: GraphEdge<i32>,
      arr_Arg: 'static,
      size_Arg: Clone,
      size_Arg: GraphEdge<i32>,
      size_Arg: 'static,
      T: TensorType,
      T: Clone,
      weights_Arg: Clone,
      weights_Arg: GraphEdge<T>,
      weights_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_INT64,
      T: 'static,
{
    pub fn bins(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(arr: arr_Arg, size: size_Arg, weights: weights_Arg) -> Self {
        Self {
            arr,
            size,
            phantom_T: PhantomData,
            weights,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(arr: arr_Arg, size: size_Arg, weights: weights_Arg) -> Edge<T> {
        Self {
            arr,
            size,
            phantom_T: PhantomData,
            weights,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<T1, x_Arg, T2, y_Arg, min_x_Arg, max_x_Arg, min_y_Arg, max_y_Arg, Toutput> GraphOperation for QuantizedMul<T1, x_Arg, T2, y_Arg, min_x_Arg, max_x_Arg, min_y_Arg, max_y_Arg, Toutput>
where T1: TensorType,
      T1: Clone,
      x_Arg: Clone,
      x_Arg: GraphEdge<T1>,
      x_Arg: 'static,
      T2: TensorType,
      T2: Clone,
      y_Arg: Clone,
      y_Arg: GraphEdge<T2>,
      y_Arg: 'static,
      min_x_Arg: Clone,
      min_x_Arg: GraphEdge<f32>,
      min_x_Arg: 'static,
      max_x_Arg: Clone,
      max_x_Arg: GraphEdge<f32>,
      max_x_Arg: 'static,
      min_y_Arg: Clone,
      min_y_Arg: GraphEdge<f32>,
      min_y_Arg: 'static,
      max_y_Arg: Clone,
      max_y_Arg: GraphEdge<f32>,
      max_y_Arg: 'static,
      Toutput: TensorType,
      T1: con_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_QINT16_or_DT_QUINT16,
      T1: 'static,
      T2: con_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_QINT16_or_DT_QUINT16,
      T2: 'static,
      Toutput: con_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_QINT16_or_DT_QUINT16,
      Toutput: 'static,
      Toutput: Clone,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("QuantizedMul_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("QuantizedMul", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.x)?
        }
        {
            new_op.add_edge(&self.y)?
        }
        {
            new_op.add_edge(&self.min_x)?
        }
        {
            new_op.add_edge(&self.max_x)?
        }
        {
            new_op.add_edge(&self.min_y)?
        }
        {
            new_op.add_edge(&self.max_y)?
        }
        {
            new_op.set_attr_type("T1", T1::data_type())?;
        }
        {
            new_op.set_attr_type("T2", T2::data_type())?;
        }
        {
            new_op.set_attr_type("Toutput", Toutput::data_type())?;
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct QuantizedMul<T1, x_Arg, T2, y_Arg, min_x_Arg, max_x_Arg, min_y_Arg, max_y_Arg, Toutput>
where T1: TensorType,
      T1: Clone,
      x_Arg: Clone,
      x_Arg: GraphEdge<T1>,
      x_Arg: 'static,
      T2: TensorType,
      T2: Clone,
      y_Arg: Clone,
      y_Arg: GraphEdge<T2>,
      y_Arg: 'static,
      min_x_Arg: Clone,
      min_x_Arg: GraphEdge<f32>,
      min_x_Arg: 'static,
      max_x_Arg: Clone,
      max_x_Arg: GraphEdge<f32>,
      max_x_Arg: 'static,
      min_y_Arg: Clone,
      min_y_Arg: GraphEdge<f32>,
      min_y_Arg: 'static,
      max_y_Arg: Clone,
      max_y_Arg: GraphEdge<f32>,
      max_y_Arg: 'static,
      Toutput: TensorType,
      T1: con_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_QINT16_or_DT_QUINT16,
      T1: 'static,
      T2: con_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_QINT16_or_DT_QUINT16,
      T2: 'static,
      Toutput: con_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_QINT16_or_DT_QUINT16,
      Toutput: 'static,
      Toutput: Clone,
{
    phantom_T1: PhantomData<T1>,
    x: x_Arg,
    phantom_T2: PhantomData<T2>,
    y: y_Arg,
    min_x: min_x_Arg,
    max_x: max_x_Arg,
    min_y: min_y_Arg,
    max_y: max_y_Arg,
    phantom_Toutput: PhantomData<Toutput>,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<T1, x_Arg, T2, y_Arg, min_x_Arg, max_x_Arg, min_y_Arg, max_y_Arg, Toutput> QuantizedMul<T1, x_Arg, T2, y_Arg, min_x_Arg, max_x_Arg, min_y_Arg, max_y_Arg, Toutput>
where T1: TensorType,
      T1: Clone,
      x_Arg: Clone,
      x_Arg: GraphEdge<T1>,
      x_Arg: 'static,
      T2: TensorType,
      T2: Clone,
      y_Arg: Clone,
      y_Arg: GraphEdge<T2>,
      y_Arg: 'static,
      min_x_Arg: Clone,
      min_x_Arg: GraphEdge<f32>,
      min_x_Arg: 'static,
      max_x_Arg: Clone,
      max_x_Arg: GraphEdge<f32>,
      max_x_Arg: 'static,
      min_y_Arg: Clone,
      min_y_Arg: GraphEdge<f32>,
      min_y_Arg: 'static,
      max_y_Arg: Clone,
      max_y_Arg: GraphEdge<f32>,
      max_y_Arg: 'static,
      Toutput: TensorType,
      T1: con_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_QINT16_or_DT_QUINT16,
      T1: 'static,
      T2: con_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_QINT16_or_DT_QUINT16,
      T2: 'static,
      Toutput: con_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_QINT16_or_DT_QUINT16,
      Toutput: 'static,
      Toutput: Clone,
{
    pub fn z(self) -> Edge<Toutput> {
        let rc = Rc::new(self);
        {
            Edge::<Toutput>::new(rc.clone(), 0)
        }
    }

    pub fn min_z(self) -> Edge<f32> {
        let rc = Rc::new(self);
        {
            Edge::<f32>::new(rc.clone(), 1)
        }
    }

    pub fn max_z(self) -> Edge<f32> {
        let rc = Rc::new(self);
        {
            Edge::<f32>::new(rc.clone(), 2)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> (Edge<Toutput>, Edge<f32>, Edge<f32>) {
        let rc = Rc::new(self);
        (
        {
            Edge::<Toutput>::new(rc.clone(), 0)
        },
        {
            Edge::<f32>::new(rc.clone(), 1)
        },
        {
            Edge::<f32>::new(rc.clone(), 2)
        },
        )
    }

    pub fn build(x: x_Arg, y: y_Arg, min_x: min_x_Arg, max_x: max_x_Arg, min_y: min_y_Arg, max_y: max_y_Arg) -> Self {
        Self {
            phantom_T1: PhantomData,
            x,
            phantom_T2: PhantomData,
            y,
            min_x,
            max_x,
            min_y,
            max_y,
            phantom_Toutput: PhantomData,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(x: x_Arg, y: y_Arg, min_x: min_x_Arg, max_x: max_x_Arg, min_y: min_y_Arg, max_y: max_y_Arg) -> (Edge<Toutput>, Edge<f32>, Edge<f32>) {
        Self {
            phantom_T1: PhantomData,
            x,
            phantom_T2: PhantomData,
            y,
            min_x,
            max_x,
            min_y,
            max_y,
            phantom_Toutput: PhantomData,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<Tinput, input_Arg, input_min_Arg, input_max_Arg> GraphOperation for RequantizationRange<Tinput, input_Arg, input_min_Arg, input_max_Arg>
where Tinput: TensorType,
      Tinput: Clone,
      input_Arg: Clone,
      input_Arg: GraphEdge<Tinput>,
      input_Arg: 'static,
      input_min_Arg: Clone,
      input_min_Arg: GraphEdge<f32>,
      input_min_Arg: 'static,
      input_max_Arg: Clone,
      input_max_Arg: GraphEdge<f32>,
      input_max_Arg: 'static,
      Tinput: con_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_QINT16_or_DT_QUINT16,
      Tinput: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("RequantizationRange_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("RequantizationRange", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.input)?
        }
        {
            new_op.add_edge(&self.input_min)?
        }
        {
            new_op.add_edge(&self.input_max)?
        }
        {
            new_op.set_attr_type("Tinput", Tinput::data_type())?;
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct RequantizationRange<Tinput, input_Arg, input_min_Arg, input_max_Arg>
where Tinput: TensorType,
      Tinput: Clone,
      input_Arg: Clone,
      input_Arg: GraphEdge<Tinput>,
      input_Arg: 'static,
      input_min_Arg: Clone,
      input_min_Arg: GraphEdge<f32>,
      input_min_Arg: 'static,
      input_max_Arg: Clone,
      input_max_Arg: GraphEdge<f32>,
      input_max_Arg: 'static,
      Tinput: con_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_QINT16_or_DT_QUINT16,
      Tinput: 'static,
{
    phantom_Tinput: PhantomData<Tinput>,
    input: input_Arg,
    input_min: input_min_Arg,
    input_max: input_max_Arg,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<Tinput, input_Arg, input_min_Arg, input_max_Arg> RequantizationRange<Tinput, input_Arg, input_min_Arg, input_max_Arg>
where Tinput: TensorType,
      Tinput: Clone,
      input_Arg: Clone,
      input_Arg: GraphEdge<Tinput>,
      input_Arg: 'static,
      input_min_Arg: Clone,
      input_min_Arg: GraphEdge<f32>,
      input_min_Arg: 'static,
      input_max_Arg: Clone,
      input_max_Arg: GraphEdge<f32>,
      input_max_Arg: 'static,
      Tinput: con_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_QINT16_or_DT_QUINT16,
      Tinput: 'static,
{
    pub fn output_min(self) -> Edge<f32> {
        let rc = Rc::new(self);
        {
            Edge::<f32>::new(rc.clone(), 0)
        }
    }

    pub fn output_max(self) -> Edge<f32> {
        let rc = Rc::new(self);
        {
            Edge::<f32>::new(rc.clone(), 1)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> (Edge<f32>, Edge<f32>) {
        let rc = Rc::new(self);
        (
        {
            Edge::<f32>::new(rc.clone(), 0)
        },
        {
            Edge::<f32>::new(rc.clone(), 1)
        },
        )
    }

    pub fn build(input: input_Arg, input_min: input_min_Arg, input_max: input_max_Arg) -> Self {
        Self {
            phantom_Tinput: PhantomData,
            input,
            input_min,
            input_max,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(input: input_Arg, input_min: input_min_Arg, input_max: input_max_Arg) -> (Edge<f32>, Edge<f32>) {
        Self {
            phantom_Tinput: PhantomData,
            input,
            input_min,
            input_max,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<input_Arg, pattern_Arg, rewrite_Arg> GraphOperation for RegexReplace<input_Arg, pattern_Arg, rewrite_Arg>
where input_Arg: Clone,
      input_Arg: GraphEdge<String>,
      input_Arg: 'static,
      pattern_Arg: Clone,
      pattern_Arg: GraphEdge<String>,
      pattern_Arg: 'static,
      rewrite_Arg: Clone,
      rewrite_Arg: GraphEdge<String>,
      rewrite_Arg: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("RegexReplace_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("RegexReplace", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.input)?
        }
        {
            new_op.add_edge(&self.pattern)?
        }
        {
            new_op.add_edge(&self.rewrite)?
        }
        {
            match self.replace_global {
                None => new_op.set_attr_value_proto("replace_global", &vec![40_u8, 1_u8,])?,
                Some(ref value) => (|attr: &bool| {new_op.set_attr_bool("replace_global", *attr)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct RegexReplace<input_Arg, pattern_Arg, rewrite_Arg>
where input_Arg: Clone,
      input_Arg: GraphEdge<String>,
      input_Arg: 'static,
      pattern_Arg: Clone,
      pattern_Arg: GraphEdge<String>,
      pattern_Arg: 'static,
      rewrite_Arg: Clone,
      rewrite_Arg: GraphEdge<String>,
      rewrite_Arg: 'static,
{
    input: input_Arg,
    pattern: pattern_Arg,
    rewrite: rewrite_Arg,
    replace_global: Option<bool>,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<input_Arg, pattern_Arg, rewrite_Arg> RegexReplace<input_Arg, pattern_Arg, rewrite_Arg>
where input_Arg: Clone,
      input_Arg: GraphEdge<String>,
      input_Arg: 'static,
      pattern_Arg: Clone,
      pattern_Arg: GraphEdge<String>,
      pattern_Arg: 'static,
      rewrite_Arg: Clone,
      rewrite_Arg: GraphEdge<String>,
      rewrite_Arg: 'static,
{
    pub fn output(self) -> Edge<String> {
        let rc = Rc::new(self);
        {
            Edge::<String>::new(rc.clone(), 0)
        }
    }

    pub fn replace_global(&mut self, replace_global: bool) -> Self {
        self.replace_global = Some(replace_global);
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<String> {
        let rc = Rc::new(self);
        {
            Edge::<String>::new(rc.clone(), 0)
        }
    }

    pub fn build(input: input_Arg, pattern: pattern_Arg, rewrite: rewrite_Arg) -> Self {
        Self {
            input,
            pattern,
            rewrite,
            replace_global: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(input: input_Arg, pattern: pattern_Arg, rewrite: rewrite_Arg) -> Edge<String> {
        Self {
            input,
            pattern,
            rewrite,
            replace_global: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<T, input_Arg> GraphOperation for NcclAllReduce<T, input_Arg>
where T: TensorType,
      T: Clone,
      input_Arg: Clone,
      input_Arg: GraphEdge<T>,
      input_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_INT64_or_DT_HALF,
      T: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("NcclAllReduce_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("NcclAllReduce", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.input)?
        }
        {
            (|attr| {new_op.set_attr_string("reduction", attr)})(&self.reduction)?
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        {
            (|attr: &i64| {new_op.set_attr_int("num_devices", *attr)})(&self.num_devices)?
        }
        {
            (|attr| {new_op.set_attr_string("shared_name", attr)})(&self.shared_name)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct NcclAllReduce<T, input_Arg>
where T: TensorType,
      T: Clone,
      input_Arg: Clone,
      input_Arg: GraphEdge<T>,
      input_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_INT64_or_DT_HALF,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    input: input_Arg,
    reduction: String,
    num_devices: i64,
    shared_name: String,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<T, input_Arg> NcclAllReduce<T, input_Arg>
where T: TensorType,
      T: Clone,
      input_Arg: Clone,
      input_Arg: GraphEdge<T>,
      input_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_INT64_or_DT_HALF,
      T: 'static,
{
    pub fn data(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(input: input_Arg, reduction: &str, num_devices: i64, shared_name: &str) -> Self {
        Self {
            phantom_T: PhantomData,
            input,
            reduction: reduction.to_string(),
            num_devices: num_devices,
            shared_name: shared_name.to_string(),
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(input: input_Arg, reduction: &str, num_devices: i64, shared_name: &str) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            input,
            reduction: reduction.to_string(),
            num_devices: num_devices,
            shared_name: shared_name.to_string(),
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<handle_Arg> GraphOperation for QueueSize<handle_Arg>
where handle_Arg: Clone,
      handle_Arg: GraphRefEdge<String>,
      handle_Arg: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("QueueSize_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("QueueSize", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.handle)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct QueueSize<handle_Arg>
where handle_Arg: Clone,
      handle_Arg: GraphRefEdge<String>,
      handle_Arg: 'static,
{
    handle: handle_Arg,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<handle_Arg> QueueSize<handle_Arg>
where handle_Arg: Clone,
      handle_Arg: GraphRefEdge<String>,
      handle_Arg: 'static,
{
    pub fn size(self) -> Edge<i32> {
        let rc = Rc::new(self);
        {
            Edge::<i32>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<i32> {
        let rc = Rc::new(self);
        {
            Edge::<i32>::new(rc.clone(), 0)
        }
    }

    pub fn build(handle: handle_Arg) -> Self {
        Self {
            handle,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(handle: handle_Arg) -> Edge<i32> {
        Self {
            handle,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<T, out_backprop_Arg> GraphOperation for BiasAddGrad<T, out_backprop_Arg>
where T: TensorType,
      T: Clone,
      out_backprop_Arg: Clone,
      out_backprop_Arg: GraphEdge<T>,
      out_backprop_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("BiasAddGrad_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("BiasAddGrad", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.out_backprop)?
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        {
            match self.data_format {
                None => new_op.set_attr_value_proto("data_format", &vec![18_u8, 4_u8, 78_u8, 72_u8, 87_u8, 67_u8,])?,
                Some(ref value) => (|attr| {new_op.set_attr_string("data_format", attr)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct BiasAddGrad<T, out_backprop_Arg>
where T: TensorType,
      T: Clone,
      out_backprop_Arg: Clone,
      out_backprop_Arg: GraphEdge<T>,
      out_backprop_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    out_backprop: out_backprop_Arg,
    data_format: Option<String>,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<T, out_backprop_Arg> BiasAddGrad<T, out_backprop_Arg>
where T: TensorType,
      T: Clone,
      out_backprop_Arg: Clone,
      out_backprop_Arg: GraphEdge<T>,
      out_backprop_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
{
    pub fn output(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn data_format(&mut self, data_format: &str) -> Self {
        self.data_format = Some(data_format.to_string());
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(out_backprop: out_backprop_Arg) -> Self {
        Self {
            phantom_T: PhantomData,
            out_backprop,
            data_format: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(out_backprop: out_backprop_Arg) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            out_backprop,
            data_format: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<T, input_Arg> GraphOperation for NcclReduce<T, input_Arg>
where T: TensorType,
      T: Clone,
      input_Arg: Clone,
      input_Arg: GraphEdge<T>,
      input_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_INT64_or_DT_HALF,
      T: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("NcclReduce_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("NcclReduce", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.input)?
        }
        {
            (|attr| {new_op.set_attr_string("reduction", attr)})(&self.reduction)?
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        {
            (|attr: &i64| {new_op.set_attr_int("num_devices", *attr)})(&self.num_devices)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct NcclReduce<T, input_Arg>
where T: TensorType,
      T: Clone,
      input_Arg: Clone,
      input_Arg: GraphEdge<T>,
      input_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_INT64_or_DT_HALF,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    input: input_Arg,
    reduction: String,
    num_devices: i64,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<T, input_Arg> NcclReduce<T, input_Arg>
where T: TensorType,
      T: Clone,
      input_Arg: Clone,
      input_Arg: GraphEdge<T>,
      input_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_INT64_or_DT_HALF,
      T: 'static,
{
    pub fn data(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(input: input_Arg, reduction: &str, num_devices: i64) -> Self {
        Self {
            phantom_T: PhantomData,
            input,
            reduction: reduction.to_string(),
            num_devices: num_devices,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(input: input_Arg, reduction: &str, num_devices: i64) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            input,
            reduction: reduction.to_string(),
            num_devices: num_devices,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<T, input_Arg> GraphOperation for _NcclReduceSend<T, input_Arg>
where T: TensorType,
      T: Clone,
      input_Arg: Clone,
      input_Arg: GraphEdge<T>,
      input_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_INT64_or_DT_HALF,
      T: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("_NcclReduceSend_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("_NcclReduceSend", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.input)?
        }
        {
            (|attr| {new_op.set_attr_string("reduction", attr)})(&self.reduction)?
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        {
            (|attr: &i64| {new_op.set_attr_int("num_devices", *attr)})(&self.num_devices)?
        }
        {
            (|attr| {new_op.set_attr_string("shared_name", attr)})(&self.shared_name)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct _NcclReduceSend<T, input_Arg>
where T: TensorType,
      T: Clone,
      input_Arg: Clone,
      input_Arg: GraphEdge<T>,
      input_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_INT64_or_DT_HALF,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    input: input_Arg,
    reduction: String,
    num_devices: i64,
    shared_name: String,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<T, input_Arg> _NcclReduceSend<T, input_Arg>
where T: TensorType,
      T: Clone,
      input_Arg: Clone,
      input_Arg: GraphEdge<T>,
      input_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_INT64_or_DT_HALF,
      T: 'static,
{
    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> () {
        let rc = Rc::new(self);
        (
        )
    }

    pub fn build(input: input_Arg, reduction: &str, num_devices: i64, shared_name: &str) -> Self {
        Self {
            phantom_T: PhantomData,
            input,
            reduction: reduction.to_string(),
            num_devices: num_devices,
            shared_name: shared_name.to_string(),
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(input: input_Arg, reduction: &str, num_devices: i64, shared_name: &str) -> () {
        Self {
            phantom_T: PhantomData,
            input,
            reduction: reduction.to_string(),
            num_devices: num_devices,
            shared_name: shared_name.to_string(),
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<weights_Arg> GraphOperation for SdcaShrinkL1<weights_Arg>
where weights_Arg: Clone,
      weights_Arg: GraphRefEdge<f32>,
      weights_Arg: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("SdcaShrinkL1_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("SdcaShrinkL1", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.weights)?
        }
        {
            (|attr: &i64| {new_op.set_attr_int("num_features", *attr)})(&self.num_features)?
        }
        {
            (|attr: &f32| {new_op.set_attr_float("l1", *attr)})(&self.l1)?
        }
        {
            (|attr: &f32| {new_op.set_attr_float("l2", *attr)})(&self.l2)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct SdcaShrinkL1<weights_Arg>
where weights_Arg: Clone,
      weights_Arg: GraphRefEdge<f32>,
      weights_Arg: 'static,
{
    weights: weights_Arg,
    num_features: i64,
    l1: f32,
    l2: f32,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<weights_Arg> SdcaShrinkL1<weights_Arg>
where weights_Arg: Clone,
      weights_Arg: GraphRefEdge<f32>,
      weights_Arg: 'static,
{
    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> () {
        let rc = Rc::new(self);
        (
        )
    }

    pub fn build(weights: weights_Arg, num_features: i64, l1: f32, l2: f32) -> Self {
        Self {
            weights,
            num_features: num_features,
            l1: l1,
            l2: l2,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(weights: weights_Arg, num_features: i64, l1: f32, l2: f32) -> () {
        Self {
            weights,
            num_features: num_features,
            l1: l1,
            l2: l2,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<T, x_Arg, y_Arg> GraphOperation for BitwiseAnd<T, x_Arg, y_Arg>
where T: TensorType,
      T: Clone,
      x_Arg: Clone,
      x_Arg: GraphEdge<T>,
      x_Arg: 'static,
      y_Arg: Clone,
      y_Arg: GraphEdge<T>,
      y_Arg: 'static,
      T: con_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_UINT16_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("BitwiseAnd_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("BitwiseAnd", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.x)?
        }
        {
            new_op.add_edge(&self.y)?
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct BitwiseAnd<T, x_Arg, y_Arg>
where T: TensorType,
      T: Clone,
      x_Arg: Clone,
      x_Arg: GraphEdge<T>,
      x_Arg: 'static,
      y_Arg: Clone,
      y_Arg: GraphEdge<T>,
      y_Arg: 'static,
      T: con_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_UINT16_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    x: x_Arg,
    y: y_Arg,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<T, x_Arg, y_Arg> BitwiseAnd<T, x_Arg, y_Arg>
where T: TensorType,
      T: Clone,
      x_Arg: Clone,
      x_Arg: GraphEdge<T>,
      x_Arg: 'static,
      y_Arg: Clone,
      y_Arg: GraphEdge<T>,
      y_Arg: 'static,
      T: con_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_INT64_or_DT_UINT16_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
{
    pub fn z(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(x: x_Arg, y: y_Arg) -> Self {
        Self {
            phantom_T: PhantomData,
            x,
            y,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(x: x_Arg, y: y_Arg) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            x,
            y,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<T, input_Arg> GraphOperation for _NcclReduceRecv<T, input_Arg>
where T: TensorType,
      T: Clone,
      input_Arg: Clone,
      input_Arg: GraphEdge<T>,
      input_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_INT64_or_DT_HALF,
      T: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("_NcclReduceRecv_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("_NcclReduceRecv", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.input)?
        }
        {
            (|attr| {new_op.set_attr_string("reduction", attr)})(&self.reduction)?
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        {
            (|attr: &i64| {new_op.set_attr_int("num_devices", *attr)})(&self.num_devices)?
        }
        {
            (|attr| {new_op.set_attr_string("shared_name", attr)})(&self.shared_name)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct _NcclReduceRecv<T, input_Arg>
where T: TensorType,
      T: Clone,
      input_Arg: Clone,
      input_Arg: GraphEdge<T>,
      input_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_INT64_or_DT_HALF,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    input: input_Arg,
    reduction: String,
    num_devices: i64,
    shared_name: String,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<T, input_Arg> _NcclReduceRecv<T, input_Arg>
where T: TensorType,
      T: Clone,
      input_Arg: Clone,
      input_Arg: GraphEdge<T>,
      input_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_INT64_or_DT_HALF,
      T: 'static,
{
    pub fn data(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(input: input_Arg, reduction: &str, num_devices: i64, shared_name: &str) -> Self {
        Self {
            phantom_T: PhantomData,
            input,
            reduction: reduction.to_string(),
            num_devices: num_devices,
            shared_name: shared_name.to_string(),
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(input: input_Arg, reduction: &str, num_devices: i64, shared_name: &str) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            input,
            reduction: reduction.to_string(),
            num_devices: num_devices,
            shared_name: shared_name.to_string(),
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<T, input_Arg> GraphOperation for _NcclBroadcastSend<T, input_Arg>
where T: TensorType,
      T: Clone,
      input_Arg: Clone,
      input_Arg: GraphEdge<T>,
      input_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_INT64_or_DT_HALF,
      T: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("_NcclBroadcastSend_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("_NcclBroadcastSend", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.input)?
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        {
            (|attr: &i64| {new_op.set_attr_int("num_devices", *attr)})(&self.num_devices)?
        }
        {
            (|attr| {new_op.set_attr_string("shared_name", attr)})(&self.shared_name)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct _NcclBroadcastSend<T, input_Arg>
where T: TensorType,
      T: Clone,
      input_Arg: Clone,
      input_Arg: GraphEdge<T>,
      input_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_INT64_or_DT_HALF,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    input: input_Arg,
    num_devices: i64,
    shared_name: String,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<T, input_Arg> _NcclBroadcastSend<T, input_Arg>
where T: TensorType,
      T: Clone,
      input_Arg: Clone,
      input_Arg: GraphEdge<T>,
      input_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_INT64_or_DT_HALF,
      T: 'static,
{
    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> () {
        let rc = Rc::new(self);
        (
        )
    }

    pub fn build(input: input_Arg, num_devices: i64, shared_name: &str) -> Self {
        Self {
            phantom_T: PhantomData,
            input,
            num_devices: num_devices,
            shared_name: shared_name.to_string(),
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(input: input_Arg, num_devices: i64, shared_name: &str) -> () {
        Self {
            phantom_T: PhantomData,
            input,
            num_devices: num_devices,
            shared_name: shared_name.to_string(),
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<shape_Arg, T> GraphOperation for _NcclBroadcastRecv<shape_Arg, T>
where shape_Arg: Clone,
      shape_Arg: GraphEdge<i32>,
      shape_Arg: 'static,
      T: TensorType,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_INT64_or_DT_HALF,
      T: 'static,
      T: Clone,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("_NcclBroadcastRecv_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("_NcclBroadcastRecv", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.shape)?
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        {
            (|attr: &i64| {new_op.set_attr_int("num_devices", *attr)})(&self.num_devices)?
        }
        {
            (|attr| {new_op.set_attr_string("shared_name", attr)})(&self.shared_name)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct _NcclBroadcastRecv<shape_Arg, T>
where shape_Arg: Clone,
      shape_Arg: GraphEdge<i32>,
      shape_Arg: 'static,
      T: TensorType,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_INT64_or_DT_HALF,
      T: 'static,
      T: Clone,
{
    shape: shape_Arg,
    phantom_T: PhantomData<T>,
    num_devices: i64,
    shared_name: String,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<shape_Arg, T> _NcclBroadcastRecv<shape_Arg, T>
where shape_Arg: Clone,
      shape_Arg: GraphEdge<i32>,
      shape_Arg: 'static,
      T: TensorType,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_INT64_or_DT_HALF,
      T: 'static,
      T: Clone,
{
    pub fn output(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(shape: shape_Arg, num_devices: i64, shared_name: &str) -> Self {
        Self {
            shape,
            phantom_T: PhantomData,
            num_devices: num_devices,
            shared_name: shared_name.to_string(),
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(shape: shape_Arg, num_devices: i64, shared_name: &str) -> Edge<T> {
        Self {
            shape,
            phantom_T: PhantomData,
            num_devices: num_devices,
            shared_name: shared_name.to_string(),
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl GraphOperation for ControlTrigger {
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("ControlTrigger_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("ControlTrigger", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct ControlTrigger {
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl ControlTrigger {
    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> () {
        let rc = Rc::new(self);
        (
        )
    }

    pub fn build() -> Self {
        Self {
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new() -> () {
        Self {
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<handle_Arg, index_Arg, flow_in_Arg, dtype> GraphOperation for TensorArrayReadV2<handle_Arg, index_Arg, flow_in_Arg, dtype>
where handle_Arg: Clone,
      handle_Arg: GraphEdge<String>,
      handle_Arg: 'static,
      index_Arg: Clone,
      index_Arg: GraphEdge<i32>,
      index_Arg: 'static,
      flow_in_Arg: Clone,
      flow_in_Arg: GraphEdge<f32>,
      flow_in_Arg: 'static,
      dtype: TensorType,
      dtype: 'static,
      dtype: Clone,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("TensorArrayReadV2_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("TensorArrayReadV2", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.handle)?
        }
        {
            new_op.add_edge(&self.index)?
        }
        {
            new_op.add_edge(&self.flow_in)?
        }
        {
            new_op.set_attr_type("dtype", dtype::data_type())?;
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct TensorArrayReadV2<handle_Arg, index_Arg, flow_in_Arg, dtype>
where handle_Arg: Clone,
      handle_Arg: GraphEdge<String>,
      handle_Arg: 'static,
      index_Arg: Clone,
      index_Arg: GraphEdge<i32>,
      index_Arg: 'static,
      flow_in_Arg: Clone,
      flow_in_Arg: GraphEdge<f32>,
      flow_in_Arg: 'static,
      dtype: TensorType,
      dtype: 'static,
      dtype: Clone,
{
    handle: handle_Arg,
    index: index_Arg,
    flow_in: flow_in_Arg,
    phantom_dtype: PhantomData<dtype>,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<handle_Arg, index_Arg, flow_in_Arg, dtype> TensorArrayReadV2<handle_Arg, index_Arg, flow_in_Arg, dtype>
where handle_Arg: Clone,
      handle_Arg: GraphEdge<String>,
      handle_Arg: 'static,
      index_Arg: Clone,
      index_Arg: GraphEdge<i32>,
      index_Arg: 'static,
      flow_in_Arg: Clone,
      flow_in_Arg: GraphEdge<f32>,
      flow_in_Arg: 'static,
      dtype: TensorType,
      dtype: 'static,
      dtype: Clone,
{
    pub fn value(self) -> Edge<dtype> {
        let rc = Rc::new(self);
        {
            Edge::<dtype>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<dtype> {
        let rc = Rc::new(self);
        {
            Edge::<dtype>::new(rc.clone(), 0)
        }
    }

    pub fn build(handle: handle_Arg, index: index_Arg, flow_in: flow_in_Arg) -> Self {
        Self {
            handle,
            index,
            flow_in,
            phantom_dtype: PhantomData,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(handle: handle_Arg, index: index_Arg, flow_in: flow_in_Arg) -> Edge<dtype> {
        Self {
            handle,
            index,
            flow_in,
            phantom_dtype: PhantomData,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<T, t_Arg, m_Arg, v_Arg, beta_Arg, gamma_Arg> GraphOperation for BatchNormWithGlobalNormalization<T, t_Arg, m_Arg, v_Arg, beta_Arg, gamma_Arg>
where T: TensorType,
      T: Clone,
      t_Arg: Clone,
      t_Arg: GraphEdge<T>,
      t_Arg: 'static,
      m_Arg: Clone,
      m_Arg: GraphEdge<T>,
      m_Arg: 'static,
      v_Arg: Clone,
      v_Arg: GraphEdge<T>,
      v_Arg: 'static,
      beta_Arg: Clone,
      beta_Arg: GraphEdge<T>,
      beta_Arg: 'static,
      gamma_Arg: Clone,
      gamma_Arg: GraphEdge<T>,
      gamma_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("BatchNormWithGlobalNormalization_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("BatchNormWithGlobalNormalization", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.t)?
        }
        {
            new_op.add_edge(&self.m)?
        }
        {
            new_op.add_edge(&self.v)?
        }
        {
            new_op.add_edge(&self.beta)?
        }
        {
            new_op.add_edge(&self.gamma)?
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        {
            (|attr: &f32| {new_op.set_attr_float("variance_epsilon", *attr)})(&self.variance_epsilon)?
        }
        {
            (|attr: &bool| {new_op.set_attr_bool("scale_after_normalization", *attr)})(&self.scale_after_normalization)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct BatchNormWithGlobalNormalization<T, t_Arg, m_Arg, v_Arg, beta_Arg, gamma_Arg>
where T: TensorType,
      T: Clone,
      t_Arg: Clone,
      t_Arg: GraphEdge<T>,
      t_Arg: 'static,
      m_Arg: Clone,
      m_Arg: GraphEdge<T>,
      m_Arg: 'static,
      v_Arg: Clone,
      v_Arg: GraphEdge<T>,
      v_Arg: 'static,
      beta_Arg: Clone,
      beta_Arg: GraphEdge<T>,
      beta_Arg: 'static,
      gamma_Arg: Clone,
      gamma_Arg: GraphEdge<T>,
      gamma_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    t: t_Arg,
    m: m_Arg,
    v: v_Arg,
    beta: beta_Arg,
    gamma: gamma_Arg,
    variance_epsilon: f32,
    scale_after_normalization: bool,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<T, t_Arg, m_Arg, v_Arg, beta_Arg, gamma_Arg> BatchNormWithGlobalNormalization<T, t_Arg, m_Arg, v_Arg, beta_Arg, gamma_Arg>
where T: TensorType,
      T: Clone,
      t_Arg: Clone,
      t_Arg: GraphEdge<T>,
      t_Arg: 'static,
      m_Arg: Clone,
      m_Arg: GraphEdge<T>,
      m_Arg: 'static,
      v_Arg: Clone,
      v_Arg: GraphEdge<T>,
      v_Arg: 'static,
      beta_Arg: Clone,
      beta_Arg: GraphEdge<T>,
      beta_Arg: 'static,
      gamma_Arg: Clone,
      gamma_Arg: GraphEdge<T>,
      gamma_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
{
    pub fn result(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(t: t_Arg, m: m_Arg, v: v_Arg, beta: beta_Arg, gamma: gamma_Arg, variance_epsilon: f32, scale_after_normalization: bool) -> Self {
        Self {
            phantom_T: PhantomData,
            t,
            m,
            v,
            beta,
            gamma,
            variance_epsilon: variance_epsilon,
            scale_after_normalization: scale_after_normalization,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(t: t_Arg, m: m_Arg, v: v_Arg, beta: beta_Arg, gamma: gamma_Arg, variance_epsilon: f32, scale_after_normalization: bool) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            t,
            m,
            v,
            beta,
            gamma,
            variance_epsilon: variance_epsilon,
            scale_after_normalization: scale_after_normalization,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<T, x_Arg, scale_Arg, offset_Arg, mean_Arg, variance_Arg> GraphOperation for FusedBatchNorm<T, x_Arg, scale_Arg, offset_Arg, mean_Arg, variance_Arg>
where T: TensorType,
      T: Clone,
      x_Arg: Clone,
      x_Arg: GraphEdge<T>,
      x_Arg: 'static,
      scale_Arg: Clone,
      scale_Arg: GraphEdge<T>,
      scale_Arg: 'static,
      offset_Arg: Clone,
      offset_Arg: GraphEdge<T>,
      offset_Arg: 'static,
      mean_Arg: Clone,
      mean_Arg: GraphEdge<T>,
      mean_Arg: 'static,
      variance_Arg: Clone,
      variance_Arg: GraphEdge<T>,
      variance_Arg: 'static,
      T: con_or_DT_FLOAT,
      T: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("FusedBatchNorm_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("FusedBatchNorm", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.x)?
        }
        {
            new_op.add_edge(&self.scale)?
        }
        {
            new_op.add_edge(&self.offset)?
        }
        {
            new_op.add_edge(&self.mean)?
        }
        {
            new_op.add_edge(&self.variance)?
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        {
            match self.epsilon {
                None => new_op.set_attr_value_proto("epsilon", &vec![37_u8, 23_u8, 183_u8, 209_u8, 56_u8,])?,
                Some(ref value) => (|attr: &f32| {new_op.set_attr_float("epsilon", *attr)})(&value)?,
            };
        }
        {
            match self.data_format {
                None => new_op.set_attr_value_proto("data_format", &vec![18_u8, 4_u8, 78_u8, 72_u8, 87_u8, 67_u8,])?,
                Some(ref value) => (|attr| {new_op.set_attr_string("data_format", attr)})(&value)?,
            };
        }
        {
            match self.is_training {
                None => new_op.set_attr_value_proto("is_training", &vec![40_u8, 1_u8,])?,
                Some(ref value) => (|attr: &bool| {new_op.set_attr_bool("is_training", *attr)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct FusedBatchNorm<T, x_Arg, scale_Arg, offset_Arg, mean_Arg, variance_Arg>
where T: TensorType,
      T: Clone,
      x_Arg: Clone,
      x_Arg: GraphEdge<T>,
      x_Arg: 'static,
      scale_Arg: Clone,
      scale_Arg: GraphEdge<T>,
      scale_Arg: 'static,
      offset_Arg: Clone,
      offset_Arg: GraphEdge<T>,
      offset_Arg: 'static,
      mean_Arg: Clone,
      mean_Arg: GraphEdge<T>,
      mean_Arg: 'static,
      variance_Arg: Clone,
      variance_Arg: GraphEdge<T>,
      variance_Arg: 'static,
      T: con_or_DT_FLOAT,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    x: x_Arg,
    scale: scale_Arg,
    offset: offset_Arg,
    mean: mean_Arg,
    variance: variance_Arg,
    epsilon: Option<f32>,
    data_format: Option<String>,
    is_training: Option<bool>,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<T, x_Arg, scale_Arg, offset_Arg, mean_Arg, variance_Arg> FusedBatchNorm<T, x_Arg, scale_Arg, offset_Arg, mean_Arg, variance_Arg>
where T: TensorType,
      T: Clone,
      x_Arg: Clone,
      x_Arg: GraphEdge<T>,
      x_Arg: 'static,
      scale_Arg: Clone,
      scale_Arg: GraphEdge<T>,
      scale_Arg: 'static,
      offset_Arg: Clone,
      offset_Arg: GraphEdge<T>,
      offset_Arg: 'static,
      mean_Arg: Clone,
      mean_Arg: GraphEdge<T>,
      mean_Arg: 'static,
      variance_Arg: Clone,
      variance_Arg: GraphEdge<T>,
      variance_Arg: 'static,
      T: con_or_DT_FLOAT,
      T: 'static,
{
    pub fn y(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn batch_mean(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 1)
        }
    }

    pub fn batch_variance(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 2)
        }
    }

    pub fn reserve_space_1(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 3)
        }
    }

    pub fn reserve_space_2(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 4)
        }
    }

    pub fn epsilon(&mut self, epsilon: f32) -> Self {
        self.epsilon = Some(epsilon);
        self.clone()
    }

    pub fn data_format(&mut self, data_format: &str) -> Self {
        self.data_format = Some(data_format.to_string());
        self.clone()
    }

    pub fn is_training(&mut self, is_training: bool) -> Self {
        self.is_training = Some(is_training);
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> (Edge<T>, Edge<T>, Edge<T>, Edge<T>, Edge<T>) {
        let rc = Rc::new(self);
        (
        {
            Edge::<T>::new(rc.clone(), 0)
        },
        {
            Edge::<T>::new(rc.clone(), 1)
        },
        {
            Edge::<T>::new(rc.clone(), 2)
        },
        {
            Edge::<T>::new(rc.clone(), 3)
        },
        {
            Edge::<T>::new(rc.clone(), 4)
        },
        )
    }

    pub fn build(x: x_Arg, scale: scale_Arg, offset: offset_Arg, mean: mean_Arg, variance: variance_Arg) -> Self {
        Self {
            phantom_T: PhantomData,
            x,
            scale,
            offset,
            mean,
            variance,
            epsilon: None,
            data_format: None,
            is_training: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(x: x_Arg, scale: scale_Arg, offset: offset_Arg, mean: mean_Arg, variance: variance_Arg) -> (Edge<T>, Edge<T>, Edge<T>, Edge<T>, Edge<T>) {
        Self {
            phantom_T: PhantomData,
            x,
            scale,
            offset,
            mean,
            variance,
            epsilon: None,
            data_format: None,
            is_training: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<T, input_Arg> GraphOperation for DebugIdentity<T, input_Arg>
where T: TensorType,
      T: Clone,
      input_Arg: Clone,
      input_Arg: GraphEdge<T>,
      input_Arg: 'static,
      T: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("DebugIdentity_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("DebugIdentity", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.input)?
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        {
            match self.device_name {
                None => new_op.set_attr_value_proto("device_name", &vec![18_u8, 0_u8,])?,
                Some(ref value) => (|attr| {new_op.set_attr_string("device_name", attr)})(&value)?,
            };
        }
        {
            match self.tensor_name {
                None => new_op.set_attr_value_proto("tensor_name", &vec![18_u8, 0_u8,])?,
                Some(ref value) => (|attr| {new_op.set_attr_string("tensor_name", attr)})(&value)?,
            };
        }
        {
            match self.debug_urls {
                None => new_op.set_attr_value_proto("debug_urls", &vec![10_u8, 0_u8,])?,
                Some(ref value) => (|attrs| {new_op.set_attr_string_list("debug_urls", attrs)})(&value)?,
            };
        }
        {
            match self.gated_grpc {
                None => new_op.set_attr_value_proto("gated_grpc", &vec![40_u8, 0_u8,])?,
                Some(ref value) => (|attr: &bool| {new_op.set_attr_bool("gated_grpc", *attr)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct DebugIdentity<T, input_Arg>
where T: TensorType,
      T: Clone,
      input_Arg: Clone,
      input_Arg: GraphEdge<T>,
      input_Arg: 'static,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    input: input_Arg,
    device_name: Option<String>,
    tensor_name: Option<String>,
    debug_urls: Option<Vec<String>>,
    gated_grpc: Option<bool>,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<T, input_Arg> DebugIdentity<T, input_Arg>
where T: TensorType,
      T: Clone,
      input_Arg: Clone,
      input_Arg: GraphEdge<T>,
      input_Arg: 'static,
      T: 'static,
{
    pub fn output(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn device_name(&mut self, device_name: &str) -> Self {
        self.device_name = Some(device_name.to_string());
        self.clone()
    }

    pub fn tensor_name(&mut self, tensor_name: &str) -> Self {
        self.tensor_name = Some(tensor_name.to_string());
        self.clone()
    }

    pub fn debug_urls(&mut self, debug_urls: &[String]) -> Self {
        self.debug_urls = Some(debug_urls.to_vec());
        self.clone()
    }

    pub fn gated_grpc(&mut self, gated_grpc: bool) -> Self {
        self.gated_grpc = Some(gated_grpc);
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(input: input_Arg) -> Self {
        Self {
            phantom_T: PhantomData,
            input,
            device_name: None,
            tensor_name: None,
            debug_urls: None,
            gated_grpc: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(input: input_Arg) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            input,
            device_name: None,
            tensor_name: None,
            debug_urls: None,
            gated_grpc: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<T, x_Arg, U, scale_Arg, offset_Arg, mean_Arg, variance_Arg> GraphOperation for FusedBatchNormV2<T, x_Arg, U, scale_Arg, offset_Arg, mean_Arg, variance_Arg>
where T: TensorType,
      T: Clone,
      x_Arg: Clone,
      x_Arg: GraphEdge<T>,
      x_Arg: 'static,
      U: TensorType,
      U: Clone,
      scale_Arg: Clone,
      scale_Arg: GraphEdge<U>,
      scale_Arg: 'static,
      offset_Arg: Clone,
      offset_Arg: GraphEdge<U>,
      offset_Arg: 'static,
      mean_Arg: Clone,
      mean_Arg: GraphEdge<U>,
      mean_Arg: 'static,
      variance_Arg: Clone,
      variance_Arg: GraphEdge<U>,
      variance_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_BFLOAT16_or_DT_HALF,
      T: 'static,
      U: con_or_DT_FLOAT,
      U: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("FusedBatchNormV2_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("FusedBatchNormV2", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.x)?
        }
        {
            new_op.add_edge(&self.scale)?
        }
        {
            new_op.add_edge(&self.offset)?
        }
        {
            new_op.add_edge(&self.mean)?
        }
        {
            new_op.add_edge(&self.variance)?
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        {
            new_op.set_attr_type("U", U::data_type())?;
        }
        {
            match self.epsilon {
                None => new_op.set_attr_value_proto("epsilon", &vec![37_u8, 23_u8, 183_u8, 209_u8, 56_u8,])?,
                Some(ref value) => (|attr: &f32| {new_op.set_attr_float("epsilon", *attr)})(&value)?,
            };
        }
        {
            match self.data_format {
                None => new_op.set_attr_value_proto("data_format", &vec![18_u8, 4_u8, 78_u8, 72_u8, 87_u8, 67_u8,])?,
                Some(ref value) => (|attr| {new_op.set_attr_string("data_format", attr)})(&value)?,
            };
        }
        {
            match self.is_training {
                None => new_op.set_attr_value_proto("is_training", &vec![40_u8, 1_u8,])?,
                Some(ref value) => (|attr: &bool| {new_op.set_attr_bool("is_training", *attr)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct FusedBatchNormV2<T, x_Arg, U, scale_Arg, offset_Arg, mean_Arg, variance_Arg>
where T: TensorType,
      T: Clone,
      x_Arg: Clone,
      x_Arg: GraphEdge<T>,
      x_Arg: 'static,
      U: TensorType,
      U: Clone,
      scale_Arg: Clone,
      scale_Arg: GraphEdge<U>,
      scale_Arg: 'static,
      offset_Arg: Clone,
      offset_Arg: GraphEdge<U>,
      offset_Arg: 'static,
      mean_Arg: Clone,
      mean_Arg: GraphEdge<U>,
      mean_Arg: 'static,
      variance_Arg: Clone,
      variance_Arg: GraphEdge<U>,
      variance_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_BFLOAT16_or_DT_HALF,
      T: 'static,
      U: con_or_DT_FLOAT,
      U: 'static,
{
    phantom_T: PhantomData<T>,
    x: x_Arg,
    phantom_U: PhantomData<U>,
    scale: scale_Arg,
    offset: offset_Arg,
    mean: mean_Arg,
    variance: variance_Arg,
    epsilon: Option<f32>,
    data_format: Option<String>,
    is_training: Option<bool>,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<T, x_Arg, U, scale_Arg, offset_Arg, mean_Arg, variance_Arg> FusedBatchNormV2<T, x_Arg, U, scale_Arg, offset_Arg, mean_Arg, variance_Arg>
where T: TensorType,
      T: Clone,
      x_Arg: Clone,
      x_Arg: GraphEdge<T>,
      x_Arg: 'static,
      U: TensorType,
      U: Clone,
      scale_Arg: Clone,
      scale_Arg: GraphEdge<U>,
      scale_Arg: 'static,
      offset_Arg: Clone,
      offset_Arg: GraphEdge<U>,
      offset_Arg: 'static,
      mean_Arg: Clone,
      mean_Arg: GraphEdge<U>,
      mean_Arg: 'static,
      variance_Arg: Clone,
      variance_Arg: GraphEdge<U>,
      variance_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_BFLOAT16_or_DT_HALF,
      T: 'static,
      U: con_or_DT_FLOAT,
      U: 'static,
{
    pub fn y(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn batch_mean(self) -> Edge<U> {
        let rc = Rc::new(self);
        {
            Edge::<U>::new(rc.clone(), 1)
        }
    }

    pub fn batch_variance(self) -> Edge<U> {
        let rc = Rc::new(self);
        {
            Edge::<U>::new(rc.clone(), 2)
        }
    }

    pub fn reserve_space_1(self) -> Edge<U> {
        let rc = Rc::new(self);
        {
            Edge::<U>::new(rc.clone(), 3)
        }
    }

    pub fn reserve_space_2(self) -> Edge<U> {
        let rc = Rc::new(self);
        {
            Edge::<U>::new(rc.clone(), 4)
        }
    }

    pub fn epsilon(&mut self, epsilon: f32) -> Self {
        self.epsilon = Some(epsilon);
        self.clone()
    }

    pub fn data_format(&mut self, data_format: &str) -> Self {
        self.data_format = Some(data_format.to_string());
        self.clone()
    }

    pub fn is_training(&mut self, is_training: bool) -> Self {
        self.is_training = Some(is_training);
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> (Edge<T>, Edge<U>, Edge<U>, Edge<U>, Edge<U>) {
        let rc = Rc::new(self);
        (
        {
            Edge::<T>::new(rc.clone(), 0)
        },
        {
            Edge::<U>::new(rc.clone(), 1)
        },
        {
            Edge::<U>::new(rc.clone(), 2)
        },
        {
            Edge::<U>::new(rc.clone(), 3)
        },
        {
            Edge::<U>::new(rc.clone(), 4)
        },
        )
    }

    pub fn build(x: x_Arg, scale: scale_Arg, offset: offset_Arg, mean: mean_Arg, variance: variance_Arg) -> Self {
        Self {
            phantom_T: PhantomData,
            x,
            phantom_U: PhantomData,
            scale,
            offset,
            mean,
            variance,
            epsilon: None,
            data_format: None,
            is_training: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(x: x_Arg, scale: scale_Arg, offset: offset_Arg, mean: mean_Arg, variance: variance_Arg) -> (Edge<T>, Edge<U>, Edge<U>, Edge<U>, Edge<U>) {
        Self {
            phantom_T: PhantomData,
            x,
            phantom_U: PhantomData,
            scale,
            offset,
            mean,
            variance,
            epsilon: None,
            data_format: None,
            is_training: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<T, x_Arg> GraphOperation for Cos<T, x_Arg>
where T: TensorType,
      T: Clone,
      x_Arg: Clone,
      x_Arg: GraphEdge<T>,
      x_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_COMPLEX64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF,
      T: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("Cos_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("Cos", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.x)?
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct Cos<T, x_Arg>
where T: TensorType,
      T: Clone,
      x_Arg: Clone,
      x_Arg: GraphEdge<T>,
      x_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_COMPLEX64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    x: x_Arg,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<T, x_Arg> Cos<T, x_Arg>
where T: TensorType,
      T: Clone,
      x_Arg: Clone,
      x_Arg: GraphEdge<T>,
      x_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_COMPLEX64_or_DT_BFLOAT16_or_DT_COMPLEX128_or_DT_HALF,
      T: 'static,
{
    pub fn y(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(x: x_Arg) -> Self {
        Self {
            phantom_T: PhantomData,
            x,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(x: x_Arg) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            x,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<T, y_backprop_Arg, x_Arg, scale_Arg, reserve_space_1_Arg, reserve_space_2_Arg> GraphOperation for FusedBatchNormGrad<T, y_backprop_Arg, x_Arg, scale_Arg, reserve_space_1_Arg, reserve_space_2_Arg>
where T: TensorType,
      T: Clone,
      y_backprop_Arg: Clone,
      y_backprop_Arg: GraphEdge<T>,
      y_backprop_Arg: 'static,
      x_Arg: Clone,
      x_Arg: GraphEdge<T>,
      x_Arg: 'static,
      scale_Arg: Clone,
      scale_Arg: GraphEdge<T>,
      scale_Arg: 'static,
      reserve_space_1_Arg: Clone,
      reserve_space_1_Arg: GraphEdge<T>,
      reserve_space_1_Arg: 'static,
      reserve_space_2_Arg: Clone,
      reserve_space_2_Arg: GraphEdge<T>,
      reserve_space_2_Arg: 'static,
      T: con_or_DT_FLOAT,
      T: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("FusedBatchNormGrad_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("FusedBatchNormGrad", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.y_backprop)?
        }
        {
            new_op.add_edge(&self.x)?
        }
        {
            new_op.add_edge(&self.scale)?
        }
        {
            new_op.add_edge(&self.reserve_space_1)?
        }
        {
            new_op.add_edge(&self.reserve_space_2)?
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        {
            match self.epsilon {
                None => new_op.set_attr_value_proto("epsilon", &vec![37_u8, 23_u8, 183_u8, 209_u8, 56_u8,])?,
                Some(ref value) => (|attr: &f32| {new_op.set_attr_float("epsilon", *attr)})(&value)?,
            };
        }
        {
            match self.data_format {
                None => new_op.set_attr_value_proto("data_format", &vec![18_u8, 4_u8, 78_u8, 72_u8, 87_u8, 67_u8,])?,
                Some(ref value) => (|attr| {new_op.set_attr_string("data_format", attr)})(&value)?,
            };
        }
        {
            match self.is_training {
                None => new_op.set_attr_value_proto("is_training", &vec![40_u8, 1_u8,])?,
                Some(ref value) => (|attr: &bool| {new_op.set_attr_bool("is_training", *attr)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct FusedBatchNormGrad<T, y_backprop_Arg, x_Arg, scale_Arg, reserve_space_1_Arg, reserve_space_2_Arg>
where T: TensorType,
      T: Clone,
      y_backprop_Arg: Clone,
      y_backprop_Arg: GraphEdge<T>,
      y_backprop_Arg: 'static,
      x_Arg: Clone,
      x_Arg: GraphEdge<T>,
      x_Arg: 'static,
      scale_Arg: Clone,
      scale_Arg: GraphEdge<T>,
      scale_Arg: 'static,
      reserve_space_1_Arg: Clone,
      reserve_space_1_Arg: GraphEdge<T>,
      reserve_space_1_Arg: 'static,
      reserve_space_2_Arg: Clone,
      reserve_space_2_Arg: GraphEdge<T>,
      reserve_space_2_Arg: 'static,
      T: con_or_DT_FLOAT,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    y_backprop: y_backprop_Arg,
    x: x_Arg,
    scale: scale_Arg,
    reserve_space_1: reserve_space_1_Arg,
    reserve_space_2: reserve_space_2_Arg,
    epsilon: Option<f32>,
    data_format: Option<String>,
    is_training: Option<bool>,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<T, y_backprop_Arg, x_Arg, scale_Arg, reserve_space_1_Arg, reserve_space_2_Arg> FusedBatchNormGrad<T, y_backprop_Arg, x_Arg, scale_Arg, reserve_space_1_Arg, reserve_space_2_Arg>
where T: TensorType,
      T: Clone,
      y_backprop_Arg: Clone,
      y_backprop_Arg: GraphEdge<T>,
      y_backprop_Arg: 'static,
      x_Arg: Clone,
      x_Arg: GraphEdge<T>,
      x_Arg: 'static,
      scale_Arg: Clone,
      scale_Arg: GraphEdge<T>,
      scale_Arg: 'static,
      reserve_space_1_Arg: Clone,
      reserve_space_1_Arg: GraphEdge<T>,
      reserve_space_1_Arg: 'static,
      reserve_space_2_Arg: Clone,
      reserve_space_2_Arg: GraphEdge<T>,
      reserve_space_2_Arg: 'static,
      T: con_or_DT_FLOAT,
      T: 'static,
{
    pub fn x_backprop(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn scale_backprop(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 1)
        }
    }

    pub fn offset_backprop(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 2)
        }
    }

    pub fn reserve_space_3(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 3)
        }
    }

    pub fn reserve_space_4(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 4)
        }
    }

    pub fn epsilon(&mut self, epsilon: f32) -> Self {
        self.epsilon = Some(epsilon);
        self.clone()
    }

    pub fn data_format(&mut self, data_format: &str) -> Self {
        self.data_format = Some(data_format.to_string());
        self.clone()
    }

    pub fn is_training(&mut self, is_training: bool) -> Self {
        self.is_training = Some(is_training);
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> (Edge<T>, Edge<T>, Edge<T>, Edge<T>, Edge<T>) {
        let rc = Rc::new(self);
        (
        {
            Edge::<T>::new(rc.clone(), 0)
        },
        {
            Edge::<T>::new(rc.clone(), 1)
        },
        {
            Edge::<T>::new(rc.clone(), 2)
        },
        {
            Edge::<T>::new(rc.clone(), 3)
        },
        {
            Edge::<T>::new(rc.clone(), 4)
        },
        )
    }

    pub fn build(y_backprop: y_backprop_Arg, x: x_Arg, scale: scale_Arg, reserve_space_1: reserve_space_1_Arg, reserve_space_2: reserve_space_2_Arg) -> Self {
        Self {
            phantom_T: PhantomData,
            y_backprop,
            x,
            scale,
            reserve_space_1,
            reserve_space_2,
            epsilon: None,
            data_format: None,
            is_training: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(y_backprop: y_backprop_Arg, x: x_Arg, scale: scale_Arg, reserve_space_1: reserve_space_1_Arg, reserve_space_2: reserve_space_2_Arg) -> (Edge<T>, Edge<T>, Edge<T>, Edge<T>, Edge<T>) {
        Self {
            phantom_T: PhantomData,
            y_backprop,
            x,
            scale,
            reserve_space_1,
            reserve_space_2,
            epsilon: None,
            data_format: None,
            is_training: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

pub trait con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_STRING_or_DT_COMPLEX64_or_DT_INT64_or_DT_BOOL_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_STRING_or_DT_COMPLEX64_or_DT_INT64_or_DT_BOOL_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF for BFloat16 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_STRING_or_DT_COMPLEX64_or_DT_INT64_or_DT_BOOL_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF for OtherComplex<f32> {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_STRING_or_DT_COMPLEX64_or_DT_INT64_or_DT_BOOL_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF for OtherComplex<f64> {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_STRING_or_DT_COMPLEX64_or_DT_INT64_or_DT_BOOL_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF for String {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_STRING_or_DT_COMPLEX64_or_DT_INT64_or_DT_BOOL_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF for bool {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_STRING_or_DT_COMPLEX64_or_DT_INT64_or_DT_BOOL_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF for f32 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_STRING_or_DT_COMPLEX64_or_DT_INT64_or_DT_BOOL_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF for f64 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_STRING_or_DT_COMPLEX64_or_DT_INT64_or_DT_BOOL_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF for i16 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_STRING_or_DT_COMPLEX64_or_DT_INT64_or_DT_BOOL_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF for i32 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_STRING_or_DT_COMPLEX64_or_DT_INT64_or_DT_BOOL_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF for i64 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_STRING_or_DT_COMPLEX64_or_DT_INT64_or_DT_BOOL_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF for i8 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_STRING_or_DT_COMPLEX64_or_DT_INT64_or_DT_BOOL_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF for u16 {
}

impl con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_STRING_or_DT_COMPLEX64_or_DT_INT64_or_DT_BOOL_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF for u8 {
}

impl<T, tensor_Arg, Tidx, axis_Arg> GraphOperation for ReverseV2<T, tensor_Arg, Tidx, axis_Arg>
where T: TensorType,
      T: Clone,
      tensor_Arg: Clone,
      tensor_Arg: GraphEdge<T>,
      tensor_Arg: 'static,
      Tidx: TensorType,
      Tidx: Clone,
      axis_Arg: Clone,
      axis_Arg: GraphEdge<Tidx>,
      axis_Arg: 'static,
      Tidx: con_or_DT_INT32_or_DT_INT64,
      Tidx: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_STRING_or_DT_COMPLEX64_or_DT_INT64_or_DT_BOOL_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF,
      T: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("ReverseV2_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("ReverseV2", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.tensor)?
        }
        {
            new_op.add_edge(&self.axis)?
        }
        {
            new_op.set_attr_type("Tidx", Tidx::data_type())?;
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct ReverseV2<T, tensor_Arg, Tidx, axis_Arg>
where T: TensorType,
      T: Clone,
      tensor_Arg: Clone,
      tensor_Arg: GraphEdge<T>,
      tensor_Arg: 'static,
      Tidx: TensorType,
      Tidx: Clone,
      axis_Arg: Clone,
      axis_Arg: GraphEdge<Tidx>,
      axis_Arg: 'static,
      Tidx: con_or_DT_INT32_or_DT_INT64,
      Tidx: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_STRING_or_DT_COMPLEX64_or_DT_INT64_or_DT_BOOL_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    tensor: tensor_Arg,
    phantom_Tidx: PhantomData<Tidx>,
    axis: axis_Arg,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<T, tensor_Arg, Tidx, axis_Arg> ReverseV2<T, tensor_Arg, Tidx, axis_Arg>
where T: TensorType,
      T: Clone,
      tensor_Arg: Clone,
      tensor_Arg: GraphEdge<T>,
      tensor_Arg: 'static,
      Tidx: TensorType,
      Tidx: Clone,
      axis_Arg: Clone,
      axis_Arg: GraphEdge<Tidx>,
      axis_Arg: 'static,
      Tidx: con_or_DT_INT32_or_DT_INT64,
      Tidx: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_STRING_or_DT_COMPLEX64_or_DT_INT64_or_DT_BOOL_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF,
      T: 'static,
{
    pub fn output(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(tensor: tensor_Arg, axis: axis_Arg) -> Self {
        Self {
            phantom_T: PhantomData,
            tensor,
            phantom_Tidx: PhantomData,
            axis,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(tensor: tensor_Arg, axis: axis_Arg) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            tensor,
            phantom_Tidx: PhantomData,
            axis,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<T, value_Arg, bias_Arg> GraphOperation for BiasAddV1<T, value_Arg, bias_Arg>
where T: TensorType,
      T: Clone,
      value_Arg: Clone,
      value_Arg: GraphEdge<T>,
      value_Arg: 'static,
      bias_Arg: Clone,
      bias_Arg: GraphEdge<T>,
      bias_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("BiasAddV1_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("BiasAddV1", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.value)?
        }
        {
            new_op.add_edge(&self.bias)?
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct BiasAddV1<T, value_Arg, bias_Arg>
where T: TensorType,
      T: Clone,
      value_Arg: Clone,
      value_Arg: GraphEdge<T>,
      value_Arg: 'static,
      bias_Arg: Clone,
      bias_Arg: GraphEdge<T>,
      bias_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    value: value_Arg,
    bias: bias_Arg,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<T, value_Arg, bias_Arg> BiasAddV1<T, value_Arg, bias_Arg>
where T: TensorType,
      T: Clone,
      value_Arg: Clone,
      value_Arg: GraphEdge<T>,
      value_Arg: 'static,
      bias_Arg: Clone,
      bias_Arg: GraphEdge<T>,
      bias_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_INT32_or_DT_UINT8_or_DT_INT16_or_DT_INT8_or_DT_COMPLEX64_or_DT_INT64_or_DT_QINT8_or_DT_QUINT8_or_DT_QINT32_or_DT_BFLOAT16_or_DT_UINT16_or_DT_COMPLEX128_or_DT_HALF_or_DT_UINT32_or_DT_UINT64,
      T: 'static,
{
    pub fn output(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(value: value_Arg, bias: bias_Arg) -> Self {
        Self {
            phantom_T: PhantomData,
            value,
            bias,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(value: value_Arg, bias: bias_Arg) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            value,
            bias,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<T, input_Arg, paddings_Arg, filter_Arg> GraphOperation for FusedPadConv2D<T, input_Arg, paddings_Arg, filter_Arg>
where T: TensorType,
      T: Clone,
      input_Arg: Clone,
      input_Arg: GraphEdge<T>,
      input_Arg: 'static,
      paddings_Arg: Clone,
      paddings_Arg: GraphEdge<i32>,
      paddings_Arg: 'static,
      filter_Arg: Clone,
      filter_Arg: GraphEdge<T>,
      filter_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_HALF,
      T: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("FusedPadConv2D_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("FusedPadConv2D", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.input)?
        }
        {
            new_op.add_edge(&self.paddings)?
        }
        {
            new_op.add_edge(&self.filter)?
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        {
            (|attr| {new_op.set_attr_string("mode", attr)})(&self.mode)?
        }
        {
            (|attrs| {new_op.set_attr_int_list("strides", attrs)})(&self.strides)?
        }
        {
            (|attr| {new_op.set_attr_string("padding", attr)})(&self.padding)?
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct FusedPadConv2D<T, input_Arg, paddings_Arg, filter_Arg>
where T: TensorType,
      T: Clone,
      input_Arg: Clone,
      input_Arg: GraphEdge<T>,
      input_Arg: 'static,
      paddings_Arg: Clone,
      paddings_Arg: GraphEdge<i32>,
      paddings_Arg: 'static,
      filter_Arg: Clone,
      filter_Arg: GraphEdge<T>,
      filter_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_HALF,
      T: 'static,
{
    phantom_T: PhantomData<T>,
    input: input_Arg,
    paddings: paddings_Arg,
    filter: filter_Arg,
    mode: String,
    strides: Vec<i64>,
    padding: String,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<T, input_Arg, paddings_Arg, filter_Arg> FusedPadConv2D<T, input_Arg, paddings_Arg, filter_Arg>
where T: TensorType,
      T: Clone,
      input_Arg: Clone,
      input_Arg: GraphEdge<T>,
      input_Arg: 'static,
      paddings_Arg: Clone,
      paddings_Arg: GraphEdge<i32>,
      paddings_Arg: 'static,
      filter_Arg: Clone,
      filter_Arg: GraphEdge<T>,
      filter_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_HALF,
      T: 'static,
{
    pub fn output(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(input: input_Arg, paddings: paddings_Arg, filter: filter_Arg, mode: &str, strides: &[i64], padding: &str) -> Self {
        Self {
            phantom_T: PhantomData,
            input,
            paddings,
            filter,
            mode: mode.to_string(),
            strides: strides.to_vec(),
            padding: padding.to_string(),
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(input: input_Arg, paddings: paddings_Arg, filter: filter_Arg, mode: &str, strides: &[i64], padding: &str) -> Edge<T> {
        Self {
            phantom_T: PhantomData,
            input,
            paddings,
            filter,
            mode: mode.to_string(),
            strides: strides.to_vec(),
            padding: padding.to_string(),
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<indices_Arg, T, data_Arg> GraphOperation for DynamicStitch<indices_Arg, T, data_Arg>
where indices_Arg: Clone,
      indices_Arg: GraphEdge<i32>,
      indices_Arg: 'static,
      T: TensorType,
      T: Clone,
      data_Arg: Clone,
      data_Arg: GraphEdge<T>,
      data_Arg: 'static,
      T: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("DynamicStitch_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("DynamicStitch", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.indices)?
        }
        {
            new_op.add_edge(&self.data)?
        }
        {
            (|attr: &i64| {new_op.set_attr_int("N", *attr)})(&self.N)?
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct DynamicStitch<indices_Arg, T, data_Arg>
where indices_Arg: Clone,
      indices_Arg: GraphEdge<i32>,
      indices_Arg: 'static,
      T: TensorType,
      T: Clone,
      data_Arg: Clone,
      data_Arg: GraphEdge<T>,
      data_Arg: 'static,
      T: 'static,
{
    indices: indices_Arg,
    phantom_T: PhantomData<T>,
    data: data_Arg,
    N: i64,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<indices_Arg, T, data_Arg> DynamicStitch<indices_Arg, T, data_Arg>
where indices_Arg: Clone,
      indices_Arg: GraphEdge<i32>,
      indices_Arg: 'static,
      T: TensorType,
      T: Clone,
      data_Arg: Clone,
      data_Arg: GraphEdge<T>,
      data_Arg: 'static,
      T: 'static,
{
    pub fn merged(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(indices: indices_Arg, data: data_Arg, N: i64) -> Self {
        Self {
            indices,
            phantom_T: PhantomData,
            data,
            N: N,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(indices: indices_Arg, data: data_Arg, N: i64) -> Edge<T> {
        Self {
            indices,
            phantom_T: PhantomData,
            data,
            N: N,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}

impl<input_sizes_Arg, T, filter_Arg, out_backprop_Arg> GraphOperation for Conv2DBackpropInput<input_sizes_Arg, T, filter_Arg, out_backprop_Arg>
where input_sizes_Arg: Clone,
      input_sizes_Arg: GraphEdge<i32>,
      input_sizes_Arg: 'static,
      T: TensorType,
      T: Clone,
      filter_Arg: Clone,
      filter_Arg: GraphEdge<T>,
      filter_Arg: 'static,
      out_backprop_Arg: Clone,
      out_backprop_Arg: GraphEdge<T>,
      out_backprop_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
      T: 'static,
{
    fn tf_operation(&self, graph: &mut Graph) -> Result<Operation> {
        if let Some(x) = graph.get_op_by_id(self.get_id()) {
            return Ok(x);
        }
        let op_name = match &self.op_name {
            Some(name) => name.clone(),
            None => graph.new_op_name("Conv2DBackpropInput_{}")?
        };
        let mut control_inputs = Vec::new();
        for control_input in self.control_inputs.iter() {
            control_inputs.push(control_input.tf_operation(graph)?);
        }
        let mut new_op = graph.new_operation("Conv2DBackpropInput", &op_name)?;
        for control_input in control_inputs {
            new_op.add_control_input(&control_input)
        }
        {
            new_op.add_edge(&self.input_sizes)?
        }
        {
            new_op.add_edge(&self.filter)?
        }
        {
            new_op.add_edge(&self.out_backprop)?
        }
        {
            new_op.set_attr_type("T", T::data_type())?;
        }
        {
            (|attrs| {new_op.set_attr_int_list("strides", attrs)})(&self.strides)?
        }
        {
            match self.use_cudnn_on_gpu {
                None => new_op.set_attr_value_proto("use_cudnn_on_gpu", &vec![40_u8, 1_u8,])?,
                Some(ref value) => (|attr: &bool| {new_op.set_attr_bool("use_cudnn_on_gpu", *attr)})(&value)?,
            };
        }
        {
            (|attr| {new_op.set_attr_string("padding", attr)})(&self.padding)?
        }
        {
            match self.data_format {
                None => new_op.set_attr_value_proto("data_format", &vec![18_u8, 4_u8, 78_u8, 72_u8, 87_u8, 67_u8,])?,
                Some(ref value) => (|attr| {new_op.set_attr_string("data_format", attr)})(&value)?,
            };
        }
        {
            match self.dilations {
                None => new_op.set_attr_value_proto("dilations", &vec![10_u8, 0_u8, 26_u8, 4_u8,])?,
                Some(ref value) => (|attrs| {new_op.set_attr_int_list("dilations", attrs)})(&value)?,
            };
        }
        let op = new_op.finish()?;
        graph.record_op(self.get_id(), op.clone());
        Ok(op)
    }
}

#[derive(Clone)]
pub struct Conv2DBackpropInput<input_sizes_Arg, T, filter_Arg, out_backprop_Arg>
where input_sizes_Arg: Clone,
      input_sizes_Arg: GraphEdge<i32>,
      input_sizes_Arg: 'static,
      T: TensorType,
      T: Clone,
      filter_Arg: Clone,
      filter_Arg: GraphEdge<T>,
      filter_Arg: 'static,
      out_backprop_Arg: Clone,
      out_backprop_Arg: GraphEdge<T>,
      out_backprop_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
      T: 'static,
{
    input_sizes: input_sizes_Arg,
    phantom_T: PhantomData<T>,
    filter: filter_Arg,
    out_backprop: out_backprop_Arg,
    strides: Vec<i64>,
    use_cudnn_on_gpu: Option<bool>,
    padding: String,
    data_format: Option<String>,
    dilations: Option<Vec<i64>>,
    op_name: Option<String>,
    control_inputs: Vec<Rc<dyn GraphOperation>>,
    id_: usize,
}

impl<input_sizes_Arg, T, filter_Arg, out_backprop_Arg> Conv2DBackpropInput<input_sizes_Arg, T, filter_Arg, out_backprop_Arg>
where input_sizes_Arg: Clone,
      input_sizes_Arg: GraphEdge<i32>,
      input_sizes_Arg: 'static,
      T: TensorType,
      T: Clone,
      filter_Arg: Clone,
      filter_Arg: GraphEdge<T>,
      filter_Arg: 'static,
      out_backprop_Arg: Clone,
      out_backprop_Arg: GraphEdge<T>,
      out_backprop_Arg: 'static,
      T: con_or_DT_FLOAT_or_DT_DOUBLE_or_DT_BFLOAT16_or_DT_HALF,
      T: 'static,
{
    pub fn output(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn use_cudnn_on_gpu(&mut self, use_cudnn_on_gpu: bool) -> Self {
        self.use_cudnn_on_gpu = Some(use_cudnn_on_gpu);
        self.clone()
    }

    pub fn data_format(&mut self, data_format: &str) -> Self {
        self.data_format = Some(data_format.to_string());
        self.clone()
    }

    pub fn dilations(&mut self, dilations: &[i64]) -> Self {
        self.dilations = Some(dilations.to_vec());
        self.clone()
    }

    pub fn op_name(&mut self, op_name: &str) -> &mut Self {
        self.op_name = Some(op_name.to_string());
        self
    }

    pub fn control_input<ControlInputT>(&mut self, control_input: ControlInputT) -> &mut Self
    where ControlInputT: GraphOperation,
          ControlInputT: Clone,
          ControlInputT: 'static,
    {
        self.control_inputs.push(Rc::new(control_input.clone()));
        self
    }

    fn get_id(&self) -> usize {
        self.id_
    }

    pub fn finish(self) -> Edge<T> {
        let rc = Rc::new(self);
        {
            Edge::<T>::new(rc.clone(), 0)
        }
    }

    pub fn build(input_sizes: input_sizes_Arg, filter: filter_Arg, out_backprop: out_backprop_Arg, strides: &[i64], padding: &str) -> Self {
        Self {
            input_sizes,
            phantom_T: PhantomData,
            filter,
            out_backprop,
            strides: strides.to_vec(),
            use_cudnn_on_gpu: None,
            padding: padding.to_string(),
            data_format: None,
            dilations: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }
    }

    pub fn new(input_sizes: input_sizes_Arg, filter: filter_Arg, out_backprop: out_backprop_Arg, strides: &[i64], padding: &str) -> Edge<T> {
        Self {
            input_sizes,
            phantom_T: PhantomData,
            filter,
            out_backprop,
            strides: strides.to_vec(),
            use_cudnn_on_gpu: None,
            padding: padding.to_string(),
            data_format: None,
            dilations: None,
            op_name: None,
            control_inputs: Vec::new(),
            id_: new_id(),
        }.finish()
    }
}